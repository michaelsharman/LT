import { a as appInstance, t as type, d as diagnostics, L as LT$1 } from "../core-UJe8vVmJ.js";
import { v as validateOptions$1, g as getTabsTheme } from "../index-2S-foDWA.js";
import { a as isObjectLike, b as baseGetTag, d as isObject$1, r as root, e as isFunction$1, f as isArrayLike, g as isIndex, h as isPrototype, j as arrayLikeKeys, o as overArg, i as isArray, k as keys$1, S as Symbol$1, l as baseUnary, n as nodeUtil, m as isBuffer, p as isTypedArray, c as copyArray, q as isArguments, s as setObserver } from "../keys-DsUdP_cB.js";
import { l as logger } from "../logger-BpyELtLr.js";
import { a as getDefaultExportFromCjs, c as commonjsGlobal } from "../_commonjsHelpers-BItOPCY9.js";
var symbolTag$3 = "[object Symbol]";
function isSymbol(le) {
  return typeof le == "symbol" || isObjectLike(le) && baseGetTag(le) == symbolTag$3;
}
var reWhitespace = /\s/;
function trimmedEndIndex(le) {
  for (var Y = le.length; Y-- && reWhitespace.test(le.charAt(Y)); )
    ;
  return Y;
}
var reTrimStart = /^\s+/;
function baseTrim(le) {
  return le && le.slice(0, trimmedEndIndex(le) + 1).replace(reTrimStart, "");
}
var NAN = NaN, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt;
function toNumber(le) {
  if (typeof le == "number")
    return le;
  if (isSymbol(le))
    return NAN;
  if (isObject$1(le)) {
    var Y = typeof le.valueOf == "function" ? le.valueOf() : le;
    le = isObject$1(Y) ? Y + "" : Y;
  }
  if (typeof le != "string")
    return le === 0 ? le : +le;
  le = baseTrim(le);
  var re = reIsBinary.test(le);
  return re || reIsOctal.test(le) ? freeParseInt(le.slice(2), re ? 2 : 8) : reIsBadHex.test(le) ? NAN : +le;
}
function identity$1(le) {
  return le;
}
var coreJsData = root["__core-js_shared__"], maskSrcKey = function() {
  var le = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return le ? "Symbol(src)_1." + le : "";
}();
function isMasked(le) {
  return !!maskSrcKey && maskSrcKey in le;
}
var funcProto$2 = Function.prototype, funcToString$2 = funcProto$2.toString;
function toSource(le) {
  if (le != null) {
    try {
      return funcToString$2.call(le);
    } catch {
    }
    try {
      return le + "";
    } catch {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto$1 = Function.prototype, objectProto$9 = Object.prototype, funcToString$1 = funcProto$1.toString, hasOwnProperty$9 = objectProto$9.hasOwnProperty, reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(le) {
  if (!isObject$1(le) || isMasked(le))
    return !1;
  var Y = isFunction$1(le) ? reIsNative : reIsHostCtor;
  return Y.test(toSource(le));
}
function getValue(le, Y) {
  return le?.[Y];
}
function getNative(le, Y) {
  var re = getValue(le, Y);
  return baseIsNative(re) ? re : void 0;
}
var WeakMap$1 = getNative(root, "WeakMap"), objectCreate = Object.create, baseCreate = /* @__PURE__ */ function() {
  function le() {
  }
  return function(Y) {
    if (!isObject$1(Y))
      return {};
    if (objectCreate)
      return objectCreate(Y);
    le.prototype = Y;
    var re = new le();
    return le.prototype = void 0, re;
  };
}();
function apply(le, Y, re) {
  switch (re.length) {
    case 0:
      return le.call(Y);
    case 1:
      return le.call(Y, re[0]);
    case 2:
      return le.call(Y, re[0], re[1]);
    case 3:
      return le.call(Y, re[0], re[1], re[2]);
  }
  return le.apply(Y, re);
}
var HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
function shortOut(le) {
  var Y = 0, re = 0;
  return function() {
    var oe = nativeNow(), ue = HOT_SPAN - (oe - re);
    if (re = oe, ue > 0) {
      if (++Y >= HOT_COUNT)
        return arguments[0];
    } else
      Y = 0;
    return le.apply(void 0, arguments);
  };
}
function constant(le) {
  return function() {
    return le;
  };
}
var defineProperty = function() {
  try {
    var le = getNative(Object, "defineProperty");
    return le({}, "", {}), le;
  } catch {
  }
}(), baseSetToString = defineProperty ? function(le, Y) {
  return defineProperty(le, "toString", {
    configurable: !0,
    enumerable: !1,
    value: constant(Y),
    writable: !0
  });
} : identity$1, setToString = shortOut(baseSetToString);
function arrayEach(le, Y) {
  for (var re = -1, oe = le == null ? 0 : le.length; ++re < oe && Y(le[re], re, le) !== !1; )
    ;
  return le;
}
function baseAssignValue(le, Y, re) {
  Y == "__proto__" && defineProperty ? defineProperty(le, Y, {
    configurable: !0,
    enumerable: !0,
    value: re,
    writable: !0
  }) : le[Y] = re;
}
function eq(le, Y) {
  return le === Y || le !== le && Y !== Y;
}
var objectProto$8 = Object.prototype, hasOwnProperty$8 = objectProto$8.hasOwnProperty;
function assignValue(le, Y, re) {
  var oe = le[Y];
  (!(hasOwnProperty$8.call(le, Y) && eq(oe, re)) || re === void 0 && !(Y in le)) && baseAssignValue(le, Y, re);
}
function copyObject(le, Y, re, oe) {
  var ue = !re;
  re || (re = {});
  for (var fe = -1, he = Y.length; ++fe < he; ) {
    var _e = Y[fe], ve = void 0;
    ve === void 0 && (ve = le[_e]), ue ? baseAssignValue(re, _e, ve) : assignValue(re, _e, ve);
  }
  return re;
}
var nativeMax$1 = Math.max;
function overRest(le, Y, re) {
  return Y = nativeMax$1(Y === void 0 ? le.length - 1 : Y, 0), function() {
    for (var oe = arguments, ue = -1, fe = nativeMax$1(oe.length - Y, 0), he = Array(fe); ++ue < fe; )
      he[ue] = oe[Y + ue];
    ue = -1;
    for (var _e = Array(Y + 1); ++ue < Y; )
      _e[ue] = oe[ue];
    return _e[Y] = re(he), apply(le, this, _e);
  };
}
function baseRest(le, Y) {
  return setToString(overRest(le, Y, identity$1), le + "");
}
function isIterateeCall(le, Y, re) {
  if (!isObject$1(re))
    return !1;
  var oe = typeof Y;
  return (oe == "number" ? isArrayLike(re) && isIndex(Y, re.length) : oe == "string" && Y in re) ? eq(re[Y], le) : !1;
}
function createAssigner(le) {
  return baseRest(function(Y, re) {
    var oe = -1, ue = re.length, fe = ue > 1 ? re[ue - 1] : void 0, he = ue > 2 ? re[2] : void 0;
    for (fe = le.length > 3 && typeof fe == "function" ? (ue--, fe) : void 0, he && isIterateeCall(re[0], re[1], he) && (fe = ue < 3 ? void 0 : fe, ue = 1), Y = Object(Y); ++oe < ue; ) {
      var _e = re[oe];
      _e && le(Y, _e, oe, fe);
    }
    return Y;
  });
}
function nativeKeysIn(le) {
  var Y = [];
  if (le != null)
    for (var re in Object(le))
      Y.push(re);
  return Y;
}
var objectProto$7 = Object.prototype, hasOwnProperty$7 = objectProto$7.hasOwnProperty;
function baseKeysIn(le) {
  if (!isObject$1(le))
    return nativeKeysIn(le);
  var Y = isPrototype(le), re = [];
  for (var oe in le)
    oe == "constructor" && (Y || !hasOwnProperty$7.call(le, oe)) || re.push(oe);
  return re;
}
function keysIn(le) {
  return isArrayLike(le) ? arrayLikeKeys(le, !0) : baseKeysIn(le);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
}
function hashDelete(le) {
  var Y = this.has(le) && delete this.__data__[le];
  return this.size -= Y ? 1 : 0, Y;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__", objectProto$6 = Object.prototype, hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function hashGet(le) {
  var Y = this.__data__;
  if (nativeCreate) {
    var re = Y[le];
    return re === HASH_UNDEFINED$2 ? void 0 : re;
  }
  return hasOwnProperty$6.call(Y, le) ? Y[le] : void 0;
}
var objectProto$5 = Object.prototype, hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function hashHas(le) {
  var Y = this.__data__;
  return nativeCreate ? Y[le] !== void 0 : hasOwnProperty$5.call(Y, le);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(le, Y) {
  var re = this.__data__;
  return this.size += this.has(le) ? 0 : 1, re[le] = nativeCreate && Y === void 0 ? HASH_UNDEFINED$1 : Y, this;
}
function Hash(le) {
  var Y = -1, re = le == null ? 0 : le.length;
  for (this.clear(); ++Y < re; ) {
    var oe = le[Y];
    this.set(oe[0], oe[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [], this.size = 0;
}
function assocIndexOf(le, Y) {
  for (var re = le.length; re--; )
    if (eq(le[re][0], Y))
      return re;
  return -1;
}
var arrayProto = Array.prototype, splice = arrayProto.splice;
function listCacheDelete(le) {
  var Y = this.__data__, re = assocIndexOf(Y, le);
  if (re < 0)
    return !1;
  var oe = Y.length - 1;
  return re == oe ? Y.pop() : splice.call(Y, re, 1), --this.size, !0;
}
function listCacheGet(le) {
  var Y = this.__data__, re = assocIndexOf(Y, le);
  return re < 0 ? void 0 : Y[re][1];
}
function listCacheHas(le) {
  return assocIndexOf(this.__data__, le) > -1;
}
function listCacheSet(le, Y) {
  var re = this.__data__, oe = assocIndexOf(re, le);
  return oe < 0 ? (++this.size, re.push([le, Y])) : re[oe][1] = Y, this;
}
function ListCache(le) {
  var Y = -1, re = le == null ? 0 : le.length;
  for (this.clear(); ++Y < re; ) {
    var oe = le[Y];
    this.set(oe[0], oe[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0, this.__data__ = {
    hash: new Hash(),
    map: new (Map$1 || ListCache)(),
    string: new Hash()
  };
}
function isKeyable(le) {
  var Y = typeof le;
  return Y == "string" || Y == "number" || Y == "symbol" || Y == "boolean" ? le !== "__proto__" : le === null;
}
function getMapData(le, Y) {
  var re = le.__data__;
  return isKeyable(Y) ? re[typeof Y == "string" ? "string" : "hash"] : re.map;
}
function mapCacheDelete(le) {
  var Y = getMapData(this, le).delete(le);
  return this.size -= Y ? 1 : 0, Y;
}
function mapCacheGet(le) {
  return getMapData(this, le).get(le);
}
function mapCacheHas(le) {
  return getMapData(this, le).has(le);
}
function mapCacheSet(le, Y) {
  var re = getMapData(this, le), oe = re.size;
  return re.set(le, Y), this.size += re.size == oe ? 0 : 1, this;
}
function MapCache(le) {
  var Y = -1, re = le == null ? 0 : le.length;
  for (this.clear(); ++Y < re; ) {
    var oe = le[Y];
    this.set(oe[0], oe[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function arrayPush(le, Y) {
  for (var re = -1, oe = Y.length, ue = le.length; ++re < oe; )
    le[ue + re] = Y[re];
  return le;
}
var getPrototype = overArg(Object.getPrototypeOf, Object), objectTag$3 = "[object Object]", funcProto = Function.prototype, objectProto$4 = Object.prototype, funcToString = funcProto.toString, hasOwnProperty$4 = objectProto$4.hasOwnProperty, objectCtorString = funcToString.call(Object);
function isPlainObject$1(le) {
  if (!isObjectLike(le) || baseGetTag(le) != objectTag$3)
    return !1;
  var Y = getPrototype(le);
  if (Y === null)
    return !0;
  var re = hasOwnProperty$4.call(Y, "constructor") && Y.constructor;
  return typeof re == "function" && re instanceof re && funcToString.call(re) == objectCtorString;
}
function stackClear() {
  this.__data__ = new ListCache(), this.size = 0;
}
function stackDelete(le) {
  var Y = this.__data__, re = Y.delete(le);
  return this.size = Y.size, re;
}
function stackGet(le) {
  return this.__data__.get(le);
}
function stackHas(le) {
  return this.__data__.has(le);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(le, Y) {
  var re = this.__data__;
  if (re instanceof ListCache) {
    var oe = re.__data__;
    if (!Map$1 || oe.length < LARGE_ARRAY_SIZE - 1)
      return oe.push([le, Y]), this.size = ++re.size, this;
    re = this.__data__ = new MapCache(oe);
  }
  return re.set(le, Y), this.size = re.size, this;
}
function Stack(le) {
  var Y = this.__data__ = new ListCache(le);
  this.size = Y.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, Buffer$1 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(le, Y) {
  if (Y)
    return le.slice();
  var re = le.length, oe = allocUnsafe ? allocUnsafe(re) : new le.constructor(re);
  return le.copy(oe), oe;
}
function arrayFilter(le, Y) {
  for (var re = -1, oe = le == null ? 0 : le.length, ue = 0, fe = []; ++re < oe; ) {
    var he = le[re];
    Y(he, re, le) && (fe[ue++] = he);
  }
  return fe;
}
function stubArray() {
  return [];
}
var objectProto$3 = Object.prototype, propertyIsEnumerable = objectProto$3.propertyIsEnumerable, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols ? function(le) {
  return le == null ? [] : (le = Object(le), arrayFilter(nativeGetSymbols(le), function(Y) {
    return propertyIsEnumerable.call(le, Y);
  }));
} : stubArray;
function baseGetAllKeys(le, Y, re) {
  var oe = Y(le);
  return isArray(le) ? oe : arrayPush(oe, re(le));
}
function getAllKeys(le) {
  return baseGetAllKeys(le, keys$1, getSymbols);
}
var DataView$1 = getNative(root, "DataView"), Promise$1 = getNative(root, "Promise"), Set$1 = getNative(root, "Set"), mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]", dataViewTag$3 = "[object DataView]", dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1), getTag = baseGetTag;
(DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) && (getTag = function(le) {
  var Y = baseGetTag(le), re = Y == objectTag$2 ? le.constructor : void 0, oe = re ? toSource(re) : "";
  if (oe)
    switch (oe) {
      case dataViewCtorString:
        return dataViewTag$3;
      case mapCtorString:
        return mapTag$4;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag$4;
      case weakMapCtorString:
        return weakMapTag$1;
    }
  return Y;
});
var objectProto$2 = Object.prototype, hasOwnProperty$3 = objectProto$2.hasOwnProperty;
function initCloneArray(le) {
  var Y = le.length, re = new le.constructor(Y);
  return Y && typeof le[0] == "string" && hasOwnProperty$3.call(le, "index") && (re.index = le.index, re.input = le.input), re;
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(le) {
  var Y = new le.constructor(le.byteLength);
  return new Uint8Array$1(Y).set(new Uint8Array$1(le)), Y;
}
function cloneDataView(le, Y) {
  var re = cloneArrayBuffer(le.buffer);
  return new le.constructor(re, le.byteOffset, le.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(le) {
  var Y = new le.constructor(le.source, reFlags.exec(le));
  return Y.lastIndex = le.lastIndex, Y;
}
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(le) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(le)) : {};
}
function cloneTypedArray(le, Y) {
  var re = Y ? cloneArrayBuffer(le.buffer) : le.buffer;
  return new le.constructor(re, le.byteOffset, le.length);
}
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]", arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(le, Y, re) {
  var oe = le.constructor;
  switch (Y) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(le);
    case boolTag$2:
    case dateTag$2:
      return new oe(+le);
    case dataViewTag$2:
      return cloneDataView(le);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(le, re);
    case mapTag$3:
      return new oe();
    case numberTag$2:
    case stringTag$2:
      return new oe(le);
    case regexpTag$2:
      return cloneRegExp(le);
    case setTag$3:
      return new oe();
    case symbolTag$2:
      return cloneSymbol(le);
  }
}
function initCloneObject(le) {
  return typeof le.constructor == "function" && !isPrototype(le) ? baseCreate(getPrototype(le)) : {};
}
var mapTag$2 = "[object Map]";
function baseIsMap(le) {
  return isObjectLike(le) && getTag(le) == mapTag$2;
}
var nodeIsMap = nodeUtil && nodeUtil.isMap, isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap, setTag$2 = "[object Set]";
function baseIsSet(le) {
  return isObjectLike(le) && getTag(le) == setTag$2;
}
var nodeIsSet = nodeUtil && nodeUtil.isSet, isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, CLONE_DEEP_FLAG$1 = 1, argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
function baseClone(le, Y, re, oe, ue, fe) {
  var he, _e = Y & CLONE_DEEP_FLAG$1;
  if (he !== void 0)
    return he;
  if (!isObject$1(le))
    return le;
  var ve = isArray(le);
  if (ve)
    he = initCloneArray(le);
  else {
    var xe = getTag(le), Ee = xe == funcTag || xe == genTag;
    if (isBuffer(le))
      return cloneBuffer(le, _e);
    if (xe == objectTag$1 || xe == argsTag$1 || Ee && !ue)
      he = Ee ? {} : initCloneObject(le);
    else {
      if (!cloneableTags[xe])
        return ue ? le : {};
      he = initCloneByTag(le, xe, _e);
    }
  }
  fe || (fe = new Stack());
  var Se = fe.get(le);
  if (Se)
    return Se;
  fe.set(le, he), isSet(le) ? le.forEach(function(Ie) {
    he.add(baseClone(Ie, Y, re, Ie, le, fe));
  }) : isMap(le) && le.forEach(function(Ie, Ne) {
    he.set(Ne, baseClone(Ie, Y, re, Ne, le, fe));
  });
  var Te = getAllKeys, Ce = ve ? void 0 : Te(le);
  return arrayEach(Ce || le, function(Ie, Ne) {
    Ce && (Ne = Ie, Ie = le[Ne]), assignValue(he, Ne, baseClone(Ie, Y, re, Ne, le, fe));
  }), he;
}
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(le) {
  return baseClone(le, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(le) {
  return this.__data__.set(le, HASH_UNDEFINED), this;
}
function setCacheHas(le) {
  return this.__data__.has(le);
}
function SetCache(le) {
  var Y = -1, re = le == null ? 0 : le.length;
  for (this.__data__ = new MapCache(); ++Y < re; )
    this.add(le[Y]);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(le, Y) {
  for (var re = -1, oe = le == null ? 0 : le.length; ++re < oe; )
    if (Y(le[re], re, le))
      return !0;
  return !1;
}
function cacheHas(le, Y) {
  return le.has(Y);
}
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays(le, Y, re, oe, ue, fe) {
  var he = re & COMPARE_PARTIAL_FLAG$3, _e = le.length, ve = Y.length;
  if (_e != ve && !(he && ve > _e))
    return !1;
  var xe = fe.get(le), Ee = fe.get(Y);
  if (xe && Ee)
    return xe == Y && Ee == le;
  var Se = -1, Te = !0, Ce = re & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  for (fe.set(le, Y), fe.set(Y, le); ++Se < _e; ) {
    var Ie = le[Se], Ne = Y[Se];
    if (oe)
      var Re = he ? oe(Ne, Ie, Se, Y, le, fe) : oe(Ie, Ne, Se, le, Y, fe);
    if (Re !== void 0) {
      if (Re)
        continue;
      Te = !1;
      break;
    }
    if (Ce) {
      if (!arraySome(Y, function(Ae, Pe) {
        if (!cacheHas(Ce, Pe) && (Ie === Ae || ue(Ie, Ae, re, oe, fe)))
          return Ce.push(Pe);
      })) {
        Te = !1;
        break;
      }
    } else if (!(Ie === Ne || ue(Ie, Ne, re, oe, fe))) {
      Te = !1;
      break;
    }
  }
  return fe.delete(le), fe.delete(Y), Te;
}
function mapToArray(le) {
  var Y = -1, re = Array(le.size);
  return le.forEach(function(oe, ue) {
    re[++Y] = [ue, oe];
  }), re;
}
function setToArray(le) {
  var Y = -1, re = Array(le.size);
  return le.forEach(function(oe) {
    re[++Y] = oe;
  }), re;
}
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2, boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(le, Y, re, oe, ue, fe, he) {
  switch (re) {
    case dataViewTag:
      if (le.byteLength != Y.byteLength || le.byteOffset != Y.byteOffset)
        return !1;
      le = le.buffer, Y = Y.buffer;
    case arrayBufferTag:
      return !(le.byteLength != Y.byteLength || !fe(new Uint8Array$1(le), new Uint8Array$1(Y)));
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+le, +Y);
    case errorTag:
      return le.name == Y.name && le.message == Y.message;
    case regexpTag:
    case stringTag:
      return le == Y + "";
    case mapTag:
      var _e = mapToArray;
    case setTag:
      var ve = oe & COMPARE_PARTIAL_FLAG$2;
      if (_e || (_e = setToArray), le.size != Y.size && !ve)
        return !1;
      var xe = he.get(le);
      if (xe)
        return xe == Y;
      oe |= COMPARE_UNORDERED_FLAG, he.set(le, Y);
      var Ee = equalArrays(_e(le), _e(Y), oe, ue, fe, he);
      return he.delete(le), Ee;
    case symbolTag:
      if (symbolValueOf)
        return symbolValueOf.call(le) == symbolValueOf.call(Y);
  }
  return !1;
}
var COMPARE_PARTIAL_FLAG$1 = 1, objectProto$1 = Object.prototype, hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function equalObjects(le, Y, re, oe, ue, fe) {
  var he = re & COMPARE_PARTIAL_FLAG$1, _e = getAllKeys(le), ve = _e.length, xe = getAllKeys(Y), Ee = xe.length;
  if (ve != Ee && !he)
    return !1;
  for (var Se = ve; Se--; ) {
    var Te = _e[Se];
    if (!(he ? Te in Y : hasOwnProperty$2.call(Y, Te)))
      return !1;
  }
  var Ce = fe.get(le), Ie = fe.get(Y);
  if (Ce && Ie)
    return Ce == Y && Ie == le;
  var Ne = !0;
  fe.set(le, Y), fe.set(Y, le);
  for (var Re = he; ++Se < ve; ) {
    Te = _e[Se];
    var Ae = le[Te], Pe = Y[Te];
    if (oe)
      var Fe = he ? oe(Pe, Ae, Te, Y, le, fe) : oe(Ae, Pe, Te, le, Y, fe);
    if (!(Fe === void 0 ? Ae === Pe || ue(Ae, Pe, re, oe, fe) : Fe)) {
      Ne = !1;
      break;
    }
    Re || (Re = Te == "constructor");
  }
  if (Ne && !Re) {
    var Le = le.constructor, He = Y.constructor;
    Le != He && "constructor" in le && "constructor" in Y && !(typeof Le == "function" && Le instanceof Le && typeof He == "function" && He instanceof He) && (Ne = !1);
  }
  return fe.delete(le), fe.delete(Y), Ne;
}
var COMPARE_PARTIAL_FLAG = 1, argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]", objectProto = Object.prototype, hasOwnProperty$1 = objectProto.hasOwnProperty;
function baseIsEqualDeep(le, Y, re, oe, ue, fe) {
  var he = isArray(le), _e = isArray(Y), ve = he ? arrayTag : getTag(le), xe = _e ? arrayTag : getTag(Y);
  ve = ve == argsTag ? objectTag : ve, xe = xe == argsTag ? objectTag : xe;
  var Ee = ve == objectTag, Se = xe == objectTag, Te = ve == xe;
  if (Te && isBuffer(le)) {
    if (!isBuffer(Y))
      return !1;
    he = !0, Ee = !1;
  }
  if (Te && !Ee)
    return fe || (fe = new Stack()), he || isTypedArray(le) ? equalArrays(le, Y, re, oe, ue, fe) : equalByTag(le, Y, ve, re, oe, ue, fe);
  if (!(re & COMPARE_PARTIAL_FLAG)) {
    var Ce = Ee && hasOwnProperty$1.call(le, "__wrapped__"), Ie = Se && hasOwnProperty$1.call(Y, "__wrapped__");
    if (Ce || Ie) {
      var Ne = Ce ? le.value() : le, Re = Ie ? Y.value() : Y;
      return fe || (fe = new Stack()), ue(Ne, Re, re, oe, fe);
    }
  }
  return Te ? (fe || (fe = new Stack()), equalObjects(le, Y, re, oe, ue, fe)) : !1;
}
function baseIsEqual(le, Y, re, oe, ue) {
  return le === Y ? !0 : le == null || Y == null || !isObjectLike(le) && !isObjectLike(Y) ? le !== le && Y !== Y : baseIsEqualDeep(le, Y, re, oe, baseIsEqual, ue);
}
function createBaseFor(le) {
  return function(Y, re, oe) {
    for (var ue = -1, fe = Object(Y), he = oe(Y), _e = he.length; _e--; ) {
      var ve = he[++ue];
      if (re(fe[ve], ve, fe) === !1)
        break;
    }
    return Y;
  };
}
var baseFor = createBaseFor(), now = function() {
  return root.Date.now();
}, FUNC_ERROR_TEXT = "Expected a function", nativeMax = Math.max, nativeMin = Math.min;
function debounce$2(le, Y, re) {
  var oe, ue, fe, he, _e, ve, xe = 0, Ee = !1, Se = !1, Te = !0;
  if (typeof le != "function")
    throw new TypeError(FUNC_ERROR_TEXT);
  Y = toNumber(Y) || 0, isObject$1(re) && (Ee = !!re.leading, Se = "maxWait" in re, fe = Se ? nativeMax(toNumber(re.maxWait) || 0, Y) : fe, Te = "trailing" in re ? !!re.trailing : Te);
  function Ce(Ge) {
    var Ve = oe, $e = ue;
    return oe = ue = void 0, xe = Ge, he = le.apply($e, Ve), he;
  }
  function Ie(Ge) {
    return xe = Ge, _e = setTimeout(Ae, Y), Ee ? Ce(Ge) : he;
  }
  function Ne(Ge) {
    var Ve = Ge - ve, $e = Ge - xe, De = Y - Ve;
    return Se ? nativeMin(De, fe - $e) : De;
  }
  function Re(Ge) {
    var Ve = Ge - ve, $e = Ge - xe;
    return ve === void 0 || Ve >= Y || Ve < 0 || Se && $e >= fe;
  }
  function Ae() {
    var Ge = now();
    if (Re(Ge))
      return Pe(Ge);
    _e = setTimeout(Ae, Ne(Ge));
  }
  function Pe(Ge) {
    return _e = void 0, Te && oe ? Ce(Ge) : (oe = ue = void 0, he);
  }
  function Fe() {
    _e !== void 0 && clearTimeout(_e), xe = 0, oe = ve = ue = _e = void 0;
  }
  function Le() {
    return _e === void 0 ? he : Pe(now());
  }
  function He() {
    var Ge = now(), Ve = Re(Ge);
    if (oe = arguments, ue = this, ve = Ge, Ve) {
      if (_e === void 0)
        return Ie(ve);
      if (Se)
        return clearTimeout(_e), _e = setTimeout(Ae, Y), Ce(ve);
    }
    return _e === void 0 && (_e = setTimeout(Ae, Y)), he;
  }
  return He.cancel = Fe, He.flush = Le, He;
}
function assignMergeValue(le, Y, re) {
  (re !== void 0 && !eq(le[Y], re) || re === void 0 && !(Y in le)) && baseAssignValue(le, Y, re);
}
function isArrayLikeObject(le) {
  return isObjectLike(le) && isArrayLike(le);
}
function safeGet(le, Y) {
  if (!(Y === "constructor" && typeof le[Y] == "function") && Y != "__proto__")
    return le[Y];
}
function toPlainObject(le) {
  return copyObject(le, keysIn(le));
}
function baseMergeDeep(le, Y, re, oe, ue, fe, he) {
  var _e = safeGet(le, re), ve = safeGet(Y, re), xe = he.get(ve);
  if (xe) {
    assignMergeValue(le, re, xe);
    return;
  }
  var Ee = fe ? fe(_e, ve, re + "", le, Y, he) : void 0, Se = Ee === void 0;
  if (Se) {
    var Te = isArray(ve), Ce = !Te && isBuffer(ve), Ie = !Te && !Ce && isTypedArray(ve);
    Ee = ve, Te || Ce || Ie ? isArray(_e) ? Ee = _e : isArrayLikeObject(_e) ? Ee = copyArray(_e) : Ce ? (Se = !1, Ee = cloneBuffer(ve, !0)) : Ie ? (Se = !1, Ee = cloneTypedArray(ve, !0)) : Ee = [] : isPlainObject$1(ve) || isArguments(ve) ? (Ee = _e, isArguments(_e) ? Ee = toPlainObject(_e) : (!isObject$1(_e) || isFunction$1(_e)) && (Ee = initCloneObject(ve))) : Se = !1;
  }
  Se && (he.set(ve, Ee), ue(Ee, ve, oe, fe, he), he.delete(ve)), assignMergeValue(le, re, Ee);
}
function baseMerge(le, Y, re, oe, ue) {
  le !== Y && baseFor(Y, function(fe, he) {
    if (ue || (ue = new Stack()), isObject$1(fe))
      baseMergeDeep(le, Y, he, re, baseMerge, oe, ue);
    else {
      var _e = oe ? oe(safeGet(le, he), fe, he + "", le, Y, ue) : void 0;
      _e === void 0 && (_e = fe), assignMergeValue(le, he, _e);
    }
  }, keysIn);
}
function baseGt(le, Y) {
  return le > Y;
}
function isEqual$2(le, Y) {
  return baseIsEqual(le, Y);
}
function baseExtremum(le, Y, re) {
  for (var oe = -1, ue = le.length; ++oe < ue; ) {
    var fe = le[oe], he = Y(fe);
    if (he != null && (_e === void 0 ? he === he && !isSymbol(he) : re(he, _e)))
      var _e = he, ve = fe;
  }
  return ve;
}
function max(le) {
  return le && le.length ? baseExtremum(le, identity$1, baseGt) : void 0;
}
var merge = createAssigner(function(le, Y, re) {
  baseMerge(le, Y, re);
});
const state$a = {
  events: {
    keydownRegistered: !1
  },
  options: {
    theme: "default",
    maxTabs: 5
  },
  renderedCss: !1
};
function run$a(le) {
  state$a.options = validateOptions$1(le), state$a.renderedCss || injectCSS$8(), document.querySelector(".lrn-author").classList.add("lt__contenttabs"), appInstance().on("widgetedit:editor:ready", () => {
    document.removeEventListener("keydown", handleKeydown), state$a.events.keydownRegistered = !1;
  }), appInstance().on("widgetedit:preview:changed", preventDOMBreaking);
}
function addContentTabs(le, Y) {
  const re = `
    <div class="lrn-qe lrn-qe-modal" style="display: block;" id="lt__addTabs">
        <div class="lrn-qe-ui">
            <div class="lrn-qe-modal-dialog">
                <div class="lrn-qe-modal-dialog-inner">
                    <div class="lrn-qe-modal-header">
                        <div class="lrn-qe-form-label lrn-qe-h4 lrn-qe-section-header">
                            <h4 class="lrn-qe-heading"><label class="lrn-qe-label lrn-qe-form-label-name">Choose number of tabs</label></h4>
                        </div>
                        <button type="button" class="lrn-qe-btn lrn-qe-modal-btn-close" aria-label="Close" tabindex="0">
                            <span class="lrn-qe-sr-only">Close</span>
                            <span aria-role="presentation" class="lrn-qe-i-cross"></span>
                        </button>
                    </div>
                    <div data-lrn-qe-selector="modal-outlet">
                        <div class="lrn-qe-modal-content" data-lrn-qe-modal-section="content">
                            <div class="lrn-qe-edit-aria-label">
                                <div class="lrn-qe-form-group-wrapper">
                                    <label class="lrn-qe-label lrn-qe-form-label" for="numtabs">Number of tabs</label>
                                    <input class="lrn-qe-input lrn-qe-form-control" type="number" id="numtabs" value="2" min="1" max="${state$a.options.maxTabs}" required>
                                </div>
                            </div>
                        </div>
                        <div class="lrn-qe-modal-footer">
                            <ul class="lrn-qe-ul">
                                <li class="lrn-qe-li lrn-qe-modal-footer-item">
                                    <button type="button" class="lrn-qe-btn lrn-qe-btn-default"><span>Cancel</span></button>
                                </li>&nbsp;
                                <li class="lrn-qe-li lrn-qe-modal-footer-item">
                                    <button type="button" class="lrn-qe-btn lrn-qe-btn-primary" data-lrn-qe-modal-action="confirm"><span>Add tabs</span></button>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    `;
  document.querySelector(".learnosity-question-editor").insertAdjacentHTML("beforeEnd", re);
  const oe = [];
  oe.push(document.querySelector("#lt__addTabs .lrn-qe-btn-default")), oe.push(document.querySelector("#lt__addTabs .lrn-qe-modal-btn-close"));
  for (let fe = 0; fe < oe.length; fe++)
    oe[fe].addEventListener("click", () => (removeElement$1("lt__addTabs"), Y("")));
  document.querySelector("#lt__addTabs .lrn-qe-btn-primary").addEventListener("click", () => {
    const fe = document.getElementById("numtabs").value;
    return removeElement$1("lt__addTabs"), Y(getTabsTemplate(fe));
  });
}
function preventDOMBreaking() {
  document.querySelectorAll(".lrn-qe-col-edit-inner .lt__nav-tabs li a").forEach((Y) => {
    Y.setAttribute("title", ""), Y.setAttribute("contenteditable", "false"), Y.addEventListener("focus", (re) => re.target.blur()), Y.addEventListener("dblclick", (re) => {
      re.preventDefault();
      const oe = window.prompt("Edit tab label:", Y.textContent);
      oe !== null && (Y.textContent = oe);
    });
  });
  const le = document.querySelector(".lrn-qe-col-edit-inner .lt__tab-content");
  le && (le.querySelectorAll(".lrn-qe-col-edit-inner .lt__tab-pane").forEach((Y) => {
    if (!Y.querySelector(".lt__guard")) {
      const re = document.createElement("p");
      re.className = "lt__guard", re.setAttribute("contenteditable", "false"), re.setAttribute("aria-hidden", "true"), re.setAttribute("tabindex", "-1"), re.innerHTML = "&#8204;", Y.insertBefore(re, Y.firstChild);
    }
  }), state$a.events.keydownRegistered || (document.addEventListener("keydown", handleKeydown), state$a.events.keydownRegistered = !0));
}
function handleKeydown(le) {
  if (le.key === "Backspace" && !!getCkeEditableContainer()?.querySelector(".lt__tabs")) {
    const re = document.querySelector(".lrn-qe-col-edit-inner .lt__tab-content"), oe = getCaretCharOffset(), ue = re.querySelector(".lt__tab-pane.active");
    if (oe === 0) {
      const fe = window.getSelection();
      if (!(!fe.isCollapsed && fe.toString().length > 0) && (le.preventDefault(), ue.firstChild)) {
        const ve = document.createTextNode("​");
        ue.appendChild(ve);
        const xe = document.createRange();
        xe.setStart(ve, ve.textContent.length), xe.collapse(!0);
        const Ee = window.getSelection();
        Ee.removeAllRanges(), Ee.addRange(xe);
      }
    }
  }
}
function getCaretCharOffset() {
  const le = window.getSelection();
  if (!le.rangeCount)
    return 0;
  const Y = le.getRangeAt(0);
  let re = Y.startContainer.nodeType === Node.TEXT_NODE ? Y.startContainer : Y.startContainer.firstChild;
  if (!re)
    return 0;
  let oe = Y.startOffset;
  for (; re && re.previousSibling; )
    re = re.previousSibling, oe += re.textContent.length;
  return oe;
}
function getCkeEditableContainer() {
  const le = window.getSelection();
  if (!le.rangeCount)
    return null;
  let Y = le.getRangeAt(0).startContainer;
  return Y.nodeType !== Node.ELEMENT_NODE && (Y = Y.parentElement), Y.closest(".cke_editable");
}
function getTabsTemplate(le) {
  let Y = '<div class="tabs lt__tabs"><ul class="nav nav-tabs lt__nav-tabs" role="tablist">', re = ' class="active"', oe = " active";
  const ue = "_" + generateRandomString$1();
  for (let fe = 1; fe <= le; fe++)
    Y += `<li role="presentation"${re} aria-controls="${fe}${ue}"><a role="tab" data-tab-target="[data-tab-id='${fe}${ue}']" data-toggle="tab" href="#">Tab ${fe}</a></li>`, fe === 1 && (re = "");
  Y += '</ul><div class="tab-content lt__tab-content">';
  for (let fe = 1; fe <= le; fe++)
    Y += `<div class="tab-pane lt__tab-pane${oe}" data-tab-id="${fe}${ue}" id="${fe}${ue}"><p>Tab ${fe} content</p></div>`, fe === 1 && (oe = "");
  return Y += "</div></div>", Y;
}
function generateRandomString$1() {
  return Math.floor(Math.random() * Date.now()).toString(36);
}
function removeElement$1(le) {
  document.getElementById(le).remove();
}
function injectCSS$8() {
  const le = document.createElement("style"), Y = getTabsTheme(state$a.options.theme).concat(
    `
`,
    `/* Learnosity content tab authoring styles */
        .lrn.lrn-author .lrn-author-item-content-wrapper .lrn-qe-col-edit-inner {
            .lt__tabs.nav-tabs>li>a,
            .lt__tabs.nav-tabs>li>a:focus,
            .lt__tabs.nav-tabs>li.active>a,
            .lt__tabs.nav-tabs>li.active>a:hover,
            .lt__tabs.nav-tabs>li.active>a:focus {
                cursor: pointer;
            }

            .lrn-qe-form-el-wrapper .lt__tabs.nav-tabs>li>a {
                position: relative; /* Needed so that the pseudo-element is positioned relative to the <a> */
                cursor: pointer;
            }

            .lt__tabs .lt__nav-tabs {
                overflow: visible;
                border-bottom: 1px solid transparent;

                > li > a {
                    overflow: visible;
                }
            }

            /* Tooltip text */
            .lt__nav-tabs.nav-tabs > li > a::after {
                content: "Double‑click to edit label";
                position: absolute;
                bottom: 65%;
                left: 110%;
                transform: translateX(-50%);
                background-color: rgba(0, 0, 0, 0.8);
                color: #fff;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 12px;
                white-space: nowrap;
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
                pointer-events: none;
                z-index: 100;
                display: block; /* Ensure block-level display */
            }

            /* Tooltip arrow */
            .lt__nav-tabs.nav-tabs > li > a::before {
                content: "";
                position: absolute;
                display: block; /* Ensure it shows up */
                bottom: calc(120% - 5px); /* Adjust so the arrow is just below the tooltip */
                left: 85%;
                bottom: calc(65% - 5px);
                transform: translateX(-50%);
                width: 0;
                height: 0;
                border-left: 5px solid transparent;
                border-right: 5px solid transparent;
                border-top: 5px solid rgba(0, 0, 0, 0.8);
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
                pointer-events: none;
                z-index: 100;
            }

            /* Show tooltip on hover */
            .lt__nav-tabs.nav-tabs > li > a:hover::after,
            .lt__nav-tabs.nav-tabs > li > a:hover::before {
                opacity: 1;
                visibility: visible;
            }
        }
    `
  );
  le.setAttribute("data-style", "LT Content Tabs"), le.textContent = Y, document.head.append(le), state$a.renderedCss = !0;
}
const contentTabs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addContentTabs,
  run: run$a
}, Symbol.toStringTag, { value: "Module" })), state$9 = {
  renderedCss: !1
};
function run$9() {
  state$9.renderedCss || injectCSS$7(), setTimeout(() => {
    le();
  }, 1500), appInstance().on("navigate", le);
  function le() {
    setTimeout(() => {
      appInstance().getLocation().route === "items/:reference/settings/:tab" && setup$2();
    }, 300);
  }
}
function setup$2() {
  const le = document.querySelector('[data-authorapi-selector="tag-search-input"]'), Y = document.querySelector(".lrn-author-tag-suggestion-list");
  le && le.addEventListener("input", debounce$2(re, 750));
  function re() {
    const oe = Y.querySelector("li.lrn-author-tag-no-suggestions");
    oe && showCreateTagsUI(oe);
  }
}
function showCreateTagsUI(le) {
  const Y = le.querySelector(".lt__createTagsContainer"), re = document.querySelector(".lt__error");
  Y || le.insertAdjacentHTML("beforeend", `
        <div class="lt__createTagsContainer">
            <span class="lt__error hidden">
                <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24">
                    <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 13V8m0 8h.01M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"/>
                </svg>
                <span class="lt__errorMessage">Invalid format. Use [type]:[name]</span>
            </span>
            <button type="button" id="lt__createTagsBtn" class="lt__btn lrn-author-btn lrn-author-btn-primary lds-btn lds-btn-primary lds-btn-sm">Create</button>
        </div>

    `), re && re.classList.add("hidden"), document.getElementById("lt__createTagsBtn").addEventListener("click", createTag);
}
function createTag() {
  const le = document.querySelector('[data-authorapi-selector="tag-search-input"]'), Y = document.querySelector(".lt__error"), re = appInstance().getItemTags(), oe = le.value;
  if (checkTagSyntax(oe)) {
    const ue = oe.split(":").map((fe) => fe.trim());
    if (validateTag(re, { type: ue[0], name: ue[1] }))
      re.push({ type: ue[0], name: ue[1] }), appInstance().setItemTags(re);
    else {
      const fe = Y.querySelector(".lt__errorMessage");
      fe.textContent = "Tag already exists", Y.classList.remove("hidden");
    }
  } else
    Y.classList.remove("hidden");
}
function validateTag(le, Y) {
  const re = (ue) => JSON.stringify(ue) === JSON.stringify(Y);
  return !(le.length && le.some(re));
}
function checkTagSyntax(le) {
  return /^[^:\s]+:\s*\S+$/.test(le);
}
function injectCSS$7() {
  const le = document.createElement("style"), Y = `
/* Learnosity create tags styles */
.lt__createTagsContainer {
    position: relative;
    top: -21px;
    float: right;
    font-size: 85%;
    height: 1px;
}
:is(#lds, body) .lds-btn.lt__btn {
    font-size: 115%;
}
.lt__error {
    color: #dd002f;
    padding-right: 2px;

    svg {
        vertical-align: middle;
    }
}
.lrn.lrn-author .lrn-author-api-react-container .lrn-author-settings-tag-search span.lt__errorMessage {
    margin-left: 0;
}
`;
  le.setAttribute("data-style", "LT Create Tags"), le.textContent = Y, document.head.append(le), state$9.renderedCss = !0;
}
const createTags = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  run: run$9
}, Symbol.toStringTag, { value: "Module" }));
class GenericElementUtils {
  static hideElements(...Y) {
    Y.forEach((re) => re.style.display = "none");
  }
  static getStyleWidth(Y, re) {
    return Number.parseFloat(Y.style[re]) || 0;
  }
  static doesElementExistInDom(Y) {
    return !!Y.parentElement;
  }
  static isFirstChildInParent(Y) {
    var re;
    return ((re = Y.parentElement) == null ? void 0 : re.firstChild) === Y;
  }
}
GenericElementUtils.NOT_SELECTABLE_CLASS = "not-selectable";
class SVGIconUtils {
  // REF-10
  static createSVGElement(Y) {
    return new DOMParser().parseFromString(Y, "image/svg+xml").documentElement;
  }
}
SVGIconUtils.WHITE_FILTER = `brightness(0) saturate(100%) invert(100%) sepia(1%) saturate(3877%)
    hue-rotate(184deg) brightness(103%) contrast(100%)`;
SVGIconUtils.LIGHT_GREY_FILTER = `brightness(0) saturate(100%) invert(68%) sepia(0%) saturate(317%)
    hue-rotate(84deg) brightness(92%) contrast(93%)`;
SVGIconUtils.HEADER_FILTER = `brightness(0) saturate(100%) invert(34%) sepia(0%) saturate(1075%)
    hue-rotate(211deg) brightness(96%) contrast(90%)`;
SVGIconUtils.DROPDOWN_ITEM_FILTER = `brightness(0) saturate(100%) invert(7%) sepia(23%) saturate(258%)
    hue-rotate(63deg) brightness(99%) contrast(97%)`;
class StaticDropdown {
}
StaticDropdown.DROPDOWN_CLASS = "static-dropdown";
StaticDropdown.ITEM_CLASS = "static-dropdown-item";
StaticDropdown.ACTIVE_ITEM_CLASS = "active-static-dropdown-item";
const _DropdownItemHighlightUtils = class $i {
  // Accepted behaviour - fadeFocused is triggered twice when moving to a different item
  static fadeCurrentlyHighlighted(Y) {
    const re = Y.dropdownItem;
    re && (re.classList.contains(StaticDropdown.ACTIVE_ITEM_CLASS) && re.classList.remove(StaticDropdown.ACTIVE_ITEM_CLASS), re.style.backgroundColor = "", delete Y.dropdownItem);
  }
  static highlightNew(Y, re) {
    $i.fadeCurrentlyHighlighted(Y), re.focus(), Y.dropdownItem = re, re.classList.contains(StaticDropdown.ITEM_CLASS) ? re.classList.add(StaticDropdown.ACTIVE_ITEM_CLASS) : re.classList.contains(DropdownItem.DROPDOWN_INPUT_CLASS) || (re.style.backgroundColor = $i.HOVER_BACKGROUND_COLOR);
  }
};
_DropdownItemHighlightUtils.HOVER_BACKGROUND_COLOR = "#eaeaea";
let DropdownItemHighlightUtils = _DropdownItemHighlightUtils;
class DropdownItemEvents {
  // prettier-ignore
  static addItemEvents(Y, re) {
    re.addEventListener(
      "mouseenter",
      DropdownItemHighlightUtils.highlightNew.bind(this, Y, re)
    ), re.addEventListener(
      "mouseleave",
      DropdownItemHighlightUtils.fadeCurrentlyHighlighted.bind(this, Y)
    );
  }
}
const _DropdownItem = class fr {
  static toggleItem(Y, re) {
    Y.style.display = re ? fr.DISPLAY : fr.HIDDEN;
  }
  static isDisplayed(Y) {
    return Y.style.display === fr.DISPLAY;
  }
  static createDropdownItemBaseElement(Y) {
    const re = document.createElement(Y);
    return re.classList.add(fr.DROPDOWN_ITEM_IDENTIFIER), re;
  }
  static createItem(Y) {
    const re = fr.createDropdownItemBaseElement("div");
    return Y && (re.tabIndex = Y.children.length), re.classList.add(fr.DROPDOWN_ITEM_CLASS, GenericElementUtils.NOT_SELECTABLE_CLASS), re;
  }
  // no need to sanitize paste as input element already does it
  static addInputItem(Y, re) {
    const oe = fr.createItem(re);
    oe.classList.add(fr.DROPDOWN_INPUT_ITEM_CLASS);
    const ue = fr.createDropdownItemBaseElement("input");
    ue.classList.add(fr.DROPDOWN_INPUT_CLASS), oe.appendChild(ue), re.appendChild(oe), DropdownItemEvents.addItemEvents(Y._activeOverlayElements, ue);
  }
  // REF-10
  static insertIcon(Y, re) {
    const { svgString: oe, containerStyles: ue } = re, fe = document.createElement("div");
    fe.classList.add(fr.DROPDOWN_ITEM_ICON_CONTAINER_CLASS), Object.assign(fe.style, ue?.dropdown);
    const he = SVGIconUtils.createSVGElement(oe);
    he.style.filter = SVGIconUtils.DROPDOWN_ITEM_FILTER, fe.appendChild(he), Y.insertBefore(fe, Y.children[0]);
  }
  static addPlaneButtonItem(Y, re, oe) {
    const ue = fr.createItem(Y), fe = fr.createDropdownItemBaseElement("div");
    return fe.innerText = re || fr.DROPDOWN_ITEM_EMPTY_PLACEHOLDER_TEXT, re.trim() === "" && fe.classList.add(fr.DROPDOWN_ITEM_EMPTY_CLASS), ue.append(fe), Y && (oe !== void 0 && Y.children[oe] ? Y.insertBefore(ue, Y.children[oe]) : Y.appendChild(ue)), ue;
  }
  // prettier-ignore
  static createButtonItemNoEvents(Y, re, ...oe) {
    const ue = fr.addPlaneButtonItem(Y, re.text);
    return re.iconSettings && fr.insertIcon(ue, re.iconSettings), oe.length > 0 && ue.classList.add(...oe), ue;
  }
  static addTitle(Y, re) {
    const oe = fr.createDropdownItemBaseElement("div");
    oe.classList.add(fr.DROPDOWN_ITEM_CLASS, fr.DROPDOWN_TITLE_ITEM_CLASS), oe.innerText = re, Y.appendChild(oe);
  }
  static addDivider(Y) {
    const re = fr.createDropdownItemBaseElement("div");
    re.classList.add(fr.DROPDOWN_ITEM_DIVIDER_CLASS), Y.appendChild(re);
  }
  // prettier-ignore
  static addButtonItem(Y, re, oe, ...ue) {
    const fe = fr.createButtonItemNoEvents(re, oe, ...ue);
    return DropdownItemEvents.addItemEvents(Y._activeOverlayElements, fe), fe;
  }
  // prettier-ignore
  static addNewButtonItems(Y, re, oe) {
    return oe.map((ue) => fr.addButtonItem(Y, re, ue));
  }
  static addButtonItemElements(Y, re, oe) {
    oe.forEach((ue) => {
      ue.tabIndex = re.children.length, re.appendChild(ue), DropdownItemEvents.addItemEvents(Y._activeOverlayElements, ue);
    });
  }
  static removeItems(Y) {
    Array.from(Y.children).forEach((re) => re.remove());
  }
  static doesElementContainItemClass(Y) {
    return Y.classList.contains(fr.DROPDOWN_ITEM_IDENTIFIER);
  }
  static doesElementContainInputClass(Y) {
    return Y.classList.contains(fr.DROPDOWN_INPUT_CLASS);
  }
  static getInputElement(Y) {
    return Y.getElementsByClassName(fr.DROPDOWN_INPUT_ITEM_CLASS)[0];
  }
  static toggleUsability(Y, re) {
    const oe = Y.children[0];
    re ? (Y.classList.remove(fr.DISABLED_ITEM_CLASS), oe.style.filter = "") : (Y.classList.add(fr.DISABLED_ITEM_CLASS), oe.style.filter = SVGIconUtils.LIGHT_GREY_FILTER);
  }
};
_DropdownItem.DROPDOWN_ITEM_CLASS = "dropdown-item";
_DropdownItem.DISABLED_ITEM_CLASS = "dropdown-disabled-item";
_DropdownItem.ACTIVE_ITEM_CLASS = "active-dropdown-item";
_DropdownItem.DROPDOWN_INPUT_CLASS = "dropdown-input";
_DropdownItem.DROPDOWN_ITEM_ICON_CONTAINER_CLASS = "dropdown-item-icon-container";
_DropdownItem.DROPDOWN_INPUT_ITEM_CLASS = "dropdown-input-item";
_DropdownItem.DROPDOWN_TITLE_ITEM_CLASS = "dropdown-title-item";
_DropdownItem.DROPDOWN_ITEM_DIVIDER_CLASS = "dropdown-item-divider";
_DropdownItem.DROPDOWN_ITEM_EMPTY_CLASS = "dropdown-item-empty";
_DropdownItem.DROPDOWN_ITEM_EMPTY_PLACEHOLDER_TEXT = "...";
_DropdownItem.DROPDOWN_ITEM_IDENTIFIER = "dropdown-item-identifier";
_DropdownItem.HIDDEN = "none";
_DropdownItem.DISPLAY = "";
let DropdownItem = _DropdownItem;
class OuterDropdownItem {
  static unsetHoverColors(Y) {
    Y.forEach((re) => re.style.backgroundColor = "");
  }
  static unsetActiveItem(Y) {
    const re = Y.getElementsByClassName(DropdownItem.ACTIVE_ITEM_CLASS)[0];
    re?.classList.remove(DropdownItem.ACTIVE_ITEM_CLASS);
  }
  static setActive(Y, re) {
    const oe = Y.find((ue) => ue.innerText === re);
    oe?.classList.add(DropdownItem.ACTIVE_ITEM_CLASS);
  }
  static setActiveByIndex(Y, re) {
    Y[re].classList.add(DropdownItem.ACTIVE_ITEM_CLASS);
  }
}
class ElementStyle {
  static setStyle(Y, re, oe) {
    Y.style[re] = oe;
  }
  // prettier-ignore
  static moveStyles(Y, re, ...oe) {
    oe.forEach((ue) => {
      Y.style[ue] && ElementStyle.setStyle(re, ue, Y.style[ue]);
    });
  }
  static unsetStyle(Y, re) {
    const oe = Object.keys(re).reduce((ue, fe) => (ue[fe] = "", ue), {});
    Object.assign(Y.style, oe);
  }
  static unsetAllCSSStates(Y, re) {
    re.click && ElementStyle.unsetStyle(Y, re.click), re.hover && ElementStyle.unsetStyle(Y, re.hover), re.default && ElementStyle.unsetStyle(Y, re.default);
  }
  static generateStatefulCSS(Y, re, oe) {
    const ue = Y.default || {}, fe = Object.assign(JSON.parse(JSON.stringify({ ...ue, ...re })), Y?.hover), he = Object.assign(JSON.parse(JSON.stringify({ ...fe, ...oe })), Y?.click);
    return { default: ue, hover: fe, click: he };
  }
}
const _ToggleableElement = class Yr {
  static set(Y, re) {
    Y.classList.add(Yr.ACTIVE_BUTTON_CLASS), Object.assign(Y.style, re);
  }
  static unset(Y, re) {
    Y.classList.remove(Yr.ACTIVE_BUTTON_CLASS), ElementStyle.unsetStyle(Y, re);
  }
  static toggleActive(Y, re) {
    const oe = !!Y.classList.contains(Yr.ACTIVE_BUTTON_CLASS);
    return oe ? (Yr.unset(Y, re), Y.dispatchEvent(new MouseEvent("mouseenter"))) : Yr.set(Y, re), oe;
  }
  static unsetActive(Y, re) {
    Y.classList.contains(Yr.ACTIVE_BUTTON_CLASS) && (Yr.unset(Y, re), Y.dispatchEvent(new MouseEvent("mouseleave")));
  }
  static setActive(Y, re) {
    Y.classList.contains(Yr.ACTIVE_BUTTON_CLASS) || Yr.set(Y, re);
  }
};
_ToggleableElement.ACTIVE_BUTTON_CLASS = "toggleable-button-active";
_ToggleableElement.AUTO_STYLING_CLASS = "toggleable-button-auto-styling";
let ToggleableElement = _ToggleableElement;
const _Dropdown = class na {
  static createBase() {
    const Y = document.createElement("div");
    return Y.classList.add(na.DROPDOWN_CLASS), Y.style.width = `${na.DROPDOWN_WIDTH}px`, Y.style.paddingTop = na.DROPDOWN_VERTICAL_PX, Y.style.paddingBottom = na.DROPDOWN_VERTICAL_PX, na.hide(Y), Y;
  }
  static isDisplayed(Y) {
    return Y?.style.display === na.CSS_DISPLAY_VISIBLE;
  }
  static display(...Y) {
    Y.forEach((re) => {
      re.style.display = na.CSS_DISPLAY_VISIBLE;
    });
  }
  static hide(...Y) {
    GenericElementUtils.hideElements(...Y);
  }
  static isPartOfDropdownElement(Y) {
    return Y.classList.contains(na.DROPDOWN_CLASS) || DropdownItem.doesElementContainItemClass(Y);
  }
};
_Dropdown.DROPDOWN_CLASS = "active-table-dropdown";
_Dropdown.CSS_DISPLAY_VISIBLE = "grid";
_Dropdown.DROPDOWN_WIDTH = 176;
_Dropdown.DROPDOWN_VERTICAL_PX = "4px";
let Dropdown = _Dropdown;
const _OuterDropdownButtonEvents = class Ia {
  static mouseClickButton(Y, re, oe) {
    const { element: ue } = re;
    ue.classList.contains(Ia.DO_NOT_DISPLAY_DROPDOWN_CLASS) ? ue.classList.remove(Ia.DO_NOT_DISPLAY_DROPDOWN_CLASS) : oe(Y, re);
  }
  static mouseDownButton(Y) {
    const { element: re, button: oe, activeButtonStyle: ue } = Y;
    Dropdown.isDisplayed(re) && (re.classList.add(Ia.DO_NOT_DISPLAY_DROPDOWN_CLASS), ToggleableElement.unsetActive(oe, ue));
  }
  static getDisplayFunc(Y) {
    return Y.startsWith("top") ? OuterDropdownElement.display : OuterDropdownElement.displayReactToBottomVisibility;
  }
  // prettier-ignore
  static set(Y, re, oe, ue, fe) {
    const he = fe || Ia.getDisplayFunc(oe);
    re.addEventListener("mousedown", Ia.mouseDownButton.bind(this, ue)), re.addEventListener(
      "click",
      Ia.mouseClickButton.bind(this, Y, ue, he)
    );
  }
};
_OuterDropdownButtonEvents.DO_NOT_DISPLAY_DROPDOWN_CLASS = "do-not-display-class";
let OuterDropdownButtonEvents = _OuterDropdownButtonEvents;
const VH = "vh", VW = "vw";
class LITElementTypeConverters {
  static convertToBoolean(le) {
    return typeof le == "string" ? le === "true" : !!le;
  }
  static convertToFunction(value) {
    if (typeof value == "function")
      return value;
    if (typeof value == "string") {
      const evaluatedExpression = eval(value);
      if (typeof evaluatedExpression == "function")
        return evaluatedExpression;
    }
    return () => {
    };
  }
}
class ObjectUtils {
  static createTwoWayObject(Y) {
    return Object.keys(Y).forEach((re) => {
      Y[Y[re]] = re;
    }), Y;
  }
  static convertStringToFunction(Y, re) {
    typeof Y[re] == "string" && (Y[re] = LITElementTypeConverters.convertToFunction(
      Y[re]
    ));
  }
  // method to check if value is not nullish
  static areValuesFullyDefined(...Y) {
    return Y.findIndex((re) => re == null) === -1;
  }
  static removeProperties(Y, ...re) {
    re.forEach((oe) => {
      delete Y[oe];
    });
  }
}
class RegexUtils {
  static extractIntegerStrs(Y) {
    return Y.match(/\d+/g);
  }
  static extractFloatStrs(Y) {
    return Y.match(/-?\d+(\.\d+)?$/g);
  }
}
class StringDimensionUtils {
  static processDimension(Y, re) {
    return Y < re ? re : Y;
  }
  // prettier-ignore
  static processPercentageDimension(Y, re, oe, ue) {
    re > 100 && (re = 100);
    const fe = (oe ? Y.getBoundingClientRect().width : Y.offsetHeight) * (re / 100);
    return { number: StringDimensionUtils.processDimension(fe, ue), isPercentage: !0 };
  }
  // can also parse numbers incase the client used that
  // if this returns a number 0 for a %, the likelyhood is that the parent element does not have that dimension set
  // prettier-ignore
  static generateNumberDimensionFromClientString(Y, re, oe, ue, fe = 0) {
    const he = re[oe], _e = typeof he == "string";
    let ve = _e ? Number(RegexUtils.extractIntegerStrs(he)[0]) : he;
    if (_e) {
      if (he.includes("%"))
        return StringDimensionUtils.processPercentageDimension(Y, ve, ue, fe);
      he.includes(VH) ? ve = window.innerHeight * (ve / 100) : he.includes(VW) && (ve = window.innerWidth * (ve / 100));
    }
    return { number: StringDimensionUtils.processDimension(ve, fe), isPercentage: !1 };
  }
  static removeAllDimensions(Y) {
    if (Y)
      return ObjectUtils.removeProperties(Y, "width", "minWidth", "maxWidth", "height", "minHeight", "maxHeight"), Y;
  }
}
class PageButtonStyle {
  // prettier-ignore
  static unsetAllCSSStates(Y, re, oe) {
    ElementStyle.unsetAllCSSStates(Y, re[oe]);
  }
  static unsetAll(Y, re, oe) {
    Y.classList.contains(re.activeButtonClass) ? PageButtonStyle.unsetAllCSSStates(Y, re, "activeButton") : Y.classList.contains(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS) ? ElementStyle.unsetStyle(Y, re.disabledButtons) : PageButtonStyle.unsetAllCSSStates(Y, re, oe ? "actionButtons" : "buttons");
  }
  static setDefault(Y, re, oe) {
    PageButtonStyle.unsetAll(Y, re, oe), oe ? Object.assign(Y.style, re.actionButtons.default) : Object.assign(Y.style, re.buttons.default);
  }
  // prettier-ignore
  static setActive(Y, re, oe) {
    oe && (PageButtonStyle.unsetAllCSSStates(oe, re, "activeButton"), Object.assign(oe.style, re.buttons.default)), Y.classList.contains(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS) ? ElementStyle.unsetStyle(Y, re.disabledButtons) : PageButtonStyle.unsetAllCSSStates(Y, re, "buttons"), Object.assign(Y.style, re.activeButton.default);
  }
  static setDisabled(Y, re, oe) {
    PageButtonStyle.setDefault(Y, re, oe), Object.assign(Y.style, re.disabledButtons);
  }
  static mouseDown(Y, re, oe) {
    Y.classList.contains(re.activeButtonClass) ? Object.assign(Y.style, re.activeButton.click) : oe ? Object.assign(Y.style, re.actionButtons.click) : Object.assign(Y.style, re.buttons.click), PaginationVisibleButtonsUtils.overrideOnMouseEvent(Y, re);
  }
  static mouseEnter(Y, re, oe) {
    Y.classList.contains(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS) || (Y.classList.contains(re.activeButtonClass) ? (PageButtonStyle.unsetAllCSSStates(Y, re, "activeButton"), Object.assign(Y.style, re.activeButton.default), Object.assign(Y.style, re.activeButton.hover)) : (PageButtonStyle.setDefault(Y, re, oe), oe ? Object.assign(Y.style, re.actionButtons.hover) : Object.assign(Y.style, re.buttons.hover)), PaginationVisibleButtonsUtils.overrideOnMouseEvent(Y, re));
  }
  static mouseLeave(Y, re, oe) {
    Y.classList.contains(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS) || (Y.classList.contains(re.activeButtonClass) ? (PageButtonStyle.unsetAll(Y, re, !1), Object.assign(Y.style, re.activeButton.default)) : PageButtonStyle.setDefault(Y, re, oe), PaginationVisibleButtonsUtils.overrideOnMouseEvent(Y, re));
  }
}
const _FilterInputElement = class Fa {
  static setPlaceholder(Y, re, oe) {
    if (re && re !== "") {
      const ue = oe || Fa.DEFAULT_PLACEHOLDER_TEMPLATE;
      Y.placeholder = ue.replace(Fa.TEMPLATE_VARIABLE, re);
    } else
      Y.placeholder = Fa.DEFAULT_PLACEHOLDER;
  }
  static createElement(Y, re, oe) {
    const ue = document.createElement("input");
    ue.classList.add(Fa.INPUT_CLASS);
    const fe = oe?.placeholderColor || "#656565";
    return ue.style.setProperty("--active-table-filter-placeholder-color", fe), Object.assign(ue.style, oe?.input), Fa.setPlaceholder(ue, Y, re), ue;
  }
  static create(Y, re, oe) {
    const ue = FilterInternalUtils.generateDefaultHeaderName(oe, Y.defaultColumnHeaderName), fe = Fa.createElement(ue, Y.placeholderTemplate, re.styles);
    return Y.inputElement = fe, fe;
  }
};
_FilterInputElement.INPUT_CLASS = "filter-rows-input";
_FilterInputElement.TEMPLATE_VARIABLE = "{headerName}";
_FilterInputElement.DEFAULT_PLACEHOLDER = "Filter";
_FilterInputElement.DEFAULT_PLACEHOLDER_TEMPLATE = `Filter ${_FilterInputElement.TEMPLATE_VARIABLE}...`;
let FilterInputElement = _FilterInputElement;
class FilterInputEvents {
  static unsetEvents(Y) {
    Y && Y.forEach((re) => re.inputElement.oninput = () => {
    });
  }
  static updateSameInputValues(Y, re) {
    Y.forEach((oe) => {
      oe.elements === re.elements && (oe.inputElement.value = re.inputElement.value);
    });
  }
  static getFilterData(Y) {
    return Y.map((re) => ({
      filterText: re.isCaseSensitive ? re.inputElement.value : re.inputElement.value.toLocaleLowerCase(),
      colCells: re.elements.slice(1),
      isCaseSensitive: re.isCaseSensitive
    }));
  }
  static splitChunksAndExecute(Y, re) {
    const oe = Y.filter((fe) => fe.filterText !== "");
    oe.length === 0 && oe.push(Y[0]);
    const ue = Math.ceil(oe[0].colCells.length / FilterInternalUtils.CHUNK_SIZE);
    for (let fe = 0; fe < ue; fe += 1) {
      const he = fe * FilterInternalUtils.CHUNK_SIZE, _e = oe.map((ve) => ({ ...ve, chunk: ve.colCells.slice(he, he + FilterInternalUtils.CHUNK_SIZE) }));
      re(_e);
    }
  }
  static setEvents(Y, re, oe) {
    if (!re.elements)
      return;
    const ue = FilterInternalUtils.getFilterFunc(Y), fe = oe.filter((he) => he !== re);
    re.inputElement.oninput = () => {
      FilterInputEvents.updateSameInputValues(fe, re), FilterInputEvents.splitChunksAndExecute(FilterInputEvents.getFilterData(oe), ue);
    };
  }
}
const ARROW_DOWN_SVG_STRING = `<?xml version="1.0" encoding="UTF-8"?>
<svg viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
		<g transform="translate(-288.000000, 0.000000)">
			<g transform="translate(288.000000, 0.000000)">
				<path d="M24,0 L24,24 L0,24 L0,0 L24,0 Z M12.5934901,23.257841 L12.5819402,23.2595131 L12.5108777,23.2950439 L12.4918791,23.2987469 L12.4918791,23.2987469 L12.4767152,23.2950439 L12.4056548,23.2595131 C12.3958229,23.2563662 12.3870493,23.2590235 12.3821421,23.2649074 L12.3780323,23.275831 L12.360941,23.7031097 L12.3658947,23.7234994 L12.3769048,23.7357139 L12.4804777,23.8096931 L12.4953491,23.8136134 L12.4953491,23.8136134 L12.5071152,23.8096931 L12.6106902,23.7357139 L12.6232938,23.7196733 L12.6232938,23.7196733 L12.6266527,23.7031097 L12.609561,23.275831 C12.6075724,23.2657013 12.6010112,23.2592993 12.5934901,23.257841 L12.5934901,23.257841 Z M12.8583906,23.1452862 L12.8445485,23.1473072 L12.6598443,23.2396597 L12.6498822,23.2499052 L12.6498822,23.2499052 L12.6471943,23.2611114 L12.6650943,23.6906389 L12.6699349,23.7034178 L12.6699349,23.7034178 L12.678386,23.7104931 L12.8793402,23.8032389 C12.8914285,23.8068999 12.9022333,23.8029875 12.9078286,23.7952264 L12.9118235,23.7811639 L12.8776777,23.1665331 C12.8752882,23.1545897 12.8674102,23.1470016 12.8583906,23.1452862 L12.8583906,23.1452862 Z M12.1430473,23.1473072 C12.1332178,23.1423925 12.1221763,23.1452606 12.1156365,23.1525954 L12.1099173,23.1665331 L12.0757714,23.7811639 C12.0751323,23.7926639 12.0828099,23.8018602 12.0926481,23.8045676 L12.108256,23.8032389 L12.3092106,23.7104931 L12.3186497,23.7024347 L12.3186497,23.7024347 L12.3225043,23.6906389 L12.340401,23.2611114 L12.337245,23.2485176 L12.337245,23.2485176 L12.3277531,23.2396597 L12.1430473,23.1473072 Z" fill-rule="nonzero"></path>
				<path d="M12.7071,15.7072 C12.3166,16.0977 11.6834,16.0977 11.2929,15.7072 L5.63604,10.0503 C5.24551,9.65982 5.24551,9.02666 5.63604,8.63613 C6.02656,8.24561 6.65973,8.24561 7.05025,8.63613 L12,13.5859 L16.9497,8.63613 C17.3403,8.24561 17.9734,8.24561 18.364,8.63613 C18.7545,9.02666 18.7545,9.65982 18.364,10.0503 L12.7071,15.7072 Z" fill="#09244B"></path>
			</g>
		</g>
	</g>
</svg>`, _FilterButtonElement = class Xi {
  static create(Y = {}) {
    const re = document.createElement("div");
    re.classList.add("filter-rows-dropdown-button", ToggleableElement.AUTO_STYLING_CLASS), FilterElements.applyStatefulStyles(re, Xi.HOVER_STYLE, Y);
    const oe = SVGIconUtils.createSVGElement(ARROW_DOWN_SVG_STRING);
    return re.appendChild(oe), re;
  }
};
_FilterButtonElement.ACTIVE_STYLE = {
  filter: (
    // eslint-disable-next-line max-len
    "brightness(0) saturate(100%) invert(14%) sepia(59%) saturate(2970%) hue-rotate(219deg) brightness(98%) contrast(126%)"
  )
};
_FilterButtonElement.HOVER_STYLE = {
  filter: (
    // eslint-disable-next-line max-len
    "brightness(0) saturate(100%) invert(31%) sepia(1%) saturate(75%) hue-rotate(327deg) brightness(100%) contrast(99%)"
  )
};
let FilterButtonElement = _FilterButtonElement;
class OuterDropdownItemEvents {
  // prettier-ignore
  static itemMouseDownCommon(Y, re, oe) {
    const { _activeOverlayElements: { outerContainerDropdown: ue } } = this, fe = oe.target.innerText;
    if (!ue)
      return;
    Y?.(this, fe, oe);
    const he = Array.from(ue.element.children);
    re?.(this._activeOverlayElements, he), ue.element.classList.contains(StaticDropdown.DROPDOWN_CLASS) || (OuterDropdownItem.unsetActiveItem(ue.element), OuterDropdownItem.setActive(he, fe), DropdownItemHighlightUtils.fadeCurrentlyHighlighted(this._activeOverlayElements));
  }
}
class FilterDropdownItemEvents {
  static resetInput(Y, re, oe, ue) {
    const fe = ue.target, he = fe.tabIndex === -1 ? fe.parentElement.tabIndex : fe.tabIndex, _e = re._columnsDetails[he].elements;
    _e !== Y.elements && (Y.elements = _e, FilterInternalUtils.resetInput(re, Y), FilterInternalUtils.unsetFilter(Y.inputElement));
  }
  static setEvents(Y, re, oe, ue) {
    const fe = FilterDropdownItemEvents.resetInput.bind(this, oe), he = FilterDropdownElement.hide.bind(this, ue);
    re.onmousedown = OuterDropdownItemEvents.itemMouseDownCommon.bind(Y, fe, he);
  }
}
class FilterDropdownItem {
  static setActive(Y, re, oe) {
    const ue = Y._columnsDetails.findIndex((fe) => fe.elements === oe.elements);
    OuterDropdownItem.setActiveByIndex(Array.from(re.children), ue);
  }
  static addItems(Y, re, oe) {
    var ue;
    const fe = (ue = Y.data[0]) == null ? void 0 : ue.map((he) => String(he));
    fe?.forEach((he) => {
      const _e = { text: he }, ve = DropdownItem.addButtonItem(Y, re.element, _e);
      FilterDropdownItemEvents.setEvents(Y, ve, oe, re.activeButtonStyle);
    });
  }
  static populate(Y, re, oe) {
    re.element.replaceChildren(), FilterDropdownItem.addItems(Y, re, oe), FilterDropdownItem.setActive(Y, re.element, oe);
  }
}
class FilterDropdownElement {
  static hide(Y, re) {
    OuterDropdownElement.hide(re, Y);
  }
  // prettier-ignore
  static display(Y, re, oe, ue) {
    oe.data[0] && (FilterDropdownItem.populate(oe, ue, re), Y(oe, ue));
  }
  // prettier-ignore
  static create(Y, re, oe, ue, fe) {
    const he = FilterButtonElement.create(fe);
    re.appendChild(he);
    const _e = fe?.active || {}, ve = { ...FilterButtonElement.ACTIVE_STYLE, ..._e }, xe = FilterDropdownElement.hide.bind(this, ve, Y._activeOverlayElements), Ee = OuterDropdownButtonEvents.getDisplayFunc(oe), Se = FilterDropdownElement.display.bind(this, Ee, ue), { element: Te } = OuterDropdownElement.create(
      Y,
      he,
      oe,
      ve,
      ["filter-rows-dropdown"],
      xe,
      Se
    );
    return Te;
  }
}
class StatefulCSSEvents {
  static apply(Y, re, oe) {
    ElementStyle.unsetAllCSSStates(oe, Y), Object.assign(oe.style, re);
  }
  static mouseUp(Y, re, oe) {
    re && oe.classList.contains(re) || (StatefulCSSEvents.apply(Y, Y.default, oe), Object.assign(oe.style, Y.hover));
  }
  static mouseDown(Y, re, oe) {
    re && oe.classList.contains(re) || Object.assign(oe.style, Y.click);
  }
  static mouseLeave(Y, re, oe) {
    re && oe.classList.contains(re) || StatefulCSSEvents.apply(Y, Y.default, oe);
  }
  static mouseEnter(Y, re, oe) {
    re && oe.classList.contains(re) || Object.assign(oe.style, Y.hover);
  }
  // can change the styling on another element by using the otherElement argument
  static getEvents(Y, re, oe, ue) {
    const fe = ue || Y;
    return {
      mouseenter: StatefulCSSEvents.mouseEnter.bind(this, re, oe, fe),
      mouseleave: StatefulCSSEvents.mouseLeave.bind(this, re, oe, fe),
      mousedown: StatefulCSSEvents.mouseDown.bind(this, re, oe, fe),
      mouseup: StatefulCSSEvents.mouseUp.bind(this, re, oe, fe)
    };
  }
  static setEvents(Y, re, oe, ue) {
    const fe = StatefulCSSEvents.getEvents(Y, re, oe, ue);
    return Y.addEventListener("mouseenter", fe.mouseenter), Y.addEventListener("mouseleave", fe.mouseleave), Y.addEventListener("mousedown", fe.mousedown), Y.addEventListener("mouseup", fe.mouseup), fe;
  }
}
class FilterInputCaseEvents {
  static clickButton(Y, re, oe) {
    const ue = oe || {}, fe = ToggleableElement.toggleActive(Y, { color: "#000000", ...ue });
    re.isCaseSensitive = !fe, FilterInternalUtils.resetInput(this, re), re.inputElement.dispatchEvent(new Event("input"));
  }
  static setEvents(Y, re, oe, ue) {
    re.onclick = FilterInputCaseEvents.clickButton.bind(Y, re, oe, ue);
  }
}
class FilterInputCaseElement {
  static createButton(Y = {}) {
    const re = document.createElement("div");
    return re.classList.add("filter-rows-case-button"), re.textContent = "Aa", FilterElements.applyStatefulStyles(re, { color: "#626262" }, Y), re;
  }
  static create(Y, re, oe, ue) {
    const fe = FilterInputCaseElement.createButton(ue?.caseIcon);
    re.appendChild(fe), setTimeout(() => {
      var he;
      return FilterInputCaseEvents.setEvents(Y, fe, oe, (he = ue?.caseIcon) == null ? void 0 : he.active);
    });
  }
}
const _FilterElements = class Wa {
  static createContainerElement(Y) {
    const re = document.createElement("div");
    return re.classList.add("filter-rows-container"), re.style.order = String(Y || 0), re;
  }
  // the order at which the elements are added is very important - please check the css selectors
  // prettier-ignore
  static createComponent(Y, re, oe) {
    var ue;
    const fe = oe.position || Wa.DEFAULT_INPUT_POSITION, he = Wa.createContainerElement(oe.order), _e = FilterInternalUtils.addConfig(Y, oe);
    if (oe.dropdown !== !1) {
      const xe = FilterDropdownElement.create(
        Y,
        he,
        fe,
        _e,
        (ue = oe.styles) == null ? void 0 : ue.dropdownIcon
      );
      setTimeout(() => he.appendChild(xe));
    }
    oe.caseButton !== !1 && FilterInputCaseElement.create(Y, he, _e, oe.styles);
    const ve = FilterInputElement.create(_e, oe, Y.data);
    he.appendChild(ve), OuterContainerElements.addToContainer(fe, re, he);
  }
  static create(Y, re) {
    typeof Y.filter == "boolean" ? Wa.createComponent(Y, re, {}) : Array.isArray(Y.filter) ? Y.filter.forEach((oe) => {
      Wa.createComponent(Y, re, oe);
    }) : Y.filter && Wa.createComponent(Y, re, Y.filter), setTimeout(() => FilterInternalUtils.resetAllInputs(Y));
  }
  static applyStatefulStyles(Y, re, oe = {}) {
    const ue = ElementStyle.generateStatefulCSS(oe, re, { color: "#484848" });
    Object.assign(Y.style, ue.default), setTimeout(() => StatefulCSSEvents.setEvents(Y, ue, ToggleableElement.ACTIVE_BUTTON_CLASS));
  }
};
_FilterElements.DEFAULT_INPUT_POSITION = "top-right";
let FilterElements = _FilterElements;
const CALENDAR_ICON_SVG_STRING = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="10px" viewBox="0 0 10 10" version="1.1">
  <g id="surface1">
    <path style=" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;" d="M 1.070312 9.285156 L 8.929688 9.285156 L 8.929688 3.570312 L 1.070312 3.570312 Z M 3.214844 2.5 L 3.214844 0.894531 C 3.214844 0.839844 3.199219 0.796875 3.164062 0.765625 C 3.128906 0.730469 3.085938 0.714844 3.035156 0.714844 L 2.679688 0.714844 C 2.625 0.714844 2.582031 0.730469 2.550781 0.765625 C 2.515625 0.796875 2.5 0.839844 2.5 0.894531 L 2.5 2.5 C 2.5 2.550781 2.515625 2.59375 2.550781 2.628906 C 2.582031 2.660156 2.625 2.679688 2.679688 2.679688 L 3.035156 2.679688 C 3.085938 2.679688 3.128906 2.660156 3.164062 2.628906 C 3.199219 2.59375 3.214844 2.550781 3.214844 2.5 Z M 7.5 2.5 L 7.5 0.894531 C 7.5 0.839844 7.484375 0.796875 7.449219 0.765625 C 7.417969 0.730469 7.375 0.714844 7.320312 0.714844 L 6.964844 0.714844 C 6.914062 0.714844 6.871094 0.730469 6.835938 0.765625 C 6.800781 0.796875 6.785156 0.839844 6.785156 0.894531 L 6.785156 2.5 C 6.785156 2.550781 6.800781 2.59375 6.835938 2.628906 C 6.871094 2.660156 6.914062 2.679688 6.964844 2.679688 L 7.320312 2.679688 C 7.375 2.679688 7.417969 2.660156 7.449219 2.628906 C 7.484375 2.59375 7.5 2.550781 7.5 2.5 Z M 9.644531 2.144531 L 9.644531 9.285156 C 9.644531 9.480469 9.570312 9.648438 9.429688 9.789062 C 9.289062 9.929688 9.121094 10 8.929688 10 L 1.070312 10 C 0.878906 10 0.710938 9.929688 0.570312 9.789062 C 0.429688 9.648438 0.355469 9.480469 0.355469 9.285156 L 0.355469 2.144531 C 0.355469 1.949219 0.429688 1.78125 0.570312 1.640625 C 0.710938 1.5 0.878906 1.429688 1.070312 1.429688 L 1.785156 1.429688 L 1.785156 0.894531 C 1.785156 0.648438 1.875 0.4375 2.046875 0.261719 C 2.222656 0.0859375 2.433594 0 2.679688 0 L 3.035156 0 C 3.28125 0 3.492188 0.0859375 3.667969 0.261719 C 3.839844 0.4375 3.929688 0.648438 3.929688 0.894531 L 3.929688 1.429688 L 6.070312 1.429688 L 6.070312 0.894531 C 6.070312 0.648438 6.160156 0.4375 6.332031 0.261719 C 6.507812 0.0859375 6.71875 0 6.964844 0 L 7.320312 0 C 7.566406 0 7.777344 0.0859375 7.953125 0.261719 C 8.125 0.4375 8.214844 0.648438 8.214844 0.894531 L 8.214844 1.429688 L 8.929688 1.429688 C 9.121094 1.429688 9.289062 1.5 9.429688 1.640625 C 9.570312 1.78125 9.644531 1.949219 9.644531 2.144531 Z M 9.644531 2.144531 "/>
  </g>
</svg>`, _DateCellCalendarIconElement = class ri {
  // need a container as mousedown target kept being different parts of svg
  // hence svgIcon has no pointer events
  static createContainer() {
    const Y = document.createElement("div");
    return Y.classList.add(ri.CALENDAR_ICON_CONTAINER_CLASS), Y;
  }
  // REF-10
  static createSVGElement() {
    const Y = SVGIconUtils.createSVGElement(CALENDAR_ICON_SVG_STRING);
    return Y.style.pointerEvents = "none", Y.style.height = "25px", Y;
  }
  static createSVG() {
    const Y = ri.createSVGElement(), re = ri.createContainer();
    return re.appendChild(Y), re;
  }
  static get() {
    return ri.CALENDAR_ICON_ELEMENT.cloneNode(!0);
  }
};
_DateCellCalendarIconElement.CALENDAR_ICON_CONTAINER_CLASS = "calender-icon-container";
_DateCellCalendarIconElement.CALENDAR_ICON_ELEMENT = _DateCellCalendarIconElement.createSVG();
let DateCellCalendarIconElement = _DateCellCalendarIconElement;
class ColumnDetailsUtils {
  static getColumnsByWidth(Y) {
    var re;
    const oe = [], ue = [];
    for (let fe = 0; fe < Y.length; fe += 1) {
      const he = Y[fe];
      ((re = he.settings.widths) == null ? void 0 : re.staticWidth) !== void 0 ? ue.push(he) : oe.push(he);
    }
    return { dynamicWidth: oe, staticWidth: ue };
  }
  static aggregateItems(Y) {
    return Y.labelDetails ? Object.keys(Y.itemsDetails).map((re) => ({ name: re, backgroundColor: Y.itemsDetails[re].backgroundColor })) : Object.keys(Y.itemsDetails).map((re) => ({ name: re }));
  }
  static getDetails(Y) {
    const re = {
      width: Y.elements[0].offsetWidth,
      typeName: Y.activeType.name
    };
    return Y.activeType.cellDropdownProps && (re.cellDropdownItems = ColumnDetailsUtils.aggregateItems(Y.cellDropdown)), re;
  }
  static getAllColumnsDetails(Y) {
    return Y.map((re) => ColumnDetailsUtils.getDetails(re));
  }
}
class FireEvents {
  // prettier-ignore
  static onCellUpdate(Y, re, oe, ue, fe) {
    const he = { text: String(re), rowIndex: oe, columnIndex: ue, updateType: fe };
    Y.onCellUpdate(he), Y.dispatchEvent(new CustomEvent("cell-update", { detail: he }));
  }
  static onDataUpdate(Y) {
    const re = JSON.parse(JSON.stringify(Y.data));
    Y.onDataUpdate(re), Y.dispatchEvent(new CustomEvent("data-update", { detail: re }));
  }
  static onColumnsUpdate(Y) {
    const re = ColumnDetailsUtils.getAllColumnsDetails(Y._columnsDetails);
    Y.onColumnsUpdate(re), Y.dispatchEvent(new CustomEvent("columns-update", { detail: re }));
  }
  static onRender(Y) {
    Y.onRender(), Y.dispatchEvent(new CustomEvent("render"));
  }
}
class StaticTable {
  // because we don't set the table width for maxWidth property, its width is made up of columns widths -
  // they don't always add up to a precise expected value, e.g. if expected 500, they can add up to a 498
  // and 499. Hence instead of doing === tableElement.offsetWidth, we do <= tableElement.offsetWidth + 2
  // number 2 seems enough but can increase if this method is returning false in valid scenarios
  static isTableAtMaxWidth(Y, re) {
    return re.maxWidth !== void 0 && re.maxWidth <= Y.offsetWidth + 2;
  }
  static isStaticTableWidth(Y, re) {
    return re.width !== void 0 || StaticTable.isTableAtMaxWidth(Y, re);
  }
}
class StaticTableWidthUtils {
  // REF-11
  static togglePreserveNarrowColumns(Y, re, oe) {
    oe || (re.style.display = Y ? "block" : "");
  }
  // when the client has not provided the 'width' value for the table, but a 'maxWidth' is present, need to
  // temporarily set the width at the start in order to help the MaximumColumns class to determine what columns fit
  // prettier-ignore
  static toggleWidthUsingMaxWidth(Y, re) {
    const { _tableElementRef: oe, _tableDimensions: { maxWidth: ue, preserveNarrowColumns: fe } } = Y;
    oe && ue !== void 0 && (oe.style.width = re ? `${ue}px` : "", StaticTableWidthUtils.togglePreserveNarrowColumns(re, oe, fe));
  }
  // prettier-ignore
  static setTableWidth(Y) {
    const { _tableDimensions: { preserveNarrowColumns: re, width: oe }, _tableElementRef: ue } = Y;
    ue && oe !== void 0 && (ue.style.width = `${oe}px`, StaticTableWidthUtils.togglePreserveNarrowColumns(!0, ue, re));
  }
  // This only runs when the table width is set
  // prettier-ignore
  static changeTableWidthForNonDynamicColumns(Y, re, oe, ue, fe) {
    Y.length === 0 || re.dynamicWidth.length > 0 ? oe.offsetWidth !== ue && (oe.style.width = `${ue}px`) : oe.style.width = `${fe}px`;
  }
  static resetDynamicWidthColumns(Y, re) {
    Y.forEach((oe) => {
      oe.elements[0].style.width = `${re.newColumnWidth}px`;
    });
  }
  static setNewColumnWidth(Y, re, oe) {
    if (re > 0) {
      const ue = Y - oe.staticWidth;
      oe.newColumnWidth = ue / re;
    }
  }
  static resetColumnSizes(Y, re, oe) {
    const ue = ColumnDetailsUtils.getColumnsByWidth(Y);
    return StaticTableWidthUtils.setNewColumnWidth(re, ue.dynamicWidth.length, oe), StaticTableWidthUtils.resetDynamicWidthColumns(ue.dynamicWidth, oe), ue;
  }
  static changeWidthsBasedOnColumnInsertRemove(Y, re) {
    const { _tableElementRef: oe, _tableDimensions: ue, _columnsDetails: fe } = Y;
    if (!oe)
      return;
    const { width: he, maxWidth: _e, staticWidth: ve } = ue;
    if (he !== void 0) {
      const xe = StaticTableWidthUtils.resetColumnSizes(fe, he, ue);
      StaticTableWidthUtils.changeTableWidthForNonDynamicColumns(fe, xe, oe, he, ve);
    } else
      re && StaticTable.isTableAtMaxWidth(oe, ue) && StaticTableWidthUtils.resetColumnSizes(fe, _e, ue);
    setTimeout(() => FireEvents.onColumnsUpdate(Y));
  }
}
class ConvertCellTypeUtils {
  static preprocessCell(Y) {
    Y.style.cursor = "";
  }
}
class CellStructureUtils {
  static setColumn(Y, re, oe, ue) {
    const { elements: fe } = Y._columnsDetails[re];
    fe.slice(1).forEach((he, _e) => {
      const ve = _e + 1;
      oe(Y, he, re, ve), Y._columnsDetails[re].settings.isCellTextEditable && ue(Y, he, ve, re);
    });
  }
}
class FocusedCellUtils {
  static createEmpty() {
    return {};
  }
  static setHeaderCell(Y, re, oe) {
    Y.element = re, Y.rowIndex = 0, Y.columnIndex = oe;
  }
  static setIndexCell(Y, re, oe) {
    Y.element = re, Y.rowIndex = oe, delete Y.columnIndex;
  }
  static set(Y, re, oe, ue) {
    Y.element = re, Y.rowIndex = oe, Y.columnIndex = ue;
  }
  static incrementColumnIndex(Y, re) {
    Y.columnIndex !== void 0 && re <= Y.columnIndex && (Y.columnIndex += 1);
  }
  static purge(Y) {
    delete Y.columnIndex, delete Y.element, delete Y.rowIndex;
  }
}
var KEYBOARD_KEY = /* @__PURE__ */ ((le) => (le.ESCAPE = "Escape", le.ENTER = "Enter", le.TAB = "Tab", le.ARROW_UP = "ArrowUp", le.ARROW_DOWN = "ArrowDown", le.ARROW_RIGHT = "ArrowRight", le.ARROW_LEFT = "ArrowLeft", le))(KEYBOARD_KEY || {});
const _Browser = class {
  // can't use DateCellInputElement class as this is called before CellElement class can be used
  static createDateInput() {
    const le = document.createElement("input");
    return le.type = "date", le;
  }
  static createColorInput() {
    const le = document.createElement("input");
    return le.type = "color", le;
  }
};
_Browser.IS_FIREFOX = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
_Browser.IS_SAFARI = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
_Browser.IS_CHROMIUM = window.chrome;
_Browser.IS_INPUT_DATE_SUPPORTED = _Browser.createDateInput().type === "date" && "showPicker" in HTMLInputElement.prototype;
_Browser.IS_COLOR_PICKER_SUPPORTED = _Browser.createColorInput().type === "color" && "showPicker" in HTMLInputElement.prototype;
let Browser = _Browser;
class ColumnSettingsStyleUtils {
  static applySettingsStyleOnCell(Y, re, oe) {
    var ue;
    Object.assign(re.style, Y.cellStyle || {}, oe ? ((ue = Y.headerStyles) == null ? void 0 : ue.default) || {} : {});
  }
  // prettier-ignore
  static setNewHeaderStyle(Y, re) {
    var oe;
    const { settings: ue, elements: fe } = re, he = ue.cellStyle || ((oe = ue.headerStyles) == null ? void 0 : oe.default);
    he && ColumnSettingsStyleUtils.applySettingsStyleOnCell(ue, fe[0], !0);
    const _e = he ? ue : void 0;
    re.headerStateColors = ColumnDetails.createHeaderStateColors(
      Y._defaultColumnsSettings,
      _e,
      Y._defaultCellHoverColors
    ), ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(re, [fe[0]]);
  }
  static unsetHeaderSettingStyle(Y, re) {
    Object.keys(re).forEach((oe) => {
      ElementStyle.setStyle(Y, oe, "");
    });
  }
  // prettier-ignore
  static resetHeaderStyleToDefault(Y, re, oe) {
    var ue;
    (ue = re.headerStyles) != null && ue.default && ColumnSettingsStyleUtils.unsetHeaderSettingStyle(Y[0], re.headerStyles.default), re.cellStyle && ElementStyle.unsetStyle(Y[0], re.cellStyle);
    const { cellStyle: fe, headerStyles: he } = oe;
    CellElement.setDefaultCellStyle(Y[0], fe, he?.default);
  }
  // prettier-ignore
  static changeHeaderStyleFunc(Y, re) {
    var oe, ue, fe;
    const he = this._columnsDetails[Y], { elements: _e, settings: { isHeaderTextEditable: ve } } = he;
    ColumnSettingsStyleUtils.resetHeaderStyleToDefault(_e, re, this._defaultColumnsSettings), ColumnSettingsStyleUtils.setNewHeaderStyle(this, he);
    const xe = (fe = (ue = (oe = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : oe.displaySettings) == null ? void 0 : ue.openMethod) == null ? void 0 : fe.cellClick, Ee = !xe && ve;
    CellElement.prepContentEditable(
      CellElement.getTextElement(_e[0]),
      !!Ee,
      xe
    );
  }
  // prettier-ignore
  static changeStyleFunc(Y, re, oe) {
    ProcessedDataTextStyle.resetDataCellsStyle(
      Y,
      re,
      ColumnSettingsStyleUtils.changeHeaderStyleFunc.bind(Y, re, oe),
      oe.cellStyle
    );
  }
  static doStylesHaveVisibleDimension(Y, re) {
    for (let oe = 0; oe < re.length; oe += 1) {
      const ue = Y[re[oe]];
      if (ue) {
        const fe = RegexUtils.extractIntegerStrs(String(ue));
        if (fe.length > 0 && Number(fe[0]) > 0)
          return !0;
      }
    }
    return !1;
  }
  // REF-23
  // prettier-ignore
  static doesSettingHaveSideBorderStyle(Y) {
    var re;
    const oe = Y.cellStyle || ((re = Y.headerStyles) == null ? void 0 : re.default);
    return oe ? ColumnSettingsStyleUtils.doStylesHaveVisibleDimension(
      oe,
      ["border", "borderLeft", "borderLeftWidth", "borderRight", "borderRightWidth"]
    ) : !1;
  }
}
class ResetColumnStyles {
  static applyDefaultStyles(Y, re) {
    const { cellStyle: oe, headerStyles: ue } = re;
    CellElement.setDefaultCellStyle(Y[0], oe, ue?.default), Y.slice(1).forEach((fe) => {
      CellElement.setDefaultCellStyle(fe, oe);
    });
  }
  static unsetLastAppliedStyle(Y, re) {
    Object.keys(Y.lastAppliedStyle).forEach((oe) => {
      ElementStyle.setStyle(re, oe, "");
    });
  }
  // if this operation turns out to be expensive - try to save and reuse the default style
  // prettier-ignore
  static setDefaultStyle(Y, re, oe, ue, fe) {
    ResetColumnStyles.unsetLastAppliedStyle(re, oe), fe && ElementStyle.unsetStyle(oe, fe), CellElement.setDefaultCellStyle(oe, ue.cellStyle), ColumnSettingsStyleUtils.applySettingsStyleOnCell(Y.settings, oe, !1);
  }
}
const _ProcessedDataTextStyle = class fa {
  // prettier-ignore
  static setCustomStyle(Y, re, oe, ue, fe, he, _e) {
    if (Y) {
      ResetColumnStyles.setDefaultStyle(oe, fe, he, _e);
      const ve = Y(String(re), ue);
      Object.assign(he.style, ve), fe.lastAppliedStyle = ve, ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(oe, [he]);
    }
  }
  // prettier-ignore
  static setFailedValidationStyle(Y, re, oe) {
    const { textValidation: ue } = Y.activeType, fe = ue.failedStyle || fa.DEFAULT_FAILED_VALIDATION_STYLE;
    Object.assign(oe.style, fe), re.lastAppliedStyle = fe;
  }
  // prettier-ignore
  static setStyle(Y, re, oe, ue, fe, he) {
    let _e = !1;
    return Y ? ue != null && ue.changeStyleFunc || (ResetColumnStyles.setDefaultStyle(re, oe, fe, he), oe.lastAppliedStyle = {}, _e = !0) : (ue != null && ue.changeStyleFunc && ResetColumnStyles.setDefaultStyle(re, oe, fe, he), fa.setFailedValidationStyle(re, oe, fe), _e = !0), _e && ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(re, [fe]), _e;
  }
  // prettier-ignore
  static setCellStyle(Y, re, oe, ue = !1) {
    const fe = Y._columnsDetails[oe], he = fe.elements[re], _e = fe.processedStyle[re], ve = CellElement.getText(he), { textValidation: { func: xe }, customTextProcessing: Ee } = fe.activeType;
    let Se = !1;
    if (xe) {
      const Te = xe(ve);
      (ue || _e.isValid !== Te) && (Se = fa.setStyle(
        Te,
        fe,
        _e,
        Ee,
        he,
        Y._defaultColumnsSettings
      ), _e.isValid = Te);
    }
    !Se && Ee != null && Ee.changeStyleFunc && fa.setCustomStyle(
      Ee.changeStyleFunc,
      ve,
      fe,
      re,
      _e,
      he,
      Y._defaultColumnsSettings
    );
  }
  static setStyleOnColumn(Y, re) {
    const oe = Y._columnsDetails[re];
    oe.elements.slice(1).forEach((ue, fe) => {
      const he = fe + 1;
      fa.setCellStyle(Y, he, re, !0), ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(oe, [ue]);
    });
  }
  static unsetStyleOnColumn(Y, re, oe) {
    const ue = Y._columnsDetails[re];
    ue.elements.slice(1).forEach((fe, he) => {
      const _e = he + 1, ve = ue.processedStyle[_e];
      ResetColumnStyles.setDefaultStyle(ue, ve, fe, Y._defaultColumnsSettings, oe);
    });
  }
  // using this to first unset the previous processed style, allow new settings/type to be applied and then set
  // new style
  // prettier-ignore
  static resetDataCellsStyle(Y, re, oe, ue) {
    fa.unsetStyleOnColumn(Y, re, ue), oe(), fa.setStyleOnColumn(Y, re);
  }
  // prettier-ignore
  // this is used for a case where the default style has been set and need to reapply the processed style
  // without having to rerun the validation/changeStyleFunc functions
  static reapplyCellsStyle(Y, re) {
    const oe = Y._columnsDetails[re], { textValidation: { func: ue }, customTextProcessing: fe } = oe.activeType;
    (ue || fe != null && fe.changeStyleFunc) && oe.elements.slice(1).forEach((he, _e) => {
      const ve = _e + 1;
      Object.assign(he.style, oe.processedStyle[ve].lastAppliedStyle);
    });
  }
  static getDefaultProcessedTextStyle() {
    return { isValid: !0, lastAppliedStyle: {} };
  }
};
_ProcessedDataTextStyle.DEFAULT_FAILED_VALIDATION_STYLE = { color: "grey" };
let ProcessedDataTextStyle = _ProcessedDataTextStyle;
class NumberOfIdenticalCells {
  // columnsDetails instead of row from data because during startup - data is already be populated and
  // not yet added to the table, hence we are automatically marking headers as duplicate and setting them
  // to default, however the end headers that are not duplicate may not be displayed due to max columns,
  // hence using columnsDetails to mark duplicates as headers are added instead
  // prettier-ignore
  static get(Y, re) {
    return re.map((oe) => oe.elements.length > 0 ? CellElement.getText(oe.elements[0]) : "").filter((oe) => oe === Y).length;
  }
}
const EMPTY_STRING = "";
class DataUtils {
  static createEmptyStringDataArray(Y) {
    return new Array(Y).fill(EMPTY_STRING);
  }
  static isTextEmpty(Y, re) {
    return Y !== EMPTY_STRING ? (typeof re == "string" ? re.trim() : re) === EMPTY_STRING : !1;
  }
  // note that NumberOfIdenticalCells.get uses the at.data top row, so it needs to be up-to-date
  // prettier-ignore
  static shouldBeSetToDefault(Y, re, oe, ue, fe) {
    const { allowDuplicateHeaders: he, _columnsDetails: _e } = Y;
    return DataUtils.isTextEmpty(oe, re) || ue === 0 && !he && NumberOfIdenticalCells.get(re, _e) > 1 || ue > 0 && !(fe.func === void 0 || fe.func(String(re)));
  }
  // prettier-ignore
  static processCellText(Y, re, oe, ue) {
    let fe = typeof ue == "string" ? ue.trim() : ue;
    const he = Y._columnsDetails[oe];
    if (!he)
      return fe;
    const { activeType: { textValidation: _e, customTextProcessing: ve }, settings: { defaultText: xe } } = he;
    return re > 0 && (ve != null && ve.changeTextFunc && (fe = ve.changeTextFunc(String(fe), re)), !_e.setTextToDefaultOnFail && fe !== EMPTY_STRING) ? fe : DataUtils.shouldBeSetToDefault(Y, fe, xe, re, _e) ? xe : fe;
  }
}
var CELL_UPDATE_TYPE = /* @__PURE__ */ ((le) => (le.UPDATE = "Update", le.ADD = "Add", le.REMOVED = "Removed", le))(CELL_UPDATE_TYPE || {});
class CellEvents {
  static executeUpdateOperation(Y, re) {
    return re?.[Y] === void 0 || re[Y] === !0;
  }
  // this is directly handled by operations that do not insert new cells as those handle the instructions below
  // in a different order asynchronously for maximum efficiency
  // prettier-ignore
  static updateCell(Y, re, oe, ue, fe) {
    return CellEvents.executeUpdateOperation("processText", fe) && (re = DataUtils.processCellText(Y, oe, ue, re)), CellEvents.executeUpdateOperation("updateData", fe) && (Y.data[oe][ue] = re), fe != null && fe.element && CellElement.setNewText(Y, fe.element, re, !1, !1), CellEvents.executeUpdateOperation("updateTableEvent", fe) && Y.onDataUpdate(Y.data), oe > 0 && ProcessedDataTextStyle.setCellStyle(Y, oe, ue), CellEvents.executeUpdateOperation("updateCellEvent", fe) && FireEvents.onCellUpdate(Y, re, oe, ue, CELL_UPDATE_TYPE.UPDATE), re;
  }
  // this is used for cases where updateCell should only be called if it has to be set to default
  // prettier-ignore
  static setCellToDefaultIfNeeded(Y, re, oe, ue, fe = !0) {
    const he = CellElement.getText(ue), _e = DataUtils.processCellText(Y, re, oe, he);
    return _e !== he ? (CellEvents.updateCell(
      Y,
      _e,
      re,
      oe,
      { element: ue, processText: !1, updateTableEvent: fe }
    ), !0) : !1;
  }
  // prettier-ignore
  static removeTextIfDefault(Y, re, oe, ue) {
    const { isDefaultTextRemovable: fe, defaultText: he } = Y._columnsDetails[oe].settings;
    fe && he !== EMPTY_STRING && he === CellElement.getText(ue) && CellEvents.updateCell(
      Y,
      EMPTY_STRING,
      re,
      oe,
      { element: ue, processText: !1 }
    );
  }
}
class CheckboxEvents {
  // REF-29
  static focusCheckbox(Y, re, oe) {
    Browser.IS_SAFARI || FocusedCellUtils.set(this._focusedElements.cell, Y, re, oe);
  }
  // REF-29
  static blurCheckbox() {
    Browser.IS_SAFARI || FocusedCellUtils.purge(this._focusedElements.cell);
  }
  static changeValueCheckbox(Y, re, oe) {
    const ue = oe.target;
    CellEvents.updateCell(this, String(ue.checked), Y, re, { processText: !1 });
  }
  static keyDownCheckbox(Y) {
    Y.key === KEYBOARD_KEY.ENTER && Y.target.click();
  }
  static setEvents(Y, re, oe, ue) {
    re.onkeydown = CheckboxEvents.keyDownCheckbox, re.onchange = CheckboxEvents.changeValueCheckbox.bind(Y, oe, ue), re.onfocus = CheckboxEvents.focusCheckbox.bind(Y, re, oe, ue), re.onblur = CheckboxEvents.blurCheckbox.bind(Y);
  }
}
class CheckboxCellEvents {
  static mouseDownCell(Y) {
    const re = Y.target;
    re.classList.contains(CellElement.CELL_CLASS) && re.children[0].click();
  }
  // REF-29
  static focusCell(Y) {
    Y.target.children[0].focus();
  }
  static setEvents(Y, re, oe, ue) {
    if (!Y._columnsDetails[ue].settings.isCellTextEditable)
      return;
    re.onblur = () => {
    }, re.onfocus = CheckboxCellEvents.focusCell, re.onmouseenter = () => {
    }, re.onmouseleave = () => {
    }, re.oninput = () => {
    }, re.onmousedown = CheckboxCellEvents.mouseDownCell.bind(Y);
    const fe = CheckboxCellElement.getCheckboxElement(re);
    CheckboxEvents.setEvents(Y, fe, oe, ue);
  }
}
class CheckboxElement {
  static createCheckbox(Y) {
    const re = document.createElement("input");
    return re.type = "checkbox", re.style.cursor = Y ? "pointer" : "auto", re.style.pointerEvents = Y ? "" : "none", re;
  }
  static setCellTextAsCheckbox(Y, re) {
    const oe = CheckboxElement.createCheckbox(re);
    Y.replaceChildren(oe);
  }
}
class CheckboxCellElement {
  static isCheckbox(Y) {
    return Y?.type === "checkbox";
  }
  static isCheckboxCell(Y) {
    return CheckboxCellElement.isCheckbox(Y.children[0]);
  }
  static getCheckboxElement(Y) {
    if (CheckboxCellElement.isCheckboxCell(Y))
      return Y.children[0];
    if (CheckboxCellElement.isCheckbox(Y))
      return Y;
  }
  static getValue(Y) {
    const re = CheckboxCellElement.getCheckboxElement(Y);
    if (re)
      return String(re.checked);
  }
  static setValue(Y, re) {
    const oe = CheckboxCellElement.getCheckboxElement(Y);
    return oe ? (oe.checked = re === "true", !0) : !1;
  }
  // prettier-ignore
  static setCellTextAsAnElement(Y, re, oe, ue) {
    const { settings: { isCellTextEditable: fe } } = Y._columnsDetails[ue], he = CellElement.getText(re);
    CheckboxElement.setCellTextAsCheckbox(re, fe), re.contentEditable = "false", re.style.cursor = fe ? "pointer" : "default", CellEvents.updateCell(Y, he, oe, ue, { element: re });
  }
  // prettier-ignore
  static setCellCheckboxStructure(Y, re, oe, ue) {
    ConvertCellTypeUtils.preprocessCell(re), CheckboxCellElement.setCellTextAsAnElement(Y, re, ue, oe);
  }
  // prettier-ignore
  static setColumnCheckboxStructure(Y, re) {
    CellStructureUtils.setColumn(
      Y,
      re,
      CheckboxCellElement.setCellCheckboxStructure,
      CheckboxCellEvents.setEvents
    );
  }
}
class CaretPosition {
  static setSelectionToEndOfText(Y, re) {
    const oe = CellElement.getTextElement(Y), ue = document.createRange();
    ue.setStart(oe.childNodes[0], CellElement.getText(oe).length || 0), ue.collapse(!0), re.removeAllRanges(), re.addRange(ue);
  }
  static getSelection(Y) {
    var re;
    const oe = Y.shadowRoot;
    return oe.getSelection ? oe.getSelection() : ((re = window.document.activeElement) == null ? void 0 : re.shadowRoot) === oe ? window.document.getSelection() : null;
  }
  static setToEndOfText(Y, re) {
    if (CheckboxCellElement.isCheckboxCell(re))
      return;
    let oe = CaretPosition.getSelection(Y);
    Browser.IS_SAFARI && !oe && (re.focus(), oe = CaretPosition.getSelection(Y)), oe && CaretPosition.setSelectionToEndOfText(re, oe);
  }
}
class ArrayUtils {
  static transpose(Y) {
    if (Y.length === 0)
      return Y;
    const re = [], oe = Math.max(Y.length, Y[0].length);
    e:
      for (let ue = 0; ue < oe; ue += 1) {
        const fe = [];
        for (let he = 0; he < oe && Y[he] !== void 0; he += 1) {
          if (Y[he][ue] === void 0)
            break e;
          fe.push(Y[he][ue]);
        }
        re.push(fe);
      }
    return re;
  }
  static shuffle(Y) {
    return Y.sort(() => Math.random() - 0.5);
  }
  static swap(Y, re, oe) {
    const ue = Y[re];
    Y[re] = Y[oe], Y[oe] = ue;
  }
}
const _LabelColorUtils = class ka {
  static generateNewPasteleColor() {
    return `hsl(${Math.floor(Math.random() * 360)}, 95%, 90%)`;
  }
  static setNewLatestPasteleColor() {
    ka.LATEST_PASTELE_COLOR = ka.generateNewPasteleColor();
  }
  static getLatestPasteleColor() {
    return ka.LATEST_PASTELE_COLOR;
  }
  static getLatestPasteleColorAndSetNew() {
    const Y = ka.getLatestPasteleColor();
    return ka.setNewLatestPasteleColor(), Y;
  }
  // REF-34
  // these colors are used before the above
  static generateDefaultColors() {
    return ArrayUtils.shuffle([
      "hsl(154deg 96% 90%)",
      "hsl(50deg 96% 90%)",
      "hsl(171deg 96% 90%)",
      "hsl(76deg 96% 90%)",
      "hsl(315deg 96% 90%)",
      "hsl(251deg 96% 90%)",
      "hsl(209deg 84% 92%)",
      "hsl(0deg 100% 81%)",
      "hsl(29deg 100% 79%)",
      "hsl(31deg 73% 75%)",
      "hsl(137deg 80% 80%)",
      "hsl(60deg 100% 82%)",
      "hsl(219deg 100% 84%)",
      "hsl(93deg 62% 74%)",
      "hsl(54deg 93% 84%)",
      "hsl(146deg 100% 90%)",
      "hsl(334deg 100% 87%)",
      "hsl(19deg 95% 84%)",
      "hsl(203deg 95% 84%)",
      "hsl(76deg 100% 78%)",
      "hsl(0deg 100% 86%)",
      "hsl(42deg 82% 82%)",
      "hsl(97deg 100% 87%)"
    ]);
  }
  // this is a solution for same label text across different columns to have the same colors
  static generateGlobalItemColors() {
    return {
      newColors: ka.generateDefaultColors(),
      existingColors: {}
    };
  }
};
_LabelColorUtils.LATEST_PASTELE_COLOR = _LabelColorUtils.generateNewPasteleColor();
let LabelColorUtils = _LabelColorUtils;
class ScrollbarUtils {
  static isVerticalPresent(Y) {
    return Y.scrollHeight > Y.clientHeight;
  }
  static isHorizontalPresent(Y) {
    return Y.scrollWidth > Y.clientWidth;
  }
}
const _CellDropdownHorizontalScrollFix = class Mi {
  static setPropertiesIfHorizontalScrollPresent(Y) {
    const { element: re, scrollbarPresence: oe, customDropdownStyle: ue } = Y;
    ScrollbarUtils.isHorizontalPresent(re) && ScrollbarUtils.isVerticalPresent(re) ? (oe.horizontal = !0, re.style.paddingBottom = Mi.NEW_BOTTOM_PADDING_IF_PRESENT) : (oe.horizontal = !1, re.style.paddingBottom = ue?.paddingBottom || Dropdown.DROPDOWN_VERTICAL_PX);
  }
  static scrollDownFurther(Y) {
    Y.scrollTop += Mi.SCROLL_FURTHER_BOTTOM_PX;
  }
};
_CellDropdownHorizontalScrollFix.NEW_BOTTOM_PADDING_IF_PRESENT = "8px";
_CellDropdownHorizontalScrollFix.SCROLL_FURTHER_BOTTOM_PX = 14;
let CellDropdownHorizontalScrollFix = _CellDropdownHorizontalScrollFix;
const _RGBAToHex = class Wi {
  static extractIndividualNumbers(Y) {
    return Y.match(Wi.REGEX);
  }
  static convert(Y) {
    return `#${Wi.extractIndividualNumbers(Y).slice(1).map(
      (re, oe) => (oe === 3 ? Math.round(parseFloat(re) * 255) : parseFloat(re)).toString(16).padStart(2, "0").replace("NaN", "")
    ).join("")}`;
  }
};
_RGBAToHex.REGEX = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)$/;
let RGBAToHex = _RGBAToHex;
const _OptionColorButton = class sa {
  // buttonLevelElement is either input or button
  static extractRelativeParentElements(Y) {
    var re;
    const oe = Y.parentElement, ue = (re = oe.previousSibling) == null ? void 0 : re.previousSibling, fe = oe.parentElement;
    return { containerElement: oe, textElement: ue, dropdownItemElement: fe };
  }
  static changeVisibility(Y, re, oe) {
    const ue = Y.children[2];
    if (ue.style.display = oe ? "block" : "none", oe) {
      const fe = ue.children[0], he = Browser.IS_SAFARI ? 9 : 5;
      fe.style.left = `${oe.offsetWidth - re + he}px`;
      const _e = ue.children[1];
      _e.style.left = `${oe.offsetWidth - re}px`;
    }
  }
  static createIcon() {
    const Y = document.createElement("div");
    return Y.innerText = sa.COLOR_ICON_TEXT, Y.classList.add(sa.COLOR_BUTTON_ICON_CLASS), Y;
  }
  static createButton() {
    const Y = document.createElement("div");
    Y.classList.add(OptionButton.BUTTON_CLASS, sa.COLOR_BUTTON_CLASS);
    const re = sa.createIcon();
    return Y.appendChild(re), Y;
  }
  static createInput() {
    const Y = document.createElement("input");
    return Y.type = "color", Y.style.top = Browser.IS_SAFARI ? "0px" : "14px", Y.classList.add(sa.COLOR_INPUT_CLASS), Y;
  }
  static createContainer() {
    const Y = document.createElement("div");
    return Y.classList.add(OptionButton.BUTTON_CONTAINER_CLASS), Y;
  }
  static create(Y, re) {
    const oe = sa.createContainer(), ue = sa.createInput();
    oe.appendChild(ue);
    const fe = sa.createButton();
    return oe.appendChild(fe), OptionColorButtonEvents.setEvents(oe, ue, Y, re), oe;
  }
};
_OptionColorButton.COLOR_INPUT_CLASS = "color-input";
_OptionColorButton.COLOR_BUTTON_CLASS = "option-color-button";
_OptionColorButton.COLOR_BUTTON_ICON_CLASS = "cell-dropdown-option-color-button-icon";
_OptionColorButton.COLOR_ICON_TEXT = "c";
let OptionColorButton = _OptionColorButton;
class OptionColorButtonEvents {
  static updateCellElements(Y, re) {
    const { itemText: oe, backgroundColor: ue } = re;
    Y.elements.slice(1).forEach((fe) => {
      const he = fe.children[0];
      he.innerText === oe && (he.style.backgroundColor = ue);
    });
  }
  // prettier-ignore
  static updateIfUpdatable(Y, re, oe) {
    const { itemText: ue, backgroundColor: fe } = oe, he = Y.cellDropdown.itemsDetails[ue];
    he && (!he.isCustomBackgroundColor || re === Y.activeType.name) && (he.backgroundColor = fe, OptionColorButtonEvents.updateCellElements(Y, oe));
  }
  // prettier-ignore
  static updateElements(Y, re, oe) {
    Y.forEach((ue) => {
      ue.cellDropdown.labelDetails && OptionColorButtonEvents.updateIfUpdatable(ue, re, oe);
    });
  }
  static updateColorStates(Y, re) {
    var oe, ue, fe;
    const { itemText: he, backgroundColor: _e } = re;
    (ue = (oe = Y.activeType.cellDropdownProps) == null ? void 0 : oe.options) == null || ue.forEach((xe) => {
      xe.text === he && (xe.backgroundColor = _e);
    });
    const ve = (fe = Y.cellDropdown.labelDetails) == null ? void 0 : fe.globalItemColors.existingColors;
    ve != null && ve[he] && (ve[he] = _e);
  }
  // prettier-ignore
  static updateColumnLabelColors(Y, re) {
    const { cellDropdown: { labelDetails: oe }, activeType: ue } = re;
    !oe || !oe.colorPickerNewValue || (OptionColorButtonEvents.updateColorStates(re, oe.colorPickerNewValue), OptionColorButtonEvents.updateElements(Y, ue.name, oe.colorPickerNewValue), delete oe.colorPickerNewValue, setTimeout(() => re.fireColumnsUpdate()));
  }
  // important to note that mouse/key down events are not fired when clicked on picker
  static windowEventClosePicker(Y, re) {
    if (re.cellDropdown) {
      const oe = re.cell.columnIndex;
      OptionButton.hideAfterColorPickerContainerClose(Y, Y[oe]);
    }
  }
  // bug fix comments are for code that fixes a firefox bug where color picker is still open after closing the dropdown
  static inputEvent(Y, re) {
    if (!Dropdown.isDisplayed(Y.element))
      return;
    const oe = re.target, { containerElement: ue, textElement: fe, dropdownItemElement: he } = OptionColorButton.extractRelativeParentElements(oe), _e = fe.textContent, ve = oe.value;
    he.style.backgroundColor = ve;
    const xe = Y.itemsDetails[_e];
    xe.backgroundColor !== ve && (xe.backgroundColor = ve, Y.labelDetails.colorPickerNewValue = { backgroundColor: ve, itemText: _e }, setTimeout(() => {
      var Ee;
      (Ee = Y.labelDetails).colorPickerContainer ?? (Ee.colorPickerContainer = ue);
    }));
  }
  // prettier-ignore
  static mouseDownContainer(Y, re, oe) {
    const { cellDropdown: { labelDetails: ue } } = re;
    if (!ue)
      return;
    if (ue.colorPickerContainer) {
      delete ue.colorPickerContainer, OptionColorButtonEvents.updateColumnLabelColors(Y, re);
      return;
    }
    const fe = oe.target, { containerElement: he, dropdownItemElement: _e } = OptionColorButton.extractRelativeParentElements(fe), ve = fe.previousSibling;
    ve.value = RGBAToHex.convert(getComputedStyle(_e).backgroundColor), ve.showPicker(), setTimeout(() => ue.colorPickerContainer = he);
  }
  // prettier-ignore
  static setEvents(Y, re, oe, ue) {
    Y.onmousedown = OptionColorButtonEvents.mouseDownContainer.bind(this, oe, ue), re.oninput = OptionColorButtonEvents.inputEvent.bind(this, ue.cellDropdown);
  }
}
class FocusNextRowCell {
  // does not work in Safari
  static focus(Y, re, oe, ue) {
    ue.preventDefault();
    const fe = oe[re + 1];
    fe && (fe.focus(), CaretPosition.setToEndOfText(Y, fe));
  }
  static focusOrBlurSelect(Y, re) {
    const oe = Y[re + 1];
    if (oe)
      return oe.dispatchEvent(new Event("mousedown")), oe.scrollIntoView({ block: "nearest" }), oe;
    Y[re].children[0].blur();
  }
}
const ARROW_DOWN_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="12" height="12">
  <g style="pointer-events: none" transform="matrix(0.6315789 0 0 0.6315789 0 0)">
    <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
      <path d="M0 87.5L350 507.5L700 87.5L0 87.5z" stroke="none" fill="#3e3e3e" fill-rule="nonzero" />
    </g>
  </g>
</svg>
`, _ArrowDownIconElement = class Ha {
  static toggle(Y, re) {
    if (!Y)
      return;
    const oe = Y.children[1];
    oe.style.display = re ? "block" : "none";
    const ue = oe.children[0];
    !re && ue.style.filter && (ue.style.filter = "");
  }
  static setActive(Y) {
    const re = Y.children[1].children[0];
    re.style.filter = `brightness(0) saturate(100%) invert(24%) sepia(73%) saturate(631%)
      hue-rotate(171deg) brightness(98%) contrast(98%)`;
  }
  // need a container to allow absolute positioning for the icon
  static createContainer() {
    const Y = document.createElement("div");
    return Y.classList.add(Ha.ARROW_ICON_CONTAINER_CLASS), Y.style.display = "none", Y;
  }
  // REF-10
  static createSVGElement() {
    const Y = SVGIconUtils.createSVGElement(ARROW_DOWN_ICON_SVG_STRING);
    return Y.classList.add(Ha.ARROW_ICON_CLASS), Y;
  }
  static createSVG() {
    const Y = Ha.createSVGElement(), re = Ha.createContainer();
    return re.appendChild(Y), re;
  }
  static get() {
    return Ha.ARROW_ICON_ELEMENT.cloneNode(!0);
  }
};
_ArrowDownIconElement.ARROW_ICON_CLASS = "arrow-down-icon";
_ArrowDownIconElement.ARROW_ICON_CONTAINER_CLASS = "arrow-down-icon-container";
_ArrowDownIconElement.ARROW_ICON_ELEMENT = _ArrowDownIconElement.createSVG();
let ArrowDownIconElement = _ArrowDownIconElement;
class TableBorderDimensionsUtils {
  static generateDefault() {
    return {
      leftWidth: 0,
      rightWidth: 0,
      topWidth: 0,
      bottomWidth: 0
    };
  }
  static getWidth(Y, re) {
    return Y.style[re] === "" ? 1 : Number.parseFloat(Y.style[re]) || 0;
  }
  static generateUsingElement(Y) {
    return {
      leftWidth: TableBorderDimensionsUtils.getWidth(Y, "borderLeftWidth"),
      rightWidth: TableBorderDimensionsUtils.getWidth(Y, "borderRightWidth"),
      topWidth: TableBorderDimensionsUtils.getWidth(Y, "borderTopWidth"),
      bottomWidth: TableBorderDimensionsUtils.getWidth(Y, "borderBottomWidth")
    };
  }
}
const _UpdateIndexColumnWidth = class pr {
  static wrapColumnTextAndGetDefaultWidth(Y) {
    const { _tableBodyElementRef: re, data: oe, _tableDimensions: ue } = Y;
    return ExtractElements.textRowsArrFromTBody(re, oe).forEach((fe) => {
      fe.children[0].classList.remove(IndexColumn.INDEX_CELL_OVERFLOW_CLASS);
    }), ue.isColumnIndexCellTextWrapped = !0, ToggleAdditionElements.update(Y, !0, AddNewColumnElement.toggle), IndexColumn.DEFAULT_WIDTH;
  }
  static changeTableWidths(Y, re) {
    const oe = re - Y._tableDimensions.indexColumnWidth;
    Y._tableDimensions.indexColumnWidth = re, TableElement.changeStaticWidthTotal(Y._tableDimensions, oe), StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(Y, !0);
  }
  static changeCellAndTableWidths(Y, re, oe) {
    const ue = re.children[0];
    pr.changeTableWidths(Y, oe), ue.style.width = `${oe}px`;
  }
  static forceWrap(Y, re) {
    const oe = pr.wrapColumnTextAndGetDefaultWidth(Y);
    pr.changeCellAndTableWidths(Y, re, oe);
  }
  static shouldTextBeWrapped(Y) {
    return !Y._tableDimensions.isColumnIndexCellTextWrapped && TableDimensionsUtils.hasSetTableWidthBeenBreached(Y);
  }
  static changeWidth(Y, re, oe) {
    pr.changeCellAndTableWidths(Y, re, oe), pr.shouldTextBeWrapped(Y) && pr.forceWrap(Y, re);
  }
  // important to note that on initial render if the font library has not been downloaded
  // scrollWidth will give the wrong number. This is usually not a problem when using
  // small numbers or cache
  static getCellWidth(Y) {
    return Y.scrollWidth + (Number.parseInt(getComputedStyle(Y).borderRightWidth) || 0);
  }
  // need to keep track of first cell because upon using pagination and uploading a new file, drag and droping a new file,
  // or using updateData method with a lot of data does not refresh the cell with original value
  // to reproduce the error, simply set the code in timeout to: firstCell.textContent = firstCellContent
  static temporarilySetFirstRowCellWithLastNumber(Y, re, oe) {
    const ue = Y.textContent;
    Y.id || (Y.id = re ? pr.TEMPORARY_INDEX_NUMBER : pr.TEMPORARY_INVISIBLE_INDEX_NUMBER), Y.textContent = oe.textContent, setTimeout(() => {
      Y.id !== "" && (Y.textContent = ue, Y.removeAttribute("id"));
    });
  }
  static getIndexColumnWidthWithAsyncFix(Y, re, oe) {
    if (oe.scrollWidth === 0) {
      const ue = Y.children[0];
      return pr.temporarilySetFirstRowCellWithLastNumber(ue, re, oe), pr.getCellWidth(ue);
    }
    return pr.getCellWidth(oe);
  }
  // this works because the 'block' display style is not set on the table
  // checking if the cells width is overflown and if so - increase its width (cannot decrease the width)
  static updateColumnWidthWhenOverflow(Y, re, oe) {
    const ue = !!Y.dataStartsAtHeader, fe = pr.getIndexColumnWidthWithAsyncFix(re, ue, oe);
    if (Y._tableDimensions.indexColumnWidth !== fe && fe !== 0) {
      const he = fe + (Browser.IS_FIREFOX ? 4 : 0);
      Browser.IS_SAFARI ? setTimeout(() => pr.changeWidth(Y, re, he)) : pr.changeWidth(Y, re, he);
    }
  }
  // when the table element display property is 'block', the 'overflow: hidden;' property does not actually work
  // and instead the lastCell width is changed automatically, all we do here is check if the expected width
  // (at.tableDimensions.indexColumnWidth) is different to the actual one and if so, we change it to actual
  static checkAutoColumnWidthUpdate(Y, re) {
    if (re.offsetWidth !== Y._tableDimensions.indexColumnWidth) {
      let oe = re.offsetWidth;
      Y.offsetWidth !== Y.scrollWidth && (oe = pr.wrapColumnTextAndGetDefaultWidth(Y)), pr.changeTableWidths(Y, oe);
    }
  }
  static updatedBasedOnTableStyle(Y, re, oe, ue = !1) {
    ue ? pr.forceWrap(Y, re) : Y._tableDimensions.preserveNarrowColumns || Y._tableDimensions.maxWidth !== void 0 ? pr.updateColumnWidthWhenOverflow(Y, re, oe) : Y._tableDimensions.width !== void 0 && pr.checkAutoColumnWidthUpdate(Y, oe);
  }
  static getFirstVisibleRow(Y) {
    const { _pagination: re, _tableBodyElementRef: oe, dataStartsAtHeader: ue } = Y;
    return ue && re ? re.visibleRows[0] : oe?.children[0];
  }
  static updatedBasedOnVisiblity(Y, re, oe = !1) {
    const ue = pr.getFirstVisibleRow(Y);
    Y._pagination && Y.filter ? ue ? pr.updatedBasedOnTableStyle(Y, ue, re, oe) : setTimeout(() => {
      const fe = pr.getFirstVisibleRow(Y);
      fe && pr.updatedBasedOnTableStyle(Y, fe, re, oe);
    }) : ue && pr.updatedBasedOnTableStyle(Y, ue, re, oe);
  }
  // used when a new row is added
  // forceWrap - REF-19
  static update(Y, re, oe = !1) {
    var ue;
    if (Y._tableDimensions.isColumnIndexCellTextWrapped)
      return;
    if (!re) {
      const { _tableBodyElementRef: he, data: _e } = Y;
      re = ExtractElements.textRowsArrFromTBody(he, _e);
    }
    const fe = (ue = re[re.length - 1]) == null ? void 0 : ue.children[0];
    fe && pr.updatedBasedOnVisiblity(Y, fe, oe);
  }
  // used when a new column is added to see if wrapping is needed
  // CAUTION-2 - this runs before re-render but stay cautions
  static wrapTextWhenNarrowColumnsBreached(Y) {
    Y._frameComponents.displayIndexColumn && pr.shouldTextBeWrapped(Y) && pr.update(Y, void 0, !0);
  }
};
_UpdateIndexColumnWidth.TEMPORARY_INDEX_NUMBER = "temp-index-number";
_UpdateIndexColumnWidth.TEMPORARY_INVISIBLE_INDEX_NUMBER = "temp-invisible-index-number";
let UpdateIndexColumnWidth = _UpdateIndexColumnWidth;
const _IndexColumn = class oa {
  static updateIndexes(Y, re) {
    const { _tableBodyElementRef: oe, data: ue, dataStartsAtHeader: fe } = Y, he = ExtractElements.textRowsArrFromTBody(oe, ue, re), _e = Number(fe);
    he.forEach((ve, xe) => {
      const Ee = ve.children[0], Se = re + xe + _e;
      Ee.innerText = String(Se);
    }), UpdateIndexColumnWidth.update(Y, he.length === 0 ? void 0 : he);
  }
  // prettier-ignore
  static createCell(Y, re) {
    var oe, ue;
    const { _tableDimensions: fe, _defaultColumnsSettings: he, _frameComponents: { styles: _e, cellColors: ve, inheritHeaderColors: xe } } = Y, Ee = CellElement.createBaseCell(re);
    Ee.classList.add(oa.INDEX_CELL_CLASS, GenericElementUtils.NOT_SELECTABLE_CLASS);
    const { displaySettings: Se, canEditHeaderRow: Te } = Y.rowDropdown;
    return Ee.style.cursor = (oe = Se.openMethod) != null && oe.cellClick && (!re || Te) ? "pointer" : "default", fe.isColumnIndexCellTextWrapped || Ee.classList.add(oa.INDEX_CELL_OVERFLOW_CLASS), Object.assign(Ee.style, he.cellStyle, _e?.default || {}), re && Object.assign(
      Ee.style,
      xe ? (ue = he.headerStyles) == null ? void 0 : ue.default : {},
      ve.header.default
    ), Ee;
  }
  static createHeaderCell(Y) {
    const re = oa.createCell(Y, !0);
    return Y.dataStartsAtHeader && (re.innerText = "1"), re.style.width = oa.DEFAULT_WIDTH_PX, Browser.IS_SAFARI && setTimeout(() => re.style.width = oa.DEFAULT_WIDTH_PX), re;
  }
  static createDataCell(Y, re) {
    const oe = oa.createCell(Y, !1), ue = Y.dataStartsAtHeader ? re + 1 : re;
    return oe.innerText = String(ue), oe;
  }
  static createAndPrependToRow(Y, re, oe) {
    const ue = oe === 0 ? oa.createHeaderCell(Y) : oa.createDataCell(Y, oe);
    Y._columnsDetails[0] && ColumnSettingsBorderUtils.unsetSubjectBorder([ue], Y._columnsDetails[0].elements, "right", 0), re.appendChild(ue);
  }
};
_IndexColumn.INDEX_CELL_CLASS = "index-cell";
_IndexColumn.INDEX_CELL_OVERFLOW_CLASS = "index-cell-overflow";
_IndexColumn.DEFAULT_WIDTH = 30;
_IndexColumn.DEFAULT_WIDTH_PX = `${_IndexColumn.DEFAULT_WIDTH}px`;
let IndexColumn = _IndexColumn;
const UNSET_NUMBER_IDENTIFIER = -1, _TableDimensionsUtils = class za {
  // REF-19
  static setIsColumnIndexCellTextWrapped(Y, re) {
    re && (typeof re == "object" && re.wrapIndexCellText ? Y.isColumnIndexCellTextWrapped = !0 : Y.isColumnIndexCellTextWrapped === void 0 && (Y.isColumnIndexCellTextWrapped = !1));
  }
  static setPreserveNarrowColumnsProp(Y, re) {
    re.preserveNarrowColumns = Y.preserveNarrowColumns;
  }
  // prettier-ignore
  static setDimension(Y, re) {
    const { tableStyle: oe, _tableDimensions: ue, _tableElementRef: fe, parentElement: he } = Y;
    if (!fe || !he)
      return;
    const _e = StringDimensionUtils.generateNumberDimensionFromClientString(
      he,
      oe,
      re,
      !0,
      za.MINIMAL_TABLE_WIDTH
    );
    _e.number > 0 && (Y.overflow && OverflowUtils.processNumberDimension(ue, _e), ue[re] = _e.number, ue.isPercentage = _e.isPercentage);
  }
  // CAUTION-3
  // prettier-ignore
  static setTableDimensions(Y) {
    const { tableStyle: re, _tableDimensions: oe, _frameComponents: { displayIndexColumn: ue } } = Y;
    re.width !== void 0 ? za.setDimension(Y, "width") : re.maxWidth !== void 0 && za.setDimension(Y, "maxWidth"), za.setPreserveNarrowColumnsProp(Y, oe), za.setIsColumnIndexCellTextWrapped(oe, ue);
  }
  static hasSetTableWidthBeenBreached(Y) {
    const { width: re, maxWidth: oe } = Y._tableDimensions, ue = Y.offsetWidth, fe = re || oe;
    return fe ? Math.ceil(fe) < ue : !1;
  }
  static record(Y) {
    Y._tableDimensions.recordedParentWidth = Y.parentElement.offsetWidth, Y._tableDimensions.recordedParentHeight = Y.parentElement.offsetHeight, Y._tableDimensions.recordedWindowWidth = window.innerWidth, Y._tableDimensions.recordedWindowHeight = window.innerHeight;
  }
  static getDefault() {
    return {
      recordedParentWidth: 0,
      recordedParentHeight: 0,
      recordedWindowWidth: 0,
      recordedWindowHeight: 0,
      border: TableBorderDimensionsUtils.generateDefault(),
      staticWidth: UNSET_NUMBER_IDENTIFIER,
      newColumnWidth: 140,
      indexColumnWidth: IndexColumn.DEFAULT_WIDTH
    };
  }
};
_TableDimensionsUtils.MINIMAL_TABLE_WIDTH = 70;
let TableDimensionsUtils = _TableDimensionsUtils;
class MaximumRows {
  static canAddMore(Y) {
    var re;
    const { _columnsDetails: oe, maxRows: ue } = Y, fe = (re = oe[0]) == null ? void 0 : re.elements.length;
    return !(fe !== void 0 && ue !== void 0 && ue > 0 && ue <= fe);
  }
}
class FrameComponentsColors {
  // prettier-ignore
  static getInheritedHeaderColors(Y) {
    var re, oe, ue, fe, he, _e;
    const { _defaultColumnsSettings: { headerStyles: ve, cellStyle: xe } } = Y;
    return {
      default: {
        backgroundColor: ((re = ve?.default) == null ? void 0 : re.backgroundColor) || xe?.backgroundColor || "",
        color: ((oe = ve?.default) == null ? void 0 : oe.color) || xe?.color || ""
      },
      hover: {
        backgroundColor: ((ue = ve?.hoverColors) == null ? void 0 : ue.backgroundColor) || ((fe = ve?.default) == null ? void 0 : fe.backgroundColor) || xe?.backgroundColor || Y._defaultCellHoverColors.backgroundColor,
        color: ((he = ve?.hoverColors) == null ? void 0 : he.color) || ((_e = ve?.default) == null ? void 0 : _e.color) || xe?.color || Y._defaultCellHoverColors.color
      }
    };
  }
  // prettier-ignore
  static getHoverColorValue(Y, re) {
    var oe, ue, fe;
    const { _frameComponents: { styles: he }, _defaultCellHoverColors: _e } = Y;
    return ((oe = he?.hoverColors) == null ? void 0 : oe[re]) || ((ue = he?.default) == null ? void 0 : ue[re]) || ((fe = Y._defaultColumnsSettings.cellStyle) == null ? void 0 : fe[re]) || _e[re];
  }
  static getDefaultColorValue(Y, re) {
    var oe, ue, fe;
    return ((ue = (oe = Y._frameComponents.styles) == null ? void 0 : oe.default) == null ? void 0 : ue[re]) || ((fe = Y._defaultColumnsSettings.cellStyle) == null ? void 0 : fe[re]) || "";
  }
  // prettier-ignore
  static setEventColors(Y) {
    const re = {
      default: {
        backgroundColor: FrameComponentsColors.getDefaultColorValue(Y, "backgroundColor"),
        color: FrameComponentsColors.getDefaultColorValue(Y, "color")
      },
      hover: {
        backgroundColor: FrameComponentsColors.getHoverColorValue(Y, "backgroundColor"),
        color: FrameComponentsColors.getHoverColorValue(Y, "color")
      }
    }, { _frameComponents: { cellColors: oe, inheritHeaderColors: ue } } = Y;
    oe.data = re, oe.header = ue ? FrameComponentsColors.getInheritedHeaderColors(Y) : re;
  }
  static getColorsBasedOnParam(Y, re) {
    const { data: oe, header: ue } = Y;
    return re === 0 ? ue : oe;
  }
  static getDefaultCellColors() {
    return {
      data: {
        default: { backgroundColor: "", color: "" },
        hover: { backgroundColor: "", color: "" }
      },
      header: {
        default: { backgroundColor: "", color: "" },
        hover: { backgroundColor: "", color: "" }
      }
    };
  }
}
class CellHighlightUtils {
  static fade(Y, re) {
    Y.style.backgroundColor = re?.backgroundColor || "", Y.style.color = re?.color || "";
  }
  static highlight(Y, re) {
    re != null && re.backgroundColor && (Y.style.backgroundColor = re.backgroundColor), re != null && re.color && (Y.style.color = re.color);
  }
  static unsetDefaultHoverProperties(Y) {
    Y.backgroundColor = "", Y.color = "";
  }
  static getDefaultHoverProperties() {
    return { backgroundColor: "#f7f7f7", color: "" };
  }
}
class ElementOffset {
  static processLeft(Y, re) {
    return Browser.IS_FIREFOX ? Y += re.leftWidth : Browser.IS_SAFARI && (Y -= re.leftWidth), Y;
  }
  static processTop(Y, re) {
    return Browser.IS_FIREFOX ? Y += re.topWidth : Browser.IS_SAFARI && (Y -= re.topWidth), Y;
  }
  static processWidth(Y, re) {
    return Browser.IS_FIREFOX && (Y += re.leftWidth), Y;
  }
}
class VisibilityUtils {
  static headerChanged(Y) {
    setTimeout(() => {
      Y._visiblityInternal.filters && FilterInternalUtils.resetAllInputs(Y);
    });
  }
  static completeReset(Y) {
    Y._visiblityInternal.filters && FilterInternalUtils.completeReset(Y);
  }
}
const _CaretDisplayFix = class la {
  static removeContentEditable(Y) {
    Y.removeAttribute(la.CONTENT_EDITABLE);
  }
  // THIS HAS TO BE CALLED IN A FOCUS EVENT!!!!!!!!!!!!!!!!!
  static setContentEditable(Y) {
    Y.setAttribute(la.CONTENT_EDITABLE, "true");
  }
  static removeTabIndex(Y) {
    Y.removeAttribute(la.TAB_INDEX);
  }
  static setTabIndex(Y) {
    Y.setAttribute(la.TAB_INDEX, "0");
  }
  static removeBRPadding(Y, re) {
    const oe = CellElement.getTextElement(re).childNodes[0];
    oe.tagName === la.BR_TAG_NAME && (oe.remove(), CaretPosition.setToEndOfText(Y, re));
  }
  static addBRPaddingToEmptyCell(Y, re) {
    const oe = CellElement.getTextElement(Y);
    re === EMPTY_STRING && oe.childNodes.length === 0 && oe.appendChild(document.createElement(la.BR_TAG_NAME));
  }
  // caret is placed too far on top left
  // this happens when cell text is programmatically set to empty or when the user doubeclicks text and clicks backspace
  // natively firefox adds a 'br' element to replace the text when the user deletes it when clicking backspace for each
  // letter however it does not for the cases outlined previously, hence this is needed
  static toggleCellTextBRPadding(Y, re, oe) {
    const ue = CellElement.getText(re);
    oe && ue !== EMPTY_STRING ? la.removeBRPadding(Y, re) : la.addBRPaddingToEmptyCell(re, ue);
  }
  static isIssueBrowser() {
    return Browser.IS_FIREFOX || Browser.IS_SAFARI;
  }
};
_CaretDisplayFix.CONTENT_EDITABLE = "contenteditable";
_CaretDisplayFix.TAB_INDEX = "tabindex";
_CaretDisplayFix.BR_TAG_NAME = "BR";
let CaretDisplayFix = _CaretDisplayFix;
const _CellTextElement = class vi {
  static set(Y, re) {
    Y.innerText = "", Y.contentEditable = "false", CaretDisplayFix.isIssueBrowser() && CaretDisplayFix.removeTabIndex(Y), Y.appendChild(re);
  }
  static createTextElement(Y, re) {
    const oe = document.createElement("div");
    return oe.innerText = Y, Y === "" && CaretDisplayFix.addBRPaddingToEmptyCell(oe, ""), oe.classList.add(vi.CELL_TEXT_DIV_CLASS), CellElement.prepContentEditable(oe, re), oe;
  }
  static setCellTextAsAnElement(Y, re) {
    const oe = CellElement.getText(Y), ue = vi.createTextElement(oe, re);
    return vi.set(Y, ue), ue;
  }
};
_CellTextElement.CELL_TEXT_DIV_CLASS = "cell-text-div";
let CellTextElement = _CellTextElement;
const _HeaderIconCellElement = class ca {
  static createTextElement(Y, re) {
    const oe = CellTextElement.setCellTextAsAnElement(Y, re);
    return oe.classList.add(ca.TEXT_CLASS), oe.style.pointerEvents = re ? "" : "none", oe;
  }
  static setScale(Y, re) {
    const oe = re?.x || 1.2, ue = re?.y || 1.2, fe = `scale(${oe}, ${ue})`;
    Y.style.transform = fe, Y.style.webkitTransform = fe;
  }
  static createSvgIcon(Y, re) {
    var oe, ue;
    const fe = SVGIconUtils.createSVGElement(Y.svgString);
    return ca.setScale(fe, (oe = re.headerIconStyle) == null ? void 0 : oe.scale), fe.style.filter = ((ue = re.headerIconStyle) == null ? void 0 : ue.filterColor) || SVGIconUtils.HEADER_FILTER, fe;
  }
  static createSVGContainer(Y) {
    const re = document.createElement("div"), { containerStyles: oe } = Y;
    return oe != null && oe.dropdown && Object.assign(re.style, oe?.dropdown), oe != null && oe.headerCorrections && Object.assign(re.style, oe?.headerCorrections), re.classList.add(ca.ICON_CONTAINER_CLASS), re;
  }
  static createSVG(Y, re) {
    const oe = ca.createSVGContainer(Y), ue = ca.createSvgIcon(Y, re);
    return oe.appendChild(ue), oe;
  }
  static changeHeaderIcon(Y) {
    const { elements: re, activeType: oe, settings: ue } = Y, fe = ca.createSVG(oe.dropdownItem.settings.iconSettings, ue), he = re[0];
    he.replaceChild(fe, he.children[0]);
  }
  static setHeaderIconStructure(Y, re, oe) {
    var ue, fe, he;
    const { activeType: _e, settings: ve } = Y._columnsDetails[oe], xe = ca.createSVG(_e.dropdownItem.settings.iconSettings, ve), Ee = (he = (fe = (ue = Y._defaultColumnsSettings.columnDropdown) == null ? void 0 : ue.displaySettings) == null ? void 0 : fe.openMethod) == null ? void 0 : he.cellClick, Se = ve.isHeaderTextEditable && !Ee, Te = ca.createTextElement(re, Se);
    re.insertBefore(xe, Te);
  }
};
_HeaderIconCellElement.TEXT_CLASS = "header-icon-side-text";
_HeaderIconCellElement.ICON_CONTAINER_CLASS = "header-icon-container";
let HeaderIconCellElement = _HeaderIconCellElement;
const _DateCellInputElement = class Qr {
  static isInputElement(Y) {
    return Y?.type === Qr.ELEMENT_TYPE;
  }
  static toggle(Y, re) {
    if (!Y)
      return;
    const oe = Y.children[1];
    oe.style.display = re ? "block" : "none";
  }
  static extractInputElementFromCell(Y) {
    return Y.children[1].children[0];
  }
  static convertTextToInputValue(Y, re) {
    if (re.calendar && (re.textValidation.func === void 0 || re.textValidation.func(Y))) {
      const oe = re.calendar.toYMDFunc(Y);
      return [oe[0], oe[1].padStart(2, "0"), oe[2].padStart(2, "0")].join("-");
    }
    return "-";
  }
  static updateInputBasedOnTextDiv(Y, re) {
    const oe = Qr.convertTextToInputValue(CellElement.getText(Y), re);
    Qr.extractInputElementFromCell(Y).value = oe;
  }
  static createInputElement(Y, re) {
    const oe = document.createElement("input");
    return oe.type = Qr.ELEMENT_TYPE, oe.classList.add(Qr.DATE_INPUT_CLASS), oe.value = Qr.convertTextToInputValue(Y, re), oe;
  }
  static createInputElementContainer() {
    const Y = document.createElement("div");
    return Y.classList.add(Qr.DATE_INPUT_CONTAINER_CLASS), Y.style.display = "none", Y;
  }
  static addDateInputElement(Y, re, oe) {
    const ue = Qr.createInputElementContainer(), fe = Qr.createInputElement(CellElement.getText(re), oe);
    ue.appendChild(fe);
    const he = DateCellCalendarIconElement.get();
    ue.appendChild(he), Y.appendChild(ue);
  }
};
_DateCellInputElement.ELEMENT_TYPE = "date";
_DateCellInputElement.DATE_INPUT_CLASS = "date-input";
_DateCellInputElement.DATE_INPUT_CONTAINER_CLASS = "date-input-container";
let DateCellInputElement = _DateCellInputElement;
class DateCellTextElement {
  static convertInputValueToText(Y, re, oe) {
    const ue = RegexUtils.extractIntegerStrs(Y);
    return ue ? oe.fromYMDFunc(ue) : re;
  }
  static setCellTextAsAnElement(Y, re) {
    const oe = CellTextElement.setCellTextAsAnElement(Y, re);
    return oe.style.float = "left", oe;
  }
}
const _DateCellCalendarIconEvents = class Hi {
  static mouseDownIcon(Y, re, oe) {
    const { _focusedElements: ue, _activeOverlayElements: fe } = this, he = oe.target.previousSibling, _e = CellElement.getCellElement(he);
    setTimeout(() => {
      FocusedCellUtils.set(ue.cell, _e, Y, re), fe.datePickerCell = _e, Browser.IS_SAFARI ? he.dispatchEvent(new MouseEvent("click")) : he.showPicker();
    }, Hi.PICKER_DISPLAY_DELAY_ML);
  }
  static setEvents(Y, re, oe, ue) {
    re.onmousedown = Hi.mouseDownIcon.bind(Y, oe, ue);
  }
};
_DateCellCalendarIconEvents.PICKER_DISPLAY_DELAY_ML = Browser.IS_FIREFOX ? 190 : 0;
let DateCellCalendarIconEvents = _DateCellCalendarIconEvents;
var MOUSE_EVENT = /* @__PURE__ */ ((le) => (le.DOWN = "Down", le))(MOUSE_EVENT || {});
class DateCellInputEvents {
  // outstanding bug is when the user opens picker and moves with arrow keys, then clicks escape
  // the picker fires a clear event and does not actually close itself and instead goes to the
  // initially opened up date. The key up event for the escape button is also not fired.
  static escapeKeyInput(Y) {
    if (Y._activeOverlayElements.datePickerCell) {
      const re = Y._focusedElements.cell.element;
      Y._hoveredElements.dateCell !== re && DateCellInputElement.toggle(re, !1), delete Y._activeOverlayElements.datePickerCell;
    }
  }
  // this is triggered when a date is selected via the date picker
  // prettier-ignore
  static inputInput(Y, re, oe) {
    const { elements: ue, settings: { defaultText: fe }, activeType: { calendar: he } } = this._columnsDetails[re];
    if (!he)
      return;
    const _e = oe.target.value, ve = DateCellTextElement.convertInputValueToText(_e, fe, he), xe = ue[Y];
    CellEvents.updateCell(this, ve, Y, re, { element: xe });
  }
  // this is triggered when the user clicks on picker buttons
  static changeInput() {
    const Y = this._focusedElements.cell.element;
    !this._userKeyEventsState[MOUSE_EVENT.DOWN] && // do not hide icon when currently hovered
    this._hoveredElements.dateCell !== Y && DateCellInputElement.toggle(Y, !1), delete this._activeOverlayElements.datePickerCell;
  }
  // the user does not use the actual input element and the events are triggered via the date picker
  static setEvents(Y, re, oe, ue) {
    re.onchange = DateCellInputEvents.changeInput.bind(Y), re.oninput = DateCellInputEvents.inputInput.bind(Y, oe, ue);
  }
}
class FocusNextColumnCellFromTextDiv {
  static focusDifferentColumnCell(Y, re, oe) {
    const { elements: ue, activeType: fe, settings: he } = Y._columnsDetails[re], _e = ue[oe];
    if (!he.isCellTextEditable || oe === 0 && !he.isHeaderTextEditable || // REF-29
    Browser.IS_SAFARI && CheckboxCellElement.isCheckboxCell(_e))
      return FocusNextColumnCellFromTextDiv.focusOrBlurNext(Y, re, oe);
    fe.cellDropdownProps ? _e.dispatchEvent(new Event("mousedown")) : (CellWithTextEvents.programmaticBlur(Y), CellElement.getTextElement(_e).focus()), _e.scrollIntoView({ block: "nearest" });
  }
  static focusOrBlurNextRowFirstCell(Y, re) {
    const oe = Y._columnsDetails[0], ue = re + 1;
    oe.elements[ue] ? FocusNextColumnCellFromTextDiv.focusDifferentColumnCell(Y, 0, ue) : Y._focusedElements.cell.element.children[0].blur();
  }
  static focusOrBlurNext(Y, re, oe) {
    Y._columnsDetails[re + 1] ? FocusNextColumnCellFromTextDiv.focusDifferentColumnCell(Y, re + 1, oe) : FocusNextColumnCellFromTextDiv.focusOrBlurNextRowFirstCell(Y, oe);
  }
}
class CellTextEvents {
  static tabOutOfCell(Y, re, oe, ue) {
    ue.preventDefault(), DataCellEvents.keyDownCell.bind(Y, re, oe)(ue), FocusNextColumnCellFromTextDiv.focusOrBlurNext(Y, oe, re);
  }
}
class DateCellTextEvents {
  static keyDownOnText(Y, re, oe) {
    oe.key === KEYBOARD_KEY.TAB && CellTextEvents.tabOutOfCell(this, Y, re, oe);
  }
  static inputText(Y, re) {
    if (Browser.IS_INPUT_DATE_SUPPORTED) {
      const { activeType: oe } = this._columnsDetails[Y], ue = CellElement.getCellElement(re.target);
      DateCellInputElement.updateInputBasedOnTextDiv(ue, oe);
    }
  }
  static blurText(Y, re, oe) {
    const ue = oe.target;
    DataCellEvents.blur(this, Y, re, ue);
  }
  static setEvents(Y, re, oe, ue) {
    Y._columnsDetails[ue].settings.isCellTextEditable && (re.onfocus = CellWithTextEvents.focusText.bind(Y, oe, ue, null), re.onblur = DateCellTextEvents.blurText.bind(Y, oe, ue), re.oninput = DateCellTextEvents.inputText.bind(Y, ue), re.onkeydown = DateCellTextEvents.keyDownOnText.bind(Y, oe, ue));
  }
}
class DateCellEvents {
  static mouseLeaveCell(Y) {
    if (delete this._hoveredElements.dateCell, Browser.IS_INPUT_DATE_SUPPORTED) {
      const re = Y.target;
      if (this._activeOverlayElements.datePickerCell === re)
        return;
      DateCellInputElement.toggle(re, !1);
    }
  }
  static mouseEnterCell(Y) {
    this._hoveredElements.dateCell = Y.target, Browser.IS_INPUT_DATE_SUPPORTED && DateCellInputElement.toggle(this._hoveredElements.dateCell, !0);
  }
  static setEvents(Y, re, oe, ue) {
    if (!Y._columnsDetails[ue].settings.isCellTextEditable)
      return;
    re.onblur = () => {
    }, re.onfocus = () => {
    }, re.onmouseenter = DateCellEvents.mouseEnterCell.bind(Y), re.onmouseleave = DateCellEvents.mouseLeaveCell.bind(Y), re.onmousedown = CellWithTextEvents.mouseDown.bind(Y, null);
    const fe = re.children[0];
    if (DateCellTextEvents.setEvents(Y, fe, oe, ue), Browser.IS_INPUT_DATE_SUPPORTED) {
      const he = re.children[1];
      DateCellInputEvents.setEvents(Y, he, oe, ue);
      const _e = he.children[1];
      DateCellCalendarIconEvents.setEvents(Y, _e, oe, ue);
    }
  }
}
class DateCellElement {
  // prettier-ignore
  static setCellDateStructure(Y, re, oe) {
    ConvertCellTypeUtils.preprocessCell(re), re.style.cursor = "text";
    const { isCellTextEditable: ue } = Y._columnsDetails[oe].settings, fe = DateCellTextElement.setCellTextAsAnElement(re, ue);
    Browser.IS_INPUT_DATE_SUPPORTED && DateCellInputElement.addDateInputElement(
      re,
      fe,
      Y._columnsDetails[oe].activeType
    );
  }
  static setColumnDateStructure(Y, re) {
    CellStructureUtils.setColumn(Y, re, DateCellElement.setCellDateStructure, DateCellEvents.setEvents);
  }
}
const _SelectCellTextElement = class Ki {
  static setCellTextAsAnElement(Y, re, oe) {
    const { isCellTextEditable: ue } = Y._columnsDetails[oe].settings;
    CellTextElement.setCellTextAsAnElement(re, ue).classList.add(Ki.TEXT_CLASS);
  }
  // prettier-ignore
  static finaliseEditedText(Y, re, oe) {
    var ue, fe;
    const he = Y._columnsDetails[oe], { cellDropdown: _e, activeType: ve, settings: xe } = he, Ee = CellElement.getText(re), Se = !!((ue = _e.itemsDetails[Ee]) != null && ue.backgroundColor);
    (fe = ve.cellDropdownProps) != null && fe.canAddMoreOptions && Ee !== EMPTY_STRING && !Se && (!xe.isDefaultTextRemovable || Ee !== xe.defaultText) && CellDropdownItem.addNewItem(Y, re, he, re.style.backgroundColor);
  }
};
_SelectCellTextElement.TEXT_CLASS = "select-cell-text";
let SelectCellTextElement = _SelectCellTextElement;
class SelectCellBaseEvents {
  static blurIfDropdownFocused(Y) {
    Y._focusedElements.cellDropdown && CellWithTextEvents.programmaticBlur(Y);
  }
}
class SelectCellEvents {
  static mouseLeaveCell(Y, re) {
    delete this._hoveredElements.selectCell;
    const oe = re.target, { cellDropdown: ue } = this._columnsDetails[Y];
    (!Dropdown.isDisplayed(ue.element) || ue.displayedCellElement !== oe) && ArrowDownIconElement.toggle(oe, !1);
  }
  static mouseEnterCell(Y) {
    this._hoveredElements.selectCell = Y.target, ArrowDownIconElement.toggle(this._hoveredElements.selectCell, !0);
  }
  static mouseDownCell(Y) {
    var re;
    const oe = Y.target;
    if (oe.classList.contains(CellElement.CELL_CLASS))
      CellWithTextEvents.mouseDownCell(this, SelectCellBaseEvents.blurIfDropdownFocused, oe, Y);
    else if (oe.classList.contains(ArrowDownIconElement.ARROW_ICON_CLASS)) {
      const ue = (re = oe.parentElement) == null ? void 0 : re.parentElement;
      CellWithTextEvents.mouseDownCell(this, SelectCellBaseEvents.blurIfDropdownFocused, ue, Y);
    }
  }
  static setEvents(Y, re, oe, ue) {
    if (!Y._columnsDetails[ue].settings.isCellTextEditable)
      return;
    re.onblur = () => {
    }, re.onfocus = () => {
    }, re.onmouseenter = SelectCellEvents.mouseEnterCell.bind(Y), re.onmouseleave = SelectCellEvents.mouseLeaveCell.bind(Y, ue), re.onmousedown = SelectCellEvents.mouseDownCell.bind(Y);
    const fe = re.children[0];
    SelectCellTextBaseEvents.setEvents(Y, fe, oe, ue);
  }
}
class SelectCellElement {
  static setCellSelectStructure(Y, re, oe) {
    ConvertCellTypeUtils.preprocessCell(re), SelectCellTextElement.setCellTextAsAnElement(Y, re, oe), re.appendChild(ArrowDownIconElement.get()), SelectCell.setPointerCursorIfCantAdd(re, Y._columnsDetails[oe].activeType);
  }
  static setColumnSelectStructure(Y, re) {
    CellStructureUtils.setColumn(Y, re, SelectCellElement.setCellSelectStructure, SelectCellEvents.setEvents);
  }
}
class LabelCellEvents {
  static setEvents(Y, re, oe, ue) {
    if (!Y._columnsDetails[ue].settings.isCellTextEditable)
      return;
    re.onblur = () => {
    }, re.onfocus = () => {
    }, re.onmouseenter = () => {
    }, re.onmouseleave = () => {
    }, re.onmousedown = CellWithTextEvents.mouseDown.bind(Y, SelectCellBaseEvents.blurIfDropdownFocused);
    const fe = re.children[0];
    SelectCellTextBaseEvents.setEvents(Y, fe, oe, ue);
  }
}
class LabelCellElement {
  // prettier-ignore
  static setCellLabelStructure(Y, re, oe) {
    var ue;
    ConvertCellTypeUtils.preprocessCell(re);
    const { cellDropdown: { itemsDetails: fe }, settings: { isCellTextEditable: he } } = Y._columnsDetails[oe], _e = ((ue = fe[CellElement.getText(re)]) == null ? void 0 : ue.backgroundColor) || "";
    LabelCellTextElement.setCellTextAsAnElement(re, _e, he), SelectCell.setPointerCursorIfCantAdd(re, Y._columnsDetails[oe].activeType);
  }
  static setColumnLabelStructure(Y, re) {
    CellStructureUtils.setColumn(Y, re, LabelCellElement.setCellLabelStructure, LabelCellEvents.setEvents);
  }
}
class SelectCell {
  static convertCell(Y, re, oe) {
    var ue;
    (ue = Y._columnsDetails[re].activeType.cellDropdownProps) != null && ue.isBasicSelect ? SelectCellElement.setCellSelectStructure(Y, oe, re) : LabelCellElement.setCellLabelStructure(Y, oe, re);
  }
  static convertColumn(Y, re, oe) {
    var ue;
    (ue = oe.cellDropdownProps) != null && ue.isBasicSelect ? SelectCellElement.setColumnSelectStructure(Y, re) : LabelCellElement.setColumnLabelStructure(Y, re);
  }
  static setEvents(Y, re, oe, ue) {
    var fe;
    const { activeType: he } = Y._columnsDetails[ue];
    (fe = he.cellDropdownProps) != null && fe.isBasicSelect ? SelectCellEvents.setEvents(Y, re, oe, ue) : LabelCellEvents.setEvents(Y, re, oe, ue);
  }
  // prettier-ignore
  static finaliseEditedText(Y, re, oe, ue = !1) {
    var fe;
    const { activeType: he } = Y._columnsDetails[oe];
    (fe = he.cellDropdownProps) != null && fe.isBasicSelect ? SelectCellTextElement.finaliseEditedText(Y, re, oe) : LabelCellTextElement.finaliseEditedText(Y, re, oe, ue);
  }
  static setPointerCursorIfCantAdd(Y, re) {
    var oe;
    if (Y.style.cursor = "pointer", !((oe = re.cellDropdownProps) != null && oe.canAddMoreOptions)) {
      const ue = Y.children[0];
      ue.style.caretColor = "transparent", ue.style.cursor = "pointer";
    }
  }
}
class DataCellElement {
  static setCellDataStructure(Y, re, oe) {
    re.innerText = CellElement.getTextElement(re).innerText;
    const { isCellTextEditable: ue } = Y._columnsDetails[oe].settings;
    CellElement.prepContentEditable(re, ue);
  }
  static setColumnDataStructure(Y, re) {
    CellStructureUtils.setColumn(Y, re, DataCellElement.setCellDataStructure, DataCellEvents.setEvents);
  }
}
class ChangeColumnType {
  static setInvalidCellToDefault(Y, re, oe) {
    const ue = re + 1, fe = Y._columnsDetails[oe].elements[ue];
    return CellEvents.setCellToDefaultIfNeeded(Y, ue, oe, fe, !1);
  }
  static setInvalidCellsToDefault(Y, re) {
    let oe = !1;
    Y.data.slice(1).forEach((ue, fe) => {
      ChangeColumnType.setInvalidCellToDefault(Y, fe, re) && !oe && (oe = !0);
    }), oe && setTimeout(() => FireEvents.onDataUpdate(Y));
  }
  static setNew(Y, re, oe) {
    const ue = Y._columnsDetails[oe];
    return ue.activeType = ue.settings.types.find((fe) => fe.name === re), ue.activeType;
  }
  static setNewStructureBasedOnType(Y, re, oe) {
    delete Y._columnsDetails[re].cellDropdown.labelDetails, oe.cellDropdownProps ? (CellDropdown.setUpDropdown(Y, re), SelectCell.convertColumn(Y, re, oe)) : oe.calendar ? DateCellElement.setColumnDateStructure(Y, re) : oe.checkbox ? CheckboxCellElement.setColumnCheckboxStructure(Y, re) : DataCellElement.setColumnDataStructure(Y, re);
  }
  // this is required as switching to another type makes it difficult to overwrite text element (as there isn't one) for
  // checkboxes when validation fails
  static resetCheckboxElements(Y) {
    Y.elements.slice(1).forEach((re) => {
      re.innerText = CellElement.getText(re);
    });
  }
  static resetAndChangeFunc(Y, re, oe) {
    const ue = Y._columnsDetails[oe];
    ue.activeType.checkbox && ChangeColumnType.resetCheckboxElements(ue);
    const fe = ChangeColumnType.setNew(Y, re, oe);
    fe.textValidation.func && fe.textValidation.setTextToDefaultOnFail && ChangeColumnType.setInvalidCellsToDefault(Y, oe), ChangeColumnType.setNewStructureBasedOnType(Y, oe, fe), Y.displayHeaderIcons && HeaderIconCellElement.changeHeaderIcon(Y._columnsDetails[oe]), setTimeout(() => FireEvents.onColumnsUpdate(Y));
  }
  // prettier-ignore
  static change(Y, re) {
    const oe = this._columnsDetails[re].activeType;
    Y !== oe.name && ProcessedDataTextStyle.resetDataCellsStyle(
      this,
      re,
      ChangeColumnType.resetAndChangeFunc.bind(this, this, Y, re)
    );
  }
}
class CheckboxValidationFunc {
  // cannot place this inside the CheckboxCellElement class as certain dependencies are not imported in time
  static getDefault() {
    return (Y) => {
      const re = String(Y).trim().toLocaleLowerCase();
      return re === "" || re === "0" || re === "00" || re === "false" ? "false" : "true";
    };
  }
}
const CURRENCY_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16">
	<g transform="matrix(0.84210527 0 0 0.84210527 0 0)">
		<g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
			<g>
				<path d="M441.1 297.29C 422.358 282.915 397.057 271.728 364.155 263.138L364.155 263.138L364.155 113.058C 378.792 114.1439 405.382 119.14 452.362 140.058C 458.8308 142.9291 466.339 142.1322 472.061 137.97209C 477.7837 133.81189 480.854 126.91709 480.1157 119.87809C 479.38132 112.84289 474.9477 106.73009 468.4867 103.843094C 413.2097 79.230095 381.8067 74.17909 364.15668 73.300095L364.15668 73.300095L364.15668 42.152092C 364.15668 34.335693 357.82077 27.996092 350.00067 27.996092C 342.18057 27.996092 335.84467 34.33589 335.84467 42.152092L335.84467 42.152092L335.84467 73.93709C 307.65366 76.28479 280.86768 87.23009 259.09866 105.29208C 234.52066 125.13208 220.09067 154.91309 219.75467 186.49509C 219.5242 216.7761 234.14967 245.24908 258.89966 262.7021C 277.64166 277.0771 302.94266 288.2641 335.84467 296.8541L335.84467 296.8541L335.84467 446.93408C 321.20767 445.84818 294.60666 440.84818 247.63766 419.93408L247.63766 419.93408L247.63766 419.93018C 241.16887 417.05908 233.66066 417.856 227.93866 422.01608C 222.21596 426.17627 219.14566 433.07108 219.88396 440.11008C 220.61833 447.14526 225.05196 453.2581 231.51295 456.14508C 286.72797 480.73108 318.18097 485.80908 335.84296 486.69608L335.84296 486.69608L335.84296 517.8371C 335.84296 525.6535 342.17886 531.9931 349.99896 531.9931C 357.81906 531.9931 364.15497 525.6533 364.15497 517.8371L364.15497 517.8371L364.15497 486.0521C 392.34598 483.7044 419.13196 472.7591 440.90097 454.69708C 465.47897 434.8571 479.90897 405.07608 480.24496 373.49408C 480.47543 343.21307 465.84998 314.74008 441.09998 297.28708L441.09998 297.28708L441.1 297.29zM282.99 231.22801C 268.099 221.23581 259.232 204.42702 259.392 186.49802C 259.81778 166.59201 269.1029 147.90802 284.712 135.54501C 299.302 123.52501 317.06 115.99001 335.841 113.85401L335.841 113.85401L335.841 255.71402C 316.907 250.75702 299.013 242.46402 282.989 231.22601zM415.27997 424.448L415.28387 424.448C 400.69388 436.468 382.93588 444.003 364.15488 446.139L364.15488 446.139L364.15488 304.279C 383.08887 309.236 400.98288 317.529 417.00687 328.767C 431.89786 338.7592 440.76486 355.568 440.60486 373.497C 440.17908 393.403 430.89395 412.087 415.28485 424.45z" stroke="none" fill="#000000" fill-rule="nonzero" />
			</g>
		</g>
	</g>
</svg>`, CHECKBOX_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="13" height="13">
  <g transform="matrix(0.68421054 0 0 0.68421054 0 0)">
    <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
      <g>
        <path d="M521.77 0L178.24002 0C 119.416016 0 70.01002 49.41 70.01002 108.23L70.01002 108.23L70.01002 454.11002C 70.01002 512.934 119.42001 562.34 178.24002 562.34L178.24002 562.34L524.12 562.34C 582.944 562.34 632.35 512.93005 632.35 454.11002L632.35 454.11002L632.35 108.23001C 629.99835 49.40601 582.94 7.6293945E-06 521.76 7.6293945E-06L521.76 7.6293945E-06L521.77 0zM587.653 451.77C 587.653 487.063 559.419 515.30096 524.122 515.30096L524.122 515.30096L178.242 515.29706C 142.949 515.29706 114.711006 487.06305 114.711006 451.76605L114.711006 451.76605L114.71491 108.23605C 114.71491 72.943054 142.94891 44.705055 178.24591 44.705055L178.24591 44.705055L524.1259 44.705055C 559.41895 44.705055 587.6569 72.93906 587.6569 108.23605z" stroke="none" fill="#010101" fill-rule="nonzero" />
        <path d="M479.41 164.71L293.53 350.59003L222.94 280.00003C 213.5298 270.58984 201.764 270.58984 192.35 280.00003C 182.9398 289.41022 182.9398 301.17603 192.35 310.59003L192.35 310.59003L279.409 397.64902C 281.7684 400.0006 286.4715 402.3521 293.534 402.3521C 300.5926 402.3521 305.3 400.00052 307.651 395.29352L307.651 395.29352L510.001 192.94351C 517.05963 185.88492 517.05963 171.76752 510.001 164.70952C 500.59082 155.29543 486.47 155.29543 479.411 164.70952L479.411 164.70952L479.41 164.71z" stroke="none" fill="#010101" fill-rule="nonzero" />
      </g>
    </g>
  </g>
</svg>`, SELECT_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="14">
	<g transform="matrix(0.9 0 0 0.93333334 0 0)">
		<g transform="matrix(0.03 0 0 0.03 2.5000005 -0)">
			<g transform="matrix(1 0 0 1 -86.77152 -33.81399)">
				<g transform="matrix(1 0 0 1 -13.737094 17.33647)">
					<path d="M399.537 218.885L277.33 218.885C 262.315 218.885 254.544 236.996 265.421 247.859L265.421 247.859L328.596 310.981C 335.328 317.708 346.201 317.708 352.933 310.466L352.933 310.466L411.966 247.343C 421.805 236.476 414.555 218.885 399.537 218.885z" stroke="none" fill="#000000" fill-rule="nonzero" />
					<path d="M340.559 56.069C 226.133 56.069 128.026 151.307 128.026 265.753C 128.026 380.198 224.339 475.408 338.765 475.408C 453.191 475.408 547.665 380.561 547.665 266.116C 547.665 151.67 454.985 56.069 340.559 56.069zM338.765 452.542C 235.73 452.542 152.37 369.168 152.37 266.116C 152.37 163.063 235.73 79.689 338.765 79.689C 441.8 79.689 525.16 163.063 525.16 266.116C 525.157 369.168 441.797 452.542 338.765 452.542z" stroke="none" fill="#000000" fill-rule="nonzero" />
				</g>
			</g>
		</g>
	</g>
</svg>`, NUMBER_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14">
	<g transform="matrix(0.7368421 0 0 0.7368421 0 0)">
		<g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
			<path d="M577.5 175L471.36 175L489.78598 55.160004C 490.4813 49.101402 487.96957 43.117004 483.15707 39.367004C 478.34848 35.620903 471.93008 34.644302 466.22308 36.796703C 460.51608 38.949005 456.34418 43.917805 455.2071 49.909702L455.2071 49.909702L435.9371 174.9997L296.35712 174.9997L314.7831 55.1597C 315.66983 50.4917 314.61905 45.6597 311.87292 41.7807C 309.12292 37.901802 304.91592 35.308 300.21692 34.5971C 295.51773 33.88226 290.7325 35.11272 286.95493 37.999397C 283.18152 40.886097 280.74402 45.186897 280.20493 49.909397L280.20493 49.909397L260.93494 174.99939L157.49493 174.99939C 151.24103 174.99939 145.46393 178.3353 142.33893 183.74939C 139.21393 189.16348 139.21393 195.83539 142.33893 201.24939C 145.46393 206.66339 151.24123 209.99939 157.49493 209.99939L157.49493 209.99939L255.49493 209.99939L234.02194 349.9994L122.49194 349.9994C 116.238045 349.9994 110.460945 353.3353 107.335945 358.7494C 104.210945 364.16348 104.210945 370.8354 107.335945 376.2494C 110.460945 381.6634 116.23824 384.9994 122.49194 384.9994L122.49194 384.9994L228.63194 384.9994L210.20595 504.8394C 209.31923 509.5074 210.37001 514.33936 213.11615 518.2184C 215.86615 522.0973 220.07315 524.6911 224.77216 525.402C 229.47136 526.1168 234.25656 524.88635 238.03415 521.9997C 241.80756 519.113 244.24506 514.8122 244.78415 510.0897L244.78415 510.0897L264.05414 384.9997L403.63416 384.9997L385.20816 504.8397C 384.32144 509.5077 385.37222 514.3397 388.11835 518.2187C 390.86835 522.0976 395.07535 524.6914 399.77435 525.4023C 404.47354 526.1171 409.25876 524.88666 413.03635 522C 416.80975 519.1133 419.24725 514.8125 419.78635 510.09L419.78635 510.09L439.05634 385L542.49634 385C 548.75024 385 554.52734 381.6641 557.65234 376.25C 560.77734 370.8359 560.77734 364.164 557.65234 358.75C 554.52734 353.336 548.75006 350 542.49634 350L542.49634 350L444.49634 350L466.03934 210L577.4993 210C 583.75323 210 589.53033 206.6641 592.65533 201.25C 595.78033 195.8359 595.78033 189.164 592.65533 183.75C 589.53033 178.336 583.75305 175 577.4993 175L577.4993 175L577.5 175zM430.5 210L408.957 350L269.497 350L291.04 210z" stroke="none" fill="#000000" fill-rule="nonzero" />
		</g>
	</g>
</svg>`, LABEL_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14">
	<g transform="matrix(0.7368421 0 0 0.7368421 0 0)">
		<g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
			<g>
				<path d="M279.16 122.86L470.53 122.86L470.53 95.829C 470.53 82.16901 464.9362 69.755005 455.913 60.735C 446.8896 51.7116 434.475 46.118 420.835 46.118L420.835 46.118L165.825 46.118C 152.165 46.118 139.75099 51.7118 130.73099 60.735C 121.70759 69.7584 116.11399 82.173004 116.11399 95.829L116.11399 95.829L116.11399 350.839C 116.11399 364.47998 121.707794 376.913 130.73099 385.917C 139.7544 394.9404 152.16899 400.534 165.82498 400.534L165.82498 400.534L192.85599 400.534L192.85599 209.164C 192.85599 185.41 202.5669 163.836 218.19199 148.195C 233.81708 132.55402 255.40298 122.85901 279.16098 122.85901L279.16098 122.85901L279.16 122.86zM507.14 122.86L534.171 122.86C 557.92505 122.86 579.499 132.5709 595.14 148.196C 610.765 163.821 620.476 185.407 620.476 209.16501L620.476 209.16501L620.476 464.175C 620.476 487.929 610.76514 509.503 595.14 525.144C 579.499 540.785 557.929 550.48 534.171 550.48L534.171 550.48L279.161 550.48C 255.40701 550.48 233.83301 540.7691 218.19202 525.144C 202.55103 509.51886 192.85602 487.93298 192.85602 464.175L192.85602 464.175L192.85602 437.14398L165.82501 437.14398C 142.07101 437.14398 120.49701 427.43307 104.85601 411.80798C 89.23101 396.18298 79.52001 374.597 79.52001 350.839L79.52001 350.839L79.52001 95.828995C 79.52001 72.075 89.23091 50.500996 104.85601 34.859993C 120.49701 19.234993 142.06702 9.523993 165.82501 9.523993L165.82501 9.523993L420.83502 9.523993C 444.58902 9.523993 466.16302 19.234894 481.80402 34.859993C 497.445 50.50099 507.14 72.07099 507.14 95.828995zM534.171 159.469L279.161 159.469C 265.52002 159.469 253.087 165.06279 244.08301 174.086C 235.0596 183.1094 229.466 195.524 229.466 209.18L229.466 209.18L229.466 464.19C 229.466 477.831 235.0598 490.264 244.08301 499.284C 253.10641 508.3074 265.521 513.901 279.161 513.901L279.161 513.901L534.171 513.901C 547.831 513.901 560.245 508.3072 569.265 499.284C 578.2884 490.2606 583.882 477.846 583.882 464.19L583.882 464.19L583.882 209.18001C 583.882 195.539 578.2882 183.106 569.265 174.086C 560.24164 165.06259 547.827 159.469 534.171 159.469z" stroke="none" fill="#000000" fill-rule="nonzero" />
			</g>
		</g>
	</g>
</svg>`, TEXT_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="12" height="12">
  <g transform="matrix(0.6315789 0 0 0.6315789 0 0)">
    <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
      <g>
        <path d="M84 32.48L616 32.48L616 92.96L84 92.96L84 32.48z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M84 177.52L470.4 177.52L470.4 238L84 238L84 177.52z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M84 322.56L616 322.56L616 383.04L84 383.04L84 322.56z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M84 467.6L470.4 467.6L470.4 528.08L84 528.08L84 467.6z" stroke="none" fill="#000000" fill-rule="nonzero" />
      </g>
    </g>
  </g>
</svg>`;
var DEFAULT_COLUMN_TYPES = /* @__PURE__ */ ((le) => (le.TEXT = "Text", le.NUMBER = "Number", le.CURRENCY = "Currency", le.DATE_DMY = "Date d-m-y", le.DATE_MDY = "Date m-d-y", le.CHECKBOX = "Checkbox", le.SELECT = "Select", le.LABEL = "Label", le))(DEFAULT_COLUMN_TYPES || {});
const _CalendarFunctionalityUtils = class {
  static mdYCellTextToYMD(le) {
    const Y = RegexUtils.extractIntegerStrs(le);
    return [Y[2], Y[0], Y[1]];
  }
  static yMDToMDYCellText(le) {
    return [le[1], le[2], le[0]].join("-");
  }
  static dMYCellTextToYMD(le) {
    const Y = RegexUtils.extractIntegerStrs(le);
    return [Y[2], Y[1], Y[0]];
  }
  static yMDToDMYCellText(le) {
    return [le[2], le[1], le[0]].join("-");
  }
};
_CalendarFunctionalityUtils.DEFAULT_TYPES_FUNCTIONALITY = {
  [DEFAULT_COLUMN_TYPES.DATE_DMY]: {
    toYMDFunc: (le) => _CalendarFunctionalityUtils.dMYCellTextToYMD(le),
    fromYMDFunc: (le) => _CalendarFunctionalityUtils.yMDToDMYCellText(le)
  },
  [DEFAULT_COLUMN_TYPES.DATE_MDY]: {
    toYMDFunc: (le) => _CalendarFunctionalityUtils.mdYCellTextToYMD(le),
    fromYMDFunc: (le) => _CalendarFunctionalityUtils.yMDToMDYCellText(le)
  }
};
let CalendarFunctionalityUtils = _CalendarFunctionalityUtils;
const _Validation = class {
  static setSelectValidation(le, Y, re) {
    var oe, ue;
    if (!((oe = le.cellDropdownProps) != null && oe.options) || (ue = le.cellDropdownProps) != null && ue.canAddMoreOptions)
      return;
    const fe = new Set(le.cellDropdownProps.options.map((he) => he.text));
    le.textValidation ?? (le.textValidation = {}), le.textValidation.func = (he) => !!fe.has(he) || !Y && he === re;
  }
};
_Validation.DEFAULT_TYPES_REGEX = {
  [DEFAULT_COLUMN_TYPES.CURRENCY]: new RegExp(
    // eslint-disable-next-line max-len
    /^(([$€£¥]\s*?-?(([1-9]\d{0,2}(,\d{3})*)|\d+)?(\.\d{1,2})?)|(-?(([1-9]\d{0,2}(,\d{3})*)|\d+)?(\.\d{1,2})?\s*?[$€£¥]))$/
  ),
  // \s*? is used to allow spaces between symbols
  [DEFAULT_COLUMN_TYPES.DATE_DMY]: new RegExp(
    /^(0?[1-9]|[12][0-9]|3[01])\s*?[/-]\s*?(0?[1-9]|1[012])\s*?[/-]\s*?\d{4}$/
  ),
  [DEFAULT_COLUMN_TYPES.DATE_MDY]: new RegExp(
    /^(0?[1-9]|1[012])\s*?[/-]\s*?(0?[1-9]|[12][0-9]|3[01])\s*?[/-]\s*?\d{4}$/
  )
};
_Validation.DEFAULT_TYPES_FUNCTIONALITY = {
  [DEFAULT_COLUMN_TYPES.NUMBER]: (le) => le !== EMPTY_STRING && !isNaN(le),
  [DEFAULT_COLUMN_TYPES.CURRENCY]: (le) => _Validation.DEFAULT_TYPES_REGEX[DEFAULT_COLUMN_TYPES.CURRENCY].test(le),
  [DEFAULT_COLUMN_TYPES.DATE_DMY]: (le) => _Validation.DEFAULT_TYPES_REGEX[DEFAULT_COLUMN_TYPES.DATE_DMY].test(le),
  [DEFAULT_COLUMN_TYPES.DATE_MDY]: (le) => _Validation.DEFAULT_TYPES_REGEX[DEFAULT_COLUMN_TYPES.DATE_MDY].test(le)
};
let Validation = _Validation;
class CellElementIndex {
  static getViaColumnIndex(Y, re) {
    const oe = Number(re);
    return Y * 2 + oe;
  }
}
const _Sort = class Or {
  static extractNumberFromString(Y) {
    const re = RegexUtils.extractFloatStrs(Y);
    return re && re.length > 0 ? Number(re[0]) : 0;
  }
  // cannot safely identify if nothing has been changed, hence need to send out an update for all cells
  // prettier-ignore
  static update(Y, re) {
    const { _tableBodyElementRef: oe, _frameComponents: { displayIndexColumn: ue }, data: fe } = Y, he = oe.children;
    re.forEach((_e, ve) => {
      const xe = ve + 1, Ee = he[xe].children;
      _e.forEach((Se, Te) => {
        const Ce = CellElementIndex.getViaColumnIndex(Te, !!ue), Ie = Ee[Ce];
        CellEvents.updateCell(
          Y,
          Se,
          xe,
          Te,
          { processText: !1, element: Ie, updateTableEvent: !1, updateData: !1 }
        ), ColumnTypesUtils.updateDataElements(Y, ve, Te, Ie);
      });
    }), fe.splice(1, re.length, ...re), setTimeout(() => FireEvents.onDataUpdate(Y));
  }
  static sortStringsColumnAscending(Y, re) {
    Y.sort((oe, ue) => String(oe[re]).localeCompare(String(ue[re])));
  }
  static sortStringsColumnDescending(Y, re) {
    Y.sort((oe, ue) => String(ue[re]).localeCompare(String(oe[re])));
  }
  static sortStrings(Y, re, oe) {
    oe ? Or.sortStringsColumnAscending(Y, re) : Or.sortStringsColumnDescending(Y, re);
  }
  // prettier-ignore
  static parseComparedText(Y, re, oe, ue) {
    const fe = ue(Y);
    if (fe === void 0)
      return oe ? 1 : -1;
    const he = ue(re);
    return he === void 0 ? oe ? -1 : 1 : [fe, he];
  }
  static validateType(Y, re) {
    return Y === void 0 || Y(re) ? re : void 0;
  }
  // prettier-ignore
  static validateAndSort(Y, re, oe, ue, fe) {
    const he = Or.parseComparedText(Y, re, fe, Or.validateType.bind(this, ue));
    return typeof he == "number" ? he : (fe ? oe.ascendingFunc : oe.descendingFunc)(he[0], he[1]);
  }
  static sortViaSortFuncs(Y, re, oe, ue) {
    const { sorting: fe, textValidation: he } = Y;
    fe && re.sort(
      (_e, ve) => Or.validateAndSort(_e[oe], ve[oe], fe, he.func, ue)
    );
  }
  static compareDates(Y, re) {
    return new Date(...Y) - new Date(...re);
  }
  static parseYMDFormat(Y, re, oe) {
    return Or.validateType(Y, oe) ? re.toYMDFunc(oe) : void 0;
  }
  // prettier-ignore
  static sortDates(Y, re, oe, ue) {
    const { calendar: fe, textValidation: he } = Y;
    fe && re.sort((_e, ve) => {
      const xe = Or.parseComparedText(
        _e[oe],
        ve[oe],
        !0,
        Or.parseYMDFormat.bind(this, he.func, fe)
      );
      return typeof xe == "number" ? xe : ue ? Or.compareDates(xe[0], xe[1]) : Or.compareDates(xe[1], xe[0]);
    });
  }
  static sortColumn(Y, re, oe) {
    const ue = Y.data.slice(1), { activeType: fe } = Y._columnsDetails[re];
    fe.calendar ? Or.sortDates(fe, ue, re, oe) : fe.sorting ? Or.sortViaSortFuncs(fe, ue, re, oe) : Or.sortStrings(ue, re, oe), Or.update(Y, ue);
  }
};
_Sort.DEFAULT_TYPES_SORT_FUNCS = {
  [DEFAULT_COLUMN_TYPES.NUMBER]: {
    ascendingFunc: (le, Y) => Number(le) - Number(Y),
    descendingFunc: (le, Y) => Number(Y) - Number(le)
  },
  [DEFAULT_COLUMN_TYPES.CURRENCY]: {
    ascendingFunc: (le, Y) => _Sort.extractNumberFromString(le) - _Sort.extractNumberFromString(Y),
    descendingFunc: (le, Y) => _Sort.extractNumberFromString(Y) - _Sort.extractNumberFromString(le)
  }
};
let Sort = _Sort;
const _DefaultColumnTypes = class Yi {
  // REF-28
  static createDropdownItemsForDefaultTypes() {
    Yi.DEFAULT_TYPES.forEach((Y) => {
      const re = {
        text: Y.name,
        iconSettings: Y.iconSettings || DropdownButtonItemConf.DEFAULT_ITEM.iconSettings
      };
      Y.dropdownItem = {
        element: DropdownItem.createButtonItemNoEvents(void 0, re),
        settings: re
      };
    });
  }
};
_DefaultColumnTypes.FALLBACK_TYPE = {
  name: DEFAULT_COLUMN_TYPES.TEXT,
  iconSettings: {
    svgString: TEXT_ICON_SVG_STRING,
    containerStyles: {
      dropdown: { marginLeft: "-0.25px", marginRight: "6px", marginTop: "2.5px" },
      headerCorrections: { marginTop: "2.5px" }
    }
  }
};
_DefaultColumnTypes.DEFAULT_TYPES = [
  _DefaultColumnTypes.FALLBACK_TYPE,
  {
    name: DEFAULT_COLUMN_TYPES.NUMBER,
    textValidation: { func: Validation.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.NUMBER] },
    sorting: Sort.DEFAULT_TYPES_SORT_FUNCS[DEFAULT_COLUMN_TYPES.NUMBER],
    iconSettings: {
      svgString: NUMBER_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginLeft: "-1px", marginRight: "4.5px", marginTop: "2px" },
        headerCorrections: { marginTop: "2.5px" }
      }
    }
  },
  {
    name: DEFAULT_COLUMN_TYPES.CURRENCY,
    textValidation: { func: Validation.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.CURRENCY] },
    sorting: Sort.DEFAULT_TYPES_SORT_FUNCS[DEFAULT_COLUMN_TYPES.CURRENCY],
    iconSettings: {
      svgString: CURRENCY_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginLeft: "-2px", marginRight: "4px", marginTop: "1px" },
        headerCorrections: { marginRight: "3px", marginTop: "2px" }
      }
    }
  },
  {
    name: DEFAULT_COLUMN_TYPES.SELECT,
    select: {},
    iconSettings: {
      svgString: SELECT_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginTop: "0px", marginRight: "3px", marginLeft: "-2.75px" },
        headerCorrections: { marginTop: "1px" }
      }
    }
  },
  {
    name: DEFAULT_COLUMN_TYPES.LABEL,
    label: {},
    iconSettings: {
      svgString: LABEL_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginTop: "1.5px", marginRight: "5.5px", marginLeft: "-1px" },
        headerCorrections: { marginTop: "2.5px", marginRight: "5.5px", marginLeft: "0px" }
      }
    }
  },
  {
    name: DEFAULT_COLUMN_TYPES.CHECKBOX,
    iconSettings: {
      svgString: CHECKBOX_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginRight: "6px", marginTop: "2px" },
        headerCorrections: { marginRight: "5px", marginLeft: "1px", marginTop: "3px" }
      }
    },
    checkbox: !0,
    customTextProcessing: {
      changeTextFunc: CheckboxValidationFunc.getDefault()
    }
  },
  {
    name: DEFAULT_COLUMN_TYPES.DATE_DMY,
    textValidation: { func: Validation.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.DATE_DMY] },
    calendar: CalendarFunctionalityUtils.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.DATE_DMY],
    iconSettings: {
      svgString: CALENDAR_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginLeft: "1.25px", marginRight: "8px", marginTop: "-1.5px" },
        headerCorrections: { marginTop: "0px" }
      }
    }
  },
  {
    name: DEFAULT_COLUMN_TYPES.DATE_MDY,
    textValidation: { func: Validation.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.DATE_MDY] },
    calendar: CalendarFunctionalityUtils.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.DATE_MDY],
    iconSettings: {
      svgString: CALENDAR_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginLeft: "1.25px", marginRight: "8px", marginTop: "-1.5px" },
        headerCorrections: { marginTop: "0px" }
      }
    }
  }
];
let DefaultColumnTypes = _DefaultColumnTypes;
class DropdownButtonItemConf {
}
DropdownButtonItemConf.DEFAULT_ITEM = {
  text: DefaultColumnTypes.FALLBACK_TYPE.name,
  iconSettings: DefaultColumnTypes.FALLBACK_TYPE.iconSettings
};
class ColumnTypesUtils {
  static getTypeByName(Y, re) {
    return Y.find((oe) => oe.name.toLocaleLowerCase() === re?.toLocaleLowerCase());
  }
  static getTypeBasedOnProperties(Y, re) {
    if (re) {
      const oe = ColumnTypesUtils.getTypeByName(Y.types, re);
      if (oe)
        return oe;
    }
    if (Y.defaultColumnTypeName) {
      const oe = ColumnTypesUtils.getTypeByName(Y.types, Y.defaultColumnTypeName);
      if (oe)
        return oe;
    }
  }
  static getActiveType(Y, re) {
    const oe = ColumnTypesUtils.getTypeBasedOnProperties(Y, re);
    if (oe)
      return oe;
    const ue = Y.types.find((he) => !he.textValidation.func);
    return ue || Y.types[0] || DefaultColumnTypes.FALLBACK_TYPE;
  }
  // prettier-ignore
  static getReusableDefaultIcon(Y) {
    var re;
    const oe = (re = Y.reusableIconName) == null ? void 0 : re.toLocaleLowerCase(), ue = DefaultColumnTypes.DEFAULT_TYPES.find((fe) => fe.name.toLocaleLowerCase() === oe);
    return ue != null && ue.iconSettings ? ue.iconSettings : DropdownButtonItemConf.DEFAULT_ITEM.iconSettings;
  }
  static processDropdownItemSettings(Y) {
    const { name: re, iconSettings: oe } = Y;
    let ue;
    oe ? oe.reusableIconName ? ue = ColumnTypesUtils.getReusableDefaultIcon(oe) : (ue = oe, Object.keys(oe).length === 0 ? ue = DropdownButtonItemConf.DEFAULT_ITEM.iconSettings : oe.svgString || (ue.svgString ?? (ue.svgString = DropdownButtonItemConf.DEFAULT_ITEM.iconSettings.svgString), ue.containerStyles ?? (ue.containerStyles = DropdownButtonItemConf.DEFAULT_ITEM.iconSettings.containerStyles))) : ue = DropdownButtonItemConf.DEFAULT_ITEM.iconSettings;
    const fe = { text: re, iconSettings: ue }, he = Y;
    he.dropdownItem ?? (he.dropdownItem = { element: null, settings: fe }), setTimeout(() => {
      var _e;
      (_e = he.dropdownItem).element ?? (_e.element = DropdownItem.createButtonItemNoEvents(void 0, fe));
    });
  }
  static processTextValidationProps(Y) {
    var re;
    Y.textValidation ?? (Y.textValidation = {}), (re = Y.textValidation).setTextToDefaultOnFail ?? (re.setTextToDefaultOnFail = !0);
  }
  static processCheckbox(Y) {
    var re;
    Y.checkbox && !((re = Y.customTextProcessing) != null && re.changeTextFunc) && (Y.customTextProcessing ?? (Y.customTextProcessing = {}), Y.customTextProcessing.changeTextFunc = CheckboxValidationFunc.getDefault());
  }
  static processSelectOptions(Y) {
    if (typeof Y.select == "object" && Y.select.options) {
      const re = Y.select;
      re.options = Y.select.options.map((oe) => ({ text: oe }));
    } else if (typeof Y.label == "object" && Y.label.options) {
      const re = Y.label;
      re.options = JSON.parse(JSON.stringify(Y.label.options));
    }
  }
  static processSelect(Y, re, oe) {
    var ue;
    const fe = Y;
    Y.select === !0 || Y.label === !0 ? fe.cellDropdownProps = { isBasicSelect: !Y.label } : (typeof Y.select == "object" || typeof Y.label == "object") && (fe.cellDropdownProps = Y.select || Y.label, fe.cellDropdownProps.isBasicSelect = !Y.label, ColumnTypesUtils.processSelectOptions(Y), Validation.setSelectValidation(fe, re, oe)), fe.cellDropdownProps && fe.cellDropdownProps.canAddMoreOptions === void 0 && (fe.cellDropdownProps.canAddMoreOptions = !((ue = fe.cellDropdownProps) != null && ue.options));
  }
  // the reason why this is needed is when the argument is JSON stringified, properties that hold functions are removed,
  // hence they can only be applied to the component as strings
  static convertStringFunctionsToRealFunctions(Y) {
    Y.textValidation && ObjectUtils.convertStringToFunction(Y.textValidation, "func"), Y.customTextProcessing && (ObjectUtils.convertStringToFunction(Y.customTextProcessing, "changeTextFunc"), ObjectUtils.convertStringToFunction(Y.customTextProcessing, "changeStyleFunc")), Y.sorting && (ObjectUtils.convertStringToFunction(Y.sorting, "ascendingFunc"), ObjectUtils.convertStringToFunction(Y.sorting, "descendingFunc")), Y.calendar && (ObjectUtils.convertStringToFunction(Y.calendar, "toYMDFunc"), ObjectUtils.convertStringToFunction(Y.calendar, "fromYMDFunc"));
  }
  // this is important because when types get processed - their resultant structure is not be the same, hence if
  // the same one is used in different settings (e.g. defaultColumnTypes set in default and custom settings),
  // the processing of the same type again would not work
  // JSON.stringify loses element and function references, hence they need to be manually reassigned
  static createTypeDeepCopy(Y) {
    const re = JSON.parse(JSON.stringify(Y));
    return Y.dropdownItem && (re.dropdownItem = Y.dropdownItem), Y.textValidation && (re.textValidation = Y.textValidation), Y.customTextProcessing && (re.customTextProcessing = Y.customTextProcessing), Y.sorting && (re.sorting = Y.sorting), Y.calendar && (re.calendar = Y.calendar), re;
  }
  static process(Y, re, oe) {
    return Y.map((ue) => {
      const fe = ColumnTypesUtils.createTypeDeepCopy(ue);
      return ColumnTypesUtils.convertStringFunctionsToRealFunctions(fe), ColumnTypesUtils.processSelect(fe, re, oe), ColumnTypesUtils.processCheckbox(fe), ColumnTypesUtils.processTextValidationProps(fe), ColumnTypesUtils.processDropdownItemSettings(fe), fe;
    });
  }
  static getAvailableTypes(Y) {
    let re = [...DefaultColumnTypes.DEFAULT_TYPES];
    const { availableDefaultColumnTypes: oe, customColumnTypes: ue } = Y;
    if (oe) {
      const fe = oe.map((he) => he.toLocaleLowerCase());
      re = re.filter((he) => fe.indexOf(he.name.toLocaleLowerCase()) > -1);
    }
    return ue && re.push(...ue), re.length === 0 && re.push(DefaultColumnTypes.FALLBACK_TYPE), re;
  }
  static getProcessedTypes(Y) {
    const { isDefaultTextRemovable: re, defaultText: oe } = Y, ue = ColumnTypesUtils.getAvailableTypes(Y);
    return ColumnTypesUtils.process(ue, re, oe);
  }
  // updates label color, date input etc.
  // prettier-ignore
  static updateDataElements(Y, re, oe, ue) {
    const { _columnsDetails: fe, _tableDimensions: he } = Y, _e = fe[oe];
    re !== 0 && (_e.activeType.cellDropdownProps ? (CellDropdown.updateCellDropdown(
      ue,
      _e.cellDropdown,
      he.border,
      _e.settings.defaultText,
      !0
    ), SelectCell.finaliseEditedText(Y, ue.children[0], oe, !0)) : Browser.IS_INPUT_DATE_SUPPORTED && _e.activeType.calendar && DateCellInputElement.updateInputBasedOnTextDiv(ue, _e.activeType));
  }
}
class MoveUtils {
  // prettier-ignore
  static setNewElementText(Y, re, oe, ue, fe) {
    const he = CellElement.getText(oe);
    return CellEvents.updateCell(Y, re, fe, ue, { element: oe, processText: !1 }), ColumnTypesUtils.updateDataElements(Y, fe, ue, oe), he;
  }
}
class MoveColumn {
  // prettier-ignore
  static overwriteDataElements(Y, re, oe, ue) {
    re.slice(1).forEach((fe, he) => {
      const _e = he + 1, ve = ue[_e];
      MoveUtils.setNewElementText(Y, ve, fe, oe, _e);
    });
  }
  // prettier-ignore
  static changeSettings(Y, re, oe, ue, fe) {
    HeaderText.onAttemptChange(Y, oe, re, { colMove: !0 }), fe !== ue.activeType && ChangeColumnType.change.bind(Y)(fe.name, re);
  }
  // prettier-ignore
  static overwrite(Y, re, oe, ue, fe, he) {
    const { elements: _e, activeType: ve } = re;
    MoveUtils.setNewElementText(Y, ue[0], _e[0], oe, 0), MoveColumn.changeSettings(Y, oe, _e[0], re, fe), MoveColumn.overwriteDataElements(Y, _e, oe, ue);
    const xe = _e[0].style.width;
    return _e[0].style.width = he, { overwrittenType: ve, overwrittenWidth: xe };
  }
  static firstChangeSettingsIfSettingsChanged(Y, re) {
    const { areSettingsDifferent: oe } = ColumnSettingsUtils.parseSettingsChange(Y);
    if (oe) {
      const ue = Y._columnsDetails[re];
      HeaderText.onAttemptChange(Y, ue.elements[0], re);
    }
  }
  // prettier-ignore
  static move(Y, re, oe) {
    MoveColumn.firstChangeSettingsIfSettingsChanged(Y, re);
    const ue = Y._columnsDetails[re], fe = Y._columnsDetails[re].elements.map((Se) => CellElement.getText(Se));
    CellHighlightUtils.fade(ue.elements[0], ue?.headerStateColors.default);
    const he = oe ? re + 1 : re - 1, _e = Y._columnsDetails[he], ve = _e.elements.map((Se) => CellElement.getText(Se)), xe = _e.elements[0].style.width, Ee = MoveColumn.overwrite(
      Y,
      ue,
      re,
      ve,
      _e.activeType,
      xe
    );
    FocusedCellUtils.set(Y._focusedElements.cell, _e.elements[0], 0, he), MoveColumn.overwrite(
      Y,
      _e,
      he,
      fe,
      Ee.overwrittenType,
      Ee.overwrittenWidth
    ), setTimeout(() => FireEvents.onColumnsUpdate(Y));
  }
}
class ColumnSizerGenericUtils {
  // the current solution for using first row position as 'relative' with divider having 100% height only works for
  // these browsers
  static canHeightBeInherited() {
    return Browser.IS_CHROMIUM || Browser.IS_FIREFOX;
  }
  static getSizerDetailsViaElementId(Y, re) {
    const oe = Number(RegexUtils.extractIntegerStrs(Y)[0]), ue = re[oe];
    return { columnSizer: ue.columnSizer, headerCell: ue.elements[0], sizerNumber: oe };
  }
  static findNextResizableColumnHeader(Y, re) {
    const oe = Y.slice(re + 1).find((ue) => {
      var fe;
      return !((fe = ue.settings.widths) != null && fe.staticWidth);
    });
    return oe?.elements[0];
  }
}
const _UpdateRowElement = class ai {
  // required to allow the divider and all its elements to inherit its height (in non chrome or firefox browsers)
  static updateHeaderRowHeight(Y) {
    ColumnSizerGenericUtils.canHeightBeInherited() || (Y.style.height = ai.UNSET, Y.style.height = getComputedStyle(Y).height);
  }
  // if this does not capture all events - use in HeaderText.onAttemptChange method instead
  static updateHeadRowHeightOnKeyDown(Y) {
    var re;
    if (!ColumnSizerGenericUtils.canHeightBeInherited()) {
      const oe = (re = Y.children) == null ? void 0 : re[0];
      oe && oe.style.height !== ai.UNSET && (oe.style.height = ai.UNSET, setTimeout(() => {
        oe.style.height = `${oe.offsetHeight}px`;
      }));
    }
  }
  static getUnsetHeightFunc(Y, re) {
    if (!ColumnSizerGenericUtils.canHeightBeInherited() && re === 0)
      return () => Y.style.height = ai.UNSET;
  }
};
_UpdateRowElement.UNSET = "unset";
let UpdateRowElement = _UpdateRowElement;
class RowHoverEvents {
  static canStyleBeApplied(Y, re, oe) {
    return (oe > 0 || Y.header) && (!AddNewRowElement.isAddNewRowRow(re) || Y.addNewRowButton);
  }
  static getRemoveColorFunc(Y, re, oe, ue) {
    const fe = Y.rowHoverStyles;
    if (fe != null && fe.style && RowHoverEvents.canStyleBeApplied(fe, re, oe))
      return () => {
        ElementStyle.unsetStyle(re, fe.style), Object.assign(re.style, ue);
      };
  }
  static addMouseLeaveEvent(Y, re, oe, ue) {
    const fe = RowHoverEvents.getRemoveColorFunc(Y, re, oe, ue), he = UpdateRowElement.getUnsetHeightFunc(re, oe);
    re.onmouseleave = () => {
      fe?.(), he?.();
    };
  }
  // prettier-ignore
  static addMouseEnterEvent(Y, re, oe) {
    const { rowHoverStyles: ue, _focusedElements: { rowDragEl: fe } } = Y, he = ue != null && ue.style && RowHoverEvents.canStyleBeApplied(ue, re, oe) ? () => Object.assign(re.style, ue?.style) : void 0;
    re.onmouseenter = () => {
      fe || he == null || he();
    };
  }
  static addEvents(Y, re, oe, ue) {
    RowHoverEvents.addMouseEnterEvent(Y, re, oe), RowHoverEvents.addMouseLeaveEvent(Y, re, oe, ue);
  }
  static process(Y, re) {
    Y != null && Y.style && (Y.header ?? (Y.header = !0), Y.addNewRowButton ?? (Y.addNewRowButton = !0), CellHighlightUtils.unsetDefaultHoverProperties(re));
  }
}
const _StripedRows = class xi {
  static setRowStyle(Y, re, oe) {
    const ue = re % 2 ? oe.even : oe.odd;
    return Object.assign(Y.style, ue), ue;
  }
  static process(Y) {
    const { stripedRows: re, _defaultCellHoverColors: oe } = Y;
    re && (typeof re == "boolean" ? Y._stripedRows = xi.DEFAULT_PROPERTIES : Y._stripedRows = {
      even: re.even || xi.DEFAULT_PROPERTIES.even,
      odd: re.odd || xi.DEFAULT_PROPERTIES.odd
    }, CellHighlightUtils.unsetDefaultHoverProperties(oe));
  }
};
_StripedRows.DEFAULT_PROPERTIES = {
  odd: { backgroundColor: "" },
  even: { backgroundColor: "#dcdcdc7a" }
};
let StripedRows = _StripedRows;
class CustomRowProperties {
  static setStyle(Y, re, oe, ue) {
    if (Y._stripedRows)
      return ue && AddNewRowElement.isAddNewRowRow(re) && (oe = +!Y.dataStartsAtHeader), StripedRows.setRowStyle(re, oe, Y._stripedRows);
  }
  // prettier-ignore
  static updateRow(Y, re, oe, ue, fe) {
    const he = CustomRowProperties.setStyle(Y, re, oe, ue);
    oe === fe ? RowHoverEvents.addEvents(Y, re, oe, he) : setTimeout(() => {
      RowHoverEvents.addEvents(Y, re, oe, he);
    });
  }
  // REF-32
  static isAddRowRowSame(Y) {
    return !!(Y.pagination && Y._frameComponents.displayAddNewRow && PaginationUtils.getLastPossiblePageNumber(Y) !== Y._pagination.activePageNumber);
  }
  // this can be considered to be wasteful if no striped rows are used and we are resetting the same row events
  // every time this is called, however we are still traversing all rows from startIndex for code simplicity
  static update(Y, re = 0) {
    if (!Y._tableBodyElementRef)
      return;
    const oe = Array.from(Y._tableBodyElementRef.children), ue = CustomRowProperties.isAddRowRowSame(Y), fe = oe.length - 1;
    oe.slice(re).forEach((he, _e) => {
      const ve = _e + re;
      CustomRowProperties.updateRow(Y, he, ve, ue, fe);
    });
  }
}
class MoveRow {
  // prettier-ignore
  static overwrite(Y, re, oe) {
    const ue = [];
    return Y._columnsDetails.forEach((fe, he) => {
      const _e = MoveUtils.setNewElementText(
        Y,
        re[he],
        fe.elements[oe],
        he,
        oe
      );
      ue.push(_e);
    }), ue;
  }
  static moveDataRows(Y, re, oe) {
    const ue = Y._columnsDetails.map(({ elements: he }) => CellElement.getText(he[oe])), fe = MoveRow.overwrite(Y, ue, re);
    MoveRow.overwrite(Y, fe, oe);
  }
  static resetFocusedCell(Y, re) {
    const { _frameComponents: oe, _focusedElements: ue } = Y, { element: fe, rowIndex: he, columnIndex: _e } = re;
    oe.displayIndexColumn ? FocusedCellUtils.setIndexCell(ue.cell, fe, he) : FocusedCellUtils.set(ue.cell, fe, he, _e);
  }
  static moveHeaderToDataRow(Y) {
    const { _columnsDetails: re, _focusedElements: oe } = Y, ue = { ...oe.cell }, fe = re.map(({ elements: _e }) => CellElement.getText(_e[1])), he = MoveRow.overwrite(Y, fe, 0);
    re.forEach((_e, ve) => {
      FocusedCellUtils.set(oe.cell, _e.elements[0], 0, ve), HeaderText.onAttemptChange(Y, _e.elements[0], ve);
    }), MoveRow.overwrite(Y, he, 1), MoveRow.resetFocusedCell(Y, ue);
  }
  static move(Y, re, oe) {
    const ue = oe ? re + 1 : re - 1;
    re === 0 || ue === 0 ? MoveRow.moveHeaderToDataRow(Y) : MoveRow.moveDataRows(Y, re, ue), CustomRowProperties.update(Y, re), Y.pagination && PaginationUtils.updateOnRowMove(Y, ue);
  }
}
const _Drag = class Qi {
  static move(Y, re, oe) {
    if (re === 0)
      return;
    const ue = re > 0, fe = ue ? 1 : -1;
    for (let he = 0; he < Math.abs(re); he += 1)
      oe(Y, Qi.ORIGINAL_INDEX + he * fe, ue);
    setTimeout(() => FocusedCellUtils.purge(Y._focusedElements.cell), 5);
  }
};
_Drag.CELL_HIDDEN_CLASS = "cell-hidden";
_Drag.DRAG_PX_TO_MOVE = 10;
_Drag.ORIGINAL_INDEX = 0;
let Drag = _Drag;
const _DragRow = class Ut extends Drag {
  static resetElements(Y) {
    var re, oe;
    (re = Ut.CLONE_ROW) == null || re.remove(), Array.from(Y.children || []).forEach((ue) => {
      ue.classList.remove(Drag.CELL_HIDDEN_CLASS);
    }), (oe = Ut.TARGET_LINE) == null || oe.remove();
  }
  static appendTargetLine(Y) {
    Ut.TARGET_LINE = document.createElement("div"), Ut.TARGET_LINE.classList.add("row-drag-target-line"), Ut.TARGET_LINE.style.opacity = "0", Y.appendChild(Ut.TARGET_LINE);
  }
  static prepareElements(Y, re, oe) {
    re.classList.add(Ut.ROW_CLONE_CLASS), re.style.top = `${oe.offsetTop}px`;
    const ue = `${oe.children[0].offsetHeight}px`, fe = Array.from(oe.children || []);
    Array.from(re.children).forEach((he, _e) => {
      he.style.width = `${fe[_e].offsetWidth}px`, he.style.height = ue;
    }), fe.forEach((he) => {
      he.classList.add(Drag.CELL_HIDDEN_CLASS);
    }), Ut.appendTargetLine(Y);
  }
  static calculateThresholdDown(Y) {
    Ut.TARGET_DOWN_ROW && Y && (Ut.THRESHOLD_DOWN = Ut.TARGET_DOWN_ROW.offsetTop + Ut.TARGET_DOWN_ROW.offsetHeight / 2 - Y.offsetHeight);
  }
  static calculateThresholdUp() {
    Ut.TARGET_UP_ROW && (Ut.THRESHOLD_UP = Ut.TARGET_UP_ROW.offsetTop + Ut.TARGET_UP_ROW.offsetHeight / 2);
  }
  static initiateDragState(Y, re, oe) {
    var ue;
    if (Ut.TARGET_UP_ROW = oe.previousSibling, Ut.TARGET_DOWN_ROW = (ue = oe.nextSibling) == null ? void 0 : ue.nextSibling, !Ut.TARGET_UP_ROW && AddNewRowElement.isAddNewRowRow(Ut.TARGET_DOWN_ROW.children[0]))
      return;
    Ut.CLONE_ROW = re, Ut.ACTIVE_ROW_TOP_PX = oe.offsetTop, Ut.ACTIVE_INDEX = 0, Ut.calculateThresholdUp(), Ut.calculateThresholdDown(oe);
    const fe = Array.from(Y.children);
    Drag.ORIGINAL_INDEX = fe.findIndex((_e) => _e === oe);
    const he = fe[fe.length - 2].offsetHeight;
    Ut.MAX_DOWN = Y.offsetHeight - oe.offsetHeight - he;
  }
  static processRowCellsToDrag(Y, re) {
    const oe = re.parentElement;
    oe.dispatchEvent(new MouseEvent("mouseleave"));
    const ue = oe.cloneNode(!0);
    return oe?.insertAdjacentElement("afterend", ue), Ut.prepareElements(Y, ue, oe), Ut.initiateDragState(Y, ue, oe), oe;
  }
  static applyEventsToElement(Y, re, oe) {
    Ut.isDisabled(Y) || (re.onmousedown = () => {
      Ut.IS_MOUSE_DOWN = !0;
    }, re.onmousemove = () => {
      Ut.IS_MOUSE_DOWN && !Y._focusedElements.rowDragEl && Y._tableBodyElementRef && (Ut.INITIALISING_DRAG_PX += 1, Ut.INITIALISING_DRAG_PX > Drag.DRAG_PX_TO_MOVE && (Y._focusedElements.rowDragEl = Ut.processRowCellsToDrag(Y._tableBodyElementRef, oe), FocusedCellUtils.set(Y._focusedElements.cell, oe, 0, Drag.ORIGINAL_INDEX)));
    });
  }
  static moveTargetLine(Y, re) {
    Y.style.opacity = "1", Y.style.top = `${re}px`;
  }
  // Upon approaching the original row the target line is hidden
  static removeLineOnMoveDown(Y) {
    Y.style.opacity = "0", Ut.ACTIVE_INDEX = 0, Ut.THRESHOLD_TO_NO_LINE_DOWN = -1, Ut.calculateThresholdUp();
  }
  static attemptSwitchUp(Y, re) {
    var oe;
    Ut.TARGET_UP_ROW && re && (((oe = Ut.TARGET_UP_ROW.previousSibling) == null ? void 0 : oe.previousSibling) === re ? (Ut.THRESHOLD_TO_NO_LINE_UP = re.offsetTop + re.offsetHeight / 2, Ut.THRESHOLD_DOWN = Ut.TARGET_UP_ROW.offsetTop + Ut.TARGET_UP_ROW.offsetHeight / 2, Ut.TARGET_DOWN_ROW = Ut.TARGET_UP_ROW, Ut.TARGET_UP_ROW = re.previousSibling, Ut.TARGET_UP_ROW ? Ut.calculateThresholdUp() : Ut.THRESHOLD_UP = -1) : (Ut.moveTargetLine(Y, Ut.TARGET_UP_ROW.offsetTop - 3), Ut.THRESHOLD_DOWN = Ut.THRESHOLD_UP, Ut.TARGET_DOWN_ROW = Ut.TARGET_UP_ROW, Ut.TARGET_UP_ROW = Ut.TARGET_UP_ROW.previousSibling, Ut.calculateThresholdUp(), Ut.ACTIVE_INDEX -= 1));
  }
  // Upon approaching the original row the target line is hidden
  static removeLineOnMoveUp(Y, re) {
    Y.style.opacity = "0", Ut.ACTIVE_INDEX = 0, Ut.THRESHOLD_TO_NO_LINE_UP = -1, Ut.calculateThresholdDown(re);
  }
  static attemptSwitchDown(Y, re) {
    var oe;
    Ut.TARGET_DOWN_ROW && (Ut.TARGET_DOWN_ROW.nextSibling === re ? (Ut.THRESHOLD_TO_NO_LINE_DOWN = Ut.TARGET_DOWN_ROW.offsetTop + Ut.TARGET_DOWN_ROW.offsetHeight / 2, Ut.TARGET_UP_ROW = Ut.TARGET_DOWN_ROW, Ut.THRESHOLD_UP = Ut.TARGET_UP_ROW.offsetTop - Ut.TARGET_UP_ROW.offsetHeight / 2, Ut.TARGET_DOWN_ROW = (oe = re?.nextSibling) == null ? void 0 : oe.nextSibling, Ut.calculateThresholdDown(re)) : (Ut.moveTargetLine(Y, Ut.TARGET_DOWN_ROW.offsetTop + Ut.TARGET_DOWN_ROW.offsetHeight - 3), Ut.THRESHOLD_UP = Ut.THRESHOLD_DOWN, Ut.TARGET_UP_ROW = Ut.TARGET_DOWN_ROW, Ut.TARGET_DOWN_ROW = Ut.TARGET_DOWN_ROW.nextSibling, Ut.calculateThresholdDown(re), Ut.ACTIVE_INDEX += 1));
  }
  static windowDrag(Y, re) {
    if (Ut.isDisabled(Y) || !Ut.TARGET_LINE || !Y._focusedElements.rowDragEl || !Ut.CLONE_ROW)
      return;
    const oe = Math.max(0, Ut.ACTIVE_ROW_TOP_PX + re.movementY), ue = Math.min(oe, Ut.MAX_DOWN);
    Ut.ACTIVE_ROW_TOP_PX = ue, Ut.CLONE_ROW.style.top = `${Ut.ACTIVE_ROW_TOP_PX}px`, Ut.ACTIVE_ROW_TOP_PX > Ut.THRESHOLD_DOWN ? Ut.attemptSwitchDown(Ut.TARGET_LINE, Y._focusedElements.rowDragEl) : Ut.ACTIVE_ROW_TOP_PX < Ut.THRESHOLD_UP ? Ut.attemptSwitchUp(Ut.TARGET_LINE, Y._focusedElements.rowDragEl) : Ut.THRESHOLD_TO_NO_LINE_DOWN >= 0 && Ut.THRESHOLD_TO_NO_LINE_DOWN < Ut.ACTIVE_ROW_TOP_PX ? Ut.removeLineOnMoveDown(Ut.TARGET_LINE) : Ut.THRESHOLD_TO_NO_LINE_UP >= 0 && Ut.THRESHOLD_TO_NO_LINE_UP > Ut.ACTIVE_ROW_TOP_PX && Ut.removeLineOnMoveUp(Ut.TARGET_LINE, Y._focusedElements.rowDragEl);
  }
  static windowMouseUp(Y) {
    Ut.IS_MOUSE_DOWN = !1, !Ut.isDisabled(Y) && Y._focusedElements.rowDragEl && (Ut.resetElements(Y._focusedElements.rowDragEl), delete Y._focusedElements.rowDragEl, Ut.INITIALISING_DRAG_PX = 0, Ut.move(Y, Ut.ACTIVE_INDEX, MoveRow.move));
  }
  // row dragging is cumbersome when filter/pagination enabled as some rows are hidden
  static isDisabled(Y) {
    return Y.dragRows === !1 || Y.filter || Y.pagination;
  }
};
_DragRow.ROW_CLONE_CLASS = "row-clone";
_DragRow.INITIALISING_DRAG_PX = 0;
_DragRow.ACTIVE_ROW_TOP_PX = 0;
_DragRow.CLONE_ROW = null;
_DragRow.IS_MOUSE_DOWN = !1;
_DragRow.ACTIVE_INDEX = 0;
_DragRow.THRESHOLD_UP = 0;
_DragRow.THRESHOLD_DOWN = 0;
_DragRow.MAX_DOWN = 0;
_DragRow.THRESHOLD_TO_NO_LINE_DOWN = -1;
_DragRow.THRESHOLD_TO_NO_LINE_UP = -1;
let DragRow = _DragRow;
const _DragColumn = class Xt extends Drag {
  static setHeaderElementsToDefault(Y) {
    var re;
    const oe = (re = Y.parentElement) == null ? void 0 : re.children;
    Xt.CLONE_CELLS.forEach((ue) => ue.remove()), Array.from(oe || []).forEach((ue) => {
      ue.tagName === CellElement.HEADER_TAG && ue.classList.remove(Drag.CELL_HIDDEN_CLASS);
    }), Xt.DIVIDERS.forEach((ue) => {
      ue.style.pointerEvents = "";
    });
  }
  static applyCloneHeaderCell(Y, re, oe, ue) {
    re.classList.add(Drag.CELL_HIDDEN_CLASS), Y.classList.add(Xt.HEADER_CELL_CLONE_CLASS), Y.classList.add(Xt.HEADER_CELL_CLONE_ANIMATION_CLASS), Y.style.left = `${re.offsetLeft}px`, Y.style.height = ue, oe?.insertAdjacentElement("beforebegin", Y), Xt.CLONE_CELLS.push(Y), Xt.REAL_CELLS.push(re);
  }
  static getThreshold(Y, re) {
    const oe = Xt.REAL_CELLS[Xt.ACTIVE_INDEX + re], ue = Math.min(Y.offsetWidth / 2, oe?.offsetWidth / 2) * re;
    return Y.offsetLeft + ue;
  }
  static initiateDragState(Y, re) {
    if (Xt.ACTIVE_INDEX = Xt.REAL_CELLS.findIndex((_e) => re === _e), Xt.ACTIVE_INDEX + 2 >= Xt.CLONE_CELLS.length && Xt.ACTIVE_INDEX - 1 <= 0)
      return;
    Y._focusedElements.colDragEl = Xt.CLONE_CELLS[Xt.ACTIVE_INDEX], Y._focusedElements.colDragEl.classList.remove(Xt.HEADER_CELL_CLONE_ANIMATION_CLASS), Xt.ACTIVE_CELL_LEFT_PX = re.offsetLeft, Xt.THRESHOLD_LEFT = Xt.getThreshold(re, -1), Xt.THRESHOLD_RIGHT = Xt.getThreshold(re, 1);
    const oe = Xt.REAL_CELLS[0];
    Xt.MIN_LEFT = oe.classList.contains(IndexColumn.INDEX_CELL_CLASS) ? oe.offsetWidth : 0;
    const ue = Xt.REAL_CELLS[Xt.REAL_CELLS.length - 1], fe = ue.classList.contains(AddNewColumnElement.ADD_COLUMN_CELL_CLASS) ? 0 : ue.offsetWidth;
    Xt.MAX_LEFT = ue.offsetLeft + fe - re.offsetWidth;
    const he = Xt.REAL_CELLS[0].classList.contains(IndexColumn.INDEX_CELL_CLASS);
    Drag.ORIGINAL_INDEX = Xt.ACTIVE_INDEX - (he ? 1 : 0);
  }
  static processHeaderCellsToDrag(Y, re, oe) {
    var ue;
    const fe = `${re.offsetHeight}px`;
    Array.from(((ue = re.parentElement) == null ? void 0 : ue.children) || []).forEach((he) => {
      if (he.tagName === CellElement.HEADER_TAG) {
        const _e = he.cloneNode(!0);
        Xt.applyCloneHeaderCell(_e, he, oe, fe);
      } else
        he.style.pointerEvents = "none", Xt.DIVIDERS.push(he);
    }), Xt.initiateDragState(Y, re);
  }
  static applyEventsToElement(Y, re, oe) {
    Y.dragColumns !== !1 && (re.onmousedown = () => {
      Xt.IS_MOUSE_DOWN = !0;
    }, re.onmousemove = () => {
      var ue;
      if (Xt.IS_MOUSE_DOWN && !Y._focusedElements.colDragEl && (Xt.INITIALISING_DRAG_PX += 1, Xt.INITIALISING_DRAG_PX > Drag.DRAG_PX_TO_MOVE)) {
        const fe = (ue = oe.parentElement) == null ? void 0 : ue.children[oe.parentElement.children.length - 1];
        Xt.processHeaderCellsToDrag(Y, oe, fe), FocusedCellUtils.set(Y._focusedElements.cell, oe, 0, Drag.ORIGINAL_INDEX);
      }
    });
  }
  static switch(Y) {
    const re = Xt.CLONE_CELLS[Xt.ACTIVE_INDEX], oe = Xt.CLONE_CELLS[Xt.ACTIVE_INDEX + Y];
    Y > 0 ? (Xt.THRESHOLD_LEFT = Xt.THRESHOLD_RIGHT - 5, Xt.THRESHOLD_RIGHT = re.offsetLeft + oe.offsetWidth, oe.style.left = `${oe.offsetLeft - re.offsetWidth}px`) : (Xt.THRESHOLD_RIGHT = Xt.THRESHOLD_LEFT + 5, Xt.THRESHOLD_LEFT = re.offsetLeft - oe.offsetWidth, oe.style.left = `${oe.offsetLeft + re.offsetWidth}px`), ArrayUtils.swap(Xt.CLONE_CELLS, Xt.ACTIVE_INDEX, Xt.ACTIVE_INDEX + Y), Xt.ACTIVE_INDEX += Y;
  }
  static windowDrag(Y, re, oe) {
    if (Y.dragColumns === !1)
      return;
    const ue = Math.max(Xt.MIN_LEFT, Xt.ACTIVE_CELL_LEFT_PX + oe.movementX), fe = Math.min(ue, Xt.MAX_LEFT);
    Xt.ACTIVE_CELL_LEFT_PX = fe, re.style.left = `${Xt.ACTIVE_CELL_LEFT_PX}px`, Xt.ACTIVE_CELL_LEFT_PX > Xt.THRESHOLD_RIGHT ? Xt.switch(1) : Xt.ACTIVE_CELL_LEFT_PX < Xt.THRESHOLD_LEFT && Xt.switch(-1);
  }
  static windowMouseUp(Y) {
    if (Xt.IS_MOUSE_DOWN = !1, Y.dragColumns === !1 || !Y._focusedElements.colDragEl)
      return;
    Xt.setHeaderElementsToDefault(Y._focusedElements.colDragEl), delete Y._focusedElements.colDragEl, Xt.INITIALISING_DRAG_PX = 0, Xt.ACTIVE_CELL_LEFT_PX = 0, Xt.CLONE_CELLS = [], Xt.DIVIDERS = [];
    const re = Xt.REAL_CELLS[0].classList.contains(IndexColumn.INDEX_CELL_CLASS);
    DragRow.move(Y, Xt.ACTIVE_INDEX - Drag.ORIGINAL_INDEX - (re ? 1 : 0), MoveColumn.move), Xt.REAL_CELLS = [];
  }
};
_DragColumn.HEADER_CELL_CLONE_CLASS = "header-cell-clone";
_DragColumn.HEADER_CELL_CLONE_ANIMATION_CLASS = "header-cell-clone-animation";
_DragColumn.INITIALISING_DRAG_PX = 0;
_DragColumn.ACTIVE_CELL_LEFT_PX = 0;
_DragColumn.IS_MOUSE_DOWN = !1;
_DragColumn.CLONE_CELLS = [];
_DragColumn.REAL_CELLS = [];
_DragColumn.DIVIDERS = [];
_DragColumn.ACTIVE_INDEX = 0;
_DragColumn.THRESHOLD_RIGHT = 0;
_DragColumn.THRESHOLD_LEFT = 0;
_DragColumn.MAX_LEFT = 0;
_DragColumn.MIN_LEFT = 0;
let DragColumn = _DragColumn;
class DropdownCellOverlay {
}
DropdownCellOverlay.HIDDEN_PX = "0px";
DropdownCellOverlay.VISIBLE_PX = "10px";
DropdownCellOverlay.DROPDOWN_CELL_OVERLAY_CLASS = "dropdown-cell-overlay";
const _ColumnDropdownCellOverlay = class ha {
  static setDefault(Y, re) {
    var oe;
    Y.style.backgroundColor = ((oe = re?.default) == null ? void 0 : oe.backgroundColor) || "";
  }
  static resetDefaultColor(Y, re) {
    var oe;
    const ue = re?.overlayStyles;
    (oe = ue?.hover) != null && oe.backgroundColor && ha.setDefault(Y, ue);
  }
  static setHoverColor(Y, re) {
    var oe, ue;
    const fe = (ue = (oe = re?.overlayStyles) == null ? void 0 : oe.hover) == null ? void 0 : ue.backgroundColor;
    fe && (Y.columnDropdownCellOverlay.style.backgroundColor = fe);
  }
  static hide(Y, re) {
    const { columnDropdownCellOverlay: oe } = re, ue = Y._hoveredElements.headerCell;
    setTimeout(() => {
      ue !== Y._hoveredElements.headerCell && (oe.style.height = DropdownCellOverlay.HIDDEN_PX);
    });
  }
  static setHorizontalDimensions(Y) {
    const { columnDropdownCellOverlay: re, elements: oe } = Y, ue = oe[0].offsetWidth / 100;
    re.style.width = `${ue * 50}px`, re.style.right = `${ue * 25}px`;
  }
  static display(Y) {
    Y.columnDropdownCellOverlay.style.height = DropdownCellOverlay.VISIBLE_PX, ha.setHorizontalDimensions(Y);
  }
  static isDisplayed(Y) {
    return Y.style.height === DropdownCellOverlay.VISIBLE_PX;
  }
  static updateIfDisplayed(Y) {
    ha.isDisplayed(Y.columnDropdownCellOverlay) && ha.setHorizontalDimensions(Y);
  }
  static create(Y, re, oe) {
    const ue = document.createElement("div");
    return ue.classList.add(DropdownCellOverlay.DROPDOWN_CELL_OVERLAY_CLASS), ue.classList.add(ha.COLUMN_DROPDOWN_CELL_OVERLAY_CLASS), ue.style.height = DropdownCellOverlay.HIDDEN_PX, ha.setDefault(ue, oe), DragColumn.applyEventsToElement(Y, ue, re), ue;
  }
  static add(Y, re) {
    var oe, ue;
    const fe = (ue = (oe = Y._defaultColumnsSettings.columnDropdown) == null ? void 0 : oe.displaySettings) == null ? void 0 : ue.overlayStyles, he = Y._columnsDetails[re].elements[0], _e = ha.create(Y, he, fe);
    return he.nextSibling.appendChild(_e), _e;
  }
};
_ColumnDropdownCellOverlay.COLUMN_DROPDOWN_CELL_OVERLAY_CLASS = "column-dropdown-cell-overlay";
let ColumnDropdownCellOverlay = _ColumnDropdownCellOverlay;
const _MovableColumnSizerElement = class ua {
  // this is recalculated as it depends on the column index that the sizer is on
  static setStaticProperties(Y, re, oe) {
    Y.style.marginRight = re, Y.style.width = oe;
  }
  // the vertical line has no pointer events, hence it should not be expected to be passed in here
  static isMovableColumnSizer(Y) {
    return Y.classList.contains(ua.MOVABLE_SIZER_CLASS);
  }
  static getVerticalLineHeight(Y, re) {
    let oe = Y.offsetHeight;
    if (re) {
      const ue = Y.lastChild.offsetHeight;
      oe -= ue;
    }
    return oe;
  }
  static display(Y, re, oe) {
    const ue = re.movableElement;
    ue.style.display = "flex";
    const fe = ue.children[0];
    fe.style.height = `${ua.getVerticalLineHeight(Y, oe)}px`;
  }
  static hide(Y) {
    Y.style.display = "none", Y.style.left = "";
  }
  static createVerticalLine(Y) {
    const re = document.createElement("div");
    return re.style.backgroundColor = Y, re.classList.add(ua.VERTICAL_LINE_CLASS), re;
  }
  static getMovableBackgroundColor(Y) {
    return Y.click || Y.hover || ua.DEFAULT_BACKGROUND_COLOR;
  }
  static create(Y) {
    const re = ua.getMovableBackgroundColor(Y), oe = document.createElement("div");
    oe.style.backgroundColor = re, oe.classList.add(ua.MOVABLE_SIZER_CLASS), ua.hide(oe);
    const ue = ua.createVerticalLine(re);
    return oe.appendChild(ue), oe;
  }
};
_MovableColumnSizerElement.DEFAULT_BACKGROUND_COLOR = "#4668ed";
_MovableColumnSizerElement.MOVABLE_SIZER_CLASS = "movable-column-sizer";
_MovableColumnSizerElement.VERTICAL_LINE_CLASS = "movable-column-sizer-vertical-line";
let MovableColumnSizerElement = _MovableColumnSizerElement;
class MoveLimits {
  // Borders of the side cells tend to breach over the limits of the table (when no side frame elements),
  // causing the offsets to give incorrect data and set the limits beyond the table. The breach magnitude is
  // influenced by the sizer start position when cells have borders - which is the very center position of
  // the total of those two borders width.
  // prettier-ignore
  static getSideLimitDelta(Y) {
    const re = ExtractElements.getRightColumnSiblingCell(Y);
    return ((Number.parseFloat(getComputedStyle(Y).borderRightWidth) || 0) - (Number.parseFloat(getComputedStyle(re).borderLeftWidth) || 0)) / 2;
  }
  static getRightLimitDynamicWidthTable() {
    return window.innerWidth;
  }
  // prettier-ignore
  static getRightLimitForMaxWidth(Y, re, oe) {
    return StaticTable.isTableAtMaxWidth(Y, re) ? oe ? Number.parseFloat(oe.style.width) : 0 : re.maxWidth - Y.offsetWidth;
  }
  static getRightLimit(Y, re) {
    return Y._tableDimensions.width !== void 0 ? Number.parseFloat(re.style.width) : Y._tableDimensions.maxWidth !== void 0 && Y._tableElementRef ? MoveLimits.getRightLimitForMaxWidth(Y._tableElementRef, Y._tableDimensions, re) : MoveLimits.getRightLimitDynamicWidthTable();
  }
  static getLeftLimit(Y, re) {
    let oe = -Y.offsetWidth;
    return re !== void 0 && (oe += re), oe;
  }
  // prettier-ignore
  static generate(Y, re, oe, ue, fe, he) {
    const _e = re || oe ? MoveLimits.getSideLimitDelta(he) : 0;
    return {
      left: MoveLimits.getLeftLimit(he, re ? _e : void 0) + ue,
      right: MoveLimits.getRightLimit(Y, fe)
    };
  }
}
class SelectedColumnSizer {
  // prettier-ignore
  static generateObj(Y, re, oe, ue, fe, he) {
    const _e = re.movableElement.offsetLeft;
    return {
      element: re.element,
      moveLimits: MoveLimits.generate(Y, oe, ue, _e, he, fe),
      // this is to reflect the initial sizer offset to center itself in the cell divider
      initialOffset: _e,
      mouseMoveOffset: _e,
      fireColumnsUpdate: FireEvents.onColumnsUpdate.bind(this, Y)
    };
  }
  static get(Y, re) {
    const oe = Y._columnsDetails[re].columnSizer, ue = re === 0, fe = Y._columnsDetails.length - 2 === re, he = Y._columnsDetails[re].elements[0], _e = ColumnSizerGenericUtils.findNextResizableColumnHeader(Y._columnsDetails, re);
    return SelectedColumnSizer.generateObj(Y, oe, ue, fe, he, _e);
  }
}
const SEMI_TRANSPARENT_COLOR = "#ffffff01";
class ColumnSizer {
  static shouldWidthBeIncreased(Y) {
    return Y > 4;
  }
  // prettier-ignore
  static getBackgroundImage(Y, re, oe, ue, fe) {
    if (ue && fe) {
      if (Number.parseInt(getComputedStyle(fe).borderRightWidth) > 0 && (re > 0 || oe === void 0 || oe > 0))
        return ColumnSizerElement.EMPTY_BACKGROUND_IMAGE;
    } else if (Y > 0)
      return ColumnSizerElement.EMPTY_BACKGROUND_IMAGE;
    return ColumnSizerElement.FILLED_BACKGROUND_IMAGE;
  }
  static getMarginRight(Y, re) {
    return re || !Y ? "0px" : `${Y.leftCellRight - Y.rightCellLeft}px`;
  }
  static getTotalCellBorderWidth(Y) {
    return Y ? Y.rightCellLeft + Y.leftCellRight : 0;
  }
  static generateBorderWidthsInfo(Y, re) {
    var oe, ue, fe;
    const he = {
      rightCellLeft: 0,
      leftCellLeft: 0,
      leftCellRight: 0,
      beforeLeftCellRight: void 0
    }, _e = (oe = Y[re - 1]) == null ? void 0 : oe.elements[0];
    _e && (he.beforeLeftCellRight = Number.parseInt(getComputedStyle(_e).borderRightWidth) || 0);
    const ve = (ue = Y[re]) == null ? void 0 : ue.elements[0];
    if (ve) {
      const Ee = getComputedStyle(ve);
      he.leftCellLeft = Number.parseInt(Ee.borderLeftWidth) || 0, he.leftCellRight = Number.parseInt(Ee.borderRightWidth) || 0;
    }
    const xe = (fe = Y[re + 1]) == null ? void 0 : fe.elements[0];
    return xe && (he.rightCellLeft = Number.parseInt(getComputedStyle(xe).borderLeftWidth) || 0), he;
  }
  // prettier-ignore
  static createObject(Y, re, oe, ue, fe, he, _e) {
    const ve = ColumnSizer.generateBorderWidthsInfo(re, oe), xe = ColumnSizer.getTotalCellBorderWidth(ve), Ee = re.length - 1 === oe, Se = ColumnSizer.getMarginRight(ve, Ee), Te = ColumnSizer.getBackgroundImage(
      xe,
      ve.leftCellLeft,
      ve.beforeLeftCellRight,
      Ee,
      ue
    ), Ce = ColumnSizer.shouldWidthBeIncreased(xe), Ie = {
      element: Y,
      styles: {
        default: {
          width: Ce ? `${xe + 2}px` : "1.5px",
          backgroundImage: Te
        },
        hover: {
          width: Ce ? `${(xe + 2) * 1.5}px` : "9px"
        },
        static: {
          marginRight: Se
        }
      },
      isSideCellHovered: !1,
      isSizerHovered: !1,
      isMouseUpOnSizer: !1
    };
    return _e && (Ie.hoverColor = _e.hover || ColumnSizerElement.DEFAULT_HOVER_COLOR), he && (Ie.movableElement = he), fe && (Ie.overlayElement = fe), Ie;
  }
  // prettier-ignore
  static create(Y, re) {
    const { _columnsDetails: oe, _tableElementRef: ue, columnResizerColors: fe } = Y, he = ColumnSizerElement.create(re, fe.hover), _e = MovableColumnSizerElement.create(fe), ve = ColumnSizerOverlayElement.create(), xe = ColumnSizer.createObject(
      he,
      oe,
      re,
      ue,
      ve,
      _e,
      fe
    );
    return ColumnSizerOverlayElement.applyEvents(Y, xe), xe;
  }
}
const _ColumnSizerFillerElement = class Ji {
  static create(Y) {
    const re = document.createElement("div");
    return re.classList.add(Ji.SIZER_FILLER_CLASS), re.style.backgroundColor = Y || ColumnSizerElement.DEFAULT_HOVER_COLOR, re.style.display = "none", re;
  }
  static setWidth(Y, re) {
    const oe = Number.parseInt(re);
    Y.style.width = `${ColumnSizer.shouldWidthBeIncreased(oe) ? oe : 4}px`;
  }
  static display(Y) {
    Y.style.display = "block";
  }
  static hide(Y) {
    Y.style.display = "none";
  }
};
_ColumnSizerFillerElement.SIZER_FILLER_CLASS = "column-sizer-filler";
let ColumnSizerFillerElement = _ColumnSizerFillerElement;
const _ColumnSizerElement = class Rr {
  static isHovered(Y) {
    return Y.style.backgroundImage === Rr.EMPTY_BACKGROUND_IMAGE;
  }
  static setBackgroundImage(Y, re) {
    Y.style.backgroundImage = re;
  }
  static unsetBackgroundImage(Y) {
    Y.style.backgroundImage = Rr.EMPTY_BACKGROUND_IMAGE;
  }
  static setBackgroundColor(Y, re) {
    Y.style.backgroundColor = re;
  }
  static setTransitionTime(Y) {
    Y.style.transition = Rr.TRANSITION_TIME;
  }
  static unsetTransitionTime(Y) {
    Y.style.transition = "0.0s";
  }
  // is not used to unset background image
  static unsetElementsToDefault(Y, re, oe = !0) {
    oe && Rr.setBackgroundColor(Y, SEMI_TRANSPARENT_COLOR), ColumnSizerFillerElement.hide(Y.children[0]), Y.style.width = re;
  }
  // this is recalculated as it depends on the column index that the sizer is on
  static setStaticProperties(Y, re) {
    Y.style.marginRight = re;
  }
  static setElementId(Y, re) {
    Y.id = `${Rr.COLUMN_SIZER_ID_PREFIX}${re}`;
  }
  static create(Y, re) {
    const oe = document.createElement("div");
    Rr.setElementId(oe, Y), oe.classList.add(Rr.COLUMN_SIZER_CLASS);
    const ue = ColumnSizerFillerElement.create(re);
    return oe.append(ue), Rr.hide(oe), oe;
  }
  static display(Y) {
    var re;
    UpdateRowElement.updateHeaderRowHeight((re = Y.parentElement) == null ? void 0 : re.parentElement), Y.style.display = "flex";
  }
  static hide(Y) {
    Y.style.display = "none";
  }
  static hideWithBlurAnimation(Y) {
    setTimeout(() => {
      Rr.hide(Y);
    }, Rr.HALF_TRANSITION_TIME_ML);
  }
  static hideWhenCellNotHovered(Y, re) {
    Y.isSideCellHovered || (re ? Rr.hideWithBlurAnimation(Y.element) : Rr.hide(Y.element));
  }
  static setHoverStyle(Y, re, oe, ue) {
    const { element: fe, hoverColor: he } = Y;
    ColumnSizerFillerElement.display(fe.children[0]), oe && Rr.setTransitionTime(fe), Rr.setBackgroundColor(fe, ue || he), fe.style.width = re;
  }
};
_ColumnSizerElement.FILLED_BACKGROUND_IMAGE = "linear-gradient(180deg, #cdcdcd, #cdcdcd 75%, transparent 75%, transparent 100%)";
_ColumnSizerElement.EMPTY_BACKGROUND_IMAGE = "none";
_ColumnSizerElement.DEFAULT_HOVER_COLOR = "grey";
_ColumnSizerElement.COLUMN_SIZER_CLASS = "column-sizer";
_ColumnSizerElement.COLUMN_SIZER_ID_PREFIX = `${_ColumnSizerElement.COLUMN_SIZER_CLASS}-`;
_ColumnSizerElement.TRANSITION_TIME_ML = 200;
_ColumnSizerElement.TRANSITION_TIME = `${_ColumnSizerElement.TRANSITION_TIME_ML / 1e3}s`;
_ColumnSizerElement.HALF_TRANSITION_TIME_ML = _ColumnSizerElement.TRANSITION_TIME_ML / 2;
let ColumnSizerElement = _ColumnSizerElement;
const _ColumnSizerOverlayEvents = class yi {
  static overlayMouseEnter(Y) {
    if (Y.isSizerHovered = !0, Y.isMouseUpOnSizer || this._activeOverlayElements.selectedColumnSizer)
      return;
    const { width: re } = Y.styles.hover;
    ColumnSizerElement.display(Y.element), ColumnSizerElement.setTransitionTime(Y.element), setTimeout(() => {
      Y.isSizerHovered && ColumnSizerElement.setHoverStyle(Y, re, !1);
    }, 1), setTimeout(() => {
      Y.isSizerHovered && ColumnSizerElement.unsetBackgroundImage(Y.element);
    }, yi.MOUSE_PASSTHROUGH_TIME_ML);
  }
  // the constant if statement checking is used to prevent a bug where if a mouse leaves the sizer and immediately reenters
  // the timeouts would still proceed to execute the code below
  static unsetColorDuringTransition(Y) {
    setTimeout(() => {
      Y.isSizerHovered || (ColumnSizerElement.setBackgroundImage(Y.element, Y.styles.default.backgroundImage), setTimeout(() => {
        Y.isSizerHovered || (ColumnSizerElement.unsetTransitionTime(Y.element), ColumnSizerElement.setBackgroundColor(Y.element, SEMI_TRANSPARENT_COLOR));
      }, ColumnSizerElement.HALF_TRANSITION_TIME_ML));
    }, ColumnSizerElement.HALF_TRANSITION_TIME_ML);
  }
  static overlayMouseLeave(Y) {
    if (Y.isSizerHovered = !1, this._activeOverlayElements.selectedColumnSizer || Y.isMouseUpOnSizer)
      return;
    const { element: re, styles: oe } = Y;
    ColumnSizerElement.unsetElementsToDefault(re, oe.default.width);
    const ue = ColumnSizerElement.isHovered(re);
    setTimeout(() => {
      !this._activeOverlayElements.selectedColumnSizer && !Y.isSizerHovered && (yi.unsetColorDuringTransition(Y), ColumnSizerElement.hideWhenCellNotHovered(Y, ue));
    }, yi.MOUSE_PASSTHROUGH_TIME_ML);
  }
  // we need to pass down the sizer element instead of the id as the id can change when columns are inserted/removed
  // prettier-ignore
  static overlayMouseDown(Y) {
    const { _columnsDetails: re, _tableBodyElementRef: oe, _frameComponents: { displayAddNewRow: ue } } = this, { columnSizer: fe, sizerNumber: he } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(Y.id, re), { element: _e, styles: ve } = fe;
    MovableColumnSizerElement.display(oe, fe, ue), ColumnSizerElement.unsetElementsToDefault(_e, ve.default.width), ColumnSizerElement.setBackgroundImage(_e, ve.default.backgroundImage), this._activeOverlayElements.selectedColumnSizer = SelectedColumnSizer.get(this, he);
  }
};
_ColumnSizerOverlayEvents.MOUSE_PASSTHROUGH_TIME_ML = 50;
let ColumnSizerOverlayEvents = _ColumnSizerOverlayEvents;
const _ColumnSizerOverlayElement = class Zi {
  // this is recalculated as it depends on the column index that the sizer is on
  static setStaticProperties(Y, re, oe) {
    Y.style.marginRight = re, Y.style.width = oe;
  }
  static applyEvents(Y, re) {
    re.overlayElement.onmouseenter = ColumnSizerOverlayEvents.overlayMouseEnter.bind(Y, re), re.overlayElement.onmouseleave = ColumnSizerOverlayEvents.overlayMouseLeave.bind(Y, re), re.overlayElement.onmousedown = ColumnSizerOverlayEvents.overlayMouseDown.bind(Y, re.element);
  }
  static create() {
    const Y = document.createElement("div");
    return Y.classList.add(Zi.SIZER_OVERLAY_CLASS), Y;
  }
};
_ColumnSizerOverlayElement.SIZER_OVERLAY_CLASS = "column-sizer-overlay";
let ColumnSizerOverlayElement = _ColumnSizerOverlayElement;
class InsertRemoveColumnSizer {
  static updateIdsOfAllSubsequent(Y, re) {
    Y.slice(re).forEach((oe, ue) => {
      if (!oe.columnSizer)
        return;
      const fe = re + ue;
      ColumnSizerElement.setElementId(oe.columnSizer.element, fe);
    });
  }
  static applySizerStateToElements(Y) {
    const { element: re, movableElement: oe, overlayElement: ue, styles: fe } = Y;
    ColumnSizerElement.unsetElementsToDefault(re, fe.default.width), ColumnSizerFillerElement.setWidth(re.children[0], fe.default.width), ColumnSizerElement.setStaticProperties(re, fe.static.marginRight), ColumnSizerElement.setBackgroundImage(re, fe.default.backgroundImage), MovableColumnSizerElement.setStaticProperties(oe, fe.static.marginRight, fe.hover.width), ColumnSizerOverlayElement.setStaticProperties(ue, fe.static.marginRight, fe.hover.width);
  }
  static insertAtIndex(Y, re, oe) {
    const ue = re.elements[0].nextSibling, fe = ColumnSizer.create(Y, oe);
    re.columnSizer = fe, ue.appendChild(fe.element), ue.appendChild(fe.overlayElement), ue.appendChild(fe.movableElement), InsertRemoveColumnSizer.applySizerStateToElements(fe);
  }
  // prettier-ignore
  static updateSizer(Y, re, oe, ue) {
    const fe = ColumnSizer.createObject(Y.element, re, oe, ue);
    Object.assign(Y, fe), InsertRemoveColumnSizer.applySizerStateToElements(Y);
  }
  static updatePrevious(Y, re, oe) {
    var ue;
    const fe = re - 1;
    if (fe < 0)
      return;
    const { columnSizer: he } = Y[fe];
    ((ue = Y[fe].settings.widths) == null ? void 0 : ue.staticWidth) !== void 0 || !he || InsertRemoveColumnSizer.updateSizer(he, Y, re, oe);
  }
  static getNewColumnIndexIfWidthSet(Y, re) {
    var oe;
    return Y.length - 1 === re ? (oe = Y[re - 1]) != null && oe.columnSizer ? -1 : re - 1 : re;
  }
  static isNotResizable(Y) {
    const { widths: re, isColumnResizable: oe } = Y.settings;
    return re?.staticWidth !== void 0 || !oe;
  }
  // REF-13
  static insert(Y, re) {
    const { _columnsDetails: oe } = Y;
    if (!InsertRemoveColumnSizer.isNotResizable(oe[re])) {
      if (Y._tableDimensions.width !== void 0) {
        if (re = InsertRemoveColumnSizer.getNewColumnIndexIfWidthSet(Y._columnsDetails, re), re === -1 || InsertRemoveColumnSizer.isNotResizable(oe[re]))
          return;
      } else
        InsertRemoveColumnSizer.updatePrevious(oe, re, Y._tableElementRef);
      InsertRemoveColumnSizer.insertAtIndex(Y, oe[re], re), InsertRemoveColumnSizer.updateIdsOfAllSubsequent(oe, re + 1);
    }
  }
  // this is only used for when table width is static, otherwise it is removed directly with the column
  static removeSizer(Y) {
    var re, oe, ue, fe, he, _e;
    (oe = (re = Y.columnSizer) == null ? void 0 : re.element) == null || oe.remove(), (fe = (ue = Y.columnSizer) == null ? void 0 : ue.movableElement) == null || fe.remove(), (_e = (he = Y.columnSizer) == null ? void 0 : he.overlayElement) == null || _e.remove(), delete Y.columnSizer;
  }
  // need to remove the sizer of the new last column as when width is set - last column does not have a sizer
  static removeIfLastColumn(Y, re) {
    return Y.length === re && Y[re] && (re -= 1, InsertRemoveColumnSizer.removeSizer(Y[re])), re;
  }
  static remove(Y, re) {
    const { _tableDimensions: oe, _columnsDetails: ue, _tableElementRef: fe } = Y;
    oe.width !== void 0 && (re = InsertRemoveColumnSizer.removeIfLastColumn(ue, re)), InsertRemoveColumnSizer.updatePrevious(ue, re, fe), InsertRemoveColumnSizer.updateIdsOfAllSubsequent(ue, re);
  }
  // This is used to cleanup sizers for columns that have or had static widths because they do not have sizers,
  // additionally when the table width is set the last column that is not static also does not have a sizer.
  static cleanUpCustomColumnSizers(Y, re) {
    const { _tableDimensions: oe, _columnsDetails: ue } = Y;
    if (oe.width === void 0)
      return;
    let fe = !1;
    for (let he = ue.length - 1; he >= 0; he -= 1) {
      const _e = ue[he];
      if (InsertRemoveColumnSizer.isNotResizable(_e))
        _e.columnSizer && InsertRemoveColumnSizer.removeSizer(_e);
      else if (fe === !1) {
        if (fe = !0, _e.columnSizer && InsertRemoveColumnSizer.removeSizer(_e), he < re)
          break;
      } else if (!_e.columnSizer && ue.length - 1 !== he && InsertRemoveColumnSizer.insertAtIndex(Y, _e, he), fe === !0 && he < re)
        break;
    }
  }
}
class DropdownDisplaySettingsUtil {
  static process(Y) {
    Y.isAvailable ?? (Y.isAvailable = !0), Y.isAvailable ? (Y.openMethod ?? (Y.openMethod = {}), Y.openMethod.overlayClick ? delete Y.openMethod.cellClick : Y.openMethod.cellClick ? delete Y.openMethod.overlayClick : Y.openMethod.overlayClick = !0) : (delete Y.openMethod, delete Y.overlayStyles);
  }
}
class ColumnSettingsDefaultTextUtils {
  static unsetDefaultText(Y, re, oe) {
    re.elements.slice(1).forEach((ue, fe) => {
      const he = fe + 1;
      CellEvents.removeTextIfDefault(Y, he, oe, ue);
    });
  }
  static setDefaultText(Y, re, oe) {
    re.elements.slice(1).forEach((ue, fe) => {
      const he = fe + 1;
      CellEvents.setCellToDefaultIfNeeded(Y, he, oe, ue, !1);
    }), setTimeout(() => FireEvents.onDataUpdate(Y));
  }
}
class ColumnSettingsWidthUtils {
  // prettier-ignore
  static getSettingsWidthNumber(Y, re, oe = !0) {
    return StringDimensionUtils.generateNumberDimensionFromClientString(
      Y,
      re,
      oe ? "staticWidth" : "initialWidth",
      !0,
      ColumnDetails.MINIMAL_COLUMN_WIDTH
    );
  }
  static updateColumnWidth(Y, re, oe, ue) {
    const { _tableDimensions: fe, _tableElementRef: he } = Y, { number: _e } = ColumnSettingsWidthUtils.getSettingsWidthNumber(he, oe);
    re.style.width = `${_e}px`, TableElement.changeStaticWidthTotal(fe, ue ? _e : -_e);
  }
  // prettier-ignore
  static changeWidth(Y, re, oe, ue) {
    let fe = !1;
    oe != null && oe.staticWidth && (ColumnSettingsWidthUtils.updateColumnWidth(Y, re, oe, !1), fe = !0), ue != null && ue.staticWidth && (ColumnSettingsWidthUtils.updateColumnWidth(Y, re, ue, !0), fe = !0), fe && StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(Y, !0);
  }
}
class ColumnDropdownCellOverlayEvents {
  static mouseClick(Y, re) {
    ColumnDropdown.display(this, Y);
    const oe = re.elements[0];
    setTimeout(() => FocusedCellUtils.setHeaderCell(this._focusedElements.cell, oe, Y));
  }
  // prettier-ignore
  static mouseLeave(Y) {
    var re;
    ColumnDropdownCellOverlay.hide(this, Y), delete this._hoveredElements.headerCell, ColumnDropdownCellOverlay.resetDefaultColor(
      Y.columnDropdownCellOverlay,
      (re = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : re.displaySettings
    );
  }
  static mouseEnter(Y) {
    var re;
    const oe = Y.elements[0];
    this._hoveredElements.headerCell = oe, ColumnDropdownCellOverlay.setHoverColor(Y, (re = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : re.displaySettings);
  }
  static setEvents(Y, re) {
    const oe = Y._columnsDetails[re], { columnDropdownCellOverlay: ue } = oe;
    ue && (ue.onmouseenter = ColumnDropdownCellOverlayEvents.mouseEnter.bind(Y, oe), ue.onmouseleave = ColumnDropdownCellOverlayEvents.mouseLeave.bind(Y, oe), ue.onclick = ColumnDropdownCellOverlayEvents.mouseClick.bind(Y, re, oe));
  }
}
class EditableHeaderIconTextEvents {
  static keyDownOnText(Y, re, oe) {
    UpdateRowElement.updateHeadRowHeightOnKeyDown(this._tableBodyElementRef), oe.key === KEYBOARD_KEY.TAB && CellTextEvents.tabOutOfCell(this, Y, re, oe);
  }
  // REF-15
  static blurText(Y, re, oe) {
    const ue = oe.target, fe = CellElement.getCellElement(ue);
    HeaderText.onAttemptChange(this, fe, re), DataCellEvents.blur(this, Y, re, ue);
  }
  static setEvents(Y, re, oe, ue) {
    Y._columnsDetails[ue].settings.isHeaderTextEditable && (re.onfocus = CellWithTextEvents.focusText.bind(Y, oe, ue, null), re.onblur = EditableHeaderIconTextEvents.blurText.bind(Y, oe, ue), re.onkeydown = EditableHeaderIconTextEvents.keyDownOnText.bind(Y, oe, ue));
  }
}
class ColumnSizerCellEvents {
  static hideColumnSizer(Y) {
    if (!Y)
      return;
    Y.isSideCellHovered = !1;
    const re = ColumnSizerElement.isHovered(Y.element);
    setTimeout(() => {
      Y.isSizerHovered || ColumnSizerElement.hideWhenCellNotHovered(Y, re);
    });
  }
  static cellMouseLeave(Y, re) {
    var oe, ue;
    ColumnSizerCellEvents.hideColumnSizer((oe = Y[re - 1]) == null ? void 0 : oe.columnSizer), ColumnSizerCellEvents.hideColumnSizer((ue = Y[re]) == null ? void 0 : ue.columnSizer);
  }
  static displayColumnSizer(Y) {
    Y && (ColumnSizerElement.display(Y.element), Y.isSideCellHovered = !0);
  }
  static cellMouseEnter(Y, re) {
    var oe, ue;
    ColumnSizerCellEvents.displayColumnSizer((oe = Y[re - 1]) == null ? void 0 : oe.columnSizer), ColumnSizerCellEvents.displayColumnSizer((ue = Y[re]) == null ? void 0 : ue.columnSizer);
  }
}
class HeaderCellEvents {
  static mouseEnterCell(Y, re) {
    var oe, ue, fe, he;
    if (!this._activeOverlayElements.selectedColumnSizer) {
      const _e = this._columnsDetails[Y], ve = re.target;
      CellHighlightUtils.highlight(ve, (oe = _e.headerStateColors) == null ? void 0 : oe.hover), ColumnSizerCellEvents.cellMouseEnter(this._columnsDetails, Y), (he = (fe = (ue = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : ue.displaySettings) == null ? void 0 : fe.openMethod) != null && he.overlayClick && ColumnDropdownCellOverlay.display(_e), this._hoveredElements.headerCell = ve;
    }
  }
  static mouseLeaveCell(Y, re) {
    var oe, ue, fe, he;
    Dropdown.isDisplayed(this._activeOverlayElements.columnDropdown) || (CellHighlightUtils.fade(re.target, (oe = this._columnsDetails[Y].headerStateColors) == null ? void 0 : oe.default), ColumnDropdownCellOverlay.hide(this, this._columnsDetails[Y]), (he = (fe = (ue = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : ue.displaySettings) == null ? void 0 : fe.openMethod) != null && he.overlayClick && delete this._hoveredElements.headerCell), this._activeOverlayElements.selectedColumnSizer || ColumnSizerCellEvents.cellMouseLeave(this._columnsDetails, Y);
  }
  static mouseClick(Y, re) {
    var oe, ue, fe;
    const he = re.target;
    CellEvents.removeTextIfDefault(this, 0, Y, he), (fe = (ue = (oe = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : oe.displaySettings) == null ? void 0 : ue.openMethod) != null && fe.cellClick && ColumnDropdown.display(this, Y), setTimeout(() => FocusedCellUtils.setHeaderCell(this._focusedElements.cell, he, Y));
  }
  static setEvents(Y, re, oe) {
    re.onmouseenter = HeaderCellEvents.mouseEnterCell.bind(Y, oe), re.onmouseleave = HeaderCellEvents.mouseLeaveCell.bind(Y, oe), re.onclick = HeaderCellEvents.mouseClick.bind(Y, oe), DragColumn.applyEventsToElement(Y, re, re);
  }
}
class EditableHeaderCellEvents {
  static mouseClickCell(Y, re) {
    const oe = re.target;
    FocusedCellUtils.purge(this._focusedElements.cell), setTimeout(() => FocusedCellUtils.setHeaderCell(this._focusedElements.cell, oe, Y));
  }
  static setEvents(Y, re, oe, ue) {
    if (re.onmouseenter = HeaderCellEvents.mouseEnterCell.bind(Y, ue), re.onmouseleave = HeaderCellEvents.mouseLeaveCell.bind(Y, ue), Y.displayHeaderIcons) {
      re.onfocus = () => {
      }, re.onblur = () => {
      }, re.onmousedown = CellWithTextEvents.mouseDown.bind(Y, null), re.onclick = EditableHeaderCellEvents.mouseClickCell.bind(Y, ue);
      const fe = CellElement.getTextElement(re);
      EditableHeaderIconTextEvents.setEvents(Y, fe, oe, ue);
    } else
      re.onclick = HeaderCellEvents.mouseClick.bind(Y, ue);
  }
}
class CellEventsReset {
  static unset(Y) {
    Y.onfocus = () => {
    }, Y.onblur = () => {
    }, Y.onmouseenter = () => {
    }, Y.onmouseleave = () => {
    }, Y.onmousedown = () => {
    }, Y.oninput = () => {
    }, Y.onpaste = () => {
    }, Y.onkeydown = () => {
    };
  }
  static setDataCellEvents(Y, re, oe, ue) {
    const { settings: fe, activeType: he } = Y._columnsDetails[ue];
    if (!fe.isCellTextEditable)
      return;
    DataCellEvents.setEvents(Y, re, oe, ue);
    const { cellDropdownProps: _e, calendar: ve, checkbox: xe } = he;
    _e ? SelectCell.setEvents(Y, re, oe, ue) : ve ? DateCellEvents.setEvents(Y, re, oe, ue) : xe && CheckboxCellEvents.setEvents(Y, re, oe, ue);
  }
  static setHeaderCellEvents(Y, re, oe, ue) {
    var fe, he, _e;
    (_e = (he = (fe = Y._defaultColumnsSettings.columnDropdown) == null ? void 0 : fe.displaySettings) == null ? void 0 : he.openMethod) != null && _e.cellClick ? HeaderCellEvents.setEvents(Y, re, ue) : (DataCellEvents.setEvents(Y, re, oe, ue), EditableHeaderCellEvents.setEvents(Y, re, 0, ue), ColumnDropdownCellOverlayEvents.setEvents(Y, ue));
  }
  // REF-33
  static reset(Y, re, oe, ue) {
    oe === 0 ? CellEventsReset.setHeaderCellEvents(Y, re, oe, ue) : CellEventsReset.setDataCellEvents(Y, re, oe, ue), !Y._frameComponents.displayIndexColumn && ue === 0 && RowDropdownCellOverlayEvents.addCellEvents(Y, oe, re);
  }
}
class ResetColumnStructure {
  static reset(Y, re, oe) {
    const { elements: ue, activeType: fe, settings: he } = re;
    ue.slice(1).forEach((_e) => {
      he.isCellTextEditable || CellEventsReset.unset(_e);
    }), ChangeColumnType.setNewStructureBasedOnType(Y, oe, fe), ColumnSettingsBorderUtils.resetBorderOverwritingState(re), setTimeout(() => FireEvents.onColumnsUpdate(Y));
  }
}
class ColumnSettingsUtils {
  static updateSizer(Y, re) {
    const { _columnsDetails: oe, _tableElementRef: ue } = Y;
    if (!ue)
      return;
    const { columnSizer: fe } = oe[re];
    fe || InsertRemoveColumnSizer.insert(Y, re), InsertRemoveColumnSizer.cleanUpCustomColumnSizers(Y, re), fe && InsertRemoveColumnSizer.updateSizer(fe, oe, re, ue);
    const he = re - 1;
    if (re > 0 && oe[he].columnSizer) {
      const { columnSizer: _e } = oe[he];
      InsertRemoveColumnSizer.updateSizer(_e, oe, he, ue);
    }
  }
  // prettier-ignore
  static change(Y, re, oe, ue, fe, he) {
    const _e = Y._columnsDetails[oe];
    ColumnSettingsDefaultTextUtils.unsetDefaultText(Y, _e, oe), _e.settings = fe, _e.activeType = ColumnTypesUtils.getActiveType(fe, _e.settings.defaultColumnTypeName), ResetColumnStructure.reset(Y, _e, oe), ColumnSettingsDefaultTextUtils.setDefaultText(Y, _e, oe), he || ColumnSettingsWidthUtils.changeWidth(Y, re, ue.widths, fe.widths), ColumnSettingsStyleUtils.changeStyleFunc(Y, oe, ue), ColumnSettingsBorderUtils.updateSiblingColumns(Y, oe), ColumnSettingsUtils.updateSizer(Y, oe), Y.displayHeaderIcons && HeaderIconCellElement.changeHeaderIcon(Y._columnsDetails[oe]), ColumnDropdownCellOverlay.updateIfDisplayed(_e), AddNewColumnElement.toggle(Y, !0);
  }
  // prettier-ignore
  static parseSettingsChange(Y) {
    const { _customColumnsSettings: re, _columnsDetails: oe, _focusedElements: { cell: { element: ue, columnIndex: fe } } } = Y, he = oe[fe].settings, _e = re[CellElement.getText(ue)];
    return { oldSettings: he, newSettings: _e, areSettingsDifferent: _e ? he !== _e : !1 };
  }
  // prettier-ignore
  static changeColumnSettingsIfNameDifferent(Y, re, oe, ue = !1) {
    const { oldSettings: fe, newSettings: he, areSettingsDifferent: _e } = ColumnSettingsUtils.parseSettingsChange(Y);
    _e && ColumnSettingsUtils.change(Y, re, oe, fe, he, ue);
  }
  static setDropdownSettings(Y, re) {
    !Y || !re || (Y.isSortAvailable ?? (Y.isSortAvailable = re.isSortAvailable), Y.isDeleteAvailable ?? (Y.isDeleteAvailable = re.isDeleteAvailable), Y.isInsertLeftAvailable ?? (Y.isInsertLeftAvailable = re.isInsertLeftAvailable), Y.isInsertRightAvailable ?? (Y.isInsertRightAvailable = re.isInsertRightAvailable), Y.isMoveAvailable ?? (Y.isMoveAvailable = re.isMoveAvailable));
  }
  static processCellDimensions(Y) {
    const re = Y.cellStyle;
    if (!re)
      return;
    const oe = Y;
    if (re.width) {
      const ue = Y.isColumnResizable === !1 ? "staticWidth" : "initialWidth";
      oe.widths = { [ue]: re.width };
    } else
      oe.widths && Y.isColumnResizable && oe.widths.staticWidth && (oe.widths = { initialWidth: oe.widths.staticWidth });
    StringDimensionUtils.removeAllDimensions(re);
  }
  static createInternalSettings(Y, re) {
    const oe = Y;
    return ColumnSettingsStyleUtils.doesSettingHaveSideBorderStyle(oe) && (oe.stylePrecedence = !0), ColumnSettingsUtils.setDropdownSettings(Y.columnDropdown, re.columnDropdown), Object.keys(re).forEach((ue) => {
      oe[ue] ?? (oe[ue] = re[ue]);
    }), oe.types = ColumnTypesUtils.getProcessedTypes(oe), ColumnSettingsUtils.processCellDimensions(Y), oe;
  }
  static createInternalMap(Y, re) {
    return Y.reduce((oe, ue) => (oe[ue.headerName] = ColumnSettingsUtils.createInternalSettings(ue, re), oe), {});
  }
  static setDefaultTypeProperties(Y) {
    const { _defaultColumnsSettings: re } = Y;
    re.availableDefaultColumnTypes = Y.availableDefaultColumnTypes, re.customColumnTypes = Y.customColumnTypes, re.defaultColumnTypeName = Y.defaultColumnTypeName, re.types = ColumnTypesUtils.getProcessedTypes(re);
  }
  static setDefaultDropdownProperties(Y) {
    var re, oe, ue, fe, he, _e;
    const { _defaultColumnsSettings: ve } = Y, xe = { openMethod: { cellClick: !0 } };
    ve.columnDropdown = Y.columnDropdown || { displaySettings: xe }, (re = ve.columnDropdown).displaySettings ?? (re.displaySettings = xe), DropdownDisplaySettingsUtil.process(ve.columnDropdown.displaySettings), (oe = ve.columnDropdown).isSortAvailable ?? (oe.isSortAvailable = !0), (ue = ve.columnDropdown).isDeleteAvailable ?? (ue.isDeleteAvailable = !0), (fe = ve.columnDropdown).isInsertLeftAvailable ?? (fe.isInsertLeftAvailable = !0), (he = ve.columnDropdown).isInsertRightAvailable ?? (he.isInsertRightAvailable = !0), (_e = ve.columnDropdown).isMoveAvailable ?? (_e.isMoveAvailable = !0);
  }
  static setDefaultGenericProperties(Y) {
    const { _defaultColumnsSettings: re } = Y;
    re.defaultText = Y.defaultText ?? EMPTY_STRING, re.isDefaultTextRemovable = Y.isDefaultTextRemovable ?? !0, re.cellStyle = Y.cellStyle, re.isCellTextEditable = Y.isCellTextEditable ?? !0, re.headerStyles = Y.headerStyles, re.isHeaderTextEditable = Y.isHeaderTextEditable ?? re.isCellTextEditable, re.headerIconStyle = Y.headerIconStyle, re.isColumnResizable = Y.isColumnResizable ?? !0;
  }
  static setDefaultColumnsSettings(Y) {
    const { _defaultColumnsSettings: re } = Y;
    ColumnSettingsUtils.setDefaultGenericProperties(Y), ColumnSettingsUtils.processCellDimensions(re), ColumnSettingsUtils.setDefaultDropdownProperties(Y), ColumnSettingsUtils.setDefaultTypeProperties(Y);
  }
  // REF-21
  static setUpInternalSettings(Y) {
    ColumnSettingsUtils.setDefaultColumnsSettings(Y), Y._customColumnsSettings = ColumnSettingsUtils.createInternalMap(
      Y.customColumnsSettings,
      Y._defaultColumnsSettings
    );
  }
}
class HeaderText {
  static onAttemptChange(Y, re, oe, ue) {
    const fe = ue?.colRemove;
    fe || ColumnSettingsUtils.changeColumnSettingsIfNameDifferent(Y, re, oe, ue?.colMove), Y._visiblityInternal.filters && FilterInternalUtils.wasHeaderChanged(Y._columnsDetails, Y._visiblityInternal.filters, oe, fe) && VisibilityUtils.headerChanged(Y);
  }
}
class NestedDropdownItem {
  static resetItemStyle(Y) {
    Array.from(Y.children).forEach((re) => {
      const oe = re;
      oe.style.backgroundColor = "", oe.style.color = "";
    });
  }
}
NestedDropdownItem.NESTED_DROPDOWN_ITEM = "nested-dropdown-item";
class DropdownItemNavigation {
  static focusInputElement(Y) {
    Y.children[0].dispatchEvent(new MouseEvent("mouseenter"));
  }
  // either at the end when isNext is true or the start when isNext is false
  static focusItemWhenOnEdge(Y, re, oe) {
    var ue;
    if (DropdownItem.doesElementContainInputClass(Y)) {
      const he = Y.parentElement;
      return DropdownItemNavigation.focusSiblingItem(he, re, oe);
    }
    ((ue = Y.parentElement) == null ? void 0 : ue.parentElement).classList.contains(DropdownItem.DROPDOWN_ITEM_CLASS) && (re = Y.parentElement);
    const fe = oe ? re.children[0] : re.children[re.children.length - 1];
    return DropdownItemNavigation.focusSiblingItem(fe, re, oe, !0);
  }
  // isEdgeItem means is it a start/end or inside item
  // prettier-ignore
  static focusSiblingItem(Y, re, oe, ue = !1) {
    if (Y.classList.contains(NestedDropdownItem.NESTED_DROPDOWN_ITEM)) {
      const he = Y.children[2];
      Dropdown.isDisplayed(he) && Dropdown.hide(he);
    }
    const fe = ue ? Y : Y[oe ? "nextSibling" : "previousSibling"];
    if (fe) {
      if (!DropdownItem.isDisplayed(fe) || fe.classList.contains(DropdownItem.DROPDOWN_TITLE_ITEM_CLASS) || fe.classList.contains(DropdownItem.DROPDOWN_ITEM_DIVIDER_CLASS))
        return DropdownItemNavigation.focusSiblingItem(fe, re, oe);
      if (fe.classList.contains(DropdownItem.DROPDOWN_INPUT_ITEM_CLASS))
        return DropdownItemNavigation.focusInputElement(fe);
    } else
      return DropdownItemNavigation.focusItemWhenOnEdge(Y, re, oe);
    fe.dispatchEvent(new MouseEvent("mouseenter"));
  }
  static focusFirstNestedDropdownItem(Y) {
    if (Y.classList.contains(NestedDropdownItem.NESTED_DROPDOWN_ITEM)) {
      const re = Y.children[2];
      Dropdown.isDisplayed(re) && re.children[0].dispatchEvent(new MouseEvent("mouseenter"));
    }
  }
  static focusNestedDropdownParentItem(Y) {
    var re;
    const oe = (re = Y.parentElement) == null ? void 0 : re.parentElement;
    oe.classList.contains(DropdownItem.DROPDOWN_ITEM_CLASS) && (Dropdown.hide(Y.parentElement), oe.dispatchEvent(new MouseEvent("mouseenter")));
  }
}
class ColumnTypeDropdownItemEvents {
  static onClickMiddleware(Y) {
    ColumnSettingsUtils.parseSettingsChange(this).areSettingsDifferent || Y(), ColumnDropdown.processTextAndHide(this);
  }
  // prettier-ignore
  static set(Y, re, oe) {
    re.forEach((ue) => {
      const fe = ue;
      fe.onclick = ColumnTypeDropdownItemEvents.onClickMiddleware.bind(
        Y,
        ChangeColumnType.change.bind(Y, fe.innerText.trim(), oe)
      );
    });
  }
}
class ColumnTypeDropdownItem {
  static unsetActiveItem(Y) {
    const re = Y.getElementsByClassName(DropdownItem.ACTIVE_ITEM_CLASS)[0];
    re && (re.children[0].style.filter = "", re.classList.remove(DropdownItem.ACTIVE_ITEM_CLASS));
  }
  static reset(Y) {
    ColumnTypeDropdownItem.unsetActiveItem(Y), DropdownItem.removeItems(Y);
  }
  static setActiveItem(Y, re) {
    const oe = Y.find((ue) => CellElement.getText(ue) === re);
    oe && (oe.classList.add(DropdownItem.ACTIVE_ITEM_CLASS), oe.children[0].style.filter = SVGIconUtils.WHITE_FILTER);
  }
  // the items are repopulated every time column dropdown is opened
  static setUp(Y, re) {
    const { columnTypeDropdown: oe } = Y._activeOverlayElements, ue = Y._columnsDetails[re], fe = ue.settings.types.map((he) => he.dropdownItem.element);
    DropdownItem.addButtonItemElements(Y, oe, fe), ColumnTypeDropdownItemEvents.set(Y, fe, re), ColumnTypeDropdownItem.setActiveItem(fe, ue.activeType.name);
  }
}
class DropdownEvents {
  static itemKeyNavigation(Y, re, oe) {
    if (oe.key === KEYBOARD_KEY.TAB || oe.key === KEYBOARD_KEY.ARROW_DOWN) {
      oe.preventDefault();
      const ue = Y != null && Y.activeElement ? oe.target : re.children[0];
      DropdownItemNavigation.focusSiblingItem(ue, re, !0);
    } else
      oe.key === KEYBOARD_KEY.ARROW_UP ? DropdownItemNavigation.focusSiblingItem(oe.target, re, !1) : oe.key === KEYBOARD_KEY.ARROW_RIGHT ? DropdownItemNavigation.focusFirstNestedDropdownItem(oe.target) : oe.key === KEYBOARD_KEY.ARROW_LEFT && DropdownItemNavigation.focusNestedDropdownParentItem(oe.target);
  }
}
class ColumnDropdownEvents {
  static focusNextColumnDropdown(Y, re) {
    var oe, ue, fe;
    re.preventDefault(), ColumnDropdown.processTextAndHide(Y);
    let he = Y._focusedElements.cell.columnIndex;
    he === Y._columnsDetails.length - 1 && (he = -1);
    const _e = Y._columnsDetails[he + 1];
    (fe = (ue = (oe = Y._defaultColumnsSettings.columnDropdown) == null ? void 0 : oe.displaySettings) == null ? void 0 : ue.openMethod) != null && fe.cellClick ? _e.elements[0].click() : _e.columnDropdownCellOverlay.click();
  }
  static onKeyDown(Y, re) {
    if (re.key === KEYBOARD_KEY.ENTER) {
      const oe = re.target;
      DropdownItem.doesElementContainInputClass(oe) ? ColumnDropdown.processTextAndHide(this) : (oe.dispatchEvent(new Event("mouseenter")), oe.dispatchEvent(new Event("click")));
    } else
      re.key === KEYBOARD_KEY.ESCAPE ? ColumnDropdown.processTextAndHide(this) : re.key === KEYBOARD_KEY.TAB && this._columnsDetails.length > 0 ? ColumnDropdownEvents.focusNextColumnDropdown(this, re) : DropdownEvents.itemKeyNavigation(this.shadowRoot, Y, re);
  }
  static set(Y, re) {
    re.onkeydown = ColumnDropdownEvents.onKeyDown.bind(Y, re);
  }
}
function buildIcon$4(le) {
  return `<?xml version="1.0" standalone="no"?>
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" style="transform: ${le}">
      <g transform="matrix(0.84210527 0 0 0.84210527 0 0)">
        <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
          <path d="M186.67 193.5L186.67 58.33C 186.67 51.888603 191.8927 46.666 198.334 46.666C 204.7793 46.666 210.002 51.888702 210.002 58.33L210.002 58.33L210.002 193.5L260.08398 143.418C 264.64258 138.8594 272.029 138.8594 276.58398 143.418C 281.14258 147.9727 281.14258 155.359 276.58398 159.918L276.58398 159.918L206.58398 229.918C 202.02928 234.4727 194.64299 234.4727 190.08398 229.918L190.08398 229.918L120.083984 159.918C 115.52928 155.3594 115.52928 147.97299 120.083984 143.418C 124.642586 138.8594 132.02899 138.8594 136.58398 143.418L136.58398 143.418L186.67 193.5zM396.66998 93.33L326.66998 93.33L326.66998 443.33002L396.66998 443.33002zM420.00198 93.33L420.00198 443.33002L490.00198 443.33002L490.00198 93.33002zM151.672 490C 145.2267 490 140.004 484.7773 140.004 478.332L140.004 478.332L140.004 268.332C 140.004 261.8906 145.2267 256.668 151.672 256.668L151.672 256.668L245.004 256.668C 251.4454 256.668 256.672 261.8907 256.672 268.332L256.672 268.332L256.672 478.332C 256.672 484.7773 251.4454 490 245.004 490zM163.336 466.668L233.336 466.668L233.336 279.998L163.336 279.998zM315.00598 466.668C 308.56458 466.668 303.33798 461.4414 303.33798 455L303.33798 455L303.33798 81.67001C 303.33798 75.22472 308.56458 70.002014 315.00598 70.002014L315.00598 70.002014L501.67596 70.002014C 508.11737 70.002014 513.33997 75.22472 513.33997 81.67001L513.33997 81.67001L513.33997 455C 513.33997 461.4414 508.11728 466.668 501.67596 466.668z" stroke="none" fill="#000000" fill-rule="nonzero" />
        </g>
      </g>
    </svg>`;
}
const INSERT_LEFT_ICON_SVG_STRING = buildIcon$4(""), INSERT_RIGHT_ICON_SVG_STRING = buildIcon$4("rotate(180deg) scale(1, -1)"), INSERT_UP_ICON_SVG_STRING = buildIcon$4("rotate(90deg) scale(1, -1)"), INSERT_DOWN_ICON_SVG_STRING = buildIcon$4("rotate(-90deg)");
function buildIcon$3(le) {
  return `<?xml version="1.0" standalone="no"?>
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="9" height="9" style="transform: ${le}">
      <g transform="matrix(0.47368425 0 0 0.47368425 0 0)">
        <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
          <g>
            <path d="M169 139.73L308.72998 0L349.175 40.484L109.124985 280.544L348.645 520.054L308.74698 559.999L169.01698 420.26904C 92.164986 343.42105 29.286987 280.29904 29.286987 279.99902C 29.286987 279.699 92.165985 216.57303 169.01698 139.72902L169.01698 139.72902L169 139.73zM490.55 139.73L630.27997 0L670.725 40.484L430.675 280.544L670.195 520.054L630.297 559.999L490.56702 420.26904C 413.71503 343.42105 350.83704 280.29904 350.83704 279.99902C 350.83704 279.699 413.71603 216.57303 490.56702 139.72902z" stroke="none" fill="#000000" fill-rule="nonzero" />
          </g>
        </g>
      </g>
    </svg>`;
}
const MOVE_LEFT_ICON_SVG_STRING = buildIcon$3(""), MOVE_RIGHT_ICON_SVG_STRING = buildIcon$3("rotate(180deg)"), MOVE_UP_ICON_SVG_STRING = buildIcon$3("rotate(90deg)"), MOVE_DOWN_ICON_SVG_STRING = buildIcon$3("rotate(-90deg)");
function buildIcon$2(le) {
  return `<?xml version="1.0" standalone="no"?>
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="9" height="12" style="transform: ${le}">
      <g transform="matrix(0.5 0 0 0.5 0 0)">
        <path d="M0 0L24 0L24 24L0 24L0 0z" stroke="none" fill="none" />
        <path d="M3 18L9 18L9 16L3 16L3 18zM3 6L3 8L21 8L21 6L3 6zM3 13L15 13L15 11L3 11L3 13z" stroke="none" fill="#000000" fill-rule="nonzero" />
      </g>
    </svg>`;
}
const SORT_ASC_ICON_SVG_STRING = buildIcon$2("scale(1, -1)"), SORT_DESC_ICON_SVG_STRING = buildIcon$2(""), TRASH_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="15">
  <g transform="matrix(1.0666668 0 0 1.0714285 0 0)">
    <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
      <g>
        <path d="M459.21 156.28L448.835 436.32C 448.6592 441.1247 444.4248 445.195 439.6006 445.195L439.6006 445.195L260.40057 445.195C 255.58028 445.195 251.34198 441.1091 251.16617 436.32L251.16617 436.32L240.79117 156.28C 240.50601 148.5534 234.00996 142.522 226.28317 142.807C 218.55658 143.09607 212.52518 149.58821 212.81018 157.315L212.81018 157.315L223.18118 437.355C 223.91946 457.195 240.51718 473.195 260.40018 473.195L260.40018 473.195L439.60016 473.195C 459.47516 473.195 476.08017 457.22202 476.81915 437.355L476.81915 437.355L487.19016 157.315C 487.4753 149.58841 481.44406 143.09601 473.71716 142.807C 465.99057 142.52185 459.49417 148.5531 459.20917 156.28L459.20917 156.28L459.21 156.28z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M338.8 212.8L338.8 403.2C 338.8 409.3875 343.81168 414.39902 349.999 414.39902C 356.1863 414.39902 361.198 409.38733 361.198 403.2L361.198 403.2L361.198 212.80002C 361.198 206.61252 356.1863 201.60101 349.999 201.60101C 343.81168 201.60101 338.8 206.61272 338.8 212.80002L338.8 212.80002L338.8 212.8z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M277.2 213.13L282.8016 403.53C 282.9852 409.7136 288.14142 414.581 294.32462 414.397C 300.5082 414.21732 305.3756 409.0572 305.19162 402.874L305.19162 402.874L299.59003 212.474C 299.41034 206.2904 294.2502 201.423 288.06702 201.607C 281.88342 201.78668 277.02002 206.9468 277.2 213.12999L277.2 213.12999L277.2 213.13z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M400.41 212.47L394.8084 402.87C 394.62482 409.0536 399.492 414.214 405.6754 414.393C 411.859 414.5766 417.0154 409.7094 417.19843 403.526L417.19843 403.526L422.80002 213.126C 422.9797 206.94241 418.11642 201.78201 411.933 201.60301C 405.74942 201.41942 400.58902 206.2866 400.41 212.47002L400.41 212.47002L400.41 212.47z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M210 162.4L490 162.4C 497.7305 162.4 504 156.1344 504 148.4C 504 140.6695 497.7305 134.4 490 134.4L490 134.4L210 134.4C 202.2695 134.4 196 140.6695 196 148.4C 196 156.1344 202.2695 162.4 210 162.4z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M307.46 143.85L313.2881 123.44401C 314.5381 119.076805 320.20218 114.803406 324.75308 114.803406L324.75308 114.803406L375.2451 114.803406C 379.7959 114.803406 385.46008 119.07291 386.71008 123.44401L386.71008 123.44401L392.53818 143.85L419.46017 136.15471L413.63208 115.75271C 408.94458 99.35771 392.29608 86.80371 375.2451 86.80371L375.2451 86.80371L324.75308 86.80371C 307.7021 86.80371 291.05008 99.36271 286.3661 115.75271L286.3661 115.75271L280.538 136.15471L307.46 143.85z" stroke="none" fill="#000000" fill-rule="nonzero" />
      </g>
    </g>
  </g>
</svg>`;
class ColumnDropdownButtonItemConf {
}
ColumnDropdownButtonItemConf.ITEMS = [
  {
    text: "Sort Ascending",
    iconSettings: {
      svgString: SORT_ASC_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginRight: "9px", marginTop: "2px" } }
    }
  },
  {
    text: "Sort Descending",
    iconSettings: {
      svgString: SORT_DESC_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginRight: "9px", marginTop: "1px" } }
    }
  },
  {
    text: "Insert Left",
    iconSettings: {
      svgString: INSERT_LEFT_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "-2px", marginRight: "3px", marginTop: "1px" } }
    }
  },
  {
    text: "Insert Right",
    iconSettings: {
      svgString: INSERT_RIGHT_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "-3px", marginRight: "4px", marginTop: "1px" } }
    }
  },
  {
    text: "Move Left",
    iconSettings: {
      svgString: MOVE_LEFT_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "1px", marginRight: "7px", marginTop: "3.5px" } }
    }
  },
  {
    text: "Move Right",
    iconSettings: {
      svgString: MOVE_RIGHT_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "1px", marginRight: "7px", marginTop: "1.5px" } }
    }
  },
  {
    text: "Delete",
    iconSettings: {
      svgString: TRASH_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "-4px", marginRight: "5px", marginTop: "-1px" } }
    }
  }
];
class UpdateCellsForColumns {
  // prettier-ignore
  static updateColumn(Y, re, oe, ue, fe) {
    fe !== CELL_UPDATE_TYPE.REMOVED && CellEventsReset.reset(Y, oe, re, ue), FireEvents.onCellUpdate(Y, CellElement.getText(oe), re, ue, fe);
  }
  // prettier-ignore
  static updateNextBeforeLastColumns(Y, re, oe, ue) {
    ExtractElements.textCellsArrFromRow(re.element).slice(oe, ue).forEach((fe, he) => {
      const _e = he + oe;
      UpdateCellsForColumns.updateColumn(Y, re.index, fe, _e, CELL_UPDATE_TYPE.UPDATE);
    });
  }
  // the reason why last column details need to be passed here is because after removal of last element, its details are
  // no longer present here as this class's methods are run in setTimeouts, hence those details need to be captured
  // before these methods are executed
  // prettier-ignore
  static rebindAndFireUpdates(Y, re, oe, ue, fe) {
    UpdateCellsForColumns.updateNextBeforeLastColumns(Y, re, oe, fe.index), UpdateCellsForColumns.updateColumn(Y, re.index, fe.element, fe.index, ue);
  }
}
class LastColumn {
  // the reason why last column details are used is because after removal of the last column element, its details are
  // no longer present and update methods are run in setTimeouts, hence those details need to be captured before
  // their methods are executed
  static getDetails(Y, re) {
    const oe = Y.length - 1;
    return { element: Y[oe].elements[re], index: oe };
  }
}
class RemoveColumn {
  static reduceStaticWidthTotal(Y, re) {
    var oe;
    if ((oe = re.widths) != null && oe.staticWidth) {
      const { number: ue } = ColumnSettingsWidthUtils.getSettingsWidthNumber(
        Y._tableElementRef,
        re.widths
      );
      TableElement.changeStaticWidthTotal(Y._tableDimensions, -ue);
    }
  }
  static updateTableDimensions(Y, re) {
    RemoveColumn.reduceStaticWidthTotal(Y, re), StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(Y, !1);
  }
  static cleanUpData(Y) {
    Y.length > 0 && Y[0].length === 0 && Y.splice(0);
  }
  static removeElements(Y, re, oe) {
    const ue = CellElementIndex.getViaColumnIndex(re, oe);
    Y.children[ue].remove(), Y.children[ue].remove();
  }
  static removeCell(Y, re, oe, ue) {
    const fe = LastColumn.getDetails(Y._columnsDetails, oe);
    RemoveColumn.removeElements(re, ue, !!Y._frameComponents.displayIndexColumn), Y.data[oe].splice(ue, 1), setTimeout(() => {
      const he = { element: re, index: oe };
      UpdateCellsForColumns.rebindAndFireUpdates(Y, he, ue, CELL_UPDATE_TYPE.REMOVED, fe);
    });
  }
  static removeCellFromAllRows(Y, re) {
    ExtractElements.textRowsArrFromTBody(Y._tableBodyElementRef, Y.data).forEach((ue, fe) => {
      RemoveColumn.removeCell(Y, ue, fe, re);
    }), RemoveColumn.cleanUpData(Y.data), HeaderText.onAttemptChange(Y, Y._columnsDetails[re].elements[0], re, { colRemove: !0 });
    const oe = Y._columnsDetails.splice(re, 1)[0];
    return RemoveColumn.updateTableDimensions(Y, oe.settings), oe;
  }
  static remove(Y, re) {
    const oe = RemoveColumn.removeCellFromAllRows(Y, re);
    ToggleAdditionElements.update(Y, !1, AddNewColumnElement.toggle), ColumnSettingsBorderUtils.updateSiblingColumns(Y, re), setTimeout(() => {
      oe.cellDropdown.element.remove(), InsertRemoveColumnSizer.remove(Y, re), InsertRemoveColumnSizer.cleanUpCustomColumnSizers(Y, re), re === 0 && Y._columnsDetails.length > 0 && RowDropdownCellOverlay.resetOverlays(Y), setTimeout(() => {
        FireEvents.onDataUpdate(Y), FireEvents.onColumnsUpdate(Y);
      });
    });
  }
  static removeEvent(Y) {
    RemoveColumn.remove(this, Y);
  }
}
class ElementSiblingIterator {
  static create(Y) {
    let re = Y;
    return {
      next: () => {
        const oe = re.nextSibling;
        return oe && (re = oe), oe;
      },
      currentElement: () => re
    };
  }
}
class ColumnDropdownItemEvents {
  static onClickMiddleware(Y) {
    Y(), ColumnDropdown.processTextAndHide(this);
  }
  // prettier-ignore
  static setItemEvents(Y, re, oe) {
    const ue = oe.getElementsByClassName(ColumnDropdownItem.SORT_ITEM_CLASS)[0], fe = ElementSiblingIterator.create(ue);
    fe.currentElement().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      Y,
      Sort.sortColumn.bind(this, Y, re, !0)
    ), fe.next().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      Y,
      Sort.sortColumn.bind(this, Y, re, !1)
    ), fe.next().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      Y,
      InsertNewColumn.insert.bind(this, Y, re)
    ), fe.next().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      Y,
      InsertNewColumn.insert.bind(this, Y, re + 1)
    ), fe.next().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      Y,
      MoveColumn.move.bind(this, Y, re, !1)
    ), fe.next().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      Y,
      MoveColumn.move.bind(this, Y, re, !0)
    ), fe.next().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      Y,
      RemoveColumn.remove.bind(this, Y, re)
    );
  }
  // reason why using onInput for updating cells is because it works for paste
  // prettier-ignore
  static onInput(Y, re, oe, ue) {
    setTimeout(() => {
      CellEvents.updateCell(this, ue.value, 0, Y, { element: re, processText: !1 }), oe.style.top = ColumnDropdown.getTopPosition(this, re);
    });
  }
  // prettier-ignore
  static setInputItemEvent(Y, re, oe, ue, fe) {
    ue.oninput = ColumnDropdownItemEvents.onInput.bind(
      Y,
      re,
      oe,
      fe,
      ue
    );
  }
}
var SIDE = /* @__PURE__ */ ((le) => (le[le.LEFT = 0] = "LEFT", le[le.RIGHT = 1] = "RIGHT", le[le.TOP = 2] = "TOP", le[le.BOTTOM = 3] = "BOTTOM", le))(SIDE || {});
class NestedDropdown {
  static create(Y, re) {
    const oe = Dropdown.createBase();
    return oe.style.top = `-${Number.parseInt(oe.style.paddingTop) + 22}px`, Y && re && DropdownItem.addNewButtonItems(Y, oe, re), oe;
  }
  static resetPosition(Y) {
    Y.style.left = "";
  }
  static hideDropdown(Y) {
    const re = Y.target.children[2];
    re.style.display = "none", NestedDropdown.resetPosition(re);
  }
  // prettier-ignore
  static correctPosition(Y, re, oe) {
    const ue = ElementVisibility.getDetailsInWindow(Y, oe);
    if (!ue.isFullyVisible && ue.blockingSides.has(SIDE.RIGHT)) {
      Y.style.left = `-${re.style.width}`;
      const fe = ElementVisibility.getDetailsInWindow(Y, oe);
      !fe.isFullyVisible && fe.blockingSides.has(SIDE.LEFT) && (Y.style.left = "");
    }
  }
  // prettier-ignore
  static correctPositionForOverflow(Y, re, oe) {
    const { _tableElementRef: ue, _overflow: fe } = Y;
    !ue || !fe || ue.offsetWidth !== fe.overflowContainer.scrollWidth && (re.style.left = `-${oe.style.width}`, re.getBoundingClientRect().x < 0 && (re.style.left = ""));
  }
  static displayAndSetDropdownPosition(Y) {
    const re = Y.target.children[2], oe = Y.target.parentElement;
    re.style.left = oe.style.width, re.style.display = oe.style.display, this._overflow && OverflowUtils.isOverflowElement(this._overflow.overflowContainer) ? NestedDropdown.correctPositionForOverflow(this, re, oe) : NestedDropdown.correctPosition(re, oe, this._tableDimensions.border);
  }
}
class NestedDropdownItemEvents {
  // prettier-ignore
  static addEvents(Y, re) {
    re.addEventListener("mouseenter", NestedDropdown.displayAndSetDropdownPosition.bind(Y)), re.addEventListener("mouseleave", NestedDropdown.hideDropdown), re.children[1].addEventListener(
      "mouseenter",
      DropdownItemHighlightUtils.highlightNew.bind(this, Y._activeOverlayElements, re)
    );
  }
}
const _ColumnTypeDropdown = class bi {
  static setupParentItemData(Y, re) {
    var oe;
    const { name: ue, dropdownItem: fe } = re, he = ((oe = fe.element) == null ? void 0 : oe.children[0]).cloneNode(!0);
    Y.replaceChild(he, Y.children[0]);
    const _e = Y.children[1];
    _e.innerText = ue;
  }
  static setUp(Y, re, oe) {
    const { activeType: ue, settings: fe } = Y._columnsDetails[oe], he = re.getElementsByClassName(bi.COLUMN_TYPE_ITEM_CLASS)[0];
    if (bi.setupParentItemData(he, ue), fe.types.length < 2)
      return he.style.pointerEvents = "none";
    he.style.pointerEvents = "", setTimeout(() => ColumnTypeDropdownItem.setUp(Y, oe));
  }
  // prettier-ignore
  static create(Y, re) {
    const oe = DropdownItem.addButtonItem(
      Y,
      re,
      DropdownButtonItemConf.DEFAULT_ITEM,
      NestedDropdownItem.NESTED_DROPDOWN_ITEM,
      bi.COLUMN_TYPE_ITEM_CLASS
    );
    NestedDropdownItemEvents.addEvents(Y, oe);
    const ue = NestedDropdown.create();
    oe.appendChild(ue), Y._activeOverlayElements.columnTypeDropdown = ue;
  }
};
_ColumnTypeDropdown.COLUMN_TYPE_ITEM_CLASS = "dropdown-column-type-item";
let ColumnTypeDropdown = _ColumnTypeDropdown;
const _ColumnDropdownItem = class pa {
  static resetItems(Y) {
    Array.from(Y.children).forEach((re) => DropdownItem.toggleItem(re, !0));
  }
  static addItems(Y, re) {
    setTimeout(() => {
      DropdownItem.addTitle(re, "Property type"), ColumnTypeDropdown.create(Y, re), DropdownItem.addDivider(re), ColumnDropdownButtonItemConf.ITEMS.slice(0, 2).forEach((oe) => {
        DropdownItem.addButtonItem(Y, re, oe, pa.SORT_ITEM_CLASS);
      }), ColumnDropdownButtonItemConf.ITEMS.slice(2).forEach((oe) => {
        DropdownItem.addButtonItem(Y, re, oe);
      });
    });
  }
  // hide divider when there are no items below
  static hideDivider(Y) {
    Y.slice(4).find((re) => re.style.display !== "none") || DropdownItem.toggleItem(Y[3], !1);
  }
  static toggleItems(Y, re) {
    const { isSortAvailable: oe, isDeleteAvailable: ue, isInsertLeftAvailable: fe, isInsertRightAvailable: he, isMoveAvailable: _e } = Y;
    oe || (DropdownItem.toggleItem(re[4], !1), DropdownItem.toggleItem(re[5], !1)), fe || DropdownItem.toggleItem(re[6], !1), he || DropdownItem.toggleItem(re[7], !1), _e || (DropdownItem.toggleItem(re[8], !1), DropdownItem.toggleItem(re[9], !1)), ue || DropdownItem.toggleItem(re[10], !1), pa.hideDivider(re);
  }
  // prettier-ignore
  static setUpInputElement(Y, re, oe, ue, fe) {
    var he, _e, ve;
    const { isCellTextEditable: xe, isHeaderTextEditable: Ee } = Y._columnsDetails[re].settings;
    if ((ve = (_e = (he = Y._defaultColumnsSettings.columnDropdown) == null ? void 0 : he.displaySettings) == null ? void 0 : _e.openMethod) != null && ve.overlayClick || (ObjectUtils.areValuesFullyDefined(Ee) ? !Ee : !xe))
      DropdownItem.toggleItem(ue, !1);
    else {
      const Se = ue.children[0];
      Se.value = Y.data[0][re], ColumnDropdownItemEvents.setInputItemEvent(Y, re, oe, Se, fe);
    }
  }
  static setUp(Y, re, oe, ue) {
    ColumnTypeDropdown.setUp(Y, re, oe);
    const fe = Array.from(re.children);
    pa.setUpInputElement(Y, oe, ue, fe[0], re), pa.toggleItems(Y._columnsDetails[oe].settings.columnDropdown, fe), pa.updateItemsStyle(Y, oe, re), ColumnDropdownItemEvents.setItemEvents(Y, oe, re);
  }
  static updateMoveColumnItemsStyle(Y, re, oe) {
    const { isMoveAvailable: ue } = Y._columnsDetails[re].settings.columnDropdown;
    ue && (DropdownItem.toggleUsability(oe[8], !0), DropdownItem.toggleUsability(oe[9], !0), re === 0 && DropdownItem.toggleUsability(oe[8], !1), re === Y._columnsDetails.length - 1 && DropdownItem.toggleUsability(oe[9], !1));
  }
  static updateInsertColumnItemsStyle(Y, re) {
    MaximumColumns.canAddMore(Y) ? (DropdownItem.toggleUsability(re[6], !0), DropdownItem.toggleUsability(re[7], !0)) : (DropdownItem.toggleUsability(re[6], !1), DropdownItem.toggleUsability(re[7], !1));
  }
  static updateItemsStyle(Y, re, oe) {
    const ue = Array.from(oe.children);
    pa.updateInsertColumnItemsStyle(Y, ue), pa.updateMoveColumnItemsStyle(Y, re, ue);
  }
};
_ColumnDropdownItem.SORT_ITEM_CLASS = "dropdown-sort-item";
let ColumnDropdownItem = _ColumnDropdownItem;
class ColumnDropdown {
  static resetDropdownPosition(Y) {
    Y.style.left = "";
  }
  // prettier-ignore
  static processTextAndHide(Y) {
    var re;
    const { _activeOverlayElements: oe, _columnsDetails: ue, _focusedElements: { cell: { element: fe, columnIndex: he } } } = Y, { columnDropdown: _e, columnTypeDropdown: ve, fullTableOverlay: xe } = oe;
    !_e || !xe || !ve || !fe || (GenericElementUtils.doesElementExistInDom(fe) && (CellEvents.setCellToDefaultIfNeeded(Y, 0, he, fe), HeaderText.onAttemptChange(Y, fe, he)), CellHighlightUtils.fade(fe, (re = ue[he]) == null ? void 0 : re.headerStateColors.default), Dropdown.hide(_e, xe, ve), ColumnTypeDropdownItem.reset(ve), ColumnDropdown.resetDropdownPosition(_e), ColumnDropdownItem.resetItems(_e), DropdownItemHighlightUtils.fadeCurrentlyHighlighted(oe));
  }
  static create(Y) {
    const re = Dropdown.createBase();
    return ColumnDropdownEvents.set(Y, re), DropdownItem.addInputItem(Y, re), ColumnDropdownItem.addItems(Y, re), re;
  }
  // prettier-ignore
  static getDefaultDropdownTopPosition(Y, re, oe) {
    return oe ? `${Browser.IS_FIREFOX ? 1 + re.topWidth : 1}px` : `${ElementOffset.processTop(Y.offsetTop + Y.offsetHeight, re)}px`;
  }
  static getTopPosition(Y, re) {
    var oe, ue, fe;
    const he = (fe = (ue = (oe = Y._defaultColumnsSettings.columnDropdown) == null ? void 0 : oe.displaySettings) == null ? void 0 : ue.openMethod) == null ? void 0 : fe.overlayClick;
    if (Y._overflow) {
      const _e = Y._overflow.overflowContainer;
      return `${he ? _e.scrollTop + 1 : _e.scrollTop + re.offsetHeight}px`;
    } else if (Y._stickyProps.header) {
      const _e = re.parentElement.offsetTop;
      return `${(he ? 1 : re.offsetHeight) + _e}px`;
    }
    return ColumnDropdown.getDefaultDropdownTopPosition(re, Y._tableDimensions.border, he);
  }
  static getLeftPropertyToCenterDropdown(Y, re) {
    return `${ElementOffset.processLeft(Y.offsetLeft + Y.offsetWidth / 2, re) - Dropdown.DROPDOWN_WIDTH / 2}px`;
  }
  static displayAndSetDropdownPosition(Y, re, oe) {
    oe.style.left = ColumnDropdown.getLeftPropertyToCenterDropdown(re, Y._tableDimensions.border), oe.style.top = ColumnDropdown.getTopPosition(Y, re), Dropdown.display(oe);
    const ue = ElementVisibility.getDetailsInWindow(oe, Y._tableDimensions.border);
    ue.isFullyVisible || (ue.blockingSides.has(SIDE.LEFT) ? oe.style.left = "0px" : ue.blockingSides.has(SIDE.RIGHT) && (oe.style.left = `${re.offsetLeft + re.offsetWidth - Dropdown.DROPDOWN_WIDTH}px`));
  }
  // no active table based overflow - REF-37
  static displayAndSetPositionForSticky(Y, re, oe) {
    oe.style.left = ColumnDropdown.getLeftPropertyToCenterDropdown(re, Y._tableDimensions.border), oe.style.top = ColumnDropdown.getTopPosition(Y, re), Dropdown.display(oe);
  }
  // prettier-ignore
  static displayAndSetPositionForOverflow(Y, re, oe) {
    const { _tableElementRef: ue, _overflow: fe, _tableDimensions: he } = Y;
    if (!ue || !(fe != null && fe.overflowContainer))
      return;
    const _e = fe.overflowContainer;
    oe.style.left = ColumnDropdown.getLeftPropertyToCenterDropdown(re, he.border), oe.style.top = ColumnDropdown.getTopPosition(Y, re), Dropdown.display(oe), ue.offsetWidth !== _e.scrollWidth ? oe.style.left = `${ue.offsetWidth - oe.offsetWidth}px` : oe.offsetLeft < 0 && (oe.style.left = "0px");
  }
  static display(Y, re) {
    const oe = Y._activeOverlayElements.columnDropdown, ue = Y._columnsDetails[re].elements[0];
    ColumnDropdownItem.setUp(Y, oe, re, ue), Y._overflow ? ColumnDropdown.displayAndSetPositionForOverflow(Y, ue, oe) : Y._stickyProps.header ? ColumnDropdown.displayAndSetPositionForSticky(Y, ue, oe) : ColumnDropdown.displayAndSetDropdownPosition(Y, ue, oe);
    const fe = DropdownItem.getInputElement(oe);
    fe && DropdownItemNavigation.focusInputElement(fe), FullTableOverlayElement.display(Y);
  }
}
class FullTableOverlayEvents {
  // prettier-ignore
  static onMouseDown(Y) {
    const { _activeOverlayElements: { columnDropdown: re, rowDropdown: oe } } = this;
    Dropdown.isDisplayed(re) && !Dropdown.isPartOfDropdownElement(Y.target) && ColumnDropdown.processTextAndHide(this), Dropdown.isDisplayed(oe) && RowDropdown.hide(this);
  }
}
class FullTableOverlayElement {
  // at offsets is a bug fix for a situation where the user was able to click the table border, focus and unfocus a cell
  // and therefore not allow the column dropdown to close because there is nothing focused
  static display(Y) {
    var re;
    const oe = Y._activeOverlayElements.fullTableOverlay;
    if (oe.style.width = `${Y.offsetWidth}px`, oe.style.height = `${Y.offsetHeight}px`, (re = Y._overflow) != null && re.overflowContainer)
      oe.style.top = `${Y.offsetTop}px`, oe.style.left = `${Y.offsetLeft}px`;
    else {
      const ue = Y._tableElementRef.offsetTop - Y.offsetTop;
      oe.style.top = `-${Browser.IS_FIREFOX ? ue : ue + Y._tableDimensions.border.topWidth}px`, oe.style.left = `-${Browser.IS_FIREFOX ? 0 : Y._tableDimensions.border.leftWidth}px`;
    }
    Dropdown.display(oe);
  }
  static create(Y) {
    const re = document.createElement("div");
    return re.id = "full-table-overlay", re.style.backgroundColor = SEMI_TRANSPARENT_COLOR, re.style.display = "none", re.onmousedown = FullTableOverlayEvents.onMouseDown.bind(Y), re;
  }
}
class RowDropdownEvents {
  // the reason why we track window key events is because the table is not actually focused when it is displayed,
  // (unlike column dropdown which has an input), hence initially clicking tab does not focus the dropdown and
  // instead we need to focus it programmatically here. Once focused, the actual dropdown events can take over.
  // prettier-ignore
  static windowOnKeyDown(Y, re) {
    const { _activeOverlayElements: { rowDropdown: oe, fullTableOverlay: ue }, shadowRoot: fe } = Y;
    Y._focusedElements.rowDropdown || !oe || !ue || (re.key === KEYBOARD_KEY.ENTER || re.key === KEYBOARD_KEY.ESCAPE ? RowDropdown.hide(Y) : fe != null && fe.activeElement || (re.key === KEYBOARD_KEY.TAB || re.key === KEYBOARD_KEY.ARROW_DOWN ? (re.preventDefault(), Y._focusedElements.rowDropdown = oe, DropdownItemNavigation.focusSiblingItem(oe.children[0], oe, !0, !0)) : re.key === KEYBOARD_KEY.ARROW_UP && (Y._focusedElements.rowDropdown = oe, DropdownItemNavigation.focusSiblingItem(
      oe.children[oe.children.length - 1],
      oe,
      !1,
      !0
    ))));
  }
  static dropdownOnKeyDown(Y, re) {
    if (re.key === KEYBOARD_KEY.ENTER) {
      const oe = re.target;
      oe.dispatchEvent(new Event("mouseenter")), oe.dispatchEvent(new Event("click"));
    } else
      re.key === KEYBOARD_KEY.ESCAPE && RowDropdown.hide(this);
    DropdownEvents.itemKeyNavigation(this.shadowRoot, Y, re);
  }
  static set(Y, re) {
    re.onkeydown = RowDropdownEvents.dropdownOnKeyDown.bind(Y, re);
  }
}
class RowDropdownButtonItemConf {
}
RowDropdownButtonItemConf.ITEMS = [
  {
    text: "Insert Up",
    iconSettings: {
      svgString: INSERT_UP_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginRight: "1px" } }
    }
  },
  {
    text: "Insert Down",
    iconSettings: {
      svgString: INSERT_DOWN_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginRight: "1px" } }
    }
  },
  {
    text: "Move Up",
    iconSettings: {
      svgString: MOVE_UP_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginRight: "8px", marginTop: "3.5px" } }
    }
  },
  {
    text: "Move Down",
    iconSettings: {
      svgString: MOVE_DOWN_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "2px", marginRight: "6px", marginTop: "3.5px" } }
    }
  },
  {
    text: "Delete",
    iconSettings: {
      svgString: TRASH_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "-4px", marginRight: "5px", marginTop: "-1px" } }
    }
  }
];
class IndexColumnEvents {
  static mouseEnterCell(Y, re) {
    const oe = re.target, { cellColors: ue } = this._frameComponents, fe = FrameComponentsColors.getColorsBasedOnParam(ue, Y);
    CellHighlightUtils.highlight(oe, fe.hover);
  }
  static mouseLeaveCell(Y, re) {
    if (!Dropdown.isDisplayed(this._activeOverlayElements.rowDropdown)) {
      const { cellColors: oe } = this._frameComponents, ue = FrameComponentsColors.getColorsBasedOnParam(oe, Y);
      CellHighlightUtils.fade(re.target, ue.default);
    }
  }
  static setEvents(Y, re, oe) {
    var ue;
    re.onmouseenter = IndexColumnEvents.mouseEnterCell.bind(Y, oe), re.onmouseleave = IndexColumnEvents.mouseLeaveCell.bind(Y, oe);
    const { displaySettings: fe, canEditHeaderRow: he } = Y.rowDropdown;
    !he && oe === 0 || (fe.isAvailable && (ue = fe.openMethod) != null && ue.cellClick ? re.onclick = RowDropdown.display.bind(Y, oe, re) : RowDropdownCellOverlayEvents.addCellEvents(Y, oe, re));
  }
}
class UpdateCellsForRows {
  // prettier-ignore
  static updateRowCells(Y, re, oe, ue, fe = !0) {
    var he;
    if (ExtractElements.textCellsArrFromRow(re).forEach((_e, ve) => {
      ue !== CELL_UPDATE_TYPE.REMOVED && CellEventsReset.reset(Y, _e, oe, ve), fe && FireEvents.onCellUpdate(Y, CellElement.getText(_e), oe, ve, ue);
    }), ue !== CELL_UPDATE_TYPE.REMOVED) {
      const _e = re.children[0];
      if (Y._frameComponents.displayIndexColumn && (IndexColumnEvents.setEvents(Y, _e, oe), DragRow.applyEventsToElement(Y, _e, _e)), (he = Y.rowDropdown.displaySettings.openMethod) != null && he.overlayClick) {
        const ve = RowDropdownCellOverlayEvents.setOverlayEvents(Y, oe, _e);
        DragRow.applyEventsToElement(Y, ve, _e);
      }
    }
  }
  static updateLastRow(Y, re, oe) {
    var ue;
    (ue = Y._tableBodyElementRef) != null && ue.children && UpdateCellsForRows.updateRowCells(Y, oe.element, oe.index, re);
  }
  static updateLowerBeforeLastRows(Y, re, oe) {
    var ue;
    const fe = (ue = Y._tableBodyElementRef) == null ? void 0 : ue.children;
    fe && Array.from(fe).slice(re, oe).forEach((he, _e) => {
      const ve = _e + re, xe = he;
      UpdateCellsForRows.updateRowCells(Y, xe, ve, CELL_UPDATE_TYPE.UPDATE);
    });
  }
  // REF-20
  // the reason why last row details need to be passed here is because after removal of last row, the last element details
  // are no longer available as this class's methods are run in setTimeouts, hence those details need to be captured
  // before these methods are executed
  // CAUTION-2 if the addition or removal of row causes the parent div to change width, this is indeed run after rerender,
  // however the onCellUpdate messages are required and event rebinding here still appears to be valid
  // prettier-ignore
  static rebindAndFireUpdates(Y, re, oe, ue) {
    UpdateCellsForRows.updateLowerBeforeLastRows(Y, re, ue.index), UpdateCellsForRows.updateLastRow(Y, oe, ue);
  }
}
class RemoveRow {
  // when the last row has been removed, there are no more columns
  static removeAllColumnsDetails(Y) {
    const { _columnsDetails: re } = Y;
    re.forEach((oe) => RemoveColumn.reduceStaticWidthTotal(Y, oe.settings)), re.splice(0, re.length);
  }
  static update(Y, re, oe, ue) {
    const fe = { element: oe, index: ue };
    UpdateCellsForRows.rebindAndFireUpdates(Y, re, CELL_UPDATE_TYPE.REMOVED, fe), setTimeout(() => FireEvents.onDataUpdate(Y)), !Y._isRendering && (Y.data.length === 0 && RemoveRow.removeAllColumnsDetails(Y), Y._addColumnCellsElementsRef.splice(re, 1));
  }
  static rowToBeRemovedIndexWhenPagination(Y, re) {
    var oe;
    const ue = (oe = Y._tableBodyElementRef) == null ? void 0 : oe.children[re];
    return Y._pagination.visibleRows.findIndex((fe) => fe === ue);
  }
  static removeRow(Y, re) {
    var oe;
    const ue = Y.pagination ? RemoveRow.rowToBeRemovedIndexWhenPagination(Y, re) : 0;
    (oe = Y._tableBodyElementRef) == null || oe.children[re].remove(), Y._rowDropdownCellOverlays.splice(re, 1);
    const fe = Y.data.splice(re, 1);
    return fe[0].forEach((he, _e) => {
      Y._columnsDetails[_e].elements.splice(re, 1), Y._columnsDetails[_e].processedStyle.splice(re, 1);
    }), Y.pagination && PaginationUtils.updateOnRowChange(Y, ue), fe[0];
  }
  // REF-27
  static changeRowIndexIfRemoveHeaderWithDataBelow(Y, re) {
    return re === 0 && Y._columnsDetails[0].elements.length > 1 ? (MoveRow.move(Y, 0, !0), 1) : re;
  }
  static remove(Y, re) {
    var oe;
    re = RemoveRow.changeRowIndexIfRemoveHeaderWithDataBelow(Y, re);
    const ue = Y.data.length - 1, fe = (oe = Y._tableBodyElementRef) == null ? void 0 : oe.children[ue];
    RemoveRow.removeRow(Y, re), ToggleAdditionElements.update(Y, !1, AddNewRowElement.toggle), Y._frameComponents.displayIndexColumn && IndexColumn.updateIndexes(Y, re), CustomRowProperties.update(Y, re), setTimeout(() => RemoveRow.update(Y, re, fe, ue));
  }
}
class RowDropdownItemEvents {
  static onClickMiddleware(Y) {
    Y(), RowDropdown.hide(this);
  }
  // prettier-ignore
  static set(Y, re, oe) {
    const ue = re.getElementsByClassName(DropdownItem.DROPDOWN_ITEM_CLASS)[0], fe = ElementSiblingIterator.create(ue);
    fe.currentElement().onclick = RowDropdownItemEvents.onClickMiddleware.bind(
      Y,
      InsertNewRow.insert.bind(this, Y, oe, !0)
    ), fe.next().onclick = RowDropdownItemEvents.onClickMiddleware.bind(
      Y,
      InsertNewRow.insert.bind(this, Y, oe + 1, !0)
    ), fe.next().onclick = RowDropdownItemEvents.onClickMiddleware.bind(
      Y,
      MoveRow.move.bind(this, Y, oe, !1)
    ), fe.next().onclick = RowDropdownItemEvents.onClickMiddleware.bind(
      Y,
      MoveRow.move.bind(this, Y, oe, !0)
    ), fe.next().onclick = RowDropdownItemEvents.onClickMiddleware.bind(
      Y,
      RemoveRow.remove.bind(this, Y, oe)
    );
  }
}
class RowDropdownItem {
  static updateDeleteRowItemStyle(Y, re, oe) {
    DropdownItem.toggleUsability(oe[4], !!(re > 0 || Y.rowDropdown.canEditHeaderRow));
  }
  static updateMoveRowsItemsStyle(Y, re, oe) {
    const { isMoveAvailable: ue, canEditHeaderRow: fe } = Y.rowDropdown;
    ue && (DropdownItem.toggleUsability(oe[2], !0), DropdownItem.toggleUsability(oe[3], !0), (re === 0 || re === 1 && !fe) && DropdownItem.toggleUsability(oe[2], !1), (re === Y._columnsDetails[0].elements.length - 1 || re === 0 && !fe) && DropdownItem.toggleUsability(oe[3], !1));
  }
  static updateInsertRowsItemsStyle(Y, re, oe) {
    MaximumRows.canAddMore(Y) ? (re === 0 && !Y.rowDropdown.canEditHeaderRow ? DropdownItem.toggleUsability(oe[0], !1) : DropdownItem.toggleUsability(oe[0], !0), DropdownItem.toggleUsability(oe[1], !0)) : (DropdownItem.toggleUsability(oe[0], !1), DropdownItem.toggleUsability(oe[1], !1));
  }
  static updateItemStyle(Y, re, oe) {
    const ue = Array.from(re.children);
    RowDropdownItem.updateInsertRowsItemsStyle(Y, oe, ue), RowDropdownItem.updateMoveRowsItemsStyle(Y, oe, ue), RowDropdownItem.updateDeleteRowItemStyle(Y, oe, ue);
  }
  static update(Y, re, oe) {
    RowDropdownItem.updateItemStyle(Y, re, oe), RowDropdownItemEvents.set(Y, re, oe);
  }
  static setUpItems(Y, re) {
    setTimeout(() => {
      const { rowDropdown: oe } = Y, { isInsertUpAvailable: ue, isInsertDownAvailable: fe, isMoveAvailable: he, isDeleteAvailable: _e } = oe, ve = RowDropdownButtonItemConf.ITEMS.map((xe) => DropdownItem.addButtonItem(Y, re, xe));
      ue || DropdownItem.toggleItem(ve[0], !1), fe || DropdownItem.toggleItem(ve[1], !1), he || (DropdownItem.toggleItem(ve[2], !1), DropdownItem.toggleItem(ve[3], !1)), _e || DropdownItem.toggleItem(ve[4], !1);
    });
  }
}
class RowDropdown {
  // prettier-ignore
  static hide(Y) {
    const {
      _activeOverlayElements: { rowDropdown: re, fullTableOverlay: oe },
      _focusedElements: { cell: { element: ue, rowIndex: fe } },
      _frameComponents: { cellColors: he, displayIndexColumn: _e }
    } = Y;
    if (!re || !oe || !ue)
      return;
    Dropdown.hide(re, oe);
    const ve = FrameComponentsColors.getColorsBasedOnParam(he, fe);
    _e && CellHighlightUtils.fade(ue, ve.default), DropdownItemHighlightUtils.fadeCurrentlyHighlighted(Y._activeOverlayElements), setTimeout(() => {
      delete Y._focusedElements.rowDropdown, FocusedCellUtils.purge(Y._focusedElements.cell);
    });
  }
  static focusCell(Y, re, oe) {
    const { _frameComponents: ue, _focusedElements: fe } = Y;
    ue.displayIndexColumn ? FocusedCellUtils.setIndexCell(fe.cell, oe, re) : FocusedCellUtils.set(fe.cell, oe, re, 0);
  }
  // prettier-ignore
  static correctPositionWhenBottomOverflow(Y, re, oe) {
    const { top: ue } = re.parentElement.getBoundingClientRect(), fe = ue + Y.border.topWidth;
    let he = window.innerHeight - fe - re.offsetHeight;
    Browser.IS_FIREFOX && (he += Y.border.topWidth), re.style.top = `${he}px`;
    const _e = ElementVisibility.getDetailsInWindow(re, Y.border);
    !_e.isFullyVisible && _e.blockingSides.has(SIDE.TOP) && (re.style.top = oe);
  }
  static getLeft(Y, re) {
    var oe;
    const ue = (oe = Y.rowDropdown.displaySettings.openMethod) == null ? void 0 : oe.cellClick;
    return `${ElementOffset.processWidth(ue ? re.offsetWidth : 5, Y._tableDimensions.border)}px`;
  }
  static displayAndSetPosition(Y, re, oe) {
    const ue = `${ElementOffset.processTop(re.offsetTop, Y._tableDimensions.border)}px`;
    oe.style.top = ue, oe.style.left = RowDropdown.getLeft(Y, re), Dropdown.display(oe);
    const fe = ElementVisibility.getDetailsInWindow(oe, Y._tableDimensions.border);
    fe.isFullyVisible || fe.blockingSides.has(SIDE.BOTTOM) && RowDropdown.correctPositionWhenBottomOverflow(Y._tableDimensions, oe, ue);
  }
  // prettier-ignore
  static setOverflowPosition(Y, re, oe, ue) {
    if (Y._stickyProps.header && re.tagName === CellElement.HEADER_TAG)
      if (Y._overflow)
        oe.style.top = `${ue.scrollTop}px`;
      else {
        const fe = re.parentElement.offsetTop, he = Number.parseInt(getComputedStyle(re).borderTopWidth);
        oe.style.top = `${fe + he}px`;
      }
    else
      oe.style.top = `${ElementOffset.processTop(re.offsetTop, Y._tableDimensions.border)}px`;
    oe.style.left = RowDropdown.getLeft(Y, re);
  }
  // no active table based overflow
  static displayAndSetPositionForSticky(Y, re, oe) {
    const ue = Y.parentElement;
    RowDropdown.setOverflowPosition(Y, re, oe, ue), Dropdown.display(oe);
  }
  static displayAndSetPositionOverflow(Y, re, oe) {
    const { _tableElementRef: ue, _overflow: fe, _stickyProps: he } = Y;
    if (!ue || !(fe != null && fe.overflowContainer))
      return;
    RowDropdown.setOverflowPosition(Y, re, oe, fe.overflowContainer), Dropdown.display(oe);
    const _e = he.header && re.tagName === CellElement.HEADER_TAG;
    ue.offsetHeight !== fe.overflowContainer.scrollHeight && !_e && (oe.style.top = `${ue.offsetHeight - oe.offsetHeight}px`);
  }
  static display(Y, re) {
    var oe;
    const ue = this._activeOverlayElements.rowDropdown;
    RowDropdownItem.update(this, ue, Y), (oe = this._overflow) != null && oe.overflowContainer ? RowDropdown.displayAndSetPositionOverflow(this, re, ue) : this._stickyProps.header ? RowDropdown.displayAndSetPositionForSticky(this, re, ue) : RowDropdown.displayAndSetPosition(this, re, ue), FullTableOverlayElement.display(this), setTimeout(() => RowDropdown.focusCell(this, Y, re));
  }
  static create(Y) {
    const re = Dropdown.createBase();
    return RowDropdownEvents.set(Y, re), RowDropdownItem.setUpItems(Y, re), re;
  }
}
class RowDropdownCellOverlayEvents {
  static mouseLeave(Y, re) {
    RowDropdownCellOverlay.hide(this, Y), delete this._hoveredElements.leftMostCell, RowDropdownCellOverlay.resetDefaultColor(this.rowDropdown.displaySettings, re);
  }
  static mouseEnter(Y, re) {
    this._hoveredElements.leftMostCell = Y, RowDropdownCellOverlay.setHoverColor(this.rowDropdown.displaySettings, re);
  }
  // prettier-ignore
  static setOverlayEvents(Y, re, oe) {
    const ue = Y._rowDropdownCellOverlays[re].element;
    return ue.onmouseenter = RowDropdownCellOverlayEvents.mouseEnter.bind(
      Y,
      oe,
      ue
    ), ue.onmouseleave = RowDropdownCellOverlayEvents.mouseLeave.bind(
      Y,
      re,
      ue
    ), ue.onclick = RowDropdown.display.bind(Y, re, oe), ue;
  }
  static cellMouseLeave(Y) {
    RowDropdownCellOverlay.hide(this, Y), delete this._hoveredElements.leftMostCell;
  }
  static cellMouseEnter(Y, re) {
    RowDropdownCellOverlay.display(this, Y), this._hoveredElements.leftMostCell = re;
  }
  // This method is adding more events to existing cells instead of overwriting them, the reason for using this approach is
  // because we would instead need to add logic inside data cell events, select/label events, header events and more as
  // row dropdown overlay can appear above them if index column is not displayed
  // Interestingly using setting events like .onmousenter does not overwrite the events that have been added via
  // addEventListener, hence they need to be removed here before adding again
  static addCellEvents(Y, re, oe) {
    const { displaySettings: ue, canEditHeaderRow: fe } = Y.rowDropdown;
    if (!ue.isAvailable || !fe && re === 0)
      return;
    const he = Y._rowDropdownCellOverlays[re];
    if (he != null && he.cellElement) {
      const { cellElement: _e, enter: ve, leave: xe } = he;
      _e.removeEventListener("mouseenter", ve), _e.removeEventListener("mouseleave", xe);
    }
    he.cellElement = oe, he.enter = RowDropdownCellOverlayEvents.cellMouseEnter.bind(Y, re, oe), he.leave = RowDropdownCellOverlayEvents.cellMouseLeave.bind(Y, re), oe.addEventListener("mouseenter", he.enter), oe.addEventListener("mouseleave", he.leave);
  }
}
const _RowDropdownCellOverlay = class La {
  static setDefault(Y, re) {
    var oe;
    Y.style.backgroundColor = ((oe = re?.default) == null ? void 0 : oe.backgroundColor) || "";
  }
  static resetDefaultColor(Y, re) {
    var oe;
    const ue = Y.overlayStyles;
    (oe = ue?.hover) != null && oe.backgroundColor && La.setDefault(re, ue);
  }
  static setHoverColor(Y, re) {
    var oe, ue;
    const fe = (ue = (oe = Y.overlayStyles) == null ? void 0 : oe.hover) == null ? void 0 : ue.backgroundColor;
    fe && (re.style.backgroundColor = fe);
  }
  static hide(Y, re) {
    const oe = Y._hoveredElements.leftMostCell;
    setTimeout(() => {
      if (oe !== Y._hoveredElements.leftMostCell) {
        const ue = Y._rowDropdownCellOverlays[re].element;
        ue.style.width = DropdownCellOverlay.HIDDEN_PX;
      }
    });
  }
  static display(Y, re) {
    const oe = Y._columnsDetails[0], ue = Y._rowDropdownCellOverlays[re].element;
    ue.style.width = DropdownCellOverlay.VISIBLE_PX;
    const fe = oe.elements[re], { displayIndexColumn: he } = Y._frameComponents, _e = he ? fe.previousSibling : fe, ve = _e.offsetHeight / 100;
    ue.style.height = `${ve * 60}px`, ue.style.top = `${ve * 20}px`;
    const xe = he ? oe.elements[0].offsetWidth : 0;
    ue.style.left = `-${_e.offsetWidth + xe}px`;
  }
  static create(Y) {
    const re = document.createElement("div");
    return re.classList.add(La.ROW_DROPDOWN_CELL_OVERLAY_CLASS), re.classList.add(DropdownCellOverlay.DROPDOWN_CELL_OVERLAY_CLASS), re.style.width = DropdownCellOverlay.HIDDEN_PX, La.setDefault(re, Y), re;
  }
  static getCellDividerElement(Y, re) {
    let oe = Y.nextSibling;
    return re && (oe = oe.nextSibling), oe;
  }
  static add(Y, re, oe) {
    const ue = La.create(Y.rowDropdown.displaySettings.overlayStyles), { displayIndexColumn: fe } = Y._frameComponents;
    La.getCellDividerElement(oe, !!fe).appendChild(ue), Y._rowDropdownCellOverlays.splice(re, 0, {
      element: ue,
      // these events are stubs and will be replaced by real ones in RowDropdownCellOverlayEvents.addCellEvents
      enter: () => {
      },
      leave: () => {
      }
    });
  }
  static resetOverlays(Y) {
    var re;
    (re = Y.rowDropdown.displaySettings.openMethod) != null && re.overlayClick && (Y._rowDropdownCellOverlays.splice(0, Y._rowDropdownCellOverlays.length), ExtractElements.textRowsArrFromTBody(Y._tableBodyElementRef, Y.data).forEach((oe, ue) => {
      const fe = oe.children[0];
      La.add(Y, ue, fe), RowDropdownCellOverlayEvents.setOverlayEvents(Y, ue, fe);
    }));
  }
};
_RowDropdownCellOverlay.ROW_DROPDOWN_CELL_OVERLAY_CLASS = "row-dropdown-cell-overlay";
let RowDropdownCellOverlay = _RowDropdownCellOverlay;
class PaginationRowIndexes {
  static getVisibleRowRealIndex(Y, re, oe) {
    const ue = Array.from(Y.children), fe = oe === void 0 ? re.visibleRows.length - 1 : oe, he = re.visibleRows[fe];
    return ue.findIndex((_e) => _e === he);
  }
  static getVisibleRowIndex(Y, re, oe) {
    const ue = Y.children[oe];
    return re.visibleRows.findIndex((fe) => fe === ue);
  }
  static getFilteredMaxVisibleRowIndex(Y, re) {
    const { rowsPerPage: oe, visibleRows: ue } = re, fe = PaginationRowIndexes.getVisibleRowRealIndex(Y, re);
    return ue.length === oe ? fe : fe + (oe - ue.length);
  }
  static getRawMaxVisibleRowIndex(Y) {
    const { _pagination: re, _tableBodyElementRef: oe, data: ue, _visiblityInternal: fe } = Y, { activePageNumber: he, rowsPerPage: _e, isAllRowsOptionSelected: ve } = re;
    return ve ? ue.length + 1 : fe.filters ? PaginationRowIndexes.getFilteredMaxVisibleRowIndex(oe, re) : he * _e;
  }
  static getMaxVisibleRowIndex(Y) {
    const { dataStartsAtHeader: re } = Y;
    let oe = PaginationRowIndexes.getRawMaxVisibleRowIndex(Y);
    return re || (oe += 1), oe;
  }
}
const _RowElement = class ma {
  static create() {
    const Y = document.createElement("tr");
    return Y.classList.add("row"), Y;
  }
  static moveClassToLastVisibleRow(Y, re) {
    re && (re.id = ""), Y.id = ma.LAST_VISIBLE_ROW_ID;
  }
  static toggleNonAddRow(Y, re, oe) {
    if (Y.pagination && Y._pagination) {
      const fe = Y._pagination.visibleRows[Y._pagination.visibleRows.length - 1];
      if (fe)
        return ma.moveClassToLastVisibleRow(fe, oe);
    }
    const { previousElementSibling: ue } = re;
    ue && ma.moveClassToLastVisibleRow(ue, oe);
  }
  // REF-25
  // Add new row element is always appended to the table, but not always visible (e.g. if the user has
  // chosen not to display it or max rows has been reached), hence we must always monitor its current
  // visibility and given that it can be safely assumed that it is the last row element, we can use
  // its isDisplayed method to help assign the last-visible row id to the correct row
  static toggleLastRowClass(Y) {
    const re = Y.shadowRoot, oe = Y._addRowCellElementRef.parentElement, ue = re.getElementById(ma.LAST_VISIBLE_ROW_ID);
    AddNewRowElement.isDisplayed(oe.children[0]) ? oe.id !== ma.LAST_VISIBLE_ROW_ID && ma.moveClassToLastVisibleRow(oe, ue) : ma.toggleNonAddRow(Y, oe, ue);
  }
};
_RowElement.LAST_VISIBLE_ROW_ID = "last-visible-row";
let RowElement = _RowElement;
class CellDividerElement {
  static create(Y) {
    const re = document.createElement("div");
    return re.classList.add("cell-divider"), Y === 0 && (re.style.height = ColumnSizerGenericUtils.canHeightBeInherited() ? "100%" : "inherit"), re;
  }
}
class InsertNewCell {
  // prettier-ignore
  static insertElementsToRow(Y, re, oe, ue, fe) {
    const he = CellElementIndex.getViaColumnIndex(ue, fe);
    Y.insertBefore(re, Y.children[he]);
    const _e = CellDividerElement.create(oe);
    Y.insertBefore(_e, Y.children[he + 1]);
  }
  static updateColumnDetailsAndSizers(Y, re, oe, ue) {
    const fe = Y._columnsDetails[oe];
    if (fe && re === 0) {
      const he = ColumnDropdownCellOverlay.add(Y, oe);
      ColumnDetails.updateWithNoSizer(fe, he), InsertRemoveColumnSizer.insert(Y, oe), ue && (InsertRemoveColumnSizer.cleanUpCustomColumnSizers(Y, oe), UpdateIndexColumnWidth.wrapTextWhenNarrowColumnsBreached(Y));
    }
  }
  // prettier-ignore
  static insert(Y, re, oe, ue, fe, he, _e) {
    const { _frameComponents: { displayIndexColumn: ve }, data: xe, _columnsDetails: Ee } = Y, Se = Ee[_e];
    Se.elements.splice(he, 0, oe), Se.processedStyle.splice(he, 0, ProcessedDataTextStyle.getDefaultProcessedTextStyle()), InsertNewCell.insertElementsToRow(re, oe, he, _e, !!ve), xe[he].splice(_e, fe ? 0 : 1, ue);
  }
  static convertCell(Y, re, oe, ue) {
    const fe = Y._columnsDetails[oe];
    re === 0 && Y.displayHeaderIcons && HeaderIconCellElement.setHeaderIconStructure(Y, ue, oe), fe.activeType && (fe.activeType.cellDropdownProps ? re === 0 ? CellDropdown.setUpDropdown(Y, oe) : (SelectCell.convertCell(Y, oe, ue), SelectCell.finaliseEditedText(Y, ue.children[0], oe, !0)) : re > 0 && (fe.activeType.checkbox && CheckboxCellElement.setCellCheckboxStructure(Y, ue, oe, re), fe.activeType.calendar && DateCellElement.setCellDateStructure(Y, ue, oe)));
  }
  // REF-13
  // prettier-ignore
  static insertInitialColumnDetails(Y, re, oe) {
    const { _columnsDetails: ue, _customColumnsSettings: fe, _cellDropdownContainer: he, _defaultColumnsSettings: _e } = Y, ve = CellDropdown.createAndAppend(he), xe = ColumnDetails.createInitial(
      _e,
      ve,
      fe[re],
      Y._defaultCellHoverColors,
      FireEvents.onColumnsUpdate.bind(this, Y)
    );
    ue.splice(oe, 0, xe);
  }
  // isNewText indicates whether rowData is already in the data state or if it needs to be added
  // prettier-ignore
  static insertToRow(Y, re, oe, ue, fe, he) {
    oe === 0 && InsertNewCell.insertInitialColumnDetails(Y, fe, ue);
    const _e = DataUtils.processCellText(Y, oe, ue, fe), ve = CellElement.createCellElement(Y, _e, ue, oe === 0);
    InsertNewCell.insert(Y, re, ve, _e, he, oe, ue), InsertNewCell.convertCell(Y, oe, ue, ve), oe === 0 ? (he && StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(Y, !0), ColumnSettingsBorderUtils.updateSiblingColumns(Y, ue)) : ProcessedDataTextStyle.setCellStyle(Y, oe, ue), setTimeout(() => InsertNewCell.updateColumnDetailsAndSizers(Y, oe, ue, he));
  }
}
class InsertNewRow {
  // CAUTION-2 if the addition or removal of row causes the parent div to change width, this is indeed run after rerender,
  // however the notification messages are necessary and the rebinding does not seem to cause issues, nevertheless take
  // note of this if editing any of the logic below
  static bindAndfireCellUpdates(Y, re) {
    var oe;
    const ue = Y.data.length - 1, fe = { element: (oe = Y._tableBodyElementRef) == null ? void 0 : oe.children[ue], index: ue };
    UpdateCellsForRows.rebindAndFireUpdates(Y, re, CELL_UPDATE_TYPE.ADD, fe), setTimeout(() => FireEvents.onDataUpdate(Y));
  }
  static canStartRenderCellBeAdded(Y, re, oe) {
    return re === 0 ? MaximumColumns.canAddMore(Y) : Y._columnsDetails[oe];
  }
  // prettier-ignore
  static addCells(Y, re, oe, ue, fe) {
    const { _frameComponents: { displayIndexColumn: he, displayAddNewColumn: _e } } = Y;
    he && IndexColumn.createAndPrependToRow(Y, oe, ue), re.forEach((ve, xe) => {
      (fe || InsertNewRow.canStartRenderCellBeAdded(Y, ue, xe)) && InsertNewCell.insertToRow(Y, oe, ue, xe, ve, fe);
    }), _e && AddNewColumnElement.createAndAppendToRow(Y, oe, ue), setTimeout(() => RowDropdownCellOverlay.add(Y, ue, oe.children[0]));
  }
  static updatePagination(Y, re, oe, ue) {
    oe ? PaginationUtils.updateOnRowChange(Y, re, ue) : PaginationUtils.initialRowUpdates(Y, re, ue);
  }
  static insertNewRow(Y, re, oe, ue) {
    var fe, he;
    const _e = ue || DataUtils.createEmptyStringDataArray(((fe = Y.data[0]) == null ? void 0 : fe.length) || 1), ve = RowElement.create();
    return Y.pagination && InsertNewRow.updatePagination(Y, re, oe, ve), (he = Y._tableBodyElementRef) == null || he.insertBefore(ve, Y._tableBodyElementRef.children[re]), oe && Y.data.splice(re, 0, []), InsertNewRow.addCells(Y, _e, ve, re, oe), ve;
  }
  // isNewText indicates whether rowData is already in the data state or if it needs to be added
  static insert(Y, re, oe, ue) {
    if (!MaximumRows.canAddMore(Y))
      return;
    const fe = oe && re === 0 && Y._columnsDetails.length > 0;
    fe && (re = 1);
    const he = InsertNewRow.insertNewRow(Y, re, oe, ue);
    oe && (ToggleAdditionElements.update(Y, !0, AddNewRowElement.toggle), Y._frameComponents.displayIndexColumn && IndexColumn.updateIndexes(Y, re + 1), CustomRowProperties.update(Y, re)), fe && MoveRow.move(Y, 0, !0), setTimeout(() => {
      Y._isPopulatingTable ? UpdateCellsForRows.updateRowCells(Y, he, re, CELL_UPDATE_TYPE.ADD) : ue ? re === Y.data.length - 1 && InsertNewRow.bindAndfireCellUpdates(Y, 0) : InsertNewRow.bindAndfireCellUpdates(Y, re);
    });
  }
  // prettier-ignore
  static insertEvent() {
    let Y = this.data.length;
    if (this.pagination)
      if (this._visiblityInternal.filters && this._tableBodyElementRef)
        Y = this.data.length === 1 && !this.dataStartsAtHeader ? 1 : PaginationRowIndexes.getVisibleRowRealIndex(this._tableBodyElementRef, this._pagination) + 1;
      else {
        const re = PaginationRowIndexes.getMaxVisibleRowIndex(this);
        re < Y && (Y = re);
      }
    InsertNewRow.insert(this, Y, !0);
  }
}
class AddNewRowEvents {
  static mouseEnterCell(Y, re) {
    CellHighlightUtils.highlight(re.target, Y.hover);
  }
  static mouseLeaveCell(Y, re) {
    CellHighlightUtils.fade(re.target, Y.default);
  }
  static setCellEvents(Y, re) {
    re.onclick = InsertNewRow.insertEvent.bind(Y);
    const oe = Y._frameComponents.cellColors.data;
    re.onmouseenter = AddNewRowEvents.mouseEnterCell.bind(this, oe), re.onmouseleave = AddNewRowEvents.mouseLeaveCell.bind(this, oe);
  }
}
const _AddNewRowElement = class Ur {
  static isDisplayed(Y) {
    return Y.style.display === Ur.VISIBLE;
  }
  static setDisplay(Y, re) {
    Ur.isDisplayed(Y) !== re && (Y.style.display = re ? Ur.VISIBLE : Ur.HIDDEN);
  }
  static setDefaultStyle(Y) {
    Y.innerText = "+ New", Y.style.width = "";
  }
  // prettier-ignore
  static createCell(Y) {
    const { _defaultColumnsSettings: { cellStyle: re }, _frameComponents: { displayAddNewRow: oe, styles: ue }, rootCell: fe } = Y, he = CellElement.createDataCell(!1, re, ue?.default);
    return he.id = Ur.ID, oe ? Ur.setDefaultStyle(he) : (RootCellElement.convertToRootCell(he, fe?.text), he.addEventListener("click", Ur.setDisplay.bind(this, he, !1))), Ur.setDisplay(he, oe), he.colSpan = Ur.DEFAULT_COL_SPAN, AddNewRowEvents.setCellEvents(Y, he), he;
  }
  static create(Y) {
    const re = RowElement.create(), oe = Ur.createCell(Y);
    return re.appendChild(oe), oe;
  }
  // prettier-ignore
  static toggle(Y) {
    const { _tableBodyElementRef: re, _addRowCellElementRef: oe, _frameComponents: { displayAddNewRow: ue } } = Y;
    !(oe != null && oe.parentElement) || !re || (ue && Ur.setDisplay(oe, MaximumRows.canAddMore(Y)), RowElement.toggleLastRowClass(Y));
  }
  static isAddNewRowRow(Y) {
    var re;
    return ((re = Y?.children[0]) == null ? void 0 : re.id) === Ur.ID;
  }
};
_AddNewRowElement.DEFAULT_COL_SPAN = 1e9;
_AddNewRowElement.HIDDEN = "none";
_AddNewRowElement.VISIBLE = "";
_AddNewRowElement.ID = "add-new-row-cell";
let AddNewRowElement = _AddNewRowElement;
class ElementEvents {
  static toggleListeners(Y, re, oe) {
    Object.keys(re).forEach((ue) => {
      (re[ue] || []).forEach((fe) => {
        Y[oe ? "addEventListener" : "removeEventListener"](ue, fe);
      });
    });
  }
  static convertToArrayObj(Y) {
    return Object.keys(Y).reduce((re, oe) => {
      const ue = oe, fe = Y[ue];
      return ue && fe && (re[ue] = [fe]), re;
    }, {});
  }
  static getDefault() {
    return { rootCell: { styles: {} } };
  }
}
class RootCellEvents {
  static removeEvents(Y, re) {
    AddNewRowElement.setDefaultStyle(Y), ElementEvents.toggleListeners(Y, re.styles, !1), Y.dispatchEvent(new MouseEvent("mouseenter")), delete re.applied;
  }
  // setting, not apply here as this is only triggered once
  static setEventFunctions(Y, re, oe) {
    if (oe && (Y._eventFunctions.rootCell.styles = ElementEvents.convertToArrayObj(
      StatefulCSSEvents.getEvents(re, oe)
    )), Y._frameComponents.displayAddNewRow) {
      const ue = RootCellElement.convertFromRootCell.bind(this, Y), { styles: fe } = Y._eventFunctions.rootCell;
      fe.click ?? (fe.click = []), fe.click.push(ue);
    }
  }
  static applyStyles(Y, re, oe) {
    var ue, fe, he, _e;
    const ve = ElementStyle.generateStatefulCSS(re, {}, {});
    (ue = ve.default) != null && ue.width && (oe.style.width = ve.default.width), (fe = ve.default) == null || delete fe.width, (he = ve.hover) == null || delete he.width, (_e = ve.click) == null || delete _e.width, Object.assign(Y.style, ve.default);
  }
  // prettier-ignore
  static applyEvents(Y, re) {
    const { _tableElementRef: oe, rootCell: ue, _eventFunctions: { rootCell: fe } } = Y, he = ue != null && ue.styles ? JSON.parse(JSON.stringify(ue.styles)) : null;
    he && oe && RootCellEvents.applyStyles(re, he, oe), Object.keys(fe.styles).length === 0 && RootCellEvents.setEventFunctions(Y, re, he), ElementEvents.toggleListeners(re, fe.styles, !0), fe.applied = !0;
  }
}
const _RootCellElement = class ii {
  // prettier-ignore
  static convertFromRootCell(Y) {
    const { _addRowCellElementRef: re, rootCell: oe, _eventFunctions: { rootCell: ue } } = Y;
    re && (re.classList.remove(ii.ROOT_CELL_CLASS), oe != null && oe.styles && ElementStyle.unsetAllCSSStates(re, oe.styles), RootCellEvents.removeEvents(re, ue));
  }
  static convertToRootCell(Y, re) {
    Y.classList.add(ii.ROOT_CELL_CLASS), Y.innerText = re || "+", Y.style.width = `${TableDimensionsUtils.MINIMAL_TABLE_WIDTH}px`;
  }
  // addNewRowCell is preserved as it is reused as the root cell
  static removeRows(Y) {
    Array.from(Y.children).slice(0, Y.children.length - 1).forEach((re) => re.remove());
  }
  // prettier-ignore
  static display(Y) {
    const {
      _tableBodyElementRef: re,
      _addColumnCellsElementsRef: oe,
      _addRowCellElementRef: ue,
      rootCell: fe,
      _frameComponents: { displayAddNewColumn: he, displayAddNewRow: _e }
    } = Y;
    if (!ue)
      return;
    const ve = re;
    he && oe.splice(0, oe.length), ii.removeRows(ve), _e && ii.convertToRootCell(ue, fe?.text), Y._eventFunctions.rootCell.applied || RootCellEvents.applyEvents(Y, ue), AddNewRowElement.setDisplay(ue, !0);
  }
};
_RootCellElement.ROOT_CELL_CLASS = "root-cell";
let RootCellElement = _RootCellElement;
class ToggleAdditionElements {
  static update(Y, re, oe) {
    Y.data.length === 0 || Y._columnsDetails.length === 0 ? RootCellElement.display(Y) : oe(Y, re);
  }
}
class InsertNewColumn {
  static updateColumns(Y, re, oe, ue) {
    const fe = { element: re, index: oe }, he = LastColumn.getDetails(Y._columnsDetails, oe);
    UpdateCellsForColumns.rebindAndFireUpdates(Y, fe, ue, CELL_UPDATE_TYPE.ADD, he);
  }
  static insertToAllRows(Y, re, oe) {
    ExtractElements.textRowsArrFromTBody(Y._tableBodyElementRef, Y.data).forEach((ue, fe) => {
      const he = oe ? oe[fe] : EMPTY_STRING;
      InsertNewCell.insertToRow(Y, ue, fe, re, he, !0), setTimeout(() => InsertNewColumn.updateColumns(Y, ue, fe, re));
    });
  }
  // columnData is in a row format to populate the column by iterating through each row
  static insert(Y, re, oe) {
    MaximumColumns.canAddMore(Y) && (FocusedCellUtils.incrementColumnIndex(Y._focusedElements.cell, re), InsertNewColumn.insertToAllRows(Y, re, oe), ToggleAdditionElements.update(Y, !0, AddNewColumnElement.toggle), setTimeout(() => {
      FireEvents.onDataUpdate(Y), FireEvents.onColumnsUpdate(Y);
    }));
  }
  static insertEvent() {
    InsertNewColumn.insert(this, this._columnsDetails.length);
  }
}
class InsertMatrix {
  // prettier-ignore
  static removeDataThatIsNotEditableFromNewRows(Y, re, oe) {
    return Y.slice(oe).forEach((ue, fe) => {
      ue.settings.isCellTextEditable || re.forEach((he) => {
        he[fe] = EMPTY_STRING;
      });
    }), re;
  }
  // if the data does not fill the 2D array, fill cells with empty strings
  static createRowDataArrayWithEmptyCells(Y, re, oe) {
    const ue = DataUtils.createEmptyStringDataArray(Y);
    return ue.splice(oe, re.length, ...re), ue;
  }
  // prettier-ignore
  static createNewRows(Y, re, oe) {
    InsertMatrix.removeDataThatIsNotEditableFromNewRows(
      Y._columnsDetails,
      re,
      oe
    ).forEach((ue) => {
      var fe;
      const he = InsertMatrix.createRowDataArrayWithEmptyCells(
        ((fe = Y.data[0]) == null ? void 0 : fe.length) || 0,
        ue,
        oe
      );
      InsertNewRow.insert(Y, Y.data.length, !0, he);
    });
  }
  static changeColumnSettings(Y, re) {
    const { elements: oe } = Y._columnsDetails[re];
    FocusedCellUtils.set(Y._focusedElements.cell, oe[0], 0, re), HeaderText.onAttemptChange(Y, oe[0], re);
  }
  static processNewColumn(Y) {
    const re = Y._columnsDetails.length - 1;
    CellEvents.setCellToDefaultIfNeeded(Y, 0, re, Y._columnsDetails[re].elements[0], !1), InsertMatrix.changeColumnSettings(Y, re);
  }
  // prettier-ignore
  static createNewColumns(Y, re, oe) {
    ArrayUtils.transpose(re).forEach((ue) => {
      const fe = InsertMatrix.createRowDataArrayWithEmptyCells(
        Y.data.length,
        ue,
        oe
      );
      InsertNewColumn.insert(Y, Y.data[0].length, fe), InsertMatrix.processNewColumn(Y);
    });
  }
  // prettier-ignore
  static overwriteCell(Y, re, oe, ue, fe) {
    const { _frameComponents: { displayIndexColumn: he }, _columnsDetails: _e } = Y, ve = CellElementIndex.getViaColumnIndex(ue, !!he), xe = re.children[ve], Ee = _e[ue];
    oe === 0 && !Ee.settings.isHeaderTextEditable || oe > 0 && !Ee.settings.isCellTextEditable || (oe === 0 && CellElement.setNewText(Y, xe, fe, !1, !1), CellEvents.updateCell(Y, fe, oe, ue, { element: xe, updateTableEvent: !1 }), ColumnTypesUtils.updateDataElements(Y, oe, ue, xe), oe === 0 && InsertMatrix.changeColumnSettings(Y, ue));
  }
  // prettier-ignore
  static overwriteRowData(Y, re, oe, ue, fe) {
    re.forEach((he, _e) => {
      const ve = ue + _e;
      InsertMatrix.overwriteCell(Y, fe, oe, ve, he);
    });
  }
  // prettier-ignore
  static setCaretToEndAndHighlightIfSelect(Y, re, oe) {
    const { activeType: ue, cellDropdown: fe, settings: { defaultText: he } } = Y._columnsDetails[oe];
    CaretPosition.setToEndOfText(Y, re), ue.cellDropdownProps && CellDropdown.updateCellDropdown(re, fe, Y._tableDimensions.border, he, !0);
  }
  // prettier-ignore
  static overwriteExistingCells(Y, re, oe, ue) {
    const fe = [];
    re.forEach((_e, ve) => {
      var xe;
      const Ee = oe + ve, Se = (xe = Y._tableBodyElementRef) == null ? void 0 : xe.children[Ee], Te = Y.data[0].length - ue, Ce = _e.slice(0, Te);
      InsertMatrix.overwriteRowData(Y, Ce, Ee, ue, Se);
      const Ie = _e.slice(Te);
      fe.push(Ie);
    });
    const he = Y._focusedElements.cell.element;
    return setTimeout(() => InsertMatrix.setCaretToEndAndHighlightIfSelect(Y, he, ue)), fe;
  }
  // no new rows should be created if no columns that are to be overwritten/created allow text edit
  static canNewRowsBeCreated(Y, re, oe) {
    return Y._columnsDetails.slice(oe, oe + re[0].length).find((ue) => ue.settings.isCellTextEditable);
  }
  static insertColumnsInsideIfCantInsertRight(Y, re, oe) {
    const ue = Y._columnsDetails.slice(oe).findIndex((fe) => fe.settings.columnDropdown.isInsertRightAvailable === !1);
    if (ue !== -1)
      if (ue === 0)
        re.forEach((fe) => fe.splice(1, fe.length - 1));
      else {
        const fe = re[0].length - (ue + 1);
        for (let he = 0; he < fe; he += 1)
          InsertNewColumn.insert(Y, oe + ue + he);
      }
  }
  static getNewMatrixBasedOnColumns(Y, re, oe) {
    var ue, fe;
    const he = (((ue = Y[0]) == null ? void 0 : ue.length) || 0) - (((fe = re[0]) == null ? void 0 : fe.length) || 0) - oe;
    return he > 0 ? new Array(re.length).fill(new Array(he).fill(EMPTY_STRING)) : [];
  }
  // A matrix is a complete 2D array
  // prettier-ignore
  static insert(Y, re, oe, ue, fe) {
    const he = Y.data.length - oe;
    fe || InsertMatrix.insertColumnsInsideIfCantInsertRight(Y, re, ue);
    const _e = re.slice(0, he), ve = fe ? InsertMatrix.getNewMatrixBasedOnColumns(re, Y.data, ue) : InsertMatrix.overwriteExistingCells(Y, _e, oe, ue);
    if (InsertMatrix.createNewColumns(Y, ve, oe), !fe && !InsertMatrix.canNewRowsBeCreated(Y, re, ue))
      return;
    const xe = re.slice(he);
    InsertMatrix.createNewRows(Y, xe, ue), setTimeout(() => FireEvents.onDataUpdate(Y));
  }
}
const _ParseCSVClipboardText = class Cr {
  static preprocessText(Y) {
    let re = Y;
    return Y.charAt(0) === Cr.STRING_QUOTE_SYMBOL && (re = re.substring(1)), Y.charAt(Y.length - 1) === Cr.STRING_QUOTE_SYMBOL && (re = re.substring(0, Y.length - 2)), re;
  }
  static getSeparatorSymbols(Y) {
    return Y.indexOf(Cr.EXPLICIT_WINDOWS_NEW_LINE_SYMBOL) > -1 ? {
      newLine: Cr.EXPLICIT_WINDOWS_NEW_LINE_SYMBOL,
      tab: Cr.EXPLICIT_TAB_SYMBOL
    } : Y.indexOf(Cr.WINDOWS_NEW_LINE_SYMBOL) > -1 ? { newLine: Cr.WINDOWS_NEW_LINE_SYMBOL, tab: Cr.TAB_SYMBOL } : Y.indexOf(Cr.EXPLICIT_NEW_LINE_SYMBOL) > -1 || Y.indexOf(Cr.EXPLICIT_TAB_SYMBOL) > -1 ? { newLine: Cr.EXPLICIT_NEW_LINE_SYMBOL, tab: Cr.EXPLICIT_TAB_SYMBOL } : { newLine: Cr.NEW_LINE_SYMBOL, tab: Cr.TAB_SYMBOL };
  }
  static parse(Y) {
    const re = Cr.preprocessText(Y), { newLine: oe, tab: ue } = Cr.getSeparatorSymbols(re);
    return re.split(oe).map((fe) => fe.split(ue).map((he) => he.replace(/\\"/g, "")));
  }
};
_ParseCSVClipboardText.STRING_QUOTE_SYMBOL = '"';
_ParseCSVClipboardText.TAB_SYMBOL = "\\t";
_ParseCSVClipboardText.NEW_LINE_SYMBOL = "\\n";
_ParseCSVClipboardText.EXPLICIT_TAB_SYMBOL = "\\\\t";
_ParseCSVClipboardText.EXPLICIT_NEW_LINE_SYMBOL = "\\\\n";
_ParseCSVClipboardText.WINDOWS_NEW_LINE_SYMBOL = "\\r\\n";
_ParseCSVClipboardText.EXPLICIT_WINDOWS_NEW_LINE_SYMBOL = "\\\\r\\\\n";
let ParseCSVClipboardText = _ParseCSVClipboardText;
class OverwriteCellsViaCSVOnPaste {
  static trimCSVRowsIfPaginationAsync(Y, re, oe, ue) {
    var fe;
    const he = Y.length + oe;
    re.length < he && (Y = Y.slice(0, Y.length - (he - re.length)));
    const _e = ((fe = re[0]) == null ? void 0 : fe.length) || 0, ve = Y[0].length + ue;
    if (_e < ve) {
      const xe = Y[0].length - (ve - _e);
      Y.forEach((Ee) => Ee.splice(xe));
    }
    return Y;
  }
  static focusOriginalCellAfterProcess(Y, re) {
    const { element: oe, rowIndex: ue, columnIndex: fe } = Y._focusedElements.cell;
    re(), FocusedCellUtils.set(Y._focusedElements.cell, oe, ue, fe);
  }
  // prettier-ignore
  static overwrite(Y, re, oe, ue, fe) {
    oe.preventDefault();
    let he = ParseCSVClipboardText.parse(re);
    Y._pagination.async && (he = OverwriteCellsViaCSVOnPaste.trimCSVRowsIfPaginationAsync(he, Y.data, ue, fe)), OverwriteCellsViaCSVOnPaste.focusOriginalCellAfterProcess(
      Y,
      InsertMatrix.insert.bind(this, Y, he, ue, fe)
    );
  }
  static isCSVData(Y) {
    return Y.indexOf(ParseCSVClipboardText.NEW_LINE_SYMBOL) > -1 || Y.indexOf(ParseCSVClipboardText.TAB_SYMBOL) > -1;
  }
}
var KEYBOARD_COMBINATION_EVENT = /* @__PURE__ */ ((le) => (le.PASTE = "Paste", le))(KEYBOARD_COMBINATION_EVENT || {});
const KEYBOARD_EVENT = { ...KEYBOARD_COMBINATION_EVENT, [KEYBOARD_KEY.TAB]: KEYBOARD_KEY.TAB }, _UserKeyEventsStateUtils = class tn {
  static createNew() {
    return { [KEYBOARD_KEY.TAB]: !1, [KEYBOARD_EVENT.PASTE]: !1, [MOUSE_EVENT.DOWN]: !1 };
  }
  static temporarilyIndicateEvent(Y, re) {
    Y[re] = !0, setTimeout(() => Y[re] = !1, tn.KEY_PRESS_STATE_TIMEOUT_ML);
  }
};
_UserKeyEventsStateUtils.KEY_PRESS_STATE_TIMEOUT_ML = 5;
let UserKeyEventsStateUtils = _UserKeyEventsStateUtils;
const _PasteUtils = class ln {
  static sanitizePastedTextData(Y) {
    var re, oe;
    Y.preventDefault();
    const ue = (re = Y.clipboardData) == null ? void 0 : re.getData("text/plain");
    (oe = document.execCommand) == null || oe.call(document, "insertHTML", !1, ue);
  }
  static extractClipboardText(Y) {
    var re;
    return JSON.stringify((re = Y.clipboardData) == null ? void 0 : re.getData(ln.TEXT_DATA_FORMAT));
  }
};
_PasteUtils.TEXT_DATA_FORMAT = "text/plain";
let PasteUtils = _PasteUtils;
const UNDO_INPUT_TYPE = "historyUndo";
class DataCellEvents {
  static keyDownCell(Y, re, oe) {
    const { elements: ue, activeType: fe } = this._columnsDetails[re];
    oe.key === KEYBOARD_KEY.TAB ? UserKeyEventsStateUtils.temporarilyIndicateEvent(this._userKeyEventsState, KEYBOARD_KEY.TAB) : oe.key === KEYBOARD_KEY.ENTER && this.enterKeyMoveDown && !fe.cellDropdownProps && FocusNextRowCell.focus(this, Y, ue, oe);
  }
  // using this instead of keydown because when this is fired the new cell text is available
  // prettier-ignore
  static inputCell(Y, re, oe) {
    const ue = oe, fe = ue.target;
    if (DateCellInputElement.isInputElement(fe))
      return;
    const he = CellElement.getText(fe);
    if (!this._userKeyEventsState[KEYBOARD_EVENT.PASTE]) {
      const _e = ue.inputType === UNDO_INPUT_TYPE;
      CellElement.setNewText(this, fe, he, !1, _e, !1);
      const ve = this._columnsDetails[re];
      ve.activeType.cellDropdownProps && Y > 0 && CellDropdown.updateCellDropdown(
        fe,
        ve.cellDropdown,
        this._tableDimensions.border,
        ve.settings.defaultText,
        !0
      ), CellEvents.updateCell(this, he, Y, re, { processText: !1 });
    }
  }
  // prettier-ignore
  static pasteCell(Y, re, oe) {
    UserKeyEventsStateUtils.temporarilyIndicateEvent(this._userKeyEventsState, KEYBOARD_EVENT.PASTE), PasteUtils.sanitizePastedTextData(oe);
    const ue = PasteUtils.extractClipboardText(oe);
    if (OverwriteCellsViaCSVOnPaste.isCSVData(ue))
      OverwriteCellsViaCSVOnPaste.overwrite(this, ue, oe, Y, re);
    else {
      const fe = oe.target, { cellDropdown: he, settings: { defaultText: _e }, activeType: ve } = this._columnsDetails[re], xe = fe.tagName === "BR" ? fe.parentElement : fe;
      setTimeout(() => {
        ve.cellDropdownProps && CellDropdown.updateCellDropdown(
          xe,
          he,
          this._tableDimensions.border,
          _e,
          !0
        ), CellEvents.updateCell(this, CellElement.getText(xe), Y, re, { processText: !1 });
      });
    }
  }
  // prettier-ignore
  // textContainerElement can be cell element for data cell, text element for select/label and date cells
  static blur(Y, re, oe, ue) {
    CaretDisplayFix.isIssueBrowser() && CaretDisplayFix.removeContentEditable(ue), CellEvents.setCellToDefaultIfNeeded(Y, re, oe, ue), FocusedCellUtils.purge(Y._focusedElements.cell);
  }
  static blurCell(Y, re, oe) {
    var ue, fe, he;
    Y === 0 && !((he = (fe = (ue = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : ue.displaySettings) == null ? void 0 : fe.openMethod) != null && he.cellClick) && HeaderText.onAttemptChange(this, oe.target, re), DataCellEvents.blur(this, Y, re, oe.target);
  }
  // textContainerElement can be cell element for data cell, text element for select/label and date cells
  static prepareText(Y, re, oe, ue) {
    var fe, he, _e;
    const ve = (_e = (he = (fe = Y._defaultColumnsSettings.columnDropdown) == null ? void 0 : fe.displaySettings) == null ? void 0 : he.openMethod) == null ? void 0 : _e.cellClick;
    CaretDisplayFix.isIssueBrowser() && (re > 0 || !ve) && CaretDisplayFix.setContentEditable(ue), CellEvents.removeTextIfDefault(Y, re, oe, ue);
  }
  static focusCell(Y, re, oe) {
    const ue = oe.target;
    DataCellEvents.prepareText(this, Y, re, ue);
    const { _userKeyEventsState: fe, _focusedElements: he } = this;
    fe[KEYBOARD_KEY.TAB] && CaretPosition.setToEndOfText(this, ue), FocusedCellUtils.set(he.cell, ue, Y, re);
  }
  static setEvents(Y, re, oe, ue) {
    re.onfocus = DataCellEvents.focusCell.bind(Y, oe, ue), re.onblur = DataCellEvents.blurCell.bind(Y, oe, ue), re.onmouseenter = () => {
    }, re.onmouseleave = () => {
    }, re.onmousedown = () => {
    }, re.oninput = DataCellEvents.inputCell.bind(Y, oe, ue), re.onpaste = DataCellEvents.pasteCell.bind(Y, oe, ue), re.onkeydown = DataCellEvents.keyDownCell.bind(Y, oe, ue);
  }
}
class SelectCellTextBaseEvents {
  // the reason why this is triggered by window is because when the user clicks on dropdown padding or delete button
  // keydown events will no longer be fired through the cell text - however we need to maintain the same behaviour
  // prettier-ignore
  static keyDownText(Y, re, oe, ue) {
    const { cellDropdown: { activeItems: fe, canAddMoreOptions: he }, elements: _e } = Y._columnsDetails[oe];
    ue.key === KEYBOARD_KEY.ESCAPE ? CellWithTextEvents.programmaticBlur(Y) : ue.key === KEYBOARD_KEY.TAB ? CellTextEvents.tabOutOfCell(Y, re, oe, ue) : ue.key === KEYBOARD_KEY.ENTER ? (ue.preventDefault(), FocusNextRowCell.focusOrBlurSelect(_e, re)) : ue.key === KEYBOARD_KEY.ARROW_UP ? (ue.preventDefault(), CellDropdownItem.setSiblingItemOnCell(Y, fe, "previousSibling")) : ue.key === KEYBOARD_KEY.ARROW_DOWN ? (ue.preventDefault(), CellDropdownItem.setSiblingItemOnCell(Y, fe, "nextSibling")) : (Y.dataStartsAtHeader || re > 0) && !he && ue.preventDefault();
  }
  static displayDropdown(Y, re, oe) {
    var ue;
    const fe = CellDropdown.display(Y, re, oe), { activeType: he, cellDropdown: _e } = Y._columnsDetails[re];
    (ue = he.cellDropdownProps) != null && ue.isBasicSelect && fe && (_e.displayedCellElement = oe, ArrowDownIconElement.toggle(oe, !0), ArrowDownIconElement.setActive(oe));
  }
  static clearTypeSpecificProps(Y, re) {
    const { cellDropdown: oe, activeType: ue } = re;
    ue.cellDropdownProps && (ue.cellDropdownProps.isBasicSelect ? (ArrowDownIconElement.toggle(oe.displayedCellElement, !1), delete oe.displayedCellElement) : OptionButton.hideAfterColorPickerContainerClose(Y, re));
  }
  static blurring(Y, re, oe, ue) {
    const fe = Y._columnsDetails[oe];
    Dropdown.hide(fe.cellDropdown.element), fe.cellDropdown.itemsDetails[CellElement.getText(ue)] || SelectCell.finaliseEditedText(Y, ue, oe), SelectCellTextBaseEvents.clearTypeSpecificProps(Y._columnsDetails, fe), DataCellEvents.blur(Y, re, oe, ue);
  }
  static blurText(Y, re, oe) {
    this._focusedElements.cellDropdown || SelectCellTextBaseEvents.blurring(this, Y, re, oe.target);
  }
  // prettier-ignore
  static setEvents(Y, re, oe, ue) {
    re.onblur = SelectCellTextBaseEvents.blurText.bind(Y, oe, ue), re.onfocus = CellWithTextEvents.focusText.bind(
      Y,
      oe,
      ue,
      SelectCellTextBaseEvents.displayDropdown
    );
  }
}
class CellWithTextEvents {
  // prettier-ignore
  static focusText(Y, re, oe, ue) {
    const fe = ue.target, he = CellElement.getCellElement(fe);
    DataCellEvents.prepareText(this, Y, re, fe), oe?.(this, re, he), FocusedCellUtils.set(this._focusedElements.cell, he, Y, re), this._userKeyEventsState[KEYBOARD_KEY.TAB] && CaretPosition.setToEndOfText(this, fe);
  }
  static programmaticBlur(Y) {
    const { rowIndex: re, columnIndex: oe, element: ue } = Y._focusedElements.cell, fe = CellElement.getTextElement(ue);
    fe.blur(), Y._focusedElements.cellDropdown && (SelectCellTextBaseEvents.blurring(Y, re, oe, fe), delete Y._focusedElements.cellDropdown);
  }
  // prettier-ignore
  static mouseDownCell(Y, re, oe, ue) {
    Y._focusedElements.cellDropdown && CellWithTextEvents.programmaticBlur(Y);
    const fe = CellElement.getTextElement(oe);
    ue.preventDefault(), re?.(Y), CaretDisplayFix.isIssueBrowser() && fe.focus(), CaretPosition.setToEndOfText(Y, fe);
  }
  static mouseDown(Y, re) {
    if (re.target.classList.contains(CellElement.CELL_CLASS)) {
      const oe = re.target;
      CellWithTextEvents.mouseDownCell(this, Y, oe, re);
    }
  }
}
class CellDropdownScrollbar {
  static setProperties(Y) {
    const { element: re, scrollbarPresence: oe } = Y;
    CellDropdownHorizontalScrollFix.setPropertiesIfHorizontalScrollPresent(Y), oe.vertical = ScrollbarUtils.isVerticalPresent(re);
  }
}
class OptionDeleteButtonEvents {
  static delete(Y, re) {
    const { cellDropdown: oe } = Y, ue = re.target.parentElement.parentElement;
    delete oe.itemsDetails[CellElement.getText(ue.children[0])], ue.remove(), Object.keys(oe.itemsDetails).length === 0 ? CellWithTextEvents.programmaticBlur(this) : CellDropdownScrollbar.setProperties(oe), setTimeout(() => FireEvents.onColumnsUpdate(this));
  }
  static addEvents(Y, re, oe) {
    oe.onclick = OptionDeleteButtonEvents.delete.bind(Y, re);
  }
}
const _OptionDeleteButton = class qa {
  static createIcon() {
    const Y = document.createElement("div");
    return Y.classList.add(qa.DELETE_BUTTON_ICON_CLASS), Y.innerText = qa.DELETE_ICON_TEXT, Y;
  }
  static createButton(Y, re) {
    const oe = document.createElement("div");
    return oe.classList.add(DropdownItem.DROPDOWN_ITEM_IDENTIFIER, OptionButton.BUTTON_CLASS), OptionDeleteButtonEvents.addEvents(Y, re, oe), oe;
  }
  static createContainer() {
    const Y = document.createElement("div");
    return Y.classList.add(OptionButton.BUTTON_CONTAINER_CLASS), Y;
  }
  static create(Y, re) {
    const oe = qa.createContainer(), ue = qa.createButton(Y, re), fe = qa.createIcon();
    return ue.appendChild(fe), oe.appendChild(ue), oe;
  }
  static changeVisibility(Y, re, oe) {
    const ue = Y.children[1];
    if (ue.style.display = oe ? "block" : "none", oe) {
      const fe = ue.children[0];
      fe.style.left = `${oe.offsetWidth - re}px`;
    }
  }
};
_OptionDeleteButton.DELETE_BUTTON_ICON_CLASS = "cell-dropdown-option-delete-button-icon";
_OptionDeleteButton.DELETE_ICON_TEXT = "×";
let OptionDeleteButton = _OptionDeleteButton;
class OptionButton {
  static changeVisibility(Y, re, oe) {
    if (Y.isTrusted) {
      const ue = Y.target, fe = re.scrollbarPresence.vertical ? 31 : 16;
      OptionDeleteButton.changeVisibility(ue, fe, oe), Browser.IS_COLOR_PICKER_SUPPORTED && re.labelDetails && !re.labelDetails.colorPickerContainer && OptionColorButton.changeVisibility(ue, fe + 18, oe);
    }
  }
  // prettier-ignore
  static hideAfterColorPickerContainerClose(Y, re) {
    const { cellDropdown: { labelDetails: oe } } = re;
    if (oe != null && oe.colorPickerContainer) {
      oe.colorPickerContainer.style.display = "none";
      const ue = oe.colorPickerContainer.previousElementSibling;
      ue.style.display = "none", delete oe.colorPickerContainer, OptionColorButtonEvents.updateColumnLabelColors(Y, re);
    }
  }
}
OptionButton.BUTTON_CONTAINER_CLASS = "cell-dropdown-option-button-container";
OptionButton.BUTTON_CLASS = "cell-dropdown-option-button";
class CellDropdownItemEvents {
  // prettier-ignore
  static blurItem(Y, re, oe) {
    var ue;
    const { activeItems: fe, labelDetails: he } = Y;
    if (he != null && he.colorPickerContainer)
      return;
    const _e = fe[re];
    _e !== void 0 && (re === "matchingWithCellText" || re === "hovered" && _e !== fe.matchingWithCellText) && (_e.style.backgroundColor = "", he || (_e.style.color = ((ue = Y.customItemStyle) == null ? void 0 : ue.textColor) || ""), delete fe[re]), oe && Y.canAddMoreOptions && OptionButton.changeVisibility(oe, Y);
  }
  // prettier-ignore
  static scrollToItem(Y, re, oe, ue, fe) {
    if (fe.isTrusted)
      return;
    const he = ElementVisibility.isVerticallyVisibleInsideParent(re, Y);
    he.isFullyVisible || (re.scrollIntoView({ block: "nearest" }), oe && he.blockingSides.has(SIDE.BOTTOM) && CellDropdownHorizontalScrollFix.scrollDownFurther(ue));
  }
  static highlightItem(Y, re) {
    const { scrollbarPresence: oe, activeItems: ue, labelDetails: fe, canAddMoreOptions: he, element: _e, itemsDetails: ve } = Y;
    if (fe != null && fe.colorPickerContainer)
      return;
    ue.hovered && (ue.hovered.style.backgroundColor = "", fe || (ue.hovered.style.color = ""));
    const xe = re.target, Ee = xe.children[0].innerText;
    xe.style.backgroundColor = ve[Ee].backgroundColor;
    const Se = xe.parentElement;
    CellDropdownItemEvents.scrollToItem(this, xe, oe.horizontal, Se, re), xe === ue.matchingWithCellText ? (fe || (xe.style.color = "white"), delete ue.hovered) : (fe || (xe.style.backgroundColor = DropdownItemHighlightUtils.HOVER_BACKGROUND_COLOR), ue.hovered = xe), he && OptionButton.changeVisibility(re, Y, _e);
  }
  static set(Y, re, oe) {
    re.onmouseenter = CellDropdownItemEvents.highlightItem.bind(Y, oe), re.onmouseleave = CellDropdownItemEvents.blurItem.bind(this, oe, "hovered");
  }
}
const _CellDropdownItem = class br {
  // prettier-ignore
  static updateCellElementIfNotUpdated(Y, re, oe, ue, fe) {
    Y.data[oe][ue] !== re && CellEvents.updateCell(Y, re, oe, ue, { processText: !1, element: fe });
  }
  // prettier-ignore
  static selectExistingItem(Y, re, oe, ue, fe) {
    var he;
    const _e = CellElement.getText(re.children[0]);
    br.updateCellElementIfNotUpdated(Y, _e, oe, ue, fe), LabelCellTextElement.isLabelText(fe) && (fe.style.backgroundColor = (he = Y._columnsDetails[ue].cellDropdown.itemsDetails[_e]) == null ? void 0 : he.backgroundColor);
  }
  // prettier-ignore
  static addNewItem(Y, re, oe, ue) {
    const { cellDropdown: { labelDetails: fe } } = oe, he = CellElement.getText(re);
    if (he === EMPTY_STRING)
      return;
    let _e = "";
    if (fe) {
      const { globalItemColors: { newColors: ve, existingColors: xe } } = fe;
      _e = ue || xe[he] || ve[ve.length - 1] || LabelColorUtils.getLatestPasteleColor(), re.style.backgroundColor = _e, xe[he] ?? (xe[he] = _e), ve.pop() || LabelColorUtils.setNewLatestPasteleColor();
    } else
      _e = br.ACTIVE_ITEM_BACKGROUND_COLOR;
    br.addItem(Y, he, _e, oe), setTimeout(() => FireEvents.onColumnsUpdate(Y));
  }
  // prettier-ignore
  static updateCellTextBgColor(Y, re, oe, ue) {
    const fe = CellElement.getText(re);
    if (Y)
      re.style.backgroundColor = oe.itemsDetails[fe].backgroundColor;
    else if (!oe.canAddMoreOptions || fe === EMPTY_STRING || fe === ue)
      re.style.backgroundColor = "";
    else if (oe.labelDetails) {
      const { globalItemColors: { newColors: he, existingColors: _e } } = oe.labelDetails;
      re.style.backgroundColor = _e[fe] || he?.[he.length - 1] || LabelColorUtils.getLatestPasteleColor();
    }
  }
  static updateItemColor(Y, re) {
    Y && (re.matchingWithCellText = Y, Y.dispatchEvent(new MouseEvent("mouseenter")));
  }
  static hideHoveredItemHighlight(Y) {
    const { hovered: re, matchingWithCellText: oe } = Y;
    re ? re.style.backgroundColor = "" : Y.hovered = oe;
  }
  // prettier-ignore
  static attemptHighlightMatchingItemWithCell(Y, re, oe, ue, fe) {
    var he;
    const { activeItems: _e, itemsDetails: ve } = re, xe = CellElement.getText(Y), Ee = fe || ((he = ve[xe]) == null ? void 0 : he.element);
    (!Ee || _e.matchingWithCellText !== Ee) && (br.hideHoveredItemHighlight(_e), CellDropdownItemEvents.blurItem(re, "matchingWithCellText")), br.updateItemColor(Ee, _e), ue && re.labelDetails && br.updateCellTextBgColor(Ee, Y, re, oe);
  }
  // prettier-ignore
  static setItemOnCell(Y, re) {
    const { element: oe, rowIndex: ue, columnIndex: fe } = Y._focusedElements.cell, { cellDropdown: he, settings: { defaultText: _e } } = Y._columnsDetails[fe], ve = oe.children[0], xe = CellElement.getText(re.children[0]);
    br.updateCellElementIfNotUpdated(Y, xe, ue, fe, ve), br.attemptHighlightMatchingItemWithCell(ve, he, _e, !0, re), CaretPosition.setToEndOfText(Y, ve);
  }
  // prettier-ignore
  static setSiblingItemOnCell(Y, re, oe) {
    const { hovered: ue, matchingWithCellText: fe } = re, he = ue || fe, _e = he?.[oe];
    if (_e)
      br.setItemOnCell(Y, _e);
    else {
      const { columnIndex: ve } = Y._focusedElements.cell, xe = Y._columnsDetails[ve].cellDropdown.element;
      if (oe === "nextSibling") {
        const Ee = xe.children[0];
        Ee && br.setItemOnCell(Y, Ee);
      } else {
        const Ee = xe.children[xe.children.length - 1];
        Ee && br.setItemOnCell(Y, Ee);
      }
    }
  }
  static addItemElement(Y, re, oe, ue = !1) {
    const { cellDropdown: fe } = oe, he = DropdownItem.addPlaneButtonItem(fe.element, re, ue ? 0 : void 0);
    if (fe.customItemStyle && (he.style.color = fe.customItemStyle.textColor), fe.canAddMoreOptions) {
      const _e = OptionDeleteButton.create(Y, oe);
      if (he.appendChild(_e), Browser.IS_COLOR_PICKER_SUPPORTED && fe.labelDetails) {
        const ve = OptionColorButton.create(Y._columnsDetails, oe);
        he.appendChild(ve);
      }
    }
    return CellDropdownItemEvents.set(Y.shadowRoot, he, fe), he;
  }
  static addItem(Y, re, oe, ue, fe = !1) {
    ue.cellDropdown.itemsDetails[re] = {
      backgroundColor: oe,
      isCustomBackgroundColor: fe,
      element: br.addItemElement(Y, re, ue)
    };
  }
  static addItems(Y, re, oe) {
    oe.cellDropdown.element.replaceChildren(), oe.cellDropdown.itemsDetails = {}, Object.keys(re).forEach((ue) => {
      br.addItem(Y, ue, re[ue].color, oe, !!re[ue].isCustom);
    });
  }
  static postProcessItemToColor(Y, re, oe) {
    Y && delete re[oe];
  }
  // prettier-ignore
  static processNewItemsToColor(Y, re, oe, ue) {
    Y.slice(1).reduce((fe, he) => {
      const _e = he[re];
      if (_e !== EMPTY_STRING && !fe[_e])
        if (ue) {
          const { globalItemColors: { newColors: ve, existingColors: xe } } = ue;
          fe[_e] = { color: xe[_e] || ve.pop() || LabelColorUtils.getLatestPasteleColorAndSetNew() }, xe[_e] ?? (xe[_e] = fe[_e].color);
        } else
          fe[_e] = { color: br.ACTIVE_ITEM_BACKGROUND_COLOR };
      return fe;
    }, oe);
  }
  // prettier-ignore
  static changeUserOptionsToItemToColor(Y, re) {
    return Y.reduce((oe, ue) => {
      var fe;
      if (re) {
        const { globalItemColors: { newColors: he, existingColors: _e } } = re;
        oe[ue.text] = { color: ue.backgroundColor || _e[ue.text] || he.pop() || LabelColorUtils.getLatestPasteleColorAndSetNew(), isCustom: !0 }, _e[fe = ue.text] ?? (_e[fe] = oe[ue.text].color);
      } else
        oe[ue.text] = { color: br.ACTIVE_ITEM_BACKGROUND_COLOR, isCustom: !0 };
      return oe;
    }, {});
  }
  // prettier-ignore
  static populateItems(Y, re) {
    const { data: oe, _columnsDetails: ue } = Y, fe = ue[re], {
      cellDropdown: { labelDetails: he },
      settings: { defaultText: _e, isDefaultTextRemovable: ve },
      activeType: { cellDropdownProps: xe }
    } = fe;
    if (!xe)
      return;
    let Ee = {};
    xe.options && (Ee = br.changeUserOptionsToItemToColor(xe.options, he)), xe.canAddMoreOptions && br.processNewItemsToColor(oe, re, Ee, he), br.postProcessItemToColor(ve, Ee, _e), br.addItems(Y, Ee, fe);
  }
};
_CellDropdownItem.ACTIVE_ITEM_BACKGROUND_COLOR = "#4a69d4";
let CellDropdownItem = _CellDropdownItem;
const _LabelCellTextElement = class zi {
  static isLabelText(Y) {
    return Y.classList.contains(zi.TEXT_CLASS);
  }
  static setCellTextAsAnElement(Y, re, oe) {
    const ue = CellTextElement.setCellTextAsAnElement(Y, oe);
    ue.classList.add(zi.TEXT_CLASS), ue.style.backgroundColor = re;
  }
  // prettier-ignore
  static finaliseEditedText(Y, re, oe, ue = !1) {
    var fe;
    const he = Y._columnsDetails[oe], { cellDropdown: _e, activeType: { cellDropdownProps: ve }, settings: { defaultText: xe, isDefaultTextRemovable: Ee } } = he, Se = (fe = _e.itemsDetails[CellElement.getText(re)]) == null ? void 0 : fe.backgroundColor;
    CellElement.getText(re) === EMPTY_STRING || Ee && CellElement.getText(re) === xe ? re.style.backgroundColor = "" : ue && Se ? re.style.backgroundColor = Se : ve != null && ve.canAddMoreOptions && CellDropdownItem.addNewItem(Y, re, he, re.style.backgroundColor);
  }
};
_LabelCellTextElement.TEXT_CLASS = "label-cell-text";
let LabelCellTextElement = _LabelCellTextElement;
class CellDropdownEvents {
  // instead of binding click event handlers with the context of current row index to individual item elements every
  // time the dropdown is displayed, click events are handled on the dropdown instead, the reason for this is
  // because it can be expensive to rebind an arbitrary amount of items e.g. 10000+
  // prettier-ignore
  static click(Y) {
    const re = Y.target;
    if (re.classList.contains(Dropdown.DROPDOWN_CLASS) || re.classList.contains(OptionButton.BUTTON_CLASS))
      return;
    const { rowIndex: oe, columnIndex: ue, element: fe } = this._focusedElements.cell, he = re.classList.contains(DropdownItem.DROPDOWN_ITEM_CLASS) ? re : re.parentElement;
    CellDropdownItem.selectExistingItem(
      this,
      he,
      oe,
      ue,
      fe.children[0]
    ), CellWithTextEvents.programmaticBlur(this);
  }
  // this is required to record to stop cell blur from closing the dropdown
  // additionally if the user clicks on dropdown scroll or padding, this will record it
  static mouseDown(Y, re) {
    Y.cellDropdown = re;
  }
  static set(Y, re) {
    re.onmousedown = CellDropdownEvents.mouseDown.bind(this, Y._focusedElements, re), re.onclick = CellDropdownEvents.click.bind(Y);
  }
}
const _CellDropdown2 = class Er {
  static generateRightPosition() {
    return "4px";
  }
  // prettier-ignore
  static generateBottomPosition(Y, re, oe) {
    const ue = Y.offsetParent, fe = oe.bottomWidth + oe.topWidth;
    return `${ue.offsetHeight - fe - Y.offsetTop - re.offsetTop + 6}px`;
  }
  // prettier-ignore
  static generateTopPosition(Y, re, oe) {
    const ue = LabelCellTextElement.isLabelText(re) ? re.offsetTop + re.offsetHeight + 2 : Y.offsetHeight - 8;
    return `${ElementOffset.processTop(Y.offsetTop + ue, oe)}px`;
  }
  // prettier-ignore
  static generateLeftPosition(Y, re, oe) {
    const ue = LabelCellTextElement.isLabelText(re) ? re.offsetLeft : 1;
    return `${ElementOffset.processLeft(Y.offsetLeft + ue, oe)}px`;
  }
  // prettier-ignore
  static correctPosition(Y, re, oe, ue) {
    const fe = ElementVisibility.getDetailsInWindow(Y, ue);
    fe.isFullyVisible || (fe.blockingSides.has(SIDE.RIGHT) && (Y.style.left = "", Y.style.right = Er.generateRightPosition()), fe.blockingSides.has(SIDE.BOTTOM) && (Y.style.top = "", Y.style.bottom = Er.generateBottomPosition(
      re,
      oe,
      ue
    )));
  }
  // prettier-ignore
  static correctPositionForOverflow(Y, re, oe) {
    re.offsetHeight !== oe.scrollHeight && (Y.style.top = `${re.offsetHeight - Y.offsetHeight}px`), re.offsetWidth !== oe.scrollWidth && (Y.style.left = `${re.offsetWidth - Y.offsetWidth}px`);
  }
  static setPosition(Y, re, oe) {
    const ue = re.children[0];
    Y.style.bottom = "", Y.style.right = "", Y.style.left = Er.generateLeftPosition(re, ue, oe), Y.style.top = Er.generateTopPosition(re, ue, oe);
    const fe = Y.parentElement.parentElement, he = fe.parentElement;
    OverflowUtils.isOverflowElement(he) ? Er.correctPositionForOverflow(Y, fe, he) : Er.correctPosition(Y, re, ue, oe);
  }
  // prettier-ignore
  static updateCellDropdown(Y, re, oe, ue, fe, he) {
    const _e = CellElement.getTextElement(Y);
    CellDropdownItem.attemptHighlightMatchingItemWithCell(
      _e,
      re,
      ue,
      fe,
      he
    ), fe && Er.setPosition(re.element, _e.parentElement, oe);
  }
  static focusItemOnDropdownOpen(Y, re, oe) {
    CellDropdownItem.attemptHighlightMatchingItemWithCell(Y, re, oe, !1);
  }
  // prettier-ignore
  static correctWidthForOverflow(Y) {
    if (Y.clientWidth !== Y.scrollWidth) {
      const re = Y.clientHeight !== Y.scrollHeight ? 16 : 0, oe = Y.scrollWidth + re;
      Y.style.width = `${Math.min(oe, Er.MAX_WIDTH)}px`;
    }
    Y.children.length > 0 && Y.scrollWidth < Y.children[0].getBoundingClientRect().width && (Y.style.width = `${Y.clientWidth + 1}px`);
  }
  static getWidth(Y, re, oe) {
    if (oe != null && oe.width)
      return Number.parseInt(oe.width);
    if (!re.labelDetails)
      return Math.max(Y.offsetWidth - 2, Er.MIN_WIDTH);
    const ue = Y.children[0];
    return Math.max(Y.offsetWidth - ue.offsetLeft * 2, Er.MIN_WIDTH);
  }
  // prettier-ignore
  static display(Y, re, oe) {
    const { cellDropdown: ue, settings: { defaultText: fe }, activeType: { cellDropdownProps: he } } = Y._columnsDetails[re], { element: _e, itemsDetails: ve } = ue;
    if (Object.keys(ve).length > 0 && he) {
      CellDropdownEvents.set(Y, _e), CellDropdownItemEvents.blurItem(ue, "hovered"), CellDropdownItemEvents.blurItem(ue, "matchingWithCellText"), _e.style.width = `${Er.getWidth(oe, ue, he.dropdownStyle)}px`, Dropdown.display(_e), _e.scrollLeft = 0, Er.correctWidthForOverflow(_e), CellDropdownScrollbar.setProperties(ue), Er.setPosition(_e, oe, Y._tableDimensions.border);
      const xe = oe.children[0];
      return Er.focusItemOnDropdownOpen(xe, ue, fe), !0;
    }
    return !1;
  }
  static setCustomStyle(Y, re) {
    const { paddingTop: oe, paddingBottom: ue, marginTop: fe, marginLeft: he, border: _e, textAlign: ve } = re;
    Y.element.style.paddingTop = oe || Dropdown.DROPDOWN_VERTICAL_PX, Y.element.style.paddingBottom = ue || Dropdown.DROPDOWN_VERTICAL_PX, Y.element.style.marginTop = fe || "0px", Y.element.style.marginLeft = he || "0px", Y.element.style.border = _e || "none", Y.element.style.textAlign = ve || "left";
  }
  static setCustomState(Y, re) {
    Y.customDropdownStyle = re.dropdownStyle, Y.customItemStyle = re.optionStyle, Y.canAddMoreOptions = !!re.canAddMoreOptions;
  }
  // prettier-ignore
  static setUpDropdown(Y, re) {
    const { _columnsDetails: oe, _globalItemColors: ue } = Y, { activeType: { cellDropdownProps: fe }, cellDropdown: he } = oe[re];
    fe && (he.labelDetails = fe.isBasicSelect ? void 0 : { globalItemColors: ue }, Er.setCustomState(he, fe), CellDropdownItem.populateItems(Y, re), fe.dropdownStyle && Er.setCustomStyle(he, fe.dropdownStyle));
  }
  // REF-8 - Created for every column
  static createAndAppend(Y) {
    const re = Dropdown.createBase();
    return re.style.maxHeight = Er.MAX_HEIGHT_PX, re.classList.add(Er.CELL_DROPDOWN_CLASS), Y.appendChild(re), re;
  }
  static getDefaultObj(Y) {
    return {
      itemsDetails: {},
      activeItems: {},
      element: Y,
      canAddMoreOptions: !0,
      scrollbarPresence: {
        horizontal: !1,
        vertical: !1
      }
    };
  }
  static createContainerElement() {
    return document.createElement("div");
  }
};
_CellDropdown2.CELL_DROPDOWN_CLASS = "cell-dropdown";
_CellDropdown2.MAX_HEIGHT_PX = "147px";
_CellDropdown2.MIN_WIDTH = 70;
_CellDropdown2.MAX_WIDTH = 200;
let CellDropdown = _CellDropdown2;
const _ColumnDetails = class Oa {
  // prettier-ignore
  static getHeaderDefaultColor(Y, re, oe, ue) {
    var fe, he, _e, ve, xe, Ee;
    return ((he = (fe = ue?.headerStyles) == null ? void 0 : fe.default) == null ? void 0 : he[re]) || ((_e = ue?.cellStyle) == null ? void 0 : _e[re]) || ((xe = (ve = Y.headerStyles) == null ? void 0 : ve.default) == null ? void 0 : xe[re]) || ((Ee = Y.cellStyle) == null ? void 0 : Ee[re]) || oe;
  }
  // prettier-ignore
  static getHeaderHoverColor(Y, re, oe, ue) {
    var fe, he, _e, ve;
    return ((he = (fe = ue?.headerStyles) == null ? void 0 : fe.hoverColors) == null ? void 0 : he[re]) || ((ve = (_e = Y.headerStyles) == null ? void 0 : _e.hoverColors) == null ? void 0 : ve[re]) || Oa.getHeaderDefaultColor(Y, re, oe, ue);
  }
  // settings variable is a variable attached to columnDetails and can be either default or custom
  // prettier-ignore
  static createHeaderStateColors(Y, re, oe) {
    return {
      hover: {
        color: Oa.getHeaderHoverColor(Y, "color", oe.color, re),
        backgroundColor: Oa.getHeaderHoverColor(
          Y,
          "backgroundColor",
          oe.backgroundColor,
          re
        )
      },
      default: {
        color: Oa.getHeaderDefaultColor(Y, "color", "", re),
        backgroundColor: Oa.getHeaderDefaultColor(Y, "backgroundColor", "", re)
      }
    };
  }
  // prettier-ignore
  static createInitial(Y, re, oe, ue, fe) {
    const he = oe || Y;
    return {
      elements: [],
      processedStyle: [],
      settings: he,
      headerStateColors: Oa.createHeaderStateColors(Y, oe, ue),
      bordersOverwrittenBySiblings: {},
      activeType: ColumnTypesUtils.getActiveType(he),
      cellDropdown: CellDropdown.getDefaultObj(re),
      fireColumnsUpdate: fe
    };
  }
  // prettier-ignore
  static updateWithNoSizer(Y, re) {
    return Object.assign(Y, { columnDropdownCellOverlay: re }), Y;
  }
};
_ColumnDetails.MINIMAL_COLUMN_WIDTH = 34;
let ColumnDetails = _ColumnDetails;
class MaximumColumns {
  // the motivation behind minimal column length came from the fact that when we have set a table width and all the columns
  // have become too narrow (24px), upon adding any subsequent columns - the set table width would be ignored and the table
  // would expand - as an infinite amount of columns can't just be added to a table width a preset width
  // the actual minimal column length is usually not reached as dividing table width by its columns rarely produces it
  // originally this was set to 28, however the extra padding on the left column causes the table width to overflow
  // the set limit hence it is set to 34 instead
  // REF-24
  // this is a small effort to toggle off the add new column button when columns with set widths breach the table
  static isStaticContentBreachingSetTableWidth(Y, re) {
    if (re)
      return !1;
    const oe = Y.width || Y.maxWidth;
    return oe !== void 0 && Y.staticWidth > oe;
  }
  // prettier-ignore
  static ignoreMinimalColumnWidthCheck(Y, re, oe) {
    return Y.preserveNarrowColumns || !StaticTable.isStaticTableWidth(re, Y) || oe === 0;
  }
  // prettier-ignore
  static canAddMore(Y) {
    const { _tableElementRef: re, _columnsDetails: oe, _tableDimensions: ue, maxColumns: fe, preserveNarrowColumns: he } = Y, _e = oe.length;
    if (fe !== void 0 && fe > 0 && fe === _e || MaximumColumns.isStaticContentBreachingSetTableWidth(ue, he))
      return !1;
    const ve = re;
    return MaximumColumns.ignoreMinimalColumnWidthCheck(ue, ve, _e) ? !0 : (ve.offsetWidth - ue.staticWidth) / (_e + 1) >= ColumnDetails.MINIMAL_COLUMN_WIDTH;
  }
}
const _AddNewColumnEvents = class Ra {
  static setHeaderCellStyle(Y, re, oe) {
    const { default: ue, hover: fe } = re;
    Y.style.color = oe ? fe.color : ue.color, Y.style.backgroundColor = oe ? fe.backgroundColor : ue.backgroundColor;
  }
  static setDataCellStyle(Y, re) {
    setTimeout(() => {
      Y.forEach((oe) => {
        oe.style.backgroundColor = re;
      });
    });
  }
  // prettier-ignore
  static setDataCellsStyle(Y, re, oe) {
    const ue = Y ? oe.hover.backgroundColor : oe.default.backgroundColor, fe = re.slice(1), he = Math.ceil(fe.length / Ra.NUMBER_OF_HIGHLIGHT_CHUNKS);
    for (let _e = 0; _e < fe.length; _e += he) {
      const ve = fe.slice(_e, _e + he);
      Ra.setDataCellStyle(ve, ue);
    }
  }
  // prettier-ignore
  static toggleColor(Y, re, oe) {
    const { data: ue, header: fe } = oe, he = re[0];
    he && Ra.setHeaderCellStyle(he, fe, Y), re.length > 1 && Ra.setDataCellsStyle(Y, re, ue);
  }
  // prettier-ignore
  static setEvents(Y, re) {
    const { _addColumnCellsElementsRef: oe, _frameComponents: { cellColors: ue } } = Y;
    re.onmouseenter = Ra.toggleColor.bind(this, !0, oe, ue), re.onmouseleave = Ra.toggleColor.bind(this, !1, oe, ue), re.onclick = InsertNewColumn.insertEvent.bind(Y);
  }
};
_AddNewColumnEvents.NUMBER_OF_HIGHLIGHT_CHUNKS = 3;
let AddNewColumnEvents = _AddNewColumnEvents;
const _AddNewColumnElement = class Ar {
  // the toggling of the add new column element is not a simple display style change because the following selector:
  // .row > .cell:last-of-type which is responsible for not adding a right-border for the rightmost cell can only
  // detect the last .cell element, so when this button is displayed we want the selector to recognise it and
  // not display a border on the right and not affect the css of the cell before it. When it is not displayed,
  // we want the previous cell to be recognised by the selector. Unfortunately this is not possible as even
  // renaming the class names on this button does not re-trigger selector to identify the previous cell as last.
  // The only way to do this is to remove the cell element when not visible, which is what the code below is doing
  // and re-adding the cell when it is visible. (The cell still remains in the addColumnCellsElementsRef object).
  static setDisplay(Y, re, oe, ue) {
    re ? oe.children[ue].appendChild(Y) : Y.remove();
  }
  static createCell(Y, re) {
    var oe;
    const ue = CellElement.createBaseCell(re);
    return ue.classList.add(
      CellElement.CELL_CLASS,
      GenericElementUtils.NOT_SELECTABLE_CLASS,
      Ar.ADD_COLUMN_CELL_CLASS
    ), Object.assign(ue.style, Y._defaultColumnsSettings.cellStyle, (oe = Y._frameComponents.styles) == null ? void 0 : oe.default), AddNewColumnEvents.setEvents(Y, ue), ue;
  }
  // prettier-ignore
  static createHeaderCell(Y) {
    const { _defaultColumnsSettings: { headerStyles: re }, _frameComponents: { cellColors: oe, inheritHeaderColors: ue } } = Y, fe = Ar.createCell(Y, !0);
    return fe.style.width = Ar.DEFAULT_WIDTH_PX, fe.innerText = "+", Object.assign(fe.style, ue ? re?.default : {}, oe.header.default), fe;
  }
  static createDataCell(Y) {
    const re = Ar.createCell(Y, !1);
    return Object.assign(re.style, Y._frameComponents.cellColors.data.default), re;
  }
  static isDisplayed(Y) {
    return GenericElementUtils.doesElementExistInDom(Y[0]);
  }
  static createAndAppendToRow(Y, re, oe) {
    const { _addColumnCellsElementsRef: ue, _columnsDetails: fe } = Y, he = ue.length === 0 || Ar.isDisplayed(ue), _e = oe === 0 ? Ar.createHeaderCell(Y) : Ar.createDataCell(Y);
    ue.splice(oe, 0, _e);
    const ve = fe[fe.length - 1];
    ColumnSettingsBorderUtils.unsetSubjectBorder(ue, ve.elements, "left", oe), he && (MaximumColumns.canAddMore(Y) ? re.appendChild(_e) : oe === 0 && TableElement.changeStaticWidthTotal(Y._tableDimensions, -Ar.DEFAULT_WIDTH));
  }
  // prettier-ignore
  static toggleEachCell(Y, re, oe, ue) {
    oe.forEach((fe, he) => {
      Ar.setDisplay(fe, Y, re, he);
    }), Y || setTimeout(() => AddNewColumnEvents.toggleColor(!1, oe, ue));
  }
  static changeTableWidths(Y, re, oe) {
    const ue = re ? Ar.DEFAULT_WIDTH : -Ar.DEFAULT_WIDTH;
    TableElement.changeStaticWidthTotal(Y._tableDimensions, ue), StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(Y, oe);
  }
  // prettier-ignore
  static toggle(Y, re) {
    const {
      _addColumnCellsElementsRef: oe,
      _tableBodyElementRef: ue,
      _frameComponents: { displayAddNewColumn: fe, cellColors: he }
    } = Y;
    if (!fe || !ue)
      return;
    const _e = MaximumColumns.canAddMore(Y);
    _e !== Ar.isDisplayed(oe) && (_e ? (Ar.toggleEachCell(_e, ue, oe, he), Ar.changeTableWidths(Y, _e, re)) : (Ar.changeTableWidths(Y, _e, re), Ar.toggleEachCell(_e, ue, oe, he)));
  }
};
_AddNewColumnElement.ADD_COLUMN_CELL_CLASS = "add-column-cell";
_AddNewColumnElement.DEFAULT_WIDTH = 25;
_AddNewColumnElement.DEFAULT_WIDTH_PX = `${_AddNewColumnElement.DEFAULT_WIDTH}px`;
let AddNewColumnElement = _AddNewColumnElement;
class ExtractElements {
  static textCellsArrFromRow(Y) {
    return Array.from(Y.children).filter(
      (re) => (re.tagName === CellElement.HEADER_TAG || re.tagName === CellElement.DATA_TAG) && !re.classList.contains(AddNewColumnElement.ADD_COLUMN_CELL_CLASS) && !re.classList.contains(IndexColumn.INDEX_CELL_CLASS)
    );
  }
  static textRowsArrFromTBody(Y, re, oe = 0) {
    return Array.from(Y.children).slice(oe, re.length);
  }
  static getRightColumnSiblingCell(Y) {
    var re;
    return (re = Y.nextSibling) == null ? void 0 : re.nextSibling;
  }
}
class ColumnSettingsFrameBorderUtils {
  // prettier-ignore
  static toggleFrameBorder(Y, re, oe, ue) {
    if (Y.length > 0) {
      const { subjectBorderStyle: fe, siblingBorderStyle: he } = ColumnSettingsBorderUtils.getColumnBorderStyles(oe), _e = Y[0], ve = re[0];
      ColumnSettingsBorderUtils.isBorderDisplayed(ve, he) ? ColumnSettingsBorderUtils.unsetSubjectBorder(Y, re, oe, 0) : _e.style[fe] === ColumnSettingsBorderUtils.UNSET_PX && ResetColumnStyles.applyDefaultStyles(Y, ue);
    }
  }
  // prettier-ignore
  static updateFrameColumns(Y, re, oe, ue) {
    const fe = re || oe;
    if (!fe)
      return;
    const {
      _defaultColumnsSettings: he,
      _addColumnCellsElementsRef: _e,
      _frameComponents: { displayAddNewColumn: ve, displayIndexColumn: xe }
    } = Y;
    if (!ue && ve && ColumnSettingsFrameBorderUtils.toggleFrameBorder(
      _e,
      fe.elements,
      "left",
      he
    ), !oe && xe) {
      const Ee = ExtractElements.textRowsArrFromTBody(Y._tableBodyElementRef, Y.data, 0).map((Se) => Se.children[0]);
      ColumnSettingsFrameBorderUtils.toggleFrameBorder(Ee, fe.elements, "right", he);
    }
  }
}
const _ColumnSettingsBorderUtils = class Sr {
  // REF-23
  static overwriteSideBorderIfSiblingsHaveSettings(Y, re) {
    const { left: oe, right: ue } = Y.bordersOverwrittenBySiblings;
    re.forEach((fe) => {
      oe && (fe.style.borderLeftWidth = Sr.UNSET_PX), ue && (fe.style.borderRightWidth = Sr.UNSET_PX);
    });
  }
  // prettier-ignore
  static getColumnBorderStyles(Y) {
    return { subjectBorderStyle: Y === "left" ? "borderLeftWidth" : "borderRightWidth", siblingBorderStyle: Y === "left" ? "borderRightWidth" : "borderLeftWidth" };
  }
  static isBorderDisplayed(Y, re) {
    return !!(Y.style[re] && Y.style[re] !== Sr.UNSET_PX);
  }
  // REF-23
  // prettier-ignore
  static unsetSubjectBorder(Y, re, oe, ue, fe) {
    const { subjectBorderStyle: he, siblingBorderStyle: _e } = Sr.getColumnBorderStyles(oe), ve = Y[ue], xe = re[ue];
    Sr.isBorderDisplayed(ve, he) && Sr.isBorderDisplayed(xe, _e) && (fe && (fe[oe] = !0), Y.forEach((Ee) => {
      ElementStyle.setStyle(Ee, he, Sr.UNSET_PX);
    }));
  }
  // prettier-ignore
  static unsetColumnBorder(Y, re, oe) {
    Sr.unsetSubjectBorder(
      Y.elements,
      re.elements,
      oe,
      0,
      Y.bordersOverwrittenBySiblings
    );
  }
  // if current column and sibling have custom setting styles
  // REF-23
  // prettier-ignore
  static unsetBorders(Y, re, oe) {
    Y && (Y.settings.stylePrecedence ? (re && Sr.unsetColumnBorder(re, Y, "right"), oe && (oe.settings.stylePrecedence ? Sr.unsetColumnBorder(Y, oe, "right") : oe.settings.stylePrecedence || Sr.unsetColumnBorder(oe, Y, "left"))) : (oe && oe.settings.stylePrecedence && Sr.unsetColumnBorder(Y, oe, "right"), re && re.settings.stylePrecedence && Sr.unsetColumnBorder(Y, re, "left")));
  }
  static resetBorderOverwritingState(Y) {
    Y && (Y.bordersOverwrittenBySiblings.left = !1, Y.bordersOverwrittenBySiblings.right = !1);
  }
  // prettier-ignore
  static resetIfBorderOverwritten(Y, re, oe, ue) {
    oe != null && oe.bordersOverwrittenBySiblings[ue] && (oe.bordersOverwrittenBySiblings[ue] = !1, ColumnSettingsStyleUtils.changeStyleFunc(Y, re, Y._columnsDetails[re].settings));
  }
  // REF-23
  static updateSiblingColumns(Y, re) {
    const { _columnsDetails: oe } = Y, ue = oe[re], fe = oe[re - 1], he = oe[re + 1];
    Sr.resetIfBorderOverwritten(Y, re + 1, he, "left"), Sr.resetIfBorderOverwritten(Y, re - 1, fe, "right"), Sr.resetBorderOverwritingState(ue), Sr.unsetBorders(ue, fe, he), ColumnSettingsFrameBorderUtils.updateFrameColumns(Y, ue, fe, he);
  }
};
_ColumnSettingsBorderUtils.UNSET_PX = "0px";
let ColumnSettingsBorderUtils = _ColumnSettingsBorderUtils;
const _CellElement = class Br {
  // prettier-ignore
  static setDefaultCellStyle(Y, re, oe) {
    Object.assign(Y.style, re, oe);
  }
  static createBaseCell(Y) {
    const re = document.createElement(Y ? Br.HEADER_TAG : Br.DATA_TAG);
    return Y && re.classList.add(Br.HEADER_CELL_CLASS), re.classList.add(Br.CELL_CLASS), re;
  }
  // prettier-ignore
  static createDataCell(Y, re, oe, ue) {
    const fe = Br.createBaseCell(Y);
    return Y && ue && fe.classList.add(GenericElementUtils.NOT_SELECTABLE_CLASS), fe.setAttribute("role", "textbox"), Br.setDefaultCellStyle(fe, re, oe), fe;
  }
  static setCursor(Y, re) {
    Y.style.cursor = re ? "text" : "default";
  }
  static prepContentEditable(Y, re, oe = !1) {
    CaretDisplayFix.isIssueBrowser() ? (re && CaretDisplayFix.setTabIndex(Y), CaretDisplayFix.removeContentEditable(Y)) : Y.contentEditable = String(re), oe || Br.setCursor(Y, re);
  }
  // prettier-ignore
  // this is used for cases where element could be the cell element or the text inside a select/label cell
  static getCellElement(Y) {
    return Y.classList.contains(CellTextElement.CELL_TEXT_DIV_CLASS) || Y.classList.contains(DateCellInputElement.DATE_INPUT_CONTAINER_CLASS) ? Y.parentElement : Y.classList.contains(DateCellInputElement.DATE_INPUT_CLASS) || Y.classList.contains(DateCellCalendarIconElement.CALENDAR_ICON_CONTAINER_CLASS) ? Y.parentElement.parentElement : Y;
  }
  static getTextElement(Y) {
    var re, oe;
    return (re = Y.children[0]) != null && re.classList.contains(CellTextElement.CELL_TEXT_DIV_CLASS) ? Y.children[0] : (oe = Y.children[1]) != null && oe.classList.contains(CellTextElement.CELL_TEXT_DIV_CLASS) ? Y.children[1] : CheckboxCellElement.isCheckboxCell(Y) ? Y.children[0] : Y;
  }
  // The reason why .trim() is used is because innerText/textContent property does not just return the cell text, but
  // additionally the new line characters (\n) which represent <br> elements within the cell that make it difficult
  // to compare cell text to other strings or use them for other programmatic purposes.
  // CAUTION-1 - The returned string should not be used to set text on other cells as .trim() removes \n chars for
  // <br> tags which are used to set the pointer position.
  static getText(Y) {
    const re = CheckboxCellElement.getValue(Y);
    return re !== void 0 ? re : Y.innerText.trim();
  }
  // this is used for case where element could be cell element that contains a text div element,
  // hence we need to set the text into the correct container
  // CAUTION-1 - be careful that the text does not come from above method
  static setText(Y, re) {
    if (!CheckboxCellElement.setValue(Y, re)) {
      const oe = Br.getTextElement(Y);
      oe.innerText = re;
    }
  }
  // set text is optional as some elements may only need to toggle the BR padding
  // prettier-ignore
  static setNewText(Y, re, oe, ue, fe, he = !0) {
    he && Br.setText(re, oe), ue ? setTimeout(() => CaretDisplayFix.toggleCellTextBRPadding(Y, re, fe)) : CaretDisplayFix.toggleCellTextBRPadding(Y, re, fe);
  }
  // REF-36
  static setColumnWidth(Y, re, oe, ue) {
    if (!Y._tableElementRef)
      return;
    const fe = oe?.widths || ue?.widths;
    if (fe != null && fe.staticWidth)
      ColumnSettingsWidthUtils.updateColumnWidth(Y, re, fe, !0);
    else if (fe != null && fe.initialWidth) {
      const he = ColumnSettingsWidthUtils.getSettingsWidthNumber(Y._tableElementRef, fe, !1);
      re.style.width = `${he.number}px`;
    } else
      re.style.width = `${Y._tableDimensions.newColumnWidth}px`;
  }
  // prettier-ignore
  static createCellElement(Y, re, oe, ue) {
    var fe, he, _e;
    const { _defaultColumnsSettings: { cellStyle: ve, headerStyles: xe }, _columnsDetails: Ee } = Y, Se = Ee[oe], Te = (_e = (he = (fe = Y._defaultColumnsSettings.columnDropdown) == null ? void 0 : fe.displaySettings) == null ? void 0 : he.openMethod) == null ? void 0 : _e.cellClick, Ce = Br.createDataCell(
      ue,
      ve,
      ue ? xe?.default : {},
      Te
    ), { settings: Ie } = Se;
    ColumnSettingsStyleUtils.applySettingsStyleOnCell(Ie, Ce, ue), ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(Se, [Ce]);
    const Ne = ue ? !Te && Ie.isHeaderTextEditable : Ie.isCellTextEditable;
    return Br.prepContentEditable(Ce, !!Ne, Te), ue && Br.setColumnWidth(Y, Ce, Ie, Y._defaultColumnsSettings), Br.setNewText(Y, Ce, re, !0, !1), Ce;
  }
};
_CellElement.CELL_CLASS = "cell";
_CellElement.HEADER_CELL_CLASS = "header-cell";
_CellElement.HEADER_TAG = "TH";
_CellElement.DATA_TAG = "TD";
let CellElement = _CellElement;
const _FilterViaWebWorkers = class Na {
  // prettier-ignore
  static processOtherColumnsIfPresent(Y, re, oe, ue) {
    FilterInternalUtils.ACTIVE_WORKERS -= 1, oe.length > 1 && ue.length > 0 ? Na.execute(Y, re, oe.slice(1), ue) : FilterInternalUtils.ACTIVE_WORKERS === 0 && Y();
  }
  // cannot use a direct link to a webworker file as parent project may not allow the component to access it
  // const worker = new Worker(new URL('./worker.js', import.meta.url))
  // using a string literal instead, ref:
  // https://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string
  static createWorkerBlobURL() {
    const Y = new Blob([Na.CODE], { type: "application/javascript" });
    return URL.createObjectURL(Y);
  }
  static hideRows(Y, re, oe, ue) {
    const { colCells: fe } = oe[0], { matchingIndexes: he, notMatchingIndexes: _e } = ue.data;
    _e.forEach((ve) => {
      fe[ve].parentElement.classList.add(FilterInternalUtils.HIDDEN_ROW_CLASS);
    }), Na.processOtherColumnsIfPresent(Y, re, oe, he);
  }
  static toggleRows(Y, re, oe, ue) {
    const fe = [], { colCells: he } = oe[0];
    ue.data.forEach((_e, ve) => {
      const xe = he[ve].parentElement;
      _e ? (xe.classList.remove(FilterInternalUtils.HIDDEN_ROW_CLASS), fe.push(ve)) : xe.classList.add(FilterInternalUtils.HIDDEN_ROW_CLASS);
    }), Na.processOtherColumnsIfPresent(Y, re, oe, fe);
  }
  // prettier-ignore
  static execute(Y, re, oe, ue) {
    const fe = new Worker(re);
    FilterInternalUtils.ACTIVE_WORKERS += 1, fe.onmessage = ue ? Na.hideRows.bind(this, Y, re, oe) : Na.toggleRows.bind(this, Y, re, oe);
    const he = oe[0];
    fe.postMessage({
      chunk: he.colCells.map((_e) => CellElement.getText(_e)),
      filterText: he.filterText,
      isCaseSensitive: he.isCaseSensitive,
      indexArray: ue
    });
  }
};
_FilterViaWebWorkers.TRAVERSE_CHUNK = `
    const result = chunk.map((text) => (isCaseSensitive ? text : text.toLocaleLowerCase()).includes(filterText));
    self.postMessage(result);
  `;
_FilterViaWebWorkers.TRAVERSE_MATCHING_INDEXES = `
    const matchingIndexes = [];
    const notMatchingIndexes = [];
    indexArray.forEach((index) => {
      const text = chunk[index];
      const isMatching = (isCaseSensitive ? text : text.toLocaleLowerCase()).includes(filterText);
      if (isMatching) {
        matchingIndexes.push(index);
      } else {
        notMatchingIndexes.push(index);
      }
    });
    self.postMessage({matchingIndexes, notMatchingIndexes});
  `;
_FilterViaWebWorkers.CODE = `
    self.onmessage = function (event) {
      const {chunk, indexArray, filterText, isCaseSensitive} = event.data;
      if (indexArray) {
        ${_FilterViaWebWorkers.TRAVERSE_MATCHING_INDEXES}
      } else {
        ${_FilterViaWebWorkers.TRAVERSE_CHUNK}
      }
    };
  `;
let FilterViaWebWorkers = _FilterViaWebWorkers;
class FilterViaTimeouts {
  static processOtherColumnsIfPresent(Y, re, oe) {
    FilterInternalUtils.ACTIVE_WORKERS -= 1, re.length > 1 && oe.length > 0 ? FilterViaTimeouts.processOtherColumns(Y, re.slice(1), oe) : FilterInternalUtils.ACTIVE_WORKERS === 0 && Y();
  }
  static toggleRow(Y, re, oe, ue) {
    const fe = CellElement.getText(Y), he = (re.isCaseSensitive ? fe : fe.toLocaleLowerCase()).includes(re.filterText), _e = Y.parentElement;
    he ? (_e.classList.remove(FilterInternalUtils.HIDDEN_ROW_CLASS), oe.push(ue)) : _e.classList.add(FilterInternalUtils.HIDDEN_ROW_CLASS);
  }
  static processOtherColumns(Y, re, oe) {
    setTimeout(() => {
      FilterInternalUtils.ACTIVE_WORKERS += 1;
      const ue = [], fe = re[0];
      oe.forEach((he) => {
        const _e = fe.chunk[he];
        FilterViaTimeouts.toggleRow(_e, fe, ue, he);
      }), FilterViaTimeouts.processOtherColumnsIfPresent(Y, re, ue);
    });
  }
  static execute(Y, re) {
    FilterInternalUtils.ACTIVE_WORKERS += 1, setTimeout(() => {
      const oe = [], ue = re[0];
      ue.chunk.forEach((fe, he) => {
        FilterViaTimeouts.toggleRow(fe, ue, oe, he);
      }), FilterViaTimeouts.processOtherColumnsIfPresent(Y, re, oe);
    });
  }
}
const _FilterInternalUtils = class ga {
  static finishFiltering(Y) {
    Y.pagination && (PageButtonContainerElement.repopulateButtons(Y), PaginationUtils.displayRowsForDifferentButton(Y, 1));
  }
  static getFilterFunc(Y) {
    const re = ga.finishFiltering.bind(this, Y);
    return window.Worker ? FilterViaWebWorkers.execute.bind(this, re, FilterViaWebWorkers.createWorkerBlobURL()) : FilterViaTimeouts.execute.bind(this, re);
  }
  static generateDefaultHeaderName(Y, re) {
    var oe, ue, fe;
    return re && ((oe = Y[0]) != null && oe.find((he) => he === re)) ? re : ((ue = Y[0]) == null ? void 0 : ue[0]) !== void 0 ? String((fe = Y[0]) == null ? void 0 : fe[0]) : "";
  }
  static addConfig(Y, re) {
    var oe;
    const { placeholderTemplate: ue, defaultColumnHeaderName: fe } = re, he = {
      isCaseSensitive: !1,
      placeholderTemplate: ue,
      defaultColumnHeaderName: fe || ga.generateDefaultHeaderName(Y.data)
    };
    return (oe = Y._visiblityInternal).filters ?? (oe.filters = []), Y._visiblityInternal.filters.push(he), he;
  }
  // colElements are used to identify active column (not using name as columns can have same names)
  static assignElements(Y, re) {
    var oe;
    const { data: ue, _columnsDetails: fe } = Y;
    if (ue.length !== 0)
      if (re.defaultColumnHeaderName) {
        const he = ue[0].findIndex((_e) => _e === re.defaultColumnHeaderName);
        re.elements = fe[he === -1 ? 0 : he].elements, delete re.defaultColumnHeaderName;
      } else
        re.elements && !((oe = Y.shadowRoot) != null && oe.contains(re.elements[0])) && (re.elements = fe[0].elements);
  }
  // prettier-ignore
  static resetInput(Y, re) {
    const { _visiblityInternal: { filters: oe } } = Y;
    if (ga.assignElements(Y, re), !re.elements || !oe)
      return;
    const ue = CellElement.getText(re.elements[0]);
    re.lastRegisteredHeaderName = ue, FilterInputElement.setPlaceholder(re.inputElement, ue, re.placeholderTemplate), FilterInputEvents.setEvents(Y, re, oe);
  }
  static unsetFilter(Y) {
    Y.value !== "" && (Y.value = "", Y.dispatchEvent(new Event("input")));
  }
  static unsetAllFilters(Y) {
    var re, oe;
    let ue = !1;
    const { data: fe, _visiblityInternal: he, _tableBodyElementRef: _e } = Y;
    return fe[0] && fe[0].length !== 0 && _e && ((re = he.filters) == null || re.forEach((ve) => {
      ve.inputElement.value !== "" && (ve.inputElement.value = "", ue = !0);
    }), ue && ((oe = he.filters) == null || oe[0].inputElement.dispatchEvent(new Event("input")))), ue;
  }
  // prettier-ignore
  static resetAllInputs(Y) {
    const { data: re, _visiblityInternal: { filters: oe } } = Y;
    if (!re[0] || re[0].length === 0 || !oe)
      return FilterInputEvents.unsetEvents(oe);
    oe.forEach((ue) => ga.resetInput(Y, ue)), ga.unsetAllFilters(Y);
  }
  static completeReset(Y) {
    const re = Y._visiblityInternal.filters;
    re && (Array.isArray(Y.filter) ? Y.filter.forEach((oe, ue) => {
      re[ue].defaultColumnHeaderName = oe.defaultColumnHeaderName;
    }) : typeof Y.filter == "object" && (re[0].defaultColumnHeaderName = Y.filter.defaultColumnHeaderName), ga.resetAllInputs(Y));
  }
  static isContainerRequired(Y, re) {
    let oe = !1;
    if (Array.isArray(Y))
      oe = !!Y.find((ue) => {
        const fe = (ue.position || FilterElements.DEFAULT_INPUT_POSITION).indexOf(re);
        return fe !== void 0 && fe >= 0;
      });
    else if (typeof Y == "object") {
      const ue = (Y.position || FilterElements.DEFAULT_INPUT_POSITION).indexOf(re);
      oe = ue !== void 0 && ue >= 0;
    } else if (typeof Y == "boolean") {
      const ue = FilterElements.DEFAULT_INPUT_POSITION.indexOf(re);
      oe = ue !== void 0 && ue >= 0;
    }
    return oe;
  }
  static extractUnfilteredRows(Y, re) {
    return Array.from(Y.children).slice(0, re).filter((oe) => !oe.classList.contains(ga.HIDDEN_ROW_CLASS));
  }
  // prettier-ignore
  static wasHeaderChanged(Y, re, oe, ue) {
    const fe = Y[oe].elements, he = re.find((_e) => fe === _e.elements);
    return he && (he.lastRegisteredHeaderName !== CellElement.getText(fe[0]) || ue);
  }
};
_FilterInternalUtils.ACTIVE_WORKERS = 0;
_FilterInternalUtils.CHUNK_SIZE = 2;
_FilterInternalUtils.HIDDEN_ROW_CLASS = "filter-hidden-row";
let FilterInternalUtils = _FilterInternalUtils;
class FileImportInputElement {
  // always created as the user may want to trigger the importCSV method without the CSV buttons and need this to work
  static create(Y) {
    const re = document.createElement("input");
    return re.type = "file", re.hidden = !0, setTimeout(() => {
      var oe;
      (oe = Y._tableElementRef) == null || oe.appendChild(re);
    }), re;
  }
}
class FilesUtils {
  static processStyles(Y) {
    const re = { default: {}, hover: { backgroundColor: "#f0f0f0" }, click: { backgroundColor: "#e4e4e4" } };
    return Y && (Object.assign(re.default, Y.default), Object.assign(re.hover, Y.hover), Object.assign(re.click, Y.click)), re;
  }
  static createDefault(Y) {
    return { inputElementRef: FileImportInputElement.create(Y) };
  }
}
FilesUtils.DEFAULT_BUTTON_POSITION = "bottom-left";
const _OuterContainerElements = class mr {
  // REF-38
  static getColumnContentContainer(Y) {
    return Y.children[0].children[0];
  }
  static setContainerHeightBasedOnMiddleColumn(Y) {
    if (Y.getBoundingClientRect().height === 0) {
      const re = mr.getColumnContentContainer(Y.children[1]);
      Y.style.height = `${re.getBoundingClientRect().height}px`;
    }
  }
  static setHeightsWhenOnlyMiddleColumns(Y) {
    setTimeout(() => {
      Y.top && mr.setContainerHeightBasedOnMiddleColumn(Y.top), Y.bottom && mr.setContainerHeightBasedOnMiddleColumn(Y.bottom);
    });
  }
  // REF-38
  static appendChildToColumn(Y, re) {
    mr.getColumnContentContainer(Y).appendChild(re);
  }
  // REF-38
  static addToContainer(Y, re, oe) {
    const ue = Y.indexOf("top") >= 0 ? re.top : re.bottom;
    Y.indexOf("left") >= 0 ? mr.appendChildToColumn(ue.children[0], oe) : Y.indexOf("center") >= 0 ? mr.appendChildToColumn(ue.children[1], oe) : mr.appendChildToColumn(ue.children[2], oe);
  }
  // REF-38
  // need an inner divs in order for the inserted components 'width' properties to work as CONTAINER_CLASS has width: 0px
  static createContainerColumn(Y, re) {
    const oe = document.createElement("div");
    oe.classList.add(mr.COLUMN_CLASS, Y);
    const ue = document.createElement("div");
    ue.classList.add(mr.COLUMN_INNER_CLASS);
    const fe = document.createElement("div");
    return fe.classList.add(mr.COLUMN_CONTENT_CLASS), ue.appendChild(fe), oe.appendChild(ue), oe.style.gridColumn = re, oe;
  }
  static createContainerElement() {
    const Y = document.createElement("div");
    Y.classList.add(mr.CONTAINER_CLASS);
    const re = mr.createContainerColumn(mr.LEFT_COLUMN_CLASS, "1");
    Y.appendChild(re);
    const oe = mr.createContainerColumn(mr.CENTER_COLUMN_CLASS, "2");
    Y.appendChild(oe);
    const ue = mr.createContainerColumn(mr.RIGHT_COLUMN_CLASS, "3");
    return Y.appendChild(ue), Y;
  }
  static addContainer(Y, re, oe) {
    const ue = mr.createContainerElement();
    ue.id = re, oe != null && oe.style.fontFamily && (ue.style.fontFamily = oe.style.fontFamily);
    const fe = re === mr.TOP_CONTAINER_ID ? "beforebegin" : "afterend";
    return Y.insertAdjacentElement(fe, ue), ue;
  }
  // can be reused for other positional components
  static isRequired(Y, re) {
    return !!Object.keys(Y).find((oe) => {
      const { position: ue } = Y[oe];
      return ue.indexOf(re) >= 0;
    });
  }
  static isContainerRequired(Y, re) {
    var oe;
    let ue = !1;
    return Y.pagination && (ue = mr.isRequired(Y._pagination.positions, re)), !ue && (oe = Y.files) != null && oe.buttons && (ue = !!Y.files.buttons.find((fe) => (fe.position || FilesUtils.DEFAULT_BUTTON_POSITION).indexOf(re) >= 0)), !ue && Y.filter && (ue = FilterInternalUtils.isContainerRequired(Y.filter, re)), ue;
  }
  // we create a top and a bottom container only if they are required
  static create(Y) {
    var re;
    const oe = {}, ue = mr.isContainerRequired(Y, "top"), fe = mr.isContainerRequired(Y, "bottom"), { _tableElementRef: he } = Y, _e = ((re = Y._overflow) == null ? void 0 : re.overflowContainer) || he;
    if (!_e)
      return oe;
    if (ue) {
      const ve = mr.addContainer(_e, mr.TOP_CONTAINER_ID, he);
      oe.top = ve;
    }
    if (fe) {
      const ve = mr.addContainer(_e, mr.BOTTOM_CONTAINER_ID, he);
      oe.bottom = ve;
    }
    return mr.setHeightsWhenOnlyMiddleColumns(oe), oe;
  }
};
_OuterContainerElements.ABSOULUTE_FULL_TABLE_CLASS = "absolute-container";
_OuterContainerElements.CONTAINER_CLASS = "outer-container";
_OuterContainerElements.TOP_CONTAINER_ID = "outer-top-container";
_OuterContainerElements.BOTTOM_CONTAINER_ID = "outer-bottom-container";
_OuterContainerElements.COLUMN_CLASS = "outer-container-column";
_OuterContainerElements.COLUMN_INNER_CLASS = "outer-container-column-inner";
_OuterContainerElements.COLUMN_CONTENT_CLASS = "outer-container-column-content";
_OuterContainerElements.LEFT_COLUMN_CLASS = "outer-container-left-column";
_OuterContainerElements.CENTER_COLUMN_CLASS = "outer-container-center-column";
_OuterContainerElements.RIGHT_COLUMN_CLASS = "outer-container-right-column";
let OuterContainerElements = _OuterContainerElements;
const _OuterDropdownButtonUtils = class wi {
  static processStatefulStyle(Y) {
    Y.hover ?? (Y.hover = Y.default), Y.click ?? (Y.click = Y.hover);
  }
  static processAndApplyDefaultStyle(Y, re) {
    re && (wi.processStatefulStyle(re), Object.assign(Y.style, re.default));
  }
  static createArrow(Y, re) {
    const oe = document.createElement("div");
    oe.classList.add(wi.ARROW_CONTAINER_CLASS, GenericElementUtils.NOT_SELECTABLE_CLASS), Y && oe.classList.add(...Y);
    const ue = SVGIconUtils.createSVGElement(ARROW_DOWN_SVG_STRING);
    return ue.classList.add(wi.ARROW_ICON_CLASS), re && ue.classList.add(...re), oe.appendChild(ue), oe;
  }
};
_OuterDropdownButtonUtils.ARROW_CONTAINER_CLASS = "outer-dropdown-button-arrow-container";
_OuterDropdownButtonUtils.ARROW_ICON_CLASS = "outer-dropdown-button-arrow-icon";
let OuterDropdownButtonUtils = _OuterDropdownButtonUtils;
class RowsPerPageSelectButtonEvents {
  static mouseDown(Y, re) {
    var oe, ue, fe, he, _e, ve;
    Object.assign(re.style, (ue = (oe = Y.styles.rowsPerPageSelect) == null ? void 0 : oe.button) == null ? void 0 : ue.click);
    const xe = re.children[0];
    Object.assign(xe.style, (he = (fe = Y.styles.rowsPerPageSelect) == null ? void 0 : fe.buttonText) == null ? void 0 : he.click);
    const Ee = re.children[1];
    Object.assign(Ee.style, (ve = (_e = Y.styles.rowsPerPageSelect) == null ? void 0 : _e.buttonArrow) == null ? void 0 : ve.click);
  }
  static mouseLeave(Y, re) {
    RowsPerPageSelectButtonElement.applyStylesOnElements(re, "default", Y.rowsPerPageSelect);
  }
  static mouseEnter(Y, re) {
    RowsPerPageSelectButtonElement.applyStylesOnElements(re, "hover", Y.rowsPerPageSelect);
  }
  static setEvents(Y, re) {
    re.onmouseenter = RowsPerPageSelectButtonEvents.mouseEnter.bind(this, Y._pagination.styles, re), re.onmouseleave = RowsPerPageSelectButtonEvents.mouseLeave.bind(this, Y._pagination.styles, re), re.onmousedown = RowsPerPageSelectButtonEvents.mouseDown.bind(this, Y._pagination, re), re.onmouseup = RowsPerPageSelectButtonEvents.mouseEnter.bind(this, Y._pagination.styles, re);
  }
}
const _RowsPerPageSelectButtonElement = class Va {
  // prettier-ignore
  static applyStylesOnElements(Y, re, oe) {
    if (!oe)
      return;
    const { button: ue, buttonText: fe, buttonArrow: he } = oe;
    if (ue && StatefulCSSEvents.apply(ue, ue[re], Y), fe) {
      const _e = Y.children[0];
      StatefulCSSEvents.apply(fe, fe[re], _e);
    }
    if (he) {
      const _e = Y.children[1];
      StatefulCSSEvents.apply(he, he[re], _e);
    }
  }
  static createButtonArrow(Y) {
    var re;
    const oe = OuterDropdownButtonUtils.createArrow();
    return OuterDropdownButtonUtils.processAndApplyDefaultStyle(oe, (re = Y.styles.rowsPerPageSelect) == null ? void 0 : re.buttonArrow), oe;
  }
  static updateButtonText(Y, re) {
    const oe = Y.children[0];
    oe.innerText = re;
  }
  static createButtonText(Y) {
    var re;
    const { isAllRowsOptionSelected: oe, rowsPerPageOptionsItemText: ue, rowsPerPage: fe, styles: he } = Y, _e = document.createElement("div");
    return _e.id = Va.TEXT_ID, _e.classList.add(GenericElementUtils.NOT_SELECTABLE_CLASS), OuterDropdownButtonUtils.processAndApplyDefaultStyle(_e, (re = he.rowsPerPageSelect) == null ? void 0 : re.buttonText), _e.innerText = oe ? ue[0] : String(fe), _e;
  }
  static createOptionsButton(Y) {
    var re;
    const oe = document.createElement("div");
    return oe.id = Va.BUTTON_ID, OuterDropdownButtonUtils.processAndApplyDefaultStyle(oe, (re = Y.styles.rowsPerPageSelect) == null ? void 0 : re.button), oe;
  }
  static create(Y) {
    const re = Va.createOptionsButton(Y._pagination);
    return re.appendChild(Va.createButtonText(Y._pagination)), re.appendChild(Va.createButtonArrow(Y._pagination)), setTimeout(() => RowsPerPageSelectButtonEvents.setEvents(Y, re)), re;
  }
};
_RowsPerPageSelectButtonElement.BUTTON_ID = "rows-per-page-select-button";
_RowsPerPageSelectButtonElement.TEXT_ID = "rows-per-page-select-button-text";
let RowsPerPageSelectButtonElement = _RowsPerPageSelectButtonElement;
class RowsPerPageDropdown {
  static getLeftPropertyToCenterDropdown(Y, re) {
    return `${Y.offsetLeft + Y.offsetWidth / 2 - re / 2}px`;
  }
  static display(Y, re, oe) {
    const { dropdownWidth: ue } = re._pagination, { element: fe } = oe;
    fe.style.left = RowsPerPageDropdown.getLeftPropertyToCenterDropdown(Y, ue), OuterDropdownSimpleUtils.display(Y, re, oe);
  }
  static setWidth(Y, re) {
    const oe = re.rowsPerPageOptionsItemText.reduce((ue, fe) => isNaN(Number(fe)) ? ue : Math.max(ue, fe.length), 1) * 8;
    re.dropdownWidth = re.dropdownWidth + oe, Y.style.width = `${re.dropdownWidth}px`;
  }
  static create(Y, re) {
    const oe = OuterDropdownSimpleUtils.hide.bind(this, Y._activeOverlayElements), ue = RowsPerPageDropdown.display.bind(this, re), fe = OuterDropdownElement.create(Y, re, "bottom-center", {}, [], oe, ue);
    return RowsPerPageDropdownItem.populate(Y, fe.element, re), RowsPerPageDropdown.setWidth(fe.element, Y._pagination), fe;
  }
}
const _RowsPerPageSelectElement = class ni {
  static createText(Y) {
    var re;
    const oe = document.createElement("div");
    return oe.id = ni.TEXT_ID, oe.style.marginRight = "8px", Object.assign(oe.style, (re = Y.styles.rowsPerPageSelect) == null ? void 0 : re.prefixText), oe.innerText = Y.rowsPerPageSelect.prefixText, oe;
  }
  static createContainer(Y) {
    var re;
    const oe = document.createElement("div");
    return oe.id = ni.ID, oe.classList.add(PaginationElements.PAGINATION_TEXT_COMPONENT_CLASS), oe.style.order = String(Y.positions.rowsPerPageSelect.order), Object.assign(oe.style, (re = Y.styles.rowsPerPageSelect) == null ? void 0 : re.container), oe;
  }
  // prettier-ignore
  static create(Y, re) {
    const oe = ni.createContainer(Y._pagination);
    oe.appendChild(ni.createText(Y._pagination));
    const ue = RowsPerPageSelectButtonElement.create(Y), fe = RowsPerPageDropdown.create(Y, ue);
    return oe.appendChild(ue), oe.appendChild(fe.element), OuterContainerElements.addToContainer(
      Y._pagination.positions.rowsPerPageSelect.position,
      re,
      oe
    ), oe;
  }
};
_RowsPerPageSelectElement.ID = "pagination-number-of-rows-select";
_RowsPerPageSelectElement.TEXT_ID = "pagination-number-of-rows-select-text";
let RowsPerPageSelectElement = _RowsPerPageSelectElement;
class PaginationElements {
  static create(Y, re) {
    Y._pagination.buttonContainer = PageButtonContainerElement.create(Y), PageButtonContainerElement.addInitialElements(Y, re), Y._pagination.rowsPerPageOptionsItemText && RowsPerPageSelectElement.create(Y, re), Y._pagination.displayNumberOfVisibleRows && (Y._pagination.numberOfVisibleRowsElement = NumberOfVisibleRowsElement.create(Y, re));
  }
}
PaginationElements.PAGINATION_TEXT_COMPONENT_CLASS = "pagination-text-component";
const _NumberOfVisibleRowsElement = class si {
  static updateForRelativeRowNumber(Y, re) {
    const { activePageNumber: oe, rowsPerPage: ue, numberOfVisibleRowsElement: fe } = Y, he = oe * ue, _e = re < 1 ? 0 : Math.max(he - ue + 1, 1), ve = Math.min(re, he);
    fe.innerText = `${_e}-${ve} of ${re}`;
  }
  static updateForAllRows(Y, re) {
    Y.innerText = `${Math.min(re, 1)}-${re} of ${re}`;
  }
  static update(Y) {
    var re, oe;
    const { _pagination: ue, data: fe, dataStartsAtHeader: he } = Y, { numberOfVisibleRowsElement: _e, isAllRowsOptionSelected: ve } = ue;
    if (!_e)
      return;
    const xe = ((oe = (re = Y._pagination) == null ? void 0 : re.asyncStartData) == null ? void 0 : oe.totalDataRows) || Math.max(he ? fe.length : fe.length - 1, 0);
    ve ? si.updateForAllRows(_e, xe) : si.updateForRelativeRowNumber(Y._pagination, xe);
  }
  static create(Y, re) {
    const oe = document.createElement("div");
    oe.id = si.ID, oe.classList.add(PaginationElements.PAGINATION_TEXT_COMPONENT_CLASS);
    const { styles: ue, positions: fe } = Y._pagination;
    return oe.style.order = String(fe.numberOfVisibleRows.order), Object.assign(oe.style, ue.numberOfVisibleRows), OuterContainerElements.addToContainer(fe.numberOfVisibleRows.position, re, oe), setTimeout(() => si.update(Y)), oe;
  }
};
_NumberOfVisibleRowsElement.ID = "pagination-number-of-visible-rows";
let NumberOfVisibleRowsElement = _NumberOfVisibleRowsElement;
class PageNumberButtonEvents {
  // REF-30
  static markClick(Y) {
    Y.clickedPageNumberButton = !0, setTimeout(() => Y.clickedPageNumberButton = !1);
  }
  static buttonMouseUp(Y, re) {
    PageNumberButtonEvents.markClick(this._pagination);
    const oe = re.target, { pageButtons: ue } = this._pagination.styles;
    this._pagination.activePageNumber === Y || PaginationUtils.getAndApplyDataOnButtonClick(this, Y), PageButtonStyle.mouseEnter(oe, ue, !1);
  }
  static setEvents(Y, re, oe) {
    oe.onmouseup = PageNumberButtonEvents.buttonMouseUp.bind(Y, re);
  }
}
class PageNumberButtonElement {
  static create(Y, re) {
    const oe = PageButtonElement.create(Y._pagination.styles.pageButtons, !1);
    return oe.innerHTML = String(re), setTimeout(() => PageNumberButtonEvents.setEvents(Y, re, oe)), oe;
  }
}
class PaginationUpdatePageButtons {
  static removeLastNumberButton(Y, re) {
    re[re.length - 1].remove();
    const oe = re[0], ue = Number(oe.innerText);
    if (ue > 1) {
      const fe = PageNumberButtonElement.create(Y, ue - 1);
      oe.insertAdjacentElement("beforebegin", fe);
    }
  }
  static updateOnRowRemove(Y) {
    const re = PaginationUtils.getPageNumberButtons(Y._pagination), oe = re[re.length - 1];
    Number(oe.innerText) > PaginationUtils.getLastPossiblePageNumber(Y) ? re.length > 1 && PaginationUpdatePageButtons.removeLastNumberButton(Y, re) : Y.data.length < (Y.dataStartsAtHeader ? 1 : 2) && PageButtonElement.setDisabled(Y._pagination);
  }
  static addNewNumberButtonAtEndIfNeeded(Y, re) {
    const oe = re[re.length - 1], ue = PaginationUtils.getLastPossiblePageNumber(Y, !0);
    if (Number(oe.innerText) < ue) {
      const fe = PageNumberButtonElement.create(Y, ue);
      oe.insertAdjacentElement("afterend", fe);
    }
  }
  static updateOnRowInsert(Y) {
    const re = Y.dataStartsAtHeader ? 0 : 1;
    if (Y.data.length === re)
      PageButtonElement.unsetDisabled(Y._pagination);
    else {
      const oe = PaginationUtils.getPageNumberButtons(Y._pagination);
      oe.length < Y._pagination.maxNumberOfVisiblePageButtons && PaginationUpdatePageButtons.addNewNumberButtonAtEndIfNeeded(Y, oe);
    }
  }
  // prettier-ignore
  static shiftLeftwards(Y, re, oe) {
    const { activePageNumber: ue } = Y._pagination, fe = re[0], he = Number(fe.innerText);
    let _e = ue <= re.length / 2 ? he - 1 : oe - ue, ve = he;
    _e > re.length && (_e = re.length, ve = re.length + 1);
    for (let xe = _e - 1; xe >= 0; xe -= 1) {
      const Ee = PageNumberButtonElement.create(Y, ve - xe - 1);
      fe.insertAdjacentElement("beforebegin", Ee);
    }
    re.slice(re.length - _e).forEach((xe) => xe.remove());
  }
  // prettier-ignore
  static shiftRightwards(Y, re, oe, ue) {
    const { activePageNumber: fe } = Y._pagination, he = PaginationUtils.getLastPossiblePageNumber(Y);
    let _e = fe > he - re.length / 2 ? he - oe : fe - ue, ve = oe;
    _e > re.length && (_e = re.length, ve = fe - re.length);
    const xe = re[re.length - 1];
    for (let Ee = _e - 1; Ee >= 0; Ee -= 1) {
      const Se = PageNumberButtonElement.create(Y, Ee + ve + 1);
      xe.insertAdjacentElement("afterend", Se);
    }
    re.slice(0, _e).forEach((Ee) => Ee.remove());
  }
  static updateOnNewActive(Y) {
    const re = PaginationUtils.getPageNumberButtons(Y._pagination), { activePageNumber: oe, maxNumberOfVisiblePageButtons: ue } = Y._pagination;
    if (re.length < ue)
      return;
    const fe = Number(re[re.length - 1].innerText), he = Math.floor(fe - re.length / 2) + 1;
    if (oe > he)
      PaginationUpdatePageButtons.shiftRightwards(Y, re, fe, he);
    else {
      const _e = Math.ceil(fe - re.length / 2);
      oe < _e && PaginationUpdatePageButtons.shiftLeftwards(Y, re, _e);
    }
  }
}
const _LoadingElement = class Vr {
  static createSpinner(Y) {
    const re = document.createElement("span");
    return re.className = "loading-spinner", Object.assign(re.style, Y), re;
  }
  static applyTableStyles(Y, re, oe) {
    Y.forEach((ue) => {
      re[ue] && (oe.style[ue] = re[ue]);
    });
  }
  static removeTableStyles(Y, re) {
    Y.forEach((oe) => {
      delete re.style[oe];
    });
  }
  static processCustom(Y, re) {
    return Y.style.display === "none" && (Y.style.display = "block"), Object.assign(Y.style, re?.container), Y;
  }
  // prettier-ignore
  static createContainer(Y, re) {
    const oe = document.createElement("div");
    return re && Vr.applyTableStyles(
      ["width", "minWidth", "maxHeight", "height", "minHeight", "maxHeight", "border", "borderColor", "borderWidth"],
      re,
      oe
    ), Object.assign(oe.style, Y?.container), oe;
  }
  static createNew(Y, re) {
    const oe = Vr.createContainer(Y, re);
    oe.classList.add(Vr.DEFAULT_LOADING_CONTAINER_CLASS);
    const ue = Vr.createSpinner(Y?.spinner);
    return oe.appendChild(ue), oe;
  }
  static processInitial(Y) {
    const { loadingStyles: re, tableStyle: oe } = Y, ue = Y.children[0];
    return ue ? Vr.processCustom(ue, re) : Vr.createNew(re, oe);
  }
  static addInitial(Y) {
    var re;
    Y._activeOverlayElements.loading = Vr.processInitial(Y), (re = Y.shadowRoot) == null || re.appendChild(Y._activeOverlayElements.loading);
  }
  static update(Y, re, oe) {
    Y.classList.contains(Vr.DEFAULT_LOADING_CONTAINER_CLASS) && re && (Vr.removeTableStyles(
      ["width", "minWidth", "maxHeight", "height", "minHeight", "maxHeight", "border", "borderColor", "borderWidth"],
      Y
    ), Object.assign(Y.style, oe?.container)), oe != null && oe.loadingBackgroundColor && (Y.style.backgroundColor = oe?.loadingBackgroundColor);
  }
  static addActive(Y) {
    var re;
    const { loading: oe } = Y._activeOverlayElements;
    oe && (oe.classList.contains(OuterContainerElements.ABSOULUTE_FULL_TABLE_CLASS) || (oe.classList.add(OuterContainerElements.ABSOULUTE_FULL_TABLE_CLASS), Vr.update(oe, Y.tableStyle, Y.loadingStyles)), (re = Y._tableElementRef) == null || re.appendChild(oe));
  }
};
_LoadingElement.DEFAULT_LOADING_CONTAINER_CLASS = "default-loading-container";
let LoadingElement = _LoadingElement;
class ErrorElement {
  static create() {
    const Y = document.createElement("div");
    Y.id = "error-container", Y.classList.add(OuterContainerElements.ABSOULUTE_FULL_TABLE_CLASS);
    const re = document.createElement("div");
    return re.id = "error-text", re.innerHTML = "Error retrieving data", Y.appendChild(re), Y;
  }
  static display(Y) {
    const { error: re } = Y._activeOverlayElements;
    re && Y._tableElementRef && Y._tableElementRef.appendChild(re);
  }
  static remove(Y) {
    var re;
    (re = Y._activeOverlayElements.error) == null || re.remove();
  }
}
class PaginationAsyncUtils {
  static displayError(Y, re) {
    ErrorElement.display(re), console.error(Y), console.error("Error fetching page information");
  }
  // prettier-ignore
  static setNewElementText(Y, re, oe, ue, fe) {
    CellEvents.updateCell(
      Y,
      re,
      fe,
      ue,
      { element: oe, processText: !1, updateCellEvent: !1, updateTableEvent: !1 }
    ), ColumnTypesUtils.updateDataElements(Y, fe, ue, oe);
  }
  static insertData(Y, re, oe) {
    const ue = Y.dataStartsAtHeader ? 0 : 1, fe = (oe - 1) * 10 + ue;
    re.length > Y._pagination.rowsPerPage && (re = re.slice(0, Y._pagination.rowsPerPage)), fe + re.length > Y.data.length && (re = re.slice(0, re.length - (fe + re.length - Y.data.length))), re.forEach((he, _e) => {
      he.forEach((ve, xe) => {
        const Ee = fe + _e, Se = Y._columnsDetails[xe].elements[Ee];
        PaginationAsyncUtils.setNewElementText(Y, ve, Se, xe, Ee);
      });
    }), UpdateIndexColumnWidth.update(Y);
  }
  static async getAndApplyNewData(Y, re, oe, ue) {
    var fe;
    const he = ue || oe;
    Y._pagination.asyncGetId = he, ErrorElement.remove(Y), LoadingElement.addActive(Y), PageButtonElement.setActive(Y, oe);
    let _e = [[]];
    try {
      if (_e = await re.getPageData(oe, Y._pagination.rowsPerPage), Y._pagination.asyncGetId !== he)
        return;
    } catch (ve) {
      PaginationAsyncUtils.displayError(ve, Y);
    }
    PaginationAsyncUtils.insertData(Y, _e, oe), (fe = Y._activeOverlayElements.loading) == null || fe.remove(), PaginationUtils.displayRowsForDifferentButton(Y, oe);
  }
  static isAsyncPagination(Y) {
    return typeof Y == "object" && Y.async;
  }
  static removeLoadingOverlay(Y) {
    var re;
    PaginationAsyncUtils.isAsyncPagination(Y.pagination) && ((re = Y._activeOverlayElements.loading) == null || re.remove());
  }
  static preprocessTablePropertiesIfAsync(Y) {
    var re;
    PaginationAsyncUtils.isAsyncPagination(Y.pagination) && (Y.displayAddNewRow = !1, Y.displayAddNewColumn = !1, Y.rowDropdown.displaySettings.isAvailable = !1, Y.columnDropdown = { displaySettings: { isAvailable: !1 } }, Y.files ?? (Y.files = {}), Y.files.buttons = (re = Y.files.buttons) == null ? void 0 : re.filter((oe) => !oe.import), Y.files.dragAndDrop = !1);
  }
}
const _PaginationUtils = class gr {
  static getLastPossiblePageNumber(Y, re = !1) {
    const { _pagination: oe, dataStartsAtHeader: ue } = Y;
    if (oe.isAllRowsOptionSelected)
      return 1;
    const fe = PaginationInternalUtils.getTotalNumberOfRows(Y), he = ue ? fe + 1 : fe, _e = re ? he : he - 1;
    return Math.max(Math.ceil(_e / oe.rowsPerPage), 1);
  }
  static getPageNumberButtons(Y) {
    const { buttonContainer: re, numberOfActionButtons: oe } = Y, ue = Array.from(re.children), fe = oe / 2;
    return ue.slice(fe, ue.length - fe);
  }
  static hideRow(Y) {
    var re;
    ((re = Y.children[0]) == null ? void 0 : re.tagName) === CellElement.HEADER_TAG ? Y.classList.add(gr.HIDDEN_ROW_CLASS) : Y.style.display = "none";
  }
  static displayRow(Y, re) {
    Y.children[0].tagName === CellElement.HEADER_TAG ? Y.classList.remove(gr.HIDDEN_ROW_CLASS) : Y.style.display = "", re.push(Y);
  }
  // changes to the page that the row was moved to
  static updateOnRowMove(Y, re) {
    const { activePageNumber: oe } = Y._pagination;
    PaginationRowIndexes.getMaxVisibleRowIndex(Y) <= re ? gr.displayRowsForDifferentButton(Y, oe + 1) : re > 0 && Y._tableBodyElementRef && re < PaginationRowIndexes.getVisibleRowRealIndex(Y._tableBodyElementRef, Y._pagination, 0) && gr.displayRowsForDifferentButton(Y, oe - 1);
  }
  // prettier-ignore
  static getSiblingVisibleRow(Y, re) {
    const oe = Y?.[re];
    if (!(!oe || AddNewRowElement.isAddNewRowRow(oe)))
      return oe.classList.contains(FilterInternalUtils.HIDDEN_ROW_CLASS) ? gr.getSiblingVisibleRow(oe, re) : oe;
  }
  static updateRowsOnRemoval(Y, re) {
    const { visibleRows: oe, activePageNumber: ue } = Y._pagination;
    if (!(ue === 1 && re === -1))
      if (oe.splice(re, 1), oe.length > 0) {
        const fe = oe[oe.length - 1], he = gr.getSiblingVisibleRow(fe, "nextSibling");
        he && gr.displayRow(he, oe);
      } else
        ue > 1 && (gr.displayRowsForDifferentButton(Y, ue - 1), Y._visiblityInternal.filters && gr.getLastPossiblePageNumber(Y) !== ue - 1 && gr.displayRowsForDifferentButton(Y, ue));
  }
  static hideLastVisibleRow(Y) {
    const { visibleRows: re } = Y;
    if (re.length === 0)
      return;
    const oe = re[re.length - 1];
    gr.hideRow(oe), Y.visibleRows.splice(Y.visibleRows.length - 1, 1);
  }
  static updateRowsOnNewInsert(Y, re, oe) {
    const { rowsPerPage: ue, visibleRows: fe, activePageNumber: he, isAllRowsOptionSelected: _e } = Y._pagination;
    if (PaginationRowIndexes.getMaxVisibleRowIndex(Y) > re && Y._tableBodyElementRef) {
      fe.length === ue && !_e && gr.hideLastVisibleRow(Y._pagination);
      const ve = PaginationRowIndexes.getVisibleRowIndex(Y._tableBodyElementRef, Y._pagination, re);
      fe.splice(ve === -1 ? fe.length : ve, 0, oe);
    } else
      gr.hideRow(oe), setTimeout(() => {
        const ve = gr.getLastPossiblePageNumber(Y), xe = he + 1;
        ve < xe ? gr.setCorrectRowsAsVisible(Y, ve) : gr.displayRowsForDifferentButton(Y, xe);
      });
  }
  // for removal - we pass visible row index as when filter is set - we need to get it before the element is removed
  static updateOnRowChange(Y, re, oe) {
    const { dataStartsAtHeader: ue, _pagination: fe } = Y;
    !ue && re === 0 && PaginationInternalUtils.getTotalNumberOfRows(Y) === 0 || (PaginationVisibleButtonsUtils.unsetStateAndStyles(fe), oe ? (PaginationUpdatePageButtons.updateOnRowInsert(Y), gr.updateRowsOnNewInsert(Y, re, oe)) : (PaginationUpdatePageButtons.updateOnRowRemove(Y), gr.updateRowsOnRemoval(Y, re)), PaginationPageActionButtonUtils.toggleActionButtons(Y), PaginationVisibleButtonsUtils.setStateAndStyles(Y), setTimeout(() => NumberOfVisibleRowsElement.update(Y)));
  }
  static initialRowUpdates(Y, re, oe) {
    const ue = Y.dataStartsAtHeader ? re + 1 : re;
    ue > Y._pagination.rowsPerPage ? gr.hideRow(oe) : ue > 0 && Y._pagination.visibleRows.push(oe);
  }
  // REF-32
  static updateAddRowRow(Y) {
    if (Y._stripedRows && Y._tableBodyElementRef && Y._addRowCellElementRef) {
      const re = Y._addRowCellElementRef.parentElement, oe = Array.from(Y._tableBodyElementRef.children).length - 1, ue = gr.getLastPossiblePageNumber(Y) !== Y._pagination.activePageNumber;
      CustomRowProperties.updateRow(Y, re, oe, ue, oe);
    }
  }
  // prettier-ignore
  static setCorrectRowsAsVisible(Y, re) {
    const { _pagination: { rowsPerPage: oe, visibleRows: ue }, _tableBodyElementRef: fe, data: he, _visiblityInternal: _e } = Y, ve = _e != null && _e.filters ? FilterInternalUtils.extractUnfilteredRows(fe, he.length) : ExtractElements.textRowsArrFromTBody(fe, he);
    let xe = oe * (re - 1);
    Y.dataStartsAtHeader || (xe += 1), ve.slice(xe, xe + oe).forEach((Ee) => {
      gr.displayRow(Ee, ue);
    });
  }
  static hideAllRows(Y) {
    Y.visibleRows.forEach((re) => gr.hideRow(re)), Y.visibleRows = [];
  }
  static displayRowsForDifferentButton(Y, re) {
    gr.hideAllRows(Y._pagination), gr.setCorrectRowsAsVisible(Y, re), PageButtonElement.setActive(Y, re), NumberOfVisibleRowsElement.update(Y), Y._frameComponents.displayAddNewRow && gr.updateAddRowRow(Y);
  }
  static getFirstVisibleRow(Y) {
    return Y.find((re) => !re.classList.contains(FilterInternalUtils.HIDDEN_ROW_CLASS));
  }
  static async getAndApplyDataOnButtonClick(Y, re, oe) {
    Y._pagination.async ? PaginationAsyncUtils.getAndApplyNewData(Y, Y._pagination.async, re, oe) : gr.displayRowsForDifferentButton(Y, re);
  }
};
_PaginationUtils.HIDDEN_ROW_CLASS = "hidden-row";
let PaginationUtils = _PaginationUtils;
class PaginationPageActionButtonUtils {
  static setButtonAsEnabled(Y, re) {
    PageButtonStyle.setDefault(Y, re, !0), Y.classList.remove(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS);
  }
  static setButtonAsDisabled(Y, re) {
    PageButtonStyle.setDisabled(Y, re, !0), Y.classList.add(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS);
  }
  // prettier-ignore
  static toggleRightButtons(Y, re, oe) {
    const { activePageNumber: ue, styles: fe } = Y._pagination, he = PaginationUtils.getLastPossiblePageNumber(Y), _e = ue === he ? PaginationPageActionButtonUtils.setButtonAsDisabled : PaginationPageActionButtonUtils.setButtonAsEnabled;
    re.slice(re.length - oe).forEach((ve) => _e(ve, fe.pageButtons));
  }
  // prettier-ignore
  static toggleLeftButtons(Y, re, oe, ue) {
    const fe = re === 1 ? PaginationPageActionButtonUtils.setButtonAsDisabled : PaginationPageActionButtonUtils.setButtonAsEnabled;
    Y.slice(0, oe).forEach((he) => fe(he, ue.pageButtons));
  }
  static toggleActionButtons(Y) {
    const { activePageNumber: re, styles: oe, numberOfActionButtons: ue, buttonContainer: fe } = Y._pagination, he = Array.from(fe.children), _e = ue / 2;
    PaginationPageActionButtonUtils.toggleLeftButtons(he, re, _e, oe), PaginationPageActionButtonUtils.toggleRightButtons(Y, he, _e);
  }
}
class PageButtonEvents {
  static buttonMouseLeave(Y, re, oe) {
    const ue = oe.target;
    PageButtonStyle.mouseLeave(ue, Y, re);
  }
  static buttonMouseEnter(Y, re, oe) {
    const ue = oe.target;
    PageButtonStyle.mouseEnter(ue, Y, re);
  }
  static buttonMouseDown(Y, re, oe) {
    const ue = oe.target;
    PageButtonStyle.mouseDown(ue, Y, re);
  }
  static setEvents(Y, re, oe) {
    Y.onmousedown = PageButtonEvents.buttonMouseDown.bind(this, re, oe), Y.onmouseenter = PageButtonEvents.buttonMouseEnter.bind(this, re, oe), Y.onmouseleave = PageButtonEvents.buttonMouseLeave.bind(this, re, oe);
  }
}
const _PageButtonElement = class Pa {
  static unsetDisabled(Y) {
    const re = PaginationUtils.getPageNumberButtons(Y)[0], { pageButtons: oe } = Y.styles;
    PageButtonStyle.setActive(re, oe), re.classList.replace(Pa.DISABLED_PAGINATION_BUTTON_CLASS, oe.activeButtonClass);
  }
  static setDisabled(Y) {
    const { buttonContainer: re, styles: oe, numberOfActionButtons: ue } = Y, fe = Array.from(re.children);
    for (let _e = 0; _e < ue / 2; _e += 1)
      PageButtonStyle.setDisabled(fe[_e], oe.pageButtons, !0), PageButtonStyle.setDisabled(fe[fe.length - 1 - _e], oe.pageButtons, !0);
    const he = PaginationUtils.getPageNumberButtons(Y)[0];
    PageButtonStyle.setDisabled(he, oe.pageButtons, !1), he.classList.remove(oe.pageButtons.activeButtonClass), fe.forEach((_e) => {
      _e.classList.add(Pa.DISABLED_PAGINATION_BUTTON_CLASS);
    });
  }
  // prettier-ignore
  static programmaticMouseEnterTrigger(Y, re, oe) {
    const ue = Y[oe], { pageButtons: fe } = re.styles;
    ue && !ue.classList.contains(fe.activeButtonClass) && (PageButtonStyle.mouseEnter(ue, fe, !1), re.programaticallyHoveredPageNumberButton = ue, setTimeout(() => delete re.programaticallyHoveredPageNumberButton));
  }
  static setNewActive(Y, re) {
    const oe = PaginationUtils.getPageNumberButtons(Y), ue = Number(oe[oe.length - 1].innerText), fe = oe.length - (ue - re) - 1, he = oe[fe];
    return he.classList.add(Y.styles.pageButtons.activeButtonClass), { newActiveButton: he, numberButtons: oe };
  }
  static unsetPreviousActive(Y, re) {
    const oe = PaginationUtils.getPageNumberButtons(Y), ue = Number(oe[oe.length - 1].innerText), fe = oe.length - (ue - Y.activePageNumber) - 1, he = oe[fe], _e = oe.length - (ue - re) - 1;
    return he ? (he.classList.remove(Y.styles.pageButtons.activeButtonClass), { previousActiveButton: he, previousLocationOfNewIndex: _e }) : { previousLocationOfNewIndex: _e };
  }
  // prettier-ignore
  static setActive(Y, re) {
    const { _pagination: oe } = Y, { styles: { pageButtons: ue }, clickedPageNumberButton: fe } = oe, { previousActiveButton: he, previousLocationOfNewIndex: _e } = Pa.unsetPreviousActive(
      oe,
      re
    );
    PaginationVisibleButtonsUtils.unsetStateAndStyles(Y._pagination), oe.activePageNumber = re, PaginationUpdatePageButtons.updateOnNewActive(Y);
    const { newActiveButton: ve, numberButtons: xe } = Pa.setNewActive(oe, re);
    PageButtonStyle.setActive(ve, ue, he), PaginationPageActionButtonUtils.toggleActionButtons(Y), PaginationVisibleButtonsUtils.setStateAndStyles(Y), fe && Pa.programmaticMouseEnterTrigger(xe, oe, _e);
  }
  static create(Y, re) {
    const oe = document.createElement("div");
    return oe.classList.add(
      Pa.PAGINATION_BUTTON_CLASS,
      PaginationElements.PAGINATION_TEXT_COMPONENT_CLASS,
      GenericElementUtils.NOT_SELECTABLE_CLASS
    ), PageButtonStyle.setDefault(oe, Y, re), setTimeout(() => PageButtonEvents.setEvents(oe, Y, re)), oe;
  }
};
_PageButtonElement.PAGINATION_BUTTON_CLASS = "pagination-button";
_PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS = "pagination-button-disabled";
_PageButtonElement.ACTIVE_PAGINATION_BUTTON_CLASS = "pagination-button-active";
_PageButtonElement.PRECEDENCE_ACTIVE_PAGINATION_BUTTON_CLASS = "pagination-button-active-precedence";
let PageButtonElement = _PageButtonElement;
const _PaginationVisibleButtonsUtils = class vr {
  static getRightBorderWidthInStyleOverride(Y) {
    return Y.borderRightWidth ? Number.parseInt(Y.borderRightWidth) : Y.borderRight ? Number.parseInt(Y.borderRight.split(" ")[0]) : -1;
  }
  // if the last button is active page (no action buttons displayed) and it has precedence, the override right border
  // will not take place and it will either have no right border or active style right border:
  // this is problematic as the border difference will cause the entire container to have a different width
  // which will in turn cause the pagination components to shift when the last button is clicked,
  // to prevent this we add the border style that would have been overriden
  static setBorderPaddingForLastPrecedence(Y, re) {
    const oe = vr.getRightBorderWidthInStyleOverride(re);
    if (isNaN(oe) || oe === 0)
      return;
    const ue = Number.parseInt(getComputedStyle(Y).borderRightWidth);
    ue > 0 ? Y.style.borderRightWidth = `${ue + oe}px` : Y.style.borderRight = `${oe}px solid #fafafa01`;
  }
  static setStyle(Y, re, oe, ue) {
    if (!ue)
      return;
    const fe = new Set(Object.keys(ue)), he = Y.classList.contains(PageButtonElement.PRECEDENCE_ACTIVE_PAGINATION_BUTTON_CLASS);
    he && re.forEach((_e) => fe.delete(_e)), fe.forEach((_e) => {
      ElementStyle.setStyle(Y, _e, ue[_e]);
    }), oe && he && vr.setBorderPaddingForLastPrecedence(Y, ue);
  }
  // prettier-ignore
  static overrideOnMouseEvent(Y, re) {
    const { firstVisibleButtonOverride: oe, lastVisibleButtonOverride: ue } = re;
    Y.classList.contains(vr.FIRST_VISIBLE_CLASS) && vr.setStyle(
      Y,
      vr.FIRST_PRECEDENCE_VALUES,
      !1,
      oe
    ), Y.classList.contains(vr.LAST_VISIBLE_CLASS) && vr.setStyle(
      Y,
      vr.LAST_PRECEDENCE_VALUES,
      !0,
      ue
    );
  }
  // prettier-ignore
  static unsetStateAndStyles(Y) {
    const {
      styles: { pageButtons: { firstVisibleButtonOverride: re, lastVisibleButtonOverride: oe } },
      visibleEdgeButtons: ue
    } = Y;
    ue.length !== 0 && (re && ElementStyle.unsetStyle(ue[0], re), ue[0].classList.remove(vr.FIRST_VISIBLE_CLASS), oe && ElementStyle.unsetStyle(ue[1], oe), ue[1].classList.remove(vr.LAST_VISIBLE_CLASS), Y.visibleEdgeButtons = []);
  }
  // when the button display property is false - clientWidth is 0
  static isButtonVisible(Y) {
    return Y.clientWidth > 0 && Y.style.visibility !== "hidden";
  }
  // prettier-ignore
  static set(Y, re, oe) {
    const { styles: { pageButtons: { firstVisibleButtonOverride: ue, lastVisibleButtonOverride: fe } } } = oe, he = Y[re];
    if (!he)
      return;
    he.classList.contains(vr.FIRST_VISIBLE_CLASS) || (vr.setStyle(
      he,
      vr.FIRST_PRECEDENCE_VALUES,
      !1,
      ue
    ), he.classList.add(vr.FIRST_VISIBLE_CLASS));
    const _e = Y.findLastIndex(vr.isButtonVisible), ve = Y[_e];
    ve.classList.contains(vr.LAST_VISIBLE_CLASS) || (vr.setStyle(
      ve,
      vr.LAST_PRECEDENCE_VALUES,
      !0,
      fe
    ), ve.classList.add(vr.LAST_VISIBLE_CLASS)), oe.visibleEdgeButtons = [he, ve];
  }
  static setStateAndStyles(Y) {
    const { _pagination: re, displayAddNewRow: oe } = Y, ue = Array.from(re.buttonContainer.children), fe = ue.findIndex(vr.isButtonVisible);
    fe === -1 ? setTimeout(() => {
      const he = ue.findIndex(vr.isButtonVisible);
      vr.set(ue, he, re);
    }) : vr.set(ue, fe, re), oe || RowElement.toggleLastRowClass(Y);
  }
};
_PaginationVisibleButtonsUtils.FIRST_VISIBLE_CLASS = "pagination-first-visible-button";
_PaginationVisibleButtonsUtils.LAST_VISIBLE_CLASS = "pagination-last-visible-button";
_PaginationVisibleButtonsUtils.FIRST_PRECEDENCE_VALUES = ["borderLeft", "borderLeftWidth", "borderLeftColor"];
_PaginationVisibleButtonsUtils.LAST_PRECEDENCE_VALUES = ["borderRight", "borderRightWidth", "borderRightColor"];
let PaginationVisibleButtonsUtils = _PaginationVisibleButtonsUtils;
function buildIcon$1(le) {
  return `<?xml version="1.0" encoding="utf-8"?>
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: ${le}">
      <path d="M5.5 5L11.7929 11.2929C12.1834 11.6834 12.1834 12.3166 11.7929 12.7071L5.5 19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>`;
}
const PREVIOUS_PAGE_ICON_SVG_STRING = buildIcon$1("rotate(180deg)"), NEXT_PAGE_ICON_SVG_STRING = buildIcon$1("");
class PreviousPageButtonEvents {
  static buttonMouseUp(Y) {
    const { activePageNumber: re, styles: oe } = this._pagination;
    if (re === 1)
      return;
    PaginationUtils.getAndApplyDataOnButtonClick(this, re - 1);
    const ue = Y.target;
    PageButtonStyle.mouseEnter(ue, oe.pageButtons, !0);
  }
  static setEvents(Y, re) {
    re.onmouseup = PreviousPageButtonEvents.buttonMouseUp.bind(Y);
  }
}
class PreviousPageButtonElement {
  static populate(Y, re) {
    if (re)
      Y.innerHTML = String(re);
    else {
      const oe = SVGIconUtils.createSVGElement(PREVIOUS_PAGE_ICON_SVG_STRING);
      oe.classList.add("pagination-prev-next-button"), Y.appendChild(oe);
    }
  }
  static create(Y) {
    const { pageButtons: re } = Y._pagination.styles, oe = PageButtonElement.create(re, !0);
    return PreviousPageButtonElement.populate(oe, re.actionButtons.previousText), setTimeout(() => PreviousPageButtonEvents.setEvents(Y, oe)), oe;
  }
}
function buildIcon(le) {
  return `<?xml version="1.0" encoding="utf-8"?>
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: ${le}">
      <path d="M5.5 5L11.7929 11.2929C12.1834 11.6834 12.1834 12.3166 11.7929 12.7071L5.5 19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M13.5 5L19.7929 11.2929C20.1834 11.6834 20.1834 12.3166 19.7929 12.7071L13.5 19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>`;
}
const FIRST_PAGE_ICON_SVG_STRING = buildIcon("rotate(180deg)"), LAST_PAGE_ICON_SVG_STRING = buildIcon("");
class FirstPageButtonEvents {
  static buttonMouseUp(Y) {
    const re = Y.target;
    PageButtonStyle.mouseEnter(re, this._pagination.styles.pageButtons, !0), this._pagination.activePageNumber !== 1 && PaginationUtils.getAndApplyDataOnButtonClick(this, 1);
  }
  static setEvents(Y, re) {
    re.onmouseup = FirstPageButtonEvents.buttonMouseUp.bind(Y);
  }
}
class FirstPageButtonElement {
  static populate(Y, re) {
    if (re)
      Y.innerHTML = String(re);
    else {
      const oe = SVGIconUtils.createSVGElement(FIRST_PAGE_ICON_SVG_STRING);
      oe.classList.add("pagination-first-last-button"), Y.appendChild(oe);
    }
  }
  static create(Y) {
    const { pageButtons: re } = Y._pagination.styles, oe = PageButtonElement.create(re, !0);
    return FirstPageButtonElement.populate(oe, re.actionButtons.firstText), setTimeout(() => FirstPageButtonEvents.setEvents(Y, oe)), oe;
  }
}
class LastPageButtonEvents {
  static buttonMouseUp(Y) {
    const re = Y.target, { activePageNumber: oe, styles: ue } = this._pagination;
    PageButtonStyle.mouseEnter(re, ue.pageButtons, !0);
    const fe = PaginationUtils.getLastPossiblePageNumber(this);
    fe <= oe || PaginationUtils.getAndApplyDataOnButtonClick(this, fe);
  }
  static setEvents(Y, re) {
    re.onmouseup = LastPageButtonEvents.buttonMouseUp.bind(Y);
  }
}
class LastPageButtonElement {
  static populate(Y, re) {
    if (re)
      Y.innerHTML = String(re);
    else {
      const oe = SVGIconUtils.createSVGElement(LAST_PAGE_ICON_SVG_STRING);
      oe.classList.add("pagination-first-last-button"), Y.appendChild(oe);
    }
  }
  static create(Y) {
    const { pageButtons: re } = Y._pagination.styles, oe = PageButtonElement.create(re, !0);
    return LastPageButtonElement.populate(oe, re.actionButtons.lastText), setTimeout(() => LastPageButtonEvents.setEvents(Y, oe)), oe;
  }
}
class NextPageButtonEvents {
  static buttonMouseUp(Y) {
    const { activePageNumber: re, styles: oe } = this._pagination;
    if (PaginationUtils.getLastPossiblePageNumber(this) <= re)
      return;
    PaginationUtils.getAndApplyDataOnButtonClick(this, re + 1);
    const ue = Y.target;
    PageButtonStyle.mouseEnter(ue, oe.pageButtons, !0);
  }
  static setEvents(Y, re) {
    re.onmouseup = NextPageButtonEvents.buttonMouseUp.bind(Y);
  }
}
class NextPageButtonElement {
  static populate(Y, re) {
    if (re)
      Y.innerHTML = String(re);
    else {
      const oe = SVGIconUtils.createSVGElement(NEXT_PAGE_ICON_SVG_STRING);
      oe.classList.add("pagination-prev-next-button"), Y.appendChild(oe);
    }
  }
  static create(Y) {
    const { pageButtons: re } = Y._pagination.styles, oe = PageButtonElement.create(re, !0);
    return NextPageButtonElement.populate(oe, re.actionButtons.nextText), setTimeout(() => NextPageButtonEvents.setEvents(Y, oe)), oe;
  }
}
class PageButtonContainerEvents {
  // REF-31
  static containerMouseLeave(Y) {
    const { clickedPageNumberButton: re, programaticallyHoveredPageNumberButton: oe, styles: ue } = Y;
    re && oe && PageButtonStyle.mouseLeave(oe, ue.pageButtons, !1);
  }
  static setEvents(Y, re) {
    Y.onmouseleave = PageButtonContainerEvents.containerMouseLeave.bind(this, re);
  }
}
const _PageButtonContainerElement = class Mr {
  static shouldButtonsBeActive(Y) {
    const re = Y.dataStartsAtHeader ? 1 : 2;
    return Y.data.length >= re;
  }
  static setStyle(Y, re) {
    Mr.shouldButtonsBeActive(Y) ? PageButtonElement.setActive(Y, re ?? 1) : PageButtonElement.setDisabled(Y._pagination);
  }
  static addNumberButtons(Y) {
    const re = PaginationUtils.getLastPossiblePageNumber(Y), { maxNumberOfVisiblePageButtons: oe, buttonContainer: ue } = Y._pagination;
    for (let fe = 0; fe < Math.min(re, oe); fe += 1) {
      const he = PageNumberButtonElement.create(Y, fe + 1);
      ue.appendChild(he);
    }
  }
  static addButton(Y, re) {
    Y.buttonContainer.appendChild(re), Y.numberOfActionButtons += 1;
  }
  static addButtons(Y) {
    const { displayPrevNext: re, displayFirstLast: oe } = Y._pagination;
    oe && Mr.addButton(Y._pagination, FirstPageButtonElement.create(Y)), re && Mr.addButton(Y._pagination, PreviousPageButtonElement.create(Y)), Mr.addNumberButtons(Y), re && Mr.addButton(Y._pagination, NextPageButtonElement.create(Y)), oe && Mr.addButton(Y._pagination, LastPageButtonElement.create(Y));
  }
  static resetState(Y) {
    Y.activePageNumber = 1, Y.numberOfActionButtons = 0, Y.visibleEdgeButtons = [];
  }
  static repopulateButtons(Y) {
    Mr.resetState(Y._pagination), Y._pagination.buttonContainer.replaceChildren(), Mr.addButtons(Y), Mr.setStyle(Y);
  }
  static addInitialElements(Y, re) {
    Mr.repopulateButtons(Y), PaginationVisibleButtonsUtils.setStateAndStyles(Y);
    const { positions: oe, buttonContainer: ue } = Y._pagination;
    OuterContainerElements.addToContainer(oe.pageButtons.position, re, ue);
  }
  static create(Y) {
    const re = document.createElement("div");
    re.id = Mr.PAGINATION_BUTTON_CONTAINER_ID;
    const { styles: oe, positions: ue } = Y._pagination;
    return re.style.order = String(ue.pageButtons.order), Object.assign(re.style, oe.pageButtons.container), PageButtonContainerEvents.setEvents(re, Y._pagination), re;
  }
};
_PageButtonContainerElement.PAGINATION_BUTTON_CONTAINER_ID = "pagination-button-container";
let PageButtonContainerElement = _PageButtonContainerElement;
class InitialDataProcessing {
  static cleanupDataThatDidNotGetAdded(Y, re) {
    var oe;
    ((oe = Y[0]) == null ? void 0 : oe.length) - re.length > 0 && Y.forEach((ue) => ue.splice(re.length)), re.length === 0 ? Y.splice(0, Y.length) : Y.length > re[0].elements.length && Y.splice(re[0].elements.length);
  }
  static postProcess(Y, re) {
    setTimeout(() => InitialDataProcessing.cleanupDataThatDidNotGetAdded(Y, re));
  }
  static fillRow(Y, re) {
    const oe = new Array(re - Y.length).fill(EMPTY_STRING);
    Y.splice(Y.length, re - Y.length, ...oe);
  }
  static processRowDataByLength(Y, re) {
    re === 0 && Y.splice(0, Y.length), Y.forEach((oe) => {
      oe.length < re && InitialDataProcessing.fillRow(oe, re);
    });
  }
  static getMaxRowLength(Y) {
    return Y.reduce((re, oe) => Math.max(re, oe.length), 0);
  }
  static removeRowsExceedingLimit(Y, re) {
    re !== void 0 && re > 0 && Y.length > re && Y.splice(re, Y.length - 1);
  }
  static removeDuplicateHeaders(Y, re) {
    const oe = Y[0];
    oe.reduce((ue, fe, he) => (ue.has(fe) ? oe[he] = re || "" : ue.add(fe), ue), /* @__PURE__ */ new Set());
  }
  static preProcess(Y, re) {
    const { maxRows: oe, allowDuplicateHeaders: ue, _defaultColumnsSettings: fe } = Y;
    InitialDataProcessing.removeRowsExceedingLimit(re, oe);
    const he = InitialDataProcessing.getMaxRowLength(re);
    InitialDataProcessing.processRowDataByLength(re, he), !ue && re.length > 0 && InitialDataProcessing.removeDuplicateHeaders(re, fe.defaultText);
  }
}
class PaginationAsyncStartData {
  static fillTotalDataRows(Y, re) {
    var oe;
    const { totalDataRows: ue, data: fe, failed: he } = re;
    if (Y.data.length < ue || he) {
      const _e = Math.max(((oe = Y.data[0]) == null ? void 0 : oe.length) || 0, InitialDataProcessing.getMaxRowLength(fe)), ve = +!Y.dataStartsAtHeader, xe = new Array(ue - Y.data.length + ve).fill(
        new Array(_e).fill(EMPTY_STRING)
      ), Ee = Y.data.length;
      Y.data.splice(Y.data.length, 0, ...xe), xe.forEach((Se, Te) => {
        const Ce = InsertNewRow.insertNewRow(Y, Ee + Te, !1, Se);
        setTimeout(() => {
          UpdateCellsForRows.updateRowCells(Y, Ce, Ee + Te, CELL_UPDATE_TYPE.UPDATE, !1);
        });
      }), PageButtonContainerElement.repopulateButtons(Y);
    }
  }
  static populate(Y, re) {
    const { data: oe, totalDataRows: ue, failed: fe } = re;
    oe.length > 0 && ue > 0 && (Y.data.length > 0 || InitialDataProcessing.getMaxRowLength(oe) > 0) && (PaginationAsyncStartData.fillTotalDataRows(Y, re), fe || PaginationAsyncUtils.insertData(Y, oe, 1));
  }
  static async get(Y, re, oe) {
    const { async: ue, rowsPerPage: fe } = re;
    if (!ue)
      return;
    const { rowsPerPage: he } = oe, _e = typeof fe == "number" ? fe : he;
    try {
      const [ve, xe] = await Promise.all([ue.getTotalRows(), ue.getPageData(1, _e)]);
      return { totalDataRows: ve, data: xe };
    } catch (ve) {
      return setTimeout(() => PaginationAsyncUtils.displayError(ve, Y)), { totalDataRows: 0, data: [["", ""]], failed: !0 };
    }
  }
}
class FrameComponentsElements {
  // index and add column cells are added on row insertion
  // CAUTION-4
  static addFrameBodyElements(Y) {
    var re, oe;
    (oe = Y._tableBodyElementRef) == null || oe.appendChild((re = Y._addRowCellElementRef) == null ? void 0 : re.parentElement), ToggleAdditionElements.update(Y, !0, AddNewRowElement.toggle);
  }
}
const _SheetJSInternalUtils = class dn {
  // REF-17
  static async execFuncWithExtractorModule(Y) {
    const re = window.XLSX;
    re ? Y(re) : console.error(dn.MODULE_NOT_FOUND_ERROR);
  }
};
_SheetJSInternalUtils.MODULE_NOT_FOUND_ERROR = "xlsx module was not found";
let SheetJSInternalUtils = _SheetJSInternalUtils;
class UpdateAllTableData {
  static toggleAdditionalElements(Y) {
    FilterInternalUtils.completeReset(Y), ToggleAdditionElements.update(Y, !0, AddNewRowElement.toggle), setTimeout(() => {
      Y._pagination && Y._pagination.activePageNumber !== 1 && PaginationUtils.displayRowsForDifferentButton(Y, 1);
    });
  }
  static insertData(Y, re, oe) {
    InsertMatrix.insert(Y, re, oe, 0, !0), oe === 0 && RootCellElement.convertFromRootCell(Y);
  }
  static changeTableData(Y, re, oe, ue) {
    for (let fe = Y.data.length - 1; fe >= oe; fe -= 1)
      RemoveRow.remove(Y, fe);
    InitialDataProcessing.preProcess(Y, re), Y._isPopulatingTable = !0, ue ? (UpdateAllTableData.insertData(Y, re, oe), UpdateAllTableData.toggleAdditionalElements(Y), Y._isPopulatingTable = !0) : (setTimeout(() => {
      UpdateAllTableData.insertData(Y, re, oe);
    }), setTimeout(() => {
      UpdateAllTableData.toggleAdditionalElements(Y), Y._isPopulatingTable = !0;
    }, 6));
  }
  static update(Y, re, oe, ue = !1) {
    if (!Array.isArray(re))
      return;
    let fe = !1;
    Y._visiblityInternal.filters && (fe = FilterInternalUtils.unsetAllFilters(Y)), !ue && fe ? setTimeout(() => UpdateAllTableData.changeTableData(Y, re, oe, ue), 40) : UpdateAllTableData.changeTableData(Y, re, oe, ue);
  }
}
class CSVImport {
  static getPaddedArray(Y, re) {
    return Y.map((oe) => oe.concat(Array(re).fill("")).slice(0, re));
  }
  static splitRow(Y) {
    const re = /("[^"]*"|[^,]+)(,|$)/g, oe = [];
    return Y.replace(re, (ue, fe) => (oe.push(fe), "")), oe;
  }
  static parseDataFromRow(Y, re, oe) {
    const ue = CSVImport.splitRow(Y);
    return ue.length > 0 && (re.push(ue), ue.length > oe && (oe = ue.length)), oe;
  }
  // TO-DO validation and error handling
  static parseCSV(Y) {
    try {
      const re = Y.split(/\r\n|\n/), oe = [];
      let ue = 0;
      return re.forEach((fe) => {
        ue = CSVImport.parseDataFromRow(fe, oe, ue);
      }), CSVImport.getPaddedArray(oe, ue);
    } catch {
      return console.error("Incorrect format"), null;
    }
  }
  static getStartRowIndex(Y, re) {
    return re && typeof re.tableRowStartIndex == "number" ? re.tableRowStartIndex < 0 || re.tableRowStartIndex > Y ? Y : re.tableRowStartIndex : 0;
  }
  static processFile(Y, re, oe) {
    const ue = CSVImport.parseCSV(re);
    if (ue && oe && typeof oe.importRowStartIndex == "number" && ue.splice(0, oe.importRowStartIndex), !ue || ue.length === 0)
      return;
    const fe = CSVImport.getStartRowIndex(Y.data.length, oe);
    UpdateAllTableData.update(Y, ue, fe);
  }
  static import(Y, re, oe) {
    const ue = new FileReader();
    ue.readAsText(re), ue.onload = (fe) => {
      var he;
      return CSVImport.processFile(Y, (he = fe.target) == null ? void 0 : he.result, oe);
    };
  }
}
class SheetJSImport {
  static import(Y, re, oe) {
    const ue = new FileReader();
    ue.readAsBinaryString(re), ue.onload = (fe) => {
      var he;
      const _e = oe.read((he = fe.target) == null ? void 0 : he.result, { type: "binary" });
      _e.SheetNames.forEach((ve) => {
        const xe = oe.utils.sheet_to_csv(_e.Sheets[ve]);
        CSVImport.processFile(Y, xe);
      });
    };
  }
}
const ACCEPTED_FILE_FORMATS = ["csv", "xls", "xlsx", "ods", "txt"], DEFAULT_FILE_FORMATS = ["csv"];
class FileImportButtonEvents {
  static importFile(Y, re, oe, ue) {
    oe.find((fe) => re.name.endsWith(fe)) && (re.name.endsWith(".csv") ? CSVImport.import(Y, re, ue) : SheetJSInternalUtils.execFuncWithExtractorModule(SheetJSImport.import.bind(this, Y, re)));
  }
  static inputChange(Y, re, oe) {
    var ue;
    const fe = oe.target, he = (ue = fe.files) == null ? void 0 : ue[0];
    FileImportButtonEvents.importFile(Y, he, ACCEPTED_FILE_FORMATS, re), fe.value = "";
  }
  static getAcceptedFormats(Y) {
    return Y != null && Y.formats && Y.formats.length > 0 ? Y.formats : DEFAULT_FILE_FORMATS;
  }
  static triggerImportPrompt(Y, re) {
    const oe = Y._files.inputElementRef, ue = FileImportButtonEvents.getAcceptedFormats(re);
    oe.accept = ue.map((fe) => `.${fe}`).join(","), oe.onchange = FileImportButtonEvents.inputChange.bind(this, Y, re?.overwriteOptions), oe.click();
  }
  static setEvents(Y, re, oe) {
    re.onclick = FileImportButtonEvents.triggerImportPrompt.bind(this, Y, oe);
  }
}
class DragAndDropEvents {
  static async uploadFile(Y, re, oe) {
    var ue, fe, he;
    const _e = (fe = (ue = oe.dataTransfer) == null ? void 0 : ue.files) == null ? void 0 : fe[0], ve = typeof ((he = Y.files) == null ? void 0 : he.dragAndDrop) == "object" ? Y.files.dragAndDrop.overwriteOptions : void 0;
    FileImportButtonEvents.importFile(Y, _e, re, ve);
  }
  static toggleOverlayElement(Y, re) {
    Y.style.display = re ? "block" : "none";
  }
  static getAcceptedFileFormats(Y) {
    var re;
    if (typeof Y?.dragAndDrop == "object" && Y.dragAndDrop.formats)
      return Y.dragAndDrop.formats;
    const oe = (re = Y?.buttons) == null ? void 0 : re.filter((ue) => ue.import).map((ue) => typeof ue.import == "object" && ue.import.formats ? ue.import.formats : DEFAULT_FILE_FORMATS).flat(1);
    return oe && oe.length > 0 ? Array.from(new Set(oe)) : DEFAULT_FILE_FORMATS;
  }
  static setEvents(Y, re, oe) {
    const ue = DragAndDropEvents.getAcceptedFileFormats(Y.files);
    re.ondragenter = (fe) => {
      fe.preventDefault(), DragAndDropEvents.toggleOverlayElement(oe, !0);
    }, oe.ondragleave = (fe) => {
      fe.preventDefault(), DragAndDropEvents.toggleOverlayElement(oe, !1);
    }, oe.ondragover = (fe) => {
      fe.preventDefault();
    }, oe.ondrop = (fe) => {
      fe.preventDefault(), DragAndDropEvents.uploadFile(Y, ue, fe), DragAndDropEvents.toggleOverlayElement(oe, !1);
    };
  }
}
class DragAndDropElement {
  static createOverlayElement(Y) {
    const re = document.createElement("div");
    return re.id = "drag-and-drop-overlay", typeof Y.dragAndDrop == "object" && Object.assign(re.style, Y.dragAndDrop.overlayStyle), re;
  }
  static append(Y, re) {
    const oe = DragAndDropElement.createOverlayElement(Y.files);
    DragAndDropEvents.setEvents(Y, re, oe), re.appendChild(oe);
  }
  static isEnabled(Y) {
    var re;
    return Y?.dragAndDrop !== void 0 ? !!Y.dragAndDrop : !!((re = Y?.buttons) != null && re.find((oe) => oe.import));
  }
}
const _StickyPropsUtils = class hn {
  static process(Y) {
    var re;
    typeof Y.stickyHeader == "boolean" ? Y._stickyProps.header = Y.stickyHeader : (re = Y.overflow) != null && re.maxHeight && (Y._stickyProps.header = !0);
  }
  // REF-37
  // prettier-ignore
  static moveTopBorderToHeaderCells(Y) {
    const { _tableElementRef: re, _tableBodyElementRef: oe } = Y;
    !re || !oe || (oe.classList.add(hn.NO_OVERFLOW_STICKY_HEADER_BODY_CLASS), re.style.border && (oe.style.borderTop = re.style.border), re.style.borderColor && (oe.style.borderTopColor = re.style.borderColor), ElementStyle.moveStyles(
      re,
      oe,
      "borderTop",
      "borderTopColor",
      "borderTopWidth",
      "borderTopStyle"
    ), re.style.borderTop = "unset");
  }
};
_StickyPropsUtils.NO_OVERFLOW_STICKY_HEADER_BODY_CLASS = "no-overflow-sticky-header-body";
let StickyPropsUtils = _StickyPropsUtils;
class ColumnSizerSetWidth {
  static getWidthDelta(Y, re) {
    return Y < re.left ? re.left : Y > re.right ? re.right : Y;
  }
  static getNewColumnWidth(Y, re) {
    const { moveLimits: oe, mouseMoveOffset: ue, initialOffset: fe } = Y, he = ColumnSizerSetWidth.getWidthDelta(ue, oe) - fe;
    return Math.max(0, Number.parseFloat(re.style.width) + he);
  }
  static setColumnWidth(Y, re) {
    const oe = ColumnSizerSetWidth.getNewColumnWidth(Y, re);
    re.style.width = `${oe}px`;
  }
  // when the user moves the sizer to the start/end of a column in an attempt to completely crush the column,
  // the dom will not allow that and will leave enough space for the column to display its text,
  // the problem is that the widths will be set incorrectly and need to be corrected
  // prettier-ignore
  static correctWidths(Y, re, oe, ue) {
    if (re.offsetWidth !== Math.round(Number.parseFloat(re.style.width))) {
      const fe = `${re.offsetWidth}px`, he = `${ue - re.offsetWidth}px`;
      re.style.width = fe, oe.style.width = he, Y.wasAutoresized = !0, setTimeout(() => Y.wasAutoresized = !1);
    }
  }
  // prettier-ignore
  static setWidths(Y, re, oe, ue) {
    const fe = ColumnSizerSetWidth.getNewColumnWidth(Y, re), he = Math.max(0, ue - fe);
    re.style.width = `${fe}px`, oe.style.width = `${he}px`;
  }
  // prettier-ignore
  static setColumnsWidths(Y, re, oe) {
    const ue = Number.parseFloat(re.style.width), fe = Number.parseFloat(oe.style.width), he = ue + fe;
    ColumnSizerSetWidth.setWidths(Y, re, oe, he), fe > ue ? ColumnSizerSetWidth.correctWidths(Y, re, oe, he) : ColumnSizerSetWidth.correctWidths(Y, oe, re, he);
  }
  // left or right header in respect to the position of the sizer element
  // prettier-ignore
  static set(Y, re, oe, ue, fe) {
    fe && StaticTable.isStaticTableWidth(re, oe) ? ColumnSizerSetWidth.setColumnsWidths(Y, ue, fe) : ColumnSizerSetWidth.setColumnWidth(Y, ue), setTimeout(() => Y.fireColumnsUpdate());
  }
}
class ColumnSizerExtrinsicEvents {
  static moveMovableElement(Y, re, oe) {
    const { columnSizer: ue } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(Y.id, re);
    ue.movableElement.style.left = `${oe}px`;
  }
  // prettier-ignore
  static windowMouseMove(Y, re) {
    const { _activeOverlayElements: { selectedColumnSizer: oe }, _columnsDetails: ue } = Y;
    if (oe) {
      const { moveLimits: fe, element: he } = oe;
      oe.mouseMoveOffset += re, oe.mouseMoveOffset >= fe.left && oe.mouseMoveOffset <= fe.right && ColumnSizerExtrinsicEvents.moveMovableElement(he, ue, oe.mouseMoveOffset);
    }
  }
  // prettier-ignore
  static setWidth(Y, re, oe, ue, fe) {
    ColumnSizerElement.unsetTransitionTime(Y.element), ColumnSizerSetWidth.set(Y, re, oe, ue, fe);
  }
  // prettier-ignore
  static mouseUp(Y) {
    var re;
    const { _activeOverlayElements: oe, _columnsDetails: ue, _tableDimensions: fe, _tableElementRef: he } = Y, _e = oe.selectedColumnSizer, { columnSizer: ve, headerCell: xe, sizerNumber: Ee } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(
      _e.element.id,
      ue
    );
    ColumnSizerExtrinsicEvents.setWidth(
      _e,
      he,
      fe,
      xe,
      ColumnSizerGenericUtils.findNextResizableColumnHeader(ue, Ee)
    ), MovableColumnSizerElement.hide(ve.movableElement), UpdateRowElement.updateHeaderRowHeight((re = ve.element.parentElement) == null ? void 0 : re.parentElement);
  }
  static setSizerStyleToHoverNoAnimation(Y, re) {
    const { width: oe } = Y.styles.hover;
    ColumnSizerElement.setHoverStyle(Y, oe, !1, re), ColumnSizerElement.unsetBackgroundImage(Y.element);
  }
  static mouseUpNotOnSizer(Y) {
    const { element: re, styles: oe, movableElement: ue } = Y;
    ColumnSizerExtrinsicEvents.setSizerStyleToHoverNoAnimation(Y, ue.style.backgroundColor), setTimeout(() => {
      ColumnSizerElement.setTransitionTime(re), ColumnSizerElement.unsetElementsToDefault(re, oe.default.width, !1), ColumnSizerElement.hideWhenCellNotHovered(Y, !0);
    }), setTimeout(() => {
      ColumnSizerElement.setBackgroundImage(re, oe.default.backgroundImage), ColumnSizerElement.setBackgroundColor(re, SEMI_TRANSPARENT_COLOR);
    }, ColumnSizerElement.TRANSITION_TIME_ML);
  }
  // if the user clicks mouse up on the table first - this will not be activated as columnSizer selected will be removed
  // prettier-ignore
  static windowMouseUp(Y) {
    const { columnSizer: re } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(
      Y._activeOverlayElements.selectedColumnSizer.element.id,
      Y._columnsDetails
    );
    ColumnSizerExtrinsicEvents.mouseUp(Y), ColumnSizerExtrinsicEvents.mouseUpNotOnSizer(re), delete Y._activeOverlayElements.selectedColumnSizer;
  }
  static mouseUpOnSizer(Y) {
    ColumnSizerExtrinsicEvents.setSizerStyleToHoverNoAnimation(Y), Y.isMouseUpOnSizer = !0, setTimeout(() => {
      Y.isMouseUpOnSizer = !1, ColumnSizerElement.setTransitionTime(Y.element);
    });
  }
  // this method is used to get what exact element was clicked on as window events just returns the component as the target
  // prettier-ignore
  static tableMouseUp(Y, re) {
    const oe = Y._activeOverlayElements.selectedColumnSizer, { columnSizer: ue } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(
      oe.element.id,
      Y._columnsDetails
    );
    ColumnSizerExtrinsicEvents.mouseUp(Y), MovableColumnSizerElement.isMovableColumnSizer(re) && !oe.wasAutoresized ? ColumnSizerExtrinsicEvents.mouseUpOnSizer(ue) : ColumnSizerExtrinsicEvents.mouseUpNotOnSizer(ue), delete Y._activeOverlayElements.selectedColumnSizer;
  }
}
class TableEvents {
  // not using hoveredElements state as the targetElement will be the element clicked, hence need to use
  // activeOverlayElements.datePickerCell to get the cell of the date picker input
  static closeDatePicker(Y, re) {
    Y.datePickerCell && (Y.datePickerCell !== CellElement.getCellElement(re) && DateCellInputElement.toggle(Y.datePickerCell, !1), delete Y.datePickerCell);
  }
  // REF-44
  // text blur will not activate when the dropdown has been clicked and will not close if its scrollbar, padding
  // or delete category buttons are clicked. If the user clicks elsewhere on the table, the dropdown is closed
  // programmatically as follows
  // prettier-ignore
  static closeCellDropdown(Y, re) {
    const { _focusedElements: oe } = Y;
    oe.cellDropdown && !Dropdown.isPartOfDropdownElement(re) && !re.classList.contains(OptionColorButton.COLOR_BUTTON_CLASS) && oe.cell.element !== CellElement.getCellElement(re) && CellWithTextEvents.programmaticBlur(Y);
  }
  static onMouseDown(Y) {
    const re = Y.target;
    UserKeyEventsStateUtils.temporarilyIndicateEvent(this._userKeyEventsState, MOUSE_EVENT.DOWN), TableEvents.closeCellDropdown(this, re), TableEvents.closeDatePicker(this._activeOverlayElements, Y.target);
  }
  static onMouseUp(Y) {
    this._activeOverlayElements.selectedColumnSizer && ColumnSizerExtrinsicEvents.tableMouseUp(this, Y.target);
  }
}
class TableElement {
  static changeStaticWidthTotal(Y, re) {
    Y.staticWidth += re;
  }
  // prettier-ignore
  static setStaticWidthContentTotal(Y) {
    const { _frameComponents: { displayAddNewColumn: re, displayIndexColumn: oe }, _tableDimensions: ue } = Y;
    ue.staticWidth = ue.border.leftWidth + ue.border.rightWidth, re && (ue.staticWidth += AddNewColumnElement.DEFAULT_WIDTH), oe && (ue.staticWidth += IndexColumn.DEFAULT_WIDTH);
  }
  // prettier-ignore
  static addOverlayElements(Y, re, oe) {
    var ue;
    const fe = FullTableOverlayElement.create(Y);
    oe.fullTableOverlay = fe;
    const he = ((ue = Y._overflow) == null ? void 0 : ue.overflowContainer) || re;
    he.appendChild(fe), DragAndDropElement.isEnabled(Y.files) && DragAndDropElement.append(Y, he);
    const _e = ColumnDropdown.create(Y);
    if (re.appendChild(_e), oe.columnDropdown = _e, Y.rowDropdown.displaySettings.isAvailable) {
      const ve = RowDropdown.create(Y);
      re.appendChild(ve), oe.rowDropdown = ve;
    }
  }
  static addCells(Y) {
    MaximumColumns.canAddMore(Y) && (StaticTableWidthUtils.toggleWidthUsingMaxWidth(Y, !0), Y.data.map((re, oe) => InsertNewRow.insert(Y, oe, !1, re)), Y._pagination.asyncStartData && PaginationAsyncStartData.populate(Y, Y._pagination.asyncStartData), StaticTableWidthUtils.toggleWidthUsingMaxWidth(Y, !1));
  }
  static postProcessColumns(Y) {
    StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(Y, !0), InitialDataProcessing.postProcess(Y.data, Y._columnsDetails), setTimeout(() => {
      FireEvents.onColumnsUpdate(Y), InsertRemoveColumnSizer.cleanUpCustomColumnSizers(Y, Y._columnsDetails.length - 1);
    });
  }
  static populateBody(Y) {
    var re;
    (re = Y._tableBodyElementRef) == null || re.replaceChildren(), StaticTableWidthUtils.setTableWidth(Y), TableElement.addCells(Y), TableElement.postProcessColumns(Y), FrameComponentsElements.addFrameBodyElements(Y), Y._frameComponents.displayIndexColumn && UpdateIndexColumnWidth.update(Y), ToggleAdditionElements.update(Y, !0, AddNewColumnElement.toggle), CustomRowProperties.update(Y);
  }
  static createTableBody(Y) {
    const re = document.createElement("tbody");
    return Y && re.classList.add("sticky-header-body"), re;
  }
  static createTableElement(Y) {
    var re;
    const oe = document.createElement("table");
    oe.classList.add("table-controlled-width");
    const ue = StringDimensionUtils.removeAllDimensions(JSON.parse(JSON.stringify(Y.tableStyle)));
    return Object.assign(oe.style, ue), (re = oe.style).fontFamily || (re.fontFamily = "Inter, sans-serif, Avenir, Helvetica, Arial"), oe.onmousedown = TableEvents.onMouseDown.bind(Y), oe.onmouseup = TableEvents.onMouseUp.bind(Y), oe;
  }
  // CAUTION-4 - add row cell is created and ref assigned here - then it is added post render in addFrameBodyElements
  static createInfrastructureElements(Y) {
    return FrameComponentsColors.setEventColors(Y), Y._tableElementRef = TableElement.createTableElement(Y), Y._tableBodyElementRef = TableElement.createTableBody(Y._stickyProps.header), Y._addRowCellElementRef = AddNewRowElement.create(Y), Y._tableElementRef.appendChild(Y._tableBodyElementRef), Y._cellDropdownContainer = CellDropdown.createContainerElement(), Y._tableElementRef.appendChild(Y._cellDropdownContainer), !Y.overflow && Y._stickyProps.header && StickyPropsUtils.moveTopBorderToHeaderCells(Y), Y._tableDimensions.border = TableBorderDimensionsUtils.generateUsingElement(Y._tableElementRef), Y._tableElementRef;
  }
}
const _OverflowUtils = class Jr {
  static isOverflowElement(Y) {
    return Y?.id === Jr.ID;
  }
  // a simple way to not take the border into consideration when doing table width calculation, however if there are issues
  // feel free to investigate a better way
  static unsetBorderDimensions(Y, re) {
    re.number -= Y.border.leftWidth + Y.border.rightWidth, TableElement.changeStaticWidthTotal(Y, -Y.border.leftWidth), TableElement.changeStaticWidthTotal(Y, -Y.border.rightWidth), Y.border.leftWidth = 0, Y.border.rightWidth = 0, Y.border.topWidth = 0, Y.border.bottomWidth = 0;
  }
  static processNumberDimension(Y, re) {
    Jr.unsetBorderDimensions(Y, re), re.number -= Jr.SCROLLBAR_WIDTH;
  }
  // prettier-ignore
  static moveBorderToOverflowContainer(Y, re) {
    ElementStyle.moveStyles(
      re,
      Y,
      "borderRight",
      "borderLeft",
      "borderTop",
      "borderBottom",
      "borderRadius",
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ), re.style.border = "unset";
  }
  static adjustStyleForScrollbarWidth(Y) {
    (Browser.IS_SAFARI || Browser.IS_FIREFOX) && Y.maxHeight && !Y.maxWidth && (Y.overflowContainer.style.paddingRight = `${Jr.SCROLLBAR_WIDTH}px`);
  }
  static setDimensions(Y, { width: re, height: oe }) {
    re && (Y.style.overflowX = "auto", Y.style.maxWidth = `${re}px`), oe && (Y.style.overflowY = "auto", Y.style.maxHeight = `${oe}px`);
  }
  // prettier-ignore
  static getDimensions(Y, re) {
    const oe = StringDimensionUtils.generateNumberDimensionFromClientString(
      Y.parentElement,
      re,
      "maxWidth",
      !0
    );
    oe.number -= Y._tableDimensions.border.leftWidth + Y._tableDimensions.border.rightWidth, oe.isPercentage && (re.isWidthPercentage = !0);
    const ue = StringDimensionUtils.generateNumberDimensionFromClientString(
      Y.parentElement,
      re,
      "maxHeight",
      !1
    );
    return ue.number -= Y._tableDimensions.border.topWidth + Y._tableDimensions.border.bottomWidth, ue.isPercentage && (re.isHeightPercentage = !0), { width: oe.number, height: ue.number };
  }
  static applyDimensions(Y) {
    const { _overflow: re } = Y;
    if (!re)
      return;
    const oe = Jr.getDimensions(Y, re);
    Jr.setDimensions(re.overflowContainer, oe), Jr.adjustStyleForScrollbarWidth(re);
  }
  static setupContainer(Y, re) {
    const oe = document.createElement("div");
    Y._overflow = { overflowContainer: oe, ...Y.overflow }, oe.id = Jr.ID, Jr.moveBorderToOverflowContainer(oe, re), oe.appendChild(re);
  }
};
_OverflowUtils.ID = "overflow-container";
_OverflowUtils.SCROLLBAR_WIDTH = 15;
let OverflowUtils = _OverflowUtils;
class ElementVisibility {
  // prettier-ignore
  static getDetailsInWindow(Y, re, oe = !0) {
    const { topWidth: ue, leftWidth: fe } = oe ? re : { topWidth: 0, leftWidth: 0 }, he = Y.getBoundingClientRect(), _e = (Browser.IS_CHROMIUM ? he.top - ue : he.top) + window.scrollY, ve = (Browser.IS_CHROMIUM ? he.left - fe : he.left) + window.scrollX, xe = Y.offsetWidth, Ee = Y.offsetHeight, Se = document.body, Te = /* @__PURE__ */ new Set();
    _e < window.pageYOffset && Te.add(SIDE.TOP);
    const Ce = Se.clientWidth < Se.scrollWidth ? OverflowUtils.SCROLLBAR_WIDTH : 0;
    _e + Ee + ue > window.pageYOffset + window.innerHeight - Ce && Te.add(SIDE.BOTTOM), ve < window.pageXOffset && Te.add(SIDE.LEFT);
    const Ie = Se.clientHeight < Se.scrollHeight ? OverflowUtils.SCROLLBAR_WIDTH : 0;
    return ve + xe + fe > window.pageXOffset + window.innerWidth - Ie && Te.add(SIDE.RIGHT), Te.size > 0 ? { isFullyVisible: !1, blockingSides: Te } : { isFullyVisible: !0 };
  }
  // no real need to take care of multiple blockages for now
  static isVerticallyVisibleInsideParent(Y, re) {
    const oe = Y.parentElement || re, ue = oe.scrollTop, fe = ue + oe.clientHeight, he = Y.offsetTop, _e = he + Y.clientHeight;
    return he < ue ? { isFullyVisible: !1, blockingSides: /* @__PURE__ */ new Set([SIDE.TOP]) } : _e > fe ? { isFullyVisible: !1, blockingSides: /* @__PURE__ */ new Set([SIDE.BOTTOM]) } : { isFullyVisible: !0 };
  }
}
class OuterDropdownEvents {
  static windowOnMouseDown(Y) {
    Y._activeOverlayElements.outerContainerDropdown && Y._activeOverlayElements.outerContainerDropdown.hide();
  }
  static focusSiblingItem(Y, re, oe) {
    const ue = re?.[oe];
    if (ue)
      DropdownItemNavigation.focusSiblingItem(ue, Y, !0, !0);
    else if (oe === "nextSibling") {
      const fe = Y.children[0];
      fe && DropdownItemNavigation.focusSiblingItem(fe, Y, !0, !0);
    } else {
      const fe = Y.children[Y.children.length - 1];
      fe && DropdownItemNavigation.focusSiblingItem(fe, Y, !1, !0);
    }
  }
  // prettier-ignore
  static windowOnKeyDownNavigation(Y, re) {
    const oe = Y.getElementsByClassName(DropdownItem.ACTIVE_ITEM_CLASS)[0];
    re === KEYBOARD_KEY.TAB || re === KEYBOARD_KEY.ARROW_DOWN ? oe ? OuterDropdownEvents.focusSiblingItem(Y, oe, "nextSibling") : DropdownItemNavigation.focusSiblingItem(Y.children[0], Y, !0, !0) : re === KEYBOARD_KEY.ARROW_UP && (oe ? OuterDropdownEvents.focusSiblingItem(Y, oe, "previousSibling") : DropdownItemNavigation.focusSiblingItem(
      Y.children[Y.children.length - 1],
      Y,
      !1,
      !0
    ));
  }
  // the reason why we track window key events is because the table is not actually focused when it is displayed,
  // (unlike column dropdown which has an input), hence initially clicking tab does not focus the dropdown and
  // instead we need to focus it programmatically here. Once focused, the actual dropdown events can take over.
  // prettier-ignore
  static windowOnKeyDown(Y, re) {
    const { shadowRoot: oe, _activeOverlayElements: { outerContainerDropdown: ue } } = Y;
    if (!ue)
      return;
    re.preventDefault();
    const { element: fe, hide: he } = ue;
    re.key === KEYBOARD_KEY.ENTER || re.key === KEYBOARD_KEY.ESCAPE ? he() : oe != null && oe.activeElement || OuterDropdownEvents.windowOnKeyDownNavigation(fe, re.key);
  }
  static dropdownOnKeyDown(Y, re) {
    re.preventDefault(), re.key === KEYBOARD_KEY.ENTER ? re.target.dispatchEvent(new MouseEvent("mousedown")) : re.key === KEYBOARD_KEY.ESCAPE && Y.hide(), DropdownEvents.itemKeyNavigation(this.shadowRoot, Y.element, re);
  }
  static set(Y, re) {
    re.element.onkeydown = OuterDropdownEvents.dropdownOnKeyDown.bind(Y, re);
  }
}
const _OuterDropdownElement = class Ga {
  static hide(Y, re) {
    const oe = Y.outerContainerDropdown;
    oe && (Dropdown.hide(oe.element), oe.button.classList.contains(ToggleableElement.AUTO_STYLING_CLASS) && ToggleableElement.unsetActive(oe.button, re), delete Y.outerContainerDropdown, DropdownItemHighlightUtils.fadeCurrentlyHighlighted(Y));
  }
  static display(Y, re) {
    re.button.classList.contains(ToggleableElement.AUTO_STYLING_CLASS) && ToggleableElement.setActive(re.button, re.activeButtonStyle), Dropdown.display(re.element), Y._activeOverlayElements.outerContainerDropdown = re;
  }
  static displayReactToBottomVisibility(Y, re) {
    re.element.classList.remove(Ga.DROPUP_CLASS), Ga.display(Y, re);
    const oe = ElementVisibility.getDetailsInWindow(re.element, Y._tableDimensions.border, !1);
    !oe.isFullyVisible && oe.blockingSides.has(SIDE.BOTTOM) && re.element.classList.add(Ga.DROPUP_CLASS);
  }
  static setOrientation(Y, re) {
    re.endsWith("right") && (Y.style.right = "0px");
  }
  static createElement(Y) {
    const re = Dropdown.createBase();
    return re.style.width = "", re.classList.add("outer-container-dropdown"), Y && re.classList.add(...Y), re;
  }
  // prettier-ignore
  static create(Y, re, oe, ue, fe, he, _e) {
    const ve = Ga.createElement(fe), xe = { element: ve, hide: he, button: re, activeButtonStyle: ue };
    return Ga.setOrientation(ve, oe), OuterDropdownButtonEvents.set(Y, re, oe, xe, _e), OuterDropdownEvents.set(Y, xe), xe;
  }
};
_OuterDropdownElement.DROPUP_CLASS = "active-table-dropup";
let OuterDropdownElement = _OuterDropdownElement;
class OuterDropdownSimpleUtils {
  static hide(Y, re) {
    var oe;
    OuterDropdownElement.hide(Y, {});
    const ue = (oe = Y.outerContainerDropdown) == null ? void 0 : oe.element;
    if (ue) {
      const fe = re || Array.from(ue.children);
      OuterDropdownItem.unsetHoverColors(fe);
    }
  }
  static getDropdownTopPosition(Y) {
    return `${Y.offsetTop + Y.offsetHeight}px`;
  }
  // this is a custom display function used by dropdowns that do not populate items on display (export, rows per page)
  static display(Y, re, oe) {
    const { element: ue } = oe;
    ue.style.bottom = "", ue.style.top = OuterDropdownSimpleUtils.getDropdownTopPosition(Y), OuterDropdownElement.displayReactToBottomVisibility(re, oe);
  }
}
class RowsPerPageDropdownItemUtil {
  static updateRowsAndPaginationComponents(Y, re, oe) {
    RowsPerPageSelectButtonElement.updateButtonText(re, oe), PageButtonContainerElement.shouldButtonsBeActive(Y) && (PageButtonContainerElement.repopulateButtons(Y), PaginationUtils.getAndApplyDataOnButtonClick(Y, 1, oe));
  }
  static getNewRowsPerPage(Y, re) {
    const { _pagination: oe, data: ue, dataStartsAtHeader: fe } = Y;
    return oe.isAllRowsOptionSelected ? fe ? ue.length : ue.length - 1 : Number(re);
  }
  static setNewRowsPerPage(Y, re, oe) {
    Y._pagination.isAllRowsOptionSelected = oe.toLocaleLowerCase() === RowsPerPageDropdownItem.ALL_ITEM_TEXT, Y._pagination.rowsPerPage = RowsPerPageDropdownItemUtil.getNewRowsPerPage(Y, oe), RowsPerPageDropdownItemUtil.updateRowsAndPaginationComponents(Y, re, oe);
  }
}
class RowsPerPageDropdownItemEvents {
  static action(Y, re, oe, ue) {
    Y.rowsPerPage !== Number(ue) && RowsPerPageDropdownItemUtil.setNewRowsPerPage(oe, re, ue);
  }
  static setEvents(Y, re, oe) {
    const ue = RowsPerPageDropdownItemEvents.action.bind(this, Y._pagination, oe), fe = OuterDropdownSimpleUtils.hide;
    re.onmousedown = OuterDropdownItemEvents.itemMouseDownCommon.bind(Y, ue, fe);
  }
}
const _RowsPerPageDropdownItem = class pn {
  // lower case as it will be compared against user set text
  static populate(Y, re, oe) {
    Y._pagination.rowsPerPageOptionsItemText.forEach((fe) => {
      const he = { text: String(fe) }, _e = DropdownItem.addButtonItem(Y, re, he, pn.ITEM_CLASS);
      RowsPerPageDropdownItemEvents.setEvents(Y, _e, oe);
    });
    const ue = String(Y._pagination.rowsPerPage);
    OuterDropdownItem.setActive(Array.from(re.children), ue);
  }
};
_RowsPerPageDropdownItem.ITEM_CLASS = "number-of-rows-dropdown-item";
_RowsPerPageDropdownItem.ALL_ITEM_TEXT = "all";
let RowsPerPageDropdownItem = _RowsPerPageDropdownItem;
const _PaginationInternalUtils = class _r {
  static getTotalNumberOfRows(Y) {
    const { data: re, _visiblityInternal: oe, _tableBodyElementRef: ue } = Y;
    return oe != null && oe.filters ? FilterInternalUtils.extractUnfilteredRows(ue, re.length).length : re.length;
  }
  static insertNewRowsPerPageOption(Y, re) {
    let oe = re.findIndex((ue) => {
      const fe = Number.parseInt(ue);
      return isNaN(fe) || Y < fe;
    });
    oe === -1 && (oe = 0), re.splice(oe, 0, String(Y));
  }
  static setFirstOptionAsRowsPerPage(Y) {
    const { _pagination: re, dataStartsAtHeader: oe } = Y, ue = re.rowsPerPageOptionsItemText[0];
    if (ue.toLocaleLowerCase() === RowsPerPageDropdownItem.ALL_ITEM_TEXT) {
      re.isAllRowsOptionSelected = !0;
      const fe = _r.getTotalNumberOfRows(Y);
      re.rowsPerPage = oe ? fe : fe - 1;
    } else
      re.rowsPerPage = Number(ue);
  }
  static processRowsPerPage(Y, re) {
    const { rowsPerPageSelect: oe } = re;
    if (Y._pagination.rowsPerPage = Number.parseInt(String(Y._pagination.rowsPerPage)), oe || oe === void 0) {
      const { rowsPerPageOptionsItemText: ue, rowsPerPage: fe } = Y._pagination;
      if (!ue.find((he) => he === String(fe))) {
        const he = Number.parseInt(String(fe));
        isNaN(he) ? _r.setFirstOptionAsRowsPerPage(Y) : _r.insertNewRowsPerPageOption(he, ue);
      }
    }
  }
  static processOptionsItemText(Y) {
    const re = Number(Y);
    return !isNaN(re) && re < 1 ? "2" : String(Y);
  }
  // REF-32
  static changeOptionNumberToEven(Y) {
    return Y.map((re) => {
      const oe = Number(re);
      return Number.isNaN(oe) ? re : oe % 2 === 1 ? oe + 1 : oe;
    });
  }
  // prettier-ignore
  static setRowsPerPageOptionsText(Y) {
    const re = Y.pagination, { rowsPerPageSelect: oe } = re;
    if (oe || oe === void 0) {
      const ue = Y._pagination.rowsPerPageSelect.options;
      let fe = oe === void 0 || oe === !0 || !oe.options || oe.options.length === 0 ? ue : oe.options;
      Y.stripedRows && (fe = _r.changeOptionNumberToEven(fe)), Y._pagination.rowsPerPageOptionsItemText = fe.map((he) => _r.processOptionsItemText(he));
    }
  }
  static processRowsPerPageOptions(Y) {
    const re = Y.pagination, { rowsPerPageSelect: oe } = re;
    oe !== void 0 && typeof oe != "boolean" && oe.prefixText && (Y._pagination.rowsPerPageSelect.prefixText = oe.prefixText), _r.setRowsPerPageOptionsText(Y), delete re.rowsPerPageSelect;
  }
  static setDefaultBackgroundColors(Y, re) {
    var oe, ue, fe;
    const { def: he, hover: _e, click: ve } = re;
    (oe = Y.click).backgroundColor ?? (oe.backgroundColor = Y.hover.backgroundColor || Y.default.backgroundColor || ve), (ue = Y.hover).backgroundColor ?? (ue.backgroundColor = Y.default.backgroundColor || _e), (fe = Y.default).backgroundColor ?? (fe.backgroundColor = he), ["click", "hover", "default"].forEach((xe) => {
      Y[xe].backgroundColor === void 0 && delete Y[xe].backgroundColor;
    });
  }
  static setStatefulCSS(Y, re) {
    var oe, ue, fe;
    Y[re] ?? (Y[re] = {}), (oe = Y[re]).click ?? (oe.click = JSON.parse(JSON.stringify(Y[re].hover || Y[re].default || {}))), (ue = Y[re]).hover ?? (ue.hover = JSON.parse(JSON.stringify(Y[re].default || {}))), (fe = Y[re]).default ?? (fe.default = {});
  }
  // prettier-ignore
  static setRowsPerPageOptionsStyle(Y) {
    var re;
    _r.setStatefulCSS(Y.rowsPerPageSelect, "button");
    const oe = { def: "", hover: "#f5f5f5", click: "#f5f5f5" };
    _r.setDefaultBackgroundColors(
      (re = Y.rowsPerPageSelect) == null ? void 0 : re.button,
      oe
    );
  }
  // activeButtons reuse buttons style
  static mergeButtonsStyleWithActiveStyle(Y) {
    const { buttons: re, actionButtons: oe, activeButton: ue } = Y, fe = JSON.parse(JSON.stringify(re));
    return fe.default.backgroundColor = "#e8e8e8", fe.hover.backgroundColor = "#d6d6d6", fe.click.backgroundColor = "#c8c8c8", ue && (Object.assign(fe.default, ue.default), fe.hover = ue.hover, fe.click = ue.click), fe;
  }
  // actionButtons reuse buttons style
  static mergeButtonsStylesWithActionStyles(Y) {
    Y.actionButtons ?? (Y.actionButtons = {});
    const { buttons: re, actionButtons: oe } = Y, ue = JSON.parse(JSON.stringify(re));
    return Object.assign(ue.default, oe.default), Object.assign(ue.hover, oe.hover), Object.assign(ue.click, oe.click), ue.previousText = oe.previousText, ue.nextText = oe.nextText, ue.firstText = oe.firstText, ue.lastText = oe.lastText, ue;
  }
  // prettier-ignore
  static processPageButtonStyles(Y) {
    var re, oe, ue, fe;
    (re = Y.styles).pageButtons ?? (re.pageButtons = {});
    const he = Y.styles.pageButtons, _e = { def: "white", hover: "#f5f5f5", click: "#c8c8c8" };
    _r.setStatefulCSS(he, "buttons"), _r.setDefaultBackgroundColors(Y.styles.pageButtons.buttons, _e), _r.setStatefulCSS(he, "actionButtons"), _r.setDefaultBackgroundColors(
      Y.styles.pageButtons.actionButtons,
      {}
    );
    const ve = _r.mergeButtonsStylesWithActionStyles(he);
    Y.styles.pageButtons.actionButtons = ve;
    const xe = _r.mergeButtonsStyleWithActiveStyle(he);
    Y.styles.pageButtons.activeButton = xe, (oe = Y.styles.pageButtons).disabledButtons ?? (oe.disabledButtons = { backgroundColor: "#f9f9f9", color: "#9d9d9d", stroke: "#9d9d9d" });
    const Ee = {
      borderLeft: "1px solid #0000004d",
      borderTopLeftRadius: "2px",
      borderBottomLeftRadius: "2px"
    };
    (ue = Y.styles.pageButtons).firstVisibleButtonOverride ?? (ue.firstVisibleButtonOverride = Ee);
    const Se = {
      borderRight: "1px solid #0000004d",
      borderTopRightRadius: "2px",
      borderBottomRightRadius: "2px"
    };
    (fe = Y.styles.pageButtons).lastVisibleButtonOverride ?? (fe.lastVisibleButtonOverride = Se), Y.styles.pageButtons.activeButtonClass = Y.styles.pageButtons.activeButtonPrecedence ? PageButtonElement.PRECEDENCE_ACTIVE_PAGINATION_BUTTON_CLASS : PageButtonElement.ACTIVE_PAGINATION_BUTTON_CLASS;
  }
  static processStyle(Y, re) {
    var oe, ue;
    Y.styles && Object.assign(re.styles, Y.styles), _r.processPageButtonStyles(re), Y.rowsPerPageSelect !== !1 && ((oe = re.styles).rowsPerPageSelect ?? (oe.rowsPerPageSelect = {}), _r.setRowsPerPageOptionsStyle(re.styles)), (ue = re.styles).numberOfVisibleRows ?? (ue.numberOfVisibleRows = {}), delete Y.styles;
  }
  static processPositions(Y) {
    Object.keys(Y).forEach((re) => {
      const oe = Y[re];
      _r.POSITIONS.has(oe.position) || (oe.position = _r.DEFAULT_POSITION);
    });
  }
  static processPosition(Y, re) {
    Y.positions && Object.assign(re.positions, Y.positions), _r.processPositions(re.positions), delete Y.positions;
  }
  static async process(Y) {
    const { _pagination: re, _activeOverlayElements: oe } = Y;
    if (!Y.pagination)
      return;
    const ue = typeof Y.pagination == "boolean" ? {} : Y.pagination;
    ue.async && (LoadingElement.addInitial(Y), oe.error = ErrorElement.create(), re.asyncStartData = await PaginationAsyncStartData.get(Y, ue, re)), ue.maxNumberOfVisiblePageButtons !== void 0 && ue.maxNumberOfVisiblePageButtons < 1 && (ue.maxNumberOfVisiblePageButtons = 1), _r.processPosition(ue, re), _r.processStyle(ue, re), ue.rowsPerPageSelect !== !1 && _r.processRowsPerPageOptions(Y), Object.assign(re, ue), ue.displayNumberOfVisibleRows !== !1 && _r.processRowsPerPage(Y, ue);
  }
  static getDefault() {
    return {
      rowsPerPage: 10,
      rowsPerPageSelect: {
        options: [10, 25, 50, "All"],
        prefixText: "Rows per page:"
      },
      maxNumberOfVisiblePageButtons: 8,
      displayPrevNext: !0,
      displayFirstLast: !0,
      displayNumberOfVisibleRows: !0,
      styles: {},
      // this is going to be populated during the call of processInternal method
      visibleEdgeButtons: [],
      numberOfActionButtons: 0,
      dropdownWidth: 24,
      positions: {
        pageButtons: {
          position: _r.DEFAULT_POSITION,
          order: 3
        },
        numberOfVisibleRows: {
          position: _r.DEFAULT_POSITION,
          order: 2
        },
        rowsPerPageSelect: {
          position: _r.DEFAULT_POSITION,
          order: 1
        }
      },
      visibleRows: [],
      activePageNumber: 1,
      isAllRowsOptionSelected: !1
    };
  }
};
_PaginationInternalUtils.DEFAULT_POSITION = "bottom-right";
_PaginationInternalUtils.POSITIONS = /* @__PURE__ */ new Set([
  "top-left",
  "top-center",
  "top-right",
  "bottom-left",
  "bottom-center",
  _PaginationInternalUtils.DEFAULT_POSITION
]);
let PaginationInternalUtils = _PaginationInternalUtils;
class ActiveOverlayElementsUtils {
  static createNew() {
    return {};
  }
}
class ProgrammaticStructureUpdate {
  static processData(Y, re) {
    if (re)
      return Y > re.length ? re.concat(DataUtils.createEmptyStringDataArray(Y - re.length)) : Y < re.length ? re.slice(0, Y) : re;
  }
  // if -1 - last row, if above last index - last row, otherwise use the given index
  static processIndex(Y, re, oe) {
    return Y = Y > -1 ? Y : oe, Y = Y > oe ? oe : Y, !re && Y === oe ? oe - 1 : Y;
  }
  // prettier-ignore
  static updateColumn(Y, re, oe, ue) {
    var fe;
    oe = ProgrammaticStructureUpdate.processIndex(oe, re, ((fe = Y.data[0]) == null ? void 0 : fe.length) || 0), Y.data.length === 0 ? ue && UpdateAllTableData.update(Y, ue.map((he) => [he]), 0, !0) : re ? (ue = ProgrammaticStructureUpdate.processData(Y.data.length || 0, ue), InsertNewColumn.insert(Y, oe, ue)) : Y.data.length > 0 && RemoveColumn.remove(Y, oe);
  }
  static updatePaginationAsync(Y, re) {
    setTimeout(() => {
      var oe;
      if (Y._pagination) {
        const ue = (oe = Y._pagination) == null ? void 0 : oe.activePageNumber;
        re !== ue ? PaginationUtils.displayRowsForDifferentButton(Y, re) : re !== 1 && (PaginationUtils.displayRowsForDifferentButton(Y, 1), PaginationUtils.displayRowsForDifferentButton(Y, re));
      }
    });
  }
  static updateRow(Y, re, oe, ue) {
    var fe, he;
    if (oe = ProgrammaticStructureUpdate.processIndex(oe, re, Y.data.length), Y.data.length === 0)
      ue && UpdateAllTableData.update(Y, [ue], 0, !0);
    else if (re) {
      const _e = (fe = Y._pagination) == null ? void 0 : fe.activePageNumber;
      ue = ProgrammaticStructureUpdate.processData(((he = Y.data[0]) == null ? void 0 : he.length) || 0, ue), InsertNewRow.insert(Y, oe, !0, ue), setTimeout(() => ProgrammaticStructureUpdate.updatePaginationAsync(Y, _e));
    } else
      RemoveRow.remove(Y, oe);
  }
  static update(Y, re) {
    const { structure: oe, isInsert: ue, index: fe, data: he } = re;
    typeof ue != "boolean" || typeof fe != "number" || (oe === "row" ? ProgrammaticStructureUpdate.updateRow(Y, ue, fe, he) : oe === "column" && ProgrammaticStructureUpdate.updateColumn(Y, ue, fe, he));
  }
}
class FrameComponentsInternalUtils {
  static set(Y) {
    const { frameComponentsStyles: re, _frameComponents: oe } = Y;
    oe.displayAddNewColumn = Y.displayAddNewColumn, oe.displayAddNewRow = Y.displayAddNewRow, oe.displayIndexColumn = Y.displayIndexColumn, oe.styles = re.styles, oe.inheritHeaderColors = re.inheritHeaderColors ?? !0;
  }
  static getDefault() {
    return {
      displayAddNewColumn: !0,
      displayAddNewRow: !0,
      displayIndexColumn: !0,
      cellColors: FrameComponentsColors.getDefaultCellColors()
    };
  }
}
class RowDropdownSettingsUtil {
  static postprocessOpenMethod(Y, re) {
    var oe, ue;
    !re.displayIndexColumn && (oe = Y.displaySettings.openMethod) != null && oe.cellClick && ((ue = Y.displaySettings.openMethod) == null || delete ue.cellClick, Y.displaySettings.openMethod.overlayClick = !0);
  }
  // prettier-ignore
  static preprocessOpenMethod(Y, re) {
    re && (Y.displaySettings.openMethod === void 0 || Object.keys(Y.displaySettings.openMethod).length === 0) && re.openMethod && (Y.displaySettings.openMethod = JSON.parse(JSON.stringify(re.openMethod)));
  }
  static process(Y) {
    var re;
    const { rowDropdown: oe, _frameComponents: ue, _defaultColumnsSettings: fe } = Y;
    oe.isInsertUpAvailable ?? (oe.isInsertUpAvailable = !0), oe.isInsertDownAvailable ?? (oe.isInsertDownAvailable = !0), oe.isMoveAvailable ?? (oe.isMoveAvailable = !0), oe.canEditHeaderRow ?? (oe.canEditHeaderRow = !0), oe.isDeleteAvailable ?? (oe.isDeleteAvailable = !0), oe.displaySettings ?? (oe.displaySettings = {}), RowDropdownSettingsUtil.preprocessOpenMethod(oe, (re = fe.columnDropdown) == null ? void 0 : re.displaySettings), DropdownDisplaySettingsUtil.process(oe.displaySettings), RowDropdownSettingsUtil.postprocessOpenMethod(oe, ue);
  }
}
class ProgrammaticCellUpdate {
  static updateText(Y, re) {
    var oe;
    const { newText: ue, rowIndex: fe, columnIndex: he } = re;
    if (!ObjectUtils.areValuesFullyDefined(ue, fe, he) || typeof ue != "string" && typeof ue != "number")
      return;
    const _e = (oe = Y._columnsDetails[he]) == null ? void 0 : oe.elements[fe];
    !_e || ue === CellElement.getText(_e) || (CellEvents.updateCell(Y, ue, fe, he, { element: _e, processText: fe > 0 }), ColumnTypesUtils.updateDataElements(Y, fe, he, _e), fe === 0 && (Dropdown.isDisplayed(Y._activeOverlayElements.columnDropdown) && ColumnDropdown.processTextAndHide(Y), HeaderText.onAttemptChange(Y, _e, he)));
  }
}
class SheetJSExport {
  static getFileName(Y, re) {
    return re ? re.endsWith(`.${Y}`) ? re : `${re}.${Y}` : `table_data.${Y}`;
  }
  // not csv
  static export(Y, re, oe, ue) {
    const fe = ue.utils.book_new(), he = ue.utils.aoa_to_sheet(Y.data);
    ue.utils.book_append_sheet(fe, he, "Sheet");
    const _e = SheetJSExport.getFileName(re, oe);
    ue.writeFile(fe, _e, { bookType: re });
  }
}
class CSVExport {
  static export(Y, re) {
    const oe = "data:text/csv;charset=utf-8," + Y.data.map((he) => he.join(",")).join(`
`), ue = encodeURI(oe), fe = document.createElement("a");
    fe.setAttribute("href", ue), fe.setAttribute("download", re || "table_data.csv"), document.body.appendChild(fe), fe.click();
  }
}
class FileExportEvents {
  static export(Y, re) {
    const oe = re?.format || "csv";
    if (ACCEPTED_FILE_FORMATS.find((ue) => oe === ue)) {
      const ue = re?.fileName;
      oe === "csv" ? CSVExport.export(Y, ue) : SheetJSInternalUtils.execFuncWithExtractorModule(SheetJSExport.export.bind(this, Y, oe, ue));
    }
  }
  static setEvents(Y, re, oe) {
    var ue;
    const fe = oe ? { format: (ue = oe.formats) == null ? void 0 : ue[0], fileName: oe.fileName } : void 0;
    re.onclick = FileExportEvents.export.bind(this, Y, fe);
  }
}
class FileExportDropdownItemEvents {
  static action(Y, re) {
    const oe = re.toLowerCase();
    FileExportEvents.export(Y, { format: oe });
  }
  static setEvents(Y, re) {
    const oe = FileExportDropdownItemEvents.action, ue = OuterDropdownSimpleUtils.hide;
    re.onmousedown = OuterDropdownItemEvents.itemMouseDownCommon.bind(Y, oe, ue);
  }
}
const _FileExportDropdownItem = class mn {
  // prettier-ignore
  static populate(Y, re, oe) {
    oe.forEach((ue) => {
      const fe = { text: ue.toUpperCase() }, he = DropdownItem.addButtonItem(
        Y,
        re,
        fe,
        mn.ITEM_CLASS,
        StaticDropdown.ITEM_CLASS
      );
      FileExportDropdownItemEvents.setEvents(Y, he);
    });
  }
};
_FileExportDropdownItem.ITEM_CLASS = "export-formats-dropdown-item";
let FileExportDropdownItem = _FileExportDropdownItem;
class FileExportDropdown {
  static create(Y, re, oe) {
    const ue = OuterDropdownSimpleUtils.hide.bind(this, Y._activeOverlayElements), fe = OuterDropdownSimpleUtils.display.bind(this, re), he = OuterDropdownElement.create(Y, re, "bottom-right", {}, [], ue, fe);
    return he.element.classList.add(StaticDropdown.DROPDOWN_CLASS), FileExportDropdownItem.populate(Y, he.element, oe), he;
  }
}
const _FileExportButtonElement = class oi {
  static createButtonArrow(Y, re) {
    const oe = OuterDropdownButtonUtils.createArrow(
      [oi.ARROW_CONTAINER_CLASS],
      [oi.ARROW_ICON_CLASS]
    ), ue = typeof re == "object" && re.formats && re.buttonArrowStyles;
    return ue && (OuterDropdownButtonUtils.processAndApplyDefaultStyle(oe, ue), setTimeout(() => StatefulCSSEvents.setEvents(Y, ue, void 0, oe))), oe;
  }
  // if there is more than 1 format - automatically create a dropdown
  static getDropdownFormats(Y) {
    if (typeof Y == "object" && Y.formats) {
      const { formats: re } = Y, oe = re.filter((ue) => oi.VALID_FORMATS[ue.toLocaleLowerCase()]);
      if (oe.length > 1)
        return oe;
    }
  }
  // prettier-ignore
  static applyDropdown(Y, re, oe, ue, fe) {
    const he = FileExportDropdown.create(Y, re, ue);
    oe.appendChild(he.element), re.appendChild(oi.createButtonArrow(re, fe));
  }
};
_FileExportButtonElement.ARROW_CONTAINER_CLASS = "file-button-arrow-container";
_FileExportButtonElement.ARROW_ICON_CLASS = "file-button-arrow-container-icon";
_FileExportButtonElement.VALID_FORMATS = ["csv", "xls", "xlsx", "ods", "txt"].reduce((le, Y) => (le[Y] = !0, le), {});
let FileExportButtonElement = _FileExportButtonElement;
const _FileButtonElements = class ja {
  static setEvents(Y, re, oe) {
    re.import ? FileImportButtonEvents.setEvents(Y, oe, typeof re.import == "object" ? re.import : void 0) : re.export && FileExportEvents.setEvents(Y, oe, typeof re.export == "object" ? re.export : void 0);
  }
  // the main reason for this is to display a dropdown
  static wrapInRelativeContainer(Y) {
    const re = document.createElement("div");
    return re.classList.add(ja.BUTTON_CONTAINER_CLASS), re.appendChild(Y), re;
  }
  static createElement(Y, re) {
    const { text: oe, order: ue, styles: fe } = Y, he = document.createElement("div");
    he.classList.add(ja.BUTTON_CLASS), he.textContent = oe || re, he.style.order = String(ue || 0);
    const _e = FilesUtils.processStyles(fe);
    return Object.assign(he.style, _e.default), setTimeout(() => StatefulCSSEvents.setEvents(he, _e)), he;
  }
  static create(Y, re) {
    var oe, ue;
    (ue = (oe = Y.files) == null ? void 0 : oe.buttons) == null || ue.forEach((fe) => {
      if (!fe.export && !fe.import)
        return;
      const he = ja.createElement(fe, fe.import ? "Import" : "Export"), _e = ja.wrapInRelativeContainer(he), ve = fe.export && FileExportButtonElement.getDropdownFormats(fe.export);
      ve ? FileExportButtonElement.applyDropdown(Y, he, _e, ve, fe.export) : setTimeout(() => ja.setEvents(Y, fe, he));
      const xe = fe.position || FilesUtils.DEFAULT_BUTTON_POSITION;
      OuterContainerElements.addToContainer(xe, re, _e);
    });
  }
};
_FileButtonElements.BUTTON_CLASS = "file-button";
_FileButtonElements.BUTTON_CONTAINER_CLASS = "file-button-container";
let FileButtonElements = _FileButtonElements;
class OuterTableComponents {
  static create(Y) {
    const re = OuterContainerElements.create(Y);
    Y.pagination && PaginationElements.create(Y, re), Y.files && FileButtonElements.create(Y, re), Y.filter && FilterElements.create(Y, re);
  }
}
class WebComponentStyleUtils {
  static add(Y, re) {
    if (!(!re || !Y))
      try {
        WebComponentStyleUtils.addStyleSheet(Y, re);
      } catch {
        WebComponentStyleUtils.addStyleElement(Y, re);
      }
  }
  static addStyleSheet(Y, re) {
    const oe = new CSSStyleSheet();
    oe.replaceSync(Y), re.adoptedStyleSheets.push(oe);
  }
  static addStyleElement(Y, re) {
    const oe = document.createElement("style");
    oe.innerHTML = Y, re.appendChild(oe);
  }
}
class FocusedElementsUtils {
  static createEmpty() {
    return { cell: FocusedCellUtils.createEmpty() };
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2 = (le) => (Y, re) => {
  re !== void 0 ? re.addInitializer(() => {
    customElements.define(le, Y);
  }) : customElements.define(le, Y);
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1$1 = globalThis, e$2$1 = t$1$1.ShadowRoot && (t$1$1.ShadyCSS === void 0 || t$1$1.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$2$1 = Symbol(), o$4 = /* @__PURE__ */ new WeakMap();
let n$3 = class {
  constructor(le, Y, re) {
    if (this._$cssResult$ = !0, re !== s$2$1)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = le, this.t = Y;
  }
  get styleSheet() {
    let le = this.o;
    const Y = this.t;
    if (e$2$1 && le === void 0) {
      const re = Y !== void 0 && Y.length === 1;
      re && (le = o$4.get(Y)), le === void 0 && ((this.o = le = new CSSStyleSheet()).replaceSync(this.cssText), re && o$4.set(Y, le));
    }
    return le;
  }
  toString() {
    return this.cssText;
  }
};
const r$4 = (le) => new n$3(typeof le == "string" ? le : le + "", void 0, s$2$1), i$3 = (le, ...Y) => {
  const re = le.length === 1 ? le[0] : Y.reduce((oe, ue, fe) => oe + ((he) => {
    if (he._$cssResult$ === !0)
      return he.cssText;
    if (typeof he == "number")
      return he;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + he + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(ue) + le[fe + 1], le[0]);
  return new n$3(re, le, s$2$1);
}, S$1$1 = (le, Y) => {
  if (e$2$1)
    le.adoptedStyleSheets = Y.map((re) => re instanceof CSSStyleSheet ? re : re.styleSheet);
  else
    for (const re of Y) {
      const oe = document.createElement("style"), ue = t$1$1.litNonce;
      ue !== void 0 && oe.setAttribute("nonce", ue), oe.textContent = re.cssText, le.appendChild(oe);
    }
}, c$2$1 = e$2$1 ? (le) => le : (le) => le instanceof CSSStyleSheet ? ((Y) => {
  let re = "";
  for (const oe of Y.cssRules)
    re += oe.cssText;
  return r$4(re);
})(le) : le;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: i$2$1, defineProperty: e$1$1, getOwnPropertyDescriptor: h$1$1, getOwnPropertyNames: r$3, getOwnPropertySymbols: o$3, getPrototypeOf: n$2 } = Object, a$1$1 = globalThis, c$1$1 = a$1$1.trustedTypes, l$1$1 = c$1$1 ? c$1$1.emptyScript : "", p$1$1 = a$1$1.reactiveElementPolyfillSupport, d$1$1 = (le, Y) => le, u$1$1 = { toAttribute(le, Y) {
  switch (Y) {
    case Boolean:
      le = le ? l$1$1 : null;
      break;
    case Object:
    case Array:
      le = le == null ? le : JSON.stringify(le);
  }
  return le;
}, fromAttribute(le, Y) {
  let re = le;
  switch (Y) {
    case Boolean:
      re = le !== null;
      break;
    case Number:
      re = le === null ? null : Number(le);
      break;
    case Object:
    case Array:
      try {
        re = JSON.parse(le);
      } catch {
        re = null;
      }
  }
  return re;
} }, f$1$1 = (le, Y) => !i$2$1(le, Y), b$2 = { attribute: !0, type: String, converter: u$1$1, reflect: !1, useDefault: !1, hasChanged: f$1$1 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a$1$1.litPropertyMetadata ?? (a$1$1.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let y$3 = class extends HTMLElement {
  static addInitializer(Y) {
    this._$Ei(), (this.l ?? (this.l = [])).push(Y);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(Y, re = b$2) {
    if (re.state && (re.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(Y) && ((re = Object.create(re)).wrapped = !0), this.elementProperties.set(Y, re), !re.noAccessor) {
      const oe = Symbol(), ue = this.getPropertyDescriptor(Y, oe, re);
      ue !== void 0 && e$1$1(this.prototype, Y, ue);
    }
  }
  static getPropertyDescriptor(Y, re, oe) {
    const { get: ue, set: fe } = h$1$1(this.prototype, Y) ?? { get() {
      return this[re];
    }, set(he) {
      this[re] = he;
    } };
    return { get: ue, set(he) {
      const _e = ue?.call(this);
      fe?.call(this, he), this.requestUpdate(Y, _e, oe);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(Y) {
    return this.elementProperties.get(Y) ?? b$2;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$1$1("elementProperties")))
      return;
    const Y = n$2(this);
    Y.finalize(), Y.l !== void 0 && (this.l = [...Y.l]), this.elementProperties = new Map(Y.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$1$1("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(d$1$1("properties"))) {
      const re = this.properties, oe = [...r$3(re), ...o$3(re)];
      for (const ue of oe)
        this.createProperty(ue, re[ue]);
    }
    const Y = this[Symbol.metadata];
    if (Y !== null) {
      const re = litPropertyMetadata.get(Y);
      if (re !== void 0)
        for (const [oe, ue] of re)
          this.elementProperties.set(oe, ue);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [re, oe] of this.elementProperties) {
      const ue = this._$Eu(re, oe);
      ue !== void 0 && this._$Eh.set(ue, re);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(Y) {
    const re = [];
    if (Array.isArray(Y)) {
      const oe = new Set(Y.flat(1 / 0).reverse());
      for (const ue of oe)
        re.unshift(c$2$1(ue));
    } else
      Y !== void 0 && re.push(c$2$1(Y));
    return re;
  }
  static _$Eu(Y, re) {
    const oe = re.attribute;
    return oe === !1 ? void 0 : typeof oe == "string" ? oe : typeof Y == "string" ? Y.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var Y;
    this._$ES = new Promise((re) => this.enableUpdating = re), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (Y = this.constructor.l) == null || Y.forEach((re) => re(this));
  }
  addController(Y) {
    var re;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(Y), this.renderRoot !== void 0 && this.isConnected && ((re = Y.hostConnected) == null || re.call(Y));
  }
  removeController(Y) {
    var re;
    (re = this._$EO) == null || re.delete(Y);
  }
  _$E_() {
    const Y = /* @__PURE__ */ new Map(), re = this.constructor.elementProperties;
    for (const oe of re.keys())
      this.hasOwnProperty(oe) && (Y.set(oe, this[oe]), delete this[oe]);
    Y.size > 0 && (this._$Ep = Y);
  }
  createRenderRoot() {
    const Y = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$1$1(Y, this.constructor.elementStyles), Y;
  }
  connectedCallback() {
    var Y;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (Y = this._$EO) == null || Y.forEach((re) => {
      var oe;
      return (oe = re.hostConnected) == null ? void 0 : oe.call(re);
    });
  }
  enableUpdating(Y) {
  }
  disconnectedCallback() {
    var Y;
    (Y = this._$EO) == null || Y.forEach((re) => {
      var oe;
      return (oe = re.hostDisconnected) == null ? void 0 : oe.call(re);
    });
  }
  attributeChangedCallback(Y, re, oe) {
    this._$AK(Y, oe);
  }
  _$ET(Y, re) {
    var oe;
    const ue = this.constructor.elementProperties.get(Y), fe = this.constructor._$Eu(Y, ue);
    if (fe !== void 0 && ue.reflect === !0) {
      const he = (((oe = ue.converter) == null ? void 0 : oe.toAttribute) !== void 0 ? ue.converter : u$1$1).toAttribute(re, ue.type);
      this._$Em = Y, he == null ? this.removeAttribute(fe) : this.setAttribute(fe, he), this._$Em = null;
    }
  }
  _$AK(Y, re) {
    var oe, ue;
    const fe = this.constructor, he = fe._$Eh.get(Y);
    if (he !== void 0 && this._$Em !== he) {
      const _e = fe.getPropertyOptions(he), ve = typeof _e.converter == "function" ? { fromAttribute: _e.converter } : ((oe = _e.converter) == null ? void 0 : oe.fromAttribute) !== void 0 ? _e.converter : u$1$1;
      this._$Em = he, this[he] = ve.fromAttribute(re, _e.type) ?? ((ue = this._$Ej) == null ? void 0 : ue.get(he)) ?? null, this._$Em = null;
    }
  }
  requestUpdate(Y, re, oe) {
    var ue;
    if (Y !== void 0) {
      const fe = this.constructor, he = this[Y];
      if (oe ?? (oe = fe.getPropertyOptions(Y)), !((oe.hasChanged ?? f$1$1)(he, re) || oe.useDefault && oe.reflect && he === ((ue = this._$Ej) == null ? void 0 : ue.get(Y)) && !this.hasAttribute(fe._$Eu(Y, oe))))
        return;
      this.C(Y, re, oe);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(Y, re, { useDefault: oe, reflect: ue, wrapped: fe }, he) {
    oe && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(Y) && (this._$Ej.set(Y, he ?? re ?? this[Y]), fe !== !0 || he !== void 0) || (this._$AL.has(Y) || (this.hasUpdated || oe || (re = void 0), this._$AL.set(Y, re)), ue === !0 && this._$Em !== Y && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(Y));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (re) {
      Promise.reject(re);
    }
    const Y = this.scheduleUpdate();
    return Y != null && await Y, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var Y;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [fe, he] of this._$Ep)
          this[fe] = he;
        this._$Ep = void 0;
      }
      const ue = this.constructor.elementProperties;
      if (ue.size > 0)
        for (const [fe, he] of ue) {
          const { wrapped: _e } = he, ve = this[fe];
          _e !== !0 || this._$AL.has(fe) || ve === void 0 || this.C(fe, void 0, he, ve);
        }
    }
    let re = !1;
    const oe = this._$AL;
    try {
      re = this.shouldUpdate(oe), re ? (this.willUpdate(oe), (Y = this._$EO) == null || Y.forEach((ue) => {
        var fe;
        return (fe = ue.hostUpdate) == null ? void 0 : fe.call(ue);
      }), this.update(oe)) : this._$EM();
    } catch (ue) {
      throw re = !1, this._$EM(), ue;
    }
    re && this._$AE(oe);
  }
  willUpdate(Y) {
  }
  _$AE(Y) {
    var re;
    (re = this._$EO) == null || re.forEach((oe) => {
      var ue;
      return (ue = oe.hostUpdated) == null ? void 0 : ue.call(oe);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(Y)), this.updated(Y);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(Y) {
    return !0;
  }
  update(Y) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((re) => this._$ET(re, this[re]))), this._$EM();
  }
  updated(Y) {
  }
  firstUpdated(Y) {
  }
};
y$3.elementStyles = [], y$3.shadowRootOptions = { mode: "open" }, y$3[d$1$1("elementProperties")] = /* @__PURE__ */ new Map(), y$3[d$1$1("finalized")] = /* @__PURE__ */ new Map(), p$1$1?.({ ReactiveElement: y$3 }), (a$1$1.reactiveElementVersions ?? (a$1$1.reactiveElementVersions = [])).push("2.1.0");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$2$1 = { attribute: !0, type: String, converter: u$1$1, reflect: !1, hasChanged: f$1$1 }, r$2$1 = (le = o$2$1, Y, re) => {
  const { kind: oe, metadata: ue } = re;
  let fe = globalThis.litPropertyMetadata.get(ue);
  if (fe === void 0 && globalThis.litPropertyMetadata.set(ue, fe = /* @__PURE__ */ new Map()), oe === "setter" && ((le = Object.create(le)).wrapped = !0), fe.set(re.name, le), oe === "accessor") {
    const { name: he } = re;
    return { set(_e) {
      const ve = Y.get.call(this);
      Y.set.call(this, _e), this.requestUpdate(he, ve, le);
    }, init(_e) {
      return _e !== void 0 && this.C(he, void 0, le, _e), _e;
    } };
  }
  if (oe === "setter") {
    const { name: he } = re;
    return function(_e) {
      const ve = this[he];
      Y.call(this, _e), this.requestUpdate(he, ve, le);
    };
  }
  throw Error("Unsupported decorator location: " + oe);
};
function n$1$1(le) {
  return (Y, re) => typeof re == "object" ? r$2$1(le, Y, re) : ((oe, ue, fe) => {
    const he = ue.hasOwnProperty(fe);
    return ue.constructor.createProperty(fe, oe), he ? Object.getOwnPropertyDescriptor(ue, fe) : void 0;
  })(le, Y, re);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$1$1(le) {
  return n$1$1({ ...le, state: !0, attribute: !1 });
}
class WindowEvents {
  static onKeyDown(Y) {
    var re, oe;
    Dropdown.isDisplayed((re = this._activeOverlayElements.outerContainerDropdown) == null ? void 0 : re.element) && OuterDropdownEvents.windowOnKeyDown(this, Y), Dropdown.isDisplayed(this._activeOverlayElements.rowDropdown) && RowDropdownEvents.windowOnKeyDown(this, Y);
    const { rowIndex: ue, columnIndex: fe, element: he } = this._focusedElements.cell;
    if (!(ue === void 0 || fe === void 0)) {
      if (ue === 0 && !Dropdown.isDisplayed(this._activeOverlayElements.columnDropdown)) {
        if (Y.key === KEYBOARD_KEY.ESCAPE)
          return HeaderText.onAttemptChange(this, he, fe);
      } else if (Dropdown.isDisplayed(this._activeOverlayElements.columnDropdown) && !((oe = this.shadowRoot) != null && oe.activeElement))
        return ColumnDropdownEvents.onKeyDown.bind(this)(this._activeOverlayElements.columnDropdown, Y);
      ue > 0 && this._columnsDetails[fe].activeType.cellDropdownProps && SelectCellTextBaseEvents.keyDownText(this, ue, fe, Y);
    }
  }
  static onKeyUp(Y) {
    Y.key === KEYBOARD_KEY.ESCAPE ? (OptionColorButtonEvents.windowEventClosePicker(this._columnsDetails, this._focusedElements), DateCellInputEvents.escapeKeyInput(this)) : Y.key === KEYBOARD_KEY.ENTER && OptionColorButtonEvents.windowEventClosePicker(this._columnsDetails, this._focusedElements);
  }
  // prettier-ignore
  static onMouseDown(Y) {
    var re;
    if (OptionColorButtonEvents.windowEventClosePicker(this._columnsDetails, this._focusedElements), Dropdown.isDisplayed((re = this._activeOverlayElements.outerContainerDropdown) == null ? void 0 : re.element) && OuterDropdownEvents.windowOnMouseDown(this), Y.target.tagName === ActiveTable._ELEMENT_TAG)
      return;
    const { _activeOverlayElements: { columnDropdown: oe, rowDropdown: ue }, _focusedElements: fe } = this;
    Dropdown.isDisplayed(ue) && RowDropdown.hide(this), Dropdown.isDisplayed(oe) ? ColumnDropdown.processTextAndHide(this) : fe.cellDropdown ? CellWithTextEvents.programmaticBlur(this) : this._activeOverlayElements.datePickerCell && (DateCellInputElement.toggle(this._activeOverlayElements.datePickerCell, !1), delete this._activeOverlayElements.datePickerCell);
  }
  static onMouseUp() {
    this._activeOverlayElements.selectedColumnSizer && ColumnSizerExtrinsicEvents.windowMouseUp(this), DragColumn.windowMouseUp(this), DragRow.windowMouseUp(this);
  }
  static onMouseMove(Y) {
    this._activeOverlayElements.selectedColumnSizer && ColumnSizerExtrinsicEvents.windowMouseMove(this, Y.movementX), this._focusedElements.colDragEl && DragColumn.windowDrag(this, this._focusedElements.colDragEl, Y), this._focusedElements.rowDragEl && DragRow.windowDrag(this, Y);
  }
}
class Render {
  // CAUTION-4 overwriting @properties causes the whole table to refresh and subsequently - an infinite render loop
  // prettier-ignore
  static refreshTableState(Y) {
    var re;
    (re = Y._cellDropdownContainer) == null || re.replaceChildren(), Y._columnsDetails.splice(0, Y._columnsDetails.length), Y._tableDimensions.indexColumnWidth = IndexColumn.DEFAULT_WIDTH, Y._addColumnCellsElementsRef.splice(0, Y._addColumnCellsElementsRef.length), Y._overflow && (Y._tableDimensions.border = TableBorderDimensionsUtils.generateUsingElement(Y._overflow.overflowContainer));
  }
  static renderTable(Y) {
    Y._isRendering = !0, TableDimensionsUtils.record(Y), Render.refreshTableState(Y), Y._overflow && OverflowUtils.applyDimensions(Y), TableElement.setStaticWidthContentTotal(Y), TableDimensionsUtils.setTableDimensions(Y), TableElement.populateBody(Y), setTimeout(() => Y._isRendering = !1);
  }
}
class WindowResize {
  // prettier-ignore
  static resize(Y) {
    const { _tableDimensions: re } = this;
    (Y.width && window.innerWidth !== re.recordedWindowWidth || Y.height && window.innerHeight !== re.recordedWindowHeight) && Render.renderTable(this);
  }
  static extractPostfix(Y) {
    if (typeof Y == "string") {
      if (Y.includes(VW))
        return VW;
      if (Y.includes(VH))
        return VH;
    }
    return "";
  }
  static extractDimensionsToObserve(Y) {
    const { tableStyle: re, _overflow: oe } = Y, ue = [re.width, re.maxWidth, oe?.maxHeight, oe?.maxWidth].map(
      (fe) => WindowResize.extractPostfix(fe)
    );
    return {
      width: !!ue.find((fe) => fe === VW),
      height: !!ue.find((fe) => fe === VH)
    };
  }
  static observeIfRequired(Y) {
    const re = WindowResize.extractDimensionsToObserve(Y);
    (re.width || re.height) && window.addEventListener("resize", WindowResize.resize.bind(Y, re));
  }
}
class WindowElement {
  static setEvents(Y) {
    window.addEventListener("keydown", WindowEvents.onKeyDown.bind(Y)), window.addEventListener("keyup", WindowEvents.onKeyUp.bind(Y)), window.addEventListener("mousedown", WindowEvents.onMouseDown.bind(Y)), window.addEventListener("mouseup", WindowEvents.onMouseUp.bind(Y)), window.addEventListener("mousemove", WindowEvents.onMouseMove.bind(Y)), WindowResize.observeIfRequired(Y);
  }
}
const _GoogleFont = class qi {
  static appendStyleSheetToHead() {
    const Y = document.getElementsByTagName("head")[0];
    if (!Array.from(Y.getElementsByTagName("link")).some(
      (re) => re.getAttribute("href") === qi.FONT_URL
    )) {
      const re = document.createElement("link");
      re.rel = "stylesheet", re.href = qi.FONT_URL, Y.appendChild(re);
    }
  }
};
_GoogleFont.FONT_URL = "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap";
let GoogleFont = _GoogleFont;
class ParentResize {
  static doesOverflowNeedRerender(Y, re) {
    if (!Y._overflow)
      return !1;
    const { isHeightPercentage: oe, isWidthPercentage: ue } = Y._overflow;
    return oe && Y._tableDimensions.recordedParentHeight !== re.offsetHeight || ue && Y._tableDimensions.recordedParentWidth !== re.offsetWidth;
  }
  static shouldRerenderTable(Y) {
    if (!Y)
      return !1;
    const re = Y.parentElement;
    return re ? ParentResize.doesOverflowNeedRerender(Y, re) ? !0 : Y._tableDimensions.isPercentage && // Resize callback gets triggered on multiple occasions when the parent width has not changed:
    // on startup, after table has been resized, when parent height is changed and when column height is changed
    // This condition prevents the table from re-rendering itself when the above occurs
    Y._tableDimensions.recordedParentWidth !== re.offsetWidth && // If the parent is resized to a width that does not impact the table width, do not bother re-rendering it
    (Y._tableDimensions.maxWidth === void 0 || Y.offsetWidth > re.offsetWidth) : !1;
  }
  static resizeCallback() {
    const Y = this;
    ParentResize.shouldRerenderTable(Y) && (Y._tableDimensions.preserveNarrowColumns || (Y._tableDimensions.preserveNarrowColumns = !0, setTimeout(() => Y._tableDimensions.preserveNarrowColumns = !1)), Render.renderTable(Y));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$3 = globalThis, i$1$1 = t$3.trustedTypes, s$1$1 = i$1$1 ? i$1$1.createPolicy("lit-html", { createHTML: (le) => le }) : void 0, e$3 = "$lit$", h$2 = `lit$${Math.random().toFixed(9).slice(2)}$`, o$1$1 = "?" + h$2, n$4 = `<${o$1$1}>`, r$5 = document, l$3 = () => r$5.createComment(""), c$3 = (le) => le === null || typeof le != "object" && typeof le != "function", a$3 = Array.isArray, u$3 = (le) => a$3(le) || typeof le?.[Symbol.iterator] == "function", d$3 = `[ 	
\f\r]`, f$3 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v$3 = /-->/g, _$2 = />/g, m$3 = RegExp(`>|${d$3}(?:([^\\s"'>=/]+)(${d$3}*=${d$3}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), p$3 = /'/g, g$3 = /"/g, $$3 = /^(?:script|style|textarea|title)$/i, T$4 = Symbol.for("lit-noChange"), E$3 = Symbol.for("lit-nothing"), A$3 = /* @__PURE__ */ new WeakMap(), C$2 = r$5.createTreeWalker(r$5, 129);
function P$3(le, Y) {
  if (!a$3(le) || !le.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return s$1$1 !== void 0 ? s$1$1.createHTML(Y) : Y;
}
const V$3 = (le, Y) => {
  const re = le.length - 1, oe = [];
  let ue, fe = Y === 2 ? "<svg>" : Y === 3 ? "<math>" : "", he = f$3;
  for (let _e = 0; _e < re; _e++) {
    const ve = le[_e];
    let xe, Ee, Se = -1, Te = 0;
    for (; Te < ve.length && (he.lastIndex = Te, Ee = he.exec(ve), Ee !== null); )
      Te = he.lastIndex, he === f$3 ? Ee[1] === "!--" ? he = v$3 : Ee[1] !== void 0 ? he = _$2 : Ee[2] !== void 0 ? ($$3.test(Ee[2]) && (ue = RegExp("</" + Ee[2], "g")), he = m$3) : Ee[3] !== void 0 && (he = m$3) : he === m$3 ? Ee[0] === ">" ? (he = ue ?? f$3, Se = -1) : Ee[1] === void 0 ? Se = -2 : (Se = he.lastIndex - Ee[2].length, xe = Ee[1], he = Ee[3] === void 0 ? m$3 : Ee[3] === '"' ? g$3 : p$3) : he === g$3 || he === p$3 ? he = m$3 : he === v$3 || he === _$2 ? he = f$3 : (he = m$3, ue = void 0);
    const Ce = he === m$3 && le[_e + 1].startsWith("/>") ? " " : "";
    fe += he === f$3 ? ve + n$4 : Se >= 0 ? (oe.push(xe), ve.slice(0, Se) + e$3 + ve.slice(Se) + h$2 + Ce) : ve + h$2 + (Se === -2 ? _e : Ce);
  }
  return [P$3(le, fe + (le[re] || "<?>") + (Y === 2 ? "</svg>" : Y === 3 ? "</math>" : "")), oe];
};
let N$3 = class gn {
  constructor({ strings: Y, _$litType$: re }, oe) {
    let ue;
    this.parts = [];
    let fe = 0, he = 0;
    const _e = Y.length - 1, ve = this.parts, [xe, Ee] = V$3(Y, re);
    if (this.el = gn.createElement(xe, oe), C$2.currentNode = this.el.content, re === 2 || re === 3) {
      const Se = this.el.content.firstChild;
      Se.replaceWith(...Se.childNodes);
    }
    for (; (ue = C$2.nextNode()) !== null && ve.length < _e; ) {
      if (ue.nodeType === 1) {
        if (ue.hasAttributes())
          for (const Se of ue.getAttributeNames())
            if (Se.endsWith(e$3)) {
              const Te = Ee[he++], Ce = ue.getAttribute(Se).split(h$2), Ie = /([.?@])?(.*)/.exec(Te);
              ve.push({ type: 1, index: fe, name: Ie[2], strings: Ce, ctor: Ie[1] === "." ? H$3 : Ie[1] === "?" ? I$2 : Ie[1] === "@" ? L$2 : k$3 }), ue.removeAttribute(Se);
            } else
              Se.startsWith(h$2) && (ve.push({ type: 6, index: fe }), ue.removeAttribute(Se));
        if ($$3.test(ue.tagName)) {
          const Se = ue.textContent.split(h$2), Te = Se.length - 1;
          if (Te > 0) {
            ue.textContent = i$1$1 ? i$1$1.emptyScript : "";
            for (let Ce = 0; Ce < Te; Ce++)
              ue.append(Se[Ce], l$3()), C$2.nextNode(), ve.push({ type: 2, index: ++fe });
            ue.append(Se[Te], l$3());
          }
        }
      } else if (ue.nodeType === 8)
        if (ue.data === o$1$1)
          ve.push({ type: 2, index: fe });
        else {
          let Se = -1;
          for (; (Se = ue.data.indexOf(h$2, Se + 1)) !== -1; )
            ve.push({ type: 7, index: fe }), Se += h$2.length - 1;
        }
      fe++;
    }
  }
  static createElement(Y, re) {
    const oe = r$5.createElement("template");
    return oe.innerHTML = Y, oe;
  }
};
function S$2(le, Y, re = le, oe) {
  var ue, fe;
  if (Y === T$4)
    return Y;
  let he = oe !== void 0 ? (ue = re._$Co) == null ? void 0 : ue[oe] : re._$Cl;
  const _e = c$3(Y) ? void 0 : Y._$litDirective$;
  return he?.constructor !== _e && ((fe = he?._$AO) == null || fe.call(he, !1), _e === void 0 ? he = void 0 : (he = new _e(le), he._$AT(le, re, oe)), oe !== void 0 ? (re._$Co ?? (re._$Co = []))[oe] = he : re._$Cl = he), he !== void 0 && (Y = S$2(le, he._$AS(le, Y.values), he, oe)), Y;
}
let M$2 = class {
  constructor(Y, re) {
    this._$AV = [], this._$AN = void 0, this._$AD = Y, this._$AM = re;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(Y) {
    const { el: { content: re }, parts: oe } = this._$AD, ue = (Y?.creationScope ?? r$5).importNode(re, !0);
    C$2.currentNode = ue;
    let fe = C$2.nextNode(), he = 0, _e = 0, ve = oe[0];
    for (; ve !== void 0; ) {
      if (he === ve.index) {
        let xe;
        ve.type === 2 ? xe = new R$1(fe, fe.nextSibling, this, Y) : ve.type === 1 ? xe = new ve.ctor(fe, ve.name, ve.strings, this, Y) : ve.type === 6 && (xe = new z$3(fe, this, Y)), this._$AV.push(xe), ve = oe[++_e];
      }
      he !== ve?.index && (fe = C$2.nextNode(), he++);
    }
    return C$2.currentNode = r$5, ue;
  }
  p(Y) {
    let re = 0;
    for (const oe of this._$AV)
      oe !== void 0 && (oe.strings !== void 0 ? (oe._$AI(Y, oe, re), re += oe.strings.length - 2) : oe._$AI(Y[re])), re++;
  }
}, R$1 = class _n {
  get _$AU() {
    var Y;
    return ((Y = this._$AM) == null ? void 0 : Y._$AU) ?? this._$Cv;
  }
  constructor(Y, re, oe, ue) {
    this.type = 2, this._$AH = E$3, this._$AN = void 0, this._$AA = Y, this._$AB = re, this._$AM = oe, this.options = ue, this._$Cv = ue?.isConnected ?? !0;
  }
  get parentNode() {
    let Y = this._$AA.parentNode;
    const re = this._$AM;
    return re !== void 0 && Y?.nodeType === 11 && (Y = re.parentNode), Y;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(Y, re = this) {
    Y = S$2(this, Y, re), c$3(Y) ? Y === E$3 || Y == null || Y === "" ? (this._$AH !== E$3 && this._$AR(), this._$AH = E$3) : Y !== this._$AH && Y !== T$4 && this._(Y) : Y._$litType$ !== void 0 ? this.$(Y) : Y.nodeType !== void 0 ? this.T(Y) : u$3(Y) ? this.k(Y) : this._(Y);
  }
  O(Y) {
    return this._$AA.parentNode.insertBefore(Y, this._$AB);
  }
  T(Y) {
    this._$AH !== Y && (this._$AR(), this._$AH = this.O(Y));
  }
  _(Y) {
    this._$AH !== E$3 && c$3(this._$AH) ? this._$AA.nextSibling.data = Y : this.T(r$5.createTextNode(Y)), this._$AH = Y;
  }
  $(Y) {
    var re;
    const { values: oe, _$litType$: ue } = Y, fe = typeof ue == "number" ? this._$AC(Y) : (ue.el === void 0 && (ue.el = N$3.createElement(P$3(ue.h, ue.h[0]), this.options)), ue);
    if (((re = this._$AH) == null ? void 0 : re._$AD) === fe)
      this._$AH.p(oe);
    else {
      const he = new M$2(fe, this), _e = he.u(this.options);
      he.p(oe), this.T(_e), this._$AH = he;
    }
  }
  _$AC(Y) {
    let re = A$3.get(Y.strings);
    return re === void 0 && A$3.set(Y.strings, re = new N$3(Y)), re;
  }
  k(Y) {
    a$3(this._$AH) || (this._$AH = [], this._$AR());
    const re = this._$AH;
    let oe, ue = 0;
    for (const fe of Y)
      ue === re.length ? re.push(oe = new _n(this.O(l$3()), this.O(l$3()), this, this.options)) : oe = re[ue], oe._$AI(fe), ue++;
    ue < re.length && (this._$AR(oe && oe._$AB.nextSibling, ue), re.length = ue);
  }
  _$AR(Y = this._$AA.nextSibling, re) {
    var oe;
    for ((oe = this._$AP) == null ? void 0 : oe.call(this, !1, !0, re); Y && Y !== this._$AB; ) {
      const ue = Y.nextSibling;
      Y.remove(), Y = ue;
    }
  }
  setConnected(Y) {
    var re;
    this._$AM === void 0 && (this._$Cv = Y, (re = this._$AP) == null || re.call(this, Y));
  }
}, k$3 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(Y, re, oe, ue, fe) {
    this.type = 1, this._$AH = E$3, this._$AN = void 0, this.element = Y, this.name = re, this._$AM = ue, this.options = fe, oe.length > 2 || oe[0] !== "" || oe[1] !== "" ? (this._$AH = Array(oe.length - 1).fill(new String()), this.strings = oe) : this._$AH = E$3;
  }
  _$AI(Y, re = this, oe, ue) {
    const fe = this.strings;
    let he = !1;
    if (fe === void 0)
      Y = S$2(this, Y, re, 0), he = !c$3(Y) || Y !== this._$AH && Y !== T$4, he && (this._$AH = Y);
    else {
      const _e = Y;
      let ve, xe;
      for (Y = fe[0], ve = 0; ve < fe.length - 1; ve++)
        xe = S$2(this, _e[oe + ve], re, ve), xe === T$4 && (xe = this._$AH[ve]), he || (he = !c$3(xe) || xe !== this._$AH[ve]), xe === E$3 ? Y = E$3 : Y !== E$3 && (Y += (xe ?? "") + fe[ve + 1]), this._$AH[ve] = xe;
    }
    he && !ue && this.j(Y);
  }
  j(Y) {
    Y === E$3 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, Y ?? "");
  }
}, H$3 = class extends k$3 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(Y) {
    this.element[this.name] = Y === E$3 ? void 0 : Y;
  }
}, I$2 = class extends k$3 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(Y) {
    this.element.toggleAttribute(this.name, !!Y && Y !== E$3);
  }
}, L$2 = class extends k$3 {
  constructor(Y, re, oe, ue, fe) {
    super(Y, re, oe, ue, fe), this.type = 5;
  }
  _$AI(Y, re = this) {
    if ((Y = S$2(this, Y, re, 0) ?? E$3) === T$4)
      return;
    const oe = this._$AH, ue = Y === E$3 && oe !== E$3 || Y.capture !== oe.capture || Y.once !== oe.once || Y.passive !== oe.passive, fe = Y !== E$3 && (oe === E$3 || ue);
    ue && this.element.removeEventListener(this.name, this, oe), fe && this.element.addEventListener(this.name, this, Y), this._$AH = Y;
  }
  handleEvent(Y) {
    var re;
    typeof this._$AH == "function" ? this._$AH.call(((re = this.options) == null ? void 0 : re.host) ?? this.element, Y) : this._$AH.handleEvent(Y);
  }
}, z$3 = class {
  constructor(Y, re, oe) {
    this.element = Y, this.type = 6, this._$AN = void 0, this._$AM = re, this.options = oe;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(Y) {
    S$2(this, Y);
  }
};
const j$4 = t$3.litHtmlPolyfillSupport;
j$4?.(N$3, R$1), (t$3.litHtmlVersions ?? (t$3.litHtmlVersions = [])).push("3.3.0");
const B$4 = (le, Y, re) => {
  const oe = re?.renderBefore ?? Y;
  let ue = oe._$litPart$;
  if (ue === void 0) {
    const fe = re?.renderBefore ?? null;
    oe._$litPart$ = ue = new R$1(Y.insertBefore(l$3(), fe), fe, void 0, re ?? {});
  }
  return ue._$AI(le), ue;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s$3 = globalThis;
let i$4 = class extends y$3 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var Y;
    const re = super.createRenderRoot();
    return (Y = this.renderOptions).renderBefore ?? (Y.renderBefore = re.firstChild), re;
  }
  update(Y) {
    const re = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(Y), this._$Do = B$4(re, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var Y;
    super.connectedCallback(), (Y = this._$Do) == null || Y.setConnected(!0);
  }
  disconnectedCallback() {
    var Y;
    super.disconnectedCallback(), (Y = this._$Do) == null || Y.setConnected(!1);
  }
  render() {
    return T$4;
  }
};
var pt;
i$4._$litElement$ = !0, i$4.finalized = !0, (pt = s$3.litElementHydrateSupport) == null || pt.call(s$3, { LitElement: i$4 });
const o$5 = s$3.litElementPolyfillSupport;
o$5?.({ LitElement: i$4 });
(s$3.litElementVersions ?? (s$3.litElementVersions = [])).push("4.2.0");
const activeTableStyle = i$3`
  /* this is used to shrink the width of the active-table element to the shadow-root width */
  :host {
    /* the following property prevents outside styles from affecting this component */
    all: initial;
    /* the following property is used to control the overall component width */
    display: inline-block;
  }

  table {
    border-spacing: 0px;
    position: relative;
    border: 1px solid #00000028;
    background-color: white;
  }

  /* REF-16 */
  .table-controlled-width {
    table-layout: fixed;
    /* fit-content does not work correctly in firefox when there are not enough columns to fit parent */
    width: min-content;
  }

  tbody {
    border-radius: inherit;
  }

  tbody > .row:first-child > *:first-child {
    border-top-left-radius: inherit;
  }

  /* using last-of-type as the last element is a divider which does not help with corner rounding */
  tbody > .row:first-child > .cell:last-of-type {
    border-top-right-radius: inherit;
  }

  #last-visible-row > *:first-child {
    border-bottom-left-radius: inherit;
  }

  #last-visible-row > .cell:last-of-type {
    border-bottom-right-radius: inherit;
  }

  .row {
    color: rgba(0, 0, 0, 0.87);
    font-size: 13px;
    font-weight: 400;
    /* the following is not supported in Firefox (on rows), hence rowHoverStyles will not have the border */
    border-radius: inherit;
  }

  tbody > .row:first-child {
    position: relative;
  }

  .row > *:first-child {
    border-left: none !important;
  }

  .row > .cell:last-of-type {
    border-right: none !important;
  }

  /* REF-25 */
  #last-visible-row > .cell {
    border-bottom: none !important;
  }

  .cell {
    text-align: left;
    padding: 11px 6px 6px;
    font-size: 14px;
    line-height: 17px;
    height: 42.5px;
    box-sizing: border-box;
    outline: none;
    overflow-wrap: anywhere;
    font-size: inherit;
    font-weight: inherit;
    border-bottom-style: solid;
    border-bottom-width: 1px;
    border-bottom-color: rgba(0, 0, 0, 0.12);
    vertical-align: top;
    text-align: left;
    border-right: 1px solid #00000021;
    color: #222222;
  }

  .cell-text-div {
    outline: none;
    overflow-wrap: anywhere;
    border-radius: 4px;
    width: fit-content;
    /* need padding for the cursor to show up */
    padding-left: 1px;
  }

  .select-cell-text {
    float: left;
  }

  .arrow-down-icon-container {
    position: relative;
  }

  .arrow-down-icon {
    position: absolute;
    right: 2px;
    top: 5px;
    text-align: center;
    cursor: pointer;
  }

  .label-cell-text {
    padding-left: 6px;
    padding-right: 6px;
    padding-top: 2px;
    padding-bottom: 2px;
  }

  .cell-divider {
    position: absolute;
    display: flex;
    justify-content: center;
  }

  .cell-divider > * {
    user-select: none;
    /* safari */
    -webkit-user-select: none;
    position: absolute;
    cursor: col-resize;
    justify-content: center;
    height: inherit;
  }

  /* this class needs to be after .cell to have style precendence */
  /* REF-1 */
  .header-cell {
    border-top: none !important;
    cursor: pointer;
    color: #626262;
    padding-top: 12px;
    padding-bottom: 12px;
    font-weight: 500;
  }

  .header-icon-container {
    float: left;
    pointer-events: none;
    /* the height is set to allow the text to be present below the icon when there is not enough space in the cell */
    height: 15px;
  }

  .header-icon-side-text {
    /* cannot use flex as pressing ENTER creates a new div */
    /* cannot use grid as it does not align in Safari */
    display: table-cell;
  }

  .not-selectable {
    user-select: none;
    /* safari */
    -webkit-user-select: none;
  }

  .column-sizer {
    /* need z-index for the sizer to display over header icon */
    z-index: 1;
    background-size: 20px 5px;
    position: absolute;
  }

  .column-sizer-filler {
    height: inherit;
    position: absolute;
    pointer-events: none;
  }

  .column-sizer-overlay {
    background-color: #ff000001;
    z-index: 1;
  }

  .movable-column-sizer {
    z-index: 1;
  }

  .movable-column-sizer-vertical-line {
    width: 1px;
    pointer-events: none;
  }

  #add-new-row-cell {
    padding-top: 8px;
    padding-left: 17px;
    min-height: 28px;
    line-height: 18px;
    font-size: 12px;
    color: #555555;
    vertical-align: middle;
    cursor: pointer;
  }

  .index-cell {
    text-align: center;
    padding: 11px 4px 0px !important;
  }

  .index-cell-overflow {
    overflow: hidden;
    overflow-wrap: normal;
  }

  #temp-invisible-index-number {
    color: #e2e2e200 !important;
  }

  .add-column-cell {
    cursor: pointer;
    text-align: center;
  }

  .header-cell-clone {
    position: absolute;
    cursor: move;
    top: 0px;
  }

  .header-cell-clone-animation {
    transition: 0.25s ease-out;
  }

  .cell-hidden {
    opacity: 0 !important;
  }

  .row-clone {
    position: absolute;
    display: flex;
    opacity: 0.8s;
  }

  .row-clone > * {
    cursor: move !important;
  }

  .row-drag-target-line {
    height: 4px;
    width: 100%;
    position: absolute;
    background-color: #69b0ff;
    pointer-events: none;
  }

  .root-cell {
    text-align: center;
    padding: 0px !important;
    border: none !important;
    // inheriting border radius as when frame components style background is set (add new row component), table border
    // radius is visibly not inherited
    border-radius: inherit;
  }

  .active-table-dropdown {
    position: absolute;
    box-shadow: rgb(15 15 15 / 5%) 0px 0px 0px 1px, rgb(15 15 15 / 10%) 0px 3px 6px, rgb(15 15 15 / 20%) 0px 9px 24px;
    border-radius: 5px;
    background-color: white;
    z-index: 1;
  }

  .active-table-dropup {
    box-shadow: rgba(15, 15, 15, 0.05) 0px 0px 0px 1px, rgba(15, 15, 15, 0.1) 0px 3px 6px,
      rgba(15, 15, 15, 0.2) 0px -2px 24px;
    top: unset !important;
    bottom: 100%;
  }

  .cell-dropdown {
    overflow: auto;
    white-space: nowrap;
  }

  .cell-dropdown::-webkit-scrollbar {
    width: 9px;
    height: 9px;
  }

  .cell-dropdown::-webkit-scrollbar-thumb {
    background-color: #aaaaaa;
    border-radius: 5px;
  }

  .cell-dropdown::-webkit-scrollbar-track {
    background-color: #f2f2f2;
  }

  .dropdown-item {
    padding-top: 3px;
    padding-bottom: 3px;
    padding-right: 5px;
    padding-left: 5px;
    color: #4b4b4b;
    position: relative;
    cursor: pointer;
    /* retaining the outline for dropdown input to make it easier to recognise */
    outline: none;
    font-size: 15px;
  }

  .cell-dropdown > .dropdown-item {
    /* the height of cell dropdown items seem to change depending on monitor size which inconsistently triggers overflow,
    this sets it to be consistent but ideally we should not do this and use a different way to allow any font sizes */
    height: 18px;
  }

  .dropdown-item-icon-container {
    display: flex;
    float: left;
    height: 90%;
    align-items: initial;
    padding-top: 2px;
    /* if items are not aligned in center - change align-items to center and revert changes
      in 0805a911cd5c7921aa05b13ffb9387d3d996c133 */
  }

  .dropdown-title-item {
    cursor: default;
    color: #7c7c7c;
    font-weight: 600;
    font-size: 0.75rem;
    margin-top: 2px;
  }

  .dropdown-input-item {
    text-align: center;
  }

  .dropdown-input {
    width: 92%;
    border: 1px solid grey;
    border-radius: 2px;
    color: #2d2d2d;
    font-size: 14px;
    padding: 3px;
    padding-top: 4px;
  }

  .dropdown-item-divider {
    border-bottom: 1px solid #d4d4d4;
    margin-top: 2px;
    margin-bottom: 2px;
  }

  .dropdown-highlightable-item:hover {
    background-color: #eaeaea;
  }

  .active-dropdown-item {
    background-color: #4a69d4;
    color: white;
  }

  /* using different class as standard dropdowns use above class in their functionality */
  .active-static-dropdown-item {
    background-color: #4a69d4;
    color: white;
  }

  .active-dropdown-item:focus {
    background-color: #2148d5 !important;
    color: white !important;
  }

  /* Do not want to set default height incase user has set a font or a font-family so
    setting a placeholder text and making it invisible */
  .dropdown-item-empty {
    color: #ffffae00 !important;
  }

  .dropdown-disabled-item {
    pointer-events: none;
    color: #9e9e9e8a;
  }

  .cell-dropdown-option-button-container {
    position: absolute;
    width: 100%;
    height: 0px;
    top: 5px;
    left: -5px;
    display: none;
  }

  .cell-dropdown-option-button {
    height: 13px;
    width: 13px;
    position: sticky;
    z-index: 1;
    border-radius: 12px;
    opacity: 0.3;
    background-color: white;
  }

  .cell-dropdown-option-button:hover {
    opacity: 1;
  }

  .cell-dropdown-option-button:active {
    background-color: #f8f8f8;
  }

  .cell-dropdown-option-button > div {
    font-size: 12px;
    height: 11px;
    pointer-events: none;
    color: black;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .cell-dropdown-option-delete-button-icon {
    font-size: 12.5px;
    width: 13px;
  }

  .cell-dropdown-option-color-button-icon {
    width: 12.5px;
  }

  .outer-container-dropdown {
    z-index: 2;
  }

  .color-input {
    width: 0px;
    height: 0px;
    padding: 0px;
    position: absolute;
    outline: none;
    pointer-events: none;
    opacity: 0;
    /* border unset stops color picker panel from appearing in safari */
  }

  .date-input-container {
    position: relative;
    float: right;
    cursor: pointer;
  }

  .date-input {
    top: 17px;
    width: 0px;
    height: 0px;
    border: unset;
    padding: 0px;
    right: 9px;
    position: absolute;
    outline: none;
  }

  .calender-icon-container {
    position: absolute;
    right: 2px;
    top: -4px;
    width: 15px;
    height: 25px;
    text-align: center;
  }

  #full-table-overlay {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100%;
  }

  #drag-and-drop-overlay {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100%;
    height: calc(100% - 10px);
    width: calc(100% - 10px);
    background-color: #70c6ff4d;
    border: 5px dashed #6dafff;
    display: none;
    z-index: 2;
  }

  .filter-hidden-row {
    display: none;
  }

  .dropdown-cell-overlay {
    cursor: pointer;
    background-color: grey;
  }

  .column-dropdown-cell-overlay {
    transition: height 0.2s;
    border-bottom-left-radius: 2px;
    border-bottom-right-radius: 2px;
  }

  .row-dropdown-cell-overlay {
    transition: width 0.2s;
    border-top-right-radius: 2px;
    border-bottom-right-radius: 2px;
  }

  #pagination-button-container {
    right: 0;
    display: flex;
    width: fit-content;
    height: fit-content;
  }

  .pagination-button {
    border: 1px solid #0000004d;
    border-right: unset;
    color: #353535;
    min-width: 31px;
    height: 30.5px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 15.5px;
    /* REF-40 */
    stroke: black;
  }

  .pagination-prev-next-button {
    width: 14.25px;
    padding-left: 4px;
  }

  .pagination-first-last-button {
    width: 13px;
  }

  .pagination-button > * {
    pointer-events: none;
  }

  .pagination-button-disabled {
    pointer-events: none;
    color: #7c7c7c;
    /* REF-40 */
    stroke: #7c7c7c;
  }

  .pagination-button > svg > path {
    /* REF-40 */
    stroke: inherit;
  }

  #pagination-number-of-visible-rows {
    padding-top: 6px;
    color: #252525;
    min-width: 82px;
    text-align: center;
    font-size: 15.5px;
    padding-top: 7.5px;
  }

  #pagination-number-of-rows-select {
    position: relative;
    color: #1d1d1d;
    min-width: max-content;
  }

  #pagination-number-of-rows-select-text {
    font-size: 15.5px;
    float: left;
    margin-top: 6px;
  }

  #rows-per-page-select-button {
    display: inline-block;
    background-color: white;
    border: 1px solid #0000004d;
    border-radius: 4px;
    height: 24px;
    padding-top: 3px;
    padding-bottom: 0.5px;
    padding-left: 6px;
    padding-right: 1px;
    margin-top: 1px;
    cursor: pointer;
  }

  .outer-dropdown-button-arrow-container {
    pointer-events: none;
    color: #353535;
    font-size: 16px;
    float: right;
    margin: 1px;
    margin-left: -1px;
    width: 19px;
  }

  .outer-dropdown-button-arrow-icon {
    width: 16px;
    transform: scale(0.9, 1);
    filter: brightness(0) saturate(100%) invert(11%) sepia(3%) saturate(99%) hue-rotate(157deg) brightness(97%)
      contrast(98%);
    padding-top: 2px;
    padding-left: 2px;
  }

  #rows-per-page-select-button-text {
    display: inline-block;
    pointer-events: none;
    padding-top: 1px;
  }

  .number-of-rows-dropdown-item {
    padding-right: 12.5px;
    text-align: right;
  }

  .file-button-container {
    position: relative;
  }

  .file-button {
    border: 1px solid #00000038;
    border-radius: 3px;
    color: #464646;
    text-align: center;
    cursor: pointer;
    user-select: none;
    background-color: #f8f8f9;
    font-size: 14.5px;
    align-items: center;
    display: flex;
    height: 29px;
    padding: 0px 10px 1px;
  }

  .file-button-arrow-container {
    margin-right: -5px;
  }

  .file-button-arrow-container-icon {
    width: 17px;
    padding-top: 5px;
  }

  .export-formats-dropdown-item {
    padding: 4px 10px;
    font-size: 14.5px;
  }

  .hidden-row {
    line-height: 0px;
    height: 0px !important;
    user-select: none;
    pointer-events: none;
  }

  .hidden-row > * {
    line-height: 0px;
    height: 0px;
    padding: 0px !important;
    font-size: 0px;
    border-bottom-width: 0px !important;
  }

  .hidden-row > th > * {
    display: none;
  }

  .outer-container {
    display: grid;
    position: relative;
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  #outer-top-container > div > div > div > * {
    margin-bottom: 13px;
  }

  #outer-bottom-container > div > div > div > * {
    margin-top: 13px;
  }

  /* REF-38 */
  .outer-container-column {
    display: flex;
    width: 0px;
  }

  .outer-container-column-inner {
    display: flex;
  }

  .outer-container-column-content {
    display: flex;
    /* use -webkit-max-content if the below does not work */
    width: max-content;
  }

  .outer-container-left-column .outer-container-column-content > div {
    margin-right: 10px;
  }

  .outer-container-center-column {
    justify-content: center;
    position: absolute;
  }

  .outer-container-center-column .outer-container-column-content > div {
    margin-left: 5px;
    margin-right: 5px;
  }

  .outer-container-right-column {
    justify-content: end;
  }

  .outer-container-right-column .outer-container-column-content > div {
    margin-left: 10px;
  }

  /* right sibling */
  .pagination-button-active-precedence + div {
    border-left-color: #fafafa01 !important;
  }

  .sticky-header-body > *:first-child {
    top: 0;
    position: sticky !important;
  }

  .sticky-header-body > *:first-child > th {
    background-color: white;
  }

  #overflow-container {
    border: 1px solid #00000026;
  }

  /* REF-37 */
  .no-overflow-sticky-header-body {
    border-top: 1px solid #00000026;
  }

  /* REF-37 */
  .no-overflow-sticky-header-body > *:first-child {
    border-top: inherit;
  }

  /* REF-37 */
  .no-overflow-sticky-header-body > *:first-child > th {
    border-top: inherit !important;
  }

  .filter-rows-container {
    position: relative;
  }

  .filter-rows-input {
    width: 150px;
    height: 20px;
    border: 1px solid #0000002b;
    border-radius: 4px;
    color: rgb(45, 45, 45);
    font-family: inherit;
    padding: 5px 6px;
    font-size: 14px;
  }

  .filter-rows-input::placeholder {
    color: var(--active-table-filter-placeholder-color);
  }

  .filter-rows-dropdown-button {
    position: absolute;
    right: 4px;
    top: 51.6%;
    transform: translateY(-50%);
    cursor: pointer;
    user-select: none;
    filter: brightness(0) saturate(100%) invert(49%) sepia(0%) saturate(974%) hue-rotate(66deg) brightness(97%)
      contrast(96%);
    width: 16px;
    height: 16px;
  }

  .filter-rows-dropdown-button + .filter-rows-case-button {
    right: 15px;
  }

  .filter-rows-case-button + .filter-rows-input {
    padding-right: 30px;
    width: 129px;
  }

  .filter-rows-dropdown-button + .filter-rows-input {
    padding-right: 22px;
    width: 137px;
  }

  .filter-rows-dropdown-button + .filter-rows-case-button + .filter-rows-input {
    padding-right: 45px;
    width: 114px;
  }

  .filter-rows-case-button {
    position: absolute;
    right: 0px;
    top: 49%;
    transform: translate(-50%, -50%);
    color: grey;
    font-size: 13px;
    cursor: pointer;
    user-select: none;
  }

  .filter-rows-dropdown {
    min-width: 100% !important;
    width: max-content !important;
  }

  .filter-rows-dropdown > .dropdown-item {
    padding-left: 8px;
    padding-right: 8px;
    padding-top: 4px;
    padding-bottom: 4px;
  }

  .default-loading-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 400px;
    width: 400px;
    border: 1px solid grey;
  }

  .loading-container-absolute {
    position: absolute;
    top: 0;
    height: 100%;
    width: 100%;
  }

  .absolute-container {
    position: absolute;
    top: 0;
    height: 100%;
    width: 100%;
  }

  .loading-spinner {
    width: 60px;
    height: 60px;
    border: 5px solid #38a4ff;
    border-bottom-color: transparent;
    border-radius: 50%;
    display: inline-block;
    box-sizing: border-box;
    animation: rotation 1s linear infinite;
  }

  #error-container {
    position: absolute;
    top: 0;
    height: 100%;
    width: 100%;
    background-color: #ff000006;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #error-text {
    font-size: 24px;
    color: red;
  }

  @keyframes rotation {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
`;
var __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __decorateClass = (le, Y, re, oe) => {
  for (var ue = oe > 1 ? void 0 : oe ? __getOwnPropDesc(Y, re) : Y, fe = le.length - 1, he; fe >= 0; fe--)
    (he = le[fe]) && (ue = (oe ? he(Y, re, ue) : he(ue)) || ue);
  return oe && ue && __defProp(Y, re, ue), ue;
};
let ActiveTable = class extends i$4 {
  constructor() {
    super(), this.getData = () => JSON.parse(JSON.stringify(this.data)), this.getColumnsDetails = () => ColumnDetailsUtils.getAllColumnsDetails(this._columnsDetails), this.updateCell = (le) => {
      ProgrammaticCellUpdate.updateText(this, le);
    }, this.updateStructure = (le) => {
      ProgrammaticStructureUpdate.update(this, le);
    }, this.updateData = (le) => {
      UpdateAllTableData.update(this, le, 0);
    }, this.importFile = (le) => FileImportButtonEvents.triggerImportPrompt(this, le), this.exportFile = (le) => FileExportEvents.export(this, le), this.onCellUpdate = () => {
    }, this.onDataUpdate = () => {
    }, this.onColumnsUpdate = () => {
    }, this.onRender = () => {
    }, this.data = [
      // ['Planet', 'Diameter', 'Mass', 'Moons', 'Density'],
      // ['Earth', 12756, 5.97, 1, 5514],
      // ['Mars', 6792, 0.642, 2, 3934],
      // ['Jupiter', 142984, 1898, 79, 1326],
      // ['Saturn', 120536, 568, 82, 687],
      // ['Neptune', 49528, 102, 14, 1638],
    ], this.tableStyle = {}, this.allowDuplicateHeaders = !0, this.displayHeaderIcons = !0, this.spellCheck = !1, this.customColumnsSettings = [], this.dragRows = !0, this.dragColumns = !0, this.preserveNarrowColumns = !0, this.displayAddNewRow = !0, this.displayAddNewColumn = !0, this.displayIndexColumn = { wrapIndexCellText: !1 }, this.frameComponentsStyles = {}, this.dataStartsAtHeader = !1, this.columnResizerColors = {}, this.rowDropdown = { displaySettings: { isAvailable: !0, openMethod: { cellClick: !0 } } }, this.enterKeyMoveDown = !1, this._stickyProps = { header: !1 }, this._defaultColumnsSettings = {}, this._customColumnsSettings = {}, this._columnsDetails = [], this._addColumnCellsElementsRef = [], this._focusedElements = FocusedElementsUtils.createEmpty(), this._hoveredElements = {}, this._activeOverlayElements = ActiveOverlayElementsUtils.createNew(), this._eventFunctions = ElementEvents.getDefault(), this._userKeyEventsState = UserKeyEventsStateUtils.createNew(), this._tableDimensions = TableDimensionsUtils.getDefault(), this._globalItemColors = LabelColorUtils.generateGlobalItemColors(), this._defaultCellHoverColors = CellHighlightUtils.getDefaultHoverProperties(), this._frameComponents = FrameComponentsInternalUtils.getDefault(), this._rowDropdownCellOverlays = [], this._pagination = PaginationInternalUtils.getDefault(), this._files = FilesUtils.createDefault(this), this._visiblityInternal = {}, this._isRendering = !1, this._isPopulatingTable = !1, GoogleFont.appendStyleSheetToHead();
  }
  // CAUTION-4
  render() {
    Render.renderTable(this), this.onDataUpdate(this.data), new ResizeObserver(ParentResize.resizeCallback.bind(this)).observe(this.parentElement), FireEvents.onRender(this);
  }
  async update(le) {
    var Y, re;
    PaginationAsyncUtils.preprocessTablePropertiesIfAsync(this), this._isPopulatingTable = !0, StickyPropsUtils.process(this), ColumnSettingsUtils.setUpInternalSettings(this), FrameComponentsInternalUtils.set(this), DefaultColumnTypes.createDropdownItemsForDefaultTypes(), RowDropdownSettingsUtil.process(this), this.pagination && await PaginationInternalUtils.process(this), this.stripedRows && StripedRows.process(this), this.rowHoverStyles && RowHoverEvents.process(this.rowHoverStyles, this._defaultCellHoverColors);
    const oe = TableElement.createInfrastructureElements(this);
    this.overflow && OverflowUtils.setupContainer(this, oe), TableElement.addOverlayElements(this, oe, this._activeOverlayElements), PaginationAsyncUtils.removeLoadingOverlay(this), (re = this.shadowRoot) == null || re.appendChild(((Y = this._overflow) == null ? void 0 : Y.overflowContainer) || oe), OuterTableComponents.create(this), InitialDataProcessing.preProcess(this, this.data), WindowElement.setEvents(this), this.spellcheck = this.spellCheck, this.auxiliaryStyle && this.shadowRoot && WebComponentStyleUtils.add(this.auxiliaryStyle, this.shadowRoot), setTimeout(() => this._isPopulatingTable = !1, 1), super.update(le);
  }
  connectedCallback() {
    Browser.IS_FIREFOX ? setTimeout(() => super.connectedCallback()) : super.connectedCallback();
  }
  // this is used to prevent a bug where the update method is called again (and adds another table) when a new property is
  // added - e.g. an event listener method
  shouldUpdate() {
    return !this._tableElementRef;
  }
};
ActiveTable._ELEMENT_TAG = "ACTIVE-TABLE";
ActiveTable.styles = [activeTableStyle];
__decorateClass([
  n$1$1({ attribute: !1 })
], ActiveTable.prototype, "getData", 2);
__decorateClass([
  n$1$1({ attribute: !1 })
], ActiveTable.prototype, "getColumnsDetails", 2);
__decorateClass([
  n$1$1({ attribute: !1 })
], ActiveTable.prototype, "updateCell", 2);
__decorateClass([
  n$1$1({ attribute: !1 })
], ActiveTable.prototype, "updateStructure", 2);
__decorateClass([
  n$1$1({ attribute: !1 })
], ActiveTable.prototype, "updateData", 2);
__decorateClass([
  n$1$1({ attribute: !1 })
], ActiveTable.prototype, "importFile", 2);
__decorateClass([
  n$1$1({ attribute: !1 })
], ActiveTable.prototype, "exportFile", 2);
__decorateClass([
  n$1$1({ converter: LITElementTypeConverters.convertToFunction })
], ActiveTable.prototype, "onCellUpdate", 2);
__decorateClass([
  n$1$1({ converter: LITElementTypeConverters.convertToFunction })
], ActiveTable.prototype, "onDataUpdate", 2);
__decorateClass([
  n$1$1({ converter: LITElementTypeConverters.convertToFunction })
], ActiveTable.prototype, "onColumnsUpdate", 2);
__decorateClass([
  n$1$1({ converter: LITElementTypeConverters.convertToFunction })
], ActiveTable.prototype, "onRender", 2);
__decorateClass([
  n$1$1({ type: Array })
], ActiveTable.prototype, "data", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "tableStyle", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "allowDuplicateHeaders", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "displayHeaderIcons", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "spellCheck", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "stickyHeader", 2);
__decorateClass([
  n$1$1({ type: Array })
], ActiveTable.prototype, "customColumnsSettings", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "rowHoverStyles", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "dragRows", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "dragColumns", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "preserveNarrowColumns", 2);
__decorateClass([
  n$1$1({ type: Number })
], ActiveTable.prototype, "maxColumns", 2);
__decorateClass([
  n$1$1({ type: Number })
], ActiveTable.prototype, "maxRows", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "displayAddNewRow", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "displayAddNewColumn", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "displayIndexColumn", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "frameComponentsStyles", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "dataStartsAtHeader", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "columnResizerColors", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "rowDropdown", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "stripedRows", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "overflow", 2);
__decorateClass([
  n$1$1({ type: String })
], ActiveTable.prototype, "defaultText", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "isDefaultTextRemovable", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "cellStyle", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "rootCell", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "isCellTextEditable", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "headerStyles", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "isHeaderTextEditable", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "headerIconStyle", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "isColumnResizable", 2);
__decorateClass([
  n$1$1({ type: Array })
], ActiveTable.prototype, "availableDefaultColumnTypes", 2);
__decorateClass([
  n$1$1({ type: Array })
], ActiveTable.prototype, "customColumnTypes", 2);
__decorateClass([
  n$1$1({ type: String })
], ActiveTable.prototype, "defaultColumnTypeName", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "columnDropdown", 2);
__decorateClass([
  n$1$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "enterKeyMoveDown", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "pagination", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "loadingStyles", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "files", 2);
__decorateClass([
  n$1$1({ type: Object })
], ActiveTable.prototype, "filter", 2);
__decorateClass([
  n$1$1({ type: String })
], ActiveTable.prototype, "auxiliaryStyle", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_stickyProps", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_defaultColumnsSettings", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_customColumnsSettings", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_columnsDetails", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_tableElementRef", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_tableBodyElementRef", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_addRowCellElementRef", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_addColumnCellsElementsRef", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_focusedElements", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_hoveredElements", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_activeOverlayElements", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_eventFunctions", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_userKeyEventsState", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_tableDimensions", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_cellDropdownContainer", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_globalItemColors", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_defaultCellHoverColors", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_frameComponents", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_rowDropdownCellOverlays", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_stripedRows", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_overflow", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_pagination", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_files", 2);
__decorateClass([
  r$1$1()
], ActiveTable.prototype, "_visiblityInternal", 2);
__decorateClass([
  r$1$1({
    hasChanged() {
      return !1;
    }
  })
], ActiveTable.prototype, "_isRendering", 2);
__decorateClass([
  r$1$1({
    hasChanged() {
      return !1;
    }
  })
], ActiveTable.prototype, "_isPopulatingTable", 2);
ActiveTable = __decorateClass([
  t$2("active-table")
], ActiveTable);
var papaparse_min$1 = { exports: {} };
/* @license
Papa Parse
v5.5.3
https://github.com/mholt/PapaParse
License: MIT
*/
var papaparse_min = papaparse_min$1.exports, hasRequiredPapaparse_min;
function requirePapaparse_min() {
  return hasRequiredPapaparse_min || (hasRequiredPapaparse_min = 1, function(le, Y) {
    ((re, oe) => {
      le.exports = oe();
    })(papaparse_min, function re() {
      var oe = typeof self < "u" ? self : typeof window < "u" ? window : oe !== void 0 ? oe : {}, ue, fe = !oe.document && !!oe.postMessage, he = oe.IS_PAPA_WORKER || !1, _e = {}, ve = 0, xe = {};
      function Ee($e) {
        this._handle = null, this._finished = !1, this._completed = !1, this._halted = !1, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = { data: [], errors: [], meta: {} }, function(De) {
          var Ke = He(De);
          Ke.chunkSize = parseInt(Ke.chunkSize), De.step || De.chunk || (Ke.chunkSize = null), this._handle = new Ne(Ke), (this._handle.streamer = this)._config = Ke;
        }.call(this, $e), this.parseChunk = function(De, Ke) {
          var ze = parseInt(this._config.skipFirstNLines) || 0;
          if (this.isFirstChunk && 0 < ze) {
            let Xe = this._config.newline;
            Xe || (tt = this._config.quoteChar || '"', Xe = this._handle.guessLineEndings(De, tt)), De = [...De.split(Xe).slice(ze)].join(Xe);
          }
          this.isFirstChunk && Ve(this._config.beforeFirstChunk) && (tt = this._config.beforeFirstChunk(De)) !== void 0 && (De = tt), this.isFirstChunk = !1, this._halted = !1;
          var ze = this._partialLine + De, tt = (this._partialLine = "", this._handle.parse(ze, this._baseIndex, !this._finished));
          if (!this._handle.paused() && !this._handle.aborted()) {
            if (De = tt.meta.cursor, ze = (this._finished || (this._partialLine = ze.substring(De - this._baseIndex), this._baseIndex = De), tt && tt.data && (this._rowCount += tt.data.length), this._finished || this._config.preview && this._rowCount >= this._config.preview), he) oe.postMessage({ results: tt, workerId: xe.WORKER_ID, finished: ze });
            else if (Ve(this._config.chunk) && !Ke) {
              if (this._config.chunk(tt, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = !0);
              this._completeResults = tt = void 0;
            }
            return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(tt.data), this._completeResults.errors = this._completeResults.errors.concat(tt.errors), this._completeResults.meta = tt.meta), this._completed || !ze || !Ve(this._config.complete) || tt && tt.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0), ze || tt && tt.meta.paused || this._nextChunk(), tt;
          }
          this._halted = !0;
        }, this._sendError = function(De) {
          Ve(this._config.error) ? this._config.error(De) : he && this._config.error && oe.postMessage({ workerId: xe.WORKER_ID, error: De, finished: !1 });
        };
      }
      function Se($e) {
        var De;
        ($e = $e || {}).chunkSize || ($e.chunkSize = xe.RemoteChunkSize), Ee.call(this, $e), this._nextChunk = fe ? function() {
          this._readChunk(), this._chunkLoaded();
        } : function() {
          this._readChunk();
        }, this.stream = function(Ke) {
          this._input = Ke, this._nextChunk();
        }, this._readChunk = function() {
          if (this._finished) this._chunkLoaded();
          else {
            if (De = new XMLHttpRequest(), this._config.withCredentials && (De.withCredentials = this._config.withCredentials), fe || (De.onload = Ge(this._chunkLoaded, this), De.onerror = Ge(this._chunkError, this)), De.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !fe), this._config.downloadRequestHeaders) {
              var Ke, ze = this._config.downloadRequestHeaders;
              for (Ke in ze) De.setRequestHeader(Ke, ze[Ke]);
            }
            var tt;
            this._config.chunkSize && (tt = this._start + this._config.chunkSize - 1, De.setRequestHeader("Range", "bytes=" + this._start + "-" + tt));
            try {
              De.send(this._config.downloadRequestBody);
            } catch (Xe) {
              this._chunkError(Xe.message);
            }
            fe && De.status === 0 && this._chunkError();
          }
        }, this._chunkLoaded = function() {
          De.readyState === 4 && (De.status < 200 || 400 <= De.status ? this._chunkError() : (this._start += this._config.chunkSize || De.responseText.length, this._finished = !this._config.chunkSize || this._start >= ((Ke) => (Ke = Ke.getResponseHeader("Content-Range")) !== null ? parseInt(Ke.substring(Ke.lastIndexOf("/") + 1)) : -1)(De), this.parseChunk(De.responseText)));
        }, this._chunkError = function(Ke) {
          Ke = De.statusText || Ke, this._sendError(new Error(Ke));
        };
      }
      function Te($e) {
        ($e = $e || {}).chunkSize || ($e.chunkSize = xe.LocalChunkSize), Ee.call(this, $e);
        var De, Ke, ze = typeof FileReader < "u";
        this.stream = function(tt) {
          this._input = tt, Ke = tt.slice || tt.webkitSlice || tt.mozSlice, ze ? ((De = new FileReader()).onload = Ge(this._chunkLoaded, this), De.onerror = Ge(this._chunkError, this)) : De = new FileReaderSync(), this._nextChunk();
        }, this._nextChunk = function() {
          this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
        }, this._readChunk = function() {
          var tt = this._input, Xe = (this._config.chunkSize && (Xe = Math.min(this._start + this._config.chunkSize, this._input.size), tt = Ke.call(tt, this._start, Xe)), De.readAsText(tt, this._config.encoding));
          ze || this._chunkLoaded({ target: { result: Xe } });
        }, this._chunkLoaded = function(tt) {
          this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(tt.target.result);
        }, this._chunkError = function() {
          this._sendError(De.error);
        };
      }
      function Ce($e) {
        var De;
        Ee.call(this, $e = $e || {}), this.stream = function(Ke) {
          return De = Ke, this._nextChunk();
        }, this._nextChunk = function() {
          var Ke, ze;
          if (!this._finished) return Ke = this._config.chunkSize, De = Ke ? (ze = De.substring(0, Ke), De.substring(Ke)) : (ze = De, ""), this._finished = !De, this.parseChunk(ze);
        };
      }
      function Ie($e) {
        Ee.call(this, $e = $e || {});
        var De = [], Ke = !0, ze = !1;
        this.pause = function() {
          Ee.prototype.pause.apply(this, arguments), this._input.pause();
        }, this.resume = function() {
          Ee.prototype.resume.apply(this, arguments), this._input.resume();
        }, this.stream = function(tt) {
          this._input = tt, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
        }, this._checkIsFinished = function() {
          ze && De.length === 1 && (this._finished = !0);
        }, this._nextChunk = function() {
          this._checkIsFinished(), De.length ? this.parseChunk(De.shift()) : Ke = !0;
        }, this._streamData = Ge(function(tt) {
          try {
            De.push(typeof tt == "string" ? tt : tt.toString(this._config.encoding)), Ke && (Ke = !1, this._checkIsFinished(), this.parseChunk(De.shift()));
          } catch (Xe) {
            this._streamError(Xe);
          }
        }, this), this._streamError = Ge(function(tt) {
          this._streamCleanUp(), this._sendError(tt);
        }, this), this._streamEnd = Ge(function() {
          this._streamCleanUp(), ze = !0, this._streamData("");
        }, this), this._streamCleanUp = Ge(function() {
          this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
        }, this);
      }
      function Ne($e) {
        var De, Ke, ze, tt, Xe = Math.pow(2, 53), mt = -Xe, at = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, qe = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, st = this, xt = 0, gt = 0, Ze = !1, _t = !1, wt = [], yt = { data: [], errors: [], meta: {} };
        function St(Be) {
          return $e.skipEmptyLines === "greedy" ? Be.join("").trim() === "" : Be.length === 1 && Be[0].length === 0;
        }
        function It() {
          if (yt && ze && (Ye("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + xe.DefaultDelimiter + "'"), ze = !1), $e.skipEmptyLines && (yt.data = yt.data.filter(function(it) {
            return !St(it);
          })), Bt()) {
            let it = function(bt, rt) {
              Ve($e.transformHeader) && (bt = $e.transformHeader(bt, rt)), wt.push(bt);
            };
            if (yt) if (Array.isArray(yt.data[0])) {
              for (var Be = 0; Bt() && Be < yt.data.length; Be++) yt.data[Be].forEach(it);
              yt.data.splice(0, 1);
            } else yt.data.forEach(it);
          }
          function et(it, bt) {
            for (var rt = $e.header ? {} : [], Ct = 0; Ct < it.length; Ct++) {
              var Rt = Ct, Ot = it[Ct], Ot = ((Mt, Dt) => ((Vt) => ($e.dynamicTypingFunction && $e.dynamicTyping[Vt] === void 0 && ($e.dynamicTyping[Vt] = $e.dynamicTypingFunction(Vt)), ($e.dynamicTyping[Vt] || $e.dynamicTyping) === !0))(Mt) ? Dt === "true" || Dt === "TRUE" || Dt !== "false" && Dt !== "FALSE" && (((Vt) => {
                if (at.test(Vt) && (Vt = parseFloat(Vt), mt < Vt && Vt < Xe))
                  return 1;
              })(Dt) ? parseFloat(Dt) : qe.test(Dt) ? new Date(Dt) : Dt === "" ? null : Dt) : Dt)(Rt = $e.header ? Ct >= wt.length ? "__parsed_extra" : wt[Ct] : Rt, Ot = $e.transform ? $e.transform(Ot, Rt) : Ot);
              Rt === "__parsed_extra" ? (rt[Rt] = rt[Rt] || [], rt[Rt].push(Ot)) : rt[Rt] = Ot;
            }
            return $e.header && (Ct > wt.length ? Ye("FieldMismatch", "TooManyFields", "Too many fields: expected " + wt.length + " fields but parsed " + Ct, gt + bt) : Ct < wt.length && Ye("FieldMismatch", "TooFewFields", "Too few fields: expected " + wt.length + " fields but parsed " + Ct, gt + bt)), rt;
          }
          var je;
          yt && ($e.header || $e.dynamicTyping || $e.transform) && (je = 1, !yt.data.length || Array.isArray(yt.data[0]) ? (yt.data = yt.data.map(et), je = yt.data.length) : yt.data = et(yt.data, 0), $e.header && yt.meta && (yt.meta.fields = wt), gt += je);
        }
        function Bt() {
          return $e.header && wt.length === 0;
        }
        function Ye(Be, et, je, it) {
          Be = { type: Be, code: et, message: je }, it !== void 0 && (Be.row = it), yt.errors.push(Be);
        }
        Ve($e.step) && (tt = $e.step, $e.step = function(Be) {
          yt = Be, Bt() ? It() : (It(), yt.data.length !== 0 && (xt += Be.data.length, $e.preview && xt > $e.preview ? Ke.abort() : (yt.data = yt.data[0], tt(yt, st))));
        }), this.parse = function(Be, et, je) {
          var it = $e.quoteChar || '"', it = ($e.newline || ($e.newline = this.guessLineEndings(Be, it)), ze = !1, $e.delimiter ? Ve($e.delimiter) && ($e.delimiter = $e.delimiter(Be), yt.meta.delimiter = $e.delimiter) : ((it = ((bt, rt, Ct, Rt, Ot) => {
            var Mt, Dt, Vt, Jt;
            Ot = Ot || [",", "	", "|", ";", xe.RECORD_SEP, xe.UNIT_SEP];
            for (var er = 0; er < Ot.length; er++) {
              for (var Zt, Gt = Ot[er], Yt = 0, $t = 0, ir = 0, Je = (Vt = void 0, new Ae({ comments: Rt, delimiter: Gt, newline: rt, preview: 10 }).parse(bt)), Ue = 0; Ue < Je.data.length; Ue++) Ct && St(Je.data[Ue]) ? ir++ : (Zt = Je.data[Ue].length, $t += Zt, Vt === void 0 ? Vt = Zt : 0 < Zt && (Yt += Math.abs(Zt - Vt), Vt = Zt));
              0 < Je.data.length && ($t /= Je.data.length - ir), (Dt === void 0 || Yt <= Dt) && (Jt === void 0 || Jt < $t) && 1.99 < $t && (Dt = Yt, Mt = Gt, Jt = $t);
            }
            return { successful: !!($e.delimiter = Mt), bestDelimiter: Mt };
          })(Be, $e.newline, $e.skipEmptyLines, $e.comments, $e.delimitersToGuess)).successful ? $e.delimiter = it.bestDelimiter : (ze = !0, $e.delimiter = xe.DefaultDelimiter), yt.meta.delimiter = $e.delimiter), He($e));
          return $e.preview && $e.header && it.preview++, De = Be, Ke = new Ae(it), yt = Ke.parse(De, et, je), It(), Ze ? { meta: { paused: !0 } } : yt || { meta: { paused: !1 } };
        }, this.paused = function() {
          return Ze;
        }, this.pause = function() {
          Ze = !0, Ke.abort(), De = Ve($e.chunk) ? "" : De.substring(Ke.getCharIndex());
        }, this.resume = function() {
          st.streamer._halted ? (Ze = !1, st.streamer.parseChunk(De, !0)) : setTimeout(st.resume, 3);
        }, this.aborted = function() {
          return _t;
        }, this.abort = function() {
          _t = !0, Ke.abort(), yt.meta.aborted = !0, Ve($e.complete) && $e.complete(yt), De = "";
        }, this.guessLineEndings = function(bt, it) {
          bt = bt.substring(0, 1048576);
          var it = new RegExp(Re(it) + "([^]*?)" + Re(it), "gm"), je = (bt = bt.replace(it, "")).split("\r"), it = bt.split(`
`), bt = 1 < it.length && it[0].length < je[0].length;
          if (je.length === 1 || bt) return `
`;
          for (var rt = 0, Ct = 0; Ct < je.length; Ct++) je[Ct][0] === `
` && rt++;
          return rt >= je.length / 2 ? `\r
` : "\r";
        };
      }
      function Re($e) {
        return $e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function Ae($e) {
        var De = ($e = $e || {}).delimiter, Ke = $e.newline, ze = $e.comments, tt = $e.step, Xe = $e.preview, mt = $e.fastMode, at = null, qe = !1, st = $e.quoteChar == null ? '"' : $e.quoteChar, xt = st;
        if ($e.escapeChar !== void 0 && (xt = $e.escapeChar), (typeof De != "string" || -1 < xe.BAD_DELIMITERS.indexOf(De)) && (De = ","), ze === De) throw new Error("Comment character same as delimiter");
        ze === !0 ? ze = "#" : (typeof ze != "string" || -1 < xe.BAD_DELIMITERS.indexOf(ze)) && (ze = !1), Ke !== `
` && Ke !== "\r" && Ke !== `\r
` && (Ke = `
`);
        var gt = 0, Ze = !1;
        this.parse = function(_t, wt, yt) {
          if (typeof _t != "string") throw new Error("Input must be a string");
          var St = _t.length, It = De.length, Bt = Ke.length, Ye = ze.length, Be = Ve(tt), et = [], je = [], it = [], bt = gt = 0;
          if (!_t) return Yt();
          if (mt || mt !== !1 && _t.indexOf(st) === -1) {
            for (var rt = _t.split(Ke), Ct = 0; Ct < rt.length; Ct++) {
              if (it = rt[Ct], gt += it.length, Ct !== rt.length - 1) gt += Ke.length;
              else if (yt) return Yt();
              if (!ze || it.substring(0, Ye) !== ze) {
                if (Be) {
                  if (et = [], Jt(it.split(De)), $t(), Ze) return Yt();
                } else Jt(it.split(De));
                if (Xe && Xe <= Ct) return et = et.slice(0, Xe), Yt(!0);
              }
            }
            return Yt();
          }
          for (var Rt = _t.indexOf(De, gt), Ot = _t.indexOf(Ke, gt), Mt = new RegExp(Re(xt) + Re(st), "g"), Dt = _t.indexOf(st, gt); ; ) if (_t[gt] === st) for (Dt = gt, gt++; ; ) {
            if ((Dt = _t.indexOf(st, Dt + 1)) === -1) return yt || je.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: et.length, index: gt }), Zt();
            if (Dt === St - 1) return Zt(_t.substring(gt, Dt).replace(Mt, st));
            if (st === xt && _t[Dt + 1] === xt) Dt++;
            else if (st === xt || Dt === 0 || _t[Dt - 1] !== xt) {
              Rt !== -1 && Rt < Dt + 1 && (Rt = _t.indexOf(De, Dt + 1));
              var Vt = er((Ot = Ot !== -1 && Ot < Dt + 1 ? _t.indexOf(Ke, Dt + 1) : Ot) === -1 ? Rt : Math.min(Rt, Ot));
              if (_t.substr(Dt + 1 + Vt, It) === De) {
                it.push(_t.substring(gt, Dt).replace(Mt, st)), _t[gt = Dt + 1 + Vt + It] !== st && (Dt = _t.indexOf(st, gt)), Rt = _t.indexOf(De, gt), Ot = _t.indexOf(Ke, gt);
                break;
              }
              if (Vt = er(Ot), _t.substring(Dt + 1 + Vt, Dt + 1 + Vt + Bt) === Ke) {
                if (it.push(_t.substring(gt, Dt).replace(Mt, st)), Gt(Dt + 1 + Vt + Bt), Rt = _t.indexOf(De, gt), Dt = _t.indexOf(st, gt), Be && ($t(), Ze)) return Yt();
                if (Xe && et.length >= Xe) return Yt(!0);
                break;
              }
              je.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: et.length, index: gt }), Dt++;
            }
          }
          else if (ze && it.length === 0 && _t.substring(gt, gt + Ye) === ze) {
            if (Ot === -1) return Yt();
            gt = Ot + Bt, Ot = _t.indexOf(Ke, gt), Rt = _t.indexOf(De, gt);
          } else if (Rt !== -1 && (Rt < Ot || Ot === -1)) it.push(_t.substring(gt, Rt)), gt = Rt + It, Rt = _t.indexOf(De, gt);
          else {
            if (Ot === -1) break;
            if (it.push(_t.substring(gt, Ot)), Gt(Ot + Bt), Be && ($t(), Ze)) return Yt();
            if (Xe && et.length >= Xe) return Yt(!0);
          }
          return Zt();
          function Jt(ir) {
            et.push(ir), bt = gt;
          }
          function er(ir) {
            var Je = 0;
            return Je = ir !== -1 && (ir = _t.substring(Dt + 1, ir)) && ir.trim() === "" ? ir.length : Je;
          }
          function Zt(ir) {
            return yt || (ir === void 0 && (ir = _t.substring(gt)), it.push(ir), gt = St, Jt(it), Be && $t()), Yt();
          }
          function Gt(ir) {
            gt = ir, Jt(it), it = [], Ot = _t.indexOf(Ke, gt);
          }
          function Yt(ir) {
            if ($e.header && !wt && et.length && !qe) {
              var Je = et[0], Ue = /* @__PURE__ */ Object.create(null), We = new Set(Je);
              let lt = !1;
              for (let ft = 0; ft < Je.length; ft++) {
                let Et = Je[ft];
                if (Ue[Et = Ve($e.transformHeader) ? $e.transformHeader(Et, ft) : Et]) {
                  let Lt, Kt = Ue[Et];
                  for (; Lt = Et + "_" + Kt, Kt++, We.has(Lt); ) ;
                  We.add(Lt), Je[ft] = Lt, Ue[Et]++, lt = !0, (at = at === null ? {} : at)[Lt] = Et;
                } else Ue[Et] = 1, Je[ft] = Et;
                We.add(Et);
              }
              lt && console.warn("Duplicate headers found and renamed."), qe = !0;
            }
            return { data: et, errors: je, meta: { delimiter: De, linebreak: Ke, aborted: Ze, truncated: !!ir, cursor: bt + (wt || 0), renamedHeaders: at } };
          }
          function $t() {
            tt(Yt()), et = [], je = [];
          }
        }, this.abort = function() {
          Ze = !0;
        }, this.getCharIndex = function() {
          return gt;
        };
      }
      function Pe($e) {
        var De = $e.data, Ke = _e[De.workerId], ze = !1;
        if (De.error) Ke.userError(De.error, De.file);
        else if (De.results && De.results.data) {
          var tt = { abort: function() {
            ze = !0, Fe(De.workerId, { data: [], errors: [], meta: { aborted: !0 } });
          }, pause: Le, resume: Le };
          if (Ve(Ke.userStep)) {
            for (var Xe = 0; Xe < De.results.data.length && (Ke.userStep({ data: De.results.data[Xe], errors: De.results.errors, meta: De.results.meta }, tt), !ze); Xe++) ;
            delete De.results;
          } else Ve(Ke.userChunk) && (Ke.userChunk(De.results, tt, De.file), delete De.results);
        }
        De.finished && !ze && Fe(De.workerId, De.results);
      }
      function Fe($e, De) {
        var Ke = _e[$e];
        Ve(Ke.userComplete) && Ke.userComplete(De), Ke.terminate(), delete _e[$e];
      }
      function Le() {
        throw new Error("Not implemented.");
      }
      function He($e) {
        if (typeof $e != "object" || $e === null) return $e;
        var De, Ke = Array.isArray($e) ? [] : {};
        for (De in $e) Ke[De] = He($e[De]);
        return Ke;
      }
      function Ge($e, De) {
        return function() {
          $e.apply(De, arguments);
        };
      }
      function Ve($e) {
        return typeof $e == "function";
      }
      return xe.parse = function($e, De) {
        var Ke = (De = De || {}).dynamicTyping || !1;
        if (Ve(Ke) && (De.dynamicTypingFunction = Ke, Ke = {}), De.dynamicTyping = Ke, De.transform = !!Ve(De.transform) && De.transform, !De.worker || !xe.WORKERS_SUPPORTED) return Ke = null, xe.NODE_STREAM_INPUT, typeof $e == "string" ? ($e = ((ze) => ze.charCodeAt(0) !== 65279 ? ze : ze.slice(1))($e), Ke = new (De.download ? Se : Ce)(De)) : $e.readable === !0 && Ve($e.read) && Ve($e.on) ? Ke = new Ie(De) : (oe.File && $e instanceof File || $e instanceof Object) && (Ke = new Te(De)), Ke.stream($e);
        (Ke = (() => {
          var ze;
          return !!xe.WORKERS_SUPPORTED && (ze = (() => {
            var tt = oe.URL || oe.webkitURL || null, Xe = re.toString();
            return xe.BLOB_URL || (xe.BLOB_URL = tt.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", Xe, ")();"], { type: "text/javascript" })));
          })(), (ze = new oe.Worker(ze)).onmessage = Pe, ze.id = ve++, _e[ze.id] = ze);
        })()).userStep = De.step, Ke.userChunk = De.chunk, Ke.userComplete = De.complete, Ke.userError = De.error, De.step = Ve(De.step), De.chunk = Ve(De.chunk), De.complete = Ve(De.complete), De.error = Ve(De.error), delete De.worker, Ke.postMessage({ input: $e, config: De, workerId: Ke.id });
      }, xe.unparse = function($e, De) {
        var Ke = !1, ze = !0, tt = ",", Xe = `\r
`, mt = '"', at = mt + mt, qe = !1, st = null, xt = !1, gt = ((() => {
          if (typeof De == "object") {
            if (typeof De.delimiter != "string" || xe.BAD_DELIMITERS.filter(function(wt) {
              return De.delimiter.indexOf(wt) !== -1;
            }).length || (tt = De.delimiter), typeof De.quotes != "boolean" && typeof De.quotes != "function" && !Array.isArray(De.quotes) || (Ke = De.quotes), typeof De.skipEmptyLines != "boolean" && typeof De.skipEmptyLines != "string" || (qe = De.skipEmptyLines), typeof De.newline == "string" && (Xe = De.newline), typeof De.quoteChar == "string" && (mt = De.quoteChar), typeof De.header == "boolean" && (ze = De.header), Array.isArray(De.columns)) {
              if (De.columns.length === 0) throw new Error("Option columns is empty");
              st = De.columns;
            }
            De.escapeChar !== void 0 && (at = De.escapeChar + mt), De.escapeFormulae instanceof RegExp ? xt = De.escapeFormulae : typeof De.escapeFormulae == "boolean" && De.escapeFormulae && (xt = /^[=+\-@\t\r].*$/);
          }
        })(), new RegExp(Re(mt), "g"));
        if (typeof $e == "string" && ($e = JSON.parse($e)), Array.isArray($e)) {
          if (!$e.length || Array.isArray($e[0])) return Ze(null, $e, qe);
          if (typeof $e[0] == "object") return Ze(st || Object.keys($e[0]), $e, qe);
        } else if (typeof $e == "object") return typeof $e.data == "string" && ($e.data = JSON.parse($e.data)), Array.isArray($e.data) && ($e.fields || ($e.fields = $e.meta && $e.meta.fields || st), $e.fields || ($e.fields = Array.isArray($e.data[0]) ? $e.fields : typeof $e.data[0] == "object" ? Object.keys($e.data[0]) : []), Array.isArray($e.data[0]) || typeof $e.data[0] == "object" || ($e.data = [$e.data])), Ze($e.fields || [], $e.data || [], qe);
        throw new Error("Unable to serialize unrecognized input");
        function Ze(wt, yt, St) {
          var It = "", Bt = (typeof wt == "string" && (wt = JSON.parse(wt)), typeof yt == "string" && (yt = JSON.parse(yt)), Array.isArray(wt) && 0 < wt.length), Ye = !Array.isArray(yt[0]);
          if (Bt && ze) {
            for (var Be = 0; Be < wt.length; Be++) 0 < Be && (It += tt), It += _t(wt[Be], Be);
            0 < yt.length && (It += Xe);
          }
          for (var et = 0; et < yt.length; et++) {
            var je = (Bt ? wt : yt[et]).length, it = !1, bt = Bt ? Object.keys(yt[et]).length === 0 : yt[et].length === 0;
            if (St && !Bt && (it = St === "greedy" ? yt[et].join("").trim() === "" : yt[et].length === 1 && yt[et][0].length === 0), St === "greedy" && Bt) {
              for (var rt = [], Ct = 0; Ct < je; Ct++) {
                var Rt = Ye ? wt[Ct] : Ct;
                rt.push(yt[et][Rt]);
              }
              it = rt.join("").trim() === "";
            }
            if (!it) {
              for (var Ot = 0; Ot < je; Ot++) {
                0 < Ot && !bt && (It += tt);
                var Mt = Bt && Ye ? wt[Ot] : Ot;
                It += _t(yt[et][Mt], Ot);
              }
              et < yt.length - 1 && (!St || 0 < je && !bt) && (It += Xe);
            }
          }
          return It;
        }
        function _t(wt, yt) {
          var St, It;
          return wt == null ? "" : wt.constructor === Date ? JSON.stringify(wt).slice(1, 25) : (It = !1, xt && typeof wt == "string" && xt.test(wt) && (wt = "'" + wt, It = !0), St = wt.toString().replace(gt, at), (It = It || Ke === !0 || typeof Ke == "function" && Ke(wt, yt) || Array.isArray(Ke) && Ke[yt] || ((Bt, Ye) => {
            for (var Be = 0; Be < Ye.length; Be++) if (-1 < Bt.indexOf(Ye[Be])) return !0;
            return !1;
          })(St, xe.BAD_DELIMITERS) || -1 < St.indexOf(tt) || St.charAt(0) === " " || St.charAt(St.length - 1) === " ") ? mt + St + mt : St);
        }
      }, xe.RECORD_SEP = "", xe.UNIT_SEP = "", xe.BYTE_ORDER_MARK = "\uFEFF", xe.BAD_DELIMITERS = ["\r", `
`, '"', xe.BYTE_ORDER_MARK], xe.WORKERS_SUPPORTED = !fe && !!oe.Worker, xe.NODE_STREAM_INPUT = 1, xe.LocalChunkSize = 10485760, xe.RemoteChunkSize = 5242880, xe.DefaultDelimiter = ",", xe.Parser = Ae, xe.ParserHandle = Ne, xe.NetworkStreamer = Se, xe.FileStreamer = Te, xe.StringStreamer = Ce, xe.ReadableStreamStreamer = Ie, oe.jQuery && ((ue = oe.jQuery).fn.parse = function($e) {
        var De = $e.config || {}, Ke = [];
        return this.each(function(Xe) {
          if (!(ue(this).prop("tagName").toUpperCase() === "INPUT" && ue(this).attr("type").toLowerCase() === "file" && oe.FileReader) || !this.files || this.files.length === 0) return !0;
          for (var mt = 0; mt < this.files.length; mt++) Ke.push({ file: this.files[mt], inputElem: this, instanceConfig: ue.extend({}, De) });
        }), ze(), this;
        function ze() {
          if (Ke.length === 0) Ve($e.complete) && $e.complete();
          else {
            var Xe, mt, at, qe, st = Ke[0];
            if (Ve($e.before)) {
              var xt = $e.before(st.file, st.inputElem);
              if (typeof xt == "object") {
                if (xt.action === "abort") return Xe = "AbortError", mt = st.file, at = st.inputElem, qe = xt.reason, void (Ve($e.error) && $e.error({ name: Xe }, mt, at, qe));
                if (xt.action === "skip") return void tt();
                typeof xt.config == "object" && (st.instanceConfig = ue.extend(st.instanceConfig, xt.config));
              } else if (xt === "skip") return void tt();
            }
            var gt = st.instanceConfig.complete;
            st.instanceConfig.complete = function(Ze) {
              Ve(gt) && gt(Ze, st.file, st.inputElem), tt();
            }, xe.parse(st.file, st.instanceConfig);
          }
        }
        function tt() {
          Ke.splice(0, 1), ze();
        }
      }), he && (oe.onmessage = function($e) {
        $e = $e.data, xe.WORKER_ID === void 0 && $e && (xe.WORKER_ID = $e.workerId), typeof $e.input == "string" ? oe.postMessage({ workerId: xe.WORKER_ID, results: xe.parse($e.input, $e.config), finished: !0 }) : (oe.File && $e.input instanceof File || $e.input instanceof Object) && ($e = xe.parse($e.input, $e.config)) && oe.postMessage({ workerId: xe.WORKER_ID, results: $e, finished: !0 });
      }), (Se.prototype = Object.create(Ee.prototype)).constructor = Se, (Te.prototype = Object.create(Ee.prototype)).constructor = Te, (Ce.prototype = Object.create(Ce.prototype)).constructor = Ce, (Ie.prototype = Object.create(Ee.prototype)).constructor = Ie, xe;
    });
  }(papaparse_min$1)), papaparse_min$1.exports;
}
var papaparse_minExports = requirePapaparse_min();
const Papa = /* @__PURE__ */ getDefaultExportFromCjs(papaparse_minExports);
/*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
var XLSX = {};
XLSX.version = "0.20.3";
var current_codepage = 1200, current_ansi = 1252, $cptable, VALID_ANSI = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4], CS2CP = {
  0: 1252,
  /* ANSI */
  1: 65001,
  /* DEFAULT */
  2: 65001,
  /* SYMBOL */
  77: 1e4,
  /* MAC */
  128: 932,
  /* SHIFTJIS */
  129: 949,
  /* HANGUL */
  130: 1361,
  /* JOHAB */
  134: 936,
  /* GB2312 */
  136: 950,
  /* CHINESEBIG5 */
  161: 1253,
  /* GREEK */
  162: 1254,
  /* TURKISH */
  163: 1258,
  /* VIETNAMESE */
  177: 1255,
  /* HEBREW */
  178: 1256,
  /* ARABIC */
  186: 1257,
  /* BALTIC */
  204: 1251,
  /* RUSSIAN */
  222: 874,
  /* THAI */
  238: 1250,
  /* EASTEUROPE */
  255: 1252,
  /* OEM */
  69: 6969
  /* MISC */
}, set_ansi = function(le) {
  VALID_ANSI.indexOf(le) != -1 && (current_ansi = CS2CP[0] = le);
};
function reset_ansi() {
  set_ansi(1252);
}
var set_cp = function(le) {
  current_codepage = le, set_ansi(le);
};
function reset_cp() {
  set_cp(1200), reset_ansi();
}
function char_codes(le) {
  for (var Y = [], re = 0, oe = le.length; re < oe; ++re) Y[re] = le.charCodeAt(re);
  return Y;
}
function utf16leread(le) {
  for (var Y = [], re = 0; re < le.length >> 1; ++re) Y[re] = String.fromCharCode(le.charCodeAt(2 * re) + (le.charCodeAt(2 * re + 1) << 8));
  return Y.join("");
}
function utf16lereadu(le) {
  for (var Y = [], re = 0; re < le.length >> 1; ++re) Y[re] = String.fromCharCode(le[2 * re] + (le[2 * re + 1] << 8));
  return Y.join("");
}
function utf16beread(le) {
  for (var Y = [], re = 0; re < le.length >> 1; ++re) Y[re] = String.fromCharCode(le.charCodeAt(2 * re + 1) + (le.charCodeAt(2 * re) << 8));
  return Y.join("");
}
var debom = function(le) {
  var Y = le.charCodeAt(0), re = le.charCodeAt(1);
  return Y == 255 && re == 254 ? utf16leread(le.slice(2)) : Y == 254 && re == 255 ? utf16beread(le.slice(2)) : Y == 65279 ? le.slice(1) : le;
}, _getchar = function le(Y) {
  return String.fromCharCode(Y);
}, _getansi = function le(Y) {
  return String.fromCharCode(Y);
};
function set_cptable(le) {
  $cptable = le, set_cp = function(Y) {
    current_codepage = Y, set_ansi(Y);
  }, debom = function(Y) {
    return Y.charCodeAt(0) === 255 && Y.charCodeAt(1) === 254 ? $cptable.utils.decode(1200, char_codes(Y.slice(2))) : Y;
  }, _getchar = function(re) {
    return current_codepage === 1200 ? String.fromCharCode(re) : $cptable.utils.decode(current_codepage, [re & 255, re >> 8])[0];
  }, _getansi = function(re) {
    return $cptable.utils.decode(current_ansi, [re])[0];
  }, cpdoit();
}
var DENSE = null, Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function Base64_encode(le) {
  for (var Y = "", re = 0, oe = 0, ue = 0, fe = 0, he = 0, _e = 0, ve = 0, xe = 0; xe < le.length; )
    re = le.charCodeAt(xe++), fe = re >> 2, oe = le.charCodeAt(xe++), he = (re & 3) << 4 | oe >> 4, ue = le.charCodeAt(xe++), _e = (oe & 15) << 2 | ue >> 6, ve = ue & 63, isNaN(oe) ? _e = ve = 64 : isNaN(ue) && (ve = 64), Y += Base64_map.charAt(fe) + Base64_map.charAt(he) + Base64_map.charAt(_e) + Base64_map.charAt(ve);
  return Y;
}
function Base64_encode_pass(le) {
  for (var Y = "", re = 0, oe = 0, ue = 0, fe = 0, he = 0, _e = 0, ve = 0, xe = 0; xe < le.length; )
    re = le.charCodeAt(xe++), re > 255 && (re = 95), fe = re >> 2, oe = le.charCodeAt(xe++), oe > 255 && (oe = 95), he = (re & 3) << 4 | oe >> 4, ue = le.charCodeAt(xe++), ue > 255 && (ue = 95), _e = (oe & 15) << 2 | ue >> 6, ve = ue & 63, isNaN(oe) ? _e = ve = 64 : isNaN(ue) && (ve = 64), Y += Base64_map.charAt(fe) + Base64_map.charAt(he) + Base64_map.charAt(_e) + Base64_map.charAt(ve);
  return Y;
}
function Base64_encode_arr(le) {
  for (var Y = "", re = 0, oe = 0, ue = 0, fe = 0, he = 0, _e = 0, ve = 0, xe = 0; xe < le.length; )
    re = le[xe++], fe = re >> 2, oe = le[xe++], he = (re & 3) << 4 | oe >> 4, ue = le[xe++], _e = (oe & 15) << 2 | ue >> 6, ve = ue & 63, isNaN(oe) ? _e = ve = 64 : isNaN(ue) && (ve = 64), Y += Base64_map.charAt(fe) + Base64_map.charAt(he) + Base64_map.charAt(_e) + Base64_map.charAt(ve);
  return Y;
}
function Base64_decode(le) {
  var Y = "", re = 0, oe = 0, ue = 0, fe = 0, he = 0, _e = 0, ve = 0;
  if (le.slice(0, 5) == "data:") {
    var xe = le.slice(0, 1024).indexOf(";base64,");
    xe > -1 && (le = le.slice(xe + 8));
  }
  le = le.replace(/[^\w\+\/\=]/g, "");
  for (var xe = 0; xe < le.length; )
    fe = Base64_map.indexOf(le.charAt(xe++)), he = Base64_map.indexOf(le.charAt(xe++)), re = fe << 2 | he >> 4, Y += String.fromCharCode(re), _e = Base64_map.indexOf(le.charAt(xe++)), oe = (he & 15) << 4 | _e >> 2, _e !== 64 && (Y += String.fromCharCode(oe)), ve = Base64_map.indexOf(le.charAt(xe++)), ue = (_e & 3) << 6 | ve, ve !== 64 && (Y += String.fromCharCode(ue));
  return Y;
}
var has_buf = /* @__PURE__ */ function() {
  return typeof Buffer < "u" && typeof process < "u" && typeof process.versions < "u" && !!process.versions.node;
}(), Buffer_from = /* @__PURE__ */ function() {
  if (typeof Buffer < "u") {
    var le = !Buffer.from;
    if (!le) try {
      Buffer.from("foo", "utf8");
    } catch {
      le = !0;
    }
    return le ? function(Y, re) {
      return re ? new Buffer(Y, re) : new Buffer(Y);
    } : Buffer.from.bind(Buffer);
  }
  return function() {
  };
}(), buf_utf16le = /* @__PURE__ */ function() {
  if (typeof Buffer > "u") return !1;
  var le = Buffer_from([65, 0]);
  if (!le) return !1;
  var Y = le.toString("utf16le");
  return Y.length == 1;
}();
function new_raw_buf(le) {
  return has_buf ? Buffer.alloc ? Buffer.alloc(le) : new Buffer(le) : typeof Uint8Array < "u" ? new Uint8Array(le) : new Array(le);
}
function new_unsafe_buf(le) {
  return has_buf ? Buffer.allocUnsafe ? Buffer.allocUnsafe(le) : new Buffer(le) : typeof Uint8Array < "u" ? new Uint8Array(le) : new Array(le);
}
var s2a = function le(Y) {
  return has_buf ? Buffer_from(Y, "binary") : Y.split("").map(function(re) {
    return re.charCodeAt(0) & 255;
  });
};
function s2ab(le) {
  if (typeof ArrayBuffer > "u") return s2a(le);
  for (var Y = new ArrayBuffer(le.length), re = new Uint8Array(Y), oe = 0; oe != le.length; ++oe) re[oe] = le.charCodeAt(oe) & 255;
  return Y;
}
function a2s(le) {
  if (Array.isArray(le)) return le.map(function(oe) {
    return String.fromCharCode(oe);
  }).join("");
  for (var Y = [], re = 0; re < le.length; ++re) Y[re] = String.fromCharCode(le[re]);
  return Y.join("");
}
function a2u(le) {
  if (typeof Uint8Array > "u") throw new Error("Unsupported");
  return new Uint8Array(le);
}
function ab2a(le) {
  if (typeof ArrayBuffer > "u") throw new Error("Unsupported");
  if (le instanceof ArrayBuffer) return ab2a(new Uint8Array(le));
  for (var Y = new Array(le.length), re = 0; re < le.length; ++re) Y[re] = le[re];
  return Y;
}
var bconcat = has_buf ? function(le) {
  return Buffer.concat(le.map(function(Y) {
    return Buffer.isBuffer(Y) ? Y : Buffer_from(Y);
  }));
} : function(le) {
  if (typeof Uint8Array < "u") {
    var Y = 0, re = 0;
    for (Y = 0; Y < le.length; ++Y) re += le[Y].length;
    var oe = new Uint8Array(re), ue = 0;
    for (Y = 0, re = 0; Y < le.length; re += ue, ++Y)
      ue = le[Y].length, le[Y] instanceof Uint8Array ? oe.set(le[Y], re) : typeof le[Y] == "string" ? oe.set(new Uint8Array(s2a(le[Y])), re) : oe.set(new Uint8Array(le[Y]), re);
    return oe;
  }
  return [].concat.apply([], le.map(function(fe) {
    return Array.isArray(fe) ? fe : [].slice.call(fe);
  }));
};
function utf8decode(le) {
  for (var Y = [], re = 0, oe = le.length + 250, ue = new_raw_buf(le.length + 255), fe = 0; fe < le.length; ++fe) {
    var he = le.charCodeAt(fe);
    if (he < 128) ue[re++] = he;
    else if (he < 2048)
      ue[re++] = 192 | he >> 6 & 31, ue[re++] = 128 | he & 63;
    else if (he >= 55296 && he < 57344) {
      he = (he & 1023) + 64;
      var _e = le.charCodeAt(++fe) & 1023;
      ue[re++] = 240 | he >> 8 & 7, ue[re++] = 128 | he >> 2 & 63, ue[re++] = 128 | _e >> 6 & 15 | (he & 3) << 4, ue[re++] = 128 | _e & 63;
    } else
      ue[re++] = 224 | he >> 12 & 15, ue[re++] = 128 | he >> 6 & 63, ue[re++] = 128 | he & 63;
    re > oe && (Y.push(ue.slice(0, re)), re = 0, ue = new_raw_buf(65535), oe = 65530);
  }
  return Y.push(ue.slice(0, re)), bconcat(Y);
}
var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;
function _strrev(le) {
  for (var Y = "", re = le.length - 1; re >= 0; ) Y += le.charAt(re--);
  return Y;
}
function pad0(le, Y) {
  var re = "" + le;
  return re.length >= Y ? re : fill("0", Y - re.length) + re;
}
function pad_(le, Y) {
  var re = "" + le;
  return re.length >= Y ? re : fill(" ", Y - re.length) + re;
}
function rpad_(le, Y) {
  var re = "" + le;
  return re.length >= Y ? re : re + fill(" ", Y - re.length);
}
function pad0r1(le, Y) {
  var re = "" + Math.round(le);
  return re.length >= Y ? re : fill("0", Y - re.length) + re;
}
function pad0r2(le, Y) {
  var re = "" + le;
  return re.length >= Y ? re : fill("0", Y - re.length) + re;
}
var p2_32 = /* @__PURE__ */ Math.pow(2, 32);
function pad0r(le, Y) {
  if (le > p2_32 || le < -p2_32) return pad0r1(le, Y);
  var re = Math.round(le);
  return pad0r2(re, Y);
}
function SSF_isgeneral(le, Y) {
  return Y = Y || 0, le.length >= 7 + Y && (le.charCodeAt(Y) | 32) === 103 && (le.charCodeAt(Y + 1) | 32) === 101 && (le.charCodeAt(Y + 2) | 32) === 110 && (le.charCodeAt(Y + 3) | 32) === 101 && (le.charCodeAt(Y + 4) | 32) === 114 && (le.charCodeAt(Y + 5) | 32) === 97 && (le.charCodeAt(Y + 6) | 32) === 108;
}
var days = [
  ["Sun", "Sunday"],
  ["Mon", "Monday"],
  ["Tue", "Tuesday"],
  ["Wed", "Wednesday"],
  ["Thu", "Thursday"],
  ["Fri", "Friday"],
  ["Sat", "Saturday"]
], months = [
  ["J", "Jan", "January"],
  ["F", "Feb", "February"],
  ["M", "Mar", "March"],
  ["A", "Apr", "April"],
  ["M", "May", "May"],
  ["J", "Jun", "June"],
  ["J", "Jul", "July"],
  ["A", "Aug", "August"],
  ["S", "Sep", "September"],
  ["O", "Oct", "October"],
  ["N", "Nov", "November"],
  ["D", "Dec", "December"]
];
function SSF_init_table(le) {
  return le || (le = {}), le[0] = "General", le[1] = "0", le[2] = "0.00", le[3] = "#,##0", le[4] = "#,##0.00", le[9] = "0%", le[10] = "0.00%", le[11] = "0.00E+00", le[12] = "# ?/?", le[13] = "# ??/??", le[14] = "m/d/yy", le[15] = "d-mmm-yy", le[16] = "d-mmm", le[17] = "mmm-yy", le[18] = "h:mm AM/PM", le[19] = "h:mm:ss AM/PM", le[20] = "h:mm", le[21] = "h:mm:ss", le[22] = "m/d/yy h:mm", le[37] = "#,##0 ;(#,##0)", le[38] = "#,##0 ;[Red](#,##0)", le[39] = "#,##0.00;(#,##0.00)", le[40] = "#,##0.00;[Red](#,##0.00)", le[45] = "mm:ss", le[46] = "[h]:mm:ss", le[47] = "mmss.0", le[48] = "##0.0E+0", le[49] = "@", le[56] = '"上午/下午 "hh"時"mm"分"ss"秒 "', le;
}
var table_fmt = {
  0: "General",
  1: "0",
  2: "0.00",
  3: "#,##0",
  4: "#,##0.00",
  9: "0%",
  10: "0.00%",
  11: "0.00E+00",
  12: "# ?/?",
  13: "# ??/??",
  14: "m/d/yy",
  15: "d-mmm-yy",
  16: "d-mmm",
  17: "mmm-yy",
  18: "h:mm AM/PM",
  19: "h:mm:ss AM/PM",
  20: "h:mm",
  21: "h:mm:ss",
  22: "m/d/yy h:mm",
  37: "#,##0 ;(#,##0)",
  38: "#,##0 ;[Red](#,##0)",
  39: "#,##0.00;(#,##0.00)",
  40: "#,##0.00;[Red](#,##0.00)",
  45: "mm:ss",
  46: "[h]:mm:ss",
  47: "mmss.0",
  48: "##0.0E+0",
  49: "@",
  56: '"上午/下午 "hh"時"mm"分"ss"秒 "'
}, SSF_default_map = {
  5: 37,
  6: 38,
  7: 39,
  8: 40,
  //  5 -> 37 ...  8 -> 40
  23: 0,
  24: 0,
  25: 0,
  26: 0,
  // 23 ->  0 ... 26 ->  0
  27: 14,
  28: 14,
  29: 14,
  30: 14,
  31: 14,
  // 27 -> 14 ... 31 -> 14
  50: 14,
  51: 14,
  52: 14,
  53: 14,
  54: 14,
  // 50 -> 14 ... 58 -> 14
  55: 14,
  56: 14,
  57: 14,
  58: 14,
  59: 1,
  60: 2,
  61: 3,
  62: 4,
  // 59 ->  1 ... 62 ->  4
  67: 9,
  68: 10,
  // 67 ->  9 ... 68 -> 10
  69: 12,
  70: 13,
  71: 14,
  // 69 -> 12 ... 71 -> 14
  72: 14,
  73: 15,
  74: 16,
  75: 17,
  // 72 -> 14 ... 75 -> 17
  76: 20,
  77: 21,
  78: 22,
  // 76 -> 20 ... 78 -> 22
  79: 45,
  80: 46,
  81: 47,
  // 79 -> 45 ... 81 -> 47
  82: 0
  // 82 ->  0 ... 65536 -> 0 (omitted)
}, SSF_default_str = {
  //  5 -- Currency,   0 decimal, black negative
  5: '"$"#,##0_);\\("$"#,##0\\)',
  63: '"$"#,##0_);\\("$"#,##0\\)',
  //  6 -- Currency,   0 decimal, red   negative
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  //  7 -- Currency,   2 decimal, black negative
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  //  8 -- Currency,   2 decimal, red   negative
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  // 41 -- Accounting, 0 decimal, No Symbol
  41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
  // 42 -- Accounting, 0 decimal, $  Symbol
  42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
  // 43 -- Accounting, 2 decimal, No Symbol
  43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
  // 44 -- Accounting, 2 decimal, $  Symbol
  44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
};
function SSF_frac(le, Y, re) {
  for (var oe = le < 0 ? -1 : 1, ue = le * oe, fe = 0, he = 1, _e = 0, ve = 1, xe = 0, Ee = 0, Se = Math.floor(ue); xe < Y && (Se = Math.floor(ue), _e = Se * he + fe, Ee = Se * xe + ve, !(ue - Se < 5e-8)); )
    ue = 1 / (ue - Se), fe = he, he = _e, ve = xe, xe = Ee;
  if (Ee > Y && (xe > Y ? (Ee = ve, _e = fe) : (Ee = xe, _e = he)), !re) return [0, oe * _e, Ee];
  var Te = Math.floor(oe * _e / Ee);
  return [Te, oe * _e - Te * Ee, Ee];
}
function SSF_normalize_xl_unsafe(le) {
  var Y = le.toPrecision(16);
  if (Y.indexOf("e") > -1) {
    var re = Y.slice(0, Y.indexOf("e"));
    return re = re.indexOf(".") > -1 ? re.slice(0, re.slice(0, 2) == "0." ? 17 : 16) : re.slice(0, 15) + fill("0", re.length - 15), re + Y.slice(Y.indexOf("e"));
  }
  var oe = Y.indexOf(".") > -1 ? Y.slice(0, Y.slice(0, 2) == "0." ? 17 : 16) : Y.slice(0, 15) + fill("0", Y.length - 15);
  return Number(oe);
}
function SSF_parse_date_code(le, Y, re) {
  if (le > 2958465 || le < 0) return null;
  le = SSF_normalize_xl_unsafe(le);
  var oe = le | 0, ue = Math.floor(86400 * (le - oe)), fe = 0, he = [], _e = { D: oe, T: ue, u: 86400 * (le - oe) - ue, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
  if (Math.abs(_e.u) < 1e-6 && (_e.u = 0), Y && Y.date1904 && (oe += 1462), _e.u > 0.9999 && (_e.u = 0, ++ue == 86400 && (_e.T = ue = 0, ++oe, ++_e.D)), oe === 60)
    he = re ? [1317, 10, 29] : [1900, 2, 29], fe = 3;
  else if (oe === 0)
    he = re ? [1317, 8, 29] : [1900, 1, 0], fe = 6;
  else {
    oe > 60 && --oe;
    var ve = new Date(1900, 0, 1);
    ve.setDate(ve.getDate() + oe - 1), he = [ve.getFullYear(), ve.getMonth() + 1, ve.getDate()], fe = ve.getDay(), oe < 60 && (fe = (fe + 6) % 7), re && (fe = SSF_fix_hijri(ve, he));
  }
  return _e.y = he[0], _e.m = he[1], _e.d = he[2], _e.S = ue % 60, ue = Math.floor(ue / 60), _e.M = ue % 60, ue = Math.floor(ue / 60), _e.H = ue, _e.q = fe, _e;
}
function SSF_strip_decimal(le) {
  return le.indexOf(".") == -1 ? le : le.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
}
function SSF_normalize_exp(le) {
  return le.indexOf("E") == -1 ? le : le.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
}
function SSF_small_exp(le) {
  var Y = le < 0 ? 12 : 11, re = SSF_strip_decimal(le.toFixed(12));
  return re.length <= Y || (re = le.toPrecision(10), re.length <= Y) ? re : le.toExponential(5);
}
function SSF_large_exp(le) {
  var Y = SSF_strip_decimal(le.toFixed(11));
  return Y.length > (le < 0 ? 12 : 11) || Y === "0" || Y === "-0" ? le.toPrecision(6) : Y;
}
function SSF_general_num(le) {
  if (!isFinite(le)) return isNaN(le) ? "#NUM!" : "#DIV/0!";
  var Y = Math.floor(Math.log(Math.abs(le)) * Math.LOG10E), re;
  return Y >= -4 && Y <= -1 ? re = le.toPrecision(10 + Y) : Math.abs(Y) <= 9 ? re = SSF_small_exp(le) : Y === 10 ? re = le.toFixed(10).substr(0, 12) : re = SSF_large_exp(le), SSF_strip_decimal(SSF_normalize_exp(re.toUpperCase()));
}
function SSF_general(le, Y) {
  switch (typeof le) {
    case "string":
      return le;
    case "boolean":
      return le ? "TRUE" : "FALSE";
    case "number":
      return (le | 0) === le ? le.toString(10) : SSF_general_num(le);
    case "undefined":
      return "";
    case "object":
      if (le == null) return "";
      if (le instanceof Date) return SSF_format(14, datenum(le, Y && Y.date1904), Y);
  }
  throw new Error("unsupported value in General format: " + le);
}
function SSF_fix_hijri(le, Y) {
  Y[0] -= 581;
  var re = le.getDay();
  return le < 60 && (re = (re + 6) % 7), re;
}
function SSF_write_date(le, Y, re, oe) {
  var ue = "", fe = 0, he = 0, _e = re.y, ve, xe = 0;
  switch (le) {
    case 98:
      _e = re.y + 543;
    /* falls through */
    case 121:
      switch (Y.length) {
        case 1:
        case 2:
          ve = _e % 100, xe = 2;
          break;
        default:
          ve = _e % 1e4, xe = 4;
          break;
      }
      break;
    case 109:
      switch (Y.length) {
        case 1:
        case 2:
          ve = re.m, xe = Y.length;
          break;
        case 3:
          return months[re.m - 1][1];
        case 5:
          return months[re.m - 1][0];
        default:
          return months[re.m - 1][2];
      }
      break;
    case 100:
      switch (Y.length) {
        case 1:
        case 2:
          ve = re.d, xe = Y.length;
          break;
        case 3:
          return days[re.q][0];
        default:
          return days[re.q][1];
      }
      break;
    case 104:
      switch (Y.length) {
        case 1:
        case 2:
          ve = 1 + (re.H + 11) % 12, xe = Y.length;
          break;
        default:
          throw "bad hour format: " + Y;
      }
      break;
    case 72:
      switch (Y.length) {
        case 1:
        case 2:
          ve = re.H, xe = Y.length;
          break;
        default:
          throw "bad hour format: " + Y;
      }
      break;
    case 77:
      switch (Y.length) {
        case 1:
        case 2:
          ve = re.M, xe = Y.length;
          break;
        default:
          throw "bad minute format: " + Y;
      }
      break;
    case 115:
      if (Y != "s" && Y != "ss" && Y != ".0" && Y != ".00" && Y != ".000") throw "bad second format: " + Y;
      return re.u === 0 && (Y == "s" || Y == "ss") ? pad0(re.S, Y.length) : (oe >= 2 ? he = oe === 3 ? 1e3 : 100 : he = oe === 1 ? 10 : 1, fe = Math.round(he * (re.S + re.u)), fe >= 60 * he && (fe = 0), Y === "s" ? fe === 0 ? "0" : "" + fe / he : (ue = pad0(fe, 2 + oe), Y === "ss" ? ue.substr(0, 2) : "." + ue.substr(2, Y.length - 1)));
    case 90:
      switch (Y) {
        case "[h]":
        case "[hh]":
          ve = re.D * 24 + re.H;
          break;
        case "[m]":
        case "[mm]":
          ve = (re.D * 24 + re.H) * 60 + re.M;
          break;
        case "[s]":
        case "[ss]":
          ve = ((re.D * 24 + re.H) * 60 + re.M) * 60 + (oe == 0 ? Math.round(re.S + re.u) : re.S);
          break;
        default:
          throw "bad abstime format: " + Y;
      }
      xe = Y.length === 3 ? 1 : 2;
      break;
    case 101:
      ve = _e, xe = 1;
      break;
  }
  var Ee = xe > 0 ? pad0(ve, xe) : "";
  return Ee;
}
function commaify(le) {
  var Y = 3;
  if (le.length <= Y) return le;
  for (var re = le.length % Y, oe = le.substr(0, re); re != le.length; re += Y) oe += (oe.length > 0 ? "," : "") + le.substr(re, Y);
  return oe;
}
var pct1 = /%/g;
function write_num_pct(le, Y, re) {
  var oe = Y.replace(pct1, ""), ue = Y.length - oe.length;
  return write_num(le, oe, re * Math.pow(10, 2 * ue)) + fill("%", ue);
}
function write_num_cm(le, Y, re) {
  for (var oe = Y.length - 1; Y.charCodeAt(oe - 1) === 44; ) --oe;
  return write_num(le, Y.substr(0, oe), re / Math.pow(10, 3 * (Y.length - oe)));
}
function write_num_exp(le, Y) {
  var re, oe = le.indexOf("E") - le.indexOf(".") - 1;
  if (le.match(/^#+0.0E\+0$/)) {
    if (Y == 0) return "0.0E+0";
    if (Y < 0) return "-" + write_num_exp(le, -Y);
    var ue = le.indexOf(".");
    ue === -1 && (ue = le.indexOf("E"));
    var fe = Math.floor(Math.log(Y) * Math.LOG10E) % ue;
    if (fe < 0 && (fe += ue), re = (Y / Math.pow(10, fe)).toPrecision(oe + 1 + (ue + fe) % ue), re.indexOf("e") === -1) {
      var he = Math.floor(Math.log(Y) * Math.LOG10E);
      for (re.indexOf(".") === -1 ? re = re.charAt(0) + "." + re.substr(1) + "E+" + (he - re.length + fe) : re += "E+" + (he - fe); re.substr(0, 2) === "0."; )
        re = re.charAt(0) + re.substr(2, ue) + "." + re.substr(2 + ue), re = re.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
      re = re.replace(/\+-/, "-");
    }
    re = re.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(_e, ve, xe, Ee) {
      return ve + xe + Ee.substr(0, (ue + fe) % ue) + "." + Ee.substr(fe) + "E";
    });
  } else re = Y.toExponential(oe);
  return le.match(/E\+00$/) && re.match(/e[+-]\d$/) && (re = re.substr(0, re.length - 1) + "0" + re.charAt(re.length - 1)), le.match(/E\-/) && re.match(/e\+/) && (re = re.replace(/e\+/, "e")), re.replace("e", "E");
}
var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
function write_num_f1(le, Y, re) {
  var oe = parseInt(le[4], 10), ue = Math.round(Y * oe), fe = Math.floor(ue / oe), he = ue - fe * oe, _e = oe;
  return re + (fe === 0 ? "" : "" + fe) + " " + (he === 0 ? fill(" ", le[1].length + 1 + le[4].length) : pad_(he, le[1].length) + le[2] + "/" + le[3] + pad0(_e, le[4].length));
}
function write_num_f2(le, Y, re) {
  return re + (Y === 0 ? "" : "" + Y) + fill(" ", le[1].length + 2 + le[4].length);
}
var dec1 = /^#*0*\.([0#]+)/, closeparen = /\)[^)]*[0#]/, phone = /\(###\) ###\\?-####/;
function hashq(le) {
  for (var Y = "", re, oe = 0; oe != le.length; ++oe) switch (re = le.charCodeAt(oe)) {
    case 35:
      break;
    case 63:
      Y += " ";
      break;
    case 48:
      Y += "0";
      break;
    default:
      Y += String.fromCharCode(re);
  }
  return Y;
}
function rnd(le, Y) {
  var re = Math.pow(10, Y);
  return "" + Math.round(le * re) / re;
}
function dec(le, Y) {
  var re = le - Math.floor(le), oe = Math.pow(10, Y);
  return Y < ("" + Math.round(re * oe)).length ? 0 : Math.round(re * oe);
}
function carry(le, Y) {
  return Y < ("" + Math.round((le - Math.floor(le)) * Math.pow(10, Y))).length ? 1 : 0;
}
function flr(le) {
  return le < 2147483647 && le > -2147483648 ? "" + (le >= 0 ? le | 0 : le - 1 | 0) : "" + Math.floor(le);
}
function write_num_flt(le, Y, re) {
  if (le.charCodeAt(0) === 40 && !Y.match(closeparen)) {
    var oe = Y.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    return re >= 0 ? write_num_flt("n", oe, re) : "(" + write_num_flt("n", oe, -re) + ")";
  }
  if (Y.charCodeAt(Y.length - 1) === 44) return write_num_cm(le, Y, re);
  if (Y.indexOf("%") !== -1) return write_num_pct(le, Y, re);
  if (Y.indexOf("E") !== -1) return write_num_exp(Y, re);
  if (Y.charCodeAt(0) === 36) return "$" + write_num_flt(le, Y.substr(Y.charAt(1) == " " ? 2 : 1), re);
  var ue, fe, he, _e, ve = Math.abs(re), xe = re < 0 ? "-" : "";
  if (Y.match(/^00+$/)) return xe + pad0r(ve, Y.length);
  if (Y.match(/^[#?]+$/))
    return ue = pad0r(re, 0), ue === "0" && (ue = ""), ue.length > Y.length ? ue : hashq(Y.substr(0, Y.length - ue.length)) + ue;
  if (fe = Y.match(frac1)) return write_num_f1(fe, ve, xe);
  if (Y.match(/^#+0+$/)) return xe + pad0r(ve, Y.length - Y.indexOf("0"));
  if (fe = Y.match(dec1))
    return ue = rnd(re, fe[1].length).replace(/^([^\.]+)$/, "$1." + hashq(fe[1])).replace(/\.$/, "." + hashq(fe[1])).replace(/\.(\d*)$/, function(Ie, Ne) {
      return "." + Ne + fill("0", hashq(
        /*::(*/
        fe[1]
      ).length - Ne.length);
    }), Y.indexOf("0.") !== -1 ? ue : ue.replace(/^0\./, ".");
  if (Y = Y.replace(/^#+([0.])/, "$1"), fe = Y.match(/^(0*)\.(#*)$/))
    return xe + rnd(ve, fe[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, fe[1].length ? "0." : ".");
  if (fe = Y.match(/^#{1,3},##0(\.?)$/)) return xe + commaify(pad0r(ve, 0));
  if (fe = Y.match(/^#,##0\.([#0]*0)$/))
    return re < 0 ? "-" + write_num_flt(le, Y, -re) : commaify("" + (Math.floor(re) + carry(re, fe[1].length))) + "." + pad0(dec(re, fe[1].length), fe[1].length);
  if (fe = Y.match(/^#,#*,#0/)) return write_num_flt(le, Y.replace(/^#,#*,/, ""), re);
  if (fe = Y.match(/^([0#]+)(\\?-([0#]+))+$/))
    return ue = _strrev(write_num_flt(le, Y.replace(/[\\-]/g, ""), re)), he = 0, _strrev(_strrev(Y.replace(/\\/g, "")).replace(/[0#]/g, function(Ie) {
      return he < ue.length ? ue.charAt(he++) : Ie === "0" ? "0" : "";
    }));
  if (Y.match(phone))
    return ue = write_num_flt(le, "##########", re), "(" + ue.substr(0, 3) + ") " + ue.substr(3, 3) + "-" + ue.substr(6);
  var Ee = "";
  if (fe = Y.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))
    return he = Math.min(
      /*::String(*/
      fe[4].length,
      7
    ), _e = SSF_frac(ve, Math.pow(10, he) - 1, !1), ue = "" + xe, Ee = write_num(
      "n",
      /*::String(*/
      fe[1],
      _e[1]
    ), Ee.charAt(Ee.length - 1) == " " && (Ee = Ee.substr(0, Ee.length - 1) + "0"), ue += Ee + /*::String(*/
    fe[2] + "/" + /*::String(*/
    fe[3], Ee = rpad_(_e[2], he), Ee.length < fe[4].length && (Ee = hashq(fe[4].substr(fe[4].length - Ee.length)) + Ee), ue += Ee, ue;
  if (fe = Y.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))
    return he = Math.min(Math.max(fe[1].length, fe[4].length), 7), _e = SSF_frac(ve, Math.pow(10, he) - 1, !0), xe + (_e[0] || (_e[1] ? "" : "0")) + " " + (_e[1] ? pad_(_e[1], he) + fe[2] + "/" + fe[3] + rpad_(_e[2], he) : fill(" ", 2 * he + 1 + fe[2].length + fe[3].length));
  if (fe = Y.match(/^[#0?]+$/))
    return ue = pad0r(re, 0), Y.length <= ue.length ? ue : hashq(Y.substr(0, Y.length - ue.length)) + ue;
  if (fe = Y.match(/^([#0?]+)\.([#0]+)$/)) {
    ue = "" + re.toFixed(Math.min(fe[2].length, 10)).replace(/([^0])0+$/, "$1"), he = ue.indexOf(".");
    var Se = Y.indexOf(".") - he, Te = Y.length - ue.length - Se;
    return hashq(Y.substr(0, Se) + ue + Y.substr(Y.length - Te));
  }
  if (fe = Y.match(/^00,000\.([#0]*0)$/))
    return he = dec(re, fe[1].length), re < 0 ? "-" + write_num_flt(le, Y, -re) : commaify(flr(re)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(Ie) {
      return "00," + (Ie.length < 3 ? pad0(0, 3 - Ie.length) : "") + Ie;
    }) + "." + pad0(he, fe[1].length);
  switch (Y) {
    case "###,##0.00":
      return write_num_flt(le, "#,##0.00", re);
    case "###,###":
    case "##,###":
    case "#,###":
      var Ce = commaify(pad0r(ve, 0));
      return Ce !== "0" ? xe + Ce : "";
    case "###,###.00":
      return write_num_flt(le, "###,##0.00", re).replace(/^0\./, ".");
    case "#,###.00":
      return write_num_flt(le, "#,##0.00", re).replace(/^0\./, ".");
  }
  throw new Error("unsupported format |" + Y + "|");
}
function write_num_cm2(le, Y, re) {
  for (var oe = Y.length - 1; Y.charCodeAt(oe - 1) === 44; ) --oe;
  return write_num(le, Y.substr(0, oe), re / Math.pow(10, 3 * (Y.length - oe)));
}
function write_num_pct2(le, Y, re) {
  var oe = Y.replace(pct1, ""), ue = Y.length - oe.length;
  return write_num(le, oe, re * Math.pow(10, 2 * ue)) + fill("%", ue);
}
function write_num_exp2(le, Y) {
  var re, oe = le.indexOf("E") - le.indexOf(".") - 1;
  if (le.match(/^#+0.0E\+0$/)) {
    if (Y == 0) return "0.0E+0";
    if (Y < 0) return "-" + write_num_exp2(le, -Y);
    var ue = le.indexOf(".");
    ue === -1 && (ue = le.indexOf("E"));
    var fe = Math.floor(Math.log(Y) * Math.LOG10E) % ue;
    if (fe < 0 && (fe += ue), re = (Y / Math.pow(10, fe)).toPrecision(oe + 1 + (ue + fe) % ue), !re.match(/[Ee]/)) {
      var he = Math.floor(Math.log(Y) * Math.LOG10E);
      re.indexOf(".") === -1 ? re = re.charAt(0) + "." + re.substr(1) + "E+" + (he - re.length + fe) : re += "E+" + (he - fe), re = re.replace(/\+-/, "-");
    }
    re = re.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(_e, ve, xe, Ee) {
      return ve + xe + Ee.substr(0, (ue + fe) % ue) + "." + Ee.substr(fe) + "E";
    });
  } else re = Y.toExponential(oe);
  return le.match(/E\+00$/) && re.match(/e[+-]\d$/) && (re = re.substr(0, re.length - 1) + "0" + re.charAt(re.length - 1)), le.match(/E\-/) && re.match(/e\+/) && (re = re.replace(/e\+/, "e")), re.replace("e", "E");
}
function write_num_int(le, Y, re) {
  if (le.charCodeAt(0) === 40 && !Y.match(closeparen)) {
    var oe = Y.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    return re >= 0 ? write_num_int("n", oe, re) : "(" + write_num_int("n", oe, -re) + ")";
  }
  if (Y.charCodeAt(Y.length - 1) === 44) return write_num_cm2(le, Y, re);
  if (Y.indexOf("%") !== -1) return write_num_pct2(le, Y, re);
  if (Y.indexOf("E") !== -1) return write_num_exp2(Y, re);
  if (Y.charCodeAt(0) === 36) return "$" + write_num_int(le, Y.substr(Y.charAt(1) == " " ? 2 : 1), re);
  var ue, fe, he, _e, ve = Math.abs(re), xe = re < 0 ? "-" : "";
  if (Y.match(/^00+$/)) return xe + pad0(ve, Y.length);
  if (Y.match(/^[#?]+$/))
    return ue = "" + re, re === 0 && (ue = ""), ue.length > Y.length ? ue : hashq(Y.substr(0, Y.length - ue.length)) + ue;
  if (fe = Y.match(frac1)) return write_num_f2(fe, ve, xe);
  if (Y.match(/^#+0+$/)) return xe + pad0(ve, Y.length - Y.indexOf("0"));
  if (fe = Y.match(dec1))
    return ue = ("" + re).replace(/^([^\.]+)$/, "$1." + hashq(fe[1])).replace(/\.$/, "." + hashq(fe[1])), ue = ue.replace(/\.(\d*)$/, function(Ie, Ne) {
      return "." + Ne + fill("0", hashq(fe[1]).length - Ne.length);
    }), Y.indexOf("0.") !== -1 ? ue : ue.replace(/^0\./, ".");
  if (Y = Y.replace(/^#+([0.])/, "$1"), fe = Y.match(/^(0*)\.(#*)$/))
    return xe + ("" + ve).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, fe[1].length ? "0." : ".");
  if (fe = Y.match(/^#{1,3},##0(\.?)$/)) return xe + commaify("" + ve);
  if (fe = Y.match(/^#,##0\.([#0]*0)$/))
    return re < 0 ? "-" + write_num_int(le, Y, -re) : commaify("" + re) + "." + fill("0", fe[1].length);
  if (fe = Y.match(/^#,#*,#0/)) return write_num_int(le, Y.replace(/^#,#*,/, ""), re);
  if (fe = Y.match(/^([0#]+)(\\?-([0#]+))+$/))
    return ue = _strrev(write_num_int(le, Y.replace(/[\\-]/g, ""), re)), he = 0, _strrev(_strrev(Y.replace(/\\/g, "")).replace(/[0#]/g, function(Ie) {
      return he < ue.length ? ue.charAt(he++) : Ie === "0" ? "0" : "";
    }));
  if (Y.match(phone))
    return ue = write_num_int(le, "##########", re), "(" + ue.substr(0, 3) + ") " + ue.substr(3, 3) + "-" + ue.substr(6);
  var Ee = "";
  if (fe = Y.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))
    return he = Math.min(
      /*::String(*/
      fe[4].length,
      7
    ), _e = SSF_frac(ve, Math.pow(10, he) - 1, !1), ue = "" + xe, Ee = write_num(
      "n",
      /*::String(*/
      fe[1],
      _e[1]
    ), Ee.charAt(Ee.length - 1) == " " && (Ee = Ee.substr(0, Ee.length - 1) + "0"), ue += Ee + /*::String(*/
    fe[2] + "/" + /*::String(*/
    fe[3], Ee = rpad_(_e[2], he), Ee.length < fe[4].length && (Ee = hashq(fe[4].substr(fe[4].length - Ee.length)) + Ee), ue += Ee, ue;
  if (fe = Y.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))
    return he = Math.min(Math.max(fe[1].length, fe[4].length), 7), _e = SSF_frac(ve, Math.pow(10, he) - 1, !0), xe + (_e[0] || (_e[1] ? "" : "0")) + " " + (_e[1] ? pad_(_e[1], he) + fe[2] + "/" + fe[3] + rpad_(_e[2], he) : fill(" ", 2 * he + 1 + fe[2].length + fe[3].length));
  if (fe = Y.match(/^[#0?]+$/))
    return ue = "" + re, Y.length <= ue.length ? ue : hashq(Y.substr(0, Y.length - ue.length)) + ue;
  if (fe = Y.match(/^([#0]+)\.([#0]+)$/)) {
    ue = "" + re.toFixed(Math.min(fe[2].length, 10)).replace(/([^0])0+$/, "$1"), he = ue.indexOf(".");
    var Se = Y.indexOf(".") - he, Te = Y.length - ue.length - Se;
    return hashq(Y.substr(0, Se) + ue + Y.substr(Y.length - Te));
  }
  if (fe = Y.match(/^00,000\.([#0]*0)$/))
    return re < 0 ? "-" + write_num_int(le, Y, -re) : commaify("" + re).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(Ie) {
      return "00," + (Ie.length < 3 ? pad0(0, 3 - Ie.length) : "") + Ie;
    }) + "." + pad0(0, fe[1].length);
  switch (Y) {
    case "###,###":
    case "##,###":
    case "#,###":
      var Ce = commaify("" + ve);
      return Ce !== "0" ? xe + Ce : "";
    default:
      if (Y.match(/\.[0#?]*$/)) return write_num_int(le, Y.slice(0, Y.lastIndexOf(".")), re) + hashq(Y.slice(Y.lastIndexOf(".")));
  }
  throw new Error("unsupported format |" + Y + "|");
}
function write_num(le, Y, re) {
  return (re | 0) === re ? write_num_int(le, Y, re) : write_num_flt(le, Y, re);
}
function SSF_split_fmt(le) {
  for (var Y = [], re = !1, oe = 0, ue = 0; oe < le.length; ++oe) switch (
    /*cc=*/
    le.charCodeAt(oe)
  ) {
    case 34:
      re = !re;
      break;
    case 95:
    case 42:
    case 92:
      ++oe;
      break;
    case 59:
      Y[Y.length] = le.substr(ue, oe - ue), ue = oe + 1;
  }
  if (Y[Y.length] = le.substr(ue), re === !0) throw new Error("Format |" + le + "| unterminated string ");
  return Y;
}
var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
function fmt_is_date(le) {
  for (var Y = 0, re = "", oe = ""; Y < le.length; )
    switch (re = le.charAt(Y)) {
      case "G":
        SSF_isgeneral(le, Y) && (Y += 6), Y++;
        break;
      case '"':
        for (
          ;
          /*cc=*/
          le.charCodeAt(++Y) !== 34 && Y < le.length;
        )
          ;
        ++Y;
        break;
      case "\\":
        Y += 2;
        break;
      case "_":
        Y += 2;
        break;
      case "@":
        ++Y;
        break;
      case "B":
      case "b":
        if (le.charAt(Y + 1) === "1" || le.charAt(Y + 1) === "2") return !0;
      /* falls through */
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
      /* falls through */
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        return !0;
      case "A":
      case "a":
      case "上":
        if (le.substr(Y, 3).toUpperCase() === "A/P" || le.substr(Y, 5).toUpperCase() === "AM/PM" || le.substr(Y, 5).toUpperCase() === "上午/下午") return !0;
        ++Y;
        break;
      case "[":
        for (oe = re; le.charAt(Y++) !== "]" && Y < le.length; ) oe += le.charAt(Y);
        if (oe.match(SSF_abstime)) return !0;
        break;
      case ".":
      /* falls through */
      case "0":
      case "#":
        for (; Y < le.length && ("0#?.,E+-%".indexOf(re = le.charAt(++Y)) > -1 || re == "\\" && le.charAt(Y + 1) == "-" && "0#".indexOf(le.charAt(Y + 2)) > -1); )
          ;
        break;
      case "?":
        for (; le.charAt(++Y) === re; )
          ;
        break;
      case "*":
        ++Y, (le.charAt(Y) == " " || le.charAt(Y) == "*") && ++Y;
        break;
      case "(":
      case ")":
        ++Y;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        for (; Y < le.length && "0123456789".indexOf(le.charAt(++Y)) > -1; )
          ;
        break;
      case " ":
        ++Y;
        break;
      default:
        ++Y;
        break;
    }
  return !1;
}
function eval_fmt(le, Y, re, oe) {
  for (var ue = [], fe = "", he = 0, _e = "", ve = "t", xe, Ee, Se, Te = "H"; he < le.length; )
    switch (_e = le.charAt(he)) {
      case "G":
        if (!SSF_isgeneral(le, he)) throw new Error("unrecognized character " + _e + " in " + le);
        ue[ue.length] = { t: "G", v: "General" }, he += 7;
        break;
      case '"':
        for (fe = ""; (Se = le.charCodeAt(++he)) !== 34 && he < le.length; ) fe += String.fromCharCode(Se);
        ue[ue.length] = { t: "t", v: fe }, ++he;
        break;
      case "\\":
        var Ce = le.charAt(++he), Ie = Ce === "(" || Ce === ")" ? Ce : "t";
        ue[ue.length] = { t: Ie, v: Ce }, ++he;
        break;
      case "_":
        ue[ue.length] = { t: "t", v: " " }, he += 2;
        break;
      case "@":
        ue[ue.length] = { t: "T", v: Y }, ++he;
        break;
      case "B":
      case "b":
        if (le.charAt(he + 1) === "1" || le.charAt(he + 1) === "2") {
          if (xe == null && (xe = SSF_parse_date_code(Y, re, le.charAt(he + 1) === "2"), xe == null))
            return "";
          ue[ue.length] = { t: "X", v: le.substr(he, 2) }, ve = _e, he += 2;
          break;
        }
      /* falls through */
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
        _e = _e.toLowerCase();
      /* falls through */
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        if (Y < 0 || xe == null && (xe = SSF_parse_date_code(Y, re), xe == null))
          return "";
        for (fe = _e; ++he < le.length && le.charAt(he).toLowerCase() === _e; ) fe += _e;
        _e === "m" && ve.toLowerCase() === "h" && (_e = "M"), _e === "h" && (_e = Te), ue[ue.length] = { t: _e, v: fe }, ve = _e;
        break;
      case "A":
      case "a":
      case "上":
        var Ne = { t: _e, v: _e };
        if (xe == null && (xe = SSF_parse_date_code(Y, re)), le.substr(he, 3).toUpperCase() === "A/P" ? (xe != null && (Ne.v = xe.H >= 12 ? le.charAt(he + 2) : _e), Ne.t = "T", Te = "h", he += 3) : le.substr(he, 5).toUpperCase() === "AM/PM" ? (xe != null && (Ne.v = xe.H >= 12 ? "PM" : "AM"), Ne.t = "T", he += 5, Te = "h") : le.substr(he, 5).toUpperCase() === "上午/下午" ? (xe != null && (Ne.v = xe.H >= 12 ? "下午" : "上午"), Ne.t = "T", he += 5, Te = "h") : (Ne.t = "t", ++he), xe == null && Ne.t === "T") return "";
        ue[ue.length] = Ne, ve = _e;
        break;
      case "[":
        for (fe = _e; le.charAt(he++) !== "]" && he < le.length; ) fe += le.charAt(he);
        if (fe.slice(-1) !== "]") throw 'unterminated "[" block: |' + fe + "|";
        if (fe.match(SSF_abstime)) {
          if (xe == null && (xe = SSF_parse_date_code(Y, re), xe == null))
            return "";
          ue[ue.length] = { t: "Z", v: fe.toLowerCase() }, ve = fe.charAt(1);
        } else fe.indexOf("$") > -1 && (fe = (fe.match(/\$([^-\[\]]*)/) || [])[1] || "$", fmt_is_date(le) || (ue[ue.length] = { t: "t", v: fe }));
        break;
      /* Numbers */
      case ".":
        if (xe != null) {
          for (fe = _e; ++he < le.length && (_e = le.charAt(he)) === "0"; ) fe += _e;
          ue[ue.length] = { t: "s", v: fe };
          break;
        }
      /* falls through */
      case "0":
      case "#":
        for (fe = _e; ++he < le.length && "0#?.,E+-%".indexOf(_e = le.charAt(he)) > -1; ) fe += _e;
        ue[ue.length] = { t: "n", v: fe };
        break;
      case "?":
        for (fe = _e; le.charAt(++he) === _e; ) fe += _e;
        ue[ue.length] = { t: _e, v: fe }, ve = _e;
        break;
      case "*":
        ++he, (le.charAt(he) == " " || le.charAt(he) == "*") && ++he;
        break;
      // **
      case "(":
      case ")":
        ue[ue.length] = { t: oe === 1 ? "t" : _e, v: _e }, ++he;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        for (fe = _e; he < le.length && "0123456789".indexOf(le.charAt(++he)) > -1; ) fe += le.charAt(he);
        ue[ue.length] = { t: "D", v: fe };
        break;
      case " ":
        ue[ue.length] = { t: _e, v: _e }, ++he;
        break;
      case "$":
        ue[ue.length] = { t: "t", v: "$" }, ++he;
        break;
      default:
        if (",$-+/():!^&'~{}<>=€acfijklopqrtuvwxzP".indexOf(_e) === -1) throw new Error("unrecognized character " + _e + " in " + le);
        ue[ue.length] = { t: "t", v: _e }, ++he;
        break;
    }
  var Re = 0, Ae = 0, Pe;
  for (he = ue.length - 1, ve = "t"; he >= 0; --he)
    switch (ue[he].t) {
      case "h":
      case "H":
        ue[he].t = Te, ve = "h", Re < 1 && (Re = 1);
        break;
      case "s":
        (Pe = ue[he].v.match(/\.0+$/)) && (Ae = Math.max(Ae, Pe[0].length - 1), Re = 4), Re < 3 && (Re = 3);
      /* falls through */
      case "d":
      case "y":
      case "e":
        ve = ue[he].t;
        break;
      case "M":
        ve = ue[he].t, Re < 2 && (Re = 2);
        break;
      case "m":
        ve === "s" && (ue[he].t = "M", Re < 2 && (Re = 2));
        break;
      case "X":
        break;
      case "Z":
        Re < 1 && ue[he].v.match(/[Hh]/) && (Re = 1), Re < 2 && ue[he].v.match(/[Mm]/) && (Re = 2), Re < 3 && ue[he].v.match(/[Ss]/) && (Re = 3);
    }
  var Fe;
  switch (Re) {
    case 0:
      break;
    case 1:
    case 2:
    case 3:
      xe.u >= 0.5 && (xe.u = 0, ++xe.S), xe.S >= 60 && (xe.S = 0, ++xe.M), xe.M >= 60 && (xe.M = 0, ++xe.H), xe.H >= 24 && (xe.H = 0, ++xe.D, Fe = SSF_parse_date_code(xe.D), Fe.u = xe.u, Fe.S = xe.S, Fe.M = xe.M, Fe.H = xe.H, xe = Fe);
      break;
    case 4:
      switch (Ae) {
        case 1:
          xe.u = Math.round(xe.u * 10) / 10;
          break;
        case 2:
          xe.u = Math.round(xe.u * 100) / 100;
          break;
        case 3:
          xe.u = Math.round(xe.u * 1e3) / 1e3;
          break;
      }
      xe.u >= 1 && (xe.u = 0, ++xe.S), xe.S >= 60 && (xe.S = 0, ++xe.M), xe.M >= 60 && (xe.M = 0, ++xe.H), xe.H >= 24 && (xe.H = 0, ++xe.D, Fe = SSF_parse_date_code(xe.D), Fe.u = xe.u, Fe.S = xe.S, Fe.M = xe.M, Fe.H = xe.H, xe = Fe);
      break;
  }
  var Le = "", He;
  for (he = 0; he < ue.length; ++he)
    switch (ue[he].t) {
      case "t":
      case "T":
      case " ":
      case "D":
        break;
      case "X":
        ue[he].v = "", ue[he].t = ";";
        break;
      case "d":
      case "m":
      case "y":
      case "h":
      case "H":
      case "M":
      case "s":
      case "e":
      case "b":
      case "Z":
        ue[he].v = SSF_write_date(ue[he].t.charCodeAt(0), ue[he].v, xe, Ae), ue[he].t = "t";
        break;
      case "n":
      case "?":
        for (He = he + 1; ue[He] != null && ((_e = ue[He].t) === "?" || _e === "D" || (_e === " " || _e === "t") && ue[He + 1] != null && (ue[He + 1].t === "?" || ue[He + 1].t === "t" && ue[He + 1].v === "/") || ue[he].t === "(" && (_e === " " || _e === "n" || _e === ")") || _e === "t" && (ue[He].v === "/" || ue[He].v === " " && ue[He + 1] != null && ue[He + 1].t == "?")); )
          ue[he].v += ue[He].v, ue[He] = { v: "", t: ";" }, ++He;
        Le += ue[he].v, he = He - 1;
        break;
      case "G":
        ue[he].t = "t", ue[he].v = SSF_general(Y, re);
        break;
    }
  var Ge = "", Ve, $e;
  if (Le.length > 0) {
    Le.charCodeAt(0) == 40 ? (Ve = Y < 0 && Le.charCodeAt(0) === 45 ? -Y : Y, $e = write_num("n", Le, Ve)) : (Ve = Y < 0 && oe > 1 ? -Y : Y, $e = write_num("n", Le, Ve), Ve < 0 && ue[0] && ue[0].t == "t" && ($e = $e.substr(1), ue[0].v = "-" + ue[0].v)), He = $e.length - 1;
    var De = ue.length;
    for (he = 0; he < ue.length; ++he) if (ue[he] != null && ue[he].t != "t" && ue[he].v.indexOf(".") > -1) {
      De = he;
      break;
    }
    var Ke = ue.length;
    if (De === ue.length && $e.indexOf("E") === -1) {
      for (he = ue.length - 1; he >= 0; --he)
        ue[he] == null || "n?".indexOf(ue[he].t) === -1 || (He >= ue[he].v.length - 1 ? (He -= ue[he].v.length, ue[he].v = $e.substr(He + 1, ue[he].v.length)) : He < 0 ? ue[he].v = "" : (ue[he].v = $e.substr(0, He + 1), He = -1), ue[he].t = "t", Ke = he);
      He >= 0 && Ke < ue.length && (ue[Ke].v = $e.substr(0, He + 1) + ue[Ke].v);
    } else if (De !== ue.length && $e.indexOf("E") === -1) {
      for (He = $e.indexOf(".") - 1, he = De; he >= 0; --he)
        if (!(ue[he] == null || "n?".indexOf(ue[he].t) === -1)) {
          for (Ee = ue[he].v.indexOf(".") > -1 && he === De ? ue[he].v.indexOf(".") - 1 : ue[he].v.length - 1, Ge = ue[he].v.substr(Ee + 1); Ee >= 0; --Ee)
            He >= 0 && (ue[he].v.charAt(Ee) === "0" || ue[he].v.charAt(Ee) === "#") && (Ge = $e.charAt(He--) + Ge);
          ue[he].v = Ge, ue[he].t = "t", Ke = he;
        }
      for (He >= 0 && Ke < ue.length && (ue[Ke].v = $e.substr(0, He + 1) + ue[Ke].v), He = $e.indexOf(".") + 1, he = De; he < ue.length; ++he)
        if (!(ue[he] == null || "n?(".indexOf(ue[he].t) === -1 && he !== De)) {
          for (Ee = ue[he].v.indexOf(".") > -1 && he === De ? ue[he].v.indexOf(".") + 1 : 0, Ge = ue[he].v.substr(0, Ee); Ee < ue[he].v.length; ++Ee)
            He < $e.length && (Ge += $e.charAt(He++));
          ue[he].v = Ge, ue[he].t = "t", Ke = he;
        }
    }
  }
  for (he = 0; he < ue.length; ++he) ue[he] != null && "n?".indexOf(ue[he].t) > -1 && (Ve = oe > 1 && Y < 0 && he > 0 && ue[he - 1].v === "-" ? -Y : Y, ue[he].v = write_num(ue[he].t, ue[he].v, Ve), ue[he].t = "t");
  var ze = "";
  for (he = 0; he !== ue.length; ++he) ue[he] != null && (ze += ue[he].v);
  return ze;
}
var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
function chkcond(le, Y) {
  if (Y == null) return !1;
  var re = parseFloat(Y[2]);
  switch (Y[1]) {
    case "=":
      if (le == re) return !0;
      break;
    case ">":
      if (le > re) return !0;
      break;
    case "<":
      if (le < re) return !0;
      break;
    case "<>":
      if (le != re) return !0;
      break;
    case ">=":
      if (le >= re) return !0;
      break;
    case "<=":
      if (le <= re) return !0;
      break;
  }
  return !1;
}
function choose_fmt(le, Y) {
  var re = SSF_split_fmt(le), oe = re.length, ue = re[oe - 1].indexOf("@");
  if (oe < 4 && ue > -1 && --oe, re.length > 4) throw new Error("cannot find right format for |" + re.join("|") + "|");
  if (typeof Y != "number") return [4, re.length === 4 || ue > -1 ? re[re.length - 1] : "@"];
  switch (typeof Y == "number" && !isFinite(Y) && (Y = 0), re.length) {
    case 1:
      re = ue > -1 ? ["General", "General", "General", re[0]] : [re[0], re[0], re[0], "@"];
      break;
    case 2:
      re = ue > -1 ? [re[0], re[0], re[0], re[1]] : [re[0], re[1], re[0], "@"];
      break;
    case 3:
      re = ue > -1 ? [re[0], re[1], re[0], re[2]] : [re[0], re[1], re[2], "@"];
      break;
  }
  var fe = Y > 0 ? re[0] : Y < 0 ? re[1] : re[2];
  if (re[0].indexOf("[") === -1 && re[1].indexOf("[") === -1) return [oe, fe];
  if (re[0].match(/\[[=<>]/) != null || re[1].match(/\[[=<>]/) != null) {
    var he = re[0].match(cfregex2), _e = re[1].match(cfregex2);
    return chkcond(Y, he) ? [oe, re[0]] : chkcond(Y, _e) ? [oe, re[1]] : [oe, re[he != null && _e != null ? 2 : 1]];
  }
  return [oe, fe];
}
function SSF_format(le, Y, re) {
  re == null && (re = {});
  var oe = "";
  switch (typeof le) {
    case "string":
      le == "m/d/yy" && re.dateNF ? oe = re.dateNF : oe = le;
      break;
    case "number":
      le == 14 && re.dateNF ? oe = re.dateNF : oe = (re.table != null ? re.table : table_fmt)[le], oe == null && (oe = re.table && re.table[SSF_default_map[le]] || table_fmt[SSF_default_map[le]]), oe == null && (oe = SSF_default_str[le] || "General");
      break;
  }
  if (SSF_isgeneral(oe, 0)) return SSF_general(Y, re);
  Y instanceof Date && (Y = datenum(Y, re.date1904));
  var ue = choose_fmt(oe, Y);
  if (SSF_isgeneral(ue[1])) return SSF_general(Y, re);
  if (Y === !0) Y = "TRUE";
  else if (Y === !1) Y = "FALSE";
  else {
    if (Y === "" || Y == null) return "";
    if (isNaN(Y) && ue[1].indexOf("0") > -1) return "#NUM!";
    if (!isFinite(Y) && ue[1].indexOf("0") > -1) return "#DIV/0!";
  }
  return eval_fmt(ue[1], Y, re, ue[0]);
}
function SSF_load(le, Y) {
  if (typeof Y != "number") {
    Y = +Y || -1;
    for (var re = 0; re < 392; ++re) {
      if (table_fmt[re] == null) {
        Y < 0 && (Y = re);
        continue;
      }
      if (table_fmt[re] == le) {
        Y = re;
        break;
      }
    }
    Y < 0 && (Y = 391);
  }
  return table_fmt[Y] = le, Y;
}
function SSF_load_table(le) {
  for (var Y = 0; Y != 392; ++Y)
    le[Y] !== void 0 && SSF_load(le[Y], Y);
}
function make_ssf() {
  table_fmt = SSF_init_table();
}
var SSF = {
  format: SSF_format,
  load: SSF_load,
  _table: table_fmt,
  load_table: SSF_load_table,
  parse_date_code: SSF_parse_date_code,
  is_date: fmt_is_date,
  get_table: function le() {
    return SSF._table = table_fmt;
  }
}, SSFImplicit = {
  5: '"$"#,##0_);\\("$"#,##0\\)',
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  23: "General",
  24: "General",
  25: "General",
  26: "General",
  27: "m/d/yy",
  28: "m/d/yy",
  29: "m/d/yy",
  30: "m/d/yy",
  31: "m/d/yy",
  32: "h:mm:ss",
  33: "h:mm:ss",
  34: "h:mm:ss",
  35: "h:mm:ss",
  36: "m/d/yy",
  41: '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
  42: '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
  43: '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
  44: '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
  50: "m/d/yy",
  51: "m/d/yy",
  52: "m/d/yy",
  53: "m/d/yy",
  54: "m/d/yy",
  55: "m/d/yy",
  56: "m/d/yy",
  57: "m/d/yy",
  58: "m/d/yy",
  59: "0",
  60: "0.00",
  61: "#,##0",
  62: "#,##0.00",
  63: '"$"#,##0_);\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  67: "0%",
  68: "0.00%",
  69: "# ?/?",
  70: "# ??/??",
  71: "m/d/yy",
  72: "m/d/yy",
  73: "d-mmm-yy",
  74: "d-mmm",
  75: "mmm-yy",
  76: "h:mm",
  77: "h:mm:ss",
  78: "m/d/yy h:mm",
  79: "mm:ss",
  80: "[h]:mm:ss",
  81: "mmss.0"
}, dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
function dateNF_regex(le) {
  var Y = typeof le == "number" ? table_fmt[le] : le;
  return Y = Y.replace(dateNFregex, "(\\d+)"), dateNFregex.lastIndex = 0, new RegExp("^" + Y + "$");
}
function dateNF_fix(le, Y, re) {
  var oe = -1, ue = -1, fe = -1, he = -1, _e = -1, ve = -1;
  (Y.match(dateNFregex) || []).forEach(function(Se, Te) {
    var Ce = parseInt(re[Te + 1], 10);
    switch (Se.toLowerCase().charAt(0)) {
      case "y":
        oe = Ce;
        break;
      case "d":
        fe = Ce;
        break;
      case "h":
        he = Ce;
        break;
      case "s":
        ve = Ce;
        break;
      case "m":
        he >= 0 ? _e = Ce : ue = Ce;
        break;
    }
  }), dateNFregex.lastIndex = 0, ve >= 0 && _e == -1 && ue >= 0 && (_e = ue, ue = -1);
  var xe = ("" + (oe >= 0 ? oe : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (ue >= 1 ? ue : 1)).slice(-2) + "-" + ("00" + (fe >= 1 ? fe : 1)).slice(-2);
  xe.length == 7 && (xe = "0" + xe), xe.length == 8 && (xe = "20" + xe);
  var Ee = ("00" + (he >= 0 ? he : 0)).slice(-2) + ":" + ("00" + (_e >= 0 ? _e : 0)).slice(-2) + ":" + ("00" + (ve >= 0 ? ve : 0)).slice(-2);
  return he == -1 && _e == -1 && ve == -1 ? xe : oe == -1 && ue == -1 && fe == -1 ? Ee : xe + "T" + Ee;
}
var bad_formats = {
  "d.m": "d\\.m"
  // Issue #2571 Google Sheets writes invalid format 'd.m', correct format is 'd"."m' or 'd\\.m'
};
function SSF__load(le, Y) {
  return SSF_load(bad_formats[le] || le, Y);
}
var CRC32 = /* @__PURE__ */ function() {
  var le = {};
  le.version = "1.2.0";
  function Y() {
    for (var Ve = 0, $e = new Array(256), De = 0; De != 256; ++De)
      Ve = De, Ve = Ve & 1 ? -306674912 ^ Ve >>> 1 : Ve >>> 1, Ve = Ve & 1 ? -306674912 ^ Ve >>> 1 : Ve >>> 1, Ve = Ve & 1 ? -306674912 ^ Ve >>> 1 : Ve >>> 1, Ve = Ve & 1 ? -306674912 ^ Ve >>> 1 : Ve >>> 1, Ve = Ve & 1 ? -306674912 ^ Ve >>> 1 : Ve >>> 1, Ve = Ve & 1 ? -306674912 ^ Ve >>> 1 : Ve >>> 1, Ve = Ve & 1 ? -306674912 ^ Ve >>> 1 : Ve >>> 1, Ve = Ve & 1 ? -306674912 ^ Ve >>> 1 : Ve >>> 1, $e[De] = Ve;
    return typeof Int32Array < "u" ? new Int32Array($e) : $e;
  }
  var re = Y();
  function oe(Ve) {
    var $e = 0, De = 0, Ke = 0, ze = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
    for (Ke = 0; Ke != 256; ++Ke) ze[Ke] = Ve[Ke];
    for (Ke = 0; Ke != 256; ++Ke)
      for (De = Ve[Ke], $e = 256 + Ke; $e < 4096; $e += 256) De = ze[$e] = De >>> 8 ^ Ve[De & 255];
    var tt = [];
    for (Ke = 1; Ke != 16; ++Ke) tt[Ke - 1] = typeof Int32Array < "u" && typeof ze.subarray == "function" ? ze.subarray(Ke * 256, Ke * 256 + 256) : ze.slice(Ke * 256, Ke * 256 + 256);
    return tt;
  }
  var ue = oe(re), fe = ue[0], he = ue[1], _e = ue[2], ve = ue[3], xe = ue[4], Ee = ue[5], Se = ue[6], Te = ue[7], Ce = ue[8], Ie = ue[9], Ne = ue[10], Re = ue[11], Ae = ue[12], Pe = ue[13], Fe = ue[14];
  function Le(Ve, $e) {
    for (var De = $e ^ -1, Ke = 0, ze = Ve.length; Ke < ze; ) De = De >>> 8 ^ re[(De ^ Ve.charCodeAt(Ke++)) & 255];
    return ~De;
  }
  function He(Ve, $e) {
    for (var De = $e ^ -1, Ke = Ve.length - 15, ze = 0; ze < Ke; ) De = Fe[Ve[ze++] ^ De & 255] ^ Pe[Ve[ze++] ^ De >> 8 & 255] ^ Ae[Ve[ze++] ^ De >> 16 & 255] ^ Re[Ve[ze++] ^ De >>> 24] ^ Ne[Ve[ze++]] ^ Ie[Ve[ze++]] ^ Ce[Ve[ze++]] ^ Te[Ve[ze++]] ^ Se[Ve[ze++]] ^ Ee[Ve[ze++]] ^ xe[Ve[ze++]] ^ ve[Ve[ze++]] ^ _e[Ve[ze++]] ^ he[Ve[ze++]] ^ fe[Ve[ze++]] ^ re[Ve[ze++]];
    for (Ke += 15; ze < Ke; ) De = De >>> 8 ^ re[(De ^ Ve[ze++]) & 255];
    return ~De;
  }
  function Ge(Ve, $e) {
    for (var De = $e ^ -1, Ke = 0, ze = Ve.length, tt = 0, Xe = 0; Ke < ze; )
      tt = Ve.charCodeAt(Ke++), tt < 128 ? De = De >>> 8 ^ re[(De ^ tt) & 255] : tt < 2048 ? (De = De >>> 8 ^ re[(De ^ (192 | tt >> 6 & 31)) & 255], De = De >>> 8 ^ re[(De ^ (128 | tt & 63)) & 255]) : tt >= 55296 && tt < 57344 ? (tt = (tt & 1023) + 64, Xe = Ve.charCodeAt(Ke++) & 1023, De = De >>> 8 ^ re[(De ^ (240 | tt >> 8 & 7)) & 255], De = De >>> 8 ^ re[(De ^ (128 | tt >> 2 & 63)) & 255], De = De >>> 8 ^ re[(De ^ (128 | Xe >> 6 & 15 | (tt & 3) << 4)) & 255], De = De >>> 8 ^ re[(De ^ (128 | Xe & 63)) & 255]) : (De = De >>> 8 ^ re[(De ^ (224 | tt >> 12 & 15)) & 255], De = De >>> 8 ^ re[(De ^ (128 | tt >> 6 & 63)) & 255], De = De >>> 8 ^ re[(De ^ (128 | tt & 63)) & 255]);
    return ~De;
  }
  return le.table = re, le.bstr = Le, le.buf = He, le.str = Ge, le;
}(), CFB = /* @__PURE__ */ function le() {
  var Y = (
    /*::(*/
    {}
  );
  Y.version = "1.2.2";
  function re(Qe, dt) {
    for (var ot = Qe.split("/"), ct = dt.split("/"), ut = 0, ht = 0, Tt = Math.min(ot.length, ct.length); ut < Tt; ++ut) {
      if (ht = ot[ut].length - ct[ut].length) return ht;
      if (ot[ut] != ct[ut]) return ot[ut] < ct[ut] ? -1 : 1;
    }
    return ot.length - ct.length;
  }
  function oe(Qe) {
    if (Qe.charAt(Qe.length - 1) == "/") return Qe.slice(0, -1).indexOf("/") === -1 ? Qe : oe(Qe.slice(0, -1));
    var dt = Qe.lastIndexOf("/");
    return dt === -1 ? Qe : Qe.slice(0, dt + 1);
  }
  function ue(Qe) {
    if (Qe.charAt(Qe.length - 1) == "/") return ue(Qe.slice(0, -1));
    var dt = Qe.lastIndexOf("/");
    return dt === -1 ? Qe : Qe.slice(dt + 1);
  }
  function fe(Qe, dt) {
    typeof dt == "string" && (dt = new Date(dt));
    var ot = dt.getHours();
    ot = ot << 6 | dt.getMinutes(), ot = ot << 5 | dt.getSeconds() >>> 1, Qe.write_shift(2, ot);
    var ct = dt.getFullYear() - 1980;
    ct = ct << 4 | dt.getMonth() + 1, ct = ct << 5 | dt.getDate(), Qe.write_shift(2, ct);
  }
  function he(Qe) {
    var dt = Qe.read_shift(2) & 65535, ot = Qe.read_shift(2) & 65535, ct = /* @__PURE__ */ new Date(), ut = ot & 31;
    ot >>>= 5;
    var ht = ot & 15;
    ot >>>= 4, ct.setMilliseconds(0), ct.setFullYear(ot + 1980), ct.setMonth(ht - 1), ct.setDate(ut);
    var Tt = dt & 31;
    dt >>>= 5;
    var Nt = dt & 63;
    return dt >>>= 6, ct.setHours(dt), ct.setMinutes(Nt), ct.setSeconds(Tt << 1), ct;
  }
  function _e(Qe) {
    prep_blob(Qe, 0);
    for (var dt = (
      /*::(*/
      {}
    ), ot = 0; Qe.l <= Qe.length - 4; ) {
      var ct = Qe.read_shift(2), ut = Qe.read_shift(2), ht = Qe.l + ut, Tt = {};
      switch (ct) {
        /* UNIX-style Timestamps */
        case 21589:
          ot = Qe.read_shift(1), ot & 1 && (Tt.mtime = Qe.read_shift(4)), ut > 5 && (ot & 2 && (Tt.atime = Qe.read_shift(4)), ot & 4 && (Tt.ctime = Qe.read_shift(4))), Tt.mtime && (Tt.mt = new Date(Tt.mtime * 1e3));
          break;
        /* ZIP64 Extended Information Field */
        case 1:
          {
            var Nt = Qe.read_shift(4), At = Qe.read_shift(4);
            Tt.usz = At * Math.pow(2, 32) + Nt, Nt = Qe.read_shift(4), At = Qe.read_shift(4), Tt.csz = At * Math.pow(2, 32) + Nt;
          }
          break;
      }
      Qe.l = ht, dt[ct] = Tt;
    }
    return dt;
  }
  var ve;
  function xe() {
    return ve || (ve = _fs);
  }
  function Ee(Qe, dt) {
    if (Qe[0] == 80 && Qe[1] == 75) return Zr(Qe, dt);
    if ((Qe[0] | 32) == 109 && (Qe[1] | 32) == 105) return Ba(Qe, dt);
    if (Qe.length < 512) throw new Error("CFB file size " + Qe.length + " < 512");
    var ot = 3, ct = 512, ut = 0, ht = 0, Tt = 0, Nt = 0, At = 0, Ft = [], kt = (
      /*::(*/
      Qe.slice(0, 512)
    );
    prep_blob(kt, 0);
    var Ht = Se(kt);
    switch (ot = Ht[0], ot) {
      case 3:
        ct = 512;
        break;
      case 4:
        ct = 4096;
        break;
      case 0:
        if (Ht[1] == 0) return Zr(Qe, dt);
      /* falls through */
      default:
        throw new Error("Major Version: Expected 3 or 4 saw " + ot);
    }
    ct !== 512 && (kt = /*::(*/
    Qe.slice(0, ct), prep_blob(
      kt,
      28
      /* blob.l */
    ));
    var Wt = Qe.slice(0, ct);
    Te(kt, ot);
    var jt = kt.read_shift(4, "i");
    if (ot === 3 && jt !== 0) throw new Error("# Directory Sectors: Expected 0 saw " + jt);
    kt.l += 4, Tt = kt.read_shift(4, "i"), kt.l += 4, kt.chk("00100000", "Mini Stream Cutoff Size: "), Nt = kt.read_shift(4, "i"), ut = kt.read_shift(4, "i"), At = kt.read_shift(4, "i"), ht = kt.read_shift(4, "i");
    for (var zt = -1, qt = 0; qt < 109 && (zt = kt.read_shift(4, "i"), !(zt < 0)); ++qt)
      Ft[qt] = zt;
    var tr = Ce(Qe, ct);
    Re(At, ht, tr, ct, Ft);
    var hr = Pe(tr, Tt, Ft, ct);
    Tt < hr.length && (hr[Tt].name = "!Directory"), ut > 0 && Nt !== Xe && (hr[Nt].name = "!MiniFAT"), hr[Ft[0]].name = "!FAT", hr.fat_addrs = Ft, hr.ssz = ct;
    var ur = {}, xr = [], $r = [], Ir = [];
    Fe(Tt, hr, tr, xr, ut, ur, $r, Nt), Ie($r, Ir, xr), xr.shift();
    var Hr = {
      FileIndex: $r,
      FullPaths: Ir
    };
    return dt && dt.raw && (Hr.raw = { header: Wt, sectors: tr }), Hr;
  }
  function Se(Qe) {
    if (Qe[Qe.l] == 80 && Qe[Qe.l + 1] == 75) return [0, 0];
    Qe.chk(mt, "Header Signature: "), Qe.l += 16;
    var dt = Qe.read_shift(2, "u");
    return [Qe.read_shift(2, "u"), dt];
  }
  function Te(Qe, dt) {
    var ot = 9;
    switch (Qe.l += 2, ot = Qe.read_shift(2)) {
      case 9:
        if (dt != 3) throw new Error("Sector Shift: Expected 9 saw " + ot);
        break;
      case 12:
        if (dt != 4) throw new Error("Sector Shift: Expected 12 saw " + ot);
        break;
      default:
        throw new Error("Sector Shift: Expected 9 or 12 saw " + ot);
    }
    Qe.chk("0600", "Mini Sector Shift: "), Qe.chk("000000000000", "Reserved: ");
  }
  function Ce(Qe, dt) {
    for (var ot = Math.ceil(Qe.length / dt) - 1, ct = [], ut = 1; ut < ot; ++ut) ct[ut - 1] = Qe.slice(ut * dt, (ut + 1) * dt);
    return ct[ot - 1] = Qe.slice(ot * dt), ct;
  }
  function Ie(Qe, dt, ot) {
    for (var ct = 0, ut = 0, ht = 0, Tt = 0, Nt = 0, At = ot.length, Ft = [], kt = []; ct < At; ++ct)
      Ft[ct] = kt[ct] = ct, dt[ct] = ot[ct];
    for (; Nt < kt.length; ++Nt)
      ct = kt[Nt], ut = Qe[ct].L, ht = Qe[ct].R, Tt = Qe[ct].C, Ft[ct] === ct && (ut !== -1 && Ft[ut] !== ut && (Ft[ct] = Ft[ut]), ht !== -1 && Ft[ht] !== ht && (Ft[ct] = Ft[ht])), Tt !== -1 && (Ft[Tt] = ct), ut !== -1 && ct != Ft[ct] && (Ft[ut] = Ft[ct], kt.lastIndexOf(ut) < Nt && kt.push(ut)), ht !== -1 && ct != Ft[ct] && (Ft[ht] = Ft[ct], kt.lastIndexOf(ht) < Nt && kt.push(ht));
    for (ct = 1; ct < At; ++ct) Ft[ct] === ct && (ht !== -1 && Ft[ht] !== ht ? Ft[ct] = Ft[ht] : ut !== -1 && Ft[ut] !== ut && (Ft[ct] = Ft[ut]));
    for (ct = 1; ct < At; ++ct)
      if (Qe[ct].type !== 0) {
        if (Nt = ct, Nt != Ft[Nt]) do
          Nt = Ft[Nt], dt[ct] = dt[Nt] + "/" + dt[ct];
        while (Nt !== 0 && Ft[Nt] !== -1 && Nt != Ft[Nt]);
        Ft[ct] = -1;
      }
    for (dt[0] += "/", ct = 1; ct < At; ++ct)
      Qe[ct].type !== 2 && (dt[ct] += "/");
  }
  function Ne(Qe, dt, ot) {
    for (var ct = Qe.start, ut = Qe.size, ht = [], Tt = ct; ot && ut > 0 && Tt >= 0; )
      ht.push(dt.slice(Tt * tt, Tt * tt + tt)), ut -= tt, Tt = __readInt32LE(ot, Tt * 4);
    return ht.length === 0 ? new_buf(0) : bconcat(ht).slice(0, Qe.size);
  }
  function Re(Qe, dt, ot, ct, ut) {
    var ht = Xe;
    if (Qe === Xe) {
      if (dt !== 0) throw new Error("DIFAT chain shorter than expected");
    } else if (Qe !== -1) {
      var Tt = ot[Qe], Nt = (ct >>> 2) - 1;
      if (!Tt) return;
      for (var At = 0; At < Nt && (ht = __readInt32LE(Tt, At * 4)) !== Xe; ++At)
        ut.push(ht);
      dt >= 1 && Re(__readInt32LE(Tt, ct - 4), dt - 1, ot, ct, ut);
    }
  }
  function Ae(Qe, dt, ot, ct, ut) {
    var ht = [], Tt = [];
    ut || (ut = []);
    var Nt = ct - 1, At = 0, Ft = 0;
    for (At = dt; At >= 0; ) {
      ut[At] = !0, ht[ht.length] = At, Tt.push(Qe[At]);
      var kt = ot[Math.floor(At * 4 / ct)];
      if (Ft = At * 4 & Nt, ct < 4 + Ft) throw new Error("FAT boundary crossed: " + At + " 4 " + ct);
      if (!Qe[kt]) break;
      At = __readInt32LE(Qe[kt], Ft);
    }
    return { nodes: ht, data: __toBuffer([Tt]) };
  }
  function Pe(Qe, dt, ot, ct) {
    var ut = Qe.length, ht = [], Tt = [], Nt = [], At = [], Ft = ct - 1, kt = 0, Ht = 0, Wt = 0, jt = 0;
    for (kt = 0; kt < ut; ++kt)
      if (Nt = [], Wt = kt + dt, Wt >= ut && (Wt -= ut), !Tt[Wt]) {
        At = [];
        var zt = [];
        for (Ht = Wt; Ht >= 0; ) {
          zt[Ht] = !0, Tt[Ht] = !0, Nt[Nt.length] = Ht, At.push(Qe[Ht]);
          var qt = ot[Math.floor(Ht * 4 / ct)];
          if (jt = Ht * 4 & Ft, ct < 4 + jt) throw new Error("FAT boundary crossed: " + Ht + " 4 " + ct);
          if (!Qe[qt] || (Ht = __readInt32LE(Qe[qt], jt), zt[Ht])) break;
        }
        ht[Wt] = { nodes: Nt, data: __toBuffer([At]) };
      }
    return ht;
  }
  function Fe(Qe, dt, ot, ct, ut, ht, Tt, Nt) {
    for (var At = 0, Ft = ct.length ? 2 : 0, kt = dt[Qe].data, Ht = 0, Wt = 0, jt; Ht < kt.length; Ht += 128) {
      var zt = (
        /*::(*/
        kt.slice(Ht, Ht + 128)
      );
      prep_blob(zt, 64), Wt = zt.read_shift(2), jt = __utf16le(zt, 0, Wt - Ft), ct.push(jt);
      var qt = {
        name: jt,
        type: zt.read_shift(1),
        color: zt.read_shift(1),
        L: zt.read_shift(4, "i"),
        R: zt.read_shift(4, "i"),
        C: zt.read_shift(4, "i"),
        clsid: zt.read_shift(16),
        state: zt.read_shift(4, "i"),
        start: 0,
        size: 0
      }, tr = zt.read_shift(2) + zt.read_shift(2) + zt.read_shift(2) + zt.read_shift(2);
      tr !== 0 && (qt.ct = Le(zt, zt.l - 8));
      var hr = zt.read_shift(2) + zt.read_shift(2) + zt.read_shift(2) + zt.read_shift(2);
      hr !== 0 && (qt.mt = Le(zt, zt.l - 8)), qt.start = zt.read_shift(4, "i"), qt.size = zt.read_shift(4, "i"), qt.size < 0 && qt.start < 0 && (qt.size = qt.type = 0, qt.start = Xe, qt.name = ""), qt.type === 5 ? (At = qt.start, ut > 0 && At !== Xe && (dt[At].name = "!StreamData")) : qt.size >= 4096 ? (qt.storage = "fat", dt[qt.start] === void 0 && (dt[qt.start] = Ae(ot, qt.start, dt.fat_addrs, dt.ssz)), dt[qt.start].name = qt.name, qt.content = dt[qt.start].data.slice(0, qt.size)) : (qt.storage = "minifat", qt.size < 0 ? qt.size = 0 : At !== Xe && qt.start !== Xe && dt[At] && (qt.content = Ne(qt, dt[At].data, (dt[Nt] || {}).data))), qt.content && prep_blob(qt.content, 0), ht[jt] = qt, Tt.push(qt);
    }
  }
  function Le(Qe, dt) {
    return new Date((__readUInt32LE(Qe, dt + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(Qe, dt) / 1e7 - 11644473600) * 1e3);
  }
  function He(Qe, dt) {
    return xe(), Ee(ve.readFileSync(Qe), dt);
  }
  function Ge(Qe, dt) {
    var ot = dt && dt.type;
    switch (ot || has_buf && Buffer.isBuffer(Qe) && (ot = "buffer"), ot || "base64") {
      case "file":
        return He(Qe, dt);
      case "base64":
        return Ee(s2a(Base64_decode(Qe)), dt);
      case "binary":
        return Ee(s2a(Qe), dt);
    }
    return Ee(
      /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
      Qe,
      dt
    );
  }
  function Ve(Qe, dt) {
    var ot = dt || {}, ct = ot.root || "Root Entry";
    if (Qe.FullPaths || (Qe.FullPaths = []), Qe.FileIndex || (Qe.FileIndex = []), Qe.FullPaths.length !== Qe.FileIndex.length) throw new Error("inconsistent CFB structure");
    Qe.FullPaths.length === 0 && (Qe.FullPaths[0] = ct + "/", Qe.FileIndex[0] = { name: ct, type: 5 }), ot.CLSID && (Qe.FileIndex[0].clsid = ot.CLSID), $e(Qe);
  }
  function $e(Qe) {
    var dt = "Sh33tJ5";
    if (!CFB.find(Qe, "/" + dt)) {
      var ot = new_buf(4);
      ot[0] = 55, ot[1] = ot[3] = 50, ot[2] = 54, Qe.FileIndex.push({ name: dt, type: 2, content: ot, size: 4, L: 69, R: 69, C: 69 }), Qe.FullPaths.push(Qe.FullPaths[0] + dt), De(Qe);
    }
  }
  function De(Qe, dt) {
    Ve(Qe);
    for (var ot = !1, ct = !1, ut = Qe.FullPaths.length - 1; ut >= 0; --ut) {
      var ht = Qe.FileIndex[ut];
      switch (ht.type) {
        case 0:
          ct ? ot = !0 : (Qe.FileIndex.pop(), Qe.FullPaths.pop());
          break;
        case 1:
        case 2:
        case 5:
          ct = !0, isNaN(ht.R * ht.L * ht.C) && (ot = !0), ht.R > -1 && ht.L > -1 && ht.R == ht.L && (ot = !0);
          break;
        default:
          ot = !0;
          break;
      }
    }
    if (!(!ot && !dt)) {
      var Tt = new Date(1987, 1, 19), Nt = 0, At = Object.create ? /* @__PURE__ */ Object.create(null) : {}, Ft = [];
      for (ut = 0; ut < Qe.FullPaths.length; ++ut)
        At[Qe.FullPaths[ut]] = !0, Qe.FileIndex[ut].type !== 0 && Ft.push([Qe.FullPaths[ut], Qe.FileIndex[ut]]);
      for (ut = 0; ut < Ft.length; ++ut) {
        var kt = oe(Ft[ut][0]);
        for (ct = At[kt]; !ct; ) {
          for (; oe(kt) && !At[oe(kt)]; ) kt = oe(kt);
          Ft.push([kt, {
            name: ue(kt).replace("/", ""),
            type: 1,
            clsid: qe,
            ct: Tt,
            mt: Tt,
            content: null
          }]), At[kt] = !0, kt = oe(Ft[ut][0]), ct = At[kt];
        }
      }
      for (Ft.sort(function(jt, zt) {
        return re(jt[0], zt[0]);
      }), Qe.FullPaths = [], Qe.FileIndex = [], ut = 0; ut < Ft.length; ++ut)
        Qe.FullPaths[ut] = Ft[ut][0], Qe.FileIndex[ut] = Ft[ut][1];
      for (ut = 0; ut < Ft.length; ++ut) {
        var Ht = Qe.FileIndex[ut], Wt = Qe.FullPaths[ut];
        if (Ht.name = ue(Wt).replace("/", ""), Ht.L = Ht.R = Ht.C = -(Ht.color = 1), Ht.size = Ht.content ? Ht.content.length : 0, Ht.start = 0, Ht.clsid = Ht.clsid || qe, ut === 0)
          Ht.C = Ft.length > 1 ? 1 : -1, Ht.size = 0, Ht.type = 5;
        else if (Wt.slice(-1) == "/") {
          for (Nt = ut + 1; Nt < Ft.length && oe(Qe.FullPaths[Nt]) != Wt; ++Nt) ;
          for (Ht.C = Nt >= Ft.length ? -1 : Nt, Nt = ut + 1; Nt < Ft.length && oe(Qe.FullPaths[Nt]) != oe(Wt); ++Nt) ;
          Ht.R = Nt >= Ft.length ? -1 : Nt, Ht.type = 1;
        } else
          oe(Qe.FullPaths[ut + 1] || "") == oe(Wt) && (Ht.R = ut + 1), Ht.type = 2;
      }
    }
  }
  function Ke(Qe, dt) {
    var ot = dt || {};
    if (ot.fileType == "mad") return Wr(Qe, ot);
    switch (De(Qe), ot.fileType) {
      case "zip":
        return ea(Qe, ot);
    }
    var ct = function(jt) {
      for (var zt = 0, qt = 0, tr = 0; tr < jt.FileIndex.length; ++tr) {
        var hr = jt.FileIndex[tr];
        if (hr.content) {
          var ur = hr.content.length;
          ur > 0 && (ur < 4096 ? zt += ur + 63 >> 6 : qt += ur + 511 >> 9);
        }
      }
      for (var xr = jt.FullPaths.length + 3 >> 2, $r = zt + 7 >> 3, Ir = zt + 127 >> 7, Hr = $r + qt + xr + Ir, zr = Hr + 127 >> 7, Sa = zr <= 109 ? 0 : Math.ceil((zr - 109) / 127); Hr + zr + Sa + 127 >> 7 > zr; ) Sa = ++zr <= 109 ? 0 : Math.ceil((zr - 109) / 127);
      var Dr = [1, Sa, zr, Ir, xr, qt, zt, 0];
      return jt.FileIndex[0].size = zt << 6, Dr[7] = (jt.FileIndex[0].start = Dr[0] + Dr[1] + Dr[2] + Dr[3] + Dr[4] + Dr[5]) + (Dr[6] + 7 >> 3), Dr;
    }(Qe), ut = new_buf(ct[7] << 9), ht = 0, Tt = 0;
    {
      for (ht = 0; ht < 8; ++ht) ut.write_shift(1, at[ht]);
      for (ht = 0; ht < 8; ++ht) ut.write_shift(2, 0);
      for (ut.write_shift(2, 62), ut.write_shift(2, 3), ut.write_shift(2, 65534), ut.write_shift(2, 9), ut.write_shift(2, 6), ht = 0; ht < 3; ++ht) ut.write_shift(2, 0);
      for (ut.write_shift(4, 0), ut.write_shift(4, ct[2]), ut.write_shift(4, ct[0] + ct[1] + ct[2] + ct[3] - 1), ut.write_shift(4, 0), ut.write_shift(4, 4096), ut.write_shift(4, ct[3] ? ct[0] + ct[1] + ct[2] - 1 : Xe), ut.write_shift(4, ct[3]), ut.write_shift(-4, ct[1] ? ct[0] - 1 : Xe), ut.write_shift(4, ct[1]), ht = 0; ht < 109; ++ht) ut.write_shift(-4, ht < ct[2] ? ct[1] + ht : -1);
    }
    if (ct[1])
      for (Tt = 0; Tt < ct[1]; ++Tt) {
        for (; ht < 236 + Tt * 127; ++ht) ut.write_shift(-4, ht < ct[2] ? ct[1] + ht : -1);
        ut.write_shift(-4, Tt === ct[1] - 1 ? Xe : Tt + 1);
      }
    var Nt = function(jt) {
      for (Tt += jt; ht < Tt - 1; ++ht) ut.write_shift(-4, ht + 1);
      jt && (++ht, ut.write_shift(-4, Xe));
    };
    for (Tt = ht = 0, Tt += ct[1]; ht < Tt; ++ht) ut.write_shift(-4, st.DIFSECT);
    for (Tt += ct[2]; ht < Tt; ++ht) ut.write_shift(-4, st.FATSECT);
    Nt(ct[3]), Nt(ct[4]);
    for (var At = 0, Ft = 0, kt = Qe.FileIndex[0]; At < Qe.FileIndex.length; ++At)
      kt = Qe.FileIndex[At], kt.content && (Ft = kt.content.length, !(Ft < 4096) && (kt.start = Tt, Nt(Ft + 511 >> 9)));
    for (Nt(ct[6] + 7 >> 3); ut.l & 511; ) ut.write_shift(-4, st.ENDOFCHAIN);
    for (Tt = ht = 0, At = 0; At < Qe.FileIndex.length; ++At)
      kt = Qe.FileIndex[At], kt.content && (Ft = kt.content.length, !(!Ft || Ft >= 4096) && (kt.start = Tt, Nt(Ft + 63 >> 6)));
    for (; ut.l & 511; ) ut.write_shift(-4, st.ENDOFCHAIN);
    for (ht = 0; ht < ct[4] << 2; ++ht) {
      var Ht = Qe.FullPaths[ht];
      if (!Ht || Ht.length === 0) {
        for (At = 0; At < 17; ++At) ut.write_shift(4, 0);
        for (At = 0; At < 3; ++At) ut.write_shift(4, -1);
        for (At = 0; At < 12; ++At) ut.write_shift(4, 0);
        continue;
      }
      kt = Qe.FileIndex[ht], ht === 0 && (kt.start = kt.size ? kt.start - 1 : Xe);
      var Wt = ht === 0 && ot.root || kt.name;
      if (Wt.length > 31 && (console.error("Name " + Wt + " will be truncated to " + Wt.slice(0, 31)), Wt = Wt.slice(0, 31)), Ft = 2 * (Wt.length + 1), ut.write_shift(64, Wt, "utf16le"), ut.write_shift(2, Ft), ut.write_shift(1, kt.type), ut.write_shift(1, kt.color), ut.write_shift(-4, kt.L), ut.write_shift(-4, kt.R), ut.write_shift(-4, kt.C), kt.clsid) ut.write_shift(16, kt.clsid, "hex");
      else for (At = 0; At < 4; ++At) ut.write_shift(4, 0);
      ut.write_shift(4, kt.state || 0), ut.write_shift(4, 0), ut.write_shift(4, 0), ut.write_shift(4, 0), ut.write_shift(4, 0), ut.write_shift(4, kt.start), ut.write_shift(4, kt.size), ut.write_shift(4, 0);
    }
    for (ht = 1; ht < Qe.FileIndex.length; ++ht)
      if (kt = Qe.FileIndex[ht], kt.size >= 4096)
        if (ut.l = kt.start + 1 << 9, has_buf && Buffer.isBuffer(kt.content))
          kt.content.copy(ut, ut.l, 0, kt.size), ut.l += kt.size + 511 & -512;
        else {
          for (At = 0; At < kt.size; ++At) ut.write_shift(1, kt.content[At]);
          for (; At & 511; ++At) ut.write_shift(1, 0);
        }
    for (ht = 1; ht < Qe.FileIndex.length; ++ht)
      if (kt = Qe.FileIndex[ht], kt.size > 0 && kt.size < 4096)
        if (has_buf && Buffer.isBuffer(kt.content))
          kt.content.copy(ut, ut.l, 0, kt.size), ut.l += kt.size + 63 & -64;
        else {
          for (At = 0; At < kt.size; ++At) ut.write_shift(1, kt.content[At]);
          for (; At & 63; ++At) ut.write_shift(1, 0);
        }
    if (has_buf)
      ut.l = ut.length;
    else
      for (; ut.l < ut.length; ) ut.write_shift(1, 0);
    return ut;
  }
  function ze(Qe, dt) {
    var ot = Qe.FullPaths.map(function(At) {
      return At.toUpperCase();
    }), ct = ot.map(function(At) {
      var Ft = At.split("/");
      return Ft[Ft.length - (At.slice(-1) == "/" ? 2 : 1)];
    }), ut = !1;
    dt.charCodeAt(0) === 47 ? (ut = !0, dt = ot[0].slice(0, -1) + dt) : ut = dt.indexOf("/") !== -1;
    var ht = dt.toUpperCase(), Tt = ut === !0 ? ot.indexOf(ht) : ct.indexOf(ht);
    if (Tt !== -1) return Qe.FileIndex[Tt];
    var Nt = !ht.match(chr1);
    for (ht = ht.replace(chr0, ""), Nt && (ht = ht.replace(chr1, "!")), Tt = 0; Tt < ot.length; ++Tt)
      if ((Nt ? ot[Tt].replace(chr1, "!") : ot[Tt]).replace(chr0, "") == ht || (Nt ? ct[Tt].replace(chr1, "!") : ct[Tt]).replace(chr0, "") == ht) return Qe.FileIndex[Tt];
    return null;
  }
  var tt = 64, Xe = -2, mt = "d0cf11e0a1b11ae1", at = [208, 207, 17, 224, 161, 177, 26, 225], qe = "00000000000000000000000000000000", st = {
    /* 2.1 Compund File Sector Numbers and Types */
    MAXREGSECT: -6,
    DIFSECT: -4,
    FATSECT: -3,
    ENDOFCHAIN: Xe,
    FREESECT: -1,
    /* 2.2 Compound File Header */
    HEADER_SIGNATURE: mt,
    HEADER_MINOR_VERSION: "3e00",
    MAXREGSID: -6,
    NOSTREAM: -1,
    HEADER_CLSID: qe,
    /* 2.6.1 Compound File Directory Entry */
    EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
  };
  function xt(Qe, dt, ot) {
    xe();
    var ct = Ke(Qe, ot);
    ve.writeFileSync(dt, ct);
  }
  function gt(Qe) {
    for (var dt = new Array(Qe.length), ot = 0; ot < Qe.length; ++ot) dt[ot] = String.fromCharCode(Qe[ot]);
    return dt.join("");
  }
  function Ze(Qe, dt) {
    var ot = Ke(Qe, dt);
    switch (dt && dt.type || "buffer") {
      case "file":
        return xe(), ve.writeFileSync(dt.filename, ot), ot;
      case "binary":
        return typeof ot == "string" ? ot : gt(ot);
      case "base64":
        return Base64_encode(typeof ot == "string" ? ot : gt(ot));
      case "buffer":
        if (has_buf) return Buffer.isBuffer(ot) ? ot : Buffer_from(ot);
      /* falls through */
      case "array":
        return typeof ot == "string" ? s2a(ot) : ot;
    }
    return ot;
  }
  var _t;
  function wt(Qe) {
    try {
      var dt = Qe.InflateRaw, ot = new dt();
      if (ot._processChunk(new Uint8Array([3, 0]), ot._finishFlushFlag), ot.bytesRead) _t = Qe;
      else throw new Error("zlib does not expose bytesRead");
    } catch (ct) {
      console.error("cannot use native zlib: " + (ct.message || ct));
    }
  }
  function yt(Qe, dt) {
    if (!_t) return nr(Qe, dt);
    var ot = _t.InflateRaw, ct = new ot(), ut = ct._processChunk(Qe.slice(Qe.l), ct._finishFlushFlag);
    return Qe.l += ct.bytesRead, ut;
  }
  function St(Qe) {
    return _t ? _t.deflateRawSync(Qe) : lt(Qe);
  }
  var It = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], Bt = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258], Ye = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
  function Be(Qe) {
    var dt = (Qe << 1 | Qe << 11) & 139536 | (Qe << 5 | Qe << 15) & 558144;
    return (dt >> 16 | dt >> 8 | dt) & 255;
  }
  for (var et = typeof Uint8Array < "u", je = et ? new Uint8Array(256) : [], it = 0; it < 256; ++it) je[it] = Be(it);
  function bt(Qe, dt) {
    var ot = je[Qe & 255];
    return dt <= 8 ? ot >>> 8 - dt : (ot = ot << 8 | je[Qe >> 8 & 255], dt <= 16 ? ot >>> 16 - dt : (ot = ot << 8 | je[Qe >> 16 & 255], ot >>> 24 - dt));
  }
  function rt(Qe, dt) {
    var ot = dt & 7, ct = dt >>> 3;
    return (Qe[ct] | (ot <= 6 ? 0 : Qe[ct + 1] << 8)) >>> ot & 3;
  }
  function Ct(Qe, dt) {
    var ot = dt & 7, ct = dt >>> 3;
    return (Qe[ct] | (ot <= 5 ? 0 : Qe[ct + 1] << 8)) >>> ot & 7;
  }
  function Rt(Qe, dt) {
    var ot = dt & 7, ct = dt >>> 3;
    return (Qe[ct] | (ot <= 4 ? 0 : Qe[ct + 1] << 8)) >>> ot & 15;
  }
  function Ot(Qe, dt) {
    var ot = dt & 7, ct = dt >>> 3;
    return (Qe[ct] | (ot <= 3 ? 0 : Qe[ct + 1] << 8)) >>> ot & 31;
  }
  function Mt(Qe, dt) {
    var ot = dt & 7, ct = dt >>> 3;
    return (Qe[ct] | (ot <= 1 ? 0 : Qe[ct + 1] << 8)) >>> ot & 127;
  }
  function Dt(Qe, dt, ot) {
    var ct = dt & 7, ut = dt >>> 3, ht = (1 << ot) - 1, Tt = Qe[ut] >>> ct;
    return ot < 8 - ct || (Tt |= Qe[ut + 1] << 8 - ct, ot < 16 - ct) || (Tt |= Qe[ut + 2] << 16 - ct, ot < 24 - ct) || (Tt |= Qe[ut + 3] << 24 - ct), Tt & ht;
  }
  function Vt(Qe, dt, ot) {
    var ct = dt & 7, ut = dt >>> 3;
    return ct <= 5 ? Qe[ut] |= (ot & 7) << ct : (Qe[ut] |= ot << ct & 255, Qe[ut + 1] = (ot & 7) >> 8 - ct), dt + 3;
  }
  function Jt(Qe, dt, ot) {
    var ct = dt & 7, ut = dt >>> 3;
    return ot = (ot & 1) << ct, Qe[ut] |= ot, dt + 1;
  }
  function er(Qe, dt, ot) {
    var ct = dt & 7, ut = dt >>> 3;
    return ot <<= ct, Qe[ut] |= ot & 255, ot >>>= 8, Qe[ut + 1] = ot, dt + 8;
  }
  function Zt(Qe, dt, ot) {
    var ct = dt & 7, ut = dt >>> 3;
    return ot <<= ct, Qe[ut] |= ot & 255, ot >>>= 8, Qe[ut + 1] = ot & 255, Qe[ut + 2] = ot >>> 8, dt + 16;
  }
  function Gt(Qe, dt) {
    var ot = Qe.length, ct = 2 * ot > dt ? 2 * ot : dt + 5, ut = 0;
    if (ot >= dt) return Qe;
    if (has_buf) {
      var ht = new_unsafe_buf(ct);
      if (Qe.copy) Qe.copy(ht);
      else for (; ut < Qe.length; ++ut) ht[ut] = Qe[ut];
      return ht;
    } else if (et) {
      var Tt = new Uint8Array(ct);
      if (Tt.set) Tt.set(Qe);
      else for (; ut < ot; ++ut) Tt[ut] = Qe[ut];
      return Tt;
    }
    return Qe.length = ct, Qe;
  }
  function Yt(Qe) {
    for (var dt = new Array(Qe), ot = 0; ot < Qe; ++ot) dt[ot] = 0;
    return dt;
  }
  function $t(Qe, dt, ot) {
    var ct = 1, ut = 0, ht = 0, Tt = 0, Nt = 0, At = Qe.length, Ft = et ? new Uint16Array(32) : Yt(32);
    for (ht = 0; ht < 32; ++ht) Ft[ht] = 0;
    for (ht = At; ht < ot; ++ht) Qe[ht] = 0;
    At = Qe.length;
    var kt = et ? new Uint16Array(At) : Yt(At);
    for (ht = 0; ht < At; ++ht)
      Ft[ut = Qe[ht]]++, ct < ut && (ct = ut), kt[ht] = 0;
    for (Ft[0] = 0, ht = 1; ht <= ct; ++ht) Ft[ht + 16] = Nt = Nt + Ft[ht - 1] << 1;
    for (ht = 0; ht < At; ++ht)
      Nt = Qe[ht], Nt != 0 && (kt[ht] = Ft[Nt + 16]++);
    var Ht = 0;
    for (ht = 0; ht < At; ++ht)
      if (Ht = Qe[ht], Ht != 0)
        for (Nt = bt(kt[ht], ct) >> ct - Ht, Tt = (1 << ct + 4 - Ht) - 1; Tt >= 0; --Tt)
          dt[Nt | Tt << Ht] = Ht & 15 | ht << 4;
    return ct;
  }
  var ir = et ? new Uint16Array(512) : Yt(512), Je = et ? new Uint16Array(32) : Yt(32);
  if (!et) {
    for (var Ue = 0; Ue < 512; ++Ue) ir[Ue] = 0;
    for (Ue = 0; Ue < 32; ++Ue) Je[Ue] = 0;
  }
  (function() {
    for (var Qe = [], dt = 0; dt < 32; dt++) Qe.push(5);
    $t(Qe, Je, 32);
    var ot = [];
    for (dt = 0; dt <= 143; dt++) ot.push(8);
    for (; dt <= 255; dt++) ot.push(9);
    for (; dt <= 279; dt++) ot.push(7);
    for (; dt <= 287; dt++) ot.push(8);
    $t(ot, ir, 288);
  })();
  var We = /* @__PURE__ */ function() {
    for (var dt = et ? new Uint8Array(32768) : [], ot = 0, ct = 0; ot < Ye.length - 1; ++ot)
      for (; ct < Ye[ot + 1]; ++ct) dt[ct] = ot;
    for (; ct < 32768; ++ct) dt[ct] = 29;
    var ut = et ? new Uint8Array(259) : [];
    for (ot = 0, ct = 0; ot < Bt.length - 1; ++ot)
      for (; ct < Bt[ot + 1]; ++ct) ut[ct] = ot;
    function ht(Nt, At) {
      for (var Ft = 0; Ft < Nt.length; ) {
        var kt = Math.min(65535, Nt.length - Ft), Ht = Ft + kt == Nt.length;
        for (At.write_shift(1, +Ht), At.write_shift(2, kt), At.write_shift(2, ~kt & 65535); kt-- > 0; ) At[At.l++] = Nt[Ft++];
      }
      return At.l;
    }
    function Tt(Nt, At) {
      for (var Ft = 0, kt = 0, Ht = et ? new Uint16Array(32768) : []; kt < Nt.length; ) {
        var Wt = (
          /* data.length - boff; */
          Math.min(65535, Nt.length - kt)
        );
        if (Wt < 10) {
          for (Ft = Vt(At, Ft, +(kt + Wt == Nt.length)), Ft & 7 && (Ft += 8 - (Ft & 7)), At.l = Ft / 8 | 0, At.write_shift(2, Wt), At.write_shift(2, ~Wt & 65535); Wt-- > 0; ) At[At.l++] = Nt[kt++];
          Ft = At.l * 8;
          continue;
        }
        Ft = Vt(At, Ft, +(kt + Wt == Nt.length) + 2);
        for (var jt = 0; Wt-- > 0; ) {
          var zt = Nt[kt];
          jt = (jt << 5 ^ zt) & 32767;
          var qt = -1, tr = 0;
          if ((qt = Ht[jt]) && (qt |= kt & -32768, qt > kt && (qt -= 32768), qt < kt))
            for (; Nt[qt + tr] == Nt[kt + tr] && tr < 250; ) ++tr;
          if (tr > 2) {
            zt = ut[tr], zt <= 22 ? Ft = er(At, Ft, je[zt + 1] >> 1) - 1 : (er(At, Ft, 3), Ft += 5, er(At, Ft, je[zt - 23] >> 5), Ft += 3);
            var hr = zt < 8 ? 0 : zt - 4 >> 2;
            hr > 0 && (Zt(At, Ft, tr - Bt[zt]), Ft += hr), zt = dt[kt - qt], Ft = er(At, Ft, je[zt] >> 3), Ft -= 3;
            var ur = zt < 4 ? 0 : zt - 2 >> 1;
            ur > 0 && (Zt(At, Ft, kt - qt - Ye[zt]), Ft += ur);
            for (var xr = 0; xr < tr; ++xr)
              Ht[jt] = kt & 32767, jt = (jt << 5 ^ Nt[kt]) & 32767, ++kt;
            Wt -= tr - 1;
          } else
            zt <= 143 ? zt = zt + 48 : Ft = Jt(At, Ft, 1), Ft = er(At, Ft, je[zt]), Ht[jt] = kt & 32767, ++kt;
        }
        Ft = er(At, Ft, 0) - 1;
      }
      return At.l = (Ft + 7) / 8 | 0, At.l;
    }
    return function(At, Ft) {
      return At.length < 8 ? ht(At, Ft) : Tt(At, Ft);
    };
  }();
  function lt(Qe) {
    var dt = new_buf(50 + Math.floor(Qe.length * 1.1)), ot = We(Qe, dt);
    return dt.slice(0, ot);
  }
  var ft = et ? new Uint16Array(32768) : Yt(32768), Et = et ? new Uint16Array(32768) : Yt(32768), Lt = et ? new Uint16Array(128) : Yt(128), Kt = 1, ar = 1;
  function sr(Qe, dt) {
    var ot = Ot(Qe, dt) + 257;
    dt += 5;
    var ct = Ot(Qe, dt) + 1;
    dt += 5;
    var ut = Rt(Qe, dt) + 4;
    dt += 4;
    for (var ht = 0, Tt = et ? new Uint8Array(19) : Yt(19), Nt = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], At = 1, Ft = et ? new Uint8Array(8) : Yt(8), kt = et ? new Uint8Array(8) : Yt(8), Ht = Tt.length, Wt = 0; Wt < ut; ++Wt)
      Tt[It[Wt]] = ht = Ct(Qe, dt), At < ht && (At = ht), Ft[ht]++, dt += 3;
    var jt = 0;
    for (Ft[0] = 0, Wt = 1; Wt <= At; ++Wt) kt[Wt] = jt = jt + Ft[Wt - 1] << 1;
    for (Wt = 0; Wt < Ht; ++Wt) (jt = Tt[Wt]) != 0 && (Nt[Wt] = kt[jt]++);
    var zt = 0;
    for (Wt = 0; Wt < Ht; ++Wt)
      if (zt = Tt[Wt], zt != 0) {
        jt = je[Nt[Wt]] >> 8 - zt;
        for (var qt = (1 << 7 - zt) - 1; qt >= 0; --qt) Lt[jt | qt << zt] = zt & 7 | Wt << 3;
      }
    var tr = [];
    for (At = 1; tr.length < ot + ct; )
      switch (jt = Lt[Mt(Qe, dt)], dt += jt & 7, jt >>>= 3) {
        case 16:
          for (ht = 3 + rt(Qe, dt), dt += 2, jt = tr[tr.length - 1]; ht-- > 0; ) tr.push(jt);
          break;
        case 17:
          for (ht = 3 + Ct(Qe, dt), dt += 3; ht-- > 0; ) tr.push(0);
          break;
        case 18:
          for (ht = 11 + Mt(Qe, dt), dt += 7; ht-- > 0; ) tr.push(0);
          break;
        default:
          tr.push(jt), At < jt && (At = jt);
          break;
      }
    var hr = tr.slice(0, ot), ur = tr.slice(ot);
    for (Wt = ot; Wt < 286; ++Wt) hr[Wt] = 0;
    for (Wt = ct; Wt < 30; ++Wt) ur[Wt] = 0;
    return Kt = $t(hr, ft, 286), ar = $t(ur, Et, 30), dt;
  }
  function or(Qe, dt) {
    if (Qe[0] == 3 && !(Qe[1] & 3))
      return [new_raw_buf(dt), 2];
    for (var ot = 0, ct = 0, ut = new_unsafe_buf(dt || 1 << 18), ht = 0, Tt = ut.length >>> 0, Nt = 0, At = 0; (ct & 1) == 0; ) {
      if (ct = Ct(Qe, ot), ot += 3, ct >>> 1)
        ct >> 1 == 1 ? (Nt = 9, At = 5) : (ot = sr(Qe, ot), Nt = Kt, At = ar);
      else {
        ot & 7 && (ot += 8 - (ot & 7));
        var Ft = Qe[ot >>> 3] | Qe[(ot >>> 3) + 1] << 8;
        if (ot += 32, Ft > 0)
          for (!dt && Tt < ht + Ft && (ut = Gt(ut, ht + Ft), Tt = ut.length); Ft-- > 0; )
            ut[ht++] = Qe[ot >>> 3], ot += 8;
        continue;
      }
      for (; ; ) {
        !dt && Tt < ht + 32767 && (ut = Gt(ut, ht + 32767), Tt = ut.length);
        var kt = Dt(Qe, ot, Nt), Ht = ct >>> 1 == 1 ? ir[kt] : ft[kt];
        if (ot += Ht & 15, Ht >>>= 4, (Ht >>> 8 & 255) === 0) ut[ht++] = Ht;
        else {
          if (Ht == 256) break;
          Ht -= 257;
          var Wt = Ht < 8 ? 0 : Ht - 4 >> 2;
          Wt > 5 && (Wt = 0);
          var jt = ht + Bt[Ht];
          Wt > 0 && (jt += Dt(Qe, ot, Wt), ot += Wt), kt = Dt(Qe, ot, At), Ht = ct >>> 1 == 1 ? Je[kt] : Et[kt], ot += Ht & 15, Ht >>>= 4;
          var zt = Ht < 4 ? 0 : Ht - 2 >> 1, qt = Ye[Ht];
          for (zt > 0 && (qt += Dt(Qe, ot, zt), ot += zt), !dt && Tt < jt && (ut = Gt(ut, jt + 100), Tt = ut.length); ht < jt; )
            ut[ht] = ut[ht - qt], ++ht;
        }
      }
    }
    return dt ? [ut, ot + 7 >>> 3] : [ut.slice(0, ht), ot + 7 >>> 3];
  }
  function nr(Qe, dt) {
    var ot = Qe.slice(Qe.l || 0), ct = or(ot, dt);
    return Qe.l += ct[1], ct[0];
  }
  function Nr(Qe, dt) {
    if (Qe)
      typeof console < "u" && console.error(dt);
    else throw new Error(dt);
  }
  function Zr(Qe, dt) {
    var ot = (
      /*::(*/
      Qe
    );
    prep_blob(ot, 0);
    var ct = [], ut = [], ht = {
      FileIndex: ct,
      FullPaths: ut
    };
    Ve(ht, { root: dt.root });
    for (var Tt = ot.length - 4; (ot[Tt] != 80 || ot[Tt + 1] != 75 || ot[Tt + 2] != 5 || ot[Tt + 3] != 6) && Tt >= 0; ) --Tt;
    ot.l = Tt + 4, ot.l += 4;
    var Nt = ot.read_shift(2);
    ot.l += 6;
    var At = ot.read_shift(4);
    for (ot.l = At, Tt = 0; Tt < Nt; ++Tt) {
      ot.l += 20;
      var Ft = ot.read_shift(4), kt = ot.read_shift(4), Ht = ot.read_shift(2), Wt = ot.read_shift(2), jt = ot.read_shift(2);
      ot.l += 8;
      var zt = ot.read_shift(4), qt = _e(
        /*::(*/
        ot.slice(ot.l + Ht, ot.l + Ht + Wt)
        /*:: :any)*/
      );
      ot.l += Ht + Wt + jt;
      var tr = ot.l;
      ot.l = zt + 4, qt && qt[1] && ((qt[1] || {}).usz && (kt = qt[1].usz), (qt[1] || {}).csz && (Ft = qt[1].csz)), va(ot, Ft, kt, ht, qt), ot.l = tr;
    }
    return ht;
  }
  function va(Qe, dt, ot, ct, ut) {
    Qe.l += 2;
    var ht = Qe.read_shift(2), Tt = Qe.read_shift(2), Nt = he(Qe);
    if (ht & 8257) throw new Error("Unsupported ZIP encryption");
    for (var At = Qe.read_shift(4), Ft = Qe.read_shift(4), kt = Qe.read_shift(4), Ht = Qe.read_shift(2), Wt = Qe.read_shift(2), jt = "", zt = 0; zt < Ht; ++zt) jt += String.fromCharCode(Qe[Qe.l++]);
    if (Wt) {
      var qt = _e(
        /*::(*/
        Qe.slice(Qe.l, Qe.l + Wt)
        /*:: :any)*/
      );
      (qt[21589] || {}).mt && (Nt = qt[21589].mt), (qt[1] || {}).usz && (kt = qt[1].usz), (qt[1] || {}).csz && (Ft = qt[1].csz), ut && ((ut[21589] || {}).mt && (Nt = ut[21589].mt), (ut[1] || {}).usz && (kt = ut[1].usz), (ut[1] || {}).csz && (Ft = ut[1].csz));
    }
    Qe.l += Wt;
    var tr = Qe.slice(Qe.l, Qe.l + Ft);
    switch (Tt) {
      case 8:
        tr = yt(Qe, kt);
        break;
      case 0:
        Qe.l += Ft;
        break;
      // TODO: scan for magic number
      default:
        throw new Error("Unsupported ZIP Compression method " + Tt);
    }
    var hr = !1;
    ht & 8 && (At = Qe.read_shift(4), At == 134695760 && (At = Qe.read_shift(4), hr = !0), Ft = Qe.read_shift(4), kt = Qe.read_shift(4)), Ft != dt && Nr(hr, "Bad compressed size: " + dt + " != " + Ft), kt != ot && Nr(hr, "Bad uncompressed size: " + ot + " != " + kt), wa(ct, jt, tr, { unsafe: !0, mt: Nt });
  }
  function ea(Qe, dt) {
    var ot = dt || {}, ct = [], ut = [], ht = new_buf(1), Tt = ot.compression ? 8 : 0, Nt = 0, At = 0, Ft = 0, kt = 0, Ht = 0, Wt = Qe.FullPaths[0], jt = Wt, zt = Qe.FileIndex[0], qt = [], tr = 0;
    for (At = 1; At < Qe.FullPaths.length; ++At)
      if (jt = Qe.FullPaths[At].slice(Wt.length), zt = Qe.FileIndex[At], !(!zt.size || !zt.content || Array.isArray(zt.content) && zt.content.length == 0 || jt == "Sh33tJ5")) {
        var hr = kt, ur = new_buf(jt.length);
        for (Ft = 0; Ft < jt.length; ++Ft) ur.write_shift(1, jt.charCodeAt(Ft) & 127);
        ur = ur.slice(0, ur.l), qt[Ht] = typeof zt.content == "string" ? CRC32.bstr(zt.content, 0) : CRC32.buf(
          /*::((*/
          zt.content,
          0
        );
        var xr = typeof zt.content == "string" ? s2a(zt.content) : zt.content;
        Tt == 8 && (xr = St(xr)), ht = new_buf(30), ht.write_shift(4, 67324752), ht.write_shift(2, 20), ht.write_shift(2, Nt), ht.write_shift(2, Tt), zt.mt ? fe(ht, zt.mt) : ht.write_shift(4, 0), ht.write_shift(-4, qt[Ht]), ht.write_shift(4, xr.length), ht.write_shift(
          4,
          /*::(*/
          zt.content.length
        ), ht.write_shift(2, ur.length), ht.write_shift(2, 0), kt += ht.length, ct.push(ht), kt += ur.length, ct.push(ur), kt += xr.length, ct.push(xr), ht = new_buf(46), ht.write_shift(4, 33639248), ht.write_shift(2, 0), ht.write_shift(2, 20), ht.write_shift(2, Nt), ht.write_shift(2, Tt), ht.write_shift(4, 0), ht.write_shift(-4, qt[Ht]), ht.write_shift(4, xr.length), ht.write_shift(
          4,
          /*::(*/
          zt.content.length
        ), ht.write_shift(2, ur.length), ht.write_shift(2, 0), ht.write_shift(2, 0), ht.write_shift(2, 0), ht.write_shift(2, 0), ht.write_shift(4, 0), ht.write_shift(4, hr), tr += ht.l, ut.push(ht), tr += ur.length, ut.push(ur), ++Ht;
      }
    return ht = new_buf(22), ht.write_shift(4, 101010256), ht.write_shift(2, 0), ht.write_shift(2, 0), ht.write_shift(2, Ht), ht.write_shift(2, Ht), ht.write_shift(4, tr), ht.write_shift(4, kt), ht.write_shift(2, 0), bconcat([bconcat(ct), bconcat(ut), ht]);
  }
  var Gr = {
    htm: "text/html",
    xml: "text/xml",
    gif: "image/gif",
    jpg: "image/jpeg",
    png: "image/png",
    mso: "application/x-mso",
    thmx: "application/vnd.ms-officetheme",
    sh33tj5: "application/octet-stream"
  };
  function ta(Qe, dt) {
    if (Qe.ctype) return Qe.ctype;
    var ot = Qe.name || "", ct = ot.match(/\.([^\.]+)$/);
    return ct && Gr[ct[1]] || dt && (ct = (ot = dt).match(/[\.\\]([^\.\\])+$/), ct && Gr[ct[1]]) ? Gr[ct[1]] : "application/octet-stream";
  }
  function xa(Qe) {
    for (var dt = Base64_encode(Qe), ot = [], ct = 0; ct < dt.length; ct += 76) ot.push(dt.slice(ct, ct + 76));
    return ot.join(`\r
`) + `\r
`;
  }
  function ya(Qe) {
    var dt = Qe.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(Ft) {
      var kt = Ft.charCodeAt(0).toString(16).toUpperCase();
      return "=" + (kt.length == 1 ? "0" + kt : kt);
    });
    dt = dt.replace(/ $/mg, "=20").replace(/\t$/mg, "=09"), dt.charAt(0) == `
` && (dt = "=0D" + dt.slice(1)), dt = dt.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, `
=0A`).replace(/([^\r\n])\n/mg, "$1=0A");
    for (var ot = [], ct = dt.split(`\r
`), ut = 0; ut < ct.length; ++ut) {
      var ht = ct[ut];
      if (ht.length == 0) {
        ot.push("");
        continue;
      }
      for (var Tt = 0; Tt < ht.length; ) {
        var Nt = 76, At = ht.slice(Tt, Tt + Nt);
        At.charAt(Nt - 1) == "=" ? Nt-- : At.charAt(Nt - 2) == "=" ? Nt -= 2 : At.charAt(Nt - 3) == "=" && (Nt -= 3), At = ht.slice(Tt, Tt + Nt), Tt += Nt, Tt < ht.length && (At += "="), ot.push(At);
      }
    }
    return ot.join(`\r
`);
  }
  function ba(Qe) {
    for (var dt = [], ot = 0; ot < Qe.length; ++ot) {
      for (var ct = Qe[ot]; ot <= Qe.length && ct.charAt(ct.length - 1) == "="; ) ct = ct.slice(0, ct.length - 1) + Qe[++ot];
      dt.push(ct);
    }
    for (var ut = 0; ut < dt.length; ++ut) dt[ut] = dt[ut].replace(/[=][0-9A-Fa-f]{2}/g, function(ht) {
      return String.fromCharCode(parseInt(ht.slice(1), 16));
    });
    return s2a(dt.join(`\r
`));
  }
  function jr(Qe, dt, ot) {
    for (var ct = "", ut = "", ht = "", Tt, Nt = 0; Nt < 10; ++Nt) {
      var At = dt[Nt];
      if (!At || At.match(/^\s*$/)) break;
      var Ft = At.match(/^([^:]*?):\s*([^\s].*)$/);
      if (Ft) switch (Ft[1].toLowerCase()) {
        case "content-location":
          ct = Ft[2].trim();
          break;
        case "content-type":
          ht = Ft[2].trim();
          break;
        case "content-transfer-encoding":
          ut = Ft[2].trim();
          break;
      }
    }
    switch (++Nt, ut.toLowerCase()) {
      case "base64":
        Tt = s2a(Base64_decode(dt.slice(Nt).join("")));
        break;
      case "quoted-printable":
        Tt = ba(dt.slice(Nt));
        break;
      default:
        throw new Error("Unsupported Content-Transfer-Encoding " + ut);
    }
    var kt = wa(Qe, ct.slice(ot.length), Tt, { unsafe: !0 });
    ht && (kt.ctype = ht);
  }
  function Ba(Qe, dt) {
    if (gt(Qe.slice(0, 13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
    var ot = dt && dt.root || "", ct = (has_buf && Buffer.isBuffer(Qe) ? Qe.toString("binary") : gt(Qe)).split(`\r
`), ut = 0, ht = "";
    for (ut = 0; ut < ct.length; ++ut)
      if (ht = ct[ut], !!/^Content-Location:/i.test(ht) && (ht = ht.slice(ht.indexOf("file")), ot || (ot = ht.slice(0, ht.lastIndexOf("/") + 1)), ht.slice(0, ot.length) != ot))
        for (; ot.length > 0 && (ot = ot.slice(0, ot.length - 1), ot = ot.slice(0, ot.lastIndexOf("/") + 1), ht.slice(0, ot.length) != ot); )
          ;
    var Tt = (ct[1] || "").match(/boundary="(.*?)"/);
    if (!Tt) throw new Error("MAD cannot find boundary");
    var Nt = "--" + (Tt[1] || ""), At = [], Ft = [], kt = {
      FileIndex: At,
      FullPaths: Ft
    };
    Ve(kt);
    var Ht, Wt = 0;
    for (ut = 0; ut < ct.length; ++ut) {
      var jt = ct[ut];
      jt !== Nt && jt !== Nt + "--" || (Wt++ && jr(kt, ct.slice(Ht, ut), ot), Ht = ut);
    }
    return kt;
  }
  function Wr(Qe, dt) {
    var ot = dt || {}, ct = ot.boundary || "SheetJS";
    ct = "------=" + ct;
    for (var ut = [
      "MIME-Version: 1.0",
      'Content-Type: multipart/related; boundary="' + ct.slice(2) + '"',
      "",
      "",
      ""
    ], ht = Qe.FullPaths[0], Tt = ht, Nt = Qe.FileIndex[0], At = 1; At < Qe.FullPaths.length; ++At)
      if (Tt = Qe.FullPaths[At].slice(ht.length), Nt = Qe.FileIndex[At], !(!Nt.size || !Nt.content || Tt == "Sh33tJ5")) {
        Tt = Tt.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(tr) {
          return "_x" + tr.charCodeAt(0).toString(16) + "_";
        }).replace(/[\u0080-\uFFFF]/g, function(tr) {
          return "_u" + tr.charCodeAt(0).toString(16) + "_";
        });
        for (var Ft = Nt.content, kt = has_buf && Buffer.isBuffer(Ft) ? Ft.toString("binary") : gt(Ft), Ht = 0, Wt = Math.min(1024, kt.length), jt = 0, zt = 0; zt <= Wt; ++zt) (jt = kt.charCodeAt(zt)) >= 32 && jt < 128 && ++Ht;
        var qt = Ht >= Wt * 4 / 5;
        ut.push(ct), ut.push("Content-Location: " + (ot.root || "file:///C:/SheetJS/") + Tt), ut.push("Content-Transfer-Encoding: " + (qt ? "quoted-printable" : "base64")), ut.push("Content-Type: " + ta(Nt, Tt)), ut.push(""), ut.push(qt ? ya(kt) : xa(kt));
      }
    return ut.push(ct + `--\r
`), ut.join(`\r
`);
  }
  function Ka(Qe) {
    var dt = {};
    return Ve(dt, Qe), dt;
  }
  function wa(Qe, dt, ot, ct) {
    var ut = ct && ct.unsafe;
    ut || Ve(Qe);
    var ht = !ut && CFB.find(Qe, dt);
    if (!ht) {
      var Tt = Qe.FullPaths[0];
      dt.slice(0, Tt.length) == Tt ? Tt = dt : (Tt.slice(-1) != "/" && (Tt += "/"), Tt = (Tt + dt).replace("//", "/")), ht = { name: ue(dt), type: 2 }, Qe.FileIndex.push(ht), Qe.FullPaths.push(Tt), ut || CFB.utils.cfb_gc(Qe);
    }
    return ht.content = ot, ht.size = ot ? ot.length : 0, ct && (ct.CLSID && (ht.clsid = ct.CLSID), ct.mt && (ht.mt = ct.mt), ct.ct && (ht.ct = ct.ct)), ht;
  }
  function Ya(Qe, dt) {
    Ve(Qe);
    var ot = CFB.find(Qe, dt);
    if (ot) {
      for (var ct = 0; ct < Qe.FileIndex.length; ++ct) if (Qe.FileIndex[ct] == ot)
        return Qe.FileIndex.splice(ct, 1), Qe.FullPaths.splice(ct, 1), !0;
    }
    return !1;
  }
  function Da(Qe, dt, ot) {
    Ve(Qe);
    var ct = CFB.find(Qe, dt);
    if (ct) {
      for (var ut = 0; ut < Qe.FileIndex.length; ++ut) if (Qe.FileIndex[ut] == ct)
        return Qe.FileIndex[ut].name = ue(ot), Qe.FullPaths[ut] = ot, !0;
    }
    return !1;
  }
  function Ea(Qe) {
    De(Qe, !0);
  }
  return Y.find = ze, Y.read = Ge, Y.parse = Ee, Y.write = Ze, Y.writeFile = xt, Y.utils = {
    cfb_new: Ka,
    cfb_add: wa,
    cfb_del: Ya,
    cfb_mov: Da,
    cfb_gc: Ea,
    ReadShift,
    CheckField,
    prep_blob,
    bconcat,
    use_zlib: wt,
    _deflateRaw: lt,
    _inflateRaw: nr,
    consts: st
  }, Y;
}(), _fs;
function set_fs(le) {
  _fs = le;
}
function blobify(le) {
  return typeof le == "string" ? s2ab(le) : Array.isArray(le) ? a2u(le) : le;
}
function write_dl(le, Y, re) {
  if (typeof _fs < "u" && _fs.writeFileSync) return re ? _fs.writeFileSync(le, Y, re) : _fs.writeFileSync(le, Y);
  if (typeof Deno < "u") {
    if (re && typeof Y == "string") switch (re) {
      case "utf8":
        Y = new TextEncoder(re).encode(Y);
        break;
      case "binary":
        Y = s2ab(Y);
        break;
      /* TODO: binary equivalent */
      default:
        throw new Error("Unsupported encoding " + re);
    }
    return Deno.writeFileSync(le, Y);
  }
  var oe = re == "utf8" ? utf8write(Y) : Y;
  if (typeof IE_SaveFile < "u") return IE_SaveFile(oe, le);
  if (typeof Blob < "u") {
    var ue = new Blob([blobify(oe)], { type: "application/octet-stream" });
    if (typeof navigator < "u" && navigator.msSaveBlob) return navigator.msSaveBlob(ue, le);
    if (typeof saveAs < "u") return saveAs(ue, le);
    if (typeof URL < "u" && typeof document < "u" && document.createElement && URL.createObjectURL) {
      var fe = URL.createObjectURL(ue);
      if (typeof chrome == "object" && typeof (chrome.downloads || {}).download == "function")
        return URL.revokeObjectURL && typeof setTimeout < "u" && setTimeout(function() {
          URL.revokeObjectURL(fe);
        }, 6e4), chrome.downloads.download({ url: fe, filename: le, saveAs: !0 });
      var he = document.createElement("a");
      if (he.download != null)
        return he.download = le, he.href = fe, document.body.appendChild(he), he.click(), document.body.removeChild(he), URL.revokeObjectURL && typeof setTimeout < "u" && setTimeout(function() {
          URL.revokeObjectURL(fe);
        }, 6e4), fe;
    } else if (typeof URL < "u" && !URL.createObjectURL && typeof chrome == "object") {
      var _e = "data:application/octet-stream;base64," + Base64_encode_arr(new Uint8Array(blobify(oe)));
      return chrome.downloads.download({ url: _e, filename: le, saveAs: !0 });
    }
  }
  if (typeof $ < "u" && typeof File < "u" && typeof Folder < "u") try {
    var ve = File(le);
    return ve.open("w"), ve.encoding = "binary", Array.isArray(Y) && (Y = a2s(Y)), ve.write(Y), ve.close(), Y;
  } catch (xe) {
    if (!xe.message || xe.message.indexOf("onstruct") == -1) throw xe;
  }
  throw new Error("cannot save file " + le);
}
function read_binary(le) {
  if (typeof _fs < "u") return _fs.readFileSync(le);
  if (typeof Deno < "u") return Deno.readFileSync(le);
  if (typeof $ < "u" && typeof File < "u" && typeof Folder < "u") try {
    var Y = File(le);
    Y.open("r"), Y.encoding = "binary";
    var re = Y.read();
    return Y.close(), re;
  } catch (oe) {
    if (!oe.message || oe.message.indexOf("onstruct") == -1) throw oe;
  }
  throw new Error("Cannot access file " + le);
}
function keys(le) {
  for (var Y = Object.keys(le), re = [], oe = 0; oe < Y.length; ++oe) Object.prototype.hasOwnProperty.call(le, Y[oe]) && re.push(Y[oe]);
  return re;
}
function evert_key(le, Y) {
  for (var re = [], oe = keys(le), ue = 0; ue !== oe.length; ++ue) re[le[oe[ue]][Y]] == null && (re[le[oe[ue]][Y]] = oe[ue]);
  return re;
}
function evert(le) {
  for (var Y = [], re = keys(le), oe = 0; oe !== re.length; ++oe) Y[le[re[oe]]] = re[oe];
  return Y;
}
function evert_num(le) {
  for (var Y = [], re = keys(le), oe = 0; oe !== re.length; ++oe) Y[le[re[oe]]] = parseInt(re[oe], 10);
  return Y;
}
function evert_arr(le) {
  for (var Y = [], re = keys(le), oe = 0; oe !== re.length; ++oe)
    Y[le[re[oe]]] == null && (Y[le[re[oe]]] = []), Y[le[re[oe]]].push(re[oe]);
  return Y;
}
var dnthresh = /* @__PURE__ */ Date.UTC(1899, 11, 30, 0, 0, 0), dnthresh1 = /* @__PURE__ */ Date.UTC(1899, 11, 31, 0, 0, 0), dnthresh2 = /* @__PURE__ */ Date.UTC(1904, 0, 1, 0, 0, 0);
function datenum(le, Y) {
  var re = /* @__PURE__ */ le.getTime(), oe = (re - dnthresh) / (24 * 60 * 60 * 1e3);
  return Y ? (oe -= 1462, oe < -1402 ? oe - 1 : oe) : oe < 60 ? oe - 1 : oe;
}
function numdate(le) {
  if (le >= 60 && le < 61) return le;
  var Y = /* @__PURE__ */ new Date();
  return Y.setTime((le > 60 ? le : le + 1) * 24 * 60 * 60 * 1e3 + dnthresh), Y;
}
function parse_isodur(le) {
  var Y = 0, re = 0, oe = !1, ue = le.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);
  if (!ue) throw new Error("|" + le + "| is not an ISO8601 Duration");
  for (var fe = 1; fe != ue.length; ++fe)
    if (ue[fe]) {
      switch (re = 1, fe > 3 && (oe = !0), ue[fe].slice(ue[fe].length - 1)) {
        case "Y":
          throw new Error("Unsupported ISO Duration Field: " + ue[fe].slice(ue[fe].length - 1));
        case "D":
          re *= 24;
        /* falls through */
        case "H":
          re *= 60;
        /* falls through */
        case "M":
          if (oe) re *= 60;
          else throw new Error("Unsupported ISO Duration Field: M");
      }
      Y += re * parseInt(ue[fe], 10);
    }
  return Y;
}
var pdre1 = /^(\d+):(\d+)(:\d+)?(\.\d+)?$/, pdre2 = /^(\d+)-(\d+)-(\d+)$/, pdre3 = /^(\d+)-(\d+)-(\d+)[T ](\d+):(\d+)(:\d+)?(\.\d+)?$/;
function parseDate(le, Y) {
  if (le instanceof Date) return le;
  var re = le.match(pdre1);
  if (re) return new Date((Y ? dnthresh2 : dnthresh1) + ((parseInt(re[1], 10) * 60 + parseInt(re[2], 10)) * 60 + (re[3] ? parseInt(re[3].slice(1), 10) : 0)) * 1e3 + (re[4] ? parseInt((re[4] + "000").slice(1, 4), 10) : 0));
  if (re = le.match(pdre2), re) return new Date(Date.UTC(+re[1], +re[2] - 1, +re[3], 0, 0, 0, 0));
  if (re = le.match(pdre3), re) return new Date(Date.UTC(+re[1], +re[2] - 1, +re[3], +re[4], +re[5], re[6] && parseInt(re[6].slice(1), 10) || 0, re[7] && parseInt((re[7] + "0000").slice(1, 4), 10) || 0));
  var oe = new Date(le);
  return oe;
}
function cc2str(le, Y) {
  if (has_buf && Buffer.isBuffer(le)) {
    if (Y && buf_utf16le) {
      if (le[0] == 255 && le[1] == 254) return utf8write(le.slice(2).toString("utf16le"));
      if (le[1] == 254 && le[2] == 255) return utf8write(utf16beread(le.slice(2).toString("binary")));
    }
    return le.toString("binary");
  }
  if (typeof TextDecoder < "u") try {
    if (Y) {
      if (le[0] == 255 && le[1] == 254) return utf8write(new TextDecoder("utf-16le").decode(le.slice(2)));
      if (le[0] == 254 && le[1] == 255) return utf8write(new TextDecoder("utf-16be").decode(le.slice(2)));
    }
    var re = {
      "€": "",
      "‚": "",
      ƒ: "",
      "„": "",
      "…": "",
      "†": "",
      "‡": "",
      "ˆ": "",
      "‰": "",
      Š: "",
      "‹": "",
      Œ: "",
      Ž: "",
      "‘": "",
      "’": "",
      "“": "",
      "”": "",
      "•": "",
      "–": "",
      "—": "",
      "˜": "",
      "™": "",
      š: "",
      "›": "",
      œ: "",
      ž: "",
      Ÿ: ""
    };
    return Array.isArray(le) && (le = new Uint8Array(le)), new TextDecoder("latin1").decode(le).replace(/[€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ]/g, function(fe) {
      return re[fe] || fe;
    });
  } catch {
  }
  var oe = [], ue = 0;
  try {
    for (ue = 0; ue < le.length - 65536; ue += 65536) oe.push(String.fromCharCode.apply(0, le.slice(ue, ue + 65536)));
    oe.push(String.fromCharCode.apply(0, le.slice(ue)));
  } catch {
    try {
      for (; ue < le.length - 16384; ue += 16384) oe.push(String.fromCharCode.apply(0, le.slice(ue, ue + 16384)));
      oe.push(String.fromCharCode.apply(0, le.slice(ue)));
    } catch {
      for (; ue != le.length; ++ue) oe.push(String.fromCharCode(le[ue]));
    }
  }
  return oe.join("");
}
function dup(le) {
  if (typeof JSON < "u" && !Array.isArray(le)) return JSON.parse(JSON.stringify(le));
  if (typeof le != "object" || le == null) return le;
  if (le instanceof Date) return new Date(le.getTime());
  var Y = {};
  for (var re in le) Object.prototype.hasOwnProperty.call(le, re) && (Y[re] = dup(le[re]));
  return Y;
}
function fill(le, Y) {
  for (var re = ""; re.length < Y; ) re += le;
  return re;
}
function fuzzynum(le) {
  var Y = Number(le);
  if (!isNaN(Y)) return isFinite(Y) ? Y : NaN;
  if (!/\d/.test(le)) return Y;
  var re = 1, oe = le.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
    return re *= 100, "";
  });
  return !isNaN(Y = Number(oe)) || (oe = oe.replace(/[(]([^()]*)[)]/, function(ue, fe) {
    return re = -re, fe;
  }), !isNaN(Y = Number(oe))) ? Y / re : Y;
}
var FDRE1 = /^(0?\d|1[0-2])(?:|:([0-5]?\d)(?:|(\.\d+)(?:|:([0-5]?\d))|:([0-5]?\d)(|\.\d+)))\s+([ap])m?$/, FDRE2 = /^([01]?\d|2[0-3])(?:|:([0-5]?\d)(?:|(\.\d+)(?:|:([0-5]?\d))|:([0-5]?\d)(|\.\d+)))$/, FDISO = /^(\d+)-(\d+)-(\d+)[T ](\d+):(\d+)(:\d+)(\.\d+)?[Z]?$/, utc_append_works = (/* @__PURE__ */ new Date("6/9/69 00:00 UTC")).valueOf() == -177984e5;
function fuzzytime1(le) {
  return le[2] ? le[3] ? le[4] ? new Date(Date.UTC(1899, 11, 31, +le[1] % 12 + (le[7] == "p" ? 12 : 0), +le[2], +le[4], parseFloat(le[3]) * 1e3)) : new Date(Date.UTC(1899, 11, 31, le[7] == "p" ? 12 : 0, +le[1], +le[2], parseFloat(le[3]) * 1e3)) : le[5] ? new Date(Date.UTC(1899, 11, 31, +le[1] % 12 + (le[7] == "p" ? 12 : 0), +le[2], +le[5], le[6] ? parseFloat(le[6]) * 1e3 : 0)) : new Date(Date.UTC(1899, 11, 31, +le[1] % 12 + (le[7] == "p" ? 12 : 0), +le[2], 0, 0)) : new Date(Date.UTC(1899, 11, 31, +le[1] % 12 + (le[7] == "p" ? 12 : 0), 0, 0, 0));
}
function fuzzytime2(le) {
  return le[2] ? le[3] ? le[4] ? new Date(Date.UTC(1899, 11, 31, +le[1], +le[2], +le[4], parseFloat(le[3]) * 1e3)) : new Date(Date.UTC(1899, 11, 31, 0, +le[1], +le[2], parseFloat(le[3]) * 1e3)) : le[5] ? new Date(Date.UTC(1899, 11, 31, +le[1], +le[2], +le[5], le[6] ? parseFloat(le[6]) * 1e3 : 0)) : new Date(Date.UTC(1899, 11, 31, +le[1], +le[2], 0, 0)) : new Date(Date.UTC(1899, 11, 31, +le[1], 0, 0, 0));
}
var lower_months = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function fuzzydate(le) {
  if (FDISO.test(le)) return le.indexOf("Z") == -1 ? local_to_utc(new Date(le)) : new Date(le);
  var Y = le.toLowerCase(), re = Y.replace(/\s+/g, " ").trim(), oe = re.match(FDRE1);
  if (oe) return fuzzytime1(oe);
  if (oe = re.match(FDRE2), oe) return fuzzytime2(oe);
  if (oe = re.match(pdre3), oe) return new Date(Date.UTC(+oe[1], +oe[2] - 1, +oe[3], +oe[4], +oe[5], oe[6] && parseInt(oe[6].slice(1), 10) || 0, oe[7] && parseInt((oe[7] + "0000").slice(1, 4), 10) || 0));
  var ue = new Date(utc_append_works && le.indexOf("UTC") == -1 ? le + " UTC" : le), fe = /* @__PURE__ */ new Date(NaN), he = ue.getYear();
  ue.getMonth();
  var _e = ue.getDate();
  if (isNaN(_e)) return fe;
  if (Y.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
    if (Y = Y.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, ""), Y.length > 3 && lower_months.indexOf(Y) == -1) return fe;
  } else if (Y.replace(/[ap]m?/, "").match(/[a-z]/)) return fe;
  return he < 0 || he > 8099 || le.match(/[^-0-9:,\/\\\ ]/) ? fe : ue;
}
var split_regex = /* @__PURE__ */ function() {
  var le = "abacaba".split(/(:?b)/i).length == 5;
  return function(re, oe, ue) {
    if (le || typeof oe == "string") return re.split(oe);
    for (var fe = re.split(oe), he = [fe[0]], _e = 1; _e < fe.length; ++_e)
      he.push(ue), he.push(fe[_e]);
    return he;
  };
}();
function utc_to_local(le) {
  return new Date(le.getUTCFullYear(), le.getUTCMonth(), le.getUTCDate(), le.getUTCHours(), le.getUTCMinutes(), le.getUTCSeconds(), le.getUTCMilliseconds());
}
function local_to_utc(le) {
  return new Date(Date.UTC(le.getFullYear(), le.getMonth(), le.getDate(), le.getHours(), le.getMinutes(), le.getSeconds(), le.getMilliseconds()));
}
function remove_doctype(le) {
  var Y = le.slice(0, 1024), re = Y.indexOf("<!DOCTYPE");
  if (re == -1) return le;
  var oe = le.match(/<[\w]/);
  return oe ? le.slice(0, re) + le.slice(oe.index) : le;
}
function str_match_ng(le, Y, re) {
  for (var oe = [], ue = le.indexOf(Y); ue > -1; ) {
    var fe = le.indexOf(re, ue + Y.length);
    if (fe == -1) break;
    oe.push(le.slice(ue, fe + re.length)), ue = le.indexOf(Y, fe + re.length);
  }
  return oe.length > 0 ? oe : null;
}
function str_remove_ng(le, Y, re) {
  var oe = [], ue = 0, fe = le.indexOf(Y);
  if (fe == -1) return le;
  for (; fe > -1; ) {
    oe.push(le.slice(ue, fe));
    var he = le.indexOf(re, fe + Y.length);
    if (he == -1) break;
    (fe = le.indexOf(Y, ue = he + re.length)) == -1 && oe.push(le.slice(ue));
  }
  return oe.join("");
}
var xml_boundary = { " ": 1, "	": 1, "\r": 1, "\n": 1, ">": 1 };
function str_match_xml(le, Y) {
  for (var re = le.indexOf("<" + Y), oe = Y.length + 1, ue = le.length; re >= 0 && re <= ue - oe && !xml_boundary[le.charAt(re + oe)]; ) re = le.indexOf("<" + Y, re + 1);
  if (re === -1) return null;
  var fe = le.indexOf(">", re + Y.length);
  if (fe === -1) return null;
  var he = "</" + Y + ">", _e = le.indexOf(he, fe);
  return _e == -1 ? null : [le.slice(re, _e + he.length), le.slice(fe + 1, _e)];
}
var str_match_xml_ns = /* @__PURE__ */ function() {
  var le = {};
  return function(re, oe) {
    var ue = le[oe];
    ue || (le[oe] = ue = [
      new RegExp("<(?:\\w+:)?" + oe + "\\b[^<>]*>", "g"),
      new RegExp("</(?:\\w+:)?" + oe + ">", "g")
    ]), ue[0].lastIndex = ue[1].lastIndex = 0;
    var fe = ue[0].exec(re);
    if (!fe) return null;
    var he = fe.index, _e = ue[0].lastIndex;
    if (ue[1].lastIndex = ue[0].lastIndex, fe = ue[1].exec(re), !fe) return null;
    var ve = fe.index, xe = ue[1].lastIndex;
    return [re.slice(he, xe), re.slice(_e, ve)];
  };
}(), str_match_xml_ns_g = /* @__PURE__ */ function() {
  var le = {};
  return function(re, oe) {
    var ue = [], fe = le[oe];
    fe || (le[oe] = fe = [
      new RegExp("<(?:\\w+:)?" + oe + "\\b[^<>]*>", "g"),
      new RegExp("</(?:\\w+:)?" + oe + ">", "g")
    ]), fe[0].lastIndex = fe[1].lastIndex = 0;
    for (var he; he = fe[0].exec(re); ) {
      var _e = he.index;
      if (fe[1].lastIndex = fe[0].lastIndex, he = fe[1].exec(re), !he) return null;
      var ve = fe[1].lastIndex;
      ue.push(re.slice(_e, ve)), fe[0].lastIndex = fe[1].lastIndex;
    }
    return ue.length == 0 ? null : ue;
  };
}(), str_remove_xml_ns_g = /* @__PURE__ */ function() {
  var le = {};
  return function(re, oe) {
    var ue = [], fe = le[oe];
    fe || (le[oe] = fe = [
      new RegExp("<(?:\\w+:)?" + oe + "\\b[^<>]*>", "g"),
      new RegExp("</(?:\\w+:)?" + oe + ">", "g")
    ]), fe[0].lastIndex = fe[1].lastIndex = 0;
    for (var he, _e = 0, ve = 0; he = fe[0].exec(re); ) {
      if (_e = he.index, ue.push(re.slice(ve, _e)), ve = _e, fe[1].lastIndex = fe[0].lastIndex, he = fe[1].exec(re), !he) return null;
      ve = fe[1].lastIndex, fe[0].lastIndex = fe[1].lastIndex;
    }
    return ue.push(re.slice(ve)), ue.length == 0 ? "" : ue.join("");
  };
}(), str_match_xml_ig = /* @__PURE__ */ function() {
  var le = {};
  return function(re, oe) {
    var ue = [], fe = le[oe];
    fe || (le[oe] = fe = [
      new RegExp("<" + oe + "\\b[^<>]*>", "ig"),
      new RegExp("</" + oe + ">", "ig")
    ]), fe[0].lastIndex = fe[1].lastIndex = 0;
    for (var he; he = fe[0].exec(re); ) {
      var _e = he.index;
      if (fe[1].lastIndex = fe[0].lastIndex, he = fe[1].exec(re), !he) return null;
      var ve = fe[1].lastIndex;
      ue.push(re.slice(_e, ve)), fe[0].lastIndex = fe[1].lastIndex;
    }
    return ue.length == 0 ? null : ue;
  };
}();
function getdatastr(le) {
  return le ? le.content && le.type ? cc2str(le.content, !0) : le.data ? debom(le.data) : le.asNodeBuffer && has_buf ? debom(le.asNodeBuffer().toString("binary")) : le.asBinary ? debom(le.asBinary()) : le._data && le._data.getContent ? debom(cc2str(Array.prototype.slice.call(le._data.getContent(), 0))) : null : null;
}
function getdatabin(le) {
  if (!le) return null;
  if (le.data) return char_codes(le.data);
  if (le.asNodeBuffer && has_buf) return le.asNodeBuffer();
  if (le._data && le._data.getContent) {
    var Y = le._data.getContent();
    return typeof Y == "string" ? char_codes(Y) : Array.prototype.slice.call(Y);
  }
  return le.content && le.type ? le.content : null;
}
function getdata(le) {
  return le && le.name.slice(-4) === ".bin" ? getdatabin(le) : getdatastr(le);
}
function safegetzipfile(le, Y) {
  for (var re = le.FullPaths || keys(le.files), oe = Y.toLowerCase().replace(/[\/]/g, "\\"), ue = oe.replace(/\\/g, "/"), fe = 0; fe < re.length; ++fe) {
    var he = re[fe].replace(/^Root Entry[\/]/, "").toLowerCase();
    if (oe == he || ue == he) return le.files ? le.files[re[fe]] : le.FileIndex[fe];
  }
  return null;
}
function getzipfile(le, Y) {
  var re = safegetzipfile(le, Y);
  if (re == null) throw new Error("Cannot find file " + Y + " in zip");
  return re;
}
function getzipdata(le, Y, re) {
  if (!re) return getdata(getzipfile(le, Y));
  if (!Y) return null;
  try {
    return getzipdata(le, Y);
  } catch {
    return null;
  }
}
function getzipstr(le, Y, re) {
  if (!re) return getdatastr(getzipfile(le, Y));
  if (!Y) return null;
  try {
    return getzipstr(le, Y);
  } catch {
    return null;
  }
}
function getzipbin(le, Y, re) {
  return getdatabin(getzipfile(le, Y));
}
function zipentries(le) {
  for (var Y = le.FullPaths || keys(le.files), re = [], oe = 0; oe < Y.length; ++oe) Y[oe].slice(-1) != "/" && re.push(Y[oe].replace(/^Root Entry[\/]/, ""));
  return re.sort();
}
function zip_add_file(le, Y, re) {
  if (le.FullPaths) {
    if (Array.isArray(re) && typeof re[0] == "string" && (re = re.join("")), typeof re == "string") {
      var oe;
      return has_buf ? oe = Buffer_from(re) : oe = utf8decode(re), CFB.utils.cfb_add(le, Y, oe);
    }
    CFB.utils.cfb_add(le, Y, re);
  } else le.file(Y, re);
}
function zip_new() {
  return CFB.utils.cfb_new();
}
function zip_read(le, Y) {
  switch (Y.type) {
    case "base64":
      return CFB.read(le, { type: "base64" });
    case "binary":
      return CFB.read(le, { type: "binary" });
    case "buffer":
    case "array":
      return CFB.read(le, { type: "buffer" });
  }
  throw new Error("Unrecognized type " + Y.type);
}
function resolve_path(le, Y) {
  if (le.charAt(0) == "/") return le.slice(1);
  var re = Y.split("/");
  Y.slice(-1) != "/" && re.pop();
  for (var oe = le.split("/"); oe.length !== 0; ) {
    var ue = oe.shift();
    ue === ".." ? re.pop() : ue !== "." && re.push(ue);
  }
  return re.join("/");
}
var XML_HEADER = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r
`, attregexg = /\s([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g, tagregex1 = /<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?<>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'"<>\s=]+))*\s*[\/\?]?>/mg, tagregex2 = /<[^<>]*>/g, tagregex = /* @__PURE__ */ XML_HEADER.match(tagregex1) ? tagregex1 : tagregex2, nsregex = /<\w*:/, nsregex2 = /<(\/?)\w+:/;
function parsexmltag(le, Y, re) {
  for (var oe = {}, ue = 0, fe = 0; ue !== le.length && !((fe = le.charCodeAt(ue)) === 32 || fe === 10 || fe === 13); ++ue) ;
  if (Y || (oe[0] = le.slice(0, ue)), ue === le.length) return oe;
  var he = le.match(attregexg), _e = 0, ve = "", xe = 0, Ee = "", Se = "", Te = 1;
  if (he) for (xe = 0; xe != he.length; ++xe) {
    for (Se = he[xe].slice(1), fe = 0; fe != Se.length && Se.charCodeAt(fe) !== 61; ++fe) ;
    for (Ee = Se.slice(0, fe).trim(); Se.charCodeAt(fe + 1) == 32; ) ++fe;
    for (Te = (ue = Se.charCodeAt(fe + 1)) == 34 || ue == 39 ? 1 : 0, ve = Se.slice(fe + 1 + Te, Se.length - Te), _e = 0; _e != Ee.length && Ee.charCodeAt(_e) !== 58; ++_e) ;
    if (_e === Ee.length)
      Ee.indexOf("_") > 0 && (Ee = Ee.slice(0, Ee.indexOf("_"))), oe[Ee] = ve, oe[Ee.toLowerCase()] = ve;
    else {
      var Ce = (_e === 5 && Ee.slice(0, 5) === "xmlns" ? "xmlns" : "") + Ee.slice(_e + 1);
      if (oe[Ce] && Ee.slice(_e - 3, _e) == "ext") continue;
      oe[Ce] = ve, oe[Ce.toLowerCase()] = ve;
    }
  }
  return oe;
}
function parsexmltagraw(le, Y, re) {
  for (var oe = {}, ue = 0, fe = 0; ue !== le.length && !((fe = le.charCodeAt(ue)) === 32 || fe === 10 || fe === 13); ++ue) ;
  if (ue === le.length) return oe;
  var he = le.match(attregexg), _e = "", ve = 0, xe = "", Ee = "", Se = 1;
  if (he) for (ve = 0; ve != he.length; ++ve) {
    for (Ee = he[ve].slice(1), fe = 0; fe != Ee.length && Ee.charCodeAt(fe) !== 61; ++fe) ;
    for (xe = Ee.slice(0, fe).trim(); Ee.charCodeAt(fe + 1) == 32; ) ++fe;
    Se = (ue = Ee.charCodeAt(fe + 1)) == 34 || ue == 39 ? 1 : 0, _e = Ee.slice(fe + 1 + Se, Ee.length - Se), xe.indexOf("_") > 0 && (xe = xe.slice(0, xe.indexOf("_"))), oe[xe] = _e, oe[xe.toLowerCase()] = _e;
  }
  return oe;
}
function strip_ns(le) {
  return le.replace(nsregex2, "<$1");
}
var encodings = {
  "&quot;": '"',
  "&apos;": "'",
  "&gt;": ">",
  "&lt;": "<",
  "&amp;": "&"
}, rencoding = /* @__PURE__ */ evert(encodings), unescapexml = /* @__PURE__ */ function() {
  var le = /&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/ig, Y = /_x([\da-fA-F]{4})_/ig;
  function re(oe) {
    var ue = oe + "", fe = ue.indexOf("<![CDATA[");
    if (fe == -1) return ue.replace(le, function(_e, ve) {
      return encodings[_e] || String.fromCharCode(parseInt(ve, _e.indexOf("x") > -1 ? 16 : 10)) || _e;
    }).replace(Y, function(_e, ve) {
      return String.fromCharCode(parseInt(ve, 16));
    });
    var he = ue.indexOf("]]>");
    return re(ue.slice(0, fe)) + ue.slice(fe + 9, he) + re(ue.slice(he + 3));
  }
  return function(ue, fe) {
    var he = re(ue);
    return fe ? he.replace(/\r\n/g, `
`) : he;
  };
}(), decregex = /[&<>'"]/g, charegex = /[\u0000-\u0008\u000b-\u001f\uFFFE-\uFFFF]/g;
function escapexml(le) {
  var Y = le + "";
  return Y.replace(decregex, function(re) {
    return rencoding[re];
  }).replace(charegex, function(re) {
    return "_x" + ("000" + re.charCodeAt(0).toString(16)).slice(-4) + "_";
  });
}
function escapexmltag(le) {
  return escapexml(le).replace(/ /g, "_x0020_");
}
var htmlcharegex = /[\u0000-\u001f]/g;
function escapehtml(le) {
  var Y = le + "";
  return Y.replace(decregex, function(re) {
    return rencoding[re];
  }).replace(/\n/g, "<br/>").replace(htmlcharegex, function(re) {
    return "&#x" + ("000" + re.charCodeAt(0).toString(16)).slice(-4) + ";";
  });
}
function escapexlml(le) {
  var Y = le + "";
  return Y.replace(decregex, function(re) {
    return rencoding[re];
  }).replace(htmlcharegex, function(re) {
    return "&#x" + re.charCodeAt(0).toString(16).toUpperCase() + ";";
  });
}
var xlml_fixstr = /* @__PURE__ */ function() {
  var le = /&#(\d+);/g;
  function Y(re, oe) {
    return String.fromCharCode(parseInt(oe, 10));
  }
  return function(oe) {
    return oe.replace(le, Y);
  };
}();
function xlml_unfixstr(le) {
  return le.replace(/(\r\n|[\r\n])/g, "&#10;");
}
function parsexmlbool(le) {
  switch (le) {
    case 1:
    case !0:
    case "1":
    case "true":
      return !0;
    case 0:
    case !1:
    case "0":
    case "false":
      return !1;
  }
  return !1;
}
function utf8reada(le) {
  for (var Y = "", re = 0, oe = 0, ue = 0, fe = 0, he = 0, _e = 0; re < le.length; ) {
    if (oe = le.charCodeAt(re++), oe < 128) {
      Y += String.fromCharCode(oe);
      continue;
    }
    if (ue = le.charCodeAt(re++), oe > 191 && oe < 224) {
      he = (oe & 31) << 6, he |= ue & 63, Y += String.fromCharCode(he);
      continue;
    }
    if (fe = le.charCodeAt(re++), oe < 240) {
      Y += String.fromCharCode((oe & 15) << 12 | (ue & 63) << 6 | fe & 63);
      continue;
    }
    he = le.charCodeAt(re++), _e = ((oe & 7) << 18 | (ue & 63) << 12 | (fe & 63) << 6 | he & 63) - 65536, Y += String.fromCharCode(55296 + (_e >>> 10 & 1023)), Y += String.fromCharCode(56320 + (_e & 1023));
  }
  return Y;
}
function utf8readb(le) {
  var Y = new_raw_buf(2 * le.length), re, oe, ue = 1, fe = 0, he = 0, _e;
  for (oe = 0; oe < le.length; oe += ue)
    ue = 1, (_e = le.charCodeAt(oe)) < 128 ? re = _e : _e < 224 ? (re = (_e & 31) * 64 + (le.charCodeAt(oe + 1) & 63), ue = 2) : _e < 240 ? (re = (_e & 15) * 4096 + (le.charCodeAt(oe + 1) & 63) * 64 + (le.charCodeAt(oe + 2) & 63), ue = 3) : (ue = 4, re = (_e & 7) * 262144 + (le.charCodeAt(oe + 1) & 63) * 4096 + (le.charCodeAt(oe + 2) & 63) * 64 + (le.charCodeAt(oe + 3) & 63), re -= 65536, he = 55296 + (re >>> 10 & 1023), re = 56320 + (re & 1023)), he !== 0 && (Y[fe++] = he & 255, Y[fe++] = he >>> 8, he = 0), Y[fe++] = re % 256, Y[fe++] = re >>> 8;
  return Y.slice(0, fe).toString("ucs2");
}
function utf8readc(le) {
  return Buffer_from(le, "binary").toString("utf8");
}
var utf8corpus = "foo bar bazâð£", utf8read = has_buf && (/* @__PURE__ */ utf8readc(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readc || /* @__PURE__ */ utf8readb(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readb) || utf8reada, utf8write = has_buf ? function(le) {
  return Buffer_from(le, "utf8").toString("binary");
} : function(le) {
  for (var Y = [], re = 0, oe = 0, ue = 0; re < le.length; )
    switch (oe = le.charCodeAt(re++), !0) {
      case oe < 128:
        Y.push(String.fromCharCode(oe));
        break;
      case oe < 2048:
        Y.push(String.fromCharCode(192 + (oe >> 6))), Y.push(String.fromCharCode(128 + (oe & 63)));
        break;
      case (oe >= 55296 && oe < 57344):
        oe -= 55296, ue = le.charCodeAt(re++) - 56320 + (oe << 10), Y.push(String.fromCharCode(240 + (ue >> 18 & 7))), Y.push(String.fromCharCode(144 + (ue >> 12 & 63))), Y.push(String.fromCharCode(128 + (ue >> 6 & 63))), Y.push(String.fromCharCode(128 + (ue & 63)));
        break;
      default:
        Y.push(String.fromCharCode(224 + (oe >> 12))), Y.push(String.fromCharCode(128 + (oe >> 6 & 63))), Y.push(String.fromCharCode(128 + (oe & 63)));
    }
  return Y.join("");
}, htmldecode = /* @__PURE__ */ function() {
  var le = [
    ["nbsp", " "],
    ["middot", "·"],
    ["quot", '"'],
    ["apos", "'"],
    ["gt", ">"],
    ["lt", "<"],
    ["amp", "&"]
  ].map(function(Y) {
    return [new RegExp("&" + Y[0] + ";", "ig"), Y[1]];
  });
  return function(re) {
    for (var oe = re.replace(/^[\t\n\r ]+/, "").replace(/(^|[^\t\n\r ])[\t\n\r ]+$/, "$1").replace(/>\s+/g, ">").replace(/\b\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, `
`).replace(/<[^<>]*>/g, ""), ue = 0; ue < le.length; ++ue) oe = oe.replace(le[ue][0], le[ue][1]);
    return oe;
  };
}(), vtvregex = /<\/?(?:vt:)?variant>/g, vtmregex = /<(?:vt:)([^<"'>]*)>([\s\S]*)</;
function parseVector(le, Y) {
  var re = parsexmltag(le), oe = str_match_xml_ns_g(le, re.baseType) || [], ue = [];
  if (oe.length != re.size) {
    if (Y.WTF) throw new Error("unexpected vector length " + oe.length + " != " + re.size);
    return ue;
  }
  return oe.forEach(function(fe) {
    var he = fe.replace(vtvregex, "").match(vtmregex);
    he && ue.push({ v: utf8read(he[2]), t: he[1] });
  }), ue;
}
var wtregex = /(^\s|\s$|\n)/;
function writetag(le, Y) {
  return "<" + le + (Y.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + Y + "</" + le + ">";
}
function wxt_helper(le) {
  return keys(le).map(function(Y) {
    return " " + Y + '="' + le[Y] + '"';
  }).join("");
}
function writextag(le, Y, re) {
  return "<" + le + (re != null ? wxt_helper(re) : "") + (Y != null ? (Y.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + Y + "</" + le : "/") + ">";
}
function write_w3cdtf(le, Y) {
  try {
    return le.toISOString().replace(/\.\d*/, "");
  } catch (re) {
    if (Y) throw re;
  }
  return "";
}
function write_vt(le, Y) {
  switch (typeof le) {
    case "string":
      var re = writextag("vt:lpwstr", escapexml(le));
      return re = re.replace(/&quot;/g, "_x0022_"), re;
    case "number":
      return writextag((le | 0) == le ? "vt:i4" : "vt:r8", escapexml(String(le)));
    case "boolean":
      return writextag("vt:bool", le ? "true" : "false");
  }
  if (le instanceof Date) return writextag("vt:filetime", write_w3cdtf(le));
  throw new Error("Unable to serialize " + le);
}
function xlml_normalize(le) {
  if (has_buf && /*::typeof Buffer !== "undefined" && d != null && d instanceof Buffer &&*/
  Buffer.isBuffer(le)) return le.toString("utf8");
  if (typeof le == "string") return le;
  if (typeof Uint8Array < "u" && le instanceof Uint8Array) return utf8read(a2s(ab2a(le)));
  throw new Error("Bad input format: expected Buffer or string");
}
var xlmlregex = /<([\/]?)([^\s?><!\/:"]*:|)([^\s?<>:\/"]+)(?:\s+[^<>=?"'\s]+="[^"]*?")*\s*[\/]?>/mg, XMLNS = {
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
  CT: "http://schemas.openxmlformats.org/package/2006/content-types",
  RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
  TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
  dc: "http://purl.org/dc/elements/1.1/",
  dcterms: "http://purl.org/dc/terms/",
  dcmitype: "http://purl.org/dc/dcmitype/",
  r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
  xsi: "http://www.w3.org/2001/XMLSchema-instance",
  xsd: "http://www.w3.org/2001/XMLSchema"
}, XMLNS_main = [
  "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "http://purl.oclc.org/ooxml/spreadsheetml/main",
  "http://schemas.microsoft.com/office/excel/2006/main",
  "http://schemas.microsoft.com/office/excel/2006/2"
], XLMLNS = {
  o: "urn:schemas-microsoft-com:office:office",
  x: "urn:schemas-microsoft-com:office:excel",
  ss: "urn:schemas-microsoft-com:office:spreadsheet",
  dt: "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
  mv: "http://macVmlSchemaUri",
  v: "urn:schemas-microsoft-com:vml",
  html: "http://www.w3.org/TR/REC-html40"
};
function read_double_le(le, Y) {
  for (var re = 1 - 2 * (le[Y + 7] >>> 7), oe = ((le[Y + 7] & 127) << 4) + (le[Y + 6] >>> 4 & 15), ue = le[Y + 6] & 15, fe = 5; fe >= 0; --fe) ue = ue * 256 + le[Y + fe];
  return oe == 2047 ? ue == 0 ? re * (1 / 0) : NaN : (oe == 0 ? oe = -1022 : (oe -= 1023, ue += Math.pow(2, 52)), re * Math.pow(2, oe - 52) * ue);
}
function write_double_le(le, Y, re) {
  var oe = (Y < 0 || 1 / Y == -1 / 0 ? 1 : 0) << 7, ue = 0, fe = 0, he = oe ? -Y : Y;
  isFinite(he) ? he == 0 ? ue = fe = 0 : (ue = Math.floor(Math.log(he) / Math.LN2), fe = he * Math.pow(2, 52 - ue), ue <= -1023 && (!isFinite(fe) || fe < Math.pow(2, 52)) ? ue = -1022 : (fe -= Math.pow(2, 52), ue += 1023)) : (ue = 2047, fe = isNaN(Y) ? 26985 : 0);
  for (var _e = 0; _e <= 5; ++_e, fe /= 256) le[re + _e] = fe & 255;
  le[re + 6] = (ue & 15) << 4 | fe & 15, le[re + 7] = ue >> 4 | oe;
}
var ___toBuffer = function(le) {
  for (var Y = [], re = 10240, oe = 0; oe < le[0].length; ++oe) if (le[0][oe]) for (var ue = 0, fe = le[0][oe].length; ue < fe; ue += re) Y.push.apply(Y, le[0][oe].slice(ue, ue + re));
  return Y;
}, __toBuffer = has_buf ? function(le) {
  return le[0].length > 0 && Buffer.isBuffer(le[0][0]) ? Buffer.concat(le[0].map(function(Y) {
    return Buffer.isBuffer(Y) ? Y : Buffer_from(Y);
  })) : ___toBuffer(le);
} : ___toBuffer, ___utf16le = function(le, Y, re) {
  for (var oe = [], ue = Y; ue < re; ue += 2) oe.push(String.fromCharCode(__readUInt16LE(le, ue)));
  return oe.join("").replace(chr0, "");
}, __utf16le = has_buf ? function(le, Y, re) {
  return !Buffer.isBuffer(le) || !buf_utf16le ? ___utf16le(le, Y, re) : le.toString("utf16le", Y, re).replace(chr0, "");
} : ___utf16le, ___hexlify = function(le, Y, re) {
  for (var oe = [], ue = Y; ue < Y + re; ++ue) oe.push(("0" + le[ue].toString(16)).slice(-2));
  return oe.join("");
}, __hexlify = has_buf ? function(le, Y, re) {
  return Buffer.isBuffer(le) ? le.toString("hex", Y, Y + re) : ___hexlify(le, Y, re);
} : ___hexlify, ___utf8 = function(le, Y, re) {
  for (var oe = [], ue = Y; ue < re; ue++) oe.push(String.fromCharCode(__readUInt8(le, ue)));
  return oe.join("");
}, __utf8 = has_buf ? function le(Y, re, oe) {
  return Buffer.isBuffer(Y) ? Y.toString("utf8", re, oe) : ___utf8(Y, re, oe);
} : ___utf8, ___lpstr = function(le, Y) {
  var re = __readUInt32LE(le, Y);
  return re > 0 ? __utf8(le, Y + 4, Y + 4 + re - 1) : "";
}, __lpstr = ___lpstr, ___cpstr = function(le, Y) {
  var re = __readUInt32LE(le, Y);
  return re > 0 ? __utf8(le, Y + 4, Y + 4 + re - 1) : "";
}, __cpstr = ___cpstr, ___lpwstr = function(le, Y) {
  var re = 2 * __readUInt32LE(le, Y);
  return re > 0 ? __utf8(le, Y + 4, Y + 4 + re - 1) : "";
}, __lpwstr = ___lpwstr, ___lpp4 = function le(Y, re) {
  var oe = __readUInt32LE(Y, re);
  return oe > 0 ? __utf16le(Y, re + 4, re + 4 + oe) : "";
}, __lpp4 = ___lpp4, ___8lpp4 = function(le, Y) {
  var re = __readUInt32LE(le, Y);
  return re > 0 ? __utf8(le, Y + 4, Y + 4 + re) : "";
}, __8lpp4 = ___8lpp4, ___double = function(le, Y) {
  return read_double_le(le, Y);
}, __double = ___double, is_buf = function le(Y) {
  return Array.isArray(Y) || typeof Uint8Array < "u" && Y instanceof Uint8Array;
};
has_buf && (__lpstr = function(Y, re) {
  if (!Buffer.isBuffer(Y)) return ___lpstr(Y, re);
  var oe = Y.readUInt32LE(re);
  return oe > 0 ? Y.toString("utf8", re + 4, re + 4 + oe - 1) : "";
}, __cpstr = function(Y, re) {
  if (!Buffer.isBuffer(Y)) return ___cpstr(Y, re);
  var oe = Y.readUInt32LE(re);
  return oe > 0 ? Y.toString("utf8", re + 4, re + 4 + oe - 1) : "";
}, __lpwstr = function(Y, re) {
  if (!Buffer.isBuffer(Y) || !buf_utf16le) return ___lpwstr(Y, re);
  var oe = 2 * Y.readUInt32LE(re);
  return Y.toString("utf16le", re + 4, re + 4 + oe - 1);
}, __lpp4 = function(Y, re) {
  if (!Buffer.isBuffer(Y) || !buf_utf16le) return ___lpp4(Y, re);
  var oe = Y.readUInt32LE(re);
  return Y.toString("utf16le", re + 4, re + 4 + oe);
}, __8lpp4 = function(Y, re) {
  if (!Buffer.isBuffer(Y)) return ___8lpp4(Y, re);
  var oe = Y.readUInt32LE(re);
  return Y.toString("utf8", re + 4, re + 4 + oe);
}, __double = function(Y, re) {
  return Buffer.isBuffer(Y) ? Y.readDoubleLE(re) : ___double(Y, re);
}, is_buf = function(Y) {
  return Buffer.isBuffer(Y) || Array.isArray(Y) || typeof Uint8Array < "u" && Y instanceof Uint8Array;
});
function cpdoit() {
  __utf16le = function(le, Y, re) {
    return $cptable.utils.decode(1200, le.slice(Y, re)).replace(chr0, "");
  }, __utf8 = function(le, Y, re) {
    return $cptable.utils.decode(65001, le.slice(Y, re));
  }, __lpstr = function(le, Y) {
    var re = __readUInt32LE(le, Y);
    return re > 0 ? $cptable.utils.decode(current_ansi, le.slice(Y + 4, Y + 4 + re - 1)) : "";
  }, __cpstr = function(le, Y) {
    var re = __readUInt32LE(le, Y);
    return re > 0 ? $cptable.utils.decode(current_codepage, le.slice(Y + 4, Y + 4 + re - 1)) : "";
  }, __lpwstr = function(le, Y) {
    var re = 2 * __readUInt32LE(le, Y);
    return re > 0 ? $cptable.utils.decode(1200, le.slice(Y + 4, Y + 4 + re - 1)) : "";
  }, __lpp4 = function(le, Y) {
    var re = __readUInt32LE(le, Y);
    return re > 0 ? $cptable.utils.decode(1200, le.slice(Y + 4, Y + 4 + re)) : "";
  }, __8lpp4 = function(le, Y) {
    var re = __readUInt32LE(le, Y);
    return re > 0 ? $cptable.utils.decode(65001, le.slice(Y + 4, Y + 4 + re)) : "";
  };
}
typeof $cptable < "u" && cpdoit();
var __readUInt8 = function(le, Y) {
  return le[Y];
}, __readUInt16LE = function(le, Y) {
  return le[Y + 1] * 256 + le[Y];
}, __readInt16LE = function(le, Y) {
  var re = le[Y + 1] * 256 + le[Y];
  return re < 32768 ? re : (65535 - re + 1) * -1;
}, __readUInt32LE = function(le, Y) {
  return le[Y + 3] * (1 << 24) + (le[Y + 2] << 16) + (le[Y + 1] << 8) + le[Y];
}, __readInt32LE = function(le, Y) {
  return le[Y + 3] << 24 | le[Y + 2] << 16 | le[Y + 1] << 8 | le[Y];
}, __readInt32BE = function(le, Y) {
  return le[Y] << 24 | le[Y + 1] << 16 | le[Y + 2] << 8 | le[Y + 3];
};
function ReadShift(le, Y) {
  var re = "", oe, ue, fe = [], he, _e, ve, xe;
  switch (Y) {
    case "dbcs":
      if (xe = this.l, has_buf && Buffer.isBuffer(this) && buf_utf16le) re = this.slice(this.l, this.l + 2 * le).toString("utf16le");
      else for (ve = 0; ve < le; ++ve)
        re += String.fromCharCode(__readUInt16LE(this, xe)), xe += 2;
      le *= 2;
      break;
    case "utf8":
      re = __utf8(this, this.l, this.l + le);
      break;
    case "utf16le":
      le *= 2, re = __utf16le(this, this.l, this.l + le);
      break;
    case "wstr":
      if (typeof $cptable < "u") re = $cptable.utils.decode(current_codepage, this.slice(this.l, this.l + 2 * le));
      else return ReadShift.call(this, le, "dbcs");
      le = 2 * le;
      break;
    /* [MS-OLEDS] 2.1.4 LengthPrefixedAnsiString */
    case "lpstr-ansi":
      re = __lpstr(this, this.l), le = 4 + __readUInt32LE(this, this.l);
      break;
    case "lpstr-cp":
      re = __cpstr(this, this.l), le = 4 + __readUInt32LE(this, this.l);
      break;
    /* [MS-OLEDS] 2.1.5 LengthPrefixedUnicodeString */
    case "lpwstr":
      re = __lpwstr(this, this.l), le = 4 + 2 * __readUInt32LE(this, this.l);
      break;
    /* [MS-OFFCRYPTO] 2.1.2 Length-Prefixed Padded Unicode String (UNICODE-LP-P4) */
    case "lpp4":
      le = 4 + __readUInt32LE(this, this.l), re = __lpp4(this, this.l), le & 2 && (le += 2);
      break;
    /* [MS-OFFCRYPTO] 2.1.3 Length-Prefixed UTF-8 String (UTF-8-LP-P4) */
    case "8lpp4":
      le = 4 + __readUInt32LE(this, this.l), re = __8lpp4(this, this.l), le & 3 && (le += 4 - (le & 3));
      break;
    case "cstr":
      for (le = 0, re = ""; (he = __readUInt8(this, this.l + le++)) !== 0; ) fe.push(_getchar(he));
      re = fe.join("");
      break;
    case "_wstr":
      for (le = 0, re = ""; (he = __readUInt16LE(this, this.l + le)) !== 0; )
        fe.push(_getchar(he)), le += 2;
      le += 2, re = fe.join("");
      break;
    /* sbcs and dbcs support continue records in the SST way TODO codepages */
    case "dbcs-cont":
      for (re = "", xe = this.l, ve = 0; ve < le; ++ve) {
        if (this.lens && this.lens.indexOf(xe) !== -1)
          return he = __readUInt8(this, xe), this.l = xe + 1, _e = ReadShift.call(this, le - ve, he ? "dbcs-cont" : "sbcs-cont"), fe.join("") + _e;
        fe.push(_getchar(__readUInt16LE(this, xe))), xe += 2;
      }
      re = fe.join(""), le *= 2;
      break;
    case "cpstr":
      if (typeof $cptable < "u") {
        re = $cptable.utils.decode(current_codepage, this.slice(this.l, this.l + le));
        break;
      }
    /* falls through */
    case "sbcs-cont":
      for (re = "", xe = this.l, ve = 0; ve != le; ++ve) {
        if (this.lens && this.lens.indexOf(xe) !== -1)
          return he = __readUInt8(this, xe), this.l = xe + 1, _e = ReadShift.call(this, le - ve, he ? "dbcs-cont" : "sbcs-cont"), fe.join("") + _e;
        fe.push(_getchar(__readUInt8(this, xe))), xe += 1;
      }
      re = fe.join("");
      break;
    default:
      switch (le) {
        case 1:
          return oe = __readUInt8(this, this.l), this.l++, oe;
        case 2:
          return oe = (Y === "i" ? __readInt16LE : __readUInt16LE)(this, this.l), this.l += 2, oe;
        case 4:
        case -4:
          return Y === "i" || (this[this.l + 3] & 128) === 0 ? (oe = (le > 0 ? __readInt32LE : __readInt32BE)(this, this.l), this.l += 4, oe) : (ue = __readUInt32LE(this, this.l), this.l += 4, ue);
        case 8:
        case -8:
          if (Y === "f")
            return le == 8 ? ue = __double(this, this.l) : ue = __double([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0), this.l += 8, ue;
          le = 8;
        /* falls through */
        case 16:
          re = __hexlify(this, this.l, le);
          break;
      }
  }
  return this.l += le, re;
}
var __writeUInt32LE = function(le, Y, re) {
  le[re] = Y & 255, le[re + 1] = Y >>> 8 & 255, le[re + 2] = Y >>> 16 & 255, le[re + 3] = Y >>> 24 & 255;
}, __writeInt32LE = function(le, Y, re) {
  le[re] = Y & 255, le[re + 1] = Y >> 8 & 255, le[re + 2] = Y >> 16 & 255, le[re + 3] = Y >> 24 & 255;
}, __writeUInt16LE = function(le, Y, re) {
  le[re] = Y & 255, le[re + 1] = Y >>> 8 & 255;
};
function WriteShift(le, Y, re) {
  var oe = 0, ue = 0;
  if (re === "dbcs") {
    for (ue = 0; ue != Y.length; ++ue) __writeUInt16LE(this, Y.charCodeAt(ue), this.l + 2 * ue);
    oe = 2 * Y.length;
  } else if (re === "sbcs" || re == "cpstr")
    if (typeof $cptable < "u" && current_ansi == 874) {
      for (ue = 0; ue != Y.length; ++ue) {
        var fe = $cptable.utils.encode(current_ansi, Y.charAt(ue));
        this[this.l + ue] = fe[0];
      }
      oe = Y.length;
    } else if (typeof $cptable < "u" && re == "cpstr") {
      if (fe = $cptable.utils.encode(current_codepage, Y), fe.length == Y.length) for (ue = 0; ue < Y.length; ++ue) fe[ue] == 0 && Y.charCodeAt(ue) != 0 && (fe[ue] = 95);
      if (fe.length == 2 * Y.length) for (ue = 0; ue < Y.length; ++ue) fe[2 * ue] == 0 && fe[2 * ue + 1] == 0 && Y.charCodeAt(ue) != 0 && (fe[2 * ue] = 95);
      for (ue = 0; ue < fe.length; ++ue) this[this.l + ue] = fe[ue];
      oe = fe.length;
    } else {
      for (Y = Y.replace(/[^\x00-\x7F]/g, "_"), ue = 0; ue != Y.length; ++ue) this[this.l + ue] = Y.charCodeAt(ue) & 255;
      oe = Y.length;
    }
  else if (re === "hex") {
    for (; ue < le; ++ue)
      this[this.l++] = parseInt(Y.slice(2 * ue, 2 * ue + 2), 16) || 0;
    return this;
  } else if (re === "utf16le") {
    var he = Math.min(this.l + le, this.length);
    for (ue = 0; ue < Math.min(Y.length, le); ++ue) {
      var _e = Y.charCodeAt(ue);
      this[this.l++] = _e & 255, this[this.l++] = _e >> 8;
    }
    for (; this.l < he; ) this[this.l++] = 0;
    return this;
  } else switch (le) {
    case 1:
      oe = 1, this[this.l] = Y & 255;
      break;
    case 2:
      oe = 2, this[this.l] = Y & 255, Y >>>= 8, this[this.l + 1] = Y & 255;
      break;
    case 3:
      oe = 3, this[this.l] = Y & 255, Y >>>= 8, this[this.l + 1] = Y & 255, Y >>>= 8, this[this.l + 2] = Y & 255;
      break;
    case 4:
      oe = 4, __writeUInt32LE(this, Y, this.l);
      break;
    case 8:
      if (oe = 8, re === "f") {
        write_double_le(this, Y, this.l);
        break;
      }
    /* falls through */
    case 16:
      break;
    case -4:
      oe = 4, __writeInt32LE(this, Y, this.l);
      break;
  }
  return this.l += oe, this;
}
function CheckField(le, Y) {
  var re = __hexlify(this, this.l, le.length >> 1);
  if (re !== le) throw new Error(Y + "Expected " + le + " saw " + re);
  this.l += le.length >> 1;
}
function prep_blob(le, Y) {
  le.l = Y, le.read_shift = /*::(*/
  ReadShift, le.chk = CheckField, le.write_shift = WriteShift;
}
function parsenoop(le, Y) {
  le.l += Y;
}
function new_buf(le) {
  var Y = new_raw_buf(le);
  return prep_blob(Y, 0), Y;
}
function recordhopper(le, Y, re) {
  if (le) {
    var oe, ue, fe;
    prep_blob(le, le.l || 0);
    for (var he = le.length, _e = 0, ve = 0; le.l < he; ) {
      _e = le.read_shift(1), _e & 128 && (_e = (_e & 127) + ((le.read_shift(1) & 127) << 7));
      var xe = XLSBRecordEnum[_e] || XLSBRecordEnum[65535];
      for (oe = le.read_shift(1), fe = oe & 127, ue = 1; ue < 4 && oe & 128; ++ue) fe += ((oe = le.read_shift(1)) & 127) << 7 * ue;
      ve = le.l + fe;
      var Ee = xe.f && xe.f(le, fe, re);
      if (le.l = ve, Y(Ee, xe, _e)) return;
    }
  }
}
function buf_array() {
  var le = [], Y = has_buf ? 16384 : 2048;
  has_buf && new_buf(Y).copy;
  var re = function(Ee) {
    var Se = new_buf(Ee);
    return prep_blob(Se, 0), Se;
  }, oe = re(Y), ue = function() {
    oe && (oe.l && (oe.length > oe.l && (oe = oe.slice(0, oe.l), oe.l = oe.length), oe.length > 0 && le.push(oe)), oe = null);
  }, fe = function(Ee) {
    return oe && Ee < oe.length - oe.l ? oe : (ue(), oe = re(Math.max(Ee + 1, Y)));
  }, he = function() {
    return ue(), bconcat(le);
  }, _e = function() {
    return ue(), le;
  }, ve = function(Ee) {
    ue(), oe = Ee, oe.l == null && (oe.l = oe.length), fe(Y);
  };
  return { next: fe, push: ve, end: he, _bufs: le, end2: _e };
}
function write_record(le, Y, re, oe) {
  var ue = +Y, fe;
  if (!isNaN(ue)) {
    oe || (oe = XLSBRecordEnum[ue].p || (re || []).length || 0), fe = 1 + (ue >= 128 ? 1 : 0) + 1, oe >= 128 && ++fe, oe >= 16384 && ++fe, oe >= 2097152 && ++fe;
    var he = le.next(fe);
    ue <= 127 ? he.write_shift(1, ue) : (he.write_shift(1, (ue & 127) + 128), he.write_shift(1, ue >> 7));
    for (var _e = 0; _e != 4; ++_e)
      if (oe >= 128)
        he.write_shift(1, (oe & 127) + 128), oe >>= 7;
      else {
        he.write_shift(1, oe);
        break;
      }
    /*:: length != null &&*/
    oe > 0 && is_buf(re) && le.push(re);
  }
}
function shift_cell_xls(le, Y, re) {
  var oe = dup(le);
  if (Y.s ? (oe.cRel && (oe.c += Y.s.c), oe.rRel && (oe.r += Y.s.r)) : (oe.cRel && (oe.c += Y.c), oe.rRel && (oe.r += Y.r)), !re || re.biff < 12) {
    for (; oe.c >= 256; ) oe.c -= 256;
    for (; oe.r >= 65536; ) oe.r -= 65536;
  }
  return oe;
}
function shift_range_xls(le, Y, re) {
  var oe = dup(le);
  return oe.s = shift_cell_xls(oe.s, Y.s, re), oe.e = shift_cell_xls(oe.e, Y.s, re), oe;
}
function encode_cell_xls(le, Y) {
  if (le.cRel && le.c < 0)
    for (le = dup(le); le.c < 0; ) le.c += Y > 8 ? 16384 : 256;
  if (le.rRel && le.r < 0)
    for (le = dup(le); le.r < 0; ) le.r += Y > 8 ? 1048576 : Y > 5 ? 65536 : 16384;
  var re = encode_cell(le);
  return !le.cRel && le.cRel != null && (re = fix_col(re)), !le.rRel && le.rRel != null && (re = fix_row(re)), re;
}
function encode_range_xls(le, Y) {
  return le.s.r == 0 && !le.s.rRel && le.e.r == (Y.biff >= 12 ? 1048575 : Y.biff >= 8 ? 65536 : 16384) && !le.e.rRel ? (le.s.cRel ? "" : "$") + encode_col(le.s.c) + ":" + (le.e.cRel ? "" : "$") + encode_col(le.e.c) : le.s.c == 0 && !le.s.cRel && le.e.c == (Y.biff >= 12 ? 16383 : 255) && !le.e.cRel ? (le.s.rRel ? "" : "$") + encode_row(le.s.r) + ":" + (le.e.rRel ? "" : "$") + encode_row(le.e.r) : encode_cell_xls(le.s, Y.biff) + ":" + encode_cell_xls(le.e, Y.biff);
}
function decode_row(le) {
  return parseInt(unfix_row(le), 10) - 1;
}
function encode_row(le) {
  return "" + (le + 1);
}
function fix_row(le) {
  return le.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
}
function unfix_row(le) {
  return le.replace(/\$(\d+)$/, "$1");
}
function decode_col(le) {
  for (var Y = unfix_col(le), re = 0, oe = 0; oe !== Y.length; ++oe) re = 26 * re + Y.charCodeAt(oe) - 64;
  return re - 1;
}
function encode_col(le) {
  if (le < 0) throw new Error("invalid column " + le);
  var Y = "";
  for (++le; le; le = Math.floor((le - 1) / 26)) Y = String.fromCharCode((le - 1) % 26 + 65) + Y;
  return Y;
}
function fix_col(le) {
  return le.replace(/^([A-Z])/, "$$$1");
}
function unfix_col(le) {
  return le.replace(/^\$([A-Z])/, "$1");
}
function split_cell(le) {
  return le.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
}
function decode_cell(le) {
  for (var Y = 0, re = 0, oe = 0; oe < le.length; ++oe) {
    var ue = le.charCodeAt(oe);
    ue >= 48 && ue <= 57 ? Y = 10 * Y + (ue - 48) : ue >= 65 && ue <= 90 && (re = 26 * re + (ue - 64));
  }
  return { c: re - 1, r: Y - 1 };
}
function encode_cell(le) {
  for (var Y = le.c + 1, re = ""; Y; Y = (Y - 1) / 26 | 0) re = String.fromCharCode((Y - 1) % 26 + 65) + re;
  return re + (le.r + 1);
}
function decode_range(le) {
  var Y = le.indexOf(":");
  return Y == -1 ? { s: decode_cell(le), e: decode_cell(le) } : { s: decode_cell(le.slice(0, Y)), e: decode_cell(le.slice(Y + 1)) };
}
function encode_range(le, Y) {
  return typeof Y > "u" || typeof Y == "number" ? encode_range(le.s, le.e) : (typeof le != "string" && (le = encode_cell(le)), typeof Y != "string" && (Y = encode_cell(Y)), le == Y ? le : le + ":" + Y);
}
function fix_range(le) {
  var Y = decode_range(le);
  return "$" + encode_col(Y.s.c) + "$" + encode_row(Y.s.r) + ":$" + encode_col(Y.e.c) + "$" + encode_row(Y.e.r);
}
function formula_quote_sheet_name(le, Y) {
  if (!le && !(Y && Y.biff <= 5 && Y.biff >= 2)) throw new Error("empty sheet name");
  return /[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(le) ? "'" + le.replace(/'/g, "''") + "'" : le;
}
function safe_decode_range(le) {
  var Y = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } }, re = 0, oe = 0, ue = 0, fe = le.length;
  for (re = 0; oe < fe && !((ue = le.charCodeAt(oe) - 64) < 1 || ue > 26); ++oe)
    re = 26 * re + ue;
  for (Y.s.c = --re, re = 0; oe < fe && !((ue = le.charCodeAt(oe) - 48) < 0 || ue > 9); ++oe)
    re = 10 * re + ue;
  if (Y.s.r = --re, oe === fe || ue != 10)
    return Y.e.c = Y.s.c, Y.e.r = Y.s.r, Y;
  for (++oe, re = 0; oe != fe && !((ue = le.charCodeAt(oe) - 64) < 1 || ue > 26); ++oe)
    re = 26 * re + ue;
  for (Y.e.c = --re, re = 0; oe != fe && !((ue = le.charCodeAt(oe) - 48) < 0 || ue > 9); ++oe)
    re = 10 * re + ue;
  return Y.e.r = --re, Y;
}
function safe_format_cell(le, Y) {
  var re = le.t == "d" && Y instanceof Date;
  if (le.z != null) try {
    return le.w = SSF_format(le.z, re ? datenum(Y) : Y);
  } catch {
  }
  try {
    return le.w = SSF_format((le.XF || {}).numFmtId || (re ? 14 : 0), re ? datenum(Y) : Y);
  } catch {
    return "" + Y;
  }
}
function format_cell(le, Y, re) {
  return le == null || le.t == null || le.t == "z" ? "" : le.w !== void 0 ? le.w : (le.t == "d" && !le.z && re && re.dateNF && (le.z = re.dateNF), le.t == "e" ? BErr[le.v] || le.v : Y == null ? safe_format_cell(le, le.v) : safe_format_cell(le, Y));
}
function sheet_to_workbook(le, Y) {
  var re = Y && Y.sheet ? Y.sheet : "Sheet1", oe = {};
  return oe[re] = le, { SheetNames: [re], Sheets: oe };
}
function sheet_new(le) {
  var Y = {}, re = le || {};
  return re.dense && (Y["!data"] = []), Y;
}
function sheet_add_aoa(le, Y, re) {
  var oe = re || {}, ue = le ? le["!data"] != null : oe.dense, fe = le || (ue ? { "!data": [] } : {});
  ue && !fe["!data"] && (fe["!data"] = []);
  var he = 0, _e = 0;
  if (fe && oe.origin != null)
    if (typeof oe.origin == "number") he = oe.origin;
    else {
      var ve = typeof oe.origin == "string" ? decode_cell(oe.origin) : oe.origin;
      he = ve.r, _e = ve.c;
    }
  var xe = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
  if (fe["!ref"]) {
    var Ee = safe_decode_range(fe["!ref"]);
    xe.s.c = Ee.s.c, xe.s.r = Ee.s.r, xe.e.c = Math.max(xe.e.c, Ee.e.c), xe.e.r = Math.max(xe.e.r, Ee.e.r), he == -1 && (xe.e.r = he = fe["!ref"] ? Ee.e.r + 1 : 0);
  } else
    xe.s.c = xe.e.c = xe.s.r = xe.e.r = 0;
  for (var Se = [], Te = !1, Ce = 0; Ce != Y.length; ++Ce)
    if (Y[Ce]) {
      if (!Array.isArray(Y[Ce])) throw new Error("aoa_to_sheet expects an array of arrays");
      var Ie = he + Ce;
      ue && (fe["!data"][Ie] || (fe["!data"][Ie] = []), Se = fe["!data"][Ie]);
      for (var Ne = Y[Ce], Re = 0; Re != Ne.length; ++Re)
        if (!(typeof Ne[Re] > "u")) {
          var Ae = { v: Ne[Re], t: "" }, Pe = _e + Re;
          if (xe.s.r > Ie && (xe.s.r = Ie), xe.s.c > Pe && (xe.s.c = Pe), xe.e.r < Ie && (xe.e.r = Ie), xe.e.c < Pe && (xe.e.c = Pe), Te = !0, Ne[Re] && typeof Ne[Re] == "object" && !Array.isArray(Ne[Re]) && !(Ne[Re] instanceof Date)) Ae = Ne[Re];
          else if (Array.isArray(Ae.v) && (Ae.f = Ne[Re][1], Ae.v = Ae.v[0]), Ae.v === null)
            if (Ae.f) Ae.t = "n";
            else if (oe.nullError)
              Ae.t = "e", Ae.v = 0;
            else if (oe.sheetStubs) Ae.t = "z";
            else continue;
          else typeof Ae.v == "number" ? isFinite(Ae.v) ? Ae.t = "n" : isNaN(Ae.v) ? (Ae.t = "e", Ae.v = 15) : (Ae.t = "e", Ae.v = 7) : typeof Ae.v == "boolean" ? Ae.t = "b" : Ae.v instanceof Date ? (Ae.z = oe.dateNF || table_fmt[14], oe.UTC || (Ae.v = local_to_utc(Ae.v)), oe.cellDates ? (Ae.t = "d", Ae.w = SSF_format(Ae.z, datenum(Ae.v, oe.date1904))) : (Ae.t = "n", Ae.v = datenum(Ae.v, oe.date1904), Ae.w = SSF_format(Ae.z, Ae.v))) : Ae.t = "s";
          if (ue)
            Se[Pe] && Se[Pe].z && (Ae.z = Se[Pe].z), Se[Pe] = Ae;
          else {
            var Fe = encode_col(Pe) + (Ie + 1);
            fe[Fe] && fe[Fe].z && (Ae.z = fe[Fe].z), fe[Fe] = Ae;
          }
        }
    }
  return Te && xe.s.c < 104e5 && (fe["!ref"] = encode_range(xe)), fe;
}
function aoa_to_sheet(le, Y) {
  return sheet_add_aoa(null, le, Y);
}
function parse_Int32LE(le) {
  return le.read_shift(4, "i");
}
function write_UInt32LE(le, Y) {
  return Y || (Y = new_buf(4)), Y.write_shift(4, le), Y;
}
function parse_XLWideString(le) {
  var Y = le.read_shift(4);
  return Y === 0 ? "" : le.read_shift(Y, "dbcs");
}
function write_XLWideString(le, Y) {
  var re = !1;
  return Y == null && (re = !0, Y = new_buf(4 + 2 * le.length)), Y.write_shift(4, le.length), le.length > 0 && Y.write_shift(0, le, "dbcs"), re ? Y.slice(0, Y.l) : Y;
}
function parse_StrRun(le) {
  return { ich: le.read_shift(2), ifnt: le.read_shift(2) };
}
function write_StrRun(le, Y) {
  return Y || (Y = new_buf(4)), Y.write_shift(2, 0), Y.write_shift(2, 0), Y;
}
function parse_RichStr(le, Y) {
  var re = le.l, oe = le.read_shift(1), ue = parse_XLWideString(le), fe = [], he = { t: ue, h: ue };
  if ((oe & 1) !== 0) {
    for (var _e = le.read_shift(4), ve = 0; ve != _e; ++ve) fe.push(parse_StrRun(le));
    he.r = fe;
  } else he.r = [{ ich: 0, ifnt: 0 }];
  return le.l = re + Y, he;
}
function write_RichStr(le, Y) {
  var re = !1;
  return Y == null && (re = !0, Y = new_buf(15 + 4 * le.t.length)), Y.write_shift(1, 0), write_XLWideString(le.t, Y), re ? Y.slice(0, Y.l) : Y;
}
var parse_BrtCommentText = parse_RichStr;
function write_BrtCommentText(le, Y) {
  var re = !1;
  return Y == null && (re = !0, Y = new_buf(23 + 4 * le.t.length)), Y.write_shift(1, 1), write_XLWideString(le.t, Y), Y.write_shift(4, 1), write_StrRun({}, Y), re ? Y.slice(0, Y.l) : Y;
}
function parse_XLSBCell(le) {
  var Y = le.read_shift(4), re = le.read_shift(2);
  return re += le.read_shift(1) << 16, le.l++, { c: Y, iStyleRef: re };
}
function write_XLSBCell(le, Y) {
  return Y == null && (Y = new_buf(8)), Y.write_shift(-4, le.c), Y.write_shift(3, le.iStyleRef || le.s), Y.write_shift(1, 0), Y;
}
function parse_XLSBShortCell(le) {
  var Y = le.read_shift(2);
  return Y += le.read_shift(1) << 16, le.l++, { c: -1, iStyleRef: Y };
}
function write_XLSBShortCell(le, Y) {
  return Y == null && (Y = new_buf(4)), Y.write_shift(3, le.iStyleRef || le.s), Y.write_shift(1, 0), Y;
}
var parse_XLSBCodeName = parse_XLWideString, write_XLSBCodeName = write_XLWideString;
function parse_XLNullableWideString(le) {
  var Y = le.read_shift(4);
  return Y === 0 || Y === 4294967295 ? "" : le.read_shift(Y, "dbcs");
}
function write_XLNullableWideString(le, Y) {
  var re = !1;
  return Y == null && (re = !0, Y = new_buf(127)), Y.write_shift(4, le.length > 0 ? le.length : 4294967295), le.length > 0 && Y.write_shift(0, le, "dbcs"), re ? Y.slice(0, Y.l) : Y;
}
var parse_XLNameWideString = parse_XLWideString, parse_RelID = parse_XLNullableWideString, write_RelID = write_XLNullableWideString;
function parse_RkNumber(le) {
  var Y = le.slice(le.l, le.l + 4), re = Y[0] & 1, oe = Y[0] & 2;
  le.l += 4;
  var ue = oe === 0 ? __double([0, 0, 0, 0, Y[0] & 252, Y[1], Y[2], Y[3]], 0) : __readInt32LE(Y, 0) >> 2;
  return re ? ue / 100 : ue;
}
function write_RkNumber(le, Y) {
  Y == null && (Y = new_buf(4));
  var re = 0, oe = 0, ue = le * 100;
  if (le == (le | 0) && le >= -536870912 && le < 1 << 29 ? oe = 1 : ue == (ue | 0) && ue >= -536870912 && ue < 1 << 29 && (oe = 1, re = 1), oe) Y.write_shift(-4, ((re ? ue : le) << 2) + (re + 2));
  else throw new Error("unsupported RkNumber " + le);
}
function parse_RfX(le) {
  var Y = { s: {}, e: {} };
  return Y.s.r = le.read_shift(4), Y.e.r = le.read_shift(4), Y.s.c = le.read_shift(4), Y.e.c = le.read_shift(4), Y;
}
function write_RfX(le, Y) {
  return Y || (Y = new_buf(16)), Y.write_shift(4, le.s.r), Y.write_shift(4, le.e.r), Y.write_shift(4, le.s.c), Y.write_shift(4, le.e.c), Y;
}
var parse_UncheckedRfX = parse_RfX, write_UncheckedRfX = write_RfX;
function parse_Xnum(le) {
  if (le.length - le.l < 8) throw "XLS Xnum Buffer underflow";
  return le.read_shift(8, "f");
}
function write_Xnum(le, Y) {
  return (Y || new_buf(8)).write_shift(8, le, "f");
}
function parse_BrtColor(le) {
  var Y = {}, re = le.read_shift(1), oe = re >>> 1, ue = le.read_shift(1), fe = le.read_shift(2, "i"), he = le.read_shift(1), _e = le.read_shift(1), ve = le.read_shift(1);
  switch (le.l++, oe) {
    case 0:
      Y.auto = 1;
      break;
    case 1:
      Y.index = ue;
      var xe = XLSIcv[ue];
      xe && (Y.rgb = rgb2Hex(xe));
      break;
    case 2:
      Y.rgb = rgb2Hex([he, _e, ve]);
      break;
    case 3:
      Y.theme = ue;
      break;
  }
  return fe != 0 && (Y.tint = fe > 0 ? fe / 32767 : fe / 32768), Y;
}
function write_BrtColor(le, Y) {
  if (Y || (Y = new_buf(8)), !le || le.auto)
    return Y.write_shift(4, 0), Y.write_shift(4, 0), Y;
  le.index != null ? (Y.write_shift(1, 2), Y.write_shift(1, le.index)) : le.theme != null ? (Y.write_shift(1, 6), Y.write_shift(1, le.theme)) : (Y.write_shift(1, 5), Y.write_shift(1, 0));
  var re = le.tint || 0;
  if (re > 0 ? re *= 32767 : re < 0 && (re *= 32768), Y.write_shift(2, re), !le.rgb || le.theme != null)
    Y.write_shift(2, 0), Y.write_shift(1, 0), Y.write_shift(1, 0);
  else {
    var oe = le.rgb || "FFFFFF";
    typeof oe == "number" && (oe = ("000000" + oe.toString(16)).slice(-6)), Y.write_shift(1, parseInt(oe.slice(0, 2), 16)), Y.write_shift(1, parseInt(oe.slice(2, 4), 16)), Y.write_shift(1, parseInt(oe.slice(4, 6), 16)), Y.write_shift(1, 255);
  }
  return Y;
}
function parse_FontFlags(le) {
  var Y = le.read_shift(1);
  le.l++;
  var re = {
    fBold: Y & 1,
    fItalic: Y & 2,
    fUnderline: Y & 4,
    fStrikeout: Y & 8,
    fOutline: Y & 16,
    fShadow: Y & 32,
    fCondense: Y & 64,
    fExtend: Y & 128
  };
  return re;
}
function write_FontFlags(le, Y) {
  Y || (Y = new_buf(2));
  var re = (le.italic ? 2 : 0) | (le.strike ? 8 : 0) | (le.outline ? 16 : 0) | (le.shadow ? 32 : 0) | (le.condense ? 64 : 0) | (le.extend ? 128 : 0);
  return Y.write_shift(1, re), Y.write_shift(1, 0), Y;
}
function parse_ClipboardFormatOrString(le, Y) {
  var re = { 2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE" }, oe = le.read_shift(4);
  switch (oe) {
    case 0:
      return "";
    case 4294967295:
    case 4294967294:
      return re[le.read_shift(4)] || "";
  }
  if (oe > 400) throw new Error("Unsupported Clipboard: " + oe.toString(16));
  return le.l -= 4, le.read_shift(0, Y == 1 ? "lpstr" : "lpwstr");
}
function parse_ClipboardFormatOrAnsiString(le) {
  return parse_ClipboardFormatOrString(le, 1);
}
function parse_ClipboardFormatOrUnicodeString(le) {
  return parse_ClipboardFormatOrString(le, 2);
}
var VT_I2 = 2, VT_I4 = 3, VT_BOOL = 11, VT_VARIANT = 12, VT_UI4 = 19, VT_FILETIME = 64, VT_BLOB = 65, VT_CF = 71, VT_VECTOR_VARIANT = 4108, VT_VECTOR_LPSTR = 4126, VT_STRING = 80, VT_USTR = 81, VT_CUSTOM = [VT_STRING, VT_USTR], DocSummaryPIDDSI = {
  1: { n: "CodePage", t: VT_I2 },
  2: { n: "Category", t: VT_STRING },
  3: { n: "PresentationFormat", t: VT_STRING },
  4: { n: "ByteCount", t: VT_I4 },
  5: { n: "LineCount", t: VT_I4 },
  6: { n: "ParagraphCount", t: VT_I4 },
  7: { n: "SlideCount", t: VT_I4 },
  8: { n: "NoteCount", t: VT_I4 },
  9: { n: "HiddenCount", t: VT_I4 },
  10: { n: "MultimediaClipCount", t: VT_I4 },
  11: { n: "ScaleCrop", t: VT_BOOL },
  12: {
    n: "HeadingPairs",
    t: VT_VECTOR_VARIANT
    /* VT_VECTOR | VT_VARIANT */
  },
  13: {
    n: "TitlesOfParts",
    t: VT_VECTOR_LPSTR
    /* VT_VECTOR | VT_LPSTR */
  },
  14: { n: "Manager", t: VT_STRING },
  15: { n: "Company", t: VT_STRING },
  16: { n: "LinksUpToDate", t: VT_BOOL },
  17: { n: "CharacterCount", t: VT_I4 },
  19: { n: "SharedDoc", t: VT_BOOL },
  22: { n: "HyperlinksChanged", t: VT_BOOL },
  23: { n: "AppVersion", t: VT_I4, p: "version" },
  24: { n: "DigSig", t: VT_BLOB },
  26: { n: "ContentType", t: VT_STRING },
  27: { n: "ContentStatus", t: VT_STRING },
  28: { n: "Language", t: VT_STRING },
  29: { n: "Version", t: VT_STRING },
  255: {},
  /* [MS-OLEPS] 2.18 */
  2147483648: { n: "Locale", t: VT_UI4 },
  2147483651: { n: "Behavior", t: VT_UI4 },
  1919054434: {}
}, SummaryPIDSI = {
  1: { n: "CodePage", t: VT_I2 },
  2: { n: "Title", t: VT_STRING },
  3: { n: "Subject", t: VT_STRING },
  4: { n: "Author", t: VT_STRING },
  5: { n: "Keywords", t: VT_STRING },
  6: { n: "Comments", t: VT_STRING },
  7: { n: "Template", t: VT_STRING },
  8: { n: "LastAuthor", t: VT_STRING },
  9: { n: "RevNumber", t: VT_STRING },
  10: { n: "EditTime", t: VT_FILETIME },
  11: { n: "LastPrinted", t: VT_FILETIME },
  12: { n: "CreatedDate", t: VT_FILETIME },
  13: { n: "ModifiedDate", t: VT_FILETIME },
  14: { n: "PageCount", t: VT_I4 },
  15: { n: "WordCount", t: VT_I4 },
  16: { n: "CharCount", t: VT_I4 },
  17: { n: "Thumbnail", t: VT_CF },
  18: { n: "Application", t: VT_STRING },
  19: { n: "DocSecurity", t: VT_I4 },
  255: {},
  /* [MS-OLEPS] 2.18 */
  2147483648: { n: "Locale", t: VT_UI4 },
  2147483651: { n: "Behavior", t: VT_UI4 },
  1919054434: {}
}, CountryEnum = {
  1: "US",
  // United States
  2: "CA",
  // Canada
  3: "",
  // Latin America (except Brazil)
  7: "RU",
  // Russia
  20: "EG",
  // Egypt
  30: "GR",
  // Greece
  31: "NL",
  // Netherlands
  32: "BE",
  // Belgium
  33: "FR",
  // France
  34: "ES",
  // Spain
  36: "HU",
  // Hungary
  39: "IT",
  // Italy
  41: "CH",
  // Switzerland
  43: "AT",
  // Austria
  44: "GB",
  // United Kingdom
  45: "DK",
  // Denmark
  46: "SE",
  // Sweden
  47: "NO",
  // Norway
  48: "PL",
  // Poland
  49: "DE",
  // Germany
  52: "MX",
  // Mexico
  55: "BR",
  // Brazil
  61: "AU",
  // Australia
  64: "NZ",
  // New Zealand
  66: "TH",
  // Thailand
  81: "JP",
  // Japan
  82: "KR",
  // Korea
  84: "VN",
  // Viet Nam
  86: "CN",
  // China
  90: "TR",
  // Turkey
  105: "JS",
  // Ramastan
  213: "DZ",
  // Algeria
  216: "MA",
  // Morocco
  218: "LY",
  // Libya
  351: "PT",
  // Portugal
  354: "IS",
  // Iceland
  358: "FI",
  // Finland
  420: "CZ",
  // Czech Republic
  886: "TW",
  // Taiwan
  961: "LB",
  // Lebanon
  962: "JO",
  // Jordan
  963: "SY",
  // Syria
  964: "IQ",
  // Iraq
  965: "KW",
  // Kuwait
  966: "SA",
  // Saudi Arabia
  971: "AE",
  // United Arab Emirates
  972: "IL",
  // Israel
  974: "QA",
  // Qatar
  981: "IR",
  // Iran
  65535: "US"
  // United States
}, XLSFillPattern = [
  null,
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
];
function rgbify(le) {
  return le.map(function(Y) {
    return [Y >> 16 & 255, Y >> 8 & 255, Y & 255];
  });
}
var _XLSIcv = /* @__PURE__ */ rgbify([
  /* Color Constants */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  /* Overridable Defaults */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  8388608,
  32768,
  128,
  8421376,
  8388736,
  32896,
  12632256,
  8421504,
  10066431,
  10040166,
  16777164,
  13434879,
  6684774,
  16744576,
  26316,
  13421823,
  128,
  16711935,
  16776960,
  65535,
  8388736,
  8388608,
  32896,
  255,
  52479,
  13434879,
  13434828,
  16777113,
  10079487,
  16751052,
  13408767,
  16764057,
  3368703,
  3394764,
  10079232,
  16763904,
  16750848,
  16737792,
  6710937,
  9868950,
  13158,
  3381606,
  13056,
  3355392,
  10040064,
  10040166,
  3355545,
  3355443,
  /* Other entries to appease BIFF8/12 */
  0,
  /* 0x40 icvForeground ?? */
  16777215,
  /* 0x41 icvBackground ?? */
  0,
  /* 0x42 icvFrame ?? */
  0,
  /* 0x43 icv3D ?? */
  0,
  /* 0x44 icv3DText ?? */
  0,
  /* 0x45 icv3DHilite ?? */
  0,
  /* 0x46 icv3DShadow ?? */
  0,
  /* 0x47 icvHilite ?? */
  0,
  /* 0x48 icvCtlText ?? */
  0,
  /* 0x49 icvCtlScrl ?? */
  0,
  /* 0x4A icvCtlInv ?? */
  0,
  /* 0x4B icvCtlBody ?? */
  0,
  /* 0x4C icvCtlFrame ?? */
  0,
  /* 0x4D icvCtlFore ?? */
  0,
  /* 0x4E icvCtlBack ?? */
  0,
  /* 0x4F icvCtlNeutral */
  0,
  /* 0x50 icvInfoBk ?? */
  0
  /* 0x51 icvInfoText ?? */
]), XLSIcv = /* @__PURE__ */ dup(_XLSIcv), BErr = {
  0: "#NULL!",
  7: "#DIV/0!",
  15: "#VALUE!",
  23: "#REF!",
  29: "#NAME?",
  36: "#NUM!",
  42: "#N/A",
  43: "#GETTING_DATA",
  255: "#WTF?"
}, RBErr = {
  "#NULL!": 0,
  "#DIV/0!": 7,
  "#VALUE!": 15,
  "#REF!": 23,
  "#NAME?": 29,
  "#NUM!": 36,
  "#N/A": 42,
  "#GETTING_DATA": 43,
  "#WTF?": 255
}, XLSLblBuiltIn = [
  "_xlnm.Consolidate_Area",
  "_xlnm.Auto_Open",
  "_xlnm.Auto_Close",
  "_xlnm.Extract",
  "_xlnm.Database",
  "_xlnm.Criteria",
  "_xlnm.Print_Area",
  "_xlnm.Print_Titles",
  "_xlnm.Recorder",
  "_xlnm.Data_Form",
  "_xlnm.Auto_Activate",
  "_xlnm.Auto_Deactivate",
  "_xlnm.Sheet_Title",
  "_xlnm._FilterDatabase"
], ct2type = {
  /* Workbook */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
  "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
  /* Worksheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
  "application/vnd.ms-excel.worksheet": "sheets",
  "application/vnd.ms-excel.binIndexWs": "TODO",
  /* Binary Index */
  /* Chartsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
  "application/vnd.ms-excel.chartsheet": "charts",
  /* Macrosheet */
  "application/vnd.ms-excel.macrosheet+xml": "macros",
  "application/vnd.ms-excel.macrosheet": "macros",
  "application/vnd.ms-excel.intlmacrosheet": "TODO",
  "application/vnd.ms-excel.binIndexMs": "TODO",
  /* Binary Index */
  /* Dialogsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
  "application/vnd.ms-excel.dialogsheet": "dialogs",
  /* Shared Strings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
  "application/vnd.ms-excel.sharedStrings": "strs",
  /* Styles */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
  "application/vnd.ms-excel.styles": "styles",
  /* File Properties */
  "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
  /* Custom Data Properties */
  "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
  /* Comments */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
  "application/vnd.ms-excel.comments": "comments",
  "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
  "application/vnd.ms-excel.person+xml": "people",
  /* Metadata (Stock/Geography and Dynamic Array) */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
  "application/vnd.ms-excel.sheetMetadata": "metadata",
  /* PivotTable */
  "application/vnd.ms-excel.pivotTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
  /* Chart Objects */
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
  /* Chart Colors */
  "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
  /* Chart Style */
  "application/vnd.ms-office.chartstyle+xml": "TODO",
  /* Chart Advanced */
  "application/vnd.ms-office.chartex+xml": "TODO",
  /* Calculation Chain */
  "application/vnd.ms-excel.calcChain": "calcchains",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
  /* Printer Settings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
  /* ActiveX */
  "application/vnd.ms-office.activeX": "TODO",
  "application/vnd.ms-office.activeX+xml": "TODO",
  /* Custom Toolbars */
  "application/vnd.ms-excel.attachedToolbars": "TODO",
  /* External Data Connections */
  "application/vnd.ms-excel.connections": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
  /* External Links */
  "application/vnd.ms-excel.externalLink": "links",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
  /* PivotCache */
  "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
  "application/vnd.ms-excel.pivotCacheRecords": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
  /* Query Table */
  "application/vnd.ms-excel.queryTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
  /* Shared Workbook */
  "application/vnd.ms-excel.userNames": "TODO",
  "application/vnd.ms-excel.revisionHeaders": "TODO",
  "application/vnd.ms-excel.revisionLog": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
  /* Single Cell Table */
  "application/vnd.ms-excel.tableSingleCells": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
  /* Slicer */
  "application/vnd.ms-excel.slicer": "TODO",
  "application/vnd.ms-excel.slicerCache": "TODO",
  "application/vnd.ms-excel.slicer+xml": "TODO",
  "application/vnd.ms-excel.slicerCache+xml": "TODO",
  /* Sort Map */
  "application/vnd.ms-excel.wsSortMap": "TODO",
  /* Table */
  "application/vnd.ms-excel.table": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
  /* Themes */
  "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
  /* Theme Override */
  "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
  /* Timeline */
  "application/vnd.ms-excel.Timeline+xml": "TODO",
  /* verify */
  "application/vnd.ms-excel.TimelineCache+xml": "TODO",
  /* verify */
  /* VBA */
  "application/vnd.ms-office.vbaProject": "vba",
  "application/vnd.ms-office.vbaProjectSignature": "TODO",
  /* Volatile Dependencies */
  "application/vnd.ms-office.volatileDependencies": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
  /* Control Properties */
  "application/vnd.ms-excel.controlproperties+xml": "TODO",
  /* Data Model */
  "application/vnd.openxmlformats-officedocument.model+data": "TODO",
  /* Survey */
  "application/vnd.ms-excel.Survey+xml": "TODO",
  /* Drawing */
  "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
  /* VML */
  "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
  "application/vnd.openxmlformats-package.relationships+xml": "rels",
  "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
  /* Image */
  "image/png": "TODO",
  sheet: "js"
}, CT_LIST = {
  workbooks: {
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
    xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
    xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
    xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
    xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
  },
  strs: {
    /* Shared Strings */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
    xlsb: "application/vnd.ms-excel.sharedStrings"
  },
  comments: {
    /* Comments */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
    xlsb: "application/vnd.ms-excel.comments"
  },
  sheets: {
    /* Worksheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
    xlsb: "application/vnd.ms-excel.worksheet"
  },
  charts: {
    /* Chartsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
    xlsb: "application/vnd.ms-excel.chartsheet"
  },
  dialogs: {
    /* Dialogsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
    xlsb: "application/vnd.ms-excel.dialogsheet"
  },
  macros: {
    /* Macrosheet (Excel 4.0 Macros) */
    xlsx: "application/vnd.ms-excel.macrosheet+xml",
    xlsb: "application/vnd.ms-excel.macrosheet"
  },
  metadata: {
    /* Metadata (Stock/Geography and Dynamic Array) */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
    xlsb: "application/vnd.ms-excel.sheetMetadata"
  },
  styles: {
    /* Styles */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
    xlsb: "application/vnd.ms-excel.styles"
  }
};
function new_ct() {
  return {
    workbooks: [],
    sheets: [],
    charts: [],
    dialogs: [],
    macros: [],
    rels: [],
    strs: [],
    comments: [],
    threadedcomments: [],
    links: [],
    coreprops: [],
    extprops: [],
    custprops: [],
    themes: [],
    styles: [],
    calcchains: [],
    vba: [],
    drawings: [],
    metadata: [],
    people: [],
    TODO: [],
    xmlns: ""
  };
}
function parse_ct(le) {
  var Y = new_ct();
  if (!le || !le.match) return Y;
  var re = {};
  if ((le.match(tagregex) || []).forEach(function(oe) {
    var ue = parsexmltag(oe);
    switch (ue[0].replace(nsregex, "<")) {
      case "<?xml":
        break;
      case "<Types":
        Y.xmlns = ue["xmlns" + (ue[0].match(/<(\w+):/) || ["", ""])[1]];
        break;
      case "<Default":
        re[ue.Extension.toLowerCase()] = ue.ContentType;
        break;
      case "<Override":
        Y[ct2type[ue.ContentType]] !== void 0 && Y[ct2type[ue.ContentType]].push(ue.PartName);
        break;
    }
  }), Y.xmlns !== XMLNS.CT) throw new Error("Unknown Namespace: " + Y.xmlns);
  return Y.calcchain = Y.calcchains.length > 0 ? Y.calcchains[0] : "", Y.sst = Y.strs.length > 0 ? Y.strs[0] : "", Y.style = Y.styles.length > 0 ? Y.styles[0] : "", Y.defaults = re, delete Y.calcchains, Y;
}
function write_ct(le, Y, re) {
  var oe = evert_arr(ct2type), ue = [], fe;
  ue[ue.length] = XML_HEADER, ue[ue.length] = writextag("Types", null, {
    xmlns: XMLNS.CT,
    "xmlns:xsd": XMLNS.xsd,
    "xmlns:xsi": XMLNS.xsi
  }), ue = ue.concat([
    ["xml", "application/xml"],
    ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"],
    ["vml", "application/vnd.openxmlformats-officedocument.vmlDrawing"],
    ["data", "application/vnd.openxmlformats-officedocument.model+data"],
    /* from test files */
    ["bmp", "image/bmp"],
    ["png", "image/png"],
    ["gif", "image/gif"],
    ["emf", "image/x-emf"],
    ["wmf", "image/x-wmf"],
    ["jpg", "image/jpeg"],
    ["jpeg", "image/jpeg"],
    ["tif", "image/tiff"],
    ["tiff", "image/tiff"],
    ["pdf", "application/pdf"],
    ["rels", "application/vnd.openxmlformats-package.relationships+xml"]
  ].map(function(xe) {
    return writextag("Default", null, { Extension: xe[0], ContentType: xe[1] });
  }));
  var he = function(xe) {
    le[xe] && le[xe].length > 0 && (fe = le[xe][0], ue[ue.length] = writextag("Override", null, {
      PartName: (fe[0] == "/" ? "" : "/") + fe,
      ContentType: CT_LIST[xe][Y.bookType] || CT_LIST[xe].xlsx
    }));
  }, _e = function(xe) {
    (le[xe] || []).forEach(function(Ee) {
      ue[ue.length] = writextag("Override", null, {
        PartName: (Ee[0] == "/" ? "" : "/") + Ee,
        ContentType: CT_LIST[xe][Y.bookType] || CT_LIST[xe].xlsx
      });
    });
  }, ve = function(xe) {
    (le[xe] || []).forEach(function(Ee) {
      ue[ue.length] = writextag("Override", null, {
        PartName: (Ee[0] == "/" ? "" : "/") + Ee,
        ContentType: oe[xe][0]
      });
    });
  };
  return he("workbooks"), _e("sheets"), _e("charts"), ve("themes"), ["strs", "styles"].forEach(he), ["coreprops", "extprops", "custprops"].forEach(ve), ve("vba"), ve("comments"), ve("threadedcomments"), ve("drawings"), _e("metadata"), ve("people"), ue.length > 2 && (ue[ue.length] = "</Types>", ue[1] = ue[1].replace("/>", ">")), ue.join("");
}
var RELS = {
  WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
  XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
  XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
  CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
  CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
  CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
  SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
  CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
  CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
  WS: [
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
  ],
  DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
  MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
  IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
  XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
  TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
  PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
  CONN: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/connections",
  VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
};
function get_rels_path(le) {
  var Y = le.lastIndexOf("/");
  return le.slice(0, Y + 1) + "_rels/" + le.slice(Y + 1) + ".rels";
}
function parse_rels(le, Y) {
  var re = { "!id": {} };
  if (!le) return re;
  Y.charAt(0) !== "/" && (Y = "/" + Y);
  var oe = {};
  return (le.match(tagregex) || []).forEach(function(ue) {
    var fe = parsexmltag(ue);
    if (fe[0] === "<Relationship") {
      var he = {};
      he.Type = fe.Type, he.Target = unescapexml(fe.Target), he.Id = fe.Id, fe.TargetMode && (he.TargetMode = fe.TargetMode);
      var _e = fe.TargetMode === "External" ? fe.Target : resolve_path(fe.Target, Y);
      re[_e] = he, oe[fe.Id] = he;
    }
  }), re["!id"] = oe, re;
}
function write_rels(le) {
  var Y = [XML_HEADER, writextag("Relationships", null, {
    //'xmlns:ns0': XMLNS.RELS,
    xmlns: XMLNS.RELS
  })];
  return keys(le["!id"]).forEach(function(re) {
    Y[Y.length] = writextag("Relationship", null, le["!id"][re]);
  }), Y.length > 2 && (Y[Y.length] = "</Relationships>", Y[1] = Y[1].replace("/>", ">")), Y.join("");
}
function add_rels(le, Y, re, oe, ue, fe) {
  if (ue || (ue = {}), le["!id"] || (le["!id"] = {}), le["!idx"] || (le["!idx"] = 1), Y < 0) for (Y = le["!idx"]; le["!id"]["rId" + Y]; ++Y)
    ;
  if (le["!idx"] = Y + 1, ue.Id = "rId" + Y, ue.Type = oe, ue.Target = re, [RELS.HLINK, RELS.XPATH, RELS.XMISS].indexOf(ue.Type) > -1 && (ue.TargetMode = "External"), le["!id"][ue.Id]) throw new Error("Cannot rewrite rId " + Y);
  return le["!id"][ue.Id] = ue, le[("/" + ue.Target).replace("//", "/")] = ue, Y;
}
var CT_ODS = "application/vnd.oasis.opendocument.spreadsheet";
function parse_manifest(le, Y) {
  for (var re = xlml_normalize(le), oe, ue; oe = xlmlregex.exec(re); )
    switch (oe[3]) {
      case "manifest":
        break;
      case "file-entry":
        if (ue = parsexmltag(oe[0], !1), ue.path == "/" && ue.type !== CT_ODS)
          throw new Error("This OpenDocument is not a spreadsheet");
        break;
      case "encryption-data":
      case "algorithm":
      case "start-key-generation":
      case "key-derivation":
        throw new Error("Unsupported ODS Encryption");
      default:
        if (Y && Y.WTF)
          throw oe;
    }
}
function write_manifest(le) {
  var Y = [XML_HEADER];
  Y.push(`<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">
`), Y.push(`  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>
`);
  for (var re = 0; re < le.length; ++re)
    Y.push('  <manifest:file-entry manifest:full-path="' + le[re][0] + '" manifest:media-type="' + le[re][1] + `"/>
`);
  return Y.push("</manifest:manifest>"), Y.join("");
}
function write_rdf_type(le, Y, re) {
  return [
    '  <rdf:Description rdf:about="' + le + `">
`,
    '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (re || "odf") + "#" + Y + `"/>
`,
    `  </rdf:Description>
`
  ].join("");
}
function write_rdf_has(le, Y) {
  return [
    '  <rdf:Description rdf:about="' + le + `">
`,
    '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + Y + `"/>
`,
    `  </rdf:Description>
`
  ].join("");
}
function write_rdf(le) {
  var Y = [XML_HEADER];
  Y.push(`<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
`);
  for (var re = 0; re != le.length; ++re)
    Y.push(write_rdf_type(le[re][0], le[re][1])), Y.push(write_rdf_has("", le[re][0]));
  return Y.push(write_rdf_type("", "Document", "pkg")), Y.push("</rdf:RDF>"), Y.join("");
}
function write_meta_ods(le, Y) {
  return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>SheetJS ' + XLSX.version + "</meta:generator></office:meta></office:document-meta>";
}
var CORE_PROPS = [
  ["cp:category", "Category"],
  ["cp:contentStatus", "ContentStatus"],
  ["cp:keywords", "Keywords"],
  ["cp:lastModifiedBy", "LastAuthor"],
  ["cp:lastPrinted", "LastPrinted"],
  ["cp:revision", "RevNumber"],
  ["cp:version", "Version"],
  ["dc:creator", "Author"],
  ["dc:description", "Comments"],
  ["dc:identifier", "Identifier"],
  ["dc:language", "Language"],
  ["dc:subject", "Subject"],
  ["dc:title", "Title"],
  ["dcterms:created", "CreatedDate", "date"],
  ["dcterms:modified", "ModifiedDate", "date"]
];
function parse_core_props(le) {
  var Y = {};
  le = utf8read(le);
  for (var re = 0; re < CORE_PROPS.length; ++re) {
    var oe = CORE_PROPS[re], ue = str_match_xml(le, oe[0]);
    ue != null && ue.length > 0 && (Y[oe[1]] = unescapexml(ue[1])), oe[2] === "date" && Y[oe[1]] && (Y[oe[1]] = parseDate(Y[oe[1]]));
  }
  return Y;
}
function cp_doit(le, Y, re, oe, ue) {
  ue[le] != null || Y == null || Y === "" || (ue[le] = Y, Y = escapexml(Y), oe[oe.length] = re ? writextag(le, Y, re) : writetag(le, Y));
}
function write_core_props(le, Y) {
  var re = Y || {}, oe = [XML_HEADER, writextag("cp:coreProperties", null, {
    //'xmlns': XMLNS.CORE_PROPS,
    "xmlns:cp": XMLNS.CORE_PROPS,
    "xmlns:dc": XMLNS.dc,
    "xmlns:dcterms": XMLNS.dcterms,
    "xmlns:dcmitype": XMLNS.dcmitype,
    "xmlns:xsi": XMLNS.xsi
  })], ue = {};
  if (!le && !re.Props) return oe.join("");
  le && (le.CreatedDate != null && cp_doit("dcterms:created", typeof le.CreatedDate == "string" ? le.CreatedDate : write_w3cdtf(le.CreatedDate, re.WTF), { "xsi:type": "dcterms:W3CDTF" }, oe, ue), le.ModifiedDate != null && cp_doit("dcterms:modified", typeof le.ModifiedDate == "string" ? le.ModifiedDate : write_w3cdtf(le.ModifiedDate, re.WTF), { "xsi:type": "dcterms:W3CDTF" }, oe, ue));
  for (var fe = 0; fe != CORE_PROPS.length; ++fe) {
    var he = CORE_PROPS[fe], _e = re.Props && re.Props[he[1]] != null ? re.Props[he[1]] : le ? le[he[1]] : null;
    _e === !0 ? _e = "1" : _e === !1 ? _e = "0" : typeof _e == "number" && (_e = String(_e)), _e != null && cp_doit(he[0], _e, null, oe, ue);
  }
  return oe.length > 2 && (oe[oe.length] = "</cp:coreProperties>", oe[1] = oe[1].replace("/>", ">")), oe.join("");
}
var EXT_PROPS = [
  ["Application", "Application", "string"],
  ["AppVersion", "AppVersion", "string"],
  ["Company", "Company", "string"],
  ["DocSecurity", "DocSecurity", "string"],
  ["Manager", "Manager", "string"],
  ["HyperlinksChanged", "HyperlinksChanged", "bool"],
  ["SharedDoc", "SharedDoc", "bool"],
  ["LinksUpToDate", "LinksUpToDate", "bool"],
  ["ScaleCrop", "ScaleCrop", "bool"],
  ["HeadingPairs", "HeadingPairs", "raw"],
  ["TitlesOfParts", "TitlesOfParts", "raw"]
], PseudoPropsPairs = [
  "Worksheets",
  "SheetNames",
  "NamedRanges",
  "DefinedNames",
  "Chartsheets",
  "ChartNames"
];
function load_props_pairs(le, Y, re, oe) {
  var ue = [];
  if (typeof le == "string") ue = parseVector(le, oe);
  else for (var fe = 0; fe < le.length; ++fe) ue = ue.concat(le[fe].map(function(Ee) {
    return { v: Ee };
  }));
  var he = typeof Y == "string" ? parseVector(Y, oe).map(function(Ee) {
    return Ee.v;
  }) : Y, _e = 0, ve = 0;
  if (he.length > 0) for (var xe = 0; xe !== ue.length; xe += 2) {
    switch (ve = +ue[xe + 1].v, ue[xe].v) {
      case "Worksheets":
      case "工作表":
      case "Листы":
      case "أوراق العمل":
      case "ワークシート":
      case "גליונות עבודה":
      case "Arbeitsblätter":
      case "Çalışma Sayfaları":
      case "Feuilles de calcul":
      case "Fogli di lavoro":
      case "Folhas de cálculo":
      case "Planilhas":
      case "Regneark":
      case "Hojas de cálculo":
      case "Werkbladen":
        re.Worksheets = ve, re.SheetNames = he.slice(_e, _e + ve);
        break;
      case "Named Ranges":
      case "Rangos con nombre":
      case "名前付き一覧":
      case "Benannte Bereiche":
      case "Navngivne områder":
        re.NamedRanges = ve, re.DefinedNames = he.slice(_e, _e + ve);
        break;
      case "Charts":
      case "Diagramme":
        re.Chartsheets = ve, re.ChartNames = he.slice(_e, _e + ve);
        break;
    }
    _e += ve;
  }
}
function parse_ext_props(le, Y, re) {
  var oe = {};
  return Y || (Y = {}), le = utf8read(le), EXT_PROPS.forEach(function(ue) {
    var fe = (str_match_xml_ns(le, ue[0]) || [])[1];
    switch (ue[2]) {
      case "string":
        fe && (Y[ue[1]] = unescapexml(fe));
        break;
      case "bool":
        Y[ue[1]] = fe === "true";
        break;
      case "raw":
        var he = str_match_xml(le, ue[0]);
        he && he.length > 0 && (oe[ue[1]] = he[1]);
        break;
    }
  }), oe.HeadingPairs && oe.TitlesOfParts && load_props_pairs(oe.HeadingPairs, oe.TitlesOfParts, Y, re), Y;
}
function write_ext_props(le) {
  var Y = [], re = writextag;
  return le || (le = {}), le.Application = "SheetJS", Y[Y.length] = XML_HEADER, Y[Y.length] = writextag("Properties", null, {
    xmlns: XMLNS.EXT_PROPS,
    "xmlns:vt": XMLNS.vt
  }), EXT_PROPS.forEach(function(oe) {
    if (le[oe[1]] !== void 0) {
      var ue;
      switch (oe[2]) {
        case "string":
          ue = escapexml(String(le[oe[1]]));
          break;
        case "bool":
          ue = le[oe[1]] ? "true" : "false";
          break;
      }
      ue !== void 0 && (Y[Y.length] = re(oe[0], ue));
    }
  }), Y[Y.length] = re("HeadingPairs", re("vt:vector", re("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + re("vt:variant", re("vt:i4", String(le.Worksheets))), { size: 2, baseType: "variant" })), Y[Y.length] = re("TitlesOfParts", re("vt:vector", le.SheetNames.map(function(oe) {
    return "<vt:lpstr>" + escapexml(oe) + "</vt:lpstr>";
  }).join(""), { size: le.Worksheets, baseType: "lpstr" })), Y.length > 2 && (Y[Y.length] = "</Properties>", Y[1] = Y[1].replace("/>", ">")), Y.join("");
}
var custregex = /<[^<>]+>[^<]*/g;
function parse_cust_props(le, Y) {
  var re = {}, oe = "", ue = le.match(custregex);
  if (ue) for (var fe = 0; fe != ue.length; ++fe) {
    var he = ue[fe], _e = parsexmltag(he);
    switch (strip_ns(_e[0])) {
      case "<?xml":
        break;
      case "<Properties":
        break;
      case "<property":
        oe = unescapexml(_e.name);
        break;
      case "</property>":
        oe = null;
        break;
      default:
        if (he.indexOf("<vt:") === 0) {
          var ve = he.split(">"), xe = ve[0].slice(4), Ee = ve[1];
          switch (xe) {
            case "lpstr":
            case "bstr":
            case "lpwstr":
              re[oe] = unescapexml(Ee);
              break;
            case "bool":
              re[oe] = parsexmlbool(Ee);
              break;
            case "i1":
            case "i2":
            case "i4":
            case "i8":
            case "int":
            case "uint":
              re[oe] = parseInt(Ee, 10);
              break;
            case "r4":
            case "r8":
            case "decimal":
              re[oe] = parseFloat(Ee);
              break;
            case "filetime":
            case "date":
              re[oe] = parseDate(Ee);
              break;
            case "cy":
            case "error":
              re[oe] = unescapexml(Ee);
              break;
            default:
              if (xe.slice(-1) == "/") break;
              Y.WTF && typeof console < "u" && console.warn("Unexpected", he, xe, ve);
          }
        } else if (he.slice(0, 2) !== "</") {
          if (Y.WTF) throw new Error(he);
        }
    }
  }
  return re;
}
function write_cust_props(le) {
  var Y = [XML_HEADER, writextag("Properties", null, {
    xmlns: XMLNS.CUST_PROPS,
    "xmlns:vt": XMLNS.vt
  })];
  if (!le) return Y.join("");
  var re = 1;
  return keys(le).forEach(function(ue) {
    ++re, Y[Y.length] = writextag("property", write_vt(le[ue]), {
      fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
      pid: re,
      name: escapexml(ue)
    });
  }), Y.length > 2 && (Y[Y.length] = "</Properties>", Y[1] = Y[1].replace("/>", ">")), Y.join("");
}
var XLMLDocPropsMap = {
  Title: "Title",
  Subject: "Subject",
  Author: "Author",
  Keywords: "Keywords",
  Comments: "Description",
  LastAuthor: "LastAuthor",
  RevNumber: "Revision",
  Application: "AppName",
  /* TotalTime: 'TotalTime', */
  LastPrinted: "LastPrinted",
  CreatedDate: "Created",
  ModifiedDate: "LastSaved",
  /* Pages */
  /* Words */
  /* Characters */
  Category: "Category",
  /* PresentationFormat */
  Manager: "Manager",
  Company: "Company",
  /* Guid */
  /* HyperlinkBase */
  /* Bytes */
  /* Lines */
  /* Paragraphs */
  /* CharactersWithSpaces */
  AppVersion: "Version",
  ContentStatus: "ContentStatus",
  /* NOTE: missing from schema */
  Identifier: "Identifier",
  /* NOTE: missing from schema */
  Language: "Language"
  /* NOTE: missing from schema */
}, evert_XLMLDPM;
function xlml_set_prop(le, Y, re) {
  evert_XLMLDPM || (evert_XLMLDPM = evert(XLMLDocPropsMap)), Y = evert_XLMLDPM[Y] || Y, le[Y] = re;
}
function xlml_write_docprops(le, Y) {
  var re = [];
  return keys(XLMLDocPropsMap).map(function(oe) {
    for (var ue = 0; ue < CORE_PROPS.length; ++ue) if (CORE_PROPS[ue][1] == oe) return CORE_PROPS[ue];
    for (ue = 0; ue < EXT_PROPS.length; ++ue) if (EXT_PROPS[ue][1] == oe) return EXT_PROPS[ue];
    throw oe;
  }).forEach(function(oe) {
    if (le[oe[1]] != null) {
      var ue = Y && Y.Props && Y.Props[oe[1]] != null ? Y.Props[oe[1]] : le[oe[1]];
      switch (oe[2]) {
        case "date":
          ue = new Date(ue).toISOString().replace(/\.\d*Z/, "Z");
          break;
      }
      typeof ue == "number" ? ue = String(ue) : ue === !0 || ue === !1 ? ue = ue ? "1" : "0" : ue instanceof Date && (ue = new Date(ue).toISOString().replace(/\.\d*Z/, "")), re.push(writetag(XLMLDocPropsMap[oe[1]] || oe[1], ue));
    }
  }), writextag("DocumentProperties", re.join(""), { xmlns: XLMLNS.o });
}
function xlml_write_custprops(le, Y) {
  var re = ["Worksheets", "SheetNames"], oe = "CustomDocumentProperties", ue = [];
  return le && keys(le).forEach(function(fe) {
    if (Object.prototype.hasOwnProperty.call(le, fe)) {
      for (var he = 0; he < CORE_PROPS.length; ++he) if (fe == CORE_PROPS[he][1]) return;
      for (he = 0; he < EXT_PROPS.length; ++he) if (fe == EXT_PROPS[he][1]) return;
      for (he = 0; he < re.length; ++he) if (fe == re[he]) return;
      var _e = le[fe], ve = "string";
      typeof _e == "number" ? (ve = "float", _e = String(_e)) : _e === !0 || _e === !1 ? (ve = "boolean", _e = _e ? "1" : "0") : _e = String(_e), ue.push(writextag(escapexmltag(fe), _e, { "dt:dt": ve }));
    }
  }), Y && keys(Y).forEach(function(fe) {
    if (Object.prototype.hasOwnProperty.call(Y, fe) && !(le && Object.prototype.hasOwnProperty.call(le, fe))) {
      var he = Y[fe], _e = "string";
      typeof he == "number" ? (_e = "float", he = String(he)) : he === !0 || he === !1 ? (_e = "boolean", he = he ? "1" : "0") : he instanceof Date ? (_e = "dateTime.tz", he = he.toISOString()) : he = String(he), ue.push(writextag(escapexmltag(fe), he, { "dt:dt": _e }));
    }
  }), "<" + oe + ' xmlns="' + XLMLNS.o + '">' + ue.join("") + "</" + oe + ">";
}
function parse_FILETIME(le) {
  var Y = le.read_shift(4), re = le.read_shift(4);
  return new Date((re / 1e7 * Math.pow(2, 32) + Y / 1e7 - 11644473600) * 1e3).toISOString().replace(/\.000/, "");
}
function write_FILETIME(le) {
  var Y = typeof le == "string" ? new Date(Date.parse(le)) : le, re = Y.getTime() / 1e3 + 11644473600, oe = re % Math.pow(2, 32), ue = (re - oe) / Math.pow(2, 32);
  oe *= 1e7, ue *= 1e7;
  var fe = oe / Math.pow(2, 32) | 0;
  fe > 0 && (oe = oe % Math.pow(2, 32), ue += fe);
  var he = new_buf(8);
  return he.write_shift(4, oe), he.write_shift(4, ue), he;
}
function parse_lpstr(le, Y, re) {
  var oe = le.l, ue = le.read_shift(0, "lpstr-cp");
  if (re) for (; le.l - oe & 3; ) ++le.l;
  return ue;
}
function parse_lpwstr(le, Y, re) {
  var oe = le.read_shift(0, "lpwstr");
  return oe;
}
function parse_VtStringBase(le, Y, re) {
  return Y === 31 ? parse_lpwstr(le) : parse_lpstr(le, Y, re);
}
function parse_VtString(le, Y, re) {
  return parse_VtStringBase(le, Y, re === !1 ? 0 : 4);
}
function parse_VtUnalignedString(le, Y) {
  if (!Y) throw new Error("VtUnalignedString must have positive length");
  return parse_VtStringBase(le, Y, 0);
}
function parse_VtVecLpwstrValue(le) {
  for (var Y = le.read_shift(4), re = [], oe = 0; oe != Y; ++oe) {
    var ue = le.l;
    re[oe] = le.read_shift(0, "lpwstr").replace(chr0, ""), le.l - ue & 2 && (le.l += 2);
  }
  return re;
}
function parse_VtVecUnalignedLpstrValue(le) {
  for (var Y = le.read_shift(4), re = [], oe = 0; oe != Y; ++oe) re[oe] = le.read_shift(0, "lpstr-cp").replace(chr0, "");
  return re;
}
function parse_VtHeadingPair(le) {
  var Y = le.l, re = parse_TypedPropertyValue(le, VT_USTR);
  le[le.l] == 0 && le[le.l + 1] == 0 && le.l - Y & 2 && (le.l += 2);
  var oe = parse_TypedPropertyValue(le, VT_I4);
  return [re, oe];
}
function parse_VtVecHeadingPairValue(le) {
  for (var Y = le.read_shift(4), re = [], oe = 0; oe < Y / 2; ++oe) re.push(parse_VtHeadingPair(le));
  return re;
}
function parse_dictionary(le, Y) {
  for (var re = le.read_shift(4), oe = {}, ue = 0; ue != re; ++ue) {
    var fe = le.read_shift(4), he = le.read_shift(4);
    oe[fe] = le.read_shift(he, Y === 1200 ? "utf16le" : "utf8").replace(chr0, "").replace(chr1, "!"), Y === 1200 && he % 2 && (le.l += 2);
  }
  return le.l & 3 && (le.l = le.l >> 3 << 2), oe;
}
function parse_BLOB(le) {
  var Y = le.read_shift(4), re = le.slice(le.l, le.l + Y);
  return le.l += Y, (Y & 3) > 0 && (le.l += 4 - (Y & 3) & 3), re;
}
function parse_ClipboardData(le) {
  var Y = {};
  return Y.Size = le.read_shift(4), le.l += Y.Size + 3 - (Y.Size - 1) % 4, Y;
}
function parse_TypedPropertyValue(le, Y, re) {
  var oe = le.read_shift(2), ue, fe = re || {};
  if (le.l += 2, Y !== VT_VARIANT && oe !== Y && VT_CUSTOM.indexOf(Y) === -1 && !((Y & 65534) == 4126 && (oe & 65534) == 4126))
    throw new Error("Expected type " + Y + " saw " + oe);
  switch (Y === VT_VARIANT ? oe : Y) {
    case 2:
      return ue = le.read_shift(2, "i"), fe.raw || (le.l += 2), ue;
    case 3:
      return ue = le.read_shift(4, "i"), ue;
    case 11:
      return le.read_shift(4) !== 0;
    case 19:
      return ue = le.read_shift(4), ue;
    case 30:
      le.l += 4, val = parse_VtString(le, le[le.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
      break;
    case 31:
      le.l += 4, val = parse_VtString(le, le[le.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
      break;
    case 64:
      return parse_FILETIME(le);
    case 65:
      return parse_BLOB(le);
    case 71:
      return parse_ClipboardData(le);
    case 80:
      return parse_VtString(le, oe, !fe.raw).replace(chr0, "");
    case 81:
      return parse_VtUnalignedString(
        le,
        oe
        /*, 4*/
      ).replace(chr0, "");
    case 4108:
      return parse_VtVecHeadingPairValue(le);
    case 4126:
    case 4127:
      return oe == 4127 ? parse_VtVecLpwstrValue(le) : parse_VtVecUnalignedLpstrValue(le);
    default:
      throw new Error("TypedPropertyValue unrecognized type " + Y + " " + oe);
  }
}
function write_TypedPropertyValue(le, Y) {
  var re = new_buf(4), oe = new_buf(4);
  switch (re.write_shift(4, le == 80 ? 31 : le), le) {
    case 3:
      oe.write_shift(-4, Y);
      break;
    case 5:
      oe = new_buf(8), oe.write_shift(8, Y, "f");
      break;
    case 11:
      oe.write_shift(4, Y ? 1 : 0);
      break;
    case 64:
      oe = write_FILETIME(Y);
      break;
    case 31:
    case 80:
      for (oe = new_buf(4 + 2 * (Y.length + 1) + (Y.length % 2 ? 0 : 2)), oe.write_shift(4, Y.length + 1), oe.write_shift(0, Y, "dbcs"); oe.l != oe.length; ) oe.write_shift(1, 0);
      break;
    default:
      throw new Error("TypedPropertyValue unrecognized type " + le + " " + Y);
  }
  return bconcat([re, oe]);
}
function parse_PropertySet(le, Y) {
  var re = le.l, oe = le.read_shift(4), ue = le.read_shift(4), fe = [], he = 0, _e = 0, ve = -1, xe = {};
  for (he = 0; he != ue; ++he) {
    var Ee = le.read_shift(4), Se = le.read_shift(4);
    fe[he] = [Ee, Se + re];
  }
  fe.sort(function(Pe, Fe) {
    return Pe[1] - Fe[1];
  });
  var Te = {};
  for (he = 0; he != ue; ++he) {
    if (le.l !== fe[he][1]) {
      var Ce = !0;
      if (he > 0 && Y) switch (Y[fe[he - 1][0]].t) {
        case 2:
          le.l + 2 === fe[he][1] && (le.l += 2, Ce = !1);
          break;
        case 80:
          le.l <= fe[he][1] && (le.l = fe[he][1], Ce = !1);
          break;
        case 4108:
          le.l <= fe[he][1] && (le.l = fe[he][1], Ce = !1);
          break;
      }
      if ((!Y || he == 0) && le.l <= fe[he][1] && (Ce = !1, le.l = fe[he][1]), Ce) throw new Error("Read Error: Expected address " + fe[he][1] + " at " + le.l + " :" + he);
    }
    if (Y) {
      if (fe[he][0] == 0 && fe.length > he + 1 && fe[he][1] == fe[he + 1][1]) continue;
      var Ie = Y[fe[he][0]];
      if (Te[Ie.n] = parse_TypedPropertyValue(le, Ie.t, { raw: !0 }), Ie.p === "version" && (Te[Ie.n] = String(Te[Ie.n] >> 16) + "." + ("0000" + String(Te[Ie.n] & 65535)).slice(-4)), Ie.n == "CodePage") switch (Te[Ie.n]) {
        case 0:
          Te[Ie.n] = 1252;
        /* falls through */
        case 874:
        case 932:
        case 936:
        case 949:
        case 950:
        case 1250:
        case 1251:
        case 1253:
        case 1254:
        case 1255:
        case 1256:
        case 1257:
        case 1258:
        case 1e4:
        case 1200:
        case 1201:
        case 1252:
        case 65e3:
        case -536:
        case 65001:
        case -535:
          set_cp(_e = Te[Ie.n] >>> 0 & 65535);
          break;
        default:
          throw new Error("Unsupported CodePage: " + Te[Ie.n]);
      }
    } else if (fe[he][0] === 1) {
      if (_e = Te.CodePage = parse_TypedPropertyValue(le, VT_I2), set_cp(_e), ve !== -1) {
        var Ne = le.l;
        le.l = fe[ve][1], xe = parse_dictionary(le, _e), le.l = Ne;
      }
    } else if (fe[he][0] === 0) {
      if (_e === 0) {
        ve = he, le.l = fe[he + 1][1];
        continue;
      }
      xe = parse_dictionary(le, _e);
    } else {
      var Re = xe[fe[he][0]], Ae;
      switch (le[le.l]) {
        case 65:
          le.l += 4, Ae = parse_BLOB(le);
          break;
        case 30:
          le.l += 4, Ae = parse_VtString(le, le[le.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
          break;
        case 31:
          le.l += 4, Ae = parse_VtString(le, le[le.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
          break;
        case 3:
          le.l += 4, Ae = le.read_shift(4, "i");
          break;
        case 19:
          le.l += 4, Ae = le.read_shift(4);
          break;
        case 5:
          le.l += 4, Ae = le.read_shift(8, "f");
          break;
        case 11:
          le.l += 4, Ae = parsebool(le, 4);
          break;
        case 64:
          le.l += 4, Ae = parseDate(parse_FILETIME(le));
          break;
        default:
          throw new Error("unparsed value: " + le[le.l]);
      }
      Te[Re] = Ae;
    }
  }
  return le.l = re + oe, Te;
}
var XLSPSSkip = ["CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID"];
function guess_property_type(le) {
  switch (typeof le) {
    case "boolean":
      return 11;
    case "number":
      return (le | 0) == le ? 3 : 5;
    case "string":
      return 31;
    case "object":
      if (le instanceof Date) return 64;
      break;
  }
  return -1;
}
function write_PropertySet(le, Y, re) {
  var oe = new_buf(8), ue = [], fe = [], he = 8, _e = 0, ve = new_buf(8), xe = new_buf(8);
  if (ve.write_shift(4, 2), ve.write_shift(4, 1200), xe.write_shift(4, 1), fe.push(ve), ue.push(xe), he += 8 + ve.length, !Y) {
    xe = new_buf(8), xe.write_shift(4, 0), ue.unshift(xe);
    var Ee = [new_buf(4)];
    for (Ee[0].write_shift(4, le.length), _e = 0; _e < le.length; ++_e) {
      var Se = le[_e][0];
      for (ve = new_buf(8 + 2 * (Se.length + 1) + (Se.length % 2 ? 0 : 2)), ve.write_shift(4, _e + 2), ve.write_shift(4, Se.length + 1), ve.write_shift(0, Se, "dbcs"); ve.l != ve.length; ) ve.write_shift(1, 0);
      Ee.push(ve);
    }
    ve = bconcat(Ee), fe.unshift(ve), he += 8 + ve.length;
  }
  for (_e = 0; _e < le.length; ++_e)
    if (!(Y && !Y[le[_e][0]]) && !(XLSPSSkip.indexOf(le[_e][0]) > -1 || PseudoPropsPairs.indexOf(le[_e][0]) > -1) && le[_e][1] != null) {
      var Te = le[_e][1], Ce = 0;
      if (Y) {
        Ce = +Y[le[_e][0]];
        var Ie = re[Ce];
        if (Ie.p == "version" && typeof Te == "string") {
          var Ne = Te.split(".");
          Te = (+Ne[0] << 16) + (+Ne[1] || 0);
        }
        ve = write_TypedPropertyValue(Ie.t, Te);
      } else {
        var Re = guess_property_type(Te);
        Re == -1 && (Re = 31, Te = String(Te)), ve = write_TypedPropertyValue(Re, Te);
      }
      fe.push(ve), xe = new_buf(8), xe.write_shift(4, Y ? Ce : 2 + _e), ue.push(xe), he += 8 + ve.length;
    }
  var Ae = 8 * (fe.length + 1);
  for (_e = 0; _e < fe.length; ++_e)
    ue[_e].write_shift(4, Ae), Ae += fe[_e].length;
  return oe.write_shift(4, he), oe.write_shift(4, fe.length), bconcat([oe].concat(ue).concat(fe));
}
function parse_PropertySetStream(le, Y, re) {
  var oe = le.content;
  if (!oe) return {};
  prep_blob(oe, 0);
  var ue, fe, he, _e, ve = 0;
  oe.chk("feff", "Byte Order: "), oe.read_shift(2);
  var xe = oe.read_shift(4), Ee = oe.read_shift(16);
  if (Ee !== CFB.utils.consts.HEADER_CLSID && Ee !== re) throw new Error("Bad PropertySet CLSID " + Ee);
  if (ue = oe.read_shift(4), ue !== 1 && ue !== 2) throw new Error("Unrecognized #Sets: " + ue);
  if (fe = oe.read_shift(16), _e = oe.read_shift(4), ue === 1 && _e !== oe.l) throw new Error("Length mismatch: " + _e + " !== " + oe.l);
  ue === 2 && (he = oe.read_shift(16), ve = oe.read_shift(4));
  var Se = parse_PropertySet(oe, Y), Te = { SystemIdentifier: xe };
  for (var Ce in Se) Te[Ce] = Se[Ce];
  if (Te.FMTID = fe, ue === 1) return Te;
  if (ve - oe.l == 2 && (oe.l += 2), oe.l !== ve) throw new Error("Length mismatch 2: " + oe.l + " !== " + ve);
  var Ie;
  try {
    Ie = parse_PropertySet(oe, null);
  } catch {
  }
  for (Ce in Ie) Te[Ce] = Ie[Ce];
  return Te.FMTID = [fe, he], Te;
}
function write_PropertySetStream(le, Y, re, oe, ue, fe) {
  var he = new_buf(ue ? 68 : 48), _e = [he];
  he.write_shift(2, 65534), he.write_shift(2, 0), he.write_shift(4, 842412599), he.write_shift(16, CFB.utils.consts.HEADER_CLSID, "hex"), he.write_shift(4, ue ? 2 : 1), he.write_shift(16, Y, "hex"), he.write_shift(4, ue ? 68 : 48);
  var ve = write_PropertySet(le, re, oe);
  if (_e.push(ve), ue) {
    var xe = write_PropertySet(ue, null, null);
    he.write_shift(16, fe, "hex"), he.write_shift(4, 68 + ve.length), _e.push(xe);
  }
  return bconcat(_e);
}
function parsenoop2(le, Y) {
  return le.read_shift(Y), null;
}
function writezeroes(le, Y) {
  Y || (Y = new_buf(le));
  for (var re = 0; re < le; ++re) Y.write_shift(1, 0);
  return Y;
}
function parslurp(le, Y, re) {
  for (var oe = [], ue = le.l + Y; le.l < ue; ) oe.push(re(le, ue - le.l));
  if (ue !== le.l) throw new Error("Slurp error");
  return oe;
}
function parsebool(le, Y) {
  return le.read_shift(Y) === 1;
}
function writebool(le, Y) {
  return Y || (Y = new_buf(2)), Y.write_shift(2, +!!le), Y;
}
function parseuint16(le) {
  return le.read_shift(2, "u");
}
function writeuint16(le, Y) {
  return Y || (Y = new_buf(2)), Y.write_shift(2, le), Y;
}
function parseuint16a(le, Y) {
  return parslurp(le, Y, parseuint16);
}
function parse_Bes(le) {
  var Y = le.read_shift(1), re = le.read_shift(1);
  return re === 1 ? Y : Y === 1;
}
function write_Bes(le, Y, re) {
  return re || (re = new_buf(2)), re.write_shift(1, Y == "e" ? +le : +!!le), re.write_shift(1, Y == "e" ? 1 : 0), re;
}
function parse_ShortXLUnicodeString(le, Y, re) {
  var oe = le.read_shift(re && re.biff >= 12 ? 2 : 1), ue = "sbcs-cont", fe = current_codepage;
  if (re && re.biff >= 8 && (current_codepage = 1200), !re || re.biff == 8) {
    var he = le.read_shift(1);
    he && (ue = "dbcs-cont");
  } else re.biff == 12 && (ue = "wstr");
  re.biff >= 2 && re.biff <= 5 && (ue = "cpstr");
  var _e = oe ? le.read_shift(oe, ue) : "";
  return current_codepage = fe, _e;
}
function parse_XLUnicodeRichExtendedString(le) {
  var Y = current_codepage;
  current_codepage = 1200;
  var re = le.read_shift(2), oe = le.read_shift(1), ue = oe & 4, fe = oe & 8, he = 1 + (oe & 1), _e = 0, ve, xe = {};
  fe && (_e = le.read_shift(2)), ue && (ve = le.read_shift(4));
  var Ee = he == 2 ? "dbcs-cont" : "sbcs-cont", Se = re === 0 ? "" : le.read_shift(re, Ee);
  return fe && (le.l += 4 * _e), ue && (le.l += ve), xe.t = Se, fe || (xe.raw = "<t>" + xe.t + "</t>", xe.r = xe.t), current_codepage = Y, xe;
}
function write_XLUnicodeRichExtendedString(le) {
  var Y = le.t || "", re = new_buf(3);
  re.write_shift(2, Y.length), re.write_shift(1, 1);
  var oe = new_buf(2 * Y.length);
  oe.write_shift(2 * Y.length, Y, "utf16le");
  var ue = [re, oe];
  return bconcat(ue);
}
function parse_XLUnicodeStringNoCch(le, Y, re) {
  var oe;
  if (re) {
    if (re.biff >= 2 && re.biff <= 5) return le.read_shift(Y, "cpstr");
    if (re.biff >= 12) return le.read_shift(Y, "dbcs-cont");
  }
  var ue = le.read_shift(1);
  return ue === 0 ? oe = le.read_shift(Y, "sbcs-cont") : oe = le.read_shift(Y, "dbcs-cont"), oe;
}
function parse_XLUnicodeString(le, Y, re) {
  var oe = le.read_shift(re && re.biff == 2 ? 1 : 2);
  return oe === 0 ? (le.l++, "") : parse_XLUnicodeStringNoCch(le, oe, re);
}
function parse_XLUnicodeString2(le, Y, re) {
  if (re.biff > 5) return parse_XLUnicodeString(le, Y, re);
  var oe = le.read_shift(1);
  return oe === 0 ? (le.l++, "") : le.read_shift(oe, re.biff <= 4 || !le.lens ? "cpstr" : "sbcs-cont");
}
function write_XLUnicodeString(le, Y, re) {
  return re || (re = new_buf(3 + 2 * le.length)), re.write_shift(2, le.length), re.write_shift(1, 1), re.write_shift(31, le, "utf16le"), re;
}
function parse_ControlInfo(le) {
  var Y = le.read_shift(1);
  le.l++;
  var re = le.read_shift(2);
  return le.l += 2, [Y, re];
}
function parse_URLMoniker(le) {
  var Y = le.read_shift(4), re = le.l, oe = !1;
  Y > 24 && (le.l += Y - 24, le.read_shift(16) === "795881f43b1d7f48af2c825dc4852763" && (oe = !0), le.l = re);
  var ue = le.read_shift((oe ? Y - 24 : Y) >> 1, "utf16le").replace(chr0, "");
  return oe && (le.l += 24), ue;
}
function parse_FileMoniker(le) {
  for (var Y = le.read_shift(2), re = ""; Y-- > 0; ) re += "../";
  var oe = le.read_shift(0, "lpstr-ansi");
  if (le.l += 2, le.read_shift(2) != 57005) throw new Error("Bad FileMoniker");
  var ue = le.read_shift(4);
  if (ue === 0) return re + oe.replace(/\\/g, "/");
  var fe = le.read_shift(4);
  if (le.read_shift(2) != 3) throw new Error("Bad FileMoniker");
  var he = le.read_shift(fe >> 1, "utf16le").replace(chr0, "");
  return re + he;
}
function parse_HyperlinkMoniker(le, Y) {
  var re = le.read_shift(16);
  switch (re) {
    case "e0c9ea79f9bace118c8200aa004ba90b":
      return parse_URLMoniker(le);
    case "0303000000000000c000000000000046":
      return parse_FileMoniker(le);
    default:
      throw new Error("Unsupported Moniker " + re);
  }
}
function parse_HyperlinkString(le) {
  var Y = le.read_shift(4), re = Y > 0 ? le.read_shift(Y, "utf16le").replace(chr0, "") : "";
  return re;
}
function write_HyperlinkString(le, Y) {
  Y || (Y = new_buf(6 + le.length * 2)), Y.write_shift(4, 1 + le.length);
  for (var re = 0; re < le.length; ++re) Y.write_shift(2, le.charCodeAt(re));
  return Y.write_shift(2, 0), Y;
}
function parse_Hyperlink(le, Y) {
  var re = le.l + Y, oe = le.read_shift(4);
  if (oe !== 2) throw new Error("Unrecognized streamVersion: " + oe);
  var ue = le.read_shift(2);
  le.l += 2;
  var fe, he, _e, ve, xe = "", Ee, Se;
  ue & 16 && (fe = parse_HyperlinkString(le, re - le.l)), ue & 128 && (he = parse_HyperlinkString(le, re - le.l)), (ue & 257) === 257 && (_e = parse_HyperlinkString(le, re - le.l)), (ue & 257) === 1 && (ve = parse_HyperlinkMoniker(le, re - le.l)), ue & 8 && (xe = parse_HyperlinkString(le, re - le.l)), ue & 32 && (Ee = le.read_shift(16)), ue & 64 && (Se = parse_FILETIME(
    le
    /*, 8*/
  )), le.l = re;
  var Te = he || _e || ve || "";
  Te && xe && (Te += "#" + xe), Te || (Te = "#" + xe), ue & 2 && Te.charAt(0) == "/" && Te.charAt(1) != "/" && (Te = "file://" + Te);
  var Ce = { Target: Te };
  return Ee && (Ce.guid = Ee), Se && (Ce.time = Se), fe && (Ce.Tooltip = fe), Ce;
}
function write_Hyperlink(le) {
  var Y = new_buf(512), re = 0, oe = le.Target;
  oe.slice(0, 7) == "file://" && (oe = oe.slice(7));
  var ue = oe.indexOf("#"), fe = ue > -1 ? 31 : 23;
  switch (oe.charAt(0)) {
    case "#":
      fe = 28;
      break;
    case ".":
      fe &= -3;
      break;
  }
  Y.write_shift(4, 2), Y.write_shift(4, fe);
  var he = [8, 6815827, 6619237, 4849780, 83];
  for (re = 0; re < he.length; ++re) Y.write_shift(4, he[re]);
  if (fe == 28)
    oe = oe.slice(1), write_HyperlinkString(oe, Y);
  else if (fe & 2) {
    for (he = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" "), re = 0; re < he.length; ++re) Y.write_shift(1, parseInt(he[re], 16));
    var _e = ue > -1 ? oe.slice(0, ue) : oe;
    for (Y.write_shift(4, 2 * (_e.length + 1)), re = 0; re < _e.length; ++re) Y.write_shift(2, _e.charCodeAt(re));
    Y.write_shift(2, 0), fe & 8 && write_HyperlinkString(ue > -1 ? oe.slice(ue + 1) : "", Y);
  } else {
    for (he = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" "), re = 0; re < he.length; ++re) Y.write_shift(1, parseInt(he[re], 16));
    for (var ve = 0; oe.slice(ve * 3, ve * 3 + 3) == "../" || oe.slice(ve * 3, ve * 3 + 3) == "..\\"; ) ++ve;
    for (Y.write_shift(2, ve), Y.write_shift(4, oe.length - 3 * ve + 1), re = 0; re < oe.length - 3 * ve; ++re) Y.write_shift(1, oe.charCodeAt(re + 3 * ve) & 255);
    for (Y.write_shift(1, 0), Y.write_shift(2, 65535), Y.write_shift(2, 57005), re = 0; re < 6; ++re) Y.write_shift(4, 0);
  }
  return Y.slice(0, Y.l);
}
function parse_LongRGBA(le) {
  var Y = le.read_shift(1), re = le.read_shift(1), oe = le.read_shift(1), ue = le.read_shift(1);
  return [Y, re, oe, ue];
}
function parse_LongRGB(le, Y) {
  var re = parse_LongRGBA(le);
  return re[3] = 0, re;
}
function parse_XLSCell(le, Y, re) {
  var oe = le.read_shift(2), ue = le.read_shift(2), fe = { r: oe, c: ue, ixfe: 0 };
  if (re && re.biff == 2 || Y == 7) {
    var he = le.read_shift(1);
    fe.ixfe = he & 63, le.l += 2;
  } else fe.ixfe = le.read_shift(2);
  return fe;
}
function write_XLSCell(le, Y, re, oe) {
  return oe || (oe = new_buf(6)), oe.write_shift(2, le), oe.write_shift(2, Y), oe.write_shift(2, re || 0), oe;
}
function parse_frtHeader(le) {
  var Y = le.read_shift(2), re = le.read_shift(2);
  return le.l += 8, { type: Y, flags: re };
}
function parse_OptXLUnicodeString(le, Y, re) {
  return Y === 0 ? "" : parse_XLUnicodeString2(le, Y, re);
}
function parse_XTI(le, Y, re) {
  var oe = re.biff > 8 ? 4 : 2, ue = le.read_shift(oe), fe = le.read_shift(oe, "i"), he = le.read_shift(oe, "i");
  return [ue, fe, he];
}
function parse_RkRec(le) {
  var Y = le.read_shift(2), re = parse_RkNumber(le);
  return [Y, re];
}
function parse_AddinUdf(le, Y, re) {
  le.l += 4, Y -= 4;
  var oe = le.l + Y, ue = parse_ShortXLUnicodeString(le, Y, re), fe = le.read_shift(2);
  if (oe -= le.l, fe !== oe) throw new Error("Malformed AddinUdf: padding = " + oe + " != " + fe);
  return le.l += fe, ue;
}
function parse_Ref8U(le) {
  var Y = le.read_shift(2), re = le.read_shift(2), oe = le.read_shift(2), ue = le.read_shift(2);
  return { s: { c: oe, r: Y }, e: { c: ue, r: re } };
}
function write_Ref8U(le, Y) {
  return Y || (Y = new_buf(8)), Y.write_shift(2, le.s.r), Y.write_shift(2, le.e.r), Y.write_shift(2, le.s.c), Y.write_shift(2, le.e.c), Y;
}
function parse_RefU(le) {
  var Y = le.read_shift(2), re = le.read_shift(2), oe = le.read_shift(1), ue = le.read_shift(1);
  return { s: { c: oe, r: Y }, e: { c: ue, r: re } };
}
var parse_Ref = parse_RefU;
function parse_FtCmo(le) {
  le.l += 4;
  var Y = le.read_shift(2), re = le.read_shift(2), oe = le.read_shift(2);
  return le.l += 12, [re, Y, oe];
}
function parse_FtNts(le) {
  var Y = {};
  return le.l += 4, le.l += 16, Y.fSharedNote = le.read_shift(2), le.l += 4, Y;
}
function parse_FtCf(le) {
  var Y = {};
  return le.l += 4, le.cf = le.read_shift(2), Y;
}
function parse_FtSkip(le) {
  le.l += 2, le.l += le.read_shift(2);
}
var FtTab = {
  0: parse_FtSkip,
  /* FtEnd */
  4: parse_FtSkip,
  /* FtMacro */
  5: parse_FtSkip,
  /* FtButton */
  6: parse_FtSkip,
  /* FtGmo */
  7: parse_FtCf,
  /* FtCf */
  8: parse_FtSkip,
  /* FtPioGrbit */
  9: parse_FtSkip,
  /* FtPictFmla */
  10: parse_FtSkip,
  /* FtCbls */
  11: parse_FtSkip,
  /* FtRbo */
  12: parse_FtSkip,
  /* FtSbs */
  13: parse_FtNts,
  /* FtNts */
  14: parse_FtSkip,
  /* FtSbsFmla */
  15: parse_FtSkip,
  /* FtGboData */
  16: parse_FtSkip,
  /* FtEdoData */
  17: parse_FtSkip,
  /* FtRboData */
  18: parse_FtSkip,
  /* FtCblsData */
  19: parse_FtSkip,
  /* FtLbsData */
  20: parse_FtSkip,
  /* FtCblsFmla */
  21: parse_FtCmo
};
function parse_FtArray(le, Y) {
  for (var re = le.l + Y, oe = []; le.l < re; ) {
    var ue = le.read_shift(2);
    le.l -= 2;
    try {
      oe[ue] = FtTab[ue](le, re - le.l);
    } catch {
      return le.l = re, oe;
    }
  }
  return le.l != re && (le.l = re), oe;
}
function parse_BOF(le, Y) {
  var re = { BIFFVer: 0, dt: 0 };
  switch (re.BIFFVer = le.read_shift(2), Y -= 2, Y >= 2 && (re.dt = le.read_shift(2), le.l -= 2), re.BIFFVer) {
    case 1536:
    /* BIFF8 */
    case 1280:
    /* BIFF5 */
    case 1024:
    /* BIFF4 */
    case 768:
    /* BIFF3 */
    case 512:
    /* BIFF2 */
    case 2:
    case 7:
      break;
    default:
      if (Y > 6) throw new Error("Unexpected BIFF Ver " + re.BIFFVer);
  }
  return le.read_shift(Y), re;
}
function write_BOF(le, Y, re) {
  var oe = 1536, ue = 16;
  switch (re.bookType) {
    case "biff8":
      break;
    case "biff5":
      oe = 1280, ue = 8;
      break;
    case "biff4":
      oe = 4, ue = 6;
      break;
    case "biff3":
      oe = 3, ue = 6;
      break;
    case "biff2":
      oe = 2, ue = 4;
      break;
    case "xla":
      break;
    default:
      throw new Error("unsupported BIFF version");
  }
  var fe = new_buf(ue);
  return fe.write_shift(2, oe), fe.write_shift(2, Y), ue > 4 && fe.write_shift(2, 29282), ue > 6 && fe.write_shift(2, 1997), ue > 8 && (fe.write_shift(2, 49161), fe.write_shift(2, 1), fe.write_shift(2, 1798), fe.write_shift(2, 0)), fe;
}
function parse_InterfaceHdr(le, Y) {
  return Y === 0 || le.read_shift(2), 1200;
}
function parse_WriteAccess(le, Y, re) {
  if (re.enc)
    return le.l += Y, "";
  var oe = le.l, ue = parse_XLUnicodeString2(le, 0, re);
  return le.read_shift(Y + oe - le.l), ue;
}
function write_WriteAccess(le, Y) {
  var re = !Y || Y.biff == 8, oe = new_buf(re ? 112 : 54);
  for (oe.write_shift(Y.biff == 8 ? 2 : 1, 7), re && oe.write_shift(1, 0), oe.write_shift(4, 859007059), oe.write_shift(4, 5458548 | (re ? 0 : 536870912)); oe.l < oe.length; ) oe.write_shift(1, re ? 0 : 32);
  return oe;
}
function parse_WsBool(le, Y, re) {
  var oe = re && re.biff == 8 || Y == 2 ? le.read_shift(2) : (le.l += Y, 0);
  return { fDialog: oe & 16, fBelow: oe & 64, fRight: oe & 128 };
}
function parse_BoundSheet8(le, Y, re) {
  var oe = "";
  if (re.biff == 4)
    return oe = parse_ShortXLUnicodeString(le, 0, re), oe.length === 0 && (oe = "Sheet1"), { name: oe };
  var ue = le.read_shift(4), fe = le.read_shift(1) & 3, he = le.read_shift(1);
  switch (he) {
    case 0:
      he = "Worksheet";
      break;
    case 1:
      he = "Macrosheet";
      break;
    case 2:
      he = "Chartsheet";
      break;
    case 6:
      he = "VBAModule";
      break;
  }
  return oe = parse_ShortXLUnicodeString(le, 0, re), oe.length === 0 && (oe = "Sheet1"), { pos: ue, hs: fe, dt: he, name: oe };
}
function write_BoundSheet8(le, Y) {
  var re = !Y || Y.biff >= 8 ? 2 : 1, oe = new_buf(8 + re * le.name.length);
  oe.write_shift(4, le.pos), oe.write_shift(1, le.hs || 0), oe.write_shift(1, le.dt), oe.write_shift(1, le.name.length), Y.biff >= 8 && oe.write_shift(1, 1), oe.write_shift(re * le.name.length, le.name, Y.biff < 8 ? "sbcs" : "utf16le");
  var ue = oe.slice(0, oe.l);
  return ue.l = oe.l, ue;
}
function parse_SST(le, Y) {
  for (var re = le.l + Y, oe = le.read_shift(4), ue = le.read_shift(4), fe = [], he = 0; he != ue && le.l < re; ++he)
    fe.push(parse_XLUnicodeRichExtendedString(le));
  return fe.Count = oe, fe.Unique = ue, fe;
}
function write_SST(le, Y) {
  var re = new_buf(8);
  re.write_shift(4, le.Count), re.write_shift(4, le.Unique);
  for (var oe = [], ue = 0; ue < le.length; ++ue) oe[ue] = write_XLUnicodeRichExtendedString(le[ue]);
  var fe = bconcat([re].concat(oe));
  return fe.parts = [re.length].concat(oe.map(function(he) {
    return he.length;
  })), fe;
}
function parse_ExtSST(le, Y) {
  var re = {};
  return re.dsst = le.read_shift(2), le.l += Y - 2, re;
}
function parse_Row(le) {
  var Y = {};
  Y.r = le.read_shift(2), Y.c = le.read_shift(2), Y.cnt = le.read_shift(2) - Y.c;
  var re = le.read_shift(2);
  le.l += 4;
  var oe = le.read_shift(1);
  return le.l += 3, oe & 7 && (Y.level = oe & 7), oe & 32 && (Y.hidden = !0), oe & 64 && (Y.hpt = re / 20), Y;
}
function parse_ForceFullCalculation(le) {
  var Y = parse_frtHeader(le);
  if (Y.type != 2211) throw new Error("Invalid Future Record " + Y.type);
  var re = le.read_shift(4);
  return re !== 0;
}
function parse_RecalcId(le) {
  return le.read_shift(2), le.read_shift(4);
}
function parse_DefaultRowHeight(le, Y, re) {
  var oe = 0;
  re && re.biff == 2 || (oe = le.read_shift(2));
  var ue = le.read_shift(2);
  re && re.biff == 2 && (oe = 1 - (ue >> 15), ue &= 32767);
  var fe = { Unsynced: oe & 1, DyZero: (oe & 2) >> 1, ExAsc: (oe & 4) >> 2, ExDsc: (oe & 8) >> 3 };
  return [fe, ue];
}
function parse_Window1(le) {
  var Y = le.read_shift(2), re = le.read_shift(2), oe = le.read_shift(2), ue = le.read_shift(2), fe = le.read_shift(2), he = le.read_shift(2), _e = le.read_shift(2), ve = le.read_shift(2), xe = le.read_shift(2);
  return {
    Pos: [Y, re],
    Dim: [oe, ue],
    Flags: fe,
    CurTab: he,
    FirstTab: _e,
    Selected: ve,
    TabRatio: xe
  };
}
function write_Window1() {
  var le = new_buf(18);
  return le.write_shift(2, 0), le.write_shift(2, 0), le.write_shift(2, 29280), le.write_shift(2, 17600), le.write_shift(2, 56), le.write_shift(2, 0), le.write_shift(2, 0), le.write_shift(2, 1), le.write_shift(2, 500), le;
}
function parse_Window2(le, Y, re) {
  if (re && re.biff >= 2 && re.biff < 5) return {};
  var oe = le.read_shift(2);
  return { RTL: oe & 64 };
}
function write_Window2(le) {
  var Y = new_buf(18), re = 1718;
  return le && le.RTL && (re |= 64), Y.write_shift(2, re), Y.write_shift(4, 0), Y.write_shift(4, 64), Y.write_shift(4, 0), Y.write_shift(4, 0), Y;
}
function parse_Pane() {
}
function parse_Font(le, Y, re) {
  var oe = {
    dyHeight: le.read_shift(2),
    fl: le.read_shift(2)
  };
  switch (re && re.biff || 8) {
    case 2:
      break;
    case 3:
    case 4:
      le.l += 2;
      break;
    default:
      le.l += 10;
      break;
  }
  return oe.name = parse_ShortXLUnicodeString(le, 0, re), oe;
}
function write_Font(le, Y) {
  var re = le.name || "Arial", oe = Y && Y.biff == 5, ue = oe ? 15 + re.length : 16 + 2 * re.length, fe = new_buf(ue);
  return fe.write_shift(2, le.sz * 20), fe.write_shift(4, 0), fe.write_shift(2, 400), fe.write_shift(4, 0), fe.write_shift(2, 0), fe.write_shift(1, re.length), oe || fe.write_shift(1, 1), fe.write_shift((oe ? 1 : 2) * re.length, re, oe ? "sbcs" : "utf16le"), fe;
}
function parse_LabelSst(le, Y, re) {
  var oe = parse_XLSCell(le, Y, re);
  return oe.isst = le.read_shift(4), oe;
}
function write_LabelSst(le, Y, re, oe) {
  var ue = new_buf(10);
  return write_XLSCell(le, Y, oe, ue), ue.write_shift(4, re), ue;
}
function parse_Label(le, Y, re) {
  re.biffguess && re.biff == 2 && (re.biff = 5);
  var oe = le.l + Y, ue = parse_XLSCell(le, Y, re), fe = parse_XLUnicodeString(le, oe - le.l, re);
  return ue.val = fe, ue;
}
function write_Label(le, Y, re, oe, ue) {
  var fe = !ue || ue.biff == 8, he = new_buf(8 + +fe + (1 + fe) * re.length);
  return write_XLSCell(le, Y, oe, he), he.write_shift(2, re.length), fe && he.write_shift(1, 1), he.write_shift((1 + fe) * re.length, re, fe ? "utf16le" : "sbcs"), he;
}
function parse_Format(le, Y, re) {
  var oe = le.read_shift(2), ue = parse_XLUnicodeString2(le, 0, re);
  return [oe, ue];
}
function write_Format(le, Y, re, oe) {
  var ue = re && re.biff == 5;
  oe || (oe = new_buf(ue ? 3 + Y.length : 5 + 2 * Y.length)), oe.write_shift(2, le), oe.write_shift(ue ? 1 : 2, Y.length), ue || oe.write_shift(1, 1), oe.write_shift((ue ? 1 : 2) * Y.length, Y, ue ? "sbcs" : "utf16le");
  var fe = oe.length > oe.l ? oe.slice(0, oe.l) : oe;
  return fe.l == null && (fe.l = fe.length), fe;
}
var parse_BIFF2Format = parse_XLUnicodeString2;
function write_BIFF2Format(le) {
  var Y = new_buf(1 + le.length);
  return Y.write_shift(1, le.length), Y.write_shift(le.length, le, "sbcs"), Y;
}
function write_BIFF4Format(le) {
  var Y = new_buf(3 + le.length);
  return Y.l += 2, Y.write_shift(1, le.length), Y.write_shift(le.length, le, "sbcs"), Y;
}
function parse_Dimensions(le, Y, re) {
  var oe = le.l + Y, ue = re.biff == 8 || !re.biff ? 4 : 2, fe = le.read_shift(ue), he = le.read_shift(ue), _e = le.read_shift(2), ve = le.read_shift(2);
  return le.l = oe, { s: { r: fe, c: _e }, e: { r: he, c: ve } };
}
function write_Dimensions(le, Y) {
  var re = Y.biff == 8 || !Y.biff ? 4 : 2, oe = new_buf(2 * re + 6);
  return oe.write_shift(re, le.s.r), oe.write_shift(re, le.e.r + 1), oe.write_shift(2, le.s.c), oe.write_shift(2, le.e.c + 1), oe.write_shift(2, 0), oe;
}
function parse_RK(le) {
  var Y = le.read_shift(2), re = le.read_shift(2), oe = parse_RkRec(le);
  return { r: Y, c: re, ixfe: oe[0], rknum: oe[1] };
}
function parse_MulRk(le, Y) {
  for (var re = le.l + Y - 2, oe = le.read_shift(2), ue = le.read_shift(2), fe = []; le.l < re; ) fe.push(parse_RkRec(le));
  if (le.l !== re) throw new Error("MulRK read error");
  var he = le.read_shift(2);
  if (fe.length != he - ue + 1) throw new Error("MulRK length mismatch");
  return { r: oe, c: ue, C: he, rkrec: fe };
}
function parse_MulBlank(le, Y) {
  for (var re = le.l + Y - 2, oe = le.read_shift(2), ue = le.read_shift(2), fe = []; le.l < re; ) fe.push(le.read_shift(2));
  if (le.l !== re) throw new Error("MulBlank read error");
  var he = le.read_shift(2);
  if (fe.length != he - ue + 1) throw new Error("MulBlank length mismatch");
  return { r: oe, c: ue, C: he, ixfe: fe };
}
function parse_CellStyleXF(le, Y, re, oe) {
  var ue = {}, fe = le.read_shift(4), he = le.read_shift(4), _e = le.read_shift(4), ve = le.read_shift(2);
  return ue.patternType = XLSFillPattern[_e >> 26], oe.cellStyles && (ue.alc = fe & 7, ue.fWrap = fe >> 3 & 1, ue.alcV = fe >> 4 & 7, ue.fJustLast = fe >> 7 & 1, ue.trot = fe >> 8 & 255, ue.cIndent = fe >> 16 & 15, ue.fShrinkToFit = fe >> 20 & 1, ue.iReadOrder = fe >> 22 & 2, ue.fAtrNum = fe >> 26 & 1, ue.fAtrFnt = fe >> 27 & 1, ue.fAtrAlc = fe >> 28 & 1, ue.fAtrBdr = fe >> 29 & 1, ue.fAtrPat = fe >> 30 & 1, ue.fAtrProt = fe >> 31 & 1, ue.dgLeft = he & 15, ue.dgRight = he >> 4 & 15, ue.dgTop = he >> 8 & 15, ue.dgBottom = he >> 12 & 15, ue.icvLeft = he >> 16 & 127, ue.icvRight = he >> 23 & 127, ue.grbitDiag = he >> 30 & 3, ue.icvTop = _e & 127, ue.icvBottom = _e >> 7 & 127, ue.icvDiag = _e >> 14 & 127, ue.dgDiag = _e >> 21 & 15, ue.icvFore = ve & 127, ue.icvBack = ve >> 7 & 127, ue.fsxButton = ve >> 14 & 1), ue;
}
function parse_XF(le, Y, re) {
  var oe = {};
  return oe.ifnt = le.read_shift(2), oe.numFmtId = le.read_shift(2), oe.flags = le.read_shift(2), oe.fStyle = oe.flags >> 2 & 1, Y -= 6, oe.data = parse_CellStyleXF(le, Y, oe.fStyle, re), oe;
}
function write_XF(le, Y, re, oe) {
  var ue = re && re.biff == 5;
  oe || (oe = new_buf(ue ? 16 : 20)), oe.write_shift(2, 0), le.style ? (oe.write_shift(2, le.numFmtId || 0), oe.write_shift(2, 65524)) : (oe.write_shift(2, le.numFmtId || 0), oe.write_shift(2, Y << 4));
  var fe = 0;
  return le.numFmtId > 0 && ue && (fe |= 1024), oe.write_shift(4, fe), oe.write_shift(4, 0), ue || oe.write_shift(4, 0), oe.write_shift(2, 0), oe;
}
function parse_BIFF2XF(le) {
  var Y = {};
  return Y.ifnt = le.read_shift(1), le.l++, Y.flags = le.read_shift(1), Y.numFmtId = Y.flags & 63, Y.flags >>= 6, Y.fStyle = 0, Y.data = {}, Y;
}
function write_BIFF2XF(le) {
  var Y = new_buf(4);
  return Y.l += 2, Y.write_shift(1, le.numFmtId), Y.l++, Y;
}
function write_BIFF3XF(le) {
  var Y = new_buf(12);
  return Y.l++, Y.write_shift(1, le.numFmtId), Y.l += 10, Y;
}
var write_BIFF4XF = write_BIFF3XF;
function parse_BIFF3XF(le) {
  var Y = {};
  return Y.ifnt = le.read_shift(1), Y.numFmtId = le.read_shift(1), Y.flags = le.read_shift(2), Y.fStyle = Y.flags >> 2 & 1, Y.data = {}, Y;
}
function parse_BIFF4XF(le) {
  var Y = {};
  return Y.ifnt = le.read_shift(1), Y.numFmtId = le.read_shift(1), Y.flags = le.read_shift(2), Y.fStyle = Y.flags >> 2 & 1, Y.data = {}, Y;
}
function parse_Guts(le) {
  le.l += 4;
  var Y = [le.read_shift(2), le.read_shift(2)];
  if (Y[0] !== 0 && Y[0]--, Y[1] !== 0 && Y[1]--, Y[0] > 7 || Y[1] > 7) throw new Error("Bad Gutters: " + Y.join("|"));
  return Y;
}
function write_Guts(le) {
  var Y = new_buf(8);
  return Y.write_shift(4, 0), Y.write_shift(2, 0), Y.write_shift(2, 0), Y;
}
function parse_BoolErr(le, Y, re) {
  var oe = parse_XLSCell(le, 6, re), ue = parse_Bes(le);
  return oe.val = ue, oe.t = ue === !0 || ue === !1 ? "b" : "e", oe;
}
function write_BoolErr(le, Y, re, oe, ue, fe) {
  var he = new_buf(8);
  return write_XLSCell(le, Y, oe, he), write_Bes(re, fe, he), he;
}
function parse_Number(le, Y, re) {
  re.biffguess && re.biff == 2 && (re.biff = 5);
  var oe = parse_XLSCell(le, 6, re), ue = parse_Xnum(le);
  return oe.val = ue, oe;
}
function write_Number(le, Y, re, oe) {
  var ue = new_buf(14);
  return write_XLSCell(le, Y, oe, ue), write_Xnum(re, ue), ue;
}
var parse_XLHeaderFooter = parse_OptXLUnicodeString;
function parse_SupBook(le, Y, re) {
  var oe = le.l + Y, ue = le.read_shift(2), fe = le.read_shift(2);
  if (re.sbcch = fe, fe == 1025 || fe == 14849) return [fe, ue];
  if (fe < 1 || fe > 255) throw new Error("Unexpected SupBook type: " + fe);
  for (var he = parse_XLUnicodeStringNoCch(le, fe), _e = []; oe > le.l; ) _e.push(parse_XLUnicodeString(le));
  return [fe, ue, he, _e];
}
function parse_ExternName(le, Y, re) {
  var oe = le.read_shift(2), ue, fe = {
    fBuiltIn: oe & 1,
    fWantAdvise: oe >>> 1 & 1,
    fWantPict: oe >>> 2 & 1,
    fOle: oe >>> 3 & 1,
    fOleLink: oe >>> 4 & 1,
    cf: oe >>> 5 & 1023,
    fIcon: oe >>> 15 & 1
  };
  return re.sbcch === 14849 && (ue = parse_AddinUdf(le, Y - 2, re)), fe.body = ue || le.read_shift(Y - 2), typeof ue == "string" && (fe.Name = ue), fe;
}
function parse_Lbl(le, Y, re) {
  var oe = le.l + Y, ue = le.read_shift(2), fe = le.read_shift(1), he = le.read_shift(1), _e = le.read_shift(re && re.biff == 2 ? 1 : 2), ve = 0;
  (!re || re.biff >= 5) && (re.biff != 5 && (le.l += 2), ve = le.read_shift(2), re.biff == 5 && (le.l += 2), le.l += 4);
  var xe = parse_XLUnicodeStringNoCch(le, he, re);
  ue & 32 && (xe = XLSLblBuiltIn[xe.charCodeAt(0)]);
  var Ee = oe - le.l;
  re && re.biff == 2 && --Ee;
  var Se = oe == le.l || _e === 0 || !(Ee > 0) ? [] : parse_NameParsedFormula(le, Ee, re, _e);
  return {
    chKey: fe,
    Name: xe,
    itab: ve,
    rgce: Se
  };
}
function parse_ExternSheet(le, Y, re) {
  if (re.biff < 8 || !(re.biff > 8) && Y == le[le.l] + (le[le.l + 1] == 3 ? 1 : 0) + 1) return parse_BIFF5ExternSheet(le, Y, re);
  for (var oe = [], ue = le.l + Y, fe = le.read_shift(re.biff > 8 ? 4 : 2); fe-- !== 0; ) oe.push(parse_XTI(le, re.biff > 8 ? 12 : 6, re));
  if (le.l != ue) throw new Error("Bad ExternSheet: " + le.l + " != " + ue);
  return oe;
}
function parse_BIFF5ExternSheet(le, Y, re) {
  le[le.l + 1] == 3 && le[le.l]++;
  var oe = parse_ShortXLUnicodeString(le, Y, re);
  return oe.charCodeAt(0) == 3 ? oe.slice(1) : oe;
}
function parse_NameCmt(le, Y, re) {
  if (re.biff < 8) {
    le.l += Y;
    return;
  }
  var oe = le.read_shift(2), ue = le.read_shift(2), fe = parse_XLUnicodeStringNoCch(le, oe, re), he = parse_XLUnicodeStringNoCch(le, ue, re);
  return [fe, he];
}
function parse_ShrFmla(le, Y, re) {
  var oe = parse_RefU(le);
  le.l++;
  var ue = le.read_shift(1);
  return Y -= 8, [parse_SharedParsedFormula(le, Y, re), ue, oe];
}
function parse_Array(le, Y, re) {
  var oe = parse_Ref(le);
  switch (re.biff) {
    case 2:
      le.l++, Y -= 7;
      break;
    case 3:
    case 4:
      le.l += 2, Y -= 8;
      break;
    default:
      le.l += 6, Y -= 12;
  }
  return [oe, parse_ArrayParsedFormula(le, Y, re)];
}
function parse_MTRSettings(le) {
  var Y = le.read_shift(4) !== 0, re = le.read_shift(4) !== 0, oe = le.read_shift(4);
  return [Y, re, oe];
}
function parse_NoteSh(le, Y, re) {
  var oe = le.read_shift(2), ue = le.read_shift(2), fe = le.read_shift(2), he = le.read_shift(2), _e = parse_XLUnicodeString2(le, 0, re);
  return [{ r: oe, c: ue }, _e, he, fe];
}
function parse_Note(le, Y, re) {
  if (re && re.biff < 8) {
    var oe = le.read_shift(2), ue = le.read_shift(2);
    if (oe == 65535 || oe == -1) return;
    var fe = le.read_shift(2), he = le.read_shift(Math.min(fe, 2048), "cpstr");
    return [{ r: oe, c: ue }, he];
  }
  return parse_NoteSh(le, Y, re);
}
function write_NOTE_BIFF2(le, Y, re, oe) {
  var ue = new_buf(6 + (oe || le.length));
  return ue.write_shift(2, Y), ue.write_shift(2, re), ue.write_shift(2, oe || le.length), ue.write_shift(le.length, le, "sbcs"), ue;
}
function parse_MergeCells(le, Y) {
  for (var re = [], oe = le.read_shift(2); oe--; ) re.push(parse_Ref8U(le));
  return re;
}
function write_MergeCells(le) {
  var Y = new_buf(2 + le.length * 8);
  Y.write_shift(2, le.length);
  for (var re = 0; re < le.length; ++re) write_Ref8U(le[re], Y);
  return Y;
}
function parse_Obj(le, Y, re) {
  if (re && re.biff < 8) return parse_BIFF5Obj(le, Y, re);
  var oe = parse_FtCmo(le), ue = parse_FtArray(le, Y - 22, oe[1]);
  return { cmo: oe, ft: ue };
}
var parse_BIFF5OT = {
  8: function(le, Y) {
    var re = le.l + Y;
    le.l += 10;
    var oe = le.read_shift(2);
    le.l += 4, le.l += 2, le.l += 2, le.l += 2, le.l += 4;
    var ue = le.read_shift(1);
    return le.l += ue, le.l = re, { fmt: oe };
  }
};
function parse_BIFF5Obj(le, Y, re) {
  le.l += 4;
  var oe = le.read_shift(2), ue = le.read_shift(2), fe = le.read_shift(2);
  le.l += 2, le.l += 2, le.l += 2, le.l += 2, le.l += 2, le.l += 2, le.l += 2, le.l += 2, le.l += 2, le.l += 6, Y -= 36;
  var he = [];
  return he.push((parse_BIFF5OT[oe] || parsenoop)(le, Y, re)), { cmo: [ue, oe, fe], ft: he };
}
function parse_TxO(le, Y, re) {
  var oe = le.l, ue = "";
  try {
    le.l += 4;
    var fe = (re.lastobj || { cmo: [0, 0] }).cmo[1], he;
    [0, 5, 7, 11, 12, 14].indexOf(fe) == -1 ? le.l += 6 : he = parse_ControlInfo(le, 6, re);
    var _e = le.read_shift(2);
    le.read_shift(2), parseuint16(le, 2);
    var ve = le.read_shift(2);
    le.l += ve;
    for (var xe = 1; xe < le.lens.length - 1; ++xe) {
      if (le.l - oe != le.lens[xe]) throw new Error("TxO: bad continue record");
      var Ee = le[le.l], Se = parse_XLUnicodeStringNoCch(le, le.lens[xe + 1] - le.lens[xe] - 1);
      if (ue += Se, ue.length >= (Ee ? _e : 2 * _e)) break;
    }
    if (ue.length !== _e && ue.length !== _e * 2)
      throw new Error("cchText: " + _e + " != " + ue.length);
    return le.l = oe + Y, { t: ue };
  } catch {
    return le.l = oe + Y, { t: ue };
  }
}
function parse_HLink(le, Y) {
  var re = parse_Ref8U(le);
  le.l += 16;
  var oe = parse_Hyperlink(le, Y - 24);
  return [re, oe];
}
function write_HLink(le) {
  var Y = new_buf(24), re = decode_cell(le[0]);
  Y.write_shift(2, re.r), Y.write_shift(2, re.r), Y.write_shift(2, re.c), Y.write_shift(2, re.c);
  for (var oe = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" "), ue = 0; ue < 16; ++ue) Y.write_shift(1, parseInt(oe[ue], 16));
  return bconcat([Y, write_Hyperlink(le[1])]);
}
function parse_HLinkTooltip(le, Y) {
  le.read_shift(2);
  var re = parse_Ref8U(le), oe = le.read_shift((Y - 10) / 2, "dbcs-cont");
  return oe = oe.replace(chr0, ""), [re, oe];
}
function write_HLinkTooltip(le) {
  var Y = le[1].Tooltip, re = new_buf(10 + 2 * (Y.length + 1));
  re.write_shift(2, 2048);
  var oe = decode_cell(le[0]);
  re.write_shift(2, oe.r), re.write_shift(2, oe.r), re.write_shift(2, oe.c), re.write_shift(2, oe.c);
  for (var ue = 0; ue < Y.length; ++ue) re.write_shift(2, Y.charCodeAt(ue));
  return re.write_shift(2, 0), re;
}
function parse_Country(le) {
  var Y = [0, 0], re;
  return re = le.read_shift(2), Y[0] = CountryEnum[re] || re, re = le.read_shift(2), Y[1] = CountryEnum[re] || re, Y;
}
function write_Country(le) {
  return le || (le = new_buf(4)), le.write_shift(2, 1), le.write_shift(2, 1), le;
}
function parse_ClrtClient(le) {
  for (var Y = le.read_shift(2), re = []; Y-- > 0; ) re.push(parse_LongRGB(le));
  return re;
}
function parse_Palette(le) {
  for (var Y = le.read_shift(2), re = []; Y-- > 0; ) re.push(parse_LongRGB(le));
  return re;
}
function parse_XFCRC(le) {
  le.l += 2;
  var Y = { cxfs: 0, crc: 0 };
  return Y.cxfs = le.read_shift(2), Y.crc = le.read_shift(4), Y;
}
function parse_ColInfo(le, Y, re) {
  if (!re.cellStyles) return parsenoop(le, Y);
  var oe = re && re.biff >= 12 ? 4 : 2, ue = le.read_shift(oe), fe = le.read_shift(oe), he = le.read_shift(oe), _e = le.read_shift(oe), ve = le.read_shift(2);
  oe == 2 && (le.l += 2);
  var xe = { s: ue, e: fe, w: he, ixfe: _e, flags: ve };
  return (re.biff >= 5 || !re.biff) && (xe.level = ve >> 8 & 7), xe;
}
function write_ColInfo(le, Y) {
  var re = new_buf(12);
  re.write_shift(2, Y), re.write_shift(2, Y), re.write_shift(2, le.width * 256), re.write_shift(2, 0);
  var oe = 0;
  return le.hidden && (oe |= 1), re.write_shift(1, oe), oe = le.level || 0, re.write_shift(1, oe), re.write_shift(2, 0), re;
}
function parse_Setup(le, Y) {
  var re = {};
  return Y < 32 || (le.l += 16, re.header = parse_Xnum(le), re.footer = parse_Xnum(le), le.l += 2), re;
}
function parse_ShtProps(le, Y, re) {
  var oe = { area: !1 };
  if (re.biff != 5)
    return le.l += Y, oe;
  var ue = le.read_shift(1);
  return le.l += 3, ue & 16 && (oe.area = !0), oe;
}
function write_RRTabId(le) {
  for (var Y = new_buf(2 * le), re = 0; re < le; ++re) Y.write_shift(2, re + 1);
  return Y;
}
var parse_Blank = parse_XLSCell, parse_Scl = parseuint16a, parse_String = parse_XLUnicodeString;
function parse_ImData(le) {
  var Y = le.read_shift(2), re = le.read_shift(2), oe = le.read_shift(4), ue = { fmt: Y, env: re, len: oe, data: le.slice(le.l, le.l + oe) };
  return le.l += oe, ue;
}
function write_BIFF2Cell(le, Y, re, oe, ue) {
  return le || (le = new_buf(7)), le.write_shift(2, Y), le.write_shift(2, re), le.write_shift(
    1,
    oe || 0
    /* & 0x3F */
  ), le.write_shift(
    1,
    ue || 0
    /* & 0x3F */
  ), le.write_shift(1, 0), le;
}
function parse_BIFF2STR(le, Y, re) {
  re.biffguess && re.biff == 5 && (re.biff = 2);
  var oe = parse_XLSCell(le, 7, re), ue = parse_XLUnicodeString2(le, Y - 7, re);
  return oe.t = "str", oe.val = ue, oe;
}
function parse_BIFF2NUM(le, Y, re) {
  var oe = parse_XLSCell(le, 7, re), ue = parse_Xnum(le);
  return oe.t = "n", oe.val = ue, oe;
}
function write_BIFF2NUM(le, Y, re, oe, ue) {
  var fe = new_buf(15);
  return write_BIFF2Cell(fe, le, Y, oe || 0, ue || 0), fe.write_shift(8, re, "f"), fe;
}
function parse_BIFF2INT(le, Y, re) {
  var oe = parse_XLSCell(le, 7, re), ue = le.read_shift(2);
  return oe.t = "n", oe.val = ue, oe;
}
function write_BIFF2INT(le, Y, re, oe, ue) {
  var fe = new_buf(9);
  return write_BIFF2Cell(fe, le, Y, oe || 0, ue || 0), fe.write_shift(2, re), fe;
}
function parse_BIFF2STRING(le) {
  var Y = le.read_shift(1);
  return Y === 0 ? (le.l++, "") : le.read_shift(Y, "sbcs-cont");
}
function parse_BIFF2BOOLERR(le, Y, re) {
  var oe = le.l + 7, ue = parse_XLSCell(le, 6, re);
  le.l = oe;
  var fe = parse_Bes(le);
  return ue.val = fe, ue.t = fe === !0 || fe === !1 ? "b" : "e", ue;
}
function parse_BIFF2FONTXTRA(le, Y) {
  le.l += 6, le.l += 2, le.l += 1, le.l += 3, le.l += 1, le.l += Y - 13;
}
function parse_RString(le, Y, re) {
  var oe = le.l + Y, ue = parse_XLSCell(le, 6, re), fe = le.read_shift(2), he = parse_XLUnicodeStringNoCch(le, fe, re);
  return le.l = oe, ue.t = "str", ue.val = he, ue;
}
function parse_BIFF4SheetInfo(le) {
  var Y = le.read_shift(4), re = le.read_shift(1), oe = le.read_shift(re, "sbcs");
  return oe.length === 0 && (oe = "Sheet1"), { flags: Y, name: oe };
}
var DBF_SUPPORTED_VERSIONS = [2, 3, 48, 49, 131, 139, 140, 245], DBF = /* @__PURE__ */ function() {
  var le = {
    /* Code Pages Supported by Visual FoxPro */
    1: 437,
    2: 850,
    3: 1252,
    4: 1e4,
    100: 852,
    101: 866,
    102: 865,
    103: 861,
    104: 895,
    105: 620,
    106: 737,
    107: 857,
    120: 950,
    121: 949,
    122: 936,
    123: 932,
    124: 874,
    125: 1255,
    126: 1256,
    150: 10007,
    151: 10029,
    152: 10006,
    200: 1250,
    201: 1251,
    202: 1254,
    203: 1253,
    /* shapefile DBF extension */
    0: 20127,
    8: 865,
    9: 437,
    10: 850,
    11: 437,
    13: 437,
    14: 850,
    15: 437,
    16: 850,
    17: 437,
    18: 850,
    19: 932,
    20: 850,
    21: 437,
    22: 850,
    23: 865,
    24: 437,
    25: 437,
    26: 850,
    27: 437,
    28: 863,
    29: 850,
    31: 852,
    34: 852,
    35: 852,
    36: 860,
    37: 850,
    38: 866,
    55: 850,
    64: 852,
    77: 936,
    78: 949,
    79: 950,
    80: 874,
    87: 1252,
    88: 1252,
    89: 1252,
    108: 863,
    134: 737,
    135: 852,
    136: 857,
    204: 1257,
    255: 16969
  }, Y = evert({
    1: 437,
    2: 850,
    3: 1252,
    4: 1e4,
    100: 852,
    101: 866,
    102: 865,
    103: 861,
    104: 895,
    105: 620,
    106: 737,
    107: 857,
    120: 950,
    121: 949,
    122: 936,
    123: 932,
    124: 874,
    125: 1255,
    126: 1256,
    150: 10007,
    151: 10029,
    152: 10006,
    200: 1250,
    201: 1251,
    202: 1254,
    203: 1253,
    0: 20127
  });
  function re(_e, ve) {
    var xe = [], Ee = new_raw_buf(1);
    switch (ve.type) {
      case "base64":
        Ee = s2a(Base64_decode(_e));
        break;
      case "binary":
        Ee = s2a(_e);
        break;
      case "buffer":
      case "array":
        Ee = _e;
        break;
    }
    prep_blob(Ee, 0);
    var Se = Ee.read_shift(1), Te = !!(Se & 136), Ce = !1, Ie = !1;
    switch (Se) {
      case 2:
        break;
      // dBASE II
      case 3:
        break;
      // dBASE III
      case 48:
        Ce = !0, Te = !0;
        break;
      // VFP
      case 49:
        Ce = !0, Te = !0;
        break;
      // VFP with autoincrement
      // 0x43 dBASE IV SQL table files
      // 0x63 dBASE IV SQL system files
      case 131:
        break;
      // dBASE III with memo
      case 139:
        break;
      // dBASE IV with memo
      case 140:
        Ie = !0;
        break;
      // dBASE Level 7 with memo
      // case 0xCB dBASE IV SQL table files with memo
      case 245:
        break;
      // FoxPro 2.x with memo
      // case 0xFB FoxBASE
      default:
        throw new Error("DBF Unsupported Version: " + Se.toString(16));
    }
    var Ne = 0, Re = 521;
    Se == 2 && (Ne = Ee.read_shift(2)), Ee.l += 3, Se != 2 && (Ne = Ee.read_shift(4)), Ne > 1048576 && (Ne = 1e6), Se != 2 && (Re = Ee.read_shift(2));
    var Ae = Ee.read_shift(2), Pe = ve.codepage || 1252;
    Se != 2 && (Ee.l += 16, Ee.read_shift(1), Ee[Ee.l] !== 0 && (Pe = le[Ee[Ee.l]]), Ee.l += 1, Ee.l += 2), Ie && (Ee.l += 36);
    for (var Fe = [], Le = {}, He = Math.min(Ee.length, Se == 2 ? 521 : Re - 10 - (Ce ? 264 : 0)), Ge = Ie ? 32 : 11; Ee.l < He && Ee[Ee.l] != 13; )
      switch (Le = {}, Le.name = (typeof $cptable < "u" ? $cptable.utils.decode(Pe, Ee.slice(Ee.l, Ee.l + Ge)) : a2s(Ee.slice(Ee.l, Ee.l + Ge))).replace(/[\u0000\r\n][\S\s]*$/g, ""), Ee.l += Ge, Le.type = String.fromCharCode(Ee.read_shift(1)), Se != 2 && !Ie && (Le.offset = Ee.read_shift(4)), Le.len = Ee.read_shift(1), Se == 2 && (Le.offset = Ee.read_shift(2)), Le.dec = Ee.read_shift(1), Le.name.length && Fe.push(Le), Se != 2 && (Ee.l += Ie ? 13 : 14), Le.type) {
        case "B":
          (!Ce || Le.len != 8) && ve.WTF && console.log("Skipping " + Le.name + ":" + Le.type);
          break;
        case "G":
        // General (FoxPro and dBASE L7)
        case "P":
          ve.WTF && console.log("Skipping " + Le.name + ":" + Le.type);
          break;
        case "+":
        // Autoincrement (dBASE L7 only)
        case "0":
        // _NullFlags (VFP only)
        case "@":
        // Timestamp (dBASE L7 only)
        case "C":
        // Character (dBASE II)
        case "D":
        // Date (dBASE III)
        case "F":
        // Float (dBASE IV)
        case "I":
        // Long (VFP and dBASE L7)
        case "L":
        // Logical (dBASE II)
        case "M":
        // Memo (dBASE III)
        case "N":
        // Number (dBASE II)
        case "O":
        // Double (dBASE L7 only)
        case "T":
        // Datetime (VFP only)
        case "Y":
          break;
        default:
          throw new Error("Unknown Field Type: " + Le.type);
      }
    if (Ee[Ee.l] !== 13 && (Ee.l = Re - 1), Ee.read_shift(1) !== 13) throw new Error("DBF Terminator not found " + Ee.l + " " + Ee[Ee.l]);
    Ee.l = Re;
    var Ve = 0, $e = 0;
    for (xe[0] = [], $e = 0; $e != Fe.length; ++$e) xe[0][$e] = Fe[$e].name;
    for (; Ne-- > 0; ) {
      if (Ee[Ee.l] === 42) {
        Ee.l += Ae;
        continue;
      }
      for (++Ee.l, xe[++Ve] = [], $e = 0, $e = 0; $e != Fe.length; ++$e) {
        var De = Ee.slice(Ee.l, Ee.l + Fe[$e].len);
        Ee.l += Fe[$e].len, prep_blob(De, 0);
        var Ke = typeof $cptable < "u" ? $cptable.utils.decode(Pe, De) : a2s(De);
        switch (Fe[$e].type) {
          case "C":
            Ke.trim().length && (xe[Ve][$e] = Ke.replace(/([^\s])\s+$/, "$1"));
            break;
          case "D":
            Ke.length === 8 ? (xe[Ve][$e] = new Date(Date.UTC(+Ke.slice(0, 4), +Ke.slice(4, 6) - 1, +Ke.slice(6, 8), 0, 0, 0, 0)), ve && ve.UTC || (xe[Ve][$e] = utc_to_local(xe[Ve][$e]))) : xe[Ve][$e] = Ke;
            break;
          case "F":
            xe[Ve][$e] = parseFloat(Ke.trim());
            break;
          case "+":
          case "I":
            xe[Ve][$e] = Ie ? De.read_shift(-4, "i") ^ 2147483648 : De.read_shift(4, "i");
            break;
          case "L":
            switch (Ke.trim().toUpperCase()) {
              case "Y":
              case "T":
                xe[Ve][$e] = !0;
                break;
              case "N":
              case "F":
                xe[Ve][$e] = !1;
                break;
              case "":
              case "\0":
              case "?":
                break;
              default:
                throw new Error("DBF Unrecognized L:|" + Ke + "|");
            }
            break;
          case "M":
            if (!Te) throw new Error("DBF Unexpected MEMO for type " + Se.toString(16));
            xe[Ve][$e] = "##MEMO##" + (Ie ? parseInt(Ke.trim(), 10) : De.read_shift(4));
            break;
          case "N":
            Ke = Ke.replace(/\u0000/g, "").trim(), Ke && Ke != "." && (xe[Ve][$e] = +Ke || 0);
            break;
          case "@":
            xe[Ve][$e] = new Date(De.read_shift(-8, "f") - 621356832e5);
            break;
          case "T":
            {
              var ze = De.read_shift(4), tt = De.read_shift(4);
              if (ze == 0 && tt == 0) break;
              xe[Ve][$e] = new Date((ze - 2440588) * 864e5 + tt), ve && ve.UTC || (xe[Ve][$e] = utc_to_local(xe[Ve][$e]));
            }
            break;
          case "Y":
            xe[Ve][$e] = De.read_shift(4, "i") / 1e4 + De.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
            break;
          case "O":
            xe[Ve][$e] = -De.read_shift(-8, "f");
            break;
          case "B":
            if (Ce && Fe[$e].len == 8) {
              xe[Ve][$e] = De.read_shift(8, "f");
              break;
            }
          /* falls through */
          case "G":
          case "P":
            De.l += Fe[$e].len;
            break;
          case "0":
            if (Fe[$e].name === "_NullFlags") break;
          /* falls through */
          default:
            throw new Error("DBF Unsupported data type " + Fe[$e].type);
        }
      }
    }
    if (Se != 2 && Ee.l < Ee.length && Ee[Ee.l++] != 26) throw new Error("DBF EOF Marker missing " + (Ee.l - 1) + " of " + Ee.length + " " + Ee[Ee.l - 1].toString(16));
    return ve && ve.sheetRows && (xe = xe.slice(0, ve.sheetRows)), ve.DBF = Fe, xe;
  }
  function oe(_e, ve) {
    var xe = ve || {};
    xe.dateNF || (xe.dateNF = "yyyymmdd");
    var Ee = aoa_to_sheet(re(_e, xe), xe);
    return Ee["!cols"] = xe.DBF.map(function(Se) {
      return {
        wch: Se.len,
        DBF: Se
      };
    }), delete xe.DBF, Ee;
  }
  function ue(_e, ve) {
    try {
      var xe = sheet_to_workbook(oe(_e, ve), ve);
      return xe.bookType = "dbf", xe;
    } catch (Ee) {
      if (ve && ve.WTF) throw Ee;
    }
    return { SheetNames: [], Sheets: {} };
  }
  var fe = { B: 8, C: 250, L: 1, D: 8, "?": 0, "": 0 };
  function he(_e, ve) {
    if (!_e["!ref"]) throw new Error("Cannot export empty sheet to DBF");
    var xe = ve || {}, Ee = current_codepage;
    if (+xe.codepage >= 0 && set_cp(+xe.codepage), xe.type == "string") throw new Error("Cannot write DBF to JS string");
    var Se = buf_array(), Te = sheet_to_json(_e, { header: 1, raw: !0, cellDates: !0 }), Ce = Te[0], Ie = Te.slice(1), Ne = _e["!cols"] || [], Re = 0, Ae = 0, Pe = 0, Fe = 1;
    for (Re = 0; Re < Ce.length; ++Re) {
      if (((Ne[Re] || {}).DBF || {}).name) {
        Ce[Re] = Ne[Re].DBF.name, ++Pe;
        continue;
      }
      if (Ce[Re] != null) {
        if (++Pe, typeof Ce[Re] == "number" && (Ce[Re] = Ce[Re].toString(10)), typeof Ce[Re] != "string") throw new Error("DBF Invalid column name " + Ce[Re] + " |" + typeof Ce[Re] + "|");
        if (Ce.indexOf(Ce[Re]) !== Re) {
          for (Ae = 0; Ae < 1024; ++Ae)
            if (Ce.indexOf(Ce[Re] + "_" + Ae) == -1) {
              Ce[Re] += "_" + Ae;
              break;
            }
        }
      }
    }
    var Le = safe_decode_range(_e["!ref"]), He = [], Ge = [], Ve = [];
    for (Re = 0; Re <= Le.e.c - Le.s.c; ++Re) {
      var $e = "", De = "", Ke = 0, ze = [];
      for (Ae = 0; Ae < Ie.length; ++Ae)
        Ie[Ae][Re] != null && ze.push(Ie[Ae][Re]);
      if (ze.length == 0 || Ce[Re] == null) {
        He[Re] = "?";
        continue;
      }
      for (Ae = 0; Ae < ze.length; ++Ae) {
        switch (typeof ze[Ae]) {
          /* TODO: check if L2 compat is desired */
          case "number":
            De = "B";
            break;
          case "string":
            De = "C";
            break;
          case "boolean":
            De = "L";
            break;
          case "object":
            De = ze[Ae] instanceof Date ? "D" : "C";
            break;
          default:
            De = "C";
        }
        Ke = Math.max(Ke, (typeof $cptable < "u" && typeof ze[Ae] == "string" ? $cptable.utils.encode(current_ansi, ze[Ae]) : String(ze[Ae])).length), $e = $e && $e != De ? "C" : De;
      }
      Ke > 250 && (Ke = 250), De = ((Ne[Re] || {}).DBF || {}).type, De == "C" && Ne[Re].DBF.len > Ke && (Ke = Ne[Re].DBF.len), $e == "B" && De == "N" && ($e = "N", Ve[Re] = Ne[Re].DBF.dec, Ke = Ne[Re].DBF.len), Ge[Re] = $e == "C" || De == "N" ? Ke : fe[$e] || 0, Fe += Ge[Re], He[Re] = $e;
    }
    var tt = Se.next(32);
    for (tt.write_shift(4, 318902576), tt.write_shift(4, Ie.length), tt.write_shift(2, 296 + 32 * Pe), tt.write_shift(2, Fe), Re = 0; Re < 4; ++Re) tt.write_shift(4, 0);
    var Xe = +Y[
      /*::String(*/
      current_codepage
      /*::)*/
    ] || 3;
    for (tt.write_shift(4, 0 | Xe << 8), le[Xe] != +xe.codepage && (xe.codepage && console.error("DBF Unsupported codepage " + current_codepage + ", using 1252"), current_codepage = 1252), Re = 0, Ae = 0; Re < Ce.length; ++Re)
      if (Ce[Re] != null) {
        var mt = Se.next(32), at = (Ce[Re].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
        mt.write_shift(1, at, "sbcs"), mt.write_shift(1, He[Re] == "?" ? "C" : He[Re], "sbcs"), mt.write_shift(4, Ae), mt.write_shift(1, Ge[Re] || fe[He[Re]] || 0), mt.write_shift(1, Ve[Re] || 0), mt.write_shift(1, 2), mt.write_shift(4, 0), mt.write_shift(1, 0), mt.write_shift(4, 0), mt.write_shift(4, 0), Ae += Ge[Re] || fe[He[Re]] || 0;
      }
    var qe = Se.next(264);
    for (qe.write_shift(4, 13), Re = 0; Re < 65; ++Re) qe.write_shift(4, 0);
    for (Re = 0; Re < Ie.length; ++Re) {
      var st = Se.next(Fe);
      for (st.write_shift(1, 0), Ae = 0; Ae < Ce.length; ++Ae)
        if (Ce[Ae] != null)
          switch (He[Ae]) {
            case "L":
              st.write_shift(1, Ie[Re][Ae] == null ? 63 : Ie[Re][Ae] ? 84 : 70);
              break;
            case "B":
              st.write_shift(8, Ie[Re][Ae] || 0, "f");
              break;
            case "N":
              var xt = "0";
              for (typeof Ie[Re][Ae] == "number" && (xt = Ie[Re][Ae].toFixed(Ve[Ae] || 0)), xt.length > Ge[Ae] && (xt = xt.slice(0, Ge[Ae])), Pe = 0; Pe < Ge[Ae] - xt.length; ++Pe) st.write_shift(1, 32);
              st.write_shift(1, xt, "sbcs");
              break;
            case "D":
              Ie[Re][Ae] ? (st.write_shift(4, ("0000" + Ie[Re][Ae].getFullYear()).slice(-4), "sbcs"), st.write_shift(2, ("00" + (Ie[Re][Ae].getMonth() + 1)).slice(-2), "sbcs"), st.write_shift(2, ("00" + Ie[Re][Ae].getDate()).slice(-2), "sbcs")) : st.write_shift(8, "00000000", "sbcs");
              break;
            case "C":
              var gt = st.l, Ze = String(Ie[Re][Ae] != null ? Ie[Re][Ae] : "").slice(0, Ge[Ae]);
              for (st.write_shift(1, Ze, "cpstr"), gt += Ge[Ae] - st.l, Pe = 0; Pe < gt; ++Pe) st.write_shift(1, 32);
              break;
          }
    }
    return current_codepage = Ee, Se.next(1).write_shift(1, 26), Se.end();
  }
  return {
    to_workbook: ue,
    to_sheet: oe,
    from_sheet: he
  };
}(), SYLK = /* @__PURE__ */ function() {
  var le = {
    AA: "À",
    BA: "Á",
    CA: "Â",
    DA: 195,
    HA: "Ä",
    JA: 197,
    AE: "È",
    BE: "É",
    CE: "Ê",
    HE: "Ë",
    AI: "Ì",
    BI: "Í",
    CI: "Î",
    HI: "Ï",
    AO: "Ò",
    BO: "Ó",
    CO: "Ô",
    DO: 213,
    HO: "Ö",
    AU: "Ù",
    BU: "Ú",
    CU: "Û",
    HU: "Ü",
    Aa: "à",
    Ba: "á",
    Ca: "â",
    Da: 227,
    Ha: "ä",
    Ja: 229,
    Ae: "è",
    Be: "é",
    Ce: "ê",
    He: "ë",
    Ai: "ì",
    Bi: "í",
    Ci: "î",
    Hi: "ï",
    Ao: "ò",
    Bo: "ó",
    Co: "ô",
    Do: 245,
    Ho: "ö",
    Au: "ù",
    Bu: "ú",
    Cu: "û",
    Hu: "ü",
    KC: "Ç",
    Kc: "ç",
    q: "æ",
    z: "œ",
    a: "Æ",
    j: "Œ",
    DN: 209,
    Dn: 241,
    Hy: 255,
    S: 169,
    c: 170,
    R: 174,
    "B ": 180,
    0: 176,
    1: 177,
    2: 178,
    3: 179,
    5: 181,
    6: 182,
    7: 183,
    Q: 185,
    k: 186,
    b: 208,
    i: 216,
    l: 222,
    s: 240,
    y: 248,
    "!": 161,
    '"': 162,
    "#": 163,
    "(": 164,
    "%": 165,
    "'": 167,
    "H ": 168,
    "+": 171,
    ";": 187,
    "<": 188,
    "=": 189,
    ">": 190,
    "?": 191,
    "{": 223
  }, Y = new RegExp("\x1BN(" + keys(le).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1").replace("{", "\\{") + "|\\|)", "gm");
  try {
    Y = new RegExp("\x1BN(" + keys(le).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm");
  } catch {
  }
  var re = function(Ce, Ie) {
    var Ne = le[Ie];
    return typeof Ne == "number" ? _getansi(Ne) : Ne;
  }, oe = function(Ce, Ie, Ne) {
    var Re = Ie.charCodeAt(0) - 32 << 4 | Ne.charCodeAt(0) - 48;
    return Re == 59 ? Ce : _getansi(Re);
  };
  le["|"] = 254;
  var ue = function(Ce) {
    return Ce.replace(/\n/g, "\x1B :").replace(/\r/g, "\x1B =");
  };
  function fe(Ce, Ie) {
    switch (Ie.type) {
      case "base64":
        return he(Base64_decode(Ce), Ie);
      case "binary":
        return he(Ce, Ie);
      case "buffer":
        return he(has_buf && Buffer.isBuffer(Ce) ? Ce.toString("binary") : a2s(Ce), Ie);
      case "array":
        return he(cc2str(Ce), Ie);
    }
    throw new Error("Unrecognized type " + Ie.type);
  }
  function he(Ce, Ie) {
    var Ne = Ce.split(/[\n\r]+/), Re = -1, Ae = -1, Pe = 0, Fe = 0, Le = [], He = [], Ge = null, Ve = {}, $e = [], De = [], Ke = [], ze = 0, tt, Xe = { Workbook: { WBProps: {}, Names: [] } };
    for (+Ie.codepage >= 0 && set_cp(+Ie.codepage); Pe !== Ne.length; ++Pe) {
      ze = 0;
      var mt = Ne[Pe].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, oe).replace(Y, re), at = mt.replace(/;;/g, "\0").split(";").map(function(it) {
        return it.replace(/\u0000/g, ";");
      }), qe = at[0], st;
      if (mt.length > 0) switch (qe) {
        case "ID":
          break;
        /* header */
        case "E":
          break;
        /* EOF */
        case "B":
          break;
        /* dimensions */
        case "O":
          for (Fe = 1; Fe < at.length; ++Fe) switch (at[Fe].charAt(0)) {
            case "V":
              {
                var xt = parseInt(at[Fe].slice(1), 10);
                xt >= 1 && xt <= 4 && (Xe.Workbook.WBProps.date1904 = !0);
              }
              break;
          }
          break;
        case "W":
          break;
        /* window */
        case "P":
          switch (at[1].charAt(0)) {
            case "P":
              He.push(mt.slice(3).replace(/;;/g, ";"));
              break;
          }
          break;
        case "NN":
          {
            var gt = { Sheet: 0 };
            for (Fe = 1; Fe < at.length; ++Fe) switch (at[Fe].charAt(0)) {
              case "N":
                gt.Name = at[Fe].slice(1);
                break;
              case "E":
                gt.Ref = (Ie && Ie.sheet || "Sheet1") + "!" + rc_to_a1(at[Fe].slice(1));
                break;
            }
            Xe.Workbook.Names.push(gt);
          }
          break;
        // case 'NE': // ??
        // case 'NU': // ??
        case "C":
          var Ze = !1, _t = !1, wt = !1, yt = !1, St = -1, It = -1, Bt = "", Ye = "z", Be = "";
          for (Fe = 1; Fe < at.length; ++Fe) switch (at[Fe].charAt(0)) {
            case "A":
              Be = at[Fe].slice(1);
              break;
            // TODO: comment
            case "X":
              Ae = parseInt(at[Fe].slice(1), 10) - 1, _t = !0;
              break;
            case "Y":
              for (Re = parseInt(at[Fe].slice(1), 10) - 1, _t || (Ae = 0), tt = Le.length; tt <= Re; ++tt) Le[tt] = [];
              break;
            case "K":
              st = at[Fe].slice(1), st.charAt(0) === '"' ? (st = st.slice(1, st.length - 1), Ye = "s") : st === "TRUE" || st === "FALSE" ? (st = st === "TRUE", Ye = "b") : st.charAt(0) == "#" && RBErr[st] != null ? (Ye = "e", st = RBErr[st]) : isNaN(fuzzynum(st)) || (st = fuzzynum(st), Ye = "n", Ge !== null && fmt_is_date(Ge) && Ie.cellDates && (st = numdate(Xe.Workbook.WBProps.date1904 ? st + 1462 : st), Ye = typeof st == "number" ? "n" : "d")), typeof $cptable < "u" && typeof st == "string" && (Ie || {}).type != "string" && (Ie || {}).codepage && (st = $cptable.utils.decode(Ie.codepage, st)), Ze = !0;
              break;
            case "E":
              yt = !0, Bt = rc_to_a1(at[Fe].slice(1), { r: Re, c: Ae });
              break;
            case "S":
              wt = !0;
              break;
            case "G":
              break;
            // unknown
            case "R":
              St = parseInt(at[Fe].slice(1), 10) - 1;
              break;
            case "C":
              It = parseInt(at[Fe].slice(1), 10) - 1;
              break;
            // case 'P': // ??
            // case 'D': // ??
            default:
              if (Ie && Ie.WTF) throw new Error("SYLK bad record " + mt);
          }
          if (Ze && (Le[Re][Ae] ? (Le[Re][Ae].t = Ye, Le[Re][Ae].v = st) : Le[Re][Ae] = { t: Ye, v: st }, Ge && (Le[Re][Ae].z = Ge), Ie.cellText !== !1 && Ge && (Le[Re][Ae].w = SSF_format(Le[Re][Ae].z, Le[Re][Ae].v, { date1904: Xe.Workbook.WBProps.date1904 })), Ge = null), wt) {
            if (yt) throw new Error("SYLK shared formula cannot have own formula");
            var et = St > -1 && Le[St][It];
            if (!et || !et[1]) throw new Error("SYLK shared formula cannot find base");
            Bt = shift_formula_str(et[1], { r: Re - St, c: Ae - It });
          }
          Bt && (Le[Re][Ae] ? Le[Re][Ae].f = Bt : Le[Re][Ae] = { t: "n", f: Bt }), Be && (Le[Re][Ae] || (Le[Re][Ae] = { t: "z" }), Le[Re][Ae].c = [{ a: "SheetJSYLK", t: Be }]);
          break;
        case "F":
          var je = 0;
          for (Fe = 1; Fe < at.length; ++Fe) switch (at[Fe].charAt(0)) {
            case "X":
              Ae = parseInt(at[Fe].slice(1), 10) - 1, ++je;
              break;
            case "Y":
              for (Re = parseInt(at[Fe].slice(1), 10) - 1, tt = Le.length; tt <= Re; ++tt) Le[tt] = [];
              break;
            case "M":
              ze = parseInt(at[Fe].slice(1), 10) / 20;
              break;
            case "F":
              break;
            /* ??? */
            case "G":
              break;
            /* hide grid */
            case "P":
              Ge = He[parseInt(at[Fe].slice(1), 10)];
              break;
            case "S":
              break;
            /* cell style */
            case "D":
              break;
            /* column */
            case "N":
              break;
            /* font */
            case "W":
              for (Ke = at[Fe].slice(1).split(" "), tt = parseInt(Ke[0], 10); tt <= parseInt(Ke[1], 10); ++tt)
                ze = parseInt(Ke[2], 10), De[tt - 1] = ze === 0 ? { hidden: !0 } : { wch: ze };
              break;
            case "C":
              Ae = parseInt(at[Fe].slice(1), 10) - 1, De[Ae] || (De[Ae] = {});
              break;
            case "R":
              Re = parseInt(at[Fe].slice(1), 10) - 1, $e[Re] || ($e[Re] = {}), ze > 0 ? ($e[Re].hpt = ze, $e[Re].hpx = pt2px(ze)) : ze === 0 && ($e[Re].hidden = !0);
              break;
            // case 'K': // ??
            // case 'E': // ??
            default:
              if (Ie && Ie.WTF) throw new Error("SYLK bad record " + mt);
          }
          je < 1 && (Ge = null);
          break;
        default:
          if (Ie && Ie.WTF) throw new Error("SYLK bad record " + mt);
      }
    }
    return $e.length > 0 && (Ve["!rows"] = $e), De.length > 0 && (Ve["!cols"] = De), De.forEach(function(it) {
      process_col(it);
    }), Ie && Ie.sheetRows && (Le = Le.slice(0, Ie.sheetRows)), [Le, Ve, Xe];
  }
  function _e(Ce, Ie) {
    var Ne = fe(Ce, Ie), Re = Ne[0], Ae = Ne[1], Pe = Ne[2], Fe = dup(Ie);
    Fe.date1904 = (((Pe || {}).Workbook || {}).WBProps || {}).date1904;
    var Le = aoa_to_sheet(Re, Fe);
    keys(Ae).forEach(function(Ge) {
      Le[Ge] = Ae[Ge];
    });
    var He = sheet_to_workbook(Le, Ie);
    return keys(Pe).forEach(function(Ge) {
      He[Ge] = Pe[Ge];
    }), He.bookType = "sylk", He;
  }
  function ve(Ce, Ie, Ne, Re, Ae, Pe) {
    var Fe = "C;Y" + (Ne + 1) + ";X" + (Re + 1) + ";K";
    switch (Ce.t) {
      case "n":
        Fe += isFinite(Ce.v) ? Ce.v || 0 : BErr[isNaN(Ce.v) ? 36 : 7], Ce.f && !Ce.F && (Fe += ";E" + a1_to_rc(Ce.f, { r: Ne, c: Re }));
        break;
      case "b":
        Fe += Ce.v ? "TRUE" : "FALSE";
        break;
      case "e":
        Fe += Ce.w || BErr[Ce.v] || Ce.v;
        break;
      case "d":
        Fe += datenum(parseDate(Ce.v, Pe), Pe);
        break;
      case "s":
        Fe += '"' + (Ce.v == null ? "" : String(Ce.v)).replace(/"/g, "").replace(/;/g, ";;") + '"';
        break;
    }
    return Fe;
  }
  function xe(Ce, Ie, Ne) {
    var Re = "C;Y" + (Ie + 1) + ";X" + (Ne + 1) + ";A";
    return Re += ue(Ce.map(function(Ae) {
      return Ae.t;
    }).join("")), Re;
  }
  function Ee(Ce, Ie) {
    Ie.forEach(function(Ne, Re) {
      var Ae = "F;W" + (Re + 1) + " " + (Re + 1) + " ";
      Ne.hidden ? Ae += "0" : (typeof Ne.width == "number" && !Ne.wpx && (Ne.wpx = width2px(Ne.width)), typeof Ne.wpx == "number" && !Ne.wch && (Ne.wch = px2char(Ne.wpx)), typeof Ne.wch == "number" && (Ae += Math.round(Ne.wch))), Ae.charAt(Ae.length - 1) != " " && Ce.push(Ae);
    });
  }
  function Se(Ce, Ie) {
    Ie.forEach(function(Ne, Re) {
      var Ae = "F;";
      Ne.hidden ? Ae += "M0;" : Ne.hpt ? Ae += "M" + 20 * Ne.hpt + ";" : Ne.hpx && (Ae += "M" + 20 * px2pt(Ne.hpx) + ";"), Ae.length > 2 && Ce.push(Ae + "R" + (Re + 1));
    });
  }
  function Te(Ce, Ie, Ne) {
    Ie || (Ie = {}), Ie._formats = ["General"];
    var Re = ["ID;PSheetJS;N;E"], Ae = [], Pe = safe_decode_range(Ce["!ref"] || "A1"), Fe, Le = Ce["!data"] != null, He = `\r
`, Ge = (((Ne || {}).Workbook || {}).WBProps || {}).date1904, Ve = "General";
    Re.push("P;PGeneral");
    var $e = Pe.s.r, De = Pe.s.c, Ke = [];
    if (Ce["!ref"]) {
      for ($e = Pe.s.r; $e <= Pe.e.r; ++$e)
        if (!(Le && !Ce["!data"][$e])) {
          for (Ke = [], De = Pe.s.c; De <= Pe.e.c; ++De)
            Fe = Le ? Ce["!data"][$e][De] : Ce[encode_col(De) + encode_row($e)], !(!Fe || !Fe.c) && Ke.push(xe(Fe.c, $e, De));
          Ke.length && Ae.push(Ke.join(He));
        }
    }
    if (Ce["!ref"]) {
      for ($e = Pe.s.r; $e <= Pe.e.r; ++$e)
        if (!(Le && !Ce["!data"][$e])) {
          for (Ke = [], De = Pe.s.c; De <= Pe.e.c; ++De)
            if (Fe = Le ? Ce["!data"][$e][De] : Ce[encode_col(De) + encode_row($e)], !(!Fe || Fe.v == null && (!Fe.f || Fe.F))) {
              if ((Fe.z || (Fe.t == "d" ? table_fmt[14] : "General")) != Ve) {
                var ze = Ie._formats.indexOf(Fe.z);
                ze == -1 && (Ie._formats.push(Fe.z), ze = Ie._formats.length - 1, Re.push("P;P" + Fe.z.replace(/;/g, ";;"))), Ke.push("F;P" + ze + ";Y" + ($e + 1) + ";X" + (De + 1));
              }
              Ke.push(ve(Fe, Ce, $e, De, Ie, Ge));
            }
          Ae.push(Ke.join(He));
        }
    }
    return Re.push("F;P0;DG0G8;M255"), Ce["!cols"] && Ee(Re, Ce["!cols"]), Ce["!rows"] && Se(Re, Ce["!rows"]), Ce["!ref"] && Re.push("B;Y" + (Pe.e.r - Pe.s.r + 1) + ";X" + (Pe.e.c - Pe.s.c + 1) + ";D" + [Pe.s.c, Pe.s.r, Pe.e.c, Pe.e.r].join(" ")), Re.push("O;L;D;B" + (Ge ? ";V4" : "") + ";K47;G100 0.001"), delete Ie._formats, Re.join(He) + He + Ae.join(He) + He + "E" + He;
  }
  return {
    to_workbook: _e,
    from_sheet: Te
  };
}(), DIF = /* @__PURE__ */ function() {
  function le(_e, ve) {
    switch (ve.type) {
      case "base64":
        return Y(Base64_decode(_e), ve);
      case "binary":
        return Y(_e, ve);
      case "buffer":
        return Y(has_buf && Buffer.isBuffer(_e) ? _e.toString("binary") : a2s(_e), ve);
      case "array":
        return Y(cc2str(_e), ve);
    }
    throw new Error("Unrecognized type " + ve.type);
  }
  function Y(_e, ve) {
    for (var xe = _e.split(`
`), Ee = -1, Se = -1, Te = 0, Ce = []; Te !== xe.length; ++Te) {
      if (xe[Te].trim() === "BOT") {
        Ce[++Ee] = [], Se = 0;
        continue;
      }
      if (!(Ee < 0)) {
        var Ie = xe[Te].trim().split(","), Ne = Ie[0], Re = Ie[1];
        ++Te;
        for (var Ae = xe[Te] || ""; (Ae.match(/["]/g) || []).length & 1 && Te < xe.length - 1; ) Ae += `
` + xe[++Te];
        switch (Ae = Ae.trim(), +Ne) {
          case -1:
            if (Ae === "BOT") {
              Ce[++Ee] = [], Se = 0;
              continue;
            } else if (Ae !== "EOD") throw new Error("Unrecognized DIF special command " + Ae);
            break;
          case 0:
            Ae === "TRUE" ? Ce[Ee][Se] = !0 : Ae === "FALSE" ? Ce[Ee][Se] = !1 : isNaN(fuzzynum(Re)) ? isNaN(fuzzydate(Re).getDate()) ? Ce[Ee][Se] = Re : (Ce[Ee][Se] = parseDate(Re), ve && ve.UTC || (Ce[Ee][Se] = utc_to_local(Ce[Ee][Se]))) : Ce[Ee][Se] = fuzzynum(Re), ++Se;
            break;
          case 1:
            Ae = Ae.slice(1, Ae.length - 1), Ae = Ae.replace(/""/g, '"'), Ae && Ae.match(/^=".*"$/) && (Ae = Ae.slice(2, -1)), Ce[Ee][Se++] = Ae !== "" ? Ae : null;
            break;
        }
        if (Ae === "EOD") break;
      }
    }
    return ve && ve.sheetRows && (Ce = Ce.slice(0, ve.sheetRows)), Ce;
  }
  function re(_e, ve) {
    return aoa_to_sheet(le(_e, ve), ve);
  }
  function oe(_e, ve) {
    var xe = sheet_to_workbook(re(_e, ve), ve);
    return xe.bookType = "dif", xe;
  }
  function ue(_e, ve) {
    return "0," + String(_e) + `\r
` + ve;
  }
  function fe(_e) {
    return `1,0\r
"` + _e.replace(/"/g, '""') + '"';
  }
  function he(_e) {
    if (!_e["!ref"]) throw new Error("Cannot export empty sheet to DIF");
    for (var ve = safe_decode_range(_e["!ref"]), xe = _e["!data"] != null, Ee = [
      `TABLE\r
0,1\r
"sheetjs"\r
`,
      `VECTORS\r
0,` + (ve.e.r - ve.s.r + 1) + `\r
""\r
`,
      `TUPLES\r
0,` + (ve.e.c - ve.s.c + 1) + `\r
""\r
`,
      `DATA\r
0,0\r
""\r
`
    ], Se = ve.s.r; Se <= ve.e.r; ++Se) {
      for (var Te = xe ? _e["!data"][Se] : [], Ce = `-1,0\r
BOT\r
`, Ie = ve.s.c; Ie <= ve.e.c; ++Ie) {
        var Ne = xe ? Te && Te[Ie] : _e[encode_cell({ r: Se, c: Ie })];
        if (Ne == null) {
          Ce += `1,0\r
""\r
`;
          continue;
        }
        switch (Ne.t) {
          case "n":
            Ne.w != null ? Ce += "0," + Ne.w + `\r
V` : Ne.v != null ? Ce += ue(Ne.v, "V") : Ne.f != null && !Ne.F ? Ce += fe("=" + Ne.f) : Ce += `1,0\r
""`;
            break;
          case "b":
            Ce += Ne.v ? ue(1, "TRUE") : ue(0, "FALSE");
            break;
          case "s":
            Ce += fe(isNaN(+Ne.v) ? Ne.v : '="' + Ne.v + '"');
            break;
          case "d":
            Ne.w || (Ne.w = SSF_format(Ne.z || table_fmt[14], datenum(parseDate(Ne.v)))), Ce += ue(Ne.w, "V");
            break;
          default:
            Ce += `1,0\r
""`;
        }
        Ce += `\r
`;
      }
      Ee.push(Ce);
    }
    return Ee.join("") + `-1,0\r
EOD`;
  }
  return {
    to_workbook: oe,
    to_sheet: re,
    from_sheet: he
  };
}(), ETH = /* @__PURE__ */ function() {
  function le(Se) {
    return Se.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, `
`);
  }
  function Y(Se) {
    return Se.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
  }
  function re(Se, Te) {
    for (var Ce = Se.split(`
`), Ie = -1, Ne = -1, Re = 0, Ae = []; Re !== Ce.length; ++Re) {
      var Pe = Ce[Re].trim().split(":");
      if (Pe[0] === "cell") {
        var Fe = decode_cell(Pe[1]);
        if (Ae.length <= Fe.r) for (Ie = Ae.length; Ie <= Fe.r; ++Ie) Ae[Ie] || (Ae[Ie] = []);
        switch (Ie = Fe.r, Ne = Fe.c, Pe[2]) {
          case "t":
            Ae[Ie][Ne] = le(Pe[3]);
            break;
          case "v":
            Ae[Ie][Ne] = +Pe[3];
            break;
          case "vtf":
            var Le = Pe[Pe.length - 1];
          /* falls through */
          case "vtc":
            switch (Pe[3]) {
              case "nl":
                Ae[Ie][Ne] = !!+Pe[4];
                break;
              default:
                Ae[Ie][Ne] = Pe[Pe.length - 1].charAt(0) == "#" ? { t: "e", v: RBErr[Pe[Pe.length - 1]] } : +Pe[4];
                break;
            }
            Pe[2] == "vtf" && (Ae[Ie][Ne] = [Ae[Ie][Ne], Le]);
        }
      }
    }
    return Te && Te.sheetRows && (Ae = Ae.slice(0, Te.sheetRows)), Ae;
  }
  function oe(Se, Te) {
    return aoa_to_sheet(re(Se, Te), Te);
  }
  function ue(Se, Te) {
    return sheet_to_workbook(oe(Se, Te), Te);
  }
  var fe = [
    "socialcalc:version:1.5",
    "MIME-Version: 1.0",
    "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
  ].join(`
`), he = [
    "--SocialCalcSpreadsheetControlSave",
    "Content-type: text/plain; charset=UTF-8"
  ].join(`
`) + `
`, _e = [
    "# SocialCalc Spreadsheet Control Save",
    "part:sheet"
  ].join(`
`), ve = "--SocialCalcSpreadsheetControlSave--";
  function xe(Se) {
    if (!Se || !Se["!ref"]) return "";
    for (var Te = [], Ce = [], Ie, Ne = "", Re = decode_range(Se["!ref"]), Ae = Se["!data"] != null, Pe = Re.s.r; Pe <= Re.e.r; ++Pe)
      for (var Fe = Re.s.c; Fe <= Re.e.c; ++Fe)
        if (Ne = encode_cell({ r: Pe, c: Fe }), Ie = Ae ? (Se["!data"][Pe] || [])[Fe] : Se[Ne], !(!Ie || Ie.v == null || Ie.t === "z")) {
          switch (Ce = ["cell", Ne, "t"], Ie.t) {
            case "s":
              Ce.push(Y(Ie.v));
              break;
            case "b":
              Ce[2] = "vt" + (Ie.f ? "f" : "c"), Ce[3] = "nl", Ce[4] = Ie.v ? "1" : "0", Ce[5] = Y(Ie.f || (Ie.v ? "TRUE" : "FALSE"));
              break;
            case "d":
              var Le = datenum(parseDate(Ie.v));
              Ce[2] = "vtc", Ce[3] = "nd", Ce[4] = "" + Le, Ce[5] = Ie.w || SSF_format(Ie.z || table_fmt[14], Le);
              break;
            case "n":
              isFinite(Ie.v) ? Ie.f ? (Ce[2] = "vtf", Ce[3] = "n", Ce[4] = Ie.v, Ce[5] = Y(Ie.f)) : (Ce[2] = "v", Ce[3] = Ie.v) : (Ce[2] = "vt" + (Ie.f ? "f" : "c"), Ce[3] = "e" + BErr[isNaN(Ie.v) ? 36 : 7], Ce[4] = "0", Ce[5] = Ie.f || Ce[3].slice(1), Ce[6] = "e", Ce[7] = Ce[3].slice(1));
              break;
            case "e":
              continue;
          }
          Te.push(Ce.join(":"));
        }
    return Te.push("sheet:c:" + (Re.e.c - Re.s.c + 1) + ":r:" + (Re.e.r - Re.s.r + 1) + ":tvf:1"), Te.push("valueformat:1:text-wiki"), Te.join(`
`);
  }
  function Ee(Se) {
    return [fe, he, _e, he, xe(Se), ve].join(`
`);
  }
  return {
    to_workbook: ue,
    to_sheet: oe,
    from_sheet: Ee
  };
}(), PRN = /* @__PURE__ */ function() {
  function le(Ee, Se, Te, Ce, Ie) {
    Ie.raw ? Se[Te][Ce] = Ee : Ee === "" || (Ee === "TRUE" ? Se[Te][Ce] = !0 : Ee === "FALSE" ? Se[Te][Ce] = !1 : isNaN(fuzzynum(Ee)) ? isNaN(fuzzydate(Ee).getDate()) ? Ee.charCodeAt(0) == 35 && RBErr[Ee] != null ? Se[Te][Ce] = { t: "e", v: RBErr[Ee], w: Ee } : Se[Te][Ce] = Ee : Se[Te][Ce] = parseDate(Ee) : Se[Te][Ce] = fuzzynum(Ee));
  }
  function Y(Ee, Se) {
    var Te = Se || {}, Ce = [];
    if (!Ee || Ee.length === 0) return Ce;
    for (var Ie = Ee.split(/[\r\n]/), Ne = Ie.length - 1; Ne >= 0 && Ie[Ne].length === 0; ) --Ne;
    for (var Re = 10, Ae = 0, Pe = 0; Pe <= Ne; ++Pe)
      Ae = Ie[Pe].indexOf(" "), Ae == -1 ? Ae = Ie[Pe].length : Ae++, Re = Math.max(Re, Ae);
    for (Pe = 0; Pe <= Ne; ++Pe) {
      Ce[Pe] = [];
      var Fe = 0;
      for (le(Ie[Pe].slice(0, Re).trim(), Ce, Pe, Fe, Te), Fe = 1; Fe <= (Ie[Pe].length - Re) / 10 + 1; ++Fe)
        le(Ie[Pe].slice(Re + (Fe - 1) * 10, Re + Fe * 10).trim(), Ce, Pe, Fe, Te);
    }
    return Te.sheetRows && (Ce = Ce.slice(0, Te.sheetRows)), Ce;
  }
  var re = {
    44: ",",
    9: "	",
    59: ";",
    124: "|"
  }, oe = {
    44: 3,
    9: 2,
    59: 1,
    124: 0
  };
  function ue(Ee) {
    for (var Se = {}, Te = !1, Ce = 0, Ie = 0; Ce < Ee.length; ++Ce)
      (Ie = Ee.charCodeAt(Ce)) == 34 ? Te = !Te : !Te && Ie in re && (Se[Ie] = (Se[Ie] || 0) + 1);
    Ie = [];
    for (Ce in Se) Object.prototype.hasOwnProperty.call(Se, Ce) && Ie.push([Se[Ce], Ce]);
    if (!Ie.length) {
      Se = oe;
      for (Ce in Se) Object.prototype.hasOwnProperty.call(Se, Ce) && Ie.push([Se[Ce], Ce]);
    }
    return Ie.sort(function(Ne, Re) {
      return Ne[0] - Re[0] || oe[Ne[1]] - oe[Re[1]];
    }), re[Ie.pop()[1]] || 44;
  }
  function fe(Ee, Se) {
    var Te = Se || {}, Ce = "", Ie = {};
    Te.dense && (Ie["!data"] = []);
    var Ne = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    Ee.slice(0, 4) == "sep=" ? Ee.charCodeAt(5) == 13 && Ee.charCodeAt(6) == 10 ? (Ce = Ee.charAt(4), Ee = Ee.slice(7)) : Ee.charCodeAt(5) == 13 || Ee.charCodeAt(5) == 10 ? (Ce = Ee.charAt(4), Ee = Ee.slice(6)) : Ce = ue(Ee.slice(0, 1024)) : Te && Te.FS ? Ce = Te.FS : Ce = ue(Ee.slice(0, 1024));
    var Re = 0, Ae = 0, Pe = 0, Fe = 0, Le = 0, He = Ce.charCodeAt(0), Ge = !1, Ve = 0, $e = Ee.charCodeAt(0), De = Te.dateNF != null ? dateNF_regex(Te.dateNF) : null;
    function Ke() {
      var ze = Ee.slice(Fe, Le);
      ze.slice(-1) == "\r" && (ze = ze.slice(0, -1));
      var tt = {};
      if (ze.charAt(0) == '"' && ze.charAt(ze.length - 1) == '"' && (ze = ze.slice(1, -1).replace(/""/g, '"')), Te.cellText !== !1 && (tt.w = ze), ze.length === 0) tt.t = "z";
      else if (Te.raw)
        tt.t = "s", tt.v = ze;
      else if (ze.trim().length === 0)
        tt.t = "s", tt.v = ze;
      else if (ze.charCodeAt(0) == 61)
        ze.charCodeAt(1) == 34 && ze.charCodeAt(ze.length - 1) == 34 ? (tt.t = "s", tt.v = ze.slice(2, -1).replace(/""/g, '"')) : fuzzyfmla(ze) ? (tt.t = "s", tt.f = ze.slice(1), tt.v = ze) : (tt.t = "s", tt.v = ze);
      else if (ze == "TRUE")
        tt.t = "b", tt.v = !0;
      else if (ze == "FALSE")
        tt.t = "b", tt.v = !1;
      else if (!isNaN(Pe = fuzzynum(ze)))
        tt.t = "n", tt.v = Pe;
      else if (!isNaN((Pe = fuzzydate(ze)).getDate()) || De && ze.match(De)) {
        if (tt.z = Te.dateNF || table_fmt[14], De && ze.match(De)) {
          var Xe = dateNF_fix(ze, Te.dateNF, ze.match(De) || []);
          Pe = parseDate(Xe), Te && Te.UTC === !1 && (Pe = utc_to_local(Pe));
        } else Te && Te.UTC === !1 ? Pe = utc_to_local(Pe) : Te.cellText !== !1 && Te.dateNF && (tt.w = SSF_format(tt.z, Pe));
        Te.cellDates ? (tt.t = "d", tt.v = Pe) : (tt.t = "n", tt.v = datenum(Pe)), Te.cellNF || delete tt.z;
      } else ze.charCodeAt(0) == 35 && RBErr[ze] != null ? (tt.t = "e", tt.w = ze, tt.v = RBErr[ze]) : (tt.t = "s", tt.v = ze);
      if (tt.t == "z" || (Te.dense ? (Ie["!data"][Re] || (Ie["!data"][Re] = []), Ie["!data"][Re][Ae] = tt) : Ie[encode_cell({ c: Ae, r: Re })] = tt), Fe = Le + 1, $e = Ee.charCodeAt(Fe), Ne.e.c < Ae && (Ne.e.c = Ae), Ne.e.r < Re && (Ne.e.r = Re), Ve == He) ++Ae;
      else if (Ae = 0, ++Re, Te.sheetRows && Te.sheetRows <= Re) return !0;
    }
    e: for (; Le < Ee.length; ++Le) switch (Ve = Ee.charCodeAt(Le)) {
      case 34:
        $e === 34 && (Ge = !Ge);
        break;
      case 13:
        if (Ge) break;
        Ee.charCodeAt(Le + 1) == 10 && ++Le;
      /* falls through */
      case He:
      case 10:
        if (!Ge && Ke()) break e;
        break;
    }
    return Le - Fe > 0 && Ke(), Ie["!ref"] = encode_range(Ne), Ie;
  }
  function he(Ee, Se) {
    return !(Se && Se.PRN) || Se.FS || Ee.slice(0, 4) == "sep=" || Ee.indexOf("	") >= 0 || Ee.indexOf(",") >= 0 || Ee.indexOf(";") >= 0 ? fe(Ee, Se) : aoa_to_sheet(Y(Ee, Se), Se);
  }
  function _e(Ee, Se) {
    var Te = "", Ce = Se.type == "string" ? [0, 0, 0, 0] : firstbyte(Ee, Se);
    switch (Se.type) {
      case "base64":
        Te = Base64_decode(Ee);
        break;
      case "binary":
        Te = Ee;
        break;
      case "buffer":
        Se.codepage == 65001 ? Te = Ee.toString("utf8") : Se.codepage && typeof $cptable < "u" ? Te = $cptable.utils.decode(Se.codepage, Ee) : Te = has_buf && Buffer.isBuffer(Ee) ? Ee.toString("binary") : a2s(Ee);
        break;
      case "array":
        Te = cc2str(Ee);
        break;
      case "string":
        Te = Ee;
        break;
      default:
        throw new Error("Unrecognized type " + Se.type);
    }
    return Ce[0] == 239 && Ce[1] == 187 && Ce[2] == 191 ? Te = utf8read(Te.slice(3)) : Se.type != "string" && Se.type != "buffer" && Se.codepage == 65001 ? Te = utf8read(Te) : Se.type == "binary" && typeof $cptable < "u" && Se.codepage && (Te = $cptable.utils.decode(Se.codepage, $cptable.utils.encode(28591, Te))), Te.slice(0, 19) == "socialcalc:version:" ? ETH.to_sheet(Se.type == "string" ? Te : utf8read(Te), Se) : he(Te, Se);
  }
  function ve(Ee, Se) {
    return sheet_to_workbook(_e(Ee, Se), Se);
  }
  function xe(Ee) {
    var Se = [];
    if (!Ee["!ref"]) return "";
    for (var Te = safe_decode_range(Ee["!ref"]), Ce, Ie = Ee["!data"] != null, Ne = Te.s.r; Ne <= Te.e.r; ++Ne) {
      for (var Re = [], Ae = Te.s.c; Ae <= Te.e.c; ++Ae) {
        var Pe = encode_cell({ r: Ne, c: Ae });
        if (Ce = Ie ? (Ee["!data"][Ne] || [])[Ae] : Ee[Pe], !Ce || Ce.v == null) {
          Re.push("          ");
          continue;
        }
        for (var Fe = (Ce.w || (format_cell(Ce), Ce.w) || "").slice(0, 10); Fe.length < 10; ) Fe += " ";
        Re.push(Fe + (Ae === 0 ? " " : ""));
      }
      Se.push(Re.join(""));
    }
    return Se.join(`
`);
  }
  return {
    to_workbook: ve,
    to_sheet: _e,
    from_sheet: xe
  };
}();
function read_wb_ID(le, Y) {
  var re = Y || {}, oe = !!re.WTF;
  re.WTF = !0;
  try {
    var ue = SYLK.to_workbook(le, re);
    return re.WTF = oe, ue;
  } catch (fe) {
    if (re.WTF = oe, fe.message.indexOf("SYLK bad record ID") == -1 && oe) throw fe;
    return PRN.to_workbook(le, Y);
  }
}
var WK_ = /* @__PURE__ */ function() {
  function le(Be, et, je) {
    if (Be) {
      prep_blob(Be, Be.l || 0);
      for (var it = je.Enum || yt; Be.l < Be.length; ) {
        var bt = Be.read_shift(2), rt = it[bt] || it[65535], Ct = Be.read_shift(2), Rt = Be.l + Ct, Ot = rt.f && rt.f(Be, Ct, je);
        if (Be.l = Rt, et(Ot, rt, bt)) return;
      }
    }
  }
  function Y(Be, et) {
    switch (et.type) {
      case "base64":
        return oe(s2a(Base64_decode(Be)), et);
      case "binary":
        return oe(s2a(Be), et);
      case "buffer":
      case "array":
        return oe(Be, et);
    }
    throw "Unsupported type " + et.type;
  }
  var re = [
    "mmmm",
    "dd-mmm-yyyy",
    "dd-mmm",
    "mmm-yyyy",
    "@",
    // "text"?
    "mm/dd",
    "hh:mm:ss AM/PM",
    // 7
    "hh:mm AM/PM",
    "mm/dd/yyyy",
    "mm/dd",
    "hh:mm:ss",
    "hh:mm"
    // 12
  ];
  function oe(Be, et) {
    if (!Be) return Be;
    var je = et || {}, it = {}, bt = "Sheet1", rt = "", Ct = 0, Rt = {}, Ot = [], Mt = [], Dt = [];
    je.dense && (Dt = it["!data"] = []);
    var Vt = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, Jt = je.sheetRows || 0, er = {};
    if (Be[4] == 81 && Be[5] == 80 && Be[6] == 87) return Ye(Be, et);
    if (Be[2] == 0 && (Be[3] == 8 || Be[3] == 9) && Be.length >= 16 && Be[14] == 5 && Be[15] === 108)
      throw new Error("Unsupported Works 3 for Mac file");
    if (Be[2] == 2)
      je.Enum = yt, le(Be, function($t, ir, Je) {
        switch (Je) {
          case 0:
            je.vers = $t, $t >= 4096 && (je.qpro = !0);
            break;
          case 255:
            je.vers = $t, je.works = !0;
            break;
          case 6:
            Vt = $t;
            break;
          /* RANGE */
          case 204:
            $t && (rt = $t);
            break;
          /* SHEETNAMECS */
          case 222:
            rt = $t;
            break;
          /* SHEETNAMELP */
          case 15:
          /* LABEL */
          case 51:
            (!je.qpro && !je.works || Je == 51) && $t[1].v.charCodeAt(0) < 48 && ($t[1].v = $t[1].v.slice(1)), (je.works || je.works2) && ($t[1].v = $t[1].v.replace(/\r\n/g, `
`));
          /* falls through */
          case 13:
          /* INTEGER */
          case 14:
          /* NUMBER */
          case 16:
            ($t[2] & 112) == 112 && ($t[2] & 15) > 1 && ($t[2] & 15) < 15 && ($t[1].z = je.dateNF || re[($t[2] & 15) - 1] || table_fmt[14], je.cellDates && ($t[1].v = numdate($t[1].v), $t[1].t = typeof $t[1].v == "number" ? "n" : "d")), je.qpro && $t[3] > Ct && (it["!ref"] = encode_range(Vt), Rt[bt] = it, Ot.push(bt), it = {}, je.dense && (Dt = it["!data"] = []), Vt = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, Ct = $t[3], bt = rt || "Sheet" + (Ct + 1), rt = "");
            var Ue = je.dense ? (Dt[$t[0].r] || [])[$t[0].c] : it[encode_cell($t[0])];
            if (Ue) {
              Ue.t = $t[1].t, Ue.v = $t[1].v, $t[1].z != null && (Ue.z = $t[1].z), $t[1].f != null && (Ue.f = $t[1].f), er = Ue;
              break;
            }
            je.dense ? (Dt[$t[0].r] || (Dt[$t[0].r] = []), Dt[$t[0].r][$t[0].c] = $t[1]) : it[encode_cell($t[0])] = $t[1], er = $t[1];
            break;
          case 21509:
            je.works2 = !0;
            break;
          case 21506:
            $t == 5281 && (er.z = "hh:mm:ss", je.cellDates && er.t == "n" && (er.v = numdate(er.v), er.t = typeof er.v == "number" ? "n" : "d"));
            break;
        }
      }, je);
    else if (Be[2] == 26 || Be[2] == 14)
      je.Enum = St, Be[2] == 14 && (je.qpro = !0, Be.l = 0), le(Be, function($t, ir, Je) {
        switch (Je) {
          case 204:
            bt = $t;
            break;
          /* SHEETNAMECS */
          case 22:
            $t[1].v.charCodeAt(0) < 48 && ($t[1].v = $t[1].v.slice(1)), $t[1].v = $t[1].v.replace(/\x0F./g, function(Ue) {
              return String.fromCharCode(Ue.charCodeAt(1) - 32);
            }).replace(/\r\n/g, `
`);
          /* falls through */
          case 23:
          /* NUMBER17 */
          case 24:
          /* NUMBER18 */
          case 25:
          /* FORMULA19 */
          case 37:
          /* NUMBER25 */
          case 39:
          /* NUMBER27 */
          case 40:
            if ($t[3] > Ct && (it["!ref"] = encode_range(Vt), Rt[bt] = it, Ot.push(bt), it = {}, je.dense && (Dt = it["!data"] = []), Vt = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, Ct = $t[3], bt = "Sheet" + (Ct + 1)), Jt > 0 && $t[0].r >= Jt) break;
            je.dense ? (Dt[$t[0].r] || (Dt[$t[0].r] = []), Dt[$t[0].r][$t[0].c] = $t[1]) : it[encode_cell($t[0])] = $t[1], Vt.e.c < $t[0].c && (Vt.e.c = $t[0].c), Vt.e.r < $t[0].r && (Vt.e.r = $t[0].r);
            break;
          case 27:
            $t[14e3] && (Mt[$t[14e3][0]] = $t[14e3][1]);
            break;
          case 1537:
            Mt[$t[0]] = $t[1], $t[0] == Ct && (bt = $t[1]);
            break;
        }
      }, je);
    else throw new Error("Unrecognized LOTUS BOF " + Be[2]);
    if (it["!ref"] = encode_range(Vt), Rt[rt || bt] = it, Ot.push(rt || bt), !Mt.length) return { SheetNames: Ot, Sheets: Rt };
    for (var Zt = {}, Gt = [], Yt = 0; Yt < Mt.length; ++Yt) Rt[Ot[Yt]] ? (Gt.push(Mt[Yt] || Ot[Yt]), Zt[Mt[Yt]] = Rt[Mt[Yt]] || Rt[Ot[Yt]]) : (Gt.push(Mt[Yt]), Zt[Mt[Yt]] = { "!ref": "A1" });
    return { SheetNames: Gt, Sheets: Zt };
  }
  function ue(Be, et) {
    var je = et || {};
    if (+je.codepage >= 0 && set_cp(+je.codepage), je.type == "string") throw new Error("Cannot write WK1 to JS string");
    var it = buf_array();
    if (!Be["!ref"]) throw new Error("Cannot export empty sheet to WK1");
    var bt = safe_decode_range(Be["!ref"]), rt = Be["!data"] != null, Ct = [];
    write_biff_rec(it, 0, he(1030)), write_biff_rec(it, 6, xe(bt));
    for (var Rt = Math.min(bt.e.r, 8191), Ot = bt.s.c; Ot <= bt.e.c; ++Ot) Ct[Ot] = encode_col(Ot);
    for (var Mt = bt.s.r; Mt <= Rt; ++Mt) {
      var Dt = encode_row(Mt);
      for (Ot = bt.s.c; Ot <= bt.e.c; ++Ot) {
        var Vt = rt ? (Be["!data"][Mt] || [])[Ot] : Be[Ct[Ot] + Dt];
        if (!(!Vt || Vt.t == "z"))
          switch (Vt.t) {
            case "n":
              (Vt.v | 0) == Vt.v && Vt.v >= -32768 && Vt.v <= 32767 ? write_biff_rec(it, 13, Re(Mt, Ot, Vt)) : write_biff_rec(it, 14, Pe(Mt, Ot, Vt));
              break;
            case "d":
              var Jt = datenum(Vt.v);
              (Jt | 0) == Jt && Jt >= -32768 && Jt <= 32767 ? write_biff_rec(it, 13, Re(Mt, Ot, { v: Jt, z: Vt.z || table_fmt[14] })) : write_biff_rec(it, 14, Pe(Mt, Ot, { v: Jt, z: Vt.z || table_fmt[14] }));
              break;
            default:
              var er = format_cell(Vt);
              write_biff_rec(it, 15, Ce(Mt, Ot, er.slice(0, 239)));
          }
      }
    }
    return write_biff_rec(it, 1), it.end();
  }
  function fe(Be, et) {
    var je = et || {};
    if (+je.codepage >= 0 && set_cp(+je.codepage), je.type == "string") throw new Error("Cannot write WK3 to JS string");
    var it = buf_array();
    write_biff_rec(it, 0, _e(Be));
    for (var bt = 0, rt = 0; bt < Be.SheetNames.length; ++bt) (Be.Sheets[Be.SheetNames[bt]] || {})["!ref"] && write_biff_rec(it, 27, wt(Be.SheetNames[bt], rt++));
    var Ct = 0;
    for (bt = 0; bt < Be.SheetNames.length; ++bt) {
      var Rt = Be.Sheets[Be.SheetNames[bt]];
      if (!(!Rt || !Rt["!ref"])) {
        for (var Ot = safe_decode_range(Rt["!ref"]), Mt = Rt["!data"] != null, Dt = [], Vt = Math.min(Ot.e.r, 8191), Jt = Ot.s.r; Jt <= Vt; ++Jt)
          for (var er = encode_row(Jt), Zt = Ot.s.c; Zt <= Ot.e.c; ++Zt) {
            Jt === Ot.s.r && (Dt[Zt] = encode_col(Zt));
            var Gt = Dt[Zt] + er, Yt = Mt ? (Rt["!data"][Jt] || [])[Zt] : Rt[Gt];
            if (!(!Yt || Yt.t == "z"))
              if (Yt.t == "n")
                write_biff_rec(it, 23, Xe(Jt, Zt, Ct, Yt.v));
              else {
                var $t = format_cell(Yt);
                write_biff_rec(it, 22, Ke(Jt, Zt, Ct, $t.slice(0, 239)));
              }
          }
        ++Ct;
      }
    }
    return write_biff_rec(it, 1), it.end();
  }
  function he(Be) {
    var et = new_buf(2);
    return et.write_shift(2, Be), et;
  }
  function _e(Be) {
    var et = new_buf(26);
    et.write_shift(2, 4096), et.write_shift(2, 4), et.write_shift(4, 0);
    for (var je = 0, it = 0, bt = 0, rt = 0; rt < Be.SheetNames.length; ++rt) {
      var Ct = Be.SheetNames[rt], Rt = Be.Sheets[Ct];
      if (!(!Rt || !Rt["!ref"])) {
        ++bt;
        var Ot = decode_range(Rt["!ref"]);
        je < Ot.e.r && (je = Ot.e.r), it < Ot.e.c && (it = Ot.e.c);
      }
    }
    return je > 8191 && (je = 8191), et.write_shift(2, je), et.write_shift(1, bt), et.write_shift(1, it), et.write_shift(2, 0), et.write_shift(2, 0), et.write_shift(1, 1), et.write_shift(1, 2), et.write_shift(4, 0), et.write_shift(4, 0), et;
  }
  function ve(Be, et, je) {
    var it = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    return et == 8 && je.qpro ? (it.s.c = Be.read_shift(1), Be.l++, it.s.r = Be.read_shift(2), it.e.c = Be.read_shift(1), Be.l++, it.e.r = Be.read_shift(2), it) : (it.s.c = Be.read_shift(2), it.s.r = Be.read_shift(2), et == 12 && je.qpro && (Be.l += 2), it.e.c = Be.read_shift(2), it.e.r = Be.read_shift(2), et == 12 && je.qpro && (Be.l += 2), it.s.c == 65535 && (it.s.c = it.e.c = it.s.r = it.e.r = 0), it);
  }
  function xe(Be) {
    var et = new_buf(8);
    return et.write_shift(2, Be.s.c), et.write_shift(2, Be.s.r), et.write_shift(2, Be.e.c), et.write_shift(2, Be.e.r), et;
  }
  function Ee(Be, et, je) {
    var it = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
    return je.qpro && je.vers != 20768 ? (it[0].c = Be.read_shift(1), it[3] = Be.read_shift(1), it[0].r = Be.read_shift(2), Be.l += 2) : je.works ? (it[0].c = Be.read_shift(2), it[0].r = Be.read_shift(2), it[2] = Be.read_shift(2)) : (it[2] = Be.read_shift(1), it[0].c = Be.read_shift(2), it[0].r = Be.read_shift(2)), it;
  }
  function Se(Be) {
    return Be.z && fmt_is_date(Be.z) ? 240 | (re.indexOf(Be.z) + 1 || 2) : 255;
  }
  function Te(Be, et, je) {
    var it = Be.l + et, bt = Ee(Be, et, je);
    if (bt[1].t = "s", (je.vers & 65534) == 20768) {
      Be.l++;
      var rt = Be.read_shift(1);
      return bt[1].v = Be.read_shift(rt, "utf8"), bt;
    }
    return je.qpro && Be.l++, bt[1].v = Be.read_shift(it - Be.l, "cstr"), bt;
  }
  function Ce(Be, et, je) {
    var it = new_buf(7 + je.length);
    it.write_shift(1, 255), it.write_shift(2, et), it.write_shift(2, Be), it.write_shift(1, 39);
    for (var bt = 0; bt < it.length; ++bt) {
      var rt = je.charCodeAt(bt);
      it.write_shift(1, rt >= 128 ? 95 : rt);
    }
    return it.write_shift(1, 0), it;
  }
  function Ie(Be, et, je) {
    var it = Be.l + et, bt = Ee(Be, et, je);
    if (bt[1].t = "s", je.vers == 20768) {
      var rt = Be.read_shift(1);
      return bt[1].v = Be.read_shift(rt, "utf8"), bt;
    }
    return bt[1].v = Be.read_shift(it - Be.l, "cstr"), bt;
  }
  function Ne(Be, et, je) {
    var it = Ee(Be, et, je);
    return it[1].v = Be.read_shift(2, "i"), it;
  }
  function Re(Be, et, je) {
    var it = new_buf(7);
    return it.write_shift(1, Se(je)), it.write_shift(2, et), it.write_shift(2, Be), it.write_shift(2, je.v, "i"), it;
  }
  function Ae(Be, et, je) {
    var it = Ee(Be, et, je);
    return it[1].v = Be.read_shift(8, "f"), it;
  }
  function Pe(Be, et, je) {
    var it = new_buf(13);
    return it.write_shift(1, Se(je)), it.write_shift(2, et), it.write_shift(2, Be), it.write_shift(8, je.v, "f"), it;
  }
  function Fe(Be, et, je) {
    var it = Be.l + et, bt = Ee(Be, et, je);
    if (bt[1].v = Be.read_shift(8, "f"), je.qpro) Be.l = it;
    else {
      var rt = Be.read_shift(2);
      Ve(Be.slice(Be.l, Be.l + rt), bt), Be.l += rt;
    }
    return bt;
  }
  function Le(Be, et, je) {
    var it = et & 32768;
    return et &= -32769, et = (it ? Be : 0) + (et >= 8192 ? et - 16384 : et), (it ? "" : "$") + (je ? encode_col(et) : encode_row(et));
  }
  var He = {
    31: ["NA", 0],
    // 0x20: ["ERR", 0],
    33: ["ABS", 1],
    34: ["TRUNC", 1],
    35: ["SQRT", 1],
    36: ["LOG", 1],
    37: ["LN", 1],
    38: ["PI", 0],
    39: ["SIN", 1],
    40: ["COS", 1],
    41: ["TAN", 1],
    42: ["ATAN2", 2],
    43: ["ATAN", 1],
    44: ["ASIN", 1],
    45: ["ACOS", 1],
    46: ["EXP", 1],
    47: ["MOD", 2],
    // 0x30
    49: ["ISNA", 1],
    50: ["ISERR", 1],
    51: ["FALSE", 0],
    52: ["TRUE", 0],
    53: ["RAND", 0],
    54: ["DATE", 3],
    // 0x37 NOW
    // 0x38 PMT
    // 0x39 PV
    // 0x3A FV
    // 0x3B IF
    // 0x3C DAY
    // 0x3D MONTH
    // 0x3E YEAR
    63: ["ROUND", 2],
    64: ["TIME", 3],
    // 0x41 HOUR
    // 0x42 MINUTE
    // 0x43 SECOND
    68: ["ISNUMBER", 1],
    69: ["ISTEXT", 1],
    70: ["LEN", 1],
    71: ["VALUE", 1],
    // 0x48: ["FIXED", ?? 1],
    73: ["MID", 3],
    74: ["CHAR", 1],
    // 0x4B
    // 0x4C FIND
    // 0x4D DATEVALUE
    // 0x4E TIMEVALUE
    // 0x4F CELL
    80: ["SUM", 69],
    81: ["AVERAGEA", 69],
    82: ["COUNTA", 69],
    83: ["MINA", 69],
    84: ["MAXA", 69],
    // 0x55 VLOOKUP
    // 0x56 NPV
    // 0x57 VAR
    // 0x58 STD
    // 0x59 IRR
    // 0x5A HLOOKUP
    // 0x5B DSUM
    // 0x5C DAVERAGE
    // 0x5D DCOUNTA
    // 0x5E DMIN
    // 0x5F DMAX
    // 0x60 DVARP
    // 0x61 DSTDEVP
    // 0x62 INDEX
    // 0x63 COLS
    // 0x64 ROWS
    // 0x65 REPEAT
    102: ["UPPER", 1],
    103: ["LOWER", 1],
    // 0x68 LEFT
    // 0x69 RIGHT
    // 0x6A REPLACE
    107: ["PROPER", 1],
    // 0x6C CELL
    109: ["TRIM", 1],
    // 0x6E CLEAN
    111: ["T", 1]
    // 0x70 V
  }, Ge = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "",
    "+",
    "-",
    "*",
    "/",
    "^",
    "=",
    "<>",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "<=",
    ">=",
    "<",
    ">",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "&",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
    // eslint-disable-line no-mixed-spaces-and-tabs
  ];
  function Ve(Be, et) {
    prep_blob(Be, 0);
    for (var je = [], it = 0, bt = "", rt = "", Ct = "", Rt = ""; Be.l < Be.length; ) {
      var Ot = Be[Be.l++];
      switch (Ot) {
        case 0:
          je.push(Be.read_shift(8, "f"));
          break;
        case 1:
          rt = Le(et[0].c, Be.read_shift(2), !0), bt = Le(et[0].r, Be.read_shift(2), !1), je.push(rt + bt);
          break;
        case 2:
          {
            var Mt = Le(et[0].c, Be.read_shift(2), !0), Dt = Le(et[0].r, Be.read_shift(2), !1);
            rt = Le(et[0].c, Be.read_shift(2), !0), bt = Le(et[0].r, Be.read_shift(2), !1), je.push(Mt + Dt + ":" + rt + bt);
          }
          break;
        case 3:
          if (Be.l < Be.length) {
            console.error("WK1 premature formula end");
            return;
          }
          break;
        case 4:
          je.push("(" + je.pop() + ")");
          break;
        case 5:
          je.push(Be.read_shift(2));
          break;
        case 6:
          {
            for (var Vt = ""; Ot = Be[Be.l++]; ) Vt += String.fromCharCode(Ot);
            je.push('"' + Vt.replace(/"/g, '""') + '"');
          }
          break;
        case 8:
          je.push("-" + je.pop());
          break;
        case 23:
          je.push("+" + je.pop());
          break;
        case 22:
          je.push("NOT(" + je.pop() + ")");
          break;
        case 20:
        case 21:
          Rt = je.pop(), Ct = je.pop(), je.push(["AND", "OR"][Ot - 20] + "(" + Ct + "," + Rt + ")");
          break;
        default:
          if (Ot < 32 && Ge[Ot])
            Rt = je.pop(), Ct = je.pop(), je.push(Ct + Ge[Ot] + Rt);
          else if (He[Ot]) {
            if (it = He[Ot][1], it == 69 && (it = Be[Be.l++]), it > je.length) {
              console.error("WK1 bad formula parse 0x" + Ot.toString(16) + ":|" + je.join("|") + "|");
              return;
            }
            var Jt = je.slice(-it);
            je.length -= it, je.push(He[Ot][0] + "(" + Jt.join(",") + ")");
          } else return Ot <= 7 ? console.error("WK1 invalid opcode " + Ot.toString(16)) : Ot <= 24 ? console.error("WK1 unsupported op " + Ot.toString(16)) : Ot <= 30 ? console.error("WK1 invalid opcode " + Ot.toString(16)) : Ot <= 115 ? console.error("WK1 unsupported function opcode " + Ot.toString(16)) : console.error("WK1 unrecognized opcode " + Ot.toString(16));
      }
    }
    je.length == 1 ? et[1].f = "" + je[0] : console.error("WK1 bad formula parse |" + je.join("|") + "|");
  }
  function $e(Be) {
    var et = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
    return et[0].r = Be.read_shift(2), et[3] = Be[Be.l++], et[0].c = Be[Be.l++], et;
  }
  function De(Be, et) {
    var je = $e(Be);
    return je[1].t = "s", je[1].v = Be.read_shift(et - 4, "cstr"), je;
  }
  function Ke(Be, et, je, it) {
    var bt = new_buf(6 + it.length);
    bt.write_shift(2, Be), bt.write_shift(1, je), bt.write_shift(1, et), bt.write_shift(1, 39);
    for (var rt = 0; rt < it.length; ++rt) {
      var Ct = it.charCodeAt(rt);
      bt.write_shift(1, Ct >= 128 ? 95 : Ct);
    }
    return bt.write_shift(1, 0), bt;
  }
  function ze(Be, et) {
    var je = $e(Be);
    je[1].v = Be.read_shift(2);
    var it = je[1].v >> 1;
    if (je[1].v & 1)
      switch (it & 7) {
        case 0:
          it = (it >> 3) * 5e3;
          break;
        case 1:
          it = (it >> 3) * 500;
          break;
        case 2:
          it = (it >> 3) / 20;
          break;
        case 3:
          it = (it >> 3) / 200;
          break;
        case 4:
          it = (it >> 3) / 2e3;
          break;
        case 5:
          it = (it >> 3) / 2e4;
          break;
        case 6:
          it = (it >> 3) / 16;
          break;
        case 7:
          it = (it >> 3) / 64;
          break;
      }
    return je[1].v = it, je;
  }
  function tt(Be, et) {
    var je = $e(Be), it = Be.read_shift(4), bt = Be.read_shift(4), rt = Be.read_shift(2);
    if (rt == 65535)
      return it === 0 && bt === 3221225472 ? (je[1].t = "e", je[1].v = 15) : it === 0 && bt === 3489660928 ? (je[1].t = "e", je[1].v = 42) : je[1].v = 0, je;
    var Ct = rt & 32768;
    return rt = (rt & 32767) - 16446, je[1].v = (1 - Ct * 2) * (bt * Math.pow(2, rt + 32) + it * Math.pow(2, rt)), je;
  }
  function Xe(Be, et, je, it) {
    var bt = new_buf(14);
    if (bt.write_shift(2, Be), bt.write_shift(1, je), bt.write_shift(1, et), it == 0)
      return bt.write_shift(4, 0), bt.write_shift(4, 0), bt.write_shift(2, 65535), bt;
    var rt = 0, Ct = 0, Rt = 0, Ot = 0;
    return it < 0 && (rt = 1, it = -it), Ct = Math.log2(it) | 0, it /= Math.pow(2, Ct - 31), Ot = it >>> 0, (Ot & 2147483648) == 0 && (it /= 2, ++Ct, Ot = it >>> 0), it -= Ot, Ot |= 2147483648, Ot >>>= 0, it *= Math.pow(2, 32), Rt = it >>> 0, bt.write_shift(4, Rt), bt.write_shift(4, Ot), Ct += 16383 + (rt ? 32768 : 0), bt.write_shift(2, Ct), bt;
  }
  function mt(Be, et) {
    var je = tt(Be);
    return Be.l += et - 14, je;
  }
  function at(Be, et) {
    var je = $e(Be), it = Be.read_shift(4);
    return je[1].v = it >> 6, je;
  }
  function qe(Be, et) {
    var je = $e(Be), it = Be.read_shift(8, "f");
    return je[1].v = it, je;
  }
  function st(Be, et) {
    var je = qe(Be);
    return Be.l += et - 12, je;
  }
  function xt(Be, et) {
    return Be[Be.l + et - 1] == 0 ? Be.read_shift(et, "cstr") : "";
  }
  function gt(Be, et) {
    var je = Be[Be.l++];
    je > et - 1 && (je = et - 1);
    for (var it = ""; it.length < je; ) it += String.fromCharCode(Be[Be.l++]);
    return it;
  }
  function Ze(Be, et, je) {
    if (!(!je.qpro || et < 21)) {
      var it = Be.read_shift(1);
      Be.l += 17, Be.l += 1, Be.l += 2;
      var bt = Be.read_shift(et - 21, "cstr");
      return [it, bt];
    }
  }
  function _t(Be, et) {
    for (var je = {}, it = Be.l + et; Be.l < it; ) {
      var bt = Be.read_shift(2);
      if (bt == 14e3) {
        for (je[bt] = [0, ""], je[bt][0] = Be.read_shift(2); Be[Be.l]; )
          je[bt][1] += String.fromCharCode(Be[Be.l]), Be.l++;
        Be.l++;
      }
    }
    return je;
  }
  function wt(Be, et) {
    var je = new_buf(5 + Be.length);
    je.write_shift(2, 14e3), je.write_shift(2, et);
    for (var it = 0; it < Be.length; ++it) {
      var bt = Be.charCodeAt(it);
      je[je.l++] = bt > 127 ? 95 : bt;
    }
    return je[je.l++] = 0, je;
  }
  var yt = {
    0: { n: "BOF", f: parseuint16 },
    1: { n: "EOF" },
    2: { n: "CALCMODE" },
    3: { n: "CALCORDER" },
    4: { n: "SPLIT" },
    5: { n: "SYNC" },
    6: { n: "RANGE", f: ve },
    7: { n: "WINDOW1" },
    8: { n: "COLW1" },
    9: { n: "WINTWO" },
    10: { n: "COLW2" },
    11: { n: "NAME" },
    12: { n: "BLANK" },
    13: { n: "INTEGER", f: Ne },
    14: { n: "NUMBER", f: Ae },
    15: { n: "LABEL", f: Te },
    16: { n: "FORMULA", f: Fe },
    24: { n: "TABLE" },
    25: { n: "ORANGE" },
    26: { n: "PRANGE" },
    27: { n: "SRANGE" },
    28: { n: "FRANGE" },
    29: { n: "KRANGE1" },
    32: { n: "HRANGE" },
    35: { n: "KRANGE2" },
    36: { n: "PROTEC" },
    37: { n: "FOOTER" },
    38: { n: "HEADER" },
    39: { n: "SETUP" },
    40: { n: "MARGINS" },
    41: { n: "LABELFMT" },
    42: { n: "TITLES" },
    43: { n: "SHEETJS" },
    45: { n: "GRAPH" },
    46: { n: "NGRAPH" },
    47: { n: "CALCCOUNT" },
    48: { n: "UNFORMATTED" },
    49: { n: "CURSORW12" },
    50: { n: "WINDOW" },
    51: { n: "STRING", f: Ie },
    55: { n: "PASSWORD" },
    56: { n: "LOCKED" },
    60: { n: "QUERY" },
    61: { n: "QUERYNAME" },
    62: { n: "PRINT" },
    63: { n: "PRINTNAME" },
    64: { n: "GRAPH2" },
    65: { n: "GRAPHNAME" },
    66: { n: "ZOOM" },
    67: { n: "SYMSPLIT" },
    68: { n: "NSROWS" },
    69: { n: "NSCOLS" },
    70: { n: "RULER" },
    71: { n: "NNAME" },
    72: { n: "ACOMM" },
    73: { n: "AMACRO" },
    74: { n: "PARSE" },
    // 0x0064
    102: { n: "PRANGES??" },
    103: { n: "RRANGES??" },
    104: { n: "FNAME??" },
    105: { n: "MRANGES??" },
    // 0x0096
    // 0x0099
    // 0x009A
    // 0x009B
    // 0x009C
    // 0x00C0
    // 0x00C7
    // 0x00C9
    204: { n: "SHEETNAMECS", f: xt },
    // 0x00CD
    222: { n: "SHEETNAMELP", f: gt },
    255: { n: "BOF", f: parseuint16 },
    21506: { n: "WKSNF", f: parseuint16 },
    65535: { n: "" }
  }, St = {
    0: { n: "BOF" },
    1: { n: "EOF" },
    2: { n: "PASSWORD" },
    3: { n: "CALCSET" },
    4: { n: "WINDOWSET" },
    5: { n: "SHEETCELLPTR" },
    6: { n: "SHEETLAYOUT" },
    7: { n: "COLUMNWIDTH" },
    8: { n: "HIDDENCOLUMN" },
    9: { n: "USERRANGE" },
    10: { n: "SYSTEMRANGE" },
    11: { n: "ZEROFORCE" },
    12: { n: "SORTKEYDIR" },
    13: { n: "FILESEAL" },
    14: { n: "DATAFILLNUMS" },
    15: { n: "PRINTMAIN" },
    16: { n: "PRINTSTRING" },
    17: { n: "GRAPHMAIN" },
    18: { n: "GRAPHSTRING" },
    19: { n: "??" },
    20: { n: "ERRCELL" },
    21: { n: "NACELL" },
    22: { n: "LABEL16", f: De },
    23: { n: "NUMBER17", f: tt },
    24: { n: "NUMBER18", f: ze },
    25: { n: "FORMULA19", f: mt },
    26: { n: "FORMULA1A" },
    27: { n: "XFORMAT", f: _t },
    28: { n: "DTLABELMISC" },
    29: { n: "DTLABELCELL" },
    30: { n: "GRAPHWINDOW" },
    31: { n: "CPA" },
    32: { n: "LPLAUTO" },
    33: { n: "QUERY" },
    34: { n: "HIDDENSHEET" },
    35: { n: "??" },
    37: { n: "NUMBER25", f: at },
    38: { n: "??" },
    39: { n: "NUMBER27", f: qe },
    40: { n: "FORMULA28", f: st },
    142: { n: "??" },
    147: { n: "??" },
    150: { n: "??" },
    151: { n: "??" },
    152: { n: "??" },
    153: { n: "??" },
    154: { n: "??" },
    155: { n: "??" },
    156: { n: "??" },
    163: { n: "??" },
    174: { n: "??" },
    175: { n: "??" },
    176: { n: "??" },
    177: { n: "??" },
    184: { n: "??" },
    185: { n: "??" },
    186: { n: "??" },
    187: { n: "??" },
    188: { n: "??" },
    195: { n: "??" },
    201: { n: "??" },
    204: { n: "SHEETNAMECS", f: xt },
    205: { n: "??" },
    206: { n: "??" },
    207: { n: "??" },
    208: { n: "??" },
    256: { n: "??" },
    259: { n: "??" },
    260: { n: "??" },
    261: { n: "??" },
    262: { n: "??" },
    263: { n: "??" },
    265: { n: "??" },
    266: { n: "??" },
    267: { n: "??" },
    268: { n: "??" },
    270: { n: "??" },
    271: { n: "??" },
    384: { n: "??" },
    389: { n: "??" },
    390: { n: "??" },
    393: { n: "??" },
    396: { n: "??" },
    512: { n: "??" },
    514: { n: "??" },
    513: { n: "??" },
    516: { n: "??" },
    517: { n: "??" },
    640: { n: "??" },
    641: { n: "??" },
    642: { n: "??" },
    643: { n: "??" },
    644: { n: "??" },
    645: { n: "??" },
    646: { n: "??" },
    647: { n: "??" },
    648: { n: "??" },
    658: { n: "??" },
    659: { n: "??" },
    660: { n: "??" },
    661: { n: "??" },
    662: { n: "??" },
    665: { n: "??" },
    666: { n: "??" },
    768: { n: "??" },
    772: { n: "??" },
    1537: { n: "SHEETINFOQP", f: Ze },
    1600: { n: "??" },
    1602: { n: "??" },
    1793: { n: "??" },
    1794: { n: "??" },
    1795: { n: "??" },
    1796: { n: "??" },
    1920: { n: "??" },
    2048: { n: "??" },
    2049: { n: "??" },
    2052: { n: "??" },
    2688: { n: "??" },
    10998: { n: "??" },
    12849: { n: "??" },
    28233: { n: "??" },
    28484: { n: "??" },
    65535: { n: "" }
  }, It = {
    5: "dd-mmm-yy",
    6: "dd-mmm",
    7: "mmm-yy",
    8: "mm/dd/yy",
    // Long Date Intl
    10: "hh:mm:ss AM/PM",
    11: "hh:mm AM/PM",
    14: "dd-mmm-yyyy",
    15: "mmm-yyyy",
    /* It is suspected that the the low nybble specifies decimal places */
    34: "0.00",
    50: "0.00;[Red]0.00",
    66: "0.00;(0.00)",
    82: "0.00;[Red](0.00)",
    162: '"$"#,##0.00;\\("$"#,##0.00\\)',
    288: "0%",
    304: "0E+00",
    320: "# ?/?"
  };
  function Bt(Be) {
    var et = Be.read_shift(2), je = Be.read_shift(1);
    if (je != 0) throw "unsupported QPW string type " + je.toString(16);
    return Be.read_shift(et, "sbcs-cont");
  }
  function Ye(Be, et) {
    prep_blob(Be, 0);
    var je = et || {}, it = {};
    je.dense && (it["!data"] = []);
    var bt = [], rt = "", Ct = { s: { r: -1, c: -1 }, e: { r: -1, c: -1 } }, Rt = 0, Ot = 0, Mt = 0, Dt = 0, Vt = { SheetNames: [], Sheets: {} }, Jt = [];
    e: for (; Be.l < Be.length; ) {
      var er = Be.read_shift(2), Zt = Be.read_shift(2), Gt = Be.slice(Be.l, Be.l + Zt);
      switch (prep_blob(Gt, 0), er) {
        case 1:
          if (Gt.read_shift(4) != 962023505) throw "Bad QPW9 BOF!";
          break;
        case 2:
          break e;
        case 8:
          break;
        // TODO: this is tied to custom number formats
        case 10:
          for (var Yt = Gt.read_shift(4), $t = (Gt.length - Gt.l) / Yt | 0, ir = 0; ir < Yt; ++ir) {
            var Je = Gt.l + $t, Ue = {};
            Gt.l += 2, Ue.numFmtId = Gt.read_shift(2), It[Ue.numFmtId] && (Ue.z = It[Ue.numFmtId]), Gt.l = Je, Jt.push(Ue);
          }
          break;
        /* TODO: The behavior here should be consistent with Numbers: QP Notebook ~ .TN.SheetArchive, QP Sheet ~ .TST.TableModelArchive */
        case 1025:
          break;
        case 1026:
          break;
        case 1031:
          for (Gt.l += 12; Gt.l < Gt.length; )
            Rt = Gt.read_shift(2), Ot = Gt.read_shift(1), bt.push(Gt.read_shift(Rt, "cstr"));
          break;
        case 1032:
          break;
        case 1537:
          {
            var We = Gt.read_shift(2);
            it = {}, je.dense && (it["!data"] = []), Ct.s.c = Gt.read_shift(2), Ct.e.c = Gt.read_shift(2), Ct.s.r = Gt.read_shift(4), Ct.e.r = Gt.read_shift(4), Gt.l += 4, Gt.l + 2 < Gt.length && (Rt = Gt.read_shift(2), Ot = Gt.read_shift(1), rt = Rt == 0 ? "" : Gt.read_shift(Rt, "cstr")), rt || (rt = encode_col(We));
          }
          break;
        case 1538:
          {
            if (Ct.s.c > 255 || Ct.s.r > 999999) break;
            Ct.e.c < Ct.s.c && (Ct.e.c = Ct.s.c), Ct.e.r < Ct.s.r && (Ct.e.r = Ct.s.r), it["!ref"] = encode_range(Ct), book_append_sheet(Vt, it, rt);
          }
          break;
        case 2561:
          Mt = Gt.read_shift(2), Ct.e.c < Mt && (Ct.e.c = Mt), Ct.s.c > Mt && (Ct.s.c = Mt), Dt = Gt.read_shift(4), Ct.s.r > Dt && (Ct.s.r = Dt), Dt = Gt.read_shift(4), Ct.e.r < Dt && (Ct.e.r = Dt);
          break;
        case 3073:
          {
            Dt = Gt.read_shift(4), Rt = Gt.read_shift(4), Ct.s.r > Dt && (Ct.s.r = Dt), Ct.e.r < Dt + Rt - 1 && (Ct.e.r = Dt + Rt - 1);
            for (var lt = encode_col(Mt); Gt.l < Gt.length; ) {
              var ft = { t: "z" }, Et = Gt.read_shift(1), Lt = -1;
              Et & 128 && (Lt = Gt.read_shift(2));
              var Kt = Et & 64 ? Gt.read_shift(2) - 1 : 0;
              switch (Et & 31) {
                case 0:
                  break;
                case 1:
                  break;
                case 2:
                  ft = { t: "n", v: Gt.read_shift(2) };
                  break;
                case 3:
                  ft = { t: "n", v: Gt.read_shift(2, "i") };
                  break;
                case 4:
                  ft = { t: "n", v: parse_RkNumber(Gt) };
                  break;
                case 5:
                  ft = { t: "n", v: Gt.read_shift(8, "f") };
                  break;
                case 7:
                  ft = { t: "s", v: bt[Ot = Gt.read_shift(4) - 1] };
                  break;
                case 8:
                  ft = { t: "n", v: Gt.read_shift(8, "f") }, Gt.l += 2, Gt.l += 4, isNaN(ft.v) && (ft = { t: "e", v: 15 });
                  break;
                default:
                  throw "Unrecognized QPW cell type " + (Et & 31);
              }
              Lt != -1 && (Jt[Lt - 1] || {}).z && (ft.z = Jt[Lt - 1].z);
              var ar = 0;
              if (Et & 32) switch (Et & 31) {
                case 2:
                  ar = Gt.read_shift(2);
                  break;
                case 3:
                  ar = Gt.read_shift(2, "i");
                  break;
                case 7:
                  ar = Gt.read_shift(2);
                  break;
                default:
                  throw "Unsupported delta for QPW cell type " + (Et & 31);
              }
              if (!(!je.sheetStubs && ft.t == "z")) {
                var sr = dup(ft);
                ft.t == "n" && ft.z && fmt_is_date(ft.z) && je.cellDates && (sr.v = numdate(ft.v), sr.t = typeof sr.v == "number" ? "n" : "d"), it["!data"] != null ? (it["!data"][Dt] || (it["!data"][Dt] = []), it["!data"][Dt][Mt] = sr) : it[lt + encode_row(Dt)] = sr;
              }
              for (++Dt, --Rt; Kt-- > 0 && Rt >= 0; ) {
                if (Et & 32) switch (Et & 31) {
                  case 2:
                    ft = { t: "n", v: ft.v + ar & 65535 };
                    break;
                  case 3:
                    ft = { t: "n", v: ft.v + ar & 65535 }, ft.v > 32767 && (ft.v -= 65536);
                    break;
                  case 7:
                    ft = { t: "s", v: bt[Ot = Ot + ar >>> 0] };
                    break;
                  default:
                    throw "Cannot apply delta for QPW cell type " + (Et & 31);
                }
                else switch (Et & 31) {
                  case 1:
                    ft = { t: "z" };
                    break;
                  case 2:
                    ft = { t: "n", v: Gt.read_shift(2) };
                    break;
                  case 7:
                    ft = { t: "s", v: bt[Ot = Gt.read_shift(4) - 1] };
                    break;
                  default:
                    throw "Cannot apply repeat for QPW cell type " + (Et & 31);
                }
                !je.sheetStubs && ft.t == "z" || (it["!data"] != null ? (it["!data"][Dt] || (it["!data"][Dt] = []), it["!data"][Dt][Mt] = ft) : it[lt + encode_row(Dt)] = ft), ++Dt, --Rt;
              }
            }
          }
          break;
        case 3074:
          {
            Mt = Gt.read_shift(2), Dt = Gt.read_shift(4);
            var or = Bt(Gt);
            it["!data"] != null ? (it["!data"][Dt] || (it["!data"][Dt] = []), it["!data"][Dt][Mt] = { t: "s", v: or }) : it[encode_col(Mt) + encode_row(Dt)] = { t: "s", v: or };
          }
          break;
      }
      Be.l += Zt;
    }
    return Vt;
  }
  return {
    sheet_to_wk1: ue,
    book_to_wk3: fe,
    to_workbook: Y
  };
}();
function parse_rpr(le) {
  var Y = {}, re = le.match(tagregex), oe = 0, ue = !1;
  if (re) for (; oe != re.length; ++oe) {
    var fe = parsexmltag(re[oe]);
    switch (fe[0].replace(/<\w*:/g, "<")) {
      /* 18.8.12 condense CT_BooleanProperty */
      /* ** not required . */
      case "<condense":
        break;
      /* 18.8.17 extend CT_BooleanProperty */
      /* ** not required . */
      case "<extend":
        break;
      /* 18.8.36 shadow CT_BooleanProperty */
      /* ** not required . */
      case "<shadow":
        if (!fe.val) break;
      /* falls through */
      case "<shadow>":
      case "<shadow/>":
        Y.shadow = 1;
        break;
      case "</shadow>":
        break;
      /* 18.4.1 charset CT_IntProperty TODO */
      case "<charset":
        if (fe.val == "1") break;
        Y.cp = CS2CP[parseInt(fe.val, 10)];
        break;
      /* 18.4.2 outline CT_BooleanProperty TODO */
      case "<outline":
        if (!fe.val) break;
      /* falls through */
      case "<outline>":
      case "<outline/>":
        Y.outline = 1;
        break;
      case "</outline>":
        break;
      /* 18.4.5 rFont CT_FontName */
      case "<rFont":
        Y.name = fe.val;
        break;
      /* 18.4.11 sz CT_FontSize */
      case "<sz":
        Y.sz = fe.val;
        break;
      /* 18.4.10 strike CT_BooleanProperty */
      case "<strike":
        if (!fe.val) break;
      /* falls through */
      case "<strike>":
      case "<strike/>":
        Y.strike = 1;
        break;
      case "</strike>":
        break;
      /* 18.4.13 u CT_UnderlineProperty */
      case "<u":
        if (!fe.val) break;
        switch (fe.val) {
          case "double":
            Y.uval = "double";
            break;
          case "singleAccounting":
            Y.uval = "single-accounting";
            break;
          case "doubleAccounting":
            Y.uval = "double-accounting";
            break;
        }
      /* falls through */
      case "<u>":
      case "<u/>":
        Y.u = 1;
        break;
      case "</u>":
        break;
      /* 18.8.2 b */
      case "<b":
        if (fe.val == "0") break;
      /* falls through */
      case "<b>":
      case "<b/>":
        Y.b = 1;
        break;
      case "</b>":
        break;
      /* 18.8.26 i */
      case "<i":
        if (fe.val == "0") break;
      /* falls through */
      case "<i>":
      case "<i/>":
        Y.i = 1;
        break;
      case "</i>":
        break;
      /* 18.3.1.15 color CT_Color TODO: tint, theme, auto, indexed */
      case "<color":
        fe.rgb && (Y.color = fe.rgb.slice(2, 8));
        break;
      case "<color>":
      case "<color/>":
      case "</color>":
        break;
      /* 18.8.18 family ST_FontFamily */
      case "<family":
        Y.family = fe.val;
        break;
      case "<family>":
      case "<family/>":
      case "</family>":
        break;
      /* 18.4.14 vertAlign CT_VerticalAlignFontProperty TODO */
      case "<vertAlign":
        Y.valign = fe.val;
        break;
      case "<vertAlign>":
      case "<vertAlign/>":
      case "</vertAlign>":
        break;
      /* 18.8.35 scheme CT_FontScheme TODO */
      case "<scheme":
        break;
      case "<scheme>":
      case "<scheme/>":
      case "</scheme>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        ue = !0;
        break;
      case "</ext>":
        ue = !1;
        break;
      default:
        if (fe[0].charCodeAt(1) !== 47 && !ue) throw new Error("Unrecognized rich format " + fe[0]);
    }
  }
  return Y;
}
var parse_rs = /* @__PURE__ */ function() {
  function le(oe) {
    var ue = str_match_xml_ns(oe, "t");
    if (!ue) return { t: "s", v: "" };
    var fe = { t: "s", v: unescapexml(ue[1]) }, he = str_match_xml_ns(oe, "rPr");
    return he && (fe.s = parse_rpr(he[1])), fe;
  }
  var Y = /<(?:\w+:)?r>/g, re = /<\/(?:\w+:)?r>/;
  return function(ue) {
    return ue.replace(Y, "").split(re).map(le).filter(function(fe) {
      return fe.v;
    });
  };
}(), rs_to_html = /* @__PURE__ */ function le() {
  var Y = /(\r\n|\n)/g;
  function re(ue, fe, he) {
    var _e = [];
    ue.u && _e.push("text-decoration: underline;"), ue.uval && _e.push("text-underline-style:" + ue.uval + ";"), ue.sz && _e.push("font-size:" + ue.sz + "pt;"), ue.outline && _e.push("text-effect: outline;"), ue.shadow && _e.push("text-shadow: auto;"), fe.push('<span style="' + _e.join("") + '">'), ue.b && (fe.push("<b>"), he.push("</b>")), ue.i && (fe.push("<i>"), he.push("</i>")), ue.strike && (fe.push("<s>"), he.push("</s>"));
    var ve = ue.valign || "";
    return ve == "superscript" || ve == "super" ? ve = "sup" : ve == "subscript" && (ve = "sub"), ve != "" && (fe.push("<" + ve + ">"), he.push("</" + ve + ">")), he.push("</span>"), ue;
  }
  function oe(ue) {
    var fe = [[], ue.v, []];
    return ue.v ? (ue.s && re(ue.s, fe[0], fe[2]), fe[0].join("") + fe[1].replace(Y, "<br/>") + fe[2].join("")) : "";
  }
  return function(fe) {
    return fe.map(oe).join("");
  };
}(), sitregex = /<(?:\w+:)?t\b[^<>]*>([^<]*)<\/(?:\w+:)?t>/g, sirregex = /<(?:\w+:)?r\b[^<>]*>/;
function parse_si(le, Y) {
  var re = Y ? Y.cellHTML : !0, oe = {};
  return le ? (le.match(/^\s*<(?:\w+:)?t[^>]*>/) ? (oe.t = unescapexml(utf8read(le.slice(le.indexOf(">") + 1).split(/<\/(?:\w+:)?t>/)[0] || ""), !0), oe.r = utf8read(le), re && (oe.h = escapehtml(oe.t))) : (
    /*y = */
    le.match(sirregex) && (oe.r = utf8read(le), oe.t = unescapexml(utf8read((str_remove_xml_ns_g(le, "rPh").match(sitregex) || []).join("").replace(tagregex, "")), !0), re && (oe.h = rs_to_html(parse_rs(oe.r))))
  ), oe) : { t: "" };
}
var sstr1 = /<(?:\w+:)?(?:si|sstItem)>/g, sstr2 = /<\/(?:\w+:)?(?:si|sstItem)>/;
function parse_sst_xml(le, Y) {
  var re = [], oe = "";
  if (!le) return re;
  var ue = str_match_xml_ns(le, "sst");
  if (ue) {
    oe = ue[1].replace(sstr1, "").split(sstr2);
    for (var fe = 0; fe != oe.length; ++fe) {
      var he = parse_si(oe[fe].trim(), Y);
      he != null && (re[re.length] = he);
    }
    ue = parsexmltag(ue[0].slice(0, ue[0].indexOf(">"))), re.Count = ue.count, re.Unique = ue.uniqueCount;
  }
  return re;
}
var straywsregex = /^\s|\s$|[\t\n\r]/;
function write_sst_xml(le, Y) {
  if (!Y.bookSST) return "";
  var re = [XML_HEADER];
  re[re.length] = writextag("sst", null, {
    xmlns: XMLNS_main[0],
    count: le.Count,
    uniqueCount: le.Unique
  });
  for (var oe = 0; oe != le.length; ++oe)
    if (le[oe] != null) {
      var ue = le[oe], fe = "<si>";
      ue.r ? fe += ue.r : (fe += "<t", ue.t || (ue.t = ""), typeof ue.t != "string" && (ue.t = String(ue.t)), ue.t.match(straywsregex) && (fe += ' xml:space="preserve"'), fe += ">" + escapexml(ue.t) + "</t>"), fe += "</si>", re[re.length] = fe;
    }
  return re.length > 2 && (re[re.length] = "</sst>", re[1] = re[1].replace("/>", ">")), re.join("");
}
function parse_BrtBeginSst(le) {
  return [le.read_shift(4), le.read_shift(4)];
}
function parse_sst_bin(le, Y) {
  var re = [], oe = !1;
  return recordhopper(le, function(fe, he, _e) {
    switch (_e) {
      case 159:
        re.Count = fe[0], re.Unique = fe[1];
        break;
      case 19:
        re.push(fe);
        break;
      case 160:
        return !0;
      case 35:
        oe = !0;
        break;
      case 36:
        oe = !1;
        break;
      default:
        if (he.T, !oe || Y.WTF) throw new Error("Unexpected record 0x" + _e.toString(16));
    }
  }), re;
}
function write_BrtBeginSst(le, Y) {
  return Y || (Y = new_buf(8)), Y.write_shift(4, le.Count), Y.write_shift(4, le.Unique), Y;
}
var write_BrtSSTItem = write_RichStr;
function write_sst_bin(le) {
  var Y = buf_array();
  write_record(Y, 159, write_BrtBeginSst(le));
  for (var re = 0; re < le.length; ++re) write_record(Y, 19, write_BrtSSTItem(le[re]));
  return write_record(
    Y,
    160
    /* BrtEndSst */
  ), Y.end();
}
function _JS2ANSI(le) {
  if (typeof $cptable < "u") return $cptable.utils.encode(current_ansi, le);
  for (var Y = [], re = le.split(""), oe = 0; oe < re.length; ++oe) Y[oe] = re[oe].charCodeAt(0);
  return Y;
}
function parse_CRYPTOVersion(le, Y) {
  var re = {};
  return re.Major = le.read_shift(2), re.Minor = le.read_shift(2), Y >= 4 && (le.l += Y - 4), re;
}
function parse_DataSpaceVersionInfo(le) {
  var Y = {};
  return Y.id = le.read_shift(0, "lpp4"), Y.R = parse_CRYPTOVersion(le, 4), Y.U = parse_CRYPTOVersion(le, 4), Y.W = parse_CRYPTOVersion(le, 4), Y;
}
function parse_DataSpaceMapEntry(le) {
  for (var Y = le.read_shift(4), re = le.l + Y - 4, oe = {}, ue = le.read_shift(4), fe = []; ue-- > 0; ) fe.push({ t: le.read_shift(4), v: le.read_shift(0, "lpp4") });
  if (oe.name = le.read_shift(0, "lpp4"), oe.comps = fe, le.l != re) throw new Error("Bad DataSpaceMapEntry: " + le.l + " != " + re);
  return oe;
}
function parse_DataSpaceMap(le) {
  var Y = [];
  le.l += 4;
  for (var re = le.read_shift(4); re-- > 0; ) Y.push(parse_DataSpaceMapEntry(le));
  return Y;
}
function parse_DataSpaceDefinition(le) {
  var Y = [];
  le.l += 4;
  for (var re = le.read_shift(4); re-- > 0; ) Y.push(le.read_shift(0, "lpp4"));
  return Y;
}
function parse_TransformInfoHeader(le) {
  var Y = {};
  return le.read_shift(4), le.l += 4, Y.id = le.read_shift(0, "lpp4"), Y.name = le.read_shift(0, "lpp4"), Y.R = parse_CRYPTOVersion(le, 4), Y.U = parse_CRYPTOVersion(le, 4), Y.W = parse_CRYPTOVersion(le, 4), Y;
}
function parse_Primary(le) {
  var Y = parse_TransformInfoHeader(le);
  if (Y.ename = le.read_shift(0, "8lpp4"), Y.blksz = le.read_shift(4), Y.cmode = le.read_shift(4), le.read_shift(4) != 4) throw new Error("Bad !Primary record");
  return Y;
}
function parse_EncryptionHeader(le, Y) {
  var re = le.l + Y, oe = {};
  oe.Flags = le.read_shift(4) & 63, le.l += 4, oe.AlgID = le.read_shift(4);
  var ue = !1;
  switch (oe.AlgID) {
    case 26126:
    case 26127:
    case 26128:
      ue = oe.Flags == 36;
      break;
    case 26625:
      ue = oe.Flags == 4;
      break;
    case 0:
      ue = oe.Flags == 16 || oe.Flags == 4 || oe.Flags == 36;
      break;
    default:
      throw "Unrecognized encryption algorithm: " + oe.AlgID;
  }
  if (!ue) throw new Error("Encryption Flags/AlgID mismatch");
  return oe.AlgIDHash = le.read_shift(4), oe.KeySize = le.read_shift(4), oe.ProviderType = le.read_shift(4), le.l += 8, oe.CSPName = le.read_shift(re - le.l >> 1, "utf16le"), le.l = re, oe;
}
function parse_EncryptionVerifier(le, Y) {
  var re = {}, oe = le.l + Y;
  return le.l += 4, re.Salt = le.slice(le.l, le.l + 16), le.l += 16, re.Verifier = le.slice(le.l, le.l + 16), le.l += 16, le.read_shift(4), re.VerifierHash = le.slice(le.l, oe), le.l = oe, re;
}
function parse_EncryptionInfo(le) {
  var Y = parse_CRYPTOVersion(le);
  switch (Y.Minor) {
    case 2:
      return [Y.Minor, parse_EncInfoStd(le)];
    case 3:
      return [Y.Minor, parse_EncInfoExt()];
    case 4:
      return [Y.Minor, parse_EncInfoAgl(le)];
  }
  throw new Error("ECMA-376 Encrypted file unrecognized Version: " + Y.Minor);
}
function parse_EncInfoStd(le) {
  var Y = le.read_shift(4);
  if ((Y & 63) != 36) throw new Error("EncryptionInfo mismatch");
  var re = le.read_shift(4), oe = parse_EncryptionHeader(le, re), ue = parse_EncryptionVerifier(le, le.length - le.l);
  return { t: "Std", h: oe, v: ue };
}
function parse_EncInfoExt() {
  throw new Error("File is password-protected: ECMA-376 Extensible");
}
function parse_EncInfoAgl(le) {
  var Y = ["saltSize", "blockSize", "keyBits", "hashSize", "cipherAlgorithm", "cipherChaining", "hashAlgorithm", "saltValue"];
  le.l += 4;
  var re = le.read_shift(le.length - le.l, "utf8"), oe = {};
  return re.replace(tagregex, function(fe) {
    var he = parsexmltag(fe);
    switch (strip_ns(he[0])) {
      case "<?xml":
        break;
      case "<encryption":
      case "</encryption>":
        break;
      case "<keyData":
        Y.forEach(function(_e) {
          oe[_e] = he[_e];
        });
        break;
      case "<dataIntegrity":
        oe.encryptedHmacKey = he.encryptedHmacKey, oe.encryptedHmacValue = he.encryptedHmacValue;
        break;
      case "<keyEncryptors>":
      case "<keyEncryptors":
        oe.encs = [];
        break;
      case "</keyEncryptors>":
        break;
      case "<keyEncryptor":
        oe.uri = he.uri;
        break;
      case "</keyEncryptor>":
        break;
      case "<encryptedKey":
        oe.encs.push(he);
        break;
      default:
        throw he[0];
    }
  }), oe;
}
function parse_RC4CryptoHeader(le, Y) {
  var re = {}, oe = re.EncryptionVersionInfo = parse_CRYPTOVersion(le, 4);
  if (Y -= 4, oe.Minor != 2) throw new Error("unrecognized minor version code: " + oe.Minor);
  if (oe.Major > 4 || oe.Major < 2) throw new Error("unrecognized major version code: " + oe.Major);
  re.Flags = le.read_shift(4), Y -= 4;
  var ue = le.read_shift(4);
  return Y -= 4, re.EncryptionHeader = parse_EncryptionHeader(le, ue), Y -= ue, re.EncryptionVerifier = parse_EncryptionVerifier(le, Y), re;
}
function parse_RC4Header(le) {
  var Y = {}, re = Y.EncryptionVersionInfo = parse_CRYPTOVersion(le, 4);
  if (re.Major != 1 || re.Minor != 1) throw "unrecognized version code " + re.Major + " : " + re.Minor;
  return Y.Salt = le.read_shift(16), Y.EncryptedVerifier = le.read_shift(16), Y.EncryptedVerifierHash = le.read_shift(16), Y;
}
function crypto_CreatePasswordVerifier_Method1(le) {
  var Y = 0, re, oe = _JS2ANSI(le), ue = oe.length + 1, fe, he, _e, ve, xe;
  for (re = new_raw_buf(ue), re[0] = oe.length, fe = 1; fe != ue; ++fe) re[fe] = oe[fe - 1];
  for (fe = ue - 1; fe >= 0; --fe)
    he = re[fe], _e = (Y & 16384) === 0 ? 0 : 1, ve = Y << 1 & 32767, xe = _e | ve, Y = xe ^ he;
  return Y ^ 52811;
}
var crypto_CreateXorArray_Method1 = /* @__PURE__ */ function() {
  var le = [187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0], Y = [57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163], re = [44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628], oe = function(he) {
    return (he / 2 | he * 128) & 255;
  }, ue = function(he, _e) {
    return oe(he ^ _e);
  }, fe = function(he) {
    for (var _e = Y[he.length - 1], ve = 104, xe = he.length - 1; xe >= 0; --xe)
      for (var Ee = he[xe], Se = 0; Se != 7; ++Se)
        Ee & 64 && (_e ^= re[ve]), Ee *= 2, --ve;
    return _e;
  };
  return function(he) {
    for (var _e = _JS2ANSI(he), ve = fe(_e), xe = _e.length, Ee = new_raw_buf(16), Se = 0; Se != 16; ++Se) Ee[Se] = 0;
    var Te, Ce, Ie;
    for ((xe & 1) === 1 && (Te = ve >> 8, Ee[xe] = ue(le[0], Te), --xe, Te = ve & 255, Ce = _e[_e.length - 1], Ee[xe] = ue(Ce, Te)); xe > 0; )
      --xe, Te = ve >> 8, Ee[xe] = ue(_e[xe], Te), --xe, Te = ve & 255, Ee[xe] = ue(_e[xe], Te);
    for (xe = 15, Ie = 15 - _e.length; Ie > 0; )
      Te = ve >> 8, Ee[xe] = ue(le[Ie], Te), --xe, --Ie, Te = ve & 255, Ee[xe] = ue(_e[xe], Te), --xe, --Ie;
    return Ee;
  };
}(), crypto_DecryptData_Method1 = function(le, Y, re, oe, ue) {
  ue || (ue = Y), oe || (oe = crypto_CreateXorArray_Method1(le));
  var fe, he;
  for (fe = 0; fe != Y.length; ++fe)
    he = Y[fe], he ^= oe[re], he = (he >> 5 | he << 3) & 255, ue[fe] = he, ++re;
  return [ue, re, oe];
}, crypto_MakeXorDecryptor = function(le) {
  var Y = 0, re = crypto_CreateXorArray_Method1(le);
  return function(oe) {
    var ue = crypto_DecryptData_Method1("", oe, Y, re);
    return Y = ue[1], ue[0];
  };
};
function parse_XORObfuscation(le, Y, re, oe) {
  var ue = { key: parseuint16(le), verificationBytes: parseuint16(le) };
  return re.password && (ue.verifier = crypto_CreatePasswordVerifier_Method1(re.password)), oe.valid = ue.verificationBytes === ue.verifier, oe.valid && (oe.insitu = crypto_MakeXorDecryptor(re.password)), ue;
}
function parse_FilePassHeader(le, Y, re) {
  var oe = re || {};
  return oe.Info = le.read_shift(2), le.l -= 2, oe.Info === 1 ? oe.Data = parse_RC4Header(le) : oe.Data = parse_RC4CryptoHeader(le, Y), oe;
}
function parse_FilePass(le, Y, re) {
  var oe = { Type: re.biff >= 8 ? le.read_shift(2) : 0 };
  return oe.Type ? parse_FilePassHeader(le, Y - 2, oe) : parse_XORObfuscation(le, re.biff >= 8 ? Y : Y - 2, re, oe), oe;
}
function rtf_to_sheet(le, Y) {
  switch (Y.type) {
    case "base64":
      return rtf_to_sheet_str(Base64_decode(le), Y);
    case "binary":
      return rtf_to_sheet_str(le, Y);
    case "buffer":
      return rtf_to_sheet_str(has_buf && Buffer.isBuffer(le) ? le.toString("binary") : a2s(le), Y);
    case "array":
      return rtf_to_sheet_str(cc2str(le), Y);
  }
  throw new Error("Unrecognized type " + Y.type);
}
function rtf_to_sheet_str(le, Y) {
  var re = Y || {}, oe = {}, ue = re.dense;
  ue && (oe["!data"] = []);
  var fe = str_match_ng(le, "\\trowd", "\\row");
  if (!fe)
    throw new Error("RTF missing table");
  var he = { s: { c: 0, r: 0 }, e: { c: 0, r: fe.length - 1 } }, _e = [];
  return fe.forEach(function(ve, xe) {
    ue && (_e = oe["!data"][xe] = []);
    for (var Ee = /\\[\w\-]+\b/g, Se = 0, Te, Ce = -1, Ie = []; (Te = Ee.exec(ve)) != null; ) {
      var Ne = ve.slice(Se, Ee.lastIndex - Te[0].length);
      switch (Ne.charCodeAt(0) == 32 && (Ne = Ne.slice(1)), Ne.length && Ie.push(Ne), Te[0]) {
        case "\\cell":
          if (++Ce, Ie.length) {
            var Re = { v: Ie.join(""), t: "s" };
            Re.v == "TRUE" || Re.v == "FALSE" ? (Re.v = Re.v == "TRUE", Re.t = "b") : isNaN(fuzzynum(Re.v)) ? RBErr[Re.v] != null && (Re.t = "e", Re.w = Re.v, Re.v = RBErr[Re.v]) : (Re.t = "n", re.cellText !== !1 && (Re.w = Re.v), Re.v = fuzzynum(Re.v)), ue ? _e[Ce] = Re : oe[encode_cell({ r: xe, c: Ce })] = Re;
          }
          Ie = [];
          break;
        case "\\par":
          Ie.push(`
`);
          break;
      }
      Se = Ee.lastIndex;
    }
    Ce > he.e.c && (he.e.c = Ce);
  }), oe["!ref"] = encode_range(he), oe;
}
function rtf_to_workbook(le, Y) {
  var re = sheet_to_workbook(rtf_to_sheet(le, Y), Y);
  return re.bookType = "rtf", re;
}
function sheet_to_rtf(le, Y) {
  var re = ["{\\rtf1\\ansi"];
  if (!le["!ref"])
    return re[0] + "}";
  for (var oe = safe_decode_range(le["!ref"]), ue, fe = le["!data"] != null, he = [], _e = oe.s.r; _e <= oe.e.r; ++_e) {
    re.push("\\trowd\\trautofit1");
    for (var ve = oe.s.c; ve <= oe.e.c; ++ve)
      re.push("\\cellx" + (ve + 1));
    for (re.push("\\pard\\intbl"), fe && (he = le["!data"][_e] || []), ve = oe.s.c; ve <= oe.e.c; ++ve) {
      var xe = encode_cell({ r: _e, c: ve });
      if (ue = fe ? he[ve] : le[xe], !ue || ue.v == null && (!ue.f || ue.F)) {
        re.push(" \\cell");
        continue;
      }
      re.push(" " + (ue.w || (format_cell(ue), ue.w) || "").replace(/[\r\n]/g, "\\par ")), re.push("\\cell");
    }
    re.push("\\pard\\intbl\\row");
  }
  return re.join("") + "}";
}
function hex2RGB(le) {
  var Y = le.slice(le[0] === "#" ? 1 : 0).slice(0, 6);
  return [parseInt(Y.slice(0, 2), 16), parseInt(Y.slice(2, 4), 16), parseInt(Y.slice(4, 6), 16)];
}
function rgb2Hex(le) {
  for (var Y = 0, re = 1; Y != 3; ++Y) re = re * 256 + (le[Y] > 255 ? 255 : le[Y] < 0 ? 0 : le[Y]);
  return re.toString(16).toUpperCase().slice(1);
}
function rgb2HSL(le) {
  var Y = le[0] / 255, re = le[1] / 255, oe = le[2] / 255, ue = Math.max(Y, re, oe), fe = Math.min(Y, re, oe), he = ue - fe;
  if (he === 0) return [0, 0, Y];
  var _e = 0, ve = 0, xe = ue + fe;
  switch (ve = he / (xe > 1 ? 2 - xe : xe), ue) {
    case Y:
      _e = ((re - oe) / he + 6) % 6;
      break;
    case re:
      _e = (oe - Y) / he + 2;
      break;
    case oe:
      _e = (Y - re) / he + 4;
      break;
  }
  return [_e / 6, ve, xe / 2];
}
function hsl2RGB(le) {
  var Y = le[0], re = le[1], oe = le[2], ue = re * 2 * (oe < 0.5 ? oe : 1 - oe), fe = oe - ue / 2, he = [fe, fe, fe], _e = 6 * Y, ve;
  if (re !== 0) switch (_e | 0) {
    case 0:
    case 6:
      ve = ue * _e, he[0] += ue, he[1] += ve;
      break;
    case 1:
      ve = ue * (2 - _e), he[0] += ve, he[1] += ue;
      break;
    case 2:
      ve = ue * (_e - 2), he[1] += ue, he[2] += ve;
      break;
    case 3:
      ve = ue * (4 - _e), he[1] += ve, he[2] += ue;
      break;
    case 4:
      ve = ue * (_e - 4), he[2] += ue, he[0] += ve;
      break;
    case 5:
      ve = ue * (6 - _e), he[2] += ve, he[0] += ue;
      break;
  }
  for (var xe = 0; xe != 3; ++xe) he[xe] = Math.round(he[xe] * 255);
  return he;
}
function rgb_tint(le, Y) {
  if (Y === 0) return le;
  var re = rgb2HSL(hex2RGB(le));
  return Y < 0 ? re[2] = re[2] * (1 + Y) : re[2] = 1 - (1 - re[2]) * (1 - Y), rgb2Hex(hsl2RGB(re));
}
var DEF_MDW = 6, MAX_MDW = 15, MIN_MDW = 1, MDW = DEF_MDW;
function width2px(le) {
  return Math.floor((le + Math.round(128 / MDW) / 256) * MDW);
}
function px2char(le) {
  return Math.floor((le - 5) / MDW * 100 + 0.5) / 100;
}
function char2width(le) {
  return Math.round((le * MDW + 5) / MDW * 256) / 256;
}
function cycle_width(le) {
  return char2width(px2char(width2px(le)));
}
function find_mdw_colw(le) {
  var Y = Math.abs(le - cycle_width(le)), re = MDW;
  if (Y > 5e-3) for (MDW = MIN_MDW; MDW < MAX_MDW; ++MDW) Math.abs(le - cycle_width(le)) <= Y && (Y = Math.abs(le - cycle_width(le)), re = MDW);
  MDW = re;
}
function process_col(le) {
  le.width ? (le.wpx = width2px(le.width), le.wch = px2char(le.wpx), le.MDW = MDW) : le.wpx ? (le.wch = px2char(le.wpx), le.width = char2width(le.wch), le.MDW = MDW) : typeof le.wch == "number" && (le.width = char2width(le.wch), le.wpx = width2px(le.width), le.MDW = MDW), le.customWidth && delete le.customWidth;
}
var DEF_PPI = 96, PPI = DEF_PPI;
function px2pt(le) {
  return le * 96 / PPI;
}
function pt2px(le) {
  return le * PPI / 96;
}
var XLMLPatternTypeMap = {
  None: "none",
  Solid: "solid",
  Gray50: "mediumGray",
  Gray75: "darkGray",
  Gray25: "lightGray",
  HorzStripe: "darkHorizontal",
  VertStripe: "darkVertical",
  ReverseDiagStripe: "darkDown",
  DiagStripe: "darkUp",
  DiagCross: "darkGrid",
  ThickDiagCross: "darkTrellis",
  ThinHorzStripe: "lightHorizontal",
  ThinVertStripe: "lightVertical",
  ThinReverseDiagStripe: "lightDown",
  ThinHorzCross: "lightGrid"
};
function parse_borders(le, Y, re, oe) {
  Y.Borders = [];
  var ue = {}, fe = !1;
  (le.match(tagregex) || []).forEach(function(he) {
    var _e = parsexmltag(he);
    switch (strip_ns(_e[0])) {
      case "<borders":
      case "<borders>":
      case "</borders>":
        break;
      /* 18.8.4 border CT_Border */
      case "<border":
      case "<border>":
      case "<border/>":
        ue = /*::(*/
        {}, _e.diagonalUp && (ue.diagonalUp = parsexmlbool(_e.diagonalUp)), _e.diagonalDown && (ue.diagonalDown = parsexmlbool(_e.diagonalDown)), Y.Borders.push(ue);
        break;
      case "</border>":
        break;
      /* note: not in spec, appears to be CT_BorderPr */
      case "<left/>":
        break;
      case "<left":
      case "<left>":
        break;
      case "</left>":
        break;
      /* note: not in spec, appears to be CT_BorderPr */
      case "<right/>":
        break;
      case "<right":
      case "<right>":
        break;
      case "</right>":
        break;
      /* 18.8.43 top CT_BorderPr */
      case "<top/>":
        break;
      case "<top":
      case "<top>":
        break;
      case "</top>":
        break;
      /* 18.8.6 bottom CT_BorderPr */
      case "<bottom/>":
        break;
      case "<bottom":
      case "<bottom>":
        break;
      case "</bottom>":
        break;
      /* 18.8.13 diagonal CT_BorderPr */
      case "<diagonal":
      case "<diagonal>":
      case "<diagonal/>":
        break;
      case "</diagonal>":
        break;
      /* 18.8.25 horizontal CT_BorderPr */
      case "<horizontal":
      case "<horizontal>":
      case "<horizontal/>":
        break;
      case "</horizontal>":
        break;
      /* 18.8.44 vertical CT_BorderPr */
      case "<vertical":
      case "<vertical>":
      case "<vertical/>":
        break;
      case "</vertical>":
        break;
      /* 18.8.37 start CT_BorderPr */
      case "<start":
      case "<start>":
      case "<start/>":
        break;
      case "</start>":
        break;
      /* 18.8.16 end CT_BorderPr */
      case "<end":
      case "<end>":
      case "<end/>":
        break;
      case "</end>":
        break;
      /* 18.8.? color CT_Color */
      case "<color":
      case "<color>":
        break;
      case "<color/>":
      case "</color>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        fe = !0;
        break;
      case "</ext>":
        fe = !1;
        break;
      default:
        if (oe && oe.WTF && !fe)
          throw new Error("unrecognized " + _e[0] + " in borders");
    }
  });
}
function parse_fills(le, Y, re, oe) {
  Y.Fills = [];
  var ue = {}, fe = !1;
  (le.match(tagregex) || []).forEach(function(he) {
    var _e = parsexmltag(he);
    switch (strip_ns(_e[0])) {
      case "<fills":
      case "<fills>":
      case "</fills>":
        break;
      /* 18.8.20 fill CT_Fill */
      case "<fill>":
      case "<fill":
      case "<fill/>":
        ue = {}, Y.Fills.push(ue);
        break;
      case "</fill>":
        break;
      /* 18.8.24 gradientFill CT_GradientFill */
      case "<gradientFill>":
        break;
      case "<gradientFill":
      case "</gradientFill>":
        Y.Fills.push(ue), ue = {};
        break;
      /* 18.8.32 patternFill CT_PatternFill */
      case "<patternFill":
      case "<patternFill>":
        _e.patternType && (ue.patternType = _e.patternType);
        break;
      case "<patternFill/>":
      case "</patternFill>":
        break;
      /* 18.8.3 bgColor CT_Color */
      case "<bgColor":
        ue.bgColor || (ue.bgColor = {}), _e.indexed && (ue.bgColor.indexed = parseInt(_e.indexed, 10)), _e.theme && (ue.bgColor.theme = parseInt(_e.theme, 10)), _e.tint && (ue.bgColor.tint = parseFloat(_e.tint)), _e.rgb && (ue.bgColor.rgb = _e.rgb.slice(-6));
        break;
      case "<bgColor/>":
      case "</bgColor>":
        break;
      /* 18.8.19 fgColor CT_Color */
      case "<fgColor":
        ue.fgColor || (ue.fgColor = {}), _e.theme && (ue.fgColor.theme = parseInt(_e.theme, 10)), _e.tint && (ue.fgColor.tint = parseFloat(_e.tint)), _e.rgb != null && (ue.fgColor.rgb = _e.rgb.slice(-6));
        break;
      case "<fgColor/>":
      case "</fgColor>":
        break;
      /* 18.8.38 stop CT_GradientStop */
      case "<stop":
      case "<stop/>":
        break;
      case "</stop>":
        break;
      /* 18.8.? color CT_Color */
      case "<color":
      case "<color/>":
        break;
      case "</color>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        fe = !0;
        break;
      case "</ext>":
        fe = !1;
        break;
      default:
        if (oe && oe.WTF && !fe)
          throw new Error("unrecognized " + _e[0] + " in fills");
    }
  });
}
function parse_fonts(le, Y, re, oe) {
  Y.Fonts = [];
  var ue = {}, fe = !1;
  (le.match(tagregex) || []).forEach(function(he) {
    var _e = parsexmltag(he);
    switch (strip_ns(_e[0])) {
      case "<fonts":
      case "<fonts>":
      case "</fonts>":
        break;
      /* 18.8.22 font CT_Font */
      case "<font":
      case "<font>":
        break;
      case "</font>":
      case "<font/>":
        Y.Fonts.push(ue), ue = {};
        break;
      /* 18.8.29 name CT_FontName */
      case "<name":
        _e.val && (ue.name = utf8read(_e.val));
        break;
      case "<name/>":
      case "</name>":
        break;
      /* 18.8.2  b CT_BooleanProperty */
      case "<b":
        ue.bold = _e.val ? parsexmlbool(_e.val) : 1;
        break;
      case "<b/>":
        ue.bold = 1;
        break;
      case "</b>":
      case "</b":
        break;
      /* 18.8.26 i CT_BooleanProperty */
      case "<i":
        ue.italic = _e.val ? parsexmlbool(_e.val) : 1;
        break;
      case "<i/>":
        ue.italic = 1;
        break;
      case "</i>":
      case "</i":
        break;
      /* 18.4.13 u CT_UnderlineProperty */
      case "<u":
        switch (_e.val) {
          case "none":
            ue.underline = 0;
            break;
          case "single":
            ue.underline = 1;
            break;
          case "double":
            ue.underline = 2;
            break;
          case "singleAccounting":
            ue.underline = 33;
            break;
          case "doubleAccounting":
            ue.underline = 34;
            break;
        }
        break;
      case "<u/>":
        ue.underline = 1;
        break;
      case "</u>":
      case "</u":
        break;
      /* 18.4.10 strike CT_BooleanProperty */
      case "<strike":
        ue.strike = _e.val ? parsexmlbool(_e.val) : 1;
        break;
      case "<strike/>":
        ue.strike = 1;
        break;
      case "</strike>":
      case "</strike":
        break;
      /* 18.4.2  outline CT_BooleanProperty */
      case "<outline":
        ue.outline = _e.val ? parsexmlbool(_e.val) : 1;
        break;
      case "<outline/>":
        ue.outline = 1;
        break;
      case "</outline>":
      case "</outline":
        break;
      /* 18.8.36 shadow CT_BooleanProperty */
      case "<shadow":
        ue.shadow = _e.val ? parsexmlbool(_e.val) : 1;
        break;
      case "<shadow/>":
        ue.shadow = 1;
        break;
      case "</shadow>":
      case "</shadow":
        break;
      /* 18.8.12 condense CT_BooleanProperty */
      case "<condense":
        ue.condense = _e.val ? parsexmlbool(_e.val) : 1;
        break;
      case "<condense/>":
        ue.condense = 1;
        break;
      case "</condense>":
      case "</condense":
        break;
      /* 18.8.17 extend CT_BooleanProperty */
      case "<extend":
        ue.extend = _e.val ? parsexmlbool(_e.val) : 1;
        break;
      case "<extend/>":
        ue.extend = 1;
        break;
      case "</extend>":
      case "</extend":
        break;
      /* 18.4.11 sz CT_FontSize */
      case "<sz":
        _e.val && (ue.sz = +_e.val);
        break;
      case "<sz/>":
      case "</sz>":
      case "</sz":
        break;
      /* 18.4.14 vertAlign CT_VerticalAlignFontProperty */
      case "<vertAlign":
        _e.val && (ue.vertAlign = _e.val);
        break;
      case "<vertAlign/>":
      case "</vertAlign>":
      case "</vertAlign":
        break;
      /* 18.8.18 family CT_FontFamily */
      case "<family":
        _e.val && (ue.family = parseInt(_e.val, 10));
        break;
      case "<family/>":
      case "</family>":
      case "</family":
        break;
      /* 18.8.35 scheme CT_FontScheme */
      case "<scheme":
        _e.val && (ue.scheme = _e.val);
        break;
      case "<scheme/>":
      case "</scheme>":
      case "</scheme":
        break;
      /* 18.4.1 charset CT_IntProperty */
      case "<charset":
        if (_e.val == "1") break;
        _e.codepage = CS2CP[parseInt(_e.val, 10)];
        break;
      case "<charset/>":
      case "</charset>":
      case "</charset":
        break;
      /* 18.?.? color CT_Color */
      case "<color":
        if (ue.color || (ue.color = {}), _e.auto && (ue.color.auto = parsexmlbool(_e.auto)), _e.rgb) ue.color.rgb = _e.rgb.slice(-6);
        else if (_e.indexed) {
          ue.color.index = parseInt(_e.indexed, 10);
          var ve = XLSIcv[ue.color.index];
          ue.color.index == 81 && (ve = XLSIcv[1]), ve || (ve = XLSIcv[1]), ue.color.rgb = ve[0].toString(16) + ve[1].toString(16) + ve[2].toString(16);
        } else _e.theme && (ue.color.theme = parseInt(_e.theme, 10), _e.tint && (ue.color.tint = parseFloat(_e.tint)), _e.theme && re.themeElements && re.themeElements.clrScheme && (ue.color.rgb = rgb_tint(re.themeElements.clrScheme[ue.color.theme].rgb, ue.color.tint || 0)));
        break;
      case "<color/>":
      case "</color>":
      case "</color":
        break;
      /* note: sometimes mc:AlternateContent appears bare */
      case "<AlternateContent":
        fe = !0;
        break;
      case "</AlternateContent>":
      case "</AlternateContent":
        fe = !1;
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        fe = !0;
        break;
      case "</ext>":
        fe = !1;
        break;
      default:
        if (oe && oe.WTF && !fe)
          throw new Error("unrecognized " + _e[0] + " in fonts");
    }
  });
}
function parse_numFmts(le, Y, re) {
  Y.NumberFmt = [];
  for (var oe = keys(table_fmt), ue = 0; ue < oe.length; ++ue) Y.NumberFmt[oe[ue]] = table_fmt[oe[ue]];
  var fe = le.match(tagregex);
  if (fe)
    for (ue = 0; ue < fe.length; ++ue) {
      var he = parsexmltag(fe[ue]);
      switch (strip_ns(he[0])) {
        case "<numFmts":
        case "</numFmts>":
        case "<numFmts/>":
        case "<numFmts>":
          break;
        case "<numFmt":
          {
            var _e = unescapexml(utf8read(he.formatCode)), ve = parseInt(he.numFmtId, 10);
            if (Y.NumberFmt[ve] = _e, ve > 0) {
              if (ve > 392) {
                for (ve = 392; ve > 60 && Y.NumberFmt[ve] != null; --ve) ;
                Y.NumberFmt[ve] = _e;
              }
              SSF__load(_e, ve);
            }
          }
          break;
        case "</numFmt>":
          break;
        default:
          if (re.WTF) throw new Error("unrecognized " + he[0] + " in numFmts");
      }
    }
}
function write_numFmts(le) {
  var Y = ["<numFmts>"];
  return [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(re) {
    for (var oe = re[0]; oe <= re[1]; ++oe) le[oe] != null && (Y[Y.length] = writextag("numFmt", null, { numFmtId: oe, formatCode: escapexml(le[oe]) }));
  }), Y.length === 1 ? "" : (Y[Y.length] = "</numFmts>", Y[0] = writextag("numFmts", null, { count: Y.length - 2 }).replace("/>", ">"), Y.join(""));
}
var cellXF_uint = ["numFmtId", "fillId", "fontId", "borderId", "xfId"], cellXF_bool = ["applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix"];
function parse_cellXfs(le, Y, re) {
  Y.CellXf = [];
  var oe, ue = !1;
  (le.match(tagregex) || []).forEach(function(fe) {
    var he = parsexmltag(fe), _e = 0;
    switch (strip_ns(he[0])) {
      case "<cellXfs":
      case "<cellXfs>":
      case "<cellXfs/>":
      case "</cellXfs>":
        break;
      /* 18.8.45 xf CT_Xf */
      case "<xf":
      case "<xf/>":
      case "<xf>":
        for (oe = he, delete oe[0], _e = 0; _e < cellXF_uint.length; ++_e) oe[cellXF_uint[_e]] && (oe[cellXF_uint[_e]] = parseInt(oe[cellXF_uint[_e]], 10));
        for (_e = 0; _e < cellXF_bool.length; ++_e) oe[cellXF_bool[_e]] && (oe[cellXF_bool[_e]] = parsexmlbool(oe[cellXF_bool[_e]]));
        if (Y.NumberFmt && oe.numFmtId > 392) {
          for (_e = 392; _e > 60; --_e) if (Y.NumberFmt[oe.numFmtId] == Y.NumberFmt[_e]) {
            oe.numFmtId = _e;
            break;
          }
        }
        Y.CellXf.push(oe);
        break;
      case "</xf>":
        break;
      /* 18.8.1 alignment CT_CellAlignment */
      case "<alignment":
      case "<alignment/>":
      case "<alignment>":
        var ve = {};
        he.vertical && (ve.vertical = he.vertical), he.horizontal && (ve.horizontal = he.horizontal), he.textRotation != null && (ve.textRotation = he.textRotation), he.indent && (ve.indent = he.indent), he.wrapText && (ve.wrapText = parsexmlbool(he.wrapText)), oe.alignment = ve;
        break;
      case "</alignment>":
        break;
      /* 18.8.33 protection CT_CellProtection */
      case "<protection":
      case "<protection>":
        break;
      case "</protection>":
      case "<protection/>":
        break;
      /* note: sometimes mc:AlternateContent appears bare */
      case "<AlternateContent":
      case "<AlternateContent>":
        ue = !0;
        break;
      case "</AlternateContent>":
        ue = !1;
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        ue = !0;
        break;
      case "</ext>":
        ue = !1;
        break;
      default:
        if (re && re.WTF && !ue)
          throw new Error("unrecognized " + he[0] + " in cellXfs");
    }
  });
}
function write_cellXfs(le) {
  var Y = [];
  return Y[Y.length] = writextag("cellXfs", null), le.forEach(function(re) {
    Y[Y.length] = writextag("xf", null, re);
  }), Y[Y.length] = "</cellXfs>", Y.length === 2 ? "" : (Y[0] = writextag("cellXfs", null, { count: Y.length - 2 }).replace("/>", ">"), Y.join(""));
}
var parse_sty_xml = /* @__PURE__ */ function le() {
  return function(re, oe, ue) {
    var fe = {};
    if (!re) return fe;
    re = remove_doctype(str_remove_ng(re, "<!--", "-->"));
    var he;
    return (he = str_match_xml_ns(re, "numFmts")) && parse_numFmts(he[0], fe, ue), (he = str_match_xml_ns(re, "fonts")) && parse_fonts(he[0], fe, oe, ue), (he = str_match_xml_ns(re, "fills")) && parse_fills(he[0], fe, oe, ue), (he = str_match_xml_ns(re, "borders")) && parse_borders(he[0], fe, oe, ue), (he = str_match_xml_ns(re, "cellXfs")) && parse_cellXfs(he[0], fe, ue), fe;
  };
}();
function write_sty_xml(le, Y) {
  var re = [XML_HEADER, writextag("styleSheet", null, {
    xmlns: XMLNS_main[0],
    "xmlns:vt": XMLNS.vt
  })], oe;
  return le.SSF && (oe = write_numFmts(le.SSF)) != null && (re[re.length] = oe), re[re.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>', re[re.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>', re[re.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>', re[re.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>', (oe = write_cellXfs(Y.cellXfs)) && (re[re.length] = oe), re[re.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>', re[re.length] = '<dxfs count="0"/>', re[re.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>', re.length > 2 && (re[re.length] = "</styleSheet>", re[1] = re[1].replace("/>", ">")), re.join("");
}
function parse_BrtFmt(le, Y) {
  var re = le.read_shift(2), oe = parse_XLWideString(le);
  return [re, oe];
}
function write_BrtFmt(le, Y, re) {
  re || (re = new_buf(6 + 4 * Y.length)), re.write_shift(2, le), write_XLWideString(Y, re);
  var oe = re.length > re.l ? re.slice(0, re.l) : re;
  return re.l == null && (re.l = re.length), oe;
}
function parse_BrtFont(le, Y, re) {
  var oe = {};
  oe.sz = le.read_shift(2) / 20;
  var ue = parse_FontFlags(le);
  ue.fItalic && (oe.italic = 1), ue.fCondense && (oe.condense = 1), ue.fExtend && (oe.extend = 1), ue.fShadow && (oe.shadow = 1), ue.fOutline && (oe.outline = 1), ue.fStrikeout && (oe.strike = 1);
  var fe = le.read_shift(2);
  switch (fe === 700 && (oe.bold = 1), le.read_shift(2)) {
    /* case 0: out.vertAlign = "baseline"; break; */
    case 1:
      oe.vertAlign = "superscript";
      break;
    case 2:
      oe.vertAlign = "subscript";
      break;
  }
  var he = le.read_shift(1);
  he != 0 && (oe.underline = he);
  var _e = le.read_shift(1);
  _e > 0 && (oe.family = _e);
  var ve = le.read_shift(1);
  switch (ve > 0 && (oe.charset = ve), le.l++, oe.color = parse_BrtColor(le), le.read_shift(1)) {
    /* case 0: out.scheme = "none": break; */
    case 1:
      oe.scheme = "major";
      break;
    case 2:
      oe.scheme = "minor";
      break;
  }
  return oe.name = parse_XLWideString(le), oe;
}
function write_BrtFont(le, Y) {
  Y || (Y = new_buf(25 + 4 * 32)), Y.write_shift(2, le.sz * 20), write_FontFlags(le, Y), Y.write_shift(2, le.bold ? 700 : 400);
  var re = 0;
  le.vertAlign == "superscript" ? re = 1 : le.vertAlign == "subscript" && (re = 2), Y.write_shift(2, re), Y.write_shift(1, le.underline || 0), Y.write_shift(1, le.family || 0), Y.write_shift(1, le.charset || 0), Y.write_shift(1, 0), write_BrtColor(le.color, Y);
  var oe = 0;
  return oe = 2, Y.write_shift(1, oe), write_XLWideString(le.name, Y), Y.length > Y.l ? Y.slice(0, Y.l) : Y;
}
var XLSBFillPTNames = [
  "none",
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
], rev_XLSBFillPTNames, parse_BrtFill = parsenoop;
function write_BrtFill(le, Y) {
  Y || (Y = new_buf(4 * 3 + 8 * 7 + 16 * 1)), rev_XLSBFillPTNames || (rev_XLSBFillPTNames = evert(XLSBFillPTNames));
  var re = rev_XLSBFillPTNames[le.patternType];
  re == null && (re = 40), Y.write_shift(4, re);
  var oe = 0;
  if (re != 40)
    for (write_BrtColor({ auto: 1 }, Y), write_BrtColor({ auto: 1 }, Y); oe < 12; ++oe) Y.write_shift(4, 0);
  else {
    for (; oe < 4; ++oe) Y.write_shift(4, 0);
    for (; oe < 12; ++oe) Y.write_shift(4, 0);
  }
  return Y.length > Y.l ? Y.slice(0, Y.l) : Y;
}
function parse_BrtXF(le, Y) {
  var re = le.l + Y, oe = le.read_shift(2), ue = le.read_shift(2);
  return le.l = re, { ixfe: oe, numFmtId: ue };
}
function write_BrtXF(le, Y, re) {
  re || (re = new_buf(16)), re.write_shift(2, Y || 0), re.write_shift(2, le.numFmtId || 0), re.write_shift(2, 0), re.write_shift(2, 0), re.write_shift(2, 0), re.write_shift(1, 0), re.write_shift(1, 0);
  var oe = 0;
  return re.write_shift(1, oe), re.write_shift(1, 0), re.write_shift(1, 0), re.write_shift(1, 0), re;
}
function write_Blxf(le, Y) {
  return Y || (Y = new_buf(10)), Y.write_shift(1, 0), Y.write_shift(1, 0), Y.write_shift(4, 0), Y.write_shift(4, 0), Y;
}
var parse_BrtBorder = parsenoop;
function write_BrtBorder(le, Y) {
  return Y || (Y = new_buf(51)), Y.write_shift(1, 0), write_Blxf(null, Y), write_Blxf(null, Y), write_Blxf(null, Y), write_Blxf(null, Y), write_Blxf(null, Y), Y.length > Y.l ? Y.slice(0, Y.l) : Y;
}
function write_BrtStyle(le, Y) {
  return Y || (Y = new_buf(12 + 4 * 10)), Y.write_shift(4, le.xfId), Y.write_shift(2, 1), Y.write_shift(1, 0), Y.write_shift(1, 0), write_XLNullableWideString(le.name || "", Y), Y.length > Y.l ? Y.slice(0, Y.l) : Y;
}
function write_BrtBeginTableStyles(le, Y, re) {
  var oe = new_buf(2052);
  return oe.write_shift(4, le), write_XLNullableWideString(Y, oe), write_XLNullableWideString(re, oe), oe.length > oe.l ? oe.slice(0, oe.l) : oe;
}
function parse_sty_bin(le, Y, re) {
  var oe = {};
  oe.NumberFmt = [];
  for (var ue in table_fmt) oe.NumberFmt[ue] = table_fmt[ue];
  oe.CellXf = [], oe.Fonts = [];
  var fe = [], he = !1;
  return recordhopper(le, function(ve, xe, Ee) {
    switch (Ee) {
      case 44:
        oe.NumberFmt[ve[0]] = ve[1], SSF__load(ve[1], ve[0]);
        break;
      case 43:
        oe.Fonts.push(ve), ve.color.theme != null && Y && Y.themeElements && Y.themeElements.clrScheme && (ve.color.rgb = rgb_tint(Y.themeElements.clrScheme[ve.color.theme].rgb, ve.color.tint || 0));
        break;
      case 1025:
        break;
      case 45:
        break;
      case 46:
        break;
      case 47:
        fe[fe.length - 1] == 617 && oe.CellXf.push(ve);
        break;
      case 48:
      /* BrtStyle */
      case 507:
      /* BrtDXF */
      case 572:
      /* BrtMRUColor */
      case 475:
        break;
      case 1171:
      /* BrtDXF14 */
      case 2102:
      /* BrtDXF15 */
      case 1130:
      /* BrtSlicerStyleElement */
      case 512:
      /* BrtTableStyleElement */
      case 2095:
      /* BrtTimelineStyleElement */
      case 3072:
        break;
      case 35:
        he = !0;
        break;
      case 36:
        he = !1;
        break;
      case 37:
        fe.push(Ee), he = !0;
        break;
      case 38:
        fe.pop(), he = !1;
        break;
      default:
        if (xe.T > 0) fe.push(Ee);
        else if (xe.T < 0) fe.pop();
        else if (!he || re.WTF && fe[fe.length - 1] != 37) throw new Error("Unexpected record 0x" + Ee.toString(16));
    }
  }), oe;
}
function write_FMTS_bin(le, Y) {
  if (Y) {
    var re = 0;
    [[5, 8], [23, 26], [41, 44], [
      /*63*/
      50,
      /*66],[164,*/
      392
    ]].forEach(function(oe) {
      for (var ue = oe[0]; ue <= oe[1]; ++ue) Y[ue] != null && ++re;
    }), re != 0 && (write_record(le, 615, write_UInt32LE(re)), [[5, 8], [23, 26], [41, 44], [
      /*63*/
      50,
      /*66],[164,*/
      392
    ]].forEach(function(oe) {
      for (var ue = oe[0]; ue <= oe[1]; ++ue) Y[ue] != null && write_record(le, 44, write_BrtFmt(ue, Y[ue]));
    }), write_record(
      le,
      616
      /* BrtEndFmts */
    ));
  }
}
function write_FONTS_bin(le) {
  var Y = 1;
  write_record(le, 611, write_UInt32LE(Y)), write_record(le, 43, write_BrtFont({
    sz: 12,
    color: { theme: 1 },
    name: "Calibri",
    family: 2
  })), write_record(
    le,
    612
    /* BrtEndFonts */
  );
}
function write_FILLS_bin(le) {
  var Y = 2;
  write_record(le, 603, write_UInt32LE(Y)), write_record(le, 45, write_BrtFill({ patternType: "none" })), write_record(le, 45, write_BrtFill({ patternType: "gray125" })), write_record(
    le,
    604
    /* BrtEndFills */
  );
}
function write_BORDERS_bin(le) {
  var Y = 1;
  write_record(le, 613, write_UInt32LE(Y)), write_record(le, 46, write_BrtBorder()), write_record(
    le,
    614
    /* BrtEndBorders */
  );
}
function write_CELLSTYLEXFS_bin(le) {
  var Y = 1;
  write_record(le, 626, write_UInt32LE(Y)), write_record(le, 47, write_BrtXF({
    numFmtId: 0
  }, 65535)), write_record(
    le,
    627
    /* BrtEndCellStyleXFs */
  );
}
function write_CELLXFS_bin(le, Y) {
  write_record(le, 617, write_UInt32LE(Y.length)), Y.forEach(function(re) {
    write_record(le, 47, write_BrtXF(re, 0));
  }), write_record(
    le,
    618
    /* BrtEndCellXFs */
  );
}
function write_STYLES_bin(le) {
  var Y = 1;
  write_record(le, 619, write_UInt32LE(Y)), write_record(le, 48, write_BrtStyle({
    xfId: 0,
    name: "Normal"
  })), write_record(
    le,
    620
    /* BrtEndStyles */
  );
}
function write_DXFS_bin(le) {
  var Y = 0;
  write_record(le, 505, write_UInt32LE(Y)), write_record(
    le,
    506
    /* BrtEndDXFs */
  );
}
function write_TABLESTYLES_bin(le) {
  var Y = 0;
  write_record(le, 508, write_BrtBeginTableStyles(Y, "TableStyleMedium9", "PivotStyleMedium4")), write_record(
    le,
    509
    /* BrtEndTableStyles */
  );
}
function write_sty_bin(le, Y) {
  var re = buf_array();
  return write_record(
    re,
    278
    /* BrtBeginStyleSheet */
  ), write_FMTS_bin(re, le.SSF), write_FONTS_bin(re), write_FILLS_bin(re), write_BORDERS_bin(re), write_CELLSTYLEXFS_bin(re), write_CELLXFS_bin(re, Y.cellXfs), write_STYLES_bin(re), write_DXFS_bin(re), write_TABLESTYLES_bin(re), write_record(
    re,
    279
    /* BrtEndStyleSheet */
  ), re.end();
}
var XLSXThemeClrScheme = [
  "</a:lt1>",
  "</a:dk1>",
  "</a:lt2>",
  "</a:dk2>",
  "</a:accent1>",
  "</a:accent2>",
  "</a:accent3>",
  "</a:accent4>",
  "</a:accent5>",
  "</a:accent6>",
  "</a:hlink>",
  "</a:folHlink>"
];
function parse_clrScheme(le, Y, re) {
  Y.themeElements.clrScheme = [];
  var oe = {};
  (le[0].match(tagregex) || []).forEach(function(ue) {
    var fe = parsexmltag(ue);
    switch (fe[0]) {
      /* 20.1.6.2 clrScheme (Color Scheme) CT_ColorScheme */
      case "<a:clrScheme":
      case "</a:clrScheme>":
        break;
      /* 20.1.2.3.32 srgbClr CT_SRgbColor */
      case "<a:srgbClr":
        oe.rgb = fe.val;
        break;
      case "</a:srgbClr>":
        break;
      /* 20.1.2.3.33 sysClr CT_SystemColor */
      case "<a:sysClr":
        oe.rgb = fe.lastClr;
        break;
      case "</a:sysClr>":
        break;
      /* 20.1.4.1.1 accent1 (Accent 1) */
      /* 20.1.4.1.2 accent2 (Accent 2) */
      /* 20.1.4.1.3 accent3 (Accent 3) */
      /* 20.1.4.1.4 accent4 (Accent 4) */
      /* 20.1.4.1.5 accent5 (Accent 5) */
      /* 20.1.4.1.6 accent6 (Accent 6) */
      /* 20.1.4.1.9 dk1 (Dark 1) */
      /* 20.1.4.1.10 dk2 (Dark 2) */
      /* 20.1.4.1.15 folHlink (Followed Hyperlink) */
      /* 20.1.4.1.19 hlink (Hyperlink) */
      /* 20.1.4.1.22 lt1 (Light 1) */
      /* 20.1.4.1.23 lt2 (Light 2) */
      case "</a:dk1>":
      case "</a:lt1>":
      case "<a:dk1>":
      case "<a:lt1>":
      case "<a:dk2>":
      case "</a:dk2>":
      case "<a:lt2>":
      case "</a:lt2>":
      case "<a:accent1>":
      case "</a:accent1>":
      case "<a:accent2>":
      case "</a:accent2>":
      case "<a:accent3>":
      case "</a:accent3>":
      case "<a:accent4>":
      case "</a:accent4>":
      case "<a:accent5>":
      case "</a:accent5>":
      case "<a:accent6>":
      case "</a:accent6>":
      case "<a:hlink>":
      case "</a:hlink>":
      case "<a:folHlink>":
      case "</a:folHlink>":
        fe[0].charAt(1) === "/" ? (Y.themeElements.clrScheme[XLSXThemeClrScheme.indexOf(fe[0])] = oe, oe = {}) : oe.name = fe[0].slice(3, fe[0].length - 1);
        break;
      default:
        if (re && re.WTF) throw new Error("Unrecognized " + fe[0] + " in clrScheme");
    }
  });
}
function parse_themeElements(le, Y, re) {
  Y.themeElements = {};
  var oe;
  if (!(oe = str_match_xml(le, "a:clrScheme"))) throw new Error("clrScheme not found in themeElements");
  if (parse_clrScheme(oe, Y, re), !(oe = str_match_xml(le, "a:fontScheme"))) throw new Error("fontScheme not found in themeElements");
  if (!(oe = str_match_xml(le, "a:fmtScheme"))) throw new Error("fmtScheme not found in themeElements");
}
function parse_theme_xml(le, Y) {
  (!le || le.length === 0) && (le = write_theme());
  var re, oe = {};
  if (!(re = str_match_xml(le, "a:themeElements"))) throw new Error("themeElements not found in theme");
  return parse_themeElements(re[0], oe, Y), oe.raw = le, oe;
}
function write_theme(le, Y) {
  if (Y && Y.themeXLSX) return Y.themeXLSX;
  if (le && typeof le.raw == "string") return le.raw;
  var re = [XML_HEADER];
  return re[re.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">', re[re.length] = "<a:themeElements>", re[re.length] = '<a:clrScheme name="Office">', re[re.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>', re[re.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>', re[re.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>', re[re.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>', re[re.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>', re[re.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>', re[re.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>', re[re.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>', re[re.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>', re[re.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>', re[re.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>', re[re.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>', re[re.length] = "</a:clrScheme>", re[re.length] = '<a:fontScheme name="Office">', re[re.length] = "<a:majorFont>", re[re.length] = '<a:latin typeface="Cambria"/>', re[re.length] = '<a:ea typeface=""/>', re[re.length] = '<a:cs typeface=""/>', re[re.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>', re[re.length] = '<a:font script="Hang" typeface="맑은 고딕"/>', re[re.length] = '<a:font script="Hans" typeface="宋体"/>', re[re.length] = '<a:font script="Hant" typeface="新細明體"/>', re[re.length] = '<a:font script="Arab" typeface="Times New Roman"/>', re[re.length] = '<a:font script="Hebr" typeface="Times New Roman"/>', re[re.length] = '<a:font script="Thai" typeface="Tahoma"/>', re[re.length] = '<a:font script="Ethi" typeface="Nyala"/>', re[re.length] = '<a:font script="Beng" typeface="Vrinda"/>', re[re.length] = '<a:font script="Gujr" typeface="Shruti"/>', re[re.length] = '<a:font script="Khmr" typeface="MoolBoran"/>', re[re.length] = '<a:font script="Knda" typeface="Tunga"/>', re[re.length] = '<a:font script="Guru" typeface="Raavi"/>', re[re.length] = '<a:font script="Cans" typeface="Euphemia"/>', re[re.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', re[re.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', re[re.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', re[re.length] = '<a:font script="Thaa" typeface="MV Boli"/>', re[re.length] = '<a:font script="Deva" typeface="Mangal"/>', re[re.length] = '<a:font script="Telu" typeface="Gautami"/>', re[re.length] = '<a:font script="Taml" typeface="Latha"/>', re[re.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', re[re.length] = '<a:font script="Orya" typeface="Kalinga"/>', re[re.length] = '<a:font script="Mlym" typeface="Kartika"/>', re[re.length] = '<a:font script="Laoo" typeface="DokChampa"/>', re[re.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', re[re.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', re[re.length] = '<a:font script="Viet" typeface="Times New Roman"/>', re[re.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', re[re.length] = '<a:font script="Geor" typeface="Sylfaen"/>', re[re.length] = "</a:majorFont>", re[re.length] = "<a:minorFont>", re[re.length] = '<a:latin typeface="Calibri"/>', re[re.length] = '<a:ea typeface=""/>', re[re.length] = '<a:cs typeface=""/>', re[re.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>', re[re.length] = '<a:font script="Hang" typeface="맑은 고딕"/>', re[re.length] = '<a:font script="Hans" typeface="宋体"/>', re[re.length] = '<a:font script="Hant" typeface="新細明體"/>', re[re.length] = '<a:font script="Arab" typeface="Arial"/>', re[re.length] = '<a:font script="Hebr" typeface="Arial"/>', re[re.length] = '<a:font script="Thai" typeface="Tahoma"/>', re[re.length] = '<a:font script="Ethi" typeface="Nyala"/>', re[re.length] = '<a:font script="Beng" typeface="Vrinda"/>', re[re.length] = '<a:font script="Gujr" typeface="Shruti"/>', re[re.length] = '<a:font script="Khmr" typeface="DaunPenh"/>', re[re.length] = '<a:font script="Knda" typeface="Tunga"/>', re[re.length] = '<a:font script="Guru" typeface="Raavi"/>', re[re.length] = '<a:font script="Cans" typeface="Euphemia"/>', re[re.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', re[re.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', re[re.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', re[re.length] = '<a:font script="Thaa" typeface="MV Boli"/>', re[re.length] = '<a:font script="Deva" typeface="Mangal"/>', re[re.length] = '<a:font script="Telu" typeface="Gautami"/>', re[re.length] = '<a:font script="Taml" typeface="Latha"/>', re[re.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', re[re.length] = '<a:font script="Orya" typeface="Kalinga"/>', re[re.length] = '<a:font script="Mlym" typeface="Kartika"/>', re[re.length] = '<a:font script="Laoo" typeface="DokChampa"/>', re[re.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', re[re.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', re[re.length] = '<a:font script="Viet" typeface="Arial"/>', re[re.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', re[re.length] = '<a:font script="Geor" typeface="Sylfaen"/>', re[re.length] = "</a:minorFont>", re[re.length] = "</a:fontScheme>", re[re.length] = '<a:fmtScheme name="Office">', re[re.length] = "<a:fillStyleLst>", re[re.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', re[re.length] = '<a:gradFill rotWithShape="1">', re[re.length] = "<a:gsLst>", re[re.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', re[re.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', re[re.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', re[re.length] = "</a:gsLst>", re[re.length] = '<a:lin ang="16200000" scaled="1"/>', re[re.length] = "</a:gradFill>", re[re.length] = '<a:gradFill rotWithShape="1">', re[re.length] = "<a:gsLst>", re[re.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>', re[re.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', re[re.length] = "</a:gsLst>", re[re.length] = '<a:lin ang="16200000" scaled="0"/>', re[re.length] = "</a:gradFill>", re[re.length] = "</a:fillStyleLst>", re[re.length] = "<a:lnStyleLst>", re[re.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>', re[re.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', re[re.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', re[re.length] = "</a:lnStyleLst>", re[re.length] = "<a:effectStyleLst>", re[re.length] = "<a:effectStyle>", re[re.length] = "<a:effectLst>", re[re.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>', re[re.length] = "</a:effectLst>", re[re.length] = "</a:effectStyle>", re[re.length] = "<a:effectStyle>", re[re.length] = "<a:effectLst>", re[re.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', re[re.length] = "</a:effectLst>", re[re.length] = "</a:effectStyle>", re[re.length] = "<a:effectStyle>", re[re.length] = "<a:effectLst>", re[re.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', re[re.length] = "</a:effectLst>", re[re.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>', re[re.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>', re[re.length] = "</a:effectStyle>", re[re.length] = "</a:effectStyleLst>", re[re.length] = "<a:bgFillStyleLst>", re[re.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', re[re.length] = '<a:gradFill rotWithShape="1">', re[re.length] = "<a:gsLst>", re[re.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', re[re.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', re[re.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>', re[re.length] = "</a:gsLst>", re[re.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>', re[re.length] = "</a:gradFill>", re[re.length] = '<a:gradFill rotWithShape="1">', re[re.length] = "<a:gsLst>", re[re.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', re[re.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>', re[re.length] = "</a:gsLst>", re[re.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>', re[re.length] = "</a:gradFill>", re[re.length] = "</a:bgFillStyleLst>", re[re.length] = "</a:fmtScheme>", re[re.length] = "</a:themeElements>", re[re.length] = "<a:objectDefaults>", re[re.length] = "<a:spDef>", re[re.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>', re[re.length] = "</a:spDef>", re[re.length] = "<a:lnDef>", re[re.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>', re[re.length] = "</a:lnDef>", re[re.length] = "</a:objectDefaults>", re[re.length] = "<a:extraClrSchemeLst/>", re[re.length] = "</a:theme>", re.join("");
}
function parse_Theme(le, Y, re) {
  var oe = le.l + Y, ue = le.read_shift(4);
  if (ue !== 124226) {
    if (!re.cellStyles) {
      le.l = oe;
      return;
    }
    var fe = le.slice(le.l);
    le.l = oe;
    var he;
    try {
      he = zip_read(fe, { type: "array" });
    } catch {
      return;
    }
    var _e = getzipstr(he, "theme/theme/theme1.xml", !0);
    if (_e)
      return parse_theme_xml(_e, re);
  }
}
function parse_ColorTheme(le) {
  return le.read_shift(4);
}
function parse_FullColorExt(le) {
  var Y = {};
  switch (Y.xclrType = le.read_shift(2), Y.nTintShade = le.read_shift(2), Y.xclrType) {
    case 0:
      le.l += 4;
      break;
    case 1:
      Y.xclrValue = parse_IcvXF(le, 4);
      break;
    case 2:
      Y.xclrValue = parse_LongRGBA(le);
      break;
    case 3:
      Y.xclrValue = parse_ColorTheme(le);
      break;
    case 4:
      le.l += 4;
      break;
  }
  return le.l += 8, Y;
}
function parse_IcvXF(le, Y) {
  return parsenoop(le, Y);
}
function parse_XFExtGradient(le, Y) {
  return parsenoop(le, Y);
}
function parse_ExtProp(le) {
  var Y = le.read_shift(2), re = le.read_shift(2) - 4, oe = [Y];
  switch (Y) {
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 13:
      oe[1] = parse_FullColorExt(le);
      break;
    case 6:
      oe[1] = parse_XFExtGradient(le, re);
      break;
    case 14:
    case 15:
      oe[1] = le.read_shift(re === 1 ? 1 : 2);
      break;
    default:
      throw new Error("Unrecognized ExtProp type: " + Y + " " + re);
  }
  return oe;
}
function parse_XFExt(le, Y) {
  var re = le.l + Y;
  le.l += 2;
  var oe = le.read_shift(2);
  le.l += 2;
  for (var ue = le.read_shift(2), fe = []; ue-- > 0; ) fe.push(parse_ExtProp(le, re - le.l));
  return { ixfe: oe, ext: fe };
}
function update_xfext(le, Y) {
  Y.forEach(function(re) {
    re[0];
  });
}
function parse_BrtMdtinfo(le, Y) {
  return {
    flags: le.read_shift(4),
    version: le.read_shift(4),
    name: parse_XLWideString(le)
  };
}
function write_BrtMdtinfo(le) {
  var Y = new_buf(12 + 2 * le.name.length);
  return Y.write_shift(4, le.flags), Y.write_shift(4, le.version), write_XLWideString(le.name, Y), Y.slice(0, Y.l);
}
function parse_BrtMdb(le) {
  for (var Y = [], re = le.read_shift(4); re-- > 0; )
    Y.push([le.read_shift(4), le.read_shift(4)]);
  return Y;
}
function write_BrtMdb(le) {
  var Y = new_buf(4 + 8 * le.length);
  Y.write_shift(4, le.length);
  for (var re = 0; re < le.length; ++re)
    Y.write_shift(4, le[re][0]), Y.write_shift(4, le[re][1]);
  return Y;
}
function write_BrtBeginEsfmd(le, Y) {
  var re = new_buf(8 + 2 * Y.length);
  return re.write_shift(4, le), write_XLWideString(Y, re), re.slice(0, re.l);
}
function parse_BrtBeginEsmdb(le) {
  return le.l += 4, le.read_shift(4) != 0;
}
function write_BrtBeginEsmdb(le, Y) {
  var re = new_buf(8);
  return re.write_shift(4, le), re.write_shift(4, 1), re;
}
function parse_xlmeta_bin(le, Y, re) {
  var oe = { Types: [], Cell: [], Value: [] }, ue = re || {}, fe = [], he = !1, _e = 2;
  return recordhopper(le, function(ve, xe, Ee) {
    switch (Ee) {
      case 335:
        oe.Types.push({ name: ve.name });
        break;
      case 51:
        ve.forEach(function(Se) {
          _e == 1 ? oe.Cell.push({ type: oe.Types[Se[0] - 1].name, index: Se[1] }) : _e == 0 && oe.Value.push({ type: oe.Types[Se[0] - 1].name, index: Se[1] });
        });
        break;
      case 337:
        _e = ve ? 1 : 0;
        break;
      case 338:
        _e = 2;
        break;
      case 35:
        fe.push(Ee), he = !0;
        break;
      case 36:
        fe.pop(), he = !1;
        break;
      default:
        if (!xe.T) {
          if (!he || ue.WTF && fe[fe.length - 1] != 35)
            throw new Error("Unexpected record 0x" + Ee.toString(16));
        }
    }
  }), oe;
}
function write_xlmeta_bin() {
  var le = buf_array();
  return write_record(le, 332), write_record(le, 334, write_UInt32LE(1)), write_record(le, 335, write_BrtMdtinfo({
    name: "XLDAPR",
    version: 12e4,
    flags: 3496657072
  })), write_record(le, 336), write_record(le, 339, write_BrtBeginEsfmd(1, "XLDAPR")), write_record(le, 52), write_record(le, 35, write_UInt32LE(514)), write_record(le, 4096, write_UInt32LE(0)), write_record(le, 4097, writeuint16(1)), write_record(le, 36), write_record(le, 53), write_record(le, 340), write_record(le, 337, write_BrtBeginEsmdb(1)), write_record(le, 51, write_BrtMdb([[1, 0]])), write_record(le, 338), write_record(le, 333), le.end();
}
function parse_xlmeta_xml(le, Y, re) {
  var oe = { Types: [], Cell: [], Value: [] };
  if (!le)
    return oe;
  var ue = !1, fe = 2, he;
  return le.replace(tagregex, function(_e) {
    var ve = parsexmltag(_e);
    switch (strip_ns(ve[0])) {
      case "<?xml":
        break;
      case "<metadata":
      case "</metadata>":
        break;
      case "<metadataTypes":
      case "</metadataTypes>":
        break;
      case "<metadataType":
        oe.Types.push({ name: ve.name });
        break;
      case "</metadataType>":
        break;
      case "<futureMetadata":
        for (var xe = 0; xe < oe.Types.length; ++xe)
          oe.Types[xe].name == ve.name && (he = oe.Types[xe]);
        break;
      case "</futureMetadata>":
        break;
      case "<bk>":
        break;
      case "</bk>":
        break;
      case "<rc":
        fe == 1 ? oe.Cell.push({ type: oe.Types[ve.t - 1].name, index: +ve.v }) : fe == 0 && oe.Value.push({ type: oe.Types[ve.t - 1].name, index: +ve.v });
        break;
      case "</rc>":
        break;
      case "<cellMetadata":
        fe = 1;
        break;
      case "</cellMetadata>":
        fe = 2;
        break;
      case "<valueMetadata":
        fe = 0;
        break;
      case "</valueMetadata>":
        fe = 2;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        ue = !0;
        break;
      case "</ext>":
        ue = !1;
        break;
      case "<rvb":
        if (!he)
          break;
        he.offsets || (he.offsets = []), he.offsets.push(+ve.i);
        break;
      default:
        if (!ue && re?.WTF)
          throw new Error("unrecognized " + ve[0] + " in metadata");
    }
    return _e;
  }), oe;
}
function write_xlmeta_xml() {
  var le = [XML_HEADER];
  return le.push(`<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">
  <metadataTypes count="1">
    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>
  </metadataTypes>
  <futureMetadata name="XLDAPR" count="1">
    <bk>
      <extLst>
        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">
          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>
        </ext>
      </extLst>
    </bk>
  </futureMetadata>
  <cellMetadata count="1">
    <bk>
      <rc t="1" v="0"/>
    </bk>
  </cellMetadata>
</metadata>`), le.join("");
}
function parse_cc_xml(le) {
  var Y = [];
  if (!le) return Y;
  var re = 1;
  return (le.match(tagregex) || []).forEach(function(oe) {
    var ue = parsexmltag(oe);
    switch (ue[0]) {
      case "<?xml":
        break;
      /* 18.6.2  calcChain CT_CalcChain 1 */
      case "<calcChain":
      case "<calcChain>":
      case "</calcChain>":
        break;
      /* 18.6.1  c CT_CalcCell 1 */
      case "<c":
        delete ue[0], ue.i ? re = ue.i : ue.i = re, Y.push(ue);
        break;
    }
  }), Y;
}
function parse_BrtCalcChainItem$(le) {
  var Y = {};
  Y.i = le.read_shift(4);
  var re = {};
  re.r = le.read_shift(4), re.c = le.read_shift(4), Y.r = encode_cell(re);
  var oe = le.read_shift(1);
  return oe & 2 && (Y.l = "1"), oe & 8 && (Y.a = "1"), Y;
}
function parse_cc_bin(le, Y, re) {
  var oe = [];
  return recordhopper(le, function(fe, he, _e) {
    switch (_e) {
      case 63:
        oe.push(fe);
        break;
      default:
        if (!he.T) throw new Error("Unexpected record 0x" + _e.toString(16));
    }
  }), oe;
}
function parse_xlink_xml() {
}
function parse_xlink_bin(le, Y, re, oe) {
  if (!le) return le;
  var ue = oe || {}, fe = !1;
  recordhopper(le, function(_e, ve, xe) {
    switch (xe) {
      case 359:
      /* 'BrtSupTabs' */
      case 363:
      /* 'BrtExternTableStart' */
      case 364:
      /* 'BrtExternTableEnd' */
      case 366:
      /* 'BrtExternRowHdr' */
      case 367:
      /* 'BrtExternCellBlank' */
      case 368:
      /* 'BrtExternCellReal' */
      case 369:
      /* 'BrtExternCellBool' */
      case 370:
      /* 'BrtExternCellError' */
      case 371:
      /* 'BrtExternCellString' */
      case 472:
      /* 'BrtExternValueMeta' */
      case 577:
      /* 'BrtSupNameStart' */
      case 578:
      /* 'BrtSupNameValueStart' */
      case 579:
      /* 'BrtSupNameValueEnd' */
      case 580:
      /* 'BrtSupNameNum' */
      case 581:
      /* 'BrtSupNameErr' */
      case 582:
      /* 'BrtSupNameSt' */
      case 583:
      /* 'BrtSupNameNil' */
      case 584:
      /* 'BrtSupNameBool' */
      case 585:
      /* 'BrtSupNameFmla' */
      case 586:
      /* 'BrtSupNameBits' */
      case 587:
        break;
      case 35:
        fe = !0;
        break;
      case 36:
        fe = !1;
        break;
      default:
        if (!ve.T) {
          if (!fe || ue.WTF) throw new Error("Unexpected record 0x" + xe.toString(16));
        }
    }
  }, ue);
}
function parse_drawing(le, Y) {
  if (!le) return "??";
  var re = (le.match(/<c:chart [^<>]*r:id="([^<>"]*)"/) || ["", ""])[1];
  return Y["!id"][re].Target;
}
function parse_vml(le, Y, re) {
  var oe = 0;
  (str_match_xml_ns_g(le, "shape") || []).forEach(function(ue) {
    var fe = "", he = !0, _e = -1, ve = -1, xe = -1;
    switch (ue.replace(tagregex, function(Se, Te) {
      var Ce = parsexmltag(Se);
      switch (strip_ns(Ce[0])) {
        case "<ClientData":
          Ce.ObjectType && (fe = Ce.ObjectType);
          break;
        case "<Visible":
        case "<Visible/>":
          he = !1;
          break;
        case "<Row":
        case "<Row>":
          _e = Te + Se.length;
          break;
        case "</Row>":
          ve = +ue.slice(_e, Te).trim();
          break;
        case "<Column":
        case "<Column>":
          _e = Te + Se.length;
          break;
        case "</Column>":
          xe = +ue.slice(_e, Te).trim();
          break;
      }
      return "";
    }), fe) {
      case "Note":
        var Ee = ws_get_cell_stub(Y, ve >= 0 && xe >= 0 ? encode_cell({ r: ve, c: xe }) : re[oe].ref);
        Ee.c && (Ee.c.hidden = he), ++oe;
        break;
    }
  });
}
function write_vml(le, Y, re) {
  var oe = [21600, 21600], ue = ["m0,0l0", oe[1], oe[0], oe[1], oe[0], "0xe"].join(","), fe = [
    writextag("xml", null, { "xmlns:v": XLMLNS.v, "xmlns:o": XLMLNS.o, "xmlns:x": XLMLNS.x, "xmlns:mv": XLMLNS.mv }).replace(/\/>/, ">"),
    writextag("o:shapelayout", writextag("o:idmap", null, { "v:ext": "edit", data: le }), { "v:ext": "edit" })
  ], he = 65536 * le, _e = Y || [];
  return _e.length > 0 && fe.push(writextag("v:shapetype", [
    writextag("v:stroke", null, { joinstyle: "miter" }),
    writextag("v:path", null, { gradientshapeok: "t", "o:connecttype": "rect" })
  ].join(""), { id: "_x0000_t202", coordsize: oe.join(","), "o:spt": 202, path: ue })), _e.forEach(function(ve) {
    ++he, fe.push(write_vml_comment(ve, he));
  }), fe.push("</xml>"), fe.join("");
}
function write_vml_comment(le, Y, re) {
  var oe = decode_cell(le[0]), ue = (
    /*::(*/
    { color2: "#BEFF82", type: "gradient" }
  );
  ue.type == "gradient" && (ue.angle = "-180");
  var fe = ue.type == "gradient" ? writextag("o:fill", null, { type: "gradientUnscaled", "v:ext": "view" }) : null, he = writextag("v:fill", fe, ue), _e = { on: "t", obscured: "t" };
  return [
    "<v:shape" + wxt_helper({
      id: "_x0000_s" + Y,
      type: "#_x0000_t202",
      style: "position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (le[1].hidden ? ";visibility:hidden" : ""),
      fillcolor: "#ECFAD4",
      strokecolor: "#edeaa1"
    }) + ">",
    he,
    writextag("v:shadow", null, _e),
    writextag("v:path", null, { "o:connecttype": "none" }),
    '<v:textbox><div style="text-align:left"></div></v:textbox>',
    '<x:ClientData ObjectType="Note">',
    "<x:MoveWithCells/>",
    "<x:SizeWithCells/>",
    /* Part 4 19.4.2.3 Anchor (Anchor) */
    writetag("x:Anchor", [oe.c + 1, 0, oe.r + 1, 0, oe.c + 3, 20, oe.r + 5, 20].join(",")),
    writetag("x:AutoFill", "False"),
    writetag("x:Row", String(oe.r)),
    writetag("x:Column", String(oe.c)),
    le[1].hidden ? "" : "<x:Visible/>",
    "</x:ClientData>",
    "</v:shape>"
  ].join("");
}
function sheet_insert_comments(le, Y, re, oe) {
  var ue = le["!data"] != null, fe;
  Y.forEach(function(he) {
    var _e = decode_cell(he.ref);
    if (!(_e.r < 0 || _e.c < 0)) {
      if (ue ? (le["!data"][_e.r] || (le["!data"][_e.r] = []), fe = le["!data"][_e.r][_e.c]) : fe = le[he.ref], !fe) {
        fe = { t: "z" }, ue ? le["!data"][_e.r][_e.c] = fe : le[he.ref] = fe;
        var ve = safe_decode_range(le["!ref"] || "BDWGO1000001:A1");
        ve.s.r > _e.r && (ve.s.r = _e.r), ve.e.r < _e.r && (ve.e.r = _e.r), ve.s.c > _e.c && (ve.s.c = _e.c), ve.e.c < _e.c && (ve.e.c = _e.c);
        var xe = encode_range(ve);
        le["!ref"] = xe;
      }
      fe.c || (fe.c = []);
      var Ee = { a: he.author, t: he.t, r: he.r, T: re };
      he.h && (Ee.h = he.h);
      for (var Se = fe.c.length - 1; Se >= 0; --Se) {
        if (!re && fe.c[Se].T) return;
        re && !fe.c[Se].T && fe.c.splice(Se, 1);
      }
      if (re && oe) {
        for (Se = 0; Se < oe.length; ++Se)
          if (Ee.a == oe[Se].id) {
            Ee.a = oe[Se].name || Ee.a;
            break;
          }
      }
      fe.c.push(Ee);
    }
  });
}
function parse_comments_xml(le, Y) {
  if (le.match(/<(?:\w+:)?comments *\/>/)) return [];
  var re = [], oe = [], ue = str_match_xml_ns(le, "authors");
  ue && ue[1] && ue[1].split(/<\/\w*:?author>/).forEach(function(he) {
    if (!(he === "" || he.trim() === "")) {
      var _e = he.match(/<(?:\w+:)?author[^<>]*>(.*)/);
      _e && re.push(_e[1]);
    }
  });
  var fe = str_match_xml_ns(le, "commentList");
  return fe && fe[1] && fe[1].split(/<\/\w*:?comment>/).forEach(function(he) {
    if (!(he === "" || he.trim() === "")) {
      var _e = he.match(/<(?:\w+:)?comment[^<>]*>/);
      if (_e) {
        var ve = parsexmltag(_e[0]), xe = { author: ve.authorId && re[ve.authorId] || "sheetjsghost", ref: ve.ref, guid: ve.guid }, Ee = decode_cell(ve.ref);
        if (!(Y.sheetRows && Y.sheetRows <= Ee.r)) {
          var Se = str_match_xml_ns(he, "text"), Te = !!Se && !!Se[1] && parse_si(Se[1]) || { r: "", t: "", h: "" };
          xe.r = Te.r, Te.r == "<t></t>" && (Te.t = Te.h = ""), xe.t = (Te.t || "").replace(/\r\n/g, `
`).replace(/\r/g, `
`), Y.cellHTML && (xe.h = Te.h), oe.push(xe);
        }
      }
    }
  }), oe;
}
function write_comments_xml(le) {
  var Y = [XML_HEADER, writextag("comments", null, { xmlns: XMLNS_main[0] })], re = [];
  return Y.push("<authors>"), le.forEach(function(oe) {
    oe[1].forEach(function(ue) {
      var fe = escapexml(ue.a);
      re.indexOf(fe) == -1 && (re.push(fe), Y.push("<author>" + fe + "</author>")), ue.T && ue.ID && re.indexOf("tc=" + ue.ID) == -1 && (re.push("tc=" + ue.ID), Y.push("<author>tc=" + ue.ID + "</author>"));
    });
  }), re.length == 0 && (re.push("SheetJ5"), Y.push("<author>SheetJ5</author>")), Y.push("</authors>"), Y.push("<commentList>"), le.forEach(function(oe) {
    var ue = 0, fe = [], he = 0;
    if (oe[1][0] && oe[1][0].T && oe[1][0].ID && (ue = re.indexOf("tc=" + oe[1][0].ID)), oe[1].forEach(function(xe) {
      xe.a && (ue = re.indexOf(escapexml(xe.a))), xe.T && ++he, fe.push(xe.t == null ? "" : escapexml(xe.t));
    }), he === 0)
      oe[1].forEach(function(xe) {
        Y.push('<comment ref="' + oe[0] + '" authorId="' + re.indexOf(escapexml(xe.a)) + '"><text>'), Y.push(writetag("t", xe.t == null ? "" : escapexml(xe.t))), Y.push("</text></comment>");
      });
    else {
      oe[1][0] && oe[1][0].T && oe[1][0].ID && (ue = re.indexOf("tc=" + oe[1][0].ID)), Y.push('<comment ref="' + oe[0] + '" authorId="' + ue + '"><text>');
      for (var _e = `Comment:
    ` + fe[0] + `
`, ve = 1; ve < fe.length; ++ve) _e += `Reply:
    ` + fe[ve] + `
`;
      Y.push(writetag("t", escapexml(_e))), Y.push("</text></comment>");
    }
  }), Y.push("</commentList>"), Y.length > 2 && (Y[Y.length] = "</comments>", Y[1] = Y[1].replace("/>", ">")), Y.join("");
}
function parse_tcmnt_xml(le, Y) {
  var re = [], oe = !1, ue = {}, fe = 0;
  return le.replace(tagregex, function(_e, ve) {
    var xe = parsexmltag(_e);
    switch (strip_ns(xe[0])) {
      case "<?xml":
        break;
      /* 2.6.207 ThreadedComments CT_ThreadedComments */
      case "<ThreadedComments":
        break;
      case "</ThreadedComments>":
        break;
      /* 2.6.205 threadedComment CT_ThreadedComment */
      case "<threadedComment":
        ue = { author: xe.personId, guid: xe.id, ref: xe.ref, T: 1 };
        break;
      case "</threadedComment>":
        ue.t != null && re.push(ue);
        break;
      case "<text>":
      case "<text":
        fe = ve + _e.length;
        break;
      case "</text>":
        ue.t = le.slice(fe, ve).replace(/\r\n/g, `
`).replace(/\r/g, `
`);
        break;
      /* 2.6.206 mentions CT_ThreadedCommentMentions TODO */
      case "<mentions":
      case "<mentions>":
        oe = !0;
        break;
      case "</mentions>":
        oe = !1;
        break;
      /* 2.6.202 mention CT_Mention TODO */
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      /* 18.2.7  ext CT_Extension + */
      case "<ext":
        oe = !0;
        break;
      case "</ext>":
        oe = !1;
        break;
      default:
        if (!oe && Y.WTF) throw new Error("unrecognized " + xe[0] + " in threaded comments");
    }
    return _e;
  }), re;
}
function write_tcmnt_xml(le, Y, re) {
  var oe = [XML_HEADER, writextag("ThreadedComments", null, { xmlns: XMLNS.TCMNT }).replace(/[\/]>/, ">")];
  return le.forEach(function(ue) {
    var fe = "";
    (ue[1] || []).forEach(function(he, _e) {
      if (!he.T) {
        delete he.ID;
        return;
      }
      he.a && Y.indexOf(he.a) == -1 && Y.push(he.a);
      var ve = {
        ref: ue[0],
        id: "{54EE7951-7262-4200-6969-" + ("000000000000" + re.tcid++).slice(-12) + "}"
      };
      _e == 0 ? fe = ve.id : ve.parentId = fe, he.ID = ve.id, he.a && (ve.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + Y.indexOf(he.a)).slice(-12) + "}"), oe.push(writextag("threadedComment", writetag("text", he.t || ""), ve));
    });
  }), oe.push("</ThreadedComments>"), oe.join("");
}
function parse_people_xml(le, Y) {
  var re = [], oe = !1;
  return le.replace(tagregex, function(fe) {
    var he = parsexmltag(fe);
    switch (strip_ns(he[0])) {
      case "<?xml":
        break;
      /* 2.4.85 personList CT_PersonList */
      case "<personList":
        break;
      case "</personList>":
        break;
      /* 2.6.203 person CT_Person TODO: providers */
      case "<person":
        re.push({ name: he.displayname, id: he.id });
        break;
      case "</person>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      /* 18.2.7  ext CT_Extension + */
      case "<ext":
        oe = !0;
        break;
      case "</ext>":
        oe = !1;
        break;
      default:
        if (!oe && Y.WTF) throw new Error("unrecognized " + he[0] + " in threaded comments");
    }
    return fe;
  }), re;
}
function write_people_xml(le) {
  var Y = [XML_HEADER, writextag("personList", null, {
    xmlns: XMLNS.TCMNT,
    "xmlns:x": XMLNS_main[0]
  }).replace(/[\/]>/, ">")];
  return le.forEach(function(re, oe) {
    Y.push(writextag("person", null, {
      displayName: re,
      id: "{54EE7950-7262-4200-6969-" + ("000000000000" + oe).slice(-12) + "}",
      userId: re,
      providerId: "None"
    }));
  }), Y.push("</personList>"), Y.join("");
}
function parse_BrtBeginComment(le) {
  var Y = {};
  Y.iauthor = le.read_shift(4);
  var re = parse_UncheckedRfX(le);
  return Y.rfx = re.s, Y.ref = encode_cell(re.s), le.l += 16, Y;
}
function write_BrtBeginComment(le, Y) {
  return Y == null && (Y = new_buf(36)), Y.write_shift(4, le[1].iauthor), write_UncheckedRfX(le[0], Y), Y.write_shift(4, 0), Y.write_shift(4, 0), Y.write_shift(4, 0), Y.write_shift(4, 0), Y;
}
var parse_BrtCommentAuthor = parse_XLWideString;
function write_BrtCommentAuthor(le) {
  return write_XLWideString(le.slice(0, 54));
}
function parse_comments_bin(le, Y) {
  var re = [], oe = [], ue = {}, fe = !1;
  return recordhopper(le, function(_e, ve, xe) {
    switch (xe) {
      case 632:
        oe.push(_e);
        break;
      case 635:
        ue = _e;
        break;
      case 637:
        ue.t = _e.t, ue.h = _e.h, ue.r = _e.r;
        break;
      case 636:
        if (ue.author = oe[ue.iauthor], delete ue.iauthor, Y.sheetRows && ue.rfx && Y.sheetRows <= ue.rfx.r) break;
        ue.t || (ue.t = ""), delete ue.rfx, re.push(ue);
        break;
      case 3072:
        break;
      case 35:
        fe = !0;
        break;
      case 36:
        fe = !1;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (!ve.T) {
          if (!fe || Y.WTF) throw new Error("Unexpected record 0x" + xe.toString(16));
        }
    }
  }), re;
}
function write_comments_bin(le) {
  var Y = buf_array(), re = [];
  return write_record(
    Y,
    628
    /* BrtBeginComments */
  ), write_record(
    Y,
    630
    /* BrtBeginCommentAuthors */
  ), le.forEach(function(oe) {
    oe[1].forEach(function(ue) {
      re.indexOf(ue.a) > -1 || (re.push(ue.a.slice(0, 54)), write_record(Y, 632, write_BrtCommentAuthor(ue.a)), ue.T && ue.ID && re.indexOf("tc=" + ue.ID) == -1 && (re.push("tc=" + ue.ID), write_record(Y, 632, write_BrtCommentAuthor("tc=" + ue.ID))));
    });
  }), write_record(
    Y,
    631
    /* BrtEndCommentAuthors */
  ), write_record(
    Y,
    633
    /* BrtBeginCommentList */
  ), le.forEach(function(oe) {
    oe[1].forEach(function(ue) {
      var fe = -1;
      ue.ID && (fe = re.indexOf("tc=" + ue.ID)), fe == -1 && oe[1][0].T && oe[1][0].ID && (fe = re.indexOf("tc=" + oe[1][0].ID)), fe == -1 && (fe = re.indexOf(ue.a)), ue.iauthor = fe;
      var he = { s: decode_cell(oe[0]), e: decode_cell(oe[0]) };
      write_record(Y, 635, write_BrtBeginComment([he, ue])), ue.t && ue.t.length > 0 && write_record(Y, 637, write_BrtCommentText(ue)), write_record(
        Y,
        636
        /* BrtEndComment */
      ), delete ue.iauthor;
    });
  }), write_record(
    Y,
    634
    /* BrtEndCommentList */
  ), write_record(
    Y,
    629
    /* BrtEndComments */
  ), Y.end();
}
var CT_VBA = "application/vnd.ms-office.vbaProject";
function make_vba_xls(le) {
  var Y = CFB.utils.cfb_new({ root: "R" });
  return le.FullPaths.forEach(function(re, oe) {
    if (!(re.slice(-1) === "/" || !re.match(/_VBA_PROJECT_CUR/))) {
      var ue = re.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");
      CFB.utils.cfb_add(Y, ue, le.FileIndex[oe].content);
    }
  }), CFB.write(Y);
}
function fill_vba_xls(le, Y) {
  Y.FullPaths.forEach(function(re, oe) {
    if (oe != 0) {
      var ue = re.replace(/^[\/]*[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
      ue.slice(-1) !== "/" && CFB.utils.cfb_add(le, ue, Y.FileIndex[oe].content);
    }
  });
}
var VBAFMTS = ["xlsb", "xlsm", "xlam", "biff8", "xla"];
function parse_ds_bin() {
  return { "!type": "dialog" };
}
function parse_ds_xml() {
  return { "!type": "dialog" };
}
function parse_ms_bin() {
  return { "!type": "macro" };
}
function parse_ms_xml() {
  return { "!type": "macro" };
}
var rc_to_a1 = /* @__PURE__ */ function() {
  var le = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g, Y = { r: 0, c: 0 };
  function re(oe, ue, fe, he) {
    var _e = !1, ve = !1;
    fe.length == 0 ? ve = !0 : fe.charAt(0) == "[" && (ve = !0, fe = fe.slice(1, -1)), he.length == 0 ? _e = !0 : he.charAt(0) == "[" && (_e = !0, he = he.slice(1, -1));
    var xe = fe.length > 0 ? parseInt(fe, 10) | 0 : 0, Ee = he.length > 0 ? parseInt(he, 10) | 0 : 0;
    return _e ? Ee += Y.c : --Ee, ve ? xe += Y.r : --xe, ue + (_e ? "" : "$") + encode_col(Ee) + (ve ? "" : "$") + encode_row(xe);
  }
  return function(ue, fe) {
    return Y = fe, ue.replace(le, re);
  };
}(), crefregex = /(^|[^._A-Z0-9])(\$?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])(\$?)(\d{1,7})(?![_.\(A-Za-z0-9])/g;
try {
  crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
} catch (le) {
}
var a1_to_rc = /* @__PURE__ */ function() {
  return function(Y, re) {
    return Y.replace(crefregex, function(oe, ue, fe, he, _e, ve) {
      var xe = decode_col(he) - (fe ? 0 : re.c), Ee = decode_row(ve) - (_e ? 0 : re.r), Se = _e == "$" ? Ee + 1 : Ee == 0 ? "" : "[" + Ee + "]", Te = fe == "$" ? xe + 1 : xe == 0 ? "" : "[" + xe + "]";
      return ue + "R" + Se + "C" + Te;
    });
  };
}();
function shift_formula_str(le, Y) {
  return le.replace(crefregex, function(re, oe, ue, fe, he, _e) {
    return oe + (ue == "$" ? ue + fe : encode_col(decode_col(fe) + Y.c)) + (he == "$" ? he + _e : encode_row(decode_row(_e) + Y.r));
  });
}
function shift_formula_xlsx(le, Y, re) {
  var oe = decode_range(Y), ue = oe.s, fe = decode_cell(re), he = { r: fe.r - ue.r, c: fe.c - ue.c };
  return shift_formula_str(le, he);
}
function fuzzyfmla(le) {
  return le.length != 1;
}
function _xlfn(le) {
  return le.replace(/_xlfn\./g, "");
}
function parseread1(le) {
  le.l += 1;
}
function parse_ColRelU(le, Y) {
  var re = le.read_shift(2);
  return [re & 16383, re >> 14 & 1, re >> 15 & 1];
}
function parse_RgceArea(le, Y, re) {
  var oe = 2;
  if (re) {
    if (re.biff >= 2 && re.biff <= 5) return parse_RgceArea_BIFF2(le);
    re.biff == 12 && (oe = 4);
  }
  var ue = le.read_shift(oe), fe = le.read_shift(oe), he = parse_ColRelU(le), _e = parse_ColRelU(le);
  return { s: { r: ue, c: he[0], cRel: he[1], rRel: he[2] }, e: { r: fe, c: _e[0], cRel: _e[1], rRel: _e[2] } };
}
function parse_RgceArea_BIFF2(le) {
  var Y = parse_ColRelU(le), re = parse_ColRelU(le), oe = le.read_shift(1), ue = le.read_shift(1);
  return { s: { r: Y[0], c: oe, cRel: Y[1], rRel: Y[2] }, e: { r: re[0], c: ue, cRel: re[1], rRel: re[2] } };
}
function parse_RgceAreaRel(le, Y, re) {
  if (re.biff < 8) return parse_RgceArea_BIFF2(le);
  var oe = le.read_shift(re.biff == 12 ? 4 : 2), ue = le.read_shift(re.biff == 12 ? 4 : 2), fe = parse_ColRelU(le), he = parse_ColRelU(le);
  return { s: { r: oe, c: fe[0], cRel: fe[1], rRel: fe[2] }, e: { r: ue, c: he[0], cRel: he[1], rRel: he[2] } };
}
function parse_RgceLoc(le, Y, re) {
  if (re && re.biff >= 2 && re.biff <= 5) return parse_RgceLoc_BIFF2(le);
  var oe = le.read_shift(re && re.biff == 12 ? 4 : 2), ue = parse_ColRelU(le);
  return { r: oe, c: ue[0], cRel: ue[1], rRel: ue[2] };
}
function parse_RgceLoc_BIFF2(le) {
  var Y = parse_ColRelU(le), re = le.read_shift(1);
  return { r: Y[0], c: re, cRel: Y[1], rRel: Y[2] };
}
function parse_RgceElfLoc(le) {
  var Y = le.read_shift(2), re = le.read_shift(2);
  return { r: Y, c: re & 255, fQuoted: !!(re & 16384), cRel: re >> 15, rRel: re >> 15 };
}
function parse_RgceLocRel(le, Y, re) {
  var oe = re && re.biff ? re.biff : 8;
  if (oe >= 2 && oe <= 5) return parse_RgceLocRel_BIFF2(le);
  var ue = le.read_shift(oe >= 12 ? 4 : 2), fe = le.read_shift(2), he = (fe & 16384) >> 14, _e = (fe & 32768) >> 15;
  if (fe &= 16383, _e == 1) for (; ue > 524287; ) ue -= 1048576;
  if (he == 1) for (; fe > 8191; ) fe = fe - 16384;
  return { r: ue, c: fe, cRel: he, rRel: _e };
}
function parse_RgceLocRel_BIFF2(le) {
  var Y = le.read_shift(2), re = le.read_shift(1), oe = (Y & 32768) >> 15, ue = (Y & 16384) >> 14;
  return Y &= 16383, oe == 1 && Y >= 8192 && (Y = Y - 16384), ue == 1 && re >= 128 && (re = re - 256), { r: Y, c: re, cRel: ue, rRel: oe };
}
function parse_PtgArea(le, Y, re) {
  var oe = (le[le.l++] & 96) >> 5, ue = parse_RgceArea(le, re.biff >= 2 && re.biff <= 5 ? 6 : 8, re);
  return [oe, ue];
}
function parse_PtgArea3d(le, Y, re) {
  var oe = (le[le.l++] & 96) >> 5, ue = le.read_shift(2, "i"), fe = 8;
  if (re) switch (re.biff) {
    case 5:
      le.l += 12, fe = 6;
      break;
    case 12:
      fe = 12;
      break;
  }
  var he = parse_RgceArea(le, fe, re);
  return [oe, ue, he];
}
function parse_PtgAreaErr(le, Y, re) {
  var oe = (le[le.l++] & 96) >> 5;
  return le.l += re && re.biff > 8 ? 12 : re.biff < 8 ? 6 : 8, [oe];
}
function parse_PtgAreaErr3d(le, Y, re) {
  var oe = (le[le.l++] & 96) >> 5, ue = le.read_shift(2), fe = 8;
  if (re) switch (re.biff) {
    case 5:
      le.l += 12, fe = 6;
      break;
    case 12:
      fe = 12;
      break;
  }
  return le.l += fe, [oe, ue];
}
function parse_PtgAreaN(le, Y, re) {
  var oe = (le[le.l++] & 96) >> 5, ue = parse_RgceAreaRel(le, Y - 1, re);
  return [oe, ue];
}
function parse_PtgArray(le, Y, re) {
  var oe = (le[le.l++] & 96) >> 5;
  return le.l += re.biff == 2 ? 6 : re.biff == 12 ? 14 : 7, [oe];
}
function parse_PtgAttrBaxcel(le) {
  var Y = le[le.l + 1] & 1, re = 1;
  return le.l += 4, [Y, re];
}
function parse_PtgAttrChoose(le, Y, re) {
  le.l += 2;
  for (var oe = le.read_shift(re && re.biff == 2 ? 1 : 2), ue = [], fe = 0; fe <= oe; ++fe) ue.push(le.read_shift(re && re.biff == 2 ? 1 : 2));
  return ue;
}
function parse_PtgAttrGoto(le, Y, re) {
  var oe = le[le.l + 1] & 255 ? 1 : 0;
  return le.l += 2, [oe, le.read_shift(re && re.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIf(le, Y, re) {
  var oe = le[le.l + 1] & 255 ? 1 : 0;
  return le.l += 2, [oe, le.read_shift(re && re.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIfError(le) {
  var Y = le[le.l + 1] & 255 ? 1 : 0;
  return le.l += 2, [Y, le.read_shift(2)];
}
function parse_PtgAttrSemi(le, Y, re) {
  var oe = le[le.l + 1] & 255 ? 1 : 0;
  return le.l += re && re.biff == 2 ? 3 : 4, [oe];
}
function parse_PtgAttrSpaceType(le) {
  var Y = le.read_shift(1), re = le.read_shift(1);
  return [Y, re];
}
function parse_PtgAttrSpace(le) {
  return le.read_shift(2), parse_PtgAttrSpaceType(le);
}
function parse_PtgAttrSpaceSemi(le) {
  return le.read_shift(2), parse_PtgAttrSpaceType(le);
}
function parse_PtgRef(le, Y, re) {
  var oe = (le[le.l] & 96) >> 5;
  le.l += 1;
  var ue = parse_RgceLoc(le, 0, re);
  return [oe, ue];
}
function parse_PtgRefN(le, Y, re) {
  var oe = (le[le.l] & 96) >> 5;
  le.l += 1;
  var ue = parse_RgceLocRel(le, 0, re);
  return [oe, ue];
}
function parse_PtgRef3d(le, Y, re) {
  var oe = (le[le.l] & 96) >> 5;
  le.l += 1;
  var ue = le.read_shift(2);
  re && re.biff == 5 && (le.l += 12);
  var fe = parse_RgceLoc(le, 0, re);
  return [oe, ue, fe];
}
function parse_PtgFunc(le, Y, re) {
  var oe = (le[le.l] & 96) >> 5;
  le.l += 1;
  var ue = le.read_shift(re && re.biff <= 3 ? 1 : 2);
  return [FtabArgc[ue], Ftab[ue], oe];
}
function parse_PtgFuncVar(le, Y, re) {
  var oe = le[le.l++], ue = le.read_shift(1), fe = re && re.biff <= 3 ? [oe == 88 ? -1 : 0, le.read_shift(1)] : parsetab(le);
  return [ue, (fe[0] === 0 ? Ftab : Cetab)[fe[1]]];
}
function parsetab(le) {
  return [le[le.l + 1] >> 7, le.read_shift(2) & 32767];
}
function parse_PtgAttrSum(le, Y, re) {
  le.l += re && re.biff == 2 ? 3 : 4;
}
function parse_PtgExp(le, Y, re) {
  if (le.l++, re && re.biff == 12) return [le.read_shift(4, "i"), 0];
  var oe = le.read_shift(2), ue = le.read_shift(re && re.biff == 2 ? 1 : 2);
  return [oe, ue];
}
function parse_PtgErr(le) {
  return le.l++, BErr[le.read_shift(1)];
}
function parse_PtgInt(le) {
  return le.l++, le.read_shift(2);
}
function parse_PtgBool(le) {
  return le.l++, le.read_shift(1) !== 0;
}
function parse_PtgNum(le) {
  return le.l++, parse_Xnum(le);
}
function parse_PtgStr(le, Y, re) {
  return le.l++, parse_ShortXLUnicodeString(le, Y - 1, re);
}
function parse_SerAr(le, Y) {
  var re = [le.read_shift(1)];
  if (Y == 12) switch (re[0]) {
    case 2:
      re[0] = 4;
      break;
    /* SerBool */
    case 4:
      re[0] = 16;
      break;
    /* SerErr */
    case 0:
      re[0] = 1;
      break;
    /* SerNum */
    case 1:
      re[0] = 2;
      break;
  }
  switch (re[0]) {
    case 4:
      re[1] = parsebool(le, 1) ? "TRUE" : "FALSE", Y != 12 && (le.l += 7);
      break;
    case 37:
    /* appears to be an alias */
    case 16:
      re[1] = BErr[le[le.l]], le.l += Y == 12 ? 4 : 8;
      break;
    case 0:
      le.l += 8;
      break;
    case 1:
      re[1] = parse_Xnum(le);
      break;
    case 2:
      re[1] = parse_XLUnicodeString2(le, 0, { biff: Y > 0 && Y < 8 ? 2 : Y });
      break;
    default:
      throw new Error("Bad SerAr: " + re[0]);
  }
  return re;
}
function parse_PtgExtraMem(le, Y, re) {
  for (var oe = le.read_shift(re.biff == 12 ? 4 : 2), ue = [], fe = 0; fe != oe; ++fe) ue.push((re.biff == 12 ? parse_UncheckedRfX : parse_Ref8U)(le));
  return ue;
}
function parse_PtgExtraArray(le, Y, re) {
  var oe = 0, ue = 0;
  re.biff == 12 ? (oe = le.read_shift(4), ue = le.read_shift(4)) : (ue = 1 + le.read_shift(1), oe = 1 + le.read_shift(2)), re.biff >= 2 && re.biff < 8 && (--oe, --ue == 0 && (ue = 256));
  for (var fe = 0, he = []; fe != oe && (he[fe] = []); ++fe)
    for (var _e = 0; _e != ue; ++_e) he[fe][_e] = parse_SerAr(le, re.biff);
  return he;
}
function parse_PtgName(le, Y, re) {
  var oe = le.read_shift(1) >>> 5 & 3, ue = !re || re.biff >= 8 ? 4 : 2, fe = le.read_shift(ue);
  switch (re.biff) {
    case 2:
      le.l += 5;
      break;
    case 3:
    case 4:
      le.l += 8;
      break;
    case 5:
      le.l += 12;
      break;
  }
  return [oe, 0, fe];
}
function parse_PtgNameX(le, Y, re) {
  if (re.biff == 5) return parse_PtgNameX_BIFF5(le);
  var oe = le.read_shift(1) >>> 5 & 3, ue = le.read_shift(2), fe = le.read_shift(4);
  return [oe, ue, fe];
}
function parse_PtgNameX_BIFF5(le) {
  var Y = le.read_shift(1) >>> 5 & 3, re = le.read_shift(2, "i");
  le.l += 8;
  var oe = le.read_shift(2);
  return le.l += 12, [Y, re, oe];
}
function parse_PtgMemArea(le, Y, re) {
  var oe = le.read_shift(1) >>> 5 & 3;
  le.l += re && re.biff == 2 ? 3 : 4;
  var ue = le.read_shift(re && re.biff == 2 ? 1 : 2);
  return [oe, ue];
}
function parse_PtgMemFunc(le, Y, re) {
  var oe = le.read_shift(1) >>> 5 & 3, ue = le.read_shift(re && re.biff == 2 ? 1 : 2);
  return [oe, ue];
}
function parse_PtgRefErr(le, Y, re) {
  var oe = le.read_shift(1) >>> 5 & 3;
  return le.l += 4, re.biff < 8 && le.l--, re.biff == 12 && (le.l += 2), [oe];
}
function parse_PtgRefErr3d(le, Y, re) {
  var oe = (le[le.l++] & 96) >> 5, ue = le.read_shift(2), fe = 4;
  if (re) switch (re.biff) {
    case 5:
      fe = 15;
      break;
    case 12:
      fe = 6;
      break;
  }
  return le.l += fe, [oe, ue];
}
var parse_PtgMemErr = parsenoop, parse_PtgMemNoMem = parsenoop, parse_PtgTbl = parsenoop;
function parse_PtgElfLoc(le, Y, re) {
  return le.l += 2, [parse_RgceElfLoc(le)];
}
function parse_PtgElfNoop(le) {
  return le.l += 6, [];
}
var parse_PtgElfCol = parse_PtgElfLoc, parse_PtgElfColS = parse_PtgElfNoop, parse_PtgElfColSV = parse_PtgElfNoop, parse_PtgElfColV = parse_PtgElfLoc;
function parse_PtgElfLel(le) {
  return le.l += 2, [parseuint16(le), le.read_shift(2) & 1];
}
var parse_PtgElfRadical = parse_PtgElfLoc, parse_PtgElfRadicalLel = parse_PtgElfLel, parse_PtgElfRadicalS = parse_PtgElfNoop, parse_PtgElfRw = parse_PtgElfLoc, parse_PtgElfRwV = parse_PtgElfLoc, PtgListRT = [
  "Data",
  "All",
  "Headers",
  "??",
  "?Data2",
  "??",
  "?DataHeaders",
  "??",
  "Totals",
  "??",
  "??",
  "??",
  "?DataTotals",
  "??",
  "??",
  "??",
  "?Current"
];
function parse_PtgList(le) {
  le.l += 2;
  var Y = le.read_shift(2), re = le.read_shift(2), oe = le.read_shift(4), ue = le.read_shift(2), fe = le.read_shift(2), he = PtgListRT[re >> 2 & 31];
  return { ixti: Y, coltype: re & 3, rt: he, idx: oe, c: ue, C: fe };
}
function parse_PtgSxName(le) {
  return le.l += 2, [le.read_shift(4)];
}
function parse_PtgSheet(le, Y, re) {
  return le.l += 5, le.l += 2, le.l += re.biff == 2 ? 1 : 4, ["PTGSHEET"];
}
function parse_PtgEndSheet(le, Y, re) {
  return le.l += re.biff == 2 ? 4 : 5, ["PTGENDSHEET"];
}
function parse_PtgMemAreaN(le) {
  var Y = le.read_shift(1) >>> 5 & 3, re = le.read_shift(2);
  return [Y, re];
}
function parse_PtgMemNoMemN(le) {
  var Y = le.read_shift(1) >>> 5 & 3, re = le.read_shift(2);
  return [Y, re];
}
function parse_PtgAttrNoop(le) {
  return le.l += 4, [0, 0];
}
var PtgTypes = {
  1: { n: "PtgExp", f: parse_PtgExp },
  2: { n: "PtgTbl", f: parse_PtgTbl },
  3: { n: "PtgAdd", f: parseread1 },
  4: { n: "PtgSub", f: parseread1 },
  5: { n: "PtgMul", f: parseread1 },
  6: { n: "PtgDiv", f: parseread1 },
  7: { n: "PtgPower", f: parseread1 },
  8: { n: "PtgConcat", f: parseread1 },
  9: { n: "PtgLt", f: parseread1 },
  10: { n: "PtgLe", f: parseread1 },
  11: { n: "PtgEq", f: parseread1 },
  12: { n: "PtgGe", f: parseread1 },
  13: { n: "PtgGt", f: parseread1 },
  14: { n: "PtgNe", f: parseread1 },
  15: { n: "PtgIsect", f: parseread1 },
  16: { n: "PtgUnion", f: parseread1 },
  17: { n: "PtgRange", f: parseread1 },
  18: { n: "PtgUplus", f: parseread1 },
  19: { n: "PtgUminus", f: parseread1 },
  20: { n: "PtgPercent", f: parseread1 },
  21: { n: "PtgParen", f: parseread1 },
  22: { n: "PtgMissArg", f: parseread1 },
  23: { n: "PtgStr", f: parse_PtgStr },
  26: { n: "PtgSheet", f: parse_PtgSheet },
  27: { n: "PtgEndSheet", f: parse_PtgEndSheet },
  28: { n: "PtgErr", f: parse_PtgErr },
  29: { n: "PtgBool", f: parse_PtgBool },
  30: { n: "PtgInt", f: parse_PtgInt },
  31: { n: "PtgNum", f: parse_PtgNum },
  32: { n: "PtgArray", f: parse_PtgArray },
  33: { n: "PtgFunc", f: parse_PtgFunc },
  34: { n: "PtgFuncVar", f: parse_PtgFuncVar },
  35: { n: "PtgName", f: parse_PtgName },
  36: { n: "PtgRef", f: parse_PtgRef },
  37: { n: "PtgArea", f: parse_PtgArea },
  38: { n: "PtgMemArea", f: parse_PtgMemArea },
  39: { n: "PtgMemErr", f: parse_PtgMemErr },
  40: { n: "PtgMemNoMem", f: parse_PtgMemNoMem },
  41: { n: "PtgMemFunc", f: parse_PtgMemFunc },
  42: { n: "PtgRefErr", f: parse_PtgRefErr },
  43: { n: "PtgAreaErr", f: parse_PtgAreaErr },
  44: { n: "PtgRefN", f: parse_PtgRefN },
  45: { n: "PtgAreaN", f: parse_PtgAreaN },
  46: { n: "PtgMemAreaN", f: parse_PtgMemAreaN },
  47: { n: "PtgMemNoMemN", f: parse_PtgMemNoMemN },
  57: { n: "PtgNameX", f: parse_PtgNameX },
  58: { n: "PtgRef3d", f: parse_PtgRef3d },
  59: { n: "PtgArea3d", f: parse_PtgArea3d },
  60: { n: "PtgRefErr3d", f: parse_PtgRefErr3d },
  61: { n: "PtgAreaErr3d", f: parse_PtgAreaErr3d },
  255: {}
}, PtgDupes = {
  64: 32,
  96: 32,
  65: 33,
  97: 33,
  66: 34,
  98: 34,
  67: 35,
  99: 35,
  68: 36,
  100: 36,
  69: 37,
  101: 37,
  70: 38,
  102: 38,
  71: 39,
  103: 39,
  72: 40,
  104: 40,
  73: 41,
  105: 41,
  74: 42,
  106: 42,
  75: 43,
  107: 43,
  76: 44,
  108: 44,
  77: 45,
  109: 45,
  78: 46,
  110: 46,
  79: 47,
  111: 47,
  88: 34,
  120: 34,
  89: 57,
  121: 57,
  90: 58,
  122: 58,
  91: 59,
  123: 59,
  92: 60,
  124: 60,
  93: 61,
  125: 61
}, Ptg18 = {
  1: { n: "PtgElfLel", f: parse_PtgElfLel },
  2: { n: "PtgElfRw", f: parse_PtgElfRw },
  3: { n: "PtgElfCol", f: parse_PtgElfCol },
  6: { n: "PtgElfRwV", f: parse_PtgElfRwV },
  7: { n: "PtgElfColV", f: parse_PtgElfColV },
  10: { n: "PtgElfRadical", f: parse_PtgElfRadical },
  11: { n: "PtgElfRadicalS", f: parse_PtgElfRadicalS },
  13: { n: "PtgElfColS", f: parse_PtgElfColS },
  15: { n: "PtgElfColSV", f: parse_PtgElfColSV },
  16: { n: "PtgElfRadicalLel", f: parse_PtgElfRadicalLel },
  25: { n: "PtgList", f: parse_PtgList },
  29: { n: "PtgSxName", f: parse_PtgSxName },
  255: {}
}, Ptg19 = {
  0: { n: "PtgAttrNoop", f: parse_PtgAttrNoop },
  1: { n: "PtgAttrSemi", f: parse_PtgAttrSemi },
  2: { n: "PtgAttrIf", f: parse_PtgAttrIf },
  4: { n: "PtgAttrChoose", f: parse_PtgAttrChoose },
  8: { n: "PtgAttrGoto", f: parse_PtgAttrGoto },
  16: { n: "PtgAttrSum", f: parse_PtgAttrSum },
  32: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  33: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  64: { n: "PtgAttrSpace", f: parse_PtgAttrSpace },
  65: { n: "PtgAttrSpaceSemi", f: parse_PtgAttrSpaceSemi },
  128: { n: "PtgAttrIfError", f: parse_PtgAttrIfError },
  255: {}
};
function parse_RgbExtra(le, Y, re, oe) {
  if (oe.biff < 8) return parsenoop(le, Y);
  for (var ue = le.l + Y, fe = [], he = 0; he !== re.length; ++he)
    switch (re[he][0]) {
      case "PtgArray":
        re[he][1] = parse_PtgExtraArray(le, 0, oe), fe.push(re[he][1]);
        break;
      case "PtgMemArea":
        re[he][2] = parse_PtgExtraMem(le, re[he][1], oe), fe.push(re[he][2]);
        break;
      case "PtgExp":
        oe && oe.biff == 12 && (re[he][1][1] = le.read_shift(4), fe.push(re[he][1]));
        break;
      case "PtgList":
      /* TODO: PtgList -> PtgExtraList */
      case "PtgElfRadicalS":
      /* TODO: PtgElfRadicalS -> PtgExtraElf */
      case "PtgElfColS":
      /* TODO: PtgElfColS -> PtgExtraElf */
      case "PtgElfColSV":
        throw "Unsupported " + re[he][0];
    }
  return Y = ue - le.l, Y !== 0 && fe.push(parsenoop(le, Y)), fe;
}
function parse_Rgce(le, Y, re) {
  for (var oe = le.l + Y, ue, fe, he = []; oe != le.l; )
    Y = oe - le.l, fe = le[le.l], ue = PtgTypes[fe] || PtgTypes[PtgDupes[fe]], (fe === 24 || fe === 25) && (ue = (fe === 24 ? Ptg18 : Ptg19)[le[le.l + 1]]), !ue || !ue.f ? parsenoop(le, Y) : he.push([ue.n, ue.f(le, Y, re)]);
  return he;
}
function stringify_array(le) {
  for (var Y = [], re = 0; re < le.length; ++re) {
    for (var oe = le[re], ue = [], fe = 0; fe < oe.length; ++fe) {
      var he = oe[fe];
      if (he) switch (he[0]) {
        // TODO: handle embedded quotes
        case 2:
          ue.push('"' + he[1].replace(/"/g, '""') + '"');
          break;
        default:
          ue.push(he[1]);
      }
      else ue.push("");
    }
    Y.push(ue.join(","));
  }
  return Y.join(";");
}
var PtgBinOp = {
  PtgAdd: "+",
  PtgConcat: "&",
  PtgDiv: "/",
  PtgEq: "=",
  PtgGe: ">=",
  PtgGt: ">",
  PtgLe: "<=",
  PtgLt: "<",
  PtgMul: "*",
  PtgNe: "<>",
  PtgPower: "^",
  PtgSub: "-"
};
function make_3d_range(le, Y) {
  var re = le.lastIndexOf("!"), oe = Y.lastIndexOf("!");
  return re == -1 && oe == -1 ? le + ":" + Y : re > 0 && oe > 0 && le.slice(0, re).toLowerCase() == Y.slice(0, oe).toLowerCase() ? le + ":" + Y.slice(oe + 1) : (console.error("Cannot hydrate range", le, Y), le + ":" + Y);
}
function get_ixti_raw(le, Y, re) {
  if (!le) return "SH33TJSERR0";
  if (re.biff > 8 && (!le.XTI || !le.XTI[Y])) return le.SheetNames[Y];
  if (!le.XTI) return "SH33TJSERR6";
  var oe = le.XTI[Y];
  if (re.biff < 8)
    return Y > 1e4 && (Y -= 65536), Y < 0 && (Y = -Y), Y == 0 ? "" : le.XTI[Y - 1];
  if (!oe) return "SH33TJSERR1";
  var ue = "";
  if (re.biff > 8) switch (le[oe[0]][0]) {
    case 357:
      return ue = oe[1] == -1 ? "#REF" : le.SheetNames[oe[1]], oe[1] == oe[2] ? ue : ue + ":" + le.SheetNames[oe[2]];
    case 358:
      return re.SID != null ? le.SheetNames[re.SID] : "SH33TJSSAME" + le[oe[0]][0];
    case 355:
    /* 'BrtSupBookSrc' */
    /* falls through */
    default:
      return "SH33TJSSRC" + le[oe[0]][0];
  }
  switch (le[oe[0]][0][0]) {
    case 1025:
      return ue = oe[1] == -1 ? "#REF" : le.SheetNames[oe[1]] || "SH33TJSERR3", oe[1] == oe[2] ? ue : ue + ":" + le.SheetNames[oe[2]];
    case 14849:
      return le[oe[0]].slice(1).map(function(fe) {
        return fe.Name;
      }).join(";;");
    //return "SH33TJSERR8";
    default:
      return le[oe[0]][0][3] ? (ue = oe[1] == -1 ? "#REF" : le[oe[0]][0][3][oe[1]] || "SH33TJSERR4", oe[1] == oe[2] ? ue : ue + ":" + le[oe[0]][0][3][oe[2]]) : "SH33TJSERR2";
  }
}
function get_ixti(le, Y, re) {
  var oe = get_ixti_raw(le, Y, re);
  return oe == "#REF" ? oe : formula_quote_sheet_name(oe, re);
}
function stringify_formula(le, Y, re, oe, ue) {
  var fe = ue && ue.biff || 8, he = (
    /*range != null ? range :*/
    { s: { c: 0, r: 0 } }
  ), _e = [], ve, xe, Ee, Se = 0, Te = 0, Ce, Ie = "";
  if (!le[0] || !le[0][0]) return "";
  for (var Ne = -1, Re = "", Ae = 0, Pe = le[0].length; Ae < Pe; ++Ae) {
    var Fe = le[0][Ae];
    switch (Fe[0]) {
      case "PtgUminus":
        _e.push("-" + _e.pop());
        break;
      case "PtgUplus":
        _e.push("+" + _e.pop());
        break;
      case "PtgPercent":
        _e.push(_e.pop() + "%");
        break;
      case "PtgAdd":
      /* [MS-XLS] 2.5.198.26 */
      case "PtgConcat":
      /* [MS-XLS] 2.5.198.43 */
      case "PtgDiv":
      /* [MS-XLS] 2.5.198.45 */
      case "PtgEq":
      /* [MS-XLS] 2.5.198.56 */
      case "PtgGe":
      /* [MS-XLS] 2.5.198.64 */
      case "PtgGt":
      /* [MS-XLS] 2.5.198.65 */
      case "PtgLe":
      /* [MS-XLS] 2.5.198.68 */
      case "PtgLt":
      /* [MS-XLS] 2.5.198.69 */
      case "PtgMul":
      /* [MS-XLS] 2.5.198.75 */
      case "PtgNe":
      /* [MS-XLS] 2.5.198.78 */
      case "PtgPower":
      /* [MS-XLS] 2.5.198.82 */
      case "PtgSub":
        if (ve = _e.pop(), xe = _e.pop(), Ne >= 0) {
          switch (le[0][Ne][1][0]) {
            case 0:
              Re = fill(" ", le[0][Ne][1][1]);
              break;
            case 1:
              Re = fill("\r", le[0][Ne][1][1]);
              break;
            default:
              if (Re = "", ue.WTF) throw new Error("Unexpected PtgAttrSpaceType " + le[0][Ne][1][0]);
          }
          xe = xe + Re, Ne = -1;
        }
        _e.push(xe + PtgBinOp[Fe[0]] + ve);
        break;
      case "PtgIsect":
        ve = _e.pop(), xe = _e.pop(), _e.push(xe + " " + ve);
        break;
      case "PtgUnion":
        ve = _e.pop(), xe = _e.pop(), _e.push(xe + "," + ve);
        break;
      case "PtgRange":
        ve = _e.pop(), xe = _e.pop(), _e.push(make_3d_range(xe, ve));
        break;
      case "PtgAttrChoose":
        break;
      case "PtgAttrGoto":
        break;
      case "PtgAttrIf":
        break;
      case "PtgAttrIfError":
        break;
      case "PtgRef":
        Ee = shift_cell_xls(Fe[1][1], he, ue), _e.push(encode_cell_xls(Ee, fe));
        break;
      case "PtgRefN":
        Ee = re ? shift_cell_xls(Fe[1][1], re, ue) : Fe[1][1], _e.push(encode_cell_xls(Ee, fe));
        break;
      case "PtgRef3d":
        Se = /*::Number(*/
        Fe[1][1], Ee = shift_cell_xls(Fe[1][2], he, ue), Ie = get_ixti(oe, Se, ue), _e.push(Ie + "!" + encode_cell_xls(Ee, fe));
        break;
      case "PtgFunc":
      /* [MS-XLS] 2.5.198.62 */
      case "PtgFuncVar":
        var Le = Fe[1][0], He = Fe[1][1];
        Le || (Le = 0), Le &= 127;
        var Ge = Le == 0 ? [] : _e.slice(-Le);
        _e.length -= Le, He === "User" && (He = Ge.shift()), _e.push(He + "(" + Ge.join(",") + ")");
        break;
      case "PtgBool":
        _e.push(Fe[1] ? "TRUE" : "FALSE");
        break;
      case "PtgInt":
        _e.push(
          /*::String(*/
          Fe[1]
          /*::)*/
        );
        break;
      case "PtgNum":
        _e.push(String(Fe[1]));
        break;
      case "PtgStr":
        _e.push('"' + Fe[1].replace(/"/g, '""') + '"');
        break;
      case "PtgErr":
        _e.push(
          /*::String(*/
          Fe[1]
          /*::)*/
        );
        break;
      case "PtgAreaN":
        Ce = shift_range_xls(Fe[1][1], re ? { s: re } : he, ue), _e.push(encode_range_xls(Ce, ue));
        break;
      case "PtgArea":
        Ce = shift_range_xls(Fe[1][1], he, ue), _e.push(encode_range_xls(Ce, ue));
        break;
      case "PtgArea3d":
        Se = /*::Number(*/
        Fe[1][1], Ce = Fe[1][2], Ie = get_ixti(oe, Se, ue), _e.push(Ie + "!" + encode_range_xls(Ce, ue));
        break;
      case "PtgAttrSum":
        _e.push("SUM(" + _e.pop() + ")");
        break;
      case "PtgAttrBaxcel":
      /* [MS-XLS] 2.5.198.33 */
      case "PtgAttrSemi":
        break;
      case "PtgName":
        Te = Fe[1][2];
        var Ve = (oe.names || [])[Te - 1] || (oe[0] || [])[Te], $e = Ve ? Ve.Name : "SH33TJSNAME" + String(Te);
        $e && $e.slice(0, 6) == "_xlfn." && !ue.xlfn && ($e = $e.slice(6)), _e.push($e);
        break;
      case "PtgNameX":
        var De = Fe[1][1];
        Te = Fe[1][2];
        var Ke;
        if (ue.biff <= 5)
          De < 0 && (De = -De), oe[De] && (Ke = oe[De][Te]);
        else {
          var ze = "";
          if (((oe[De] || [])[0] || [])[0] == 14849 || (((oe[De] || [])[0] || [])[0] == 1025 ? oe[De][Te] && oe[De][Te].itab > 0 && (ze = oe.SheetNames[oe[De][Te].itab - 1] + "!") : ze = oe.SheetNames[Te - 1] + "!"), oe[De] && oe[De][Te]) ze += oe[De][Te].Name;
          else if (oe[0] && oe[0][Te]) ze += oe[0][Te].Name;
          else {
            var tt = (get_ixti_raw(oe, De, ue) || "").split(";;");
            tt[Te - 1] ? ze = tt[Te - 1] : ze += "SH33TJSERRX";
          }
          _e.push(ze);
          break;
        }
        Ke || (Ke = { Name: "SH33TJSERRY" }), _e.push(Ke.Name);
        break;
      case "PtgParen":
        var Xe = "(", mt = ")";
        if (Ne >= 0) {
          switch (Re = "", le[0][Ne][1][0]) {
            // $FlowIgnore
            case 2:
              Xe = fill(" ", le[0][Ne][1][1]) + Xe;
              break;
            // $FlowIgnore
            case 3:
              Xe = fill("\r", le[0][Ne][1][1]) + Xe;
              break;
            // $FlowIgnore
            case 4:
              mt = fill(" ", le[0][Ne][1][1]) + mt;
              break;
            // $FlowIgnore
            case 5:
              mt = fill("\r", le[0][Ne][1][1]) + mt;
              break;
            default:
              if (ue.WTF) throw new Error("Unexpected PtgAttrSpaceType " + le[0][Ne][1][0]);
          }
          Ne = -1;
        }
        _e.push(Xe + _e.pop() + mt);
        break;
      case "PtgRefErr":
        _e.push("#REF!");
        break;
      case "PtgRefErr3d":
        _e.push("#REF!");
        break;
      case "PtgExp":
        Ee = { c: Fe[1][1], r: Fe[1][0] };
        var at = { c: re.c, r: re.r };
        if (oe.sharedf[encode_cell(Ee)]) {
          var qe = oe.sharedf[encode_cell(Ee)];
          _e.push(stringify_formula(qe, he, at, oe, ue));
        } else {
          var st = !1;
          for (ve = 0; ve != oe.arrayf.length; ++ve)
            if (xe = oe.arrayf[ve], !(Ee.c < xe[0].s.c || Ee.c > xe[0].e.c) && !(Ee.r < xe[0].s.r || Ee.r > xe[0].e.r)) {
              _e.push(stringify_formula(xe[1], he, at, oe, ue)), st = !0;
              break;
            }
          st || _e.push(
            /*::String(*/
            Fe[1]
            /*::)*/
          );
        }
        break;
      case "PtgArray":
        _e.push("{" + stringify_array(
          /*::(*/
          Fe[1]
          /*:: :any)*/
        ) + "}");
        break;
      case "PtgMemArea":
        break;
      case "PtgAttrSpace":
      /* [MS-XLS] 2.5.198.38 */
      case "PtgAttrSpaceSemi":
        Ne = Ae;
        break;
      case "PtgTbl":
        break;
      case "PtgMemErr":
        break;
      case "PtgMissArg":
        _e.push("");
        break;
      case "PtgAreaErr":
        _e.push("#REF!");
        break;
      case "PtgAreaErr3d":
        _e.push("#REF!");
        break;
      case "PtgList":
        _e.push("Table" + Fe[1].idx + "[#" + Fe[1].rt + "]");
        break;
      case "PtgMemAreaN":
      case "PtgMemNoMemN":
      case "PtgAttrNoop":
      case "PtgSheet":
      case "PtgEndSheet":
        break;
      case "PtgMemFunc":
        break;
      case "PtgMemNoMem":
        break;
      case "PtgElfCol":
      /* [MS-XLS] 2.5.198.46 */
      case "PtgElfColS":
      /* [MS-XLS] 2.5.198.47 */
      case "PtgElfColSV":
      /* [MS-XLS] 2.5.198.48 */
      case "PtgElfColV":
      /* [MS-XLS] 2.5.198.49 */
      case "PtgElfLel":
      /* [MS-XLS] 2.5.198.50 */
      case "PtgElfRadical":
      /* [MS-XLS] 2.5.198.51 */
      case "PtgElfRadicalLel":
      /* [MS-XLS] 2.5.198.52 */
      case "PtgElfRadicalS":
      /* [MS-XLS] 2.5.198.53 */
      case "PtgElfRw":
      /* [MS-XLS] 2.5.198.54 */
      case "PtgElfRwV":
        throw new Error("Unsupported ELFs");
      case "PtgSxName":
        throw new Error("Unrecognized Formula Token: " + String(Fe));
      default:
        throw new Error("Unrecognized Formula Token: " + String(Fe));
    }
    var xt = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
    if (ue.biff != 3 && Ne >= 0 && xt.indexOf(le[0][Ae][0]) == -1) {
      Fe = le[0][Ne];
      var gt = !0;
      switch (Fe[1][0]) {
        /* note: some bad XLSB files omit the PtgParen */
        case 4:
          gt = !1;
        /* falls through */
        case 0:
          Re = fill(" ", Fe[1][1]);
          break;
        case 5:
          gt = !1;
        /* falls through */
        case 1:
          Re = fill("\r", Fe[1][1]);
          break;
        default:
          if (Re = "", ue.WTF) throw new Error("Unexpected PtgAttrSpaceType " + Fe[1][0]);
      }
      _e.push((gt ? Re : "") + _e.pop() + (gt ? "" : Re)), Ne = -1;
    }
  }
  if (_e.length > 1 && ue.WTF) throw new Error("bad formula stack");
  return _e[0] == "TRUE" ? !0 : _e[0] == "FALSE" ? !1 : _e[0];
}
function parse_ArrayParsedFormula(le, Y, re) {
  var oe = le.l + Y, ue = re.biff == 2 ? 1 : 2, fe, he = le.read_shift(ue);
  if (he == 65535) return [[], parsenoop(le, Y - 2)];
  var _e = parse_Rgce(le, he, re);
  return Y !== he + ue && (fe = parse_RgbExtra(le, Y - he - ue, _e, re)), le.l = oe, [_e, fe];
}
function parse_XLSCellParsedFormula(le, Y, re) {
  var oe = le.l + Y, ue = re.biff == 2 ? 1 : 2, fe, he = le.read_shift(ue);
  if (he == 65535) return [[], parsenoop(le, Y - 2)];
  var _e = parse_Rgce(le, he, re);
  return Y !== he + ue && (fe = parse_RgbExtra(le, Y - he - ue, _e, re)), le.l = oe, [_e, fe];
}
function parse_NameParsedFormula(le, Y, re, oe) {
  var ue = le.l + Y, fe = parse_Rgce(le, oe, re), he;
  return ue !== le.l && (he = parse_RgbExtra(le, ue - le.l, fe, re)), [fe, he];
}
function parse_SharedParsedFormula(le, Y, re) {
  var oe = le.l + Y, ue, fe = le.read_shift(2), he = parse_Rgce(le, fe, re);
  return fe == 65535 ? [[], parsenoop(le, Y - 2)] : (Y !== fe + 2 && (ue = parse_RgbExtra(le, oe - fe - 2, he, re)), [he, ue]);
}
function parse_FormulaValue(le) {
  var Y;
  if (__readUInt16LE(le, le.l + 6) !== 65535) return [parse_Xnum(le), "n"];
  switch (le[le.l]) {
    case 0:
      return le.l += 8, ["String", "s"];
    case 1:
      return Y = le[le.l + 2] === 1, le.l += 8, [Y, "b"];
    case 2:
      return Y = le[le.l + 2], le.l += 8, [Y, "e"];
    case 3:
      return le.l += 8, ["", "s"];
  }
  return [];
}
function write_FormulaValue(le) {
  if (le == null) {
    var Y = new_buf(8);
    return Y.write_shift(1, 3), Y.write_shift(1, 0), Y.write_shift(2, 0), Y.write_shift(2, 0), Y.write_shift(2, 65535), Y;
  } else if (typeof le == "number") return write_Xnum(le);
  return write_Xnum(0);
}
function parse_Formula(le, Y, re) {
  var oe = le.l + Y, ue = parse_XLSCell(le, 6, re), fe = parse_FormulaValue(le), he = le.read_shift(1);
  re.biff != 2 && (le.read_shift(1), re.biff >= 5 && le.read_shift(4));
  var _e = parse_XLSCellParsedFormula(le, oe - le.l, re);
  return { cell: ue, val: fe[0], formula: _e, shared: he >> 3 & 1, tt: fe[1] };
}
function write_Formula(le, Y, re, oe, ue) {
  var fe = write_XLSCell(Y, re, ue), he = write_FormulaValue(le.v), _e = new_buf(6), ve = 33;
  _e.write_shift(2, ve), _e.write_shift(4, 0);
  for (var xe = new_buf(le.bf.length), Ee = 0; Ee < le.bf.length; ++Ee) xe[Ee] = le.bf[Ee];
  var Se = bconcat([fe, he, _e, xe]);
  return Se;
}
function parse_XLSBParsedFormula(le, Y, re) {
  var oe = le.read_shift(4), ue = parse_Rgce(le, oe, re), fe = le.read_shift(4), he = fe > 0 ? parse_RgbExtra(le, fe, ue, re) : null;
  return [ue, he];
}
var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula, parse_XLSBCellParsedFormula = parse_XLSBParsedFormula, parse_XLSBNameParsedFormula = parse_XLSBParsedFormula, parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
function write_XLSBFormulaNum(le) {
  if ((le | 0) == le && le < Math.pow(2, 16) && le >= 0) {
    var Y = new_buf(11);
    return Y.write_shift(4, 3), Y.write_shift(1, 30), Y.write_shift(2, le), Y.write_shift(4, 0), Y;
  }
  var re = new_buf(17);
  return re.write_shift(4, 11), re.write_shift(1, 31), re.write_shift(8, le), re.write_shift(4, 0), re;
}
function write_XLSBFormulaErr(le) {
  var Y = new_buf(10);
  return Y.write_shift(4, 2), Y.write_shift(1, 28), Y.write_shift(1, le), Y.write_shift(4, 0), Y;
}
function write_XLSBFormulaBool(le) {
  var Y = new_buf(10);
  return Y.write_shift(4, 2), Y.write_shift(1, 29), Y.write_shift(1, le ? 1 : 0), Y.write_shift(4, 0), Y;
}
function write_XLSBFormulaStr(le) {
  var Y = new_buf(7);
  Y.write_shift(4, 3 + 2 * le.length), Y.write_shift(1, 23), Y.write_shift(2, le.length);
  var re = new_buf(2 * le.length);
  re.write_shift(2 * le.length, le, "utf16le");
  var oe = new_buf(4);
  return oe.write_shift(4, 0), bconcat([Y, re, oe]);
}
function write_XLSBFormulaRef(le) {
  var Y = decode_cell(le), re = new_buf(15);
  return re.write_shift(4, 7), re.write_shift(1, 36), re.write_shift(4, Y.r), re.write_shift(2, Y.c | (le.charAt(0) == "$" ? 0 : 1) << 14 | (le.match(/\$\d/) ? 0 : 1) << 15), re.write_shift(4, 0), re;
}
function write_XLSBFormulaRef3D(le, Y) {
  var re = le.lastIndexOf("!"), oe = le.slice(0, re);
  le = le.slice(re + 1);
  var ue = decode_cell(le);
  oe.charAt(0) == "'" && (oe = oe.slice(1, -1).replace(/''/g, "'"));
  var fe = new_buf(17);
  return fe.write_shift(4, 9), fe.write_shift(1, 58), fe.write_shift(2, 2 + Y.SheetNames.map(function(he) {
    return he.toLowerCase();
  }).indexOf(oe.toLowerCase())), fe.write_shift(4, ue.r), fe.write_shift(2, ue.c | (le.charAt(0) == "$" ? 0 : 1) << 14 | (le.match(/\$\d/) ? 0 : 1) << 15), fe.write_shift(4, 0), fe;
}
function write_XLSBFormulaRefErr3D(le, Y) {
  var re = le.lastIndexOf("!"), oe = le.slice(0, re);
  le = le.slice(re + 1), oe.charAt(0) == "'" && (oe = oe.slice(1, -1).replace(/''/g, "'"));
  var ue = new_buf(17);
  return ue.write_shift(4, 9), ue.write_shift(1, 60), ue.write_shift(2, 2 + Y.SheetNames.map(function(fe) {
    return fe.toLowerCase();
  }).indexOf(oe.toLowerCase())), ue.write_shift(4, 0), ue.write_shift(2, 0), ue.write_shift(4, 0), ue;
}
function write_XLSBFormulaRange(le) {
  var Y = le.split(":"), re = Y[0], oe = new_buf(23);
  oe.write_shift(4, 15), re = Y[0];
  var ue = decode_cell(re);
  return oe.write_shift(1, 36), oe.write_shift(4, ue.r), oe.write_shift(2, ue.c | (re.charAt(0) == "$" ? 0 : 1) << 14 | (re.match(/\$\d/) ? 0 : 1) << 15), oe.write_shift(4, 0), re = Y[1], ue = decode_cell(re), oe.write_shift(1, 36), oe.write_shift(4, ue.r), oe.write_shift(2, ue.c | (re.charAt(0) == "$" ? 0 : 1) << 14 | (re.match(/\$\d/) ? 0 : 1) << 15), oe.write_shift(4, 0), oe.write_shift(1, 17), oe.write_shift(4, 0), oe;
}
function write_XLSBFormulaRangeWS(le, Y) {
  var re = le.lastIndexOf("!"), oe = le.slice(0, re);
  le = le.slice(re + 1), oe.charAt(0) == "'" && (oe = oe.slice(1, -1).replace(/''/g, "'"));
  var ue = le.split(":"), fe = new_buf(27);
  fe.write_shift(4, 19);
  var he = ue[0], _e = decode_cell(he);
  return fe.write_shift(1, 58), fe.write_shift(2, 2 + Y.SheetNames.map(function(ve) {
    return ve.toLowerCase();
  }).indexOf(oe.toLowerCase())), fe.write_shift(4, _e.r), fe.write_shift(2, _e.c | (he.charAt(0) == "$" ? 0 : 1) << 14 | (he.match(/\$\d/) ? 0 : 1) << 15), he = ue[1], _e = decode_cell(he), fe.write_shift(1, 58), fe.write_shift(2, 2 + Y.SheetNames.map(function(ve) {
    return ve.toLowerCase();
  }).indexOf(oe.toLowerCase())), fe.write_shift(4, _e.r), fe.write_shift(2, _e.c | (he.charAt(0) == "$" ? 0 : 1) << 14 | (he.match(/\$\d/) ? 0 : 1) << 15), fe.write_shift(1, 17), fe.write_shift(4, 0), fe;
}
function write_XLSBFormulaArea3D(le, Y) {
  var re = le.lastIndexOf("!"), oe = le.slice(0, re);
  le = le.slice(re + 1), oe.charAt(0) == "'" && (oe = oe.slice(1, -1).replace(/''/g, "'"));
  var ue = decode_range(le), fe = new_buf(23);
  return fe.write_shift(4, 15), fe.write_shift(1, 59), fe.write_shift(2, 2 + Y.SheetNames.map(function(he) {
    return he.toLowerCase();
  }).indexOf(oe.toLowerCase())), fe.write_shift(4, ue.s.r), fe.write_shift(4, ue.e.r), fe.write_shift(2, ue.s.c), fe.write_shift(2, ue.e.c), fe.write_shift(4, 0), fe;
}
function write_XLSBFormula(le, Y) {
  if (typeof le == "number") return write_XLSBFormulaNum(le);
  if (typeof le == "boolean") return write_XLSBFormulaBool(le);
  if (/^#(DIV\/0!|GETTING_DATA|N\/A|NAME\?|NULL!|NUM!|REF!|VALUE!)$/.test(le)) return write_XLSBFormulaErr(+RBErr[le]);
  if (le.match(/^\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRef(le);
  if (le.match(/^\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRange(le);
  if (le.match(/^#REF!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaArea3D(le, Y);
  if (le.match(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,<.>]*)!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRef3D(le, Y);
  if (le.match(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,<.>]*)!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRangeWS(le, Y);
  if (/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,<.>]*)!#REF!$/.test(le)) return write_XLSBFormulaRefErr3D(le, Y);
  if (/^".*"$/.test(le)) return write_XLSBFormulaStr(le);
  if (/^[+-]\d+$/.test(le)) return write_XLSBFormulaNum(parseInt(le, 10));
  throw "Formula |" + le + "| not supported for XLSB";
}
var write_XLSBNameParsedFormula = write_XLSBFormula, Cetab = {
  0: "BEEP",
  1: "OPEN",
  2: "OPEN.LINKS",
  3: "CLOSE.ALL",
  4: "SAVE",
  5: "SAVE.AS",
  6: "FILE.DELETE",
  7: "PAGE.SETUP",
  8: "PRINT",
  9: "PRINTER.SETUP",
  10: "QUIT",
  11: "NEW.WINDOW",
  12: "ARRANGE.ALL",
  13: "WINDOW.SIZE",
  14: "WINDOW.MOVE",
  15: "FULL",
  16: "CLOSE",
  17: "RUN",
  22: "SET.PRINT.AREA",
  23: "SET.PRINT.TITLES",
  24: "SET.PAGE.BREAK",
  25: "REMOVE.PAGE.BREAK",
  26: "FONT",
  27: "DISPLAY",
  28: "PROTECT.DOCUMENT",
  29: "PRECISION",
  30: "A1.R1C1",
  31: "CALCULATE.NOW",
  32: "CALCULATION",
  34: "DATA.FIND",
  35: "EXTRACT",
  36: "DATA.DELETE",
  37: "SET.DATABASE",
  38: "SET.CRITERIA",
  39: "SORT",
  40: "DATA.SERIES",
  41: "TABLE",
  42: "FORMAT.NUMBER",
  43: "ALIGNMENT",
  44: "STYLE",
  45: "BORDER",
  46: "CELL.PROTECTION",
  47: "COLUMN.WIDTH",
  48: "UNDO",
  49: "CUT",
  50: "COPY",
  51: "PASTE",
  52: "CLEAR",
  53: "PASTE.SPECIAL",
  54: "EDIT.DELETE",
  55: "INSERT",
  56: "FILL.RIGHT",
  57: "FILL.DOWN",
  61: "DEFINE.NAME",
  62: "CREATE.NAMES",
  63: "FORMULA.GOTO",
  64: "FORMULA.FIND",
  65: "SELECT.LAST.CELL",
  66: "SHOW.ACTIVE.CELL",
  67: "GALLERY.AREA",
  68: "GALLERY.BAR",
  69: "GALLERY.COLUMN",
  70: "GALLERY.LINE",
  71: "GALLERY.PIE",
  72: "GALLERY.SCATTER",
  73: "COMBINATION",
  74: "PREFERRED",
  75: "ADD.OVERLAY",
  76: "GRIDLINES",
  77: "SET.PREFERRED",
  78: "AXES",
  79: "LEGEND",
  80: "ATTACH.TEXT",
  81: "ADD.ARROW",
  82: "SELECT.CHART",
  83: "SELECT.PLOT.AREA",
  84: "PATTERNS",
  85: "MAIN.CHART",
  86: "OVERLAY",
  87: "SCALE",
  88: "FORMAT.LEGEND",
  89: "FORMAT.TEXT",
  90: "EDIT.REPEAT",
  91: "PARSE",
  92: "JUSTIFY",
  93: "HIDE",
  94: "UNHIDE",
  95: "WORKSPACE",
  96: "FORMULA",
  97: "FORMULA.FILL",
  98: "FORMULA.ARRAY",
  99: "DATA.FIND.NEXT",
  100: "DATA.FIND.PREV",
  101: "FORMULA.FIND.NEXT",
  102: "FORMULA.FIND.PREV",
  103: "ACTIVATE",
  104: "ACTIVATE.NEXT",
  105: "ACTIVATE.PREV",
  106: "UNLOCKED.NEXT",
  107: "UNLOCKED.PREV",
  108: "COPY.PICTURE",
  109: "SELECT",
  110: "DELETE.NAME",
  111: "DELETE.FORMAT",
  112: "VLINE",
  113: "HLINE",
  114: "VPAGE",
  115: "HPAGE",
  116: "VSCROLL",
  117: "HSCROLL",
  118: "ALERT",
  119: "NEW",
  120: "CANCEL.COPY",
  121: "SHOW.CLIPBOARD",
  122: "MESSAGE",
  124: "PASTE.LINK",
  125: "APP.ACTIVATE",
  126: "DELETE.ARROW",
  127: "ROW.HEIGHT",
  128: "FORMAT.MOVE",
  129: "FORMAT.SIZE",
  130: "FORMULA.REPLACE",
  131: "SEND.KEYS",
  132: "SELECT.SPECIAL",
  133: "APPLY.NAMES",
  134: "REPLACE.FONT",
  135: "FREEZE.PANES",
  136: "SHOW.INFO",
  137: "SPLIT",
  138: "ON.WINDOW",
  139: "ON.DATA",
  140: "DISABLE.INPUT",
  142: "OUTLINE",
  143: "LIST.NAMES",
  144: "FILE.CLOSE",
  145: "SAVE.WORKBOOK",
  146: "DATA.FORM",
  147: "COPY.CHART",
  148: "ON.TIME",
  149: "WAIT",
  150: "FORMAT.FONT",
  151: "FILL.UP",
  152: "FILL.LEFT",
  153: "DELETE.OVERLAY",
  155: "SHORT.MENUS",
  159: "SET.UPDATE.STATUS",
  161: "COLOR.PALETTE",
  162: "DELETE.STYLE",
  163: "WINDOW.RESTORE",
  164: "WINDOW.MAXIMIZE",
  166: "CHANGE.LINK",
  167: "CALCULATE.DOCUMENT",
  168: "ON.KEY",
  169: "APP.RESTORE",
  170: "APP.MOVE",
  171: "APP.SIZE",
  172: "APP.MINIMIZE",
  173: "APP.MAXIMIZE",
  174: "BRING.TO.FRONT",
  175: "SEND.TO.BACK",
  185: "MAIN.CHART.TYPE",
  186: "OVERLAY.CHART.TYPE",
  187: "SELECT.END",
  188: "OPEN.MAIL",
  189: "SEND.MAIL",
  190: "STANDARD.FONT",
  191: "CONSOLIDATE",
  192: "SORT.SPECIAL",
  193: "GALLERY.3D.AREA",
  194: "GALLERY.3D.COLUMN",
  195: "GALLERY.3D.LINE",
  196: "GALLERY.3D.PIE",
  197: "VIEW.3D",
  198: "GOAL.SEEK",
  199: "WORKGROUP",
  200: "FILL.GROUP",
  201: "UPDATE.LINK",
  202: "PROMOTE",
  203: "DEMOTE",
  204: "SHOW.DETAIL",
  206: "UNGROUP",
  207: "OBJECT.PROPERTIES",
  208: "SAVE.NEW.OBJECT",
  209: "SHARE",
  210: "SHARE.NAME",
  211: "DUPLICATE",
  212: "APPLY.STYLE",
  213: "ASSIGN.TO.OBJECT",
  214: "OBJECT.PROTECTION",
  215: "HIDE.OBJECT",
  216: "SET.EXTRACT",
  217: "CREATE.PUBLISHER",
  218: "SUBSCRIBE.TO",
  219: "ATTRIBUTES",
  220: "SHOW.TOOLBAR",
  222: "PRINT.PREVIEW",
  223: "EDIT.COLOR",
  224: "SHOW.LEVELS",
  225: "FORMAT.MAIN",
  226: "FORMAT.OVERLAY",
  227: "ON.RECALC",
  228: "EDIT.SERIES",
  229: "DEFINE.STYLE",
  240: "LINE.PRINT",
  243: "ENTER.DATA",
  249: "GALLERY.RADAR",
  250: "MERGE.STYLES",
  251: "EDITION.OPTIONS",
  252: "PASTE.PICTURE",
  253: "PASTE.PICTURE.LINK",
  254: "SPELLING",
  256: "ZOOM",
  259: "INSERT.OBJECT",
  260: "WINDOW.MINIMIZE",
  265: "SOUND.NOTE",
  266: "SOUND.PLAY",
  267: "FORMAT.SHAPE",
  268: "EXTEND.POLYGON",
  269: "FORMAT.AUTO",
  272: "GALLERY.3D.BAR",
  273: "GALLERY.3D.SURFACE",
  274: "FILL.AUTO",
  276: "CUSTOMIZE.TOOLBAR",
  277: "ADD.TOOL",
  278: "EDIT.OBJECT",
  279: "ON.DOUBLECLICK",
  280: "ON.ENTRY",
  281: "WORKBOOK.ADD",
  282: "WORKBOOK.MOVE",
  283: "WORKBOOK.COPY",
  284: "WORKBOOK.OPTIONS",
  285: "SAVE.WORKSPACE",
  288: "CHART.WIZARD",
  289: "DELETE.TOOL",
  290: "MOVE.TOOL",
  291: "WORKBOOK.SELECT",
  292: "WORKBOOK.ACTIVATE",
  293: "ASSIGN.TO.TOOL",
  295: "COPY.TOOL",
  296: "RESET.TOOL",
  297: "CONSTRAIN.NUMERIC",
  298: "PASTE.TOOL",
  302: "WORKBOOK.NEW",
  305: "SCENARIO.CELLS",
  306: "SCENARIO.DELETE",
  307: "SCENARIO.ADD",
  308: "SCENARIO.EDIT",
  309: "SCENARIO.SHOW",
  310: "SCENARIO.SHOW.NEXT",
  311: "SCENARIO.SUMMARY",
  312: "PIVOT.TABLE.WIZARD",
  313: "PIVOT.FIELD.PROPERTIES",
  314: "PIVOT.FIELD",
  315: "PIVOT.ITEM",
  316: "PIVOT.ADD.FIELDS",
  318: "OPTIONS.CALCULATION",
  319: "OPTIONS.EDIT",
  320: "OPTIONS.VIEW",
  321: "ADDIN.MANAGER",
  322: "MENU.EDITOR",
  323: "ATTACH.TOOLBARS",
  324: "VBAActivate",
  325: "OPTIONS.CHART",
  328: "VBA.INSERT.FILE",
  330: "VBA.PROCEDURE.DEFINITION",
  336: "ROUTING.SLIP",
  338: "ROUTE.DOCUMENT",
  339: "MAIL.LOGON",
  342: "INSERT.PICTURE",
  343: "EDIT.TOOL",
  344: "GALLERY.DOUGHNUT",
  350: "CHART.TREND",
  352: "PIVOT.ITEM.PROPERTIES",
  354: "WORKBOOK.INSERT",
  355: "OPTIONS.TRANSITION",
  356: "OPTIONS.GENERAL",
  370: "FILTER.ADVANCED",
  373: "MAIL.ADD.MAILER",
  374: "MAIL.DELETE.MAILER",
  375: "MAIL.REPLY",
  376: "MAIL.REPLY.ALL",
  377: "MAIL.FORWARD",
  378: "MAIL.NEXT.LETTER",
  379: "DATA.LABEL",
  380: "INSERT.TITLE",
  381: "FONT.PROPERTIES",
  382: "MACRO.OPTIONS",
  383: "WORKBOOK.HIDE",
  384: "WORKBOOK.UNHIDE",
  385: "WORKBOOK.DELETE",
  386: "WORKBOOK.NAME",
  388: "GALLERY.CUSTOM",
  390: "ADD.CHART.AUTOFORMAT",
  391: "DELETE.CHART.AUTOFORMAT",
  392: "CHART.ADD.DATA",
  393: "AUTO.OUTLINE",
  394: "TAB.ORDER",
  395: "SHOW.DIALOG",
  396: "SELECT.ALL",
  397: "UNGROUP.SHEETS",
  398: "SUBTOTAL.CREATE",
  399: "SUBTOTAL.REMOVE",
  400: "RENAME.OBJECT",
  412: "WORKBOOK.SCROLL",
  413: "WORKBOOK.NEXT",
  414: "WORKBOOK.PREV",
  415: "WORKBOOK.TAB.SPLIT",
  416: "FULL.SCREEN",
  417: "WORKBOOK.PROTECT",
  420: "SCROLLBAR.PROPERTIES",
  421: "PIVOT.SHOW.PAGES",
  422: "TEXT.TO.COLUMNS",
  423: "FORMAT.CHARTTYPE",
  424: "LINK.FORMAT",
  425: "TRACER.DISPLAY",
  430: "TRACER.NAVIGATE",
  431: "TRACER.CLEAR",
  432: "TRACER.ERROR",
  433: "PIVOT.FIELD.GROUP",
  434: "PIVOT.FIELD.UNGROUP",
  435: "CHECKBOX.PROPERTIES",
  436: "LABEL.PROPERTIES",
  437: "LISTBOX.PROPERTIES",
  438: "EDITBOX.PROPERTIES",
  439: "PIVOT.REFRESH",
  440: "LINK.COMBO",
  441: "OPEN.TEXT",
  442: "HIDE.DIALOG",
  443: "SET.DIALOG.FOCUS",
  444: "ENABLE.OBJECT",
  445: "PUSHBUTTON.PROPERTIES",
  446: "SET.DIALOG.DEFAULT",
  447: "FILTER",
  448: "FILTER.SHOW.ALL",
  449: "CLEAR.OUTLINE",
  450: "FUNCTION.WIZARD",
  451: "ADD.LIST.ITEM",
  452: "SET.LIST.ITEM",
  453: "REMOVE.LIST.ITEM",
  454: "SELECT.LIST.ITEM",
  455: "SET.CONTROL.VALUE",
  456: "SAVE.COPY.AS",
  458: "OPTIONS.LISTS.ADD",
  459: "OPTIONS.LISTS.DELETE",
  460: "SERIES.AXES",
  461: "SERIES.X",
  462: "SERIES.Y",
  463: "ERRORBAR.X",
  464: "ERRORBAR.Y",
  465: "FORMAT.CHART",
  466: "SERIES.ORDER",
  467: "MAIL.LOGOFF",
  468: "CLEAR.ROUTING.SLIP",
  469: "APP.ACTIVATE.MICROSOFT",
  470: "MAIL.EDIT.MAILER",
  471: "ON.SHEET",
  472: "STANDARD.WIDTH",
  473: "SCENARIO.MERGE",
  474: "SUMMARY.INFO",
  475: "FIND.FILE",
  476: "ACTIVE.CELL.FONT",
  477: "ENABLE.TIPWIZARD",
  478: "VBA.MAKE.ADDIN",
  480: "INSERTDATATABLE",
  481: "WORKGROUP.OPTIONS",
  482: "MAIL.SEND.MAILER",
  485: "AUTOCORRECT",
  489: "POST.DOCUMENT",
  491: "PICKLIST",
  493: "VIEW.SHOW",
  494: "VIEW.DEFINE",
  495: "VIEW.DELETE",
  509: "SHEET.BACKGROUND",
  510: "INSERT.MAP.OBJECT",
  511: "OPTIONS.MENONO",
  517: "MSOCHECKS",
  518: "NORMAL",
  519: "LAYOUT",
  520: "RM.PRINT.AREA",
  521: "CLEAR.PRINT.AREA",
  522: "ADD.PRINT.AREA",
  523: "MOVE.BRK",
  545: "HIDECURR.NOTE",
  546: "HIDEALL.NOTES",
  547: "DELETE.NOTE",
  548: "TRAVERSE.NOTES",
  549: "ACTIVATE.NOTES",
  620: "PROTECT.REVISIONS",
  621: "UNPROTECT.REVISIONS",
  647: "OPTIONS.ME",
  653: "WEB.PUBLISH",
  667: "NEWWEBQUERY",
  673: "PIVOT.TABLE.CHART",
  753: "OPTIONS.SAVE",
  755: "OPTIONS.SPELL",
  808: "HIDEALL.INKANNOTS"
}, Ftab = {
  0: "COUNT",
  1: "IF",
  2: "ISNA",
  3: "ISERROR",
  4: "SUM",
  5: "AVERAGE",
  6: "MIN",
  7: "MAX",
  8: "ROW",
  9: "COLUMN",
  10: "NA",
  11: "NPV",
  12: "STDEV",
  13: "DOLLAR",
  14: "FIXED",
  15: "SIN",
  16: "COS",
  17: "TAN",
  18: "ATAN",
  19: "PI",
  20: "SQRT",
  21: "EXP",
  22: "LN",
  23: "LOG10",
  24: "ABS",
  25: "INT",
  26: "SIGN",
  27: "ROUND",
  28: "LOOKUP",
  29: "INDEX",
  30: "REPT",
  31: "MID",
  32: "LEN",
  33: "VALUE",
  34: "TRUE",
  35: "FALSE",
  36: "AND",
  37: "OR",
  38: "NOT",
  39: "MOD",
  40: "DCOUNT",
  41: "DSUM",
  42: "DAVERAGE",
  43: "DMIN",
  44: "DMAX",
  45: "DSTDEV",
  46: "VAR",
  47: "DVAR",
  48: "TEXT",
  49: "LINEST",
  50: "TREND",
  51: "LOGEST",
  52: "GROWTH",
  53: "GOTO",
  54: "HALT",
  55: "RETURN",
  56: "PV",
  57: "FV",
  58: "NPER",
  59: "PMT",
  60: "RATE",
  61: "MIRR",
  62: "IRR",
  63: "RAND",
  64: "MATCH",
  65: "DATE",
  66: "TIME",
  67: "DAY",
  68: "MONTH",
  69: "YEAR",
  70: "WEEKDAY",
  71: "HOUR",
  72: "MINUTE",
  73: "SECOND",
  74: "NOW",
  75: "AREAS",
  76: "ROWS",
  77: "COLUMNS",
  78: "OFFSET",
  79: "ABSREF",
  80: "RELREF",
  81: "ARGUMENT",
  82: "SEARCH",
  83: "TRANSPOSE",
  84: "ERROR",
  85: "STEP",
  86: "TYPE",
  87: "ECHO",
  88: "SET.NAME",
  89: "CALLER",
  90: "DEREF",
  91: "WINDOWS",
  92: "SERIES",
  93: "DOCUMENTS",
  94: "ACTIVE.CELL",
  95: "SELECTION",
  96: "RESULT",
  97: "ATAN2",
  98: "ASIN",
  99: "ACOS",
  100: "CHOOSE",
  101: "HLOOKUP",
  102: "VLOOKUP",
  103: "LINKS",
  104: "INPUT",
  105: "ISREF",
  106: "GET.FORMULA",
  107: "GET.NAME",
  108: "SET.VALUE",
  109: "LOG",
  110: "EXEC",
  111: "CHAR",
  112: "LOWER",
  113: "UPPER",
  114: "PROPER",
  115: "LEFT",
  116: "RIGHT",
  117: "EXACT",
  118: "TRIM",
  119: "REPLACE",
  120: "SUBSTITUTE",
  121: "CODE",
  122: "NAMES",
  123: "DIRECTORY",
  124: "FIND",
  125: "CELL",
  126: "ISERR",
  127: "ISTEXT",
  128: "ISNUMBER",
  129: "ISBLANK",
  130: "T",
  131: "N",
  132: "FOPEN",
  133: "FCLOSE",
  134: "FSIZE",
  135: "FREADLN",
  136: "FREAD",
  137: "FWRITELN",
  138: "FWRITE",
  139: "FPOS",
  140: "DATEVALUE",
  141: "TIMEVALUE",
  142: "SLN",
  143: "SYD",
  144: "DDB",
  145: "GET.DEF",
  146: "REFTEXT",
  147: "TEXTREF",
  148: "INDIRECT",
  149: "REGISTER",
  150: "CALL",
  151: "ADD.BAR",
  152: "ADD.MENU",
  153: "ADD.COMMAND",
  154: "ENABLE.COMMAND",
  155: "CHECK.COMMAND",
  156: "RENAME.COMMAND",
  157: "SHOW.BAR",
  158: "DELETE.MENU",
  159: "DELETE.COMMAND",
  160: "GET.CHART.ITEM",
  161: "DIALOG.BOX",
  162: "CLEAN",
  163: "MDETERM",
  164: "MINVERSE",
  165: "MMULT",
  166: "FILES",
  167: "IPMT",
  168: "PPMT",
  169: "COUNTA",
  170: "CANCEL.KEY",
  171: "FOR",
  172: "WHILE",
  173: "BREAK",
  174: "NEXT",
  175: "INITIATE",
  176: "REQUEST",
  177: "POKE",
  178: "EXECUTE",
  179: "TERMINATE",
  180: "RESTART",
  181: "HELP",
  182: "GET.BAR",
  183: "PRODUCT",
  184: "FACT",
  185: "GET.CELL",
  186: "GET.WORKSPACE",
  187: "GET.WINDOW",
  188: "GET.DOCUMENT",
  189: "DPRODUCT",
  190: "ISNONTEXT",
  191: "GET.NOTE",
  192: "NOTE",
  193: "STDEVP",
  194: "VARP",
  195: "DSTDEVP",
  196: "DVARP",
  197: "TRUNC",
  198: "ISLOGICAL",
  199: "DCOUNTA",
  200: "DELETE.BAR",
  201: "UNREGISTER",
  204: "USDOLLAR",
  205: "FINDB",
  206: "SEARCHB",
  207: "REPLACEB",
  208: "LEFTB",
  209: "RIGHTB",
  210: "MIDB",
  211: "LENB",
  212: "ROUNDUP",
  213: "ROUNDDOWN",
  214: "ASC",
  215: "DBCS",
  216: "RANK",
  219: "ADDRESS",
  220: "DAYS360",
  221: "TODAY",
  222: "VDB",
  223: "ELSE",
  224: "ELSE.IF",
  225: "END.IF",
  226: "FOR.CELL",
  227: "MEDIAN",
  228: "SUMPRODUCT",
  229: "SINH",
  230: "COSH",
  231: "TANH",
  232: "ASINH",
  233: "ACOSH",
  234: "ATANH",
  235: "DGET",
  236: "CREATE.OBJECT",
  237: "VOLATILE",
  238: "LAST.ERROR",
  239: "CUSTOM.UNDO",
  240: "CUSTOM.REPEAT",
  241: "FORMULA.CONVERT",
  242: "GET.LINK.INFO",
  243: "TEXT.BOX",
  244: "INFO",
  245: "GROUP",
  246: "GET.OBJECT",
  247: "DB",
  248: "PAUSE",
  251: "RESUME",
  252: "FREQUENCY",
  253: "ADD.TOOLBAR",
  254: "DELETE.TOOLBAR",
  255: "User",
  256: "RESET.TOOLBAR",
  257: "EVALUATE",
  258: "GET.TOOLBAR",
  259: "GET.TOOL",
  260: "SPELLING.CHECK",
  261: "ERROR.TYPE",
  262: "APP.TITLE",
  263: "WINDOW.TITLE",
  264: "SAVE.TOOLBAR",
  265: "ENABLE.TOOL",
  266: "PRESS.TOOL",
  267: "REGISTER.ID",
  268: "GET.WORKBOOK",
  269: "AVEDEV",
  270: "BETADIST",
  271: "GAMMALN",
  272: "BETAINV",
  273: "BINOMDIST",
  274: "CHIDIST",
  275: "CHIINV",
  276: "COMBIN",
  277: "CONFIDENCE",
  278: "CRITBINOM",
  279: "EVEN",
  280: "EXPONDIST",
  281: "FDIST",
  282: "FINV",
  283: "FISHER",
  284: "FISHERINV",
  285: "FLOOR",
  286: "GAMMADIST",
  287: "GAMMAINV",
  288: "CEILING",
  289: "HYPGEOMDIST",
  290: "LOGNORMDIST",
  291: "LOGINV",
  292: "NEGBINOMDIST",
  293: "NORMDIST",
  294: "NORMSDIST",
  295: "NORMINV",
  296: "NORMSINV",
  297: "STANDARDIZE",
  298: "ODD",
  299: "PERMUT",
  300: "POISSON",
  301: "TDIST",
  302: "WEIBULL",
  303: "SUMXMY2",
  304: "SUMX2MY2",
  305: "SUMX2PY2",
  306: "CHITEST",
  307: "CORREL",
  308: "COVAR",
  309: "FORECAST",
  310: "FTEST",
  311: "INTERCEPT",
  312: "PEARSON",
  313: "RSQ",
  314: "STEYX",
  315: "SLOPE",
  316: "TTEST",
  317: "PROB",
  318: "DEVSQ",
  319: "GEOMEAN",
  320: "HARMEAN",
  321: "SUMSQ",
  322: "KURT",
  323: "SKEW",
  324: "ZTEST",
  325: "LARGE",
  326: "SMALL",
  327: "QUARTILE",
  328: "PERCENTILE",
  329: "PERCENTRANK",
  330: "MODE",
  331: "TRIMMEAN",
  332: "TINV",
  334: "MOVIE.COMMAND",
  335: "GET.MOVIE",
  336: "CONCATENATE",
  337: "POWER",
  338: "PIVOT.ADD.DATA",
  339: "GET.PIVOT.TABLE",
  340: "GET.PIVOT.FIELD",
  341: "GET.PIVOT.ITEM",
  342: "RADIANS",
  343: "DEGREES",
  344: "SUBTOTAL",
  345: "SUMIF",
  346: "COUNTIF",
  347: "COUNTBLANK",
  348: "SCENARIO.GET",
  349: "OPTIONS.LISTS.GET",
  350: "ISPMT",
  351: "DATEDIF",
  352: "DATESTRING",
  353: "NUMBERSTRING",
  354: "ROMAN",
  355: "OPEN.DIALOG",
  356: "SAVE.DIALOG",
  357: "VIEW.GET",
  358: "GETPIVOTDATA",
  359: "HYPERLINK",
  360: "PHONETIC",
  361: "AVERAGEA",
  362: "MAXA",
  363: "MINA",
  364: "STDEVPA",
  365: "VARPA",
  366: "STDEVA",
  367: "VARA",
  368: "BAHTTEXT",
  369: "THAIDAYOFWEEK",
  370: "THAIDIGIT",
  371: "THAIMONTHOFYEAR",
  372: "THAINUMSOUND",
  373: "THAINUMSTRING",
  374: "THAISTRINGLENGTH",
  375: "ISTHAIDIGIT",
  376: "ROUNDBAHTDOWN",
  377: "ROUNDBAHTUP",
  378: "THAIYEAR",
  379: "RTD",
  380: "CUBEVALUE",
  381: "CUBEMEMBER",
  382: "CUBEMEMBERPROPERTY",
  383: "CUBERANKEDMEMBER",
  384: "HEX2BIN",
  385: "HEX2DEC",
  386: "HEX2OCT",
  387: "DEC2BIN",
  388: "DEC2HEX",
  389: "DEC2OCT",
  390: "OCT2BIN",
  391: "OCT2HEX",
  392: "OCT2DEC",
  393: "BIN2DEC",
  394: "BIN2OCT",
  395: "BIN2HEX",
  396: "IMSUB",
  397: "IMDIV",
  398: "IMPOWER",
  399: "IMABS",
  400: "IMSQRT",
  401: "IMLN",
  402: "IMLOG2",
  403: "IMLOG10",
  404: "IMSIN",
  405: "IMCOS",
  406: "IMEXP",
  407: "IMARGUMENT",
  408: "IMCONJUGATE",
  409: "IMAGINARY",
  410: "IMREAL",
  411: "COMPLEX",
  412: "IMSUM",
  413: "IMPRODUCT",
  414: "SERIESSUM",
  415: "FACTDOUBLE",
  416: "SQRTPI",
  417: "QUOTIENT",
  418: "DELTA",
  419: "GESTEP",
  420: "ISEVEN",
  421: "ISODD",
  422: "MROUND",
  423: "ERF",
  424: "ERFC",
  425: "BESSELJ",
  426: "BESSELK",
  427: "BESSELY",
  428: "BESSELI",
  429: "XIRR",
  430: "XNPV",
  431: "PRICEMAT",
  432: "YIELDMAT",
  433: "INTRATE",
  434: "RECEIVED",
  435: "DISC",
  436: "PRICEDISC",
  437: "YIELDDISC",
  438: "TBILLEQ",
  439: "TBILLPRICE",
  440: "TBILLYIELD",
  441: "PRICE",
  442: "YIELD",
  443: "DOLLARDE",
  444: "DOLLARFR",
  445: "NOMINAL",
  446: "EFFECT",
  447: "CUMPRINC",
  448: "CUMIPMT",
  449: "EDATE",
  450: "EOMONTH",
  451: "YEARFRAC",
  452: "COUPDAYBS",
  453: "COUPDAYS",
  454: "COUPDAYSNC",
  455: "COUPNCD",
  456: "COUPNUM",
  457: "COUPPCD",
  458: "DURATION",
  459: "MDURATION",
  460: "ODDLPRICE",
  461: "ODDLYIELD",
  462: "ODDFPRICE",
  463: "ODDFYIELD",
  464: "RANDBETWEEN",
  465: "WEEKNUM",
  466: "AMORDEGRC",
  467: "AMORLINC",
  468: "CONVERT",
  724: "SHEETJS",
  469: "ACCRINT",
  470: "ACCRINTM",
  471: "WORKDAY",
  472: "NETWORKDAYS",
  473: "GCD",
  474: "MULTINOMIAL",
  475: "LCM",
  476: "FVSCHEDULE",
  477: "CUBEKPIMEMBER",
  478: "CUBESET",
  479: "CUBESETCOUNT",
  480: "IFERROR",
  481: "COUNTIFS",
  482: "SUMIFS",
  483: "AVERAGEIF",
  484: "AVERAGEIFS"
}, FtabArgc = {
  2: 1,
  3: 1,
  10: 0,
  15: 1,
  16: 1,
  17: 1,
  18: 1,
  19: 0,
  20: 1,
  21: 1,
  22: 1,
  23: 1,
  24: 1,
  25: 1,
  26: 1,
  27: 2,
  30: 2,
  31: 3,
  32: 1,
  33: 1,
  34: 0,
  35: 0,
  38: 1,
  39: 2,
  40: 3,
  41: 3,
  42: 3,
  43: 3,
  44: 3,
  45: 3,
  47: 3,
  48: 2,
  53: 1,
  61: 3,
  63: 0,
  65: 3,
  66: 3,
  67: 1,
  68: 1,
  69: 1,
  70: 1,
  71: 1,
  72: 1,
  73: 1,
  74: 0,
  75: 1,
  76: 1,
  77: 1,
  79: 2,
  80: 2,
  83: 1,
  85: 0,
  86: 1,
  89: 0,
  90: 1,
  94: 0,
  95: 0,
  97: 2,
  98: 1,
  99: 1,
  101: 3,
  102: 3,
  105: 1,
  106: 1,
  108: 2,
  111: 1,
  112: 1,
  113: 1,
  114: 1,
  117: 2,
  118: 1,
  119: 4,
  121: 1,
  126: 1,
  127: 1,
  128: 1,
  129: 1,
  130: 1,
  131: 1,
  133: 1,
  134: 1,
  135: 1,
  136: 2,
  137: 2,
  138: 2,
  140: 1,
  141: 1,
  142: 3,
  143: 4,
  144: 4,
  161: 1,
  162: 1,
  163: 1,
  164: 1,
  165: 2,
  172: 1,
  175: 2,
  176: 2,
  177: 3,
  178: 2,
  179: 1,
  184: 1,
  186: 1,
  189: 3,
  190: 1,
  195: 3,
  196: 3,
  197: 1,
  198: 1,
  199: 3,
  201: 1,
  207: 4,
  210: 3,
  211: 1,
  212: 2,
  213: 2,
  214: 1,
  215: 1,
  225: 0,
  229: 1,
  230: 1,
  231: 1,
  232: 1,
  233: 1,
  234: 1,
  235: 3,
  244: 1,
  247: 4,
  252: 2,
  257: 1,
  261: 1,
  271: 1,
  273: 4,
  274: 2,
  275: 2,
  276: 2,
  277: 3,
  278: 3,
  279: 1,
  280: 3,
  281: 3,
  282: 3,
  283: 1,
  284: 1,
  285: 2,
  286: 4,
  287: 3,
  288: 2,
  289: 4,
  290: 3,
  291: 3,
  292: 3,
  293: 4,
  294: 1,
  295: 3,
  296: 1,
  297: 3,
  298: 1,
  299: 2,
  300: 3,
  301: 3,
  302: 4,
  303: 2,
  304: 2,
  305: 2,
  306: 2,
  307: 2,
  308: 2,
  309: 3,
  310: 2,
  311: 2,
  312: 2,
  313: 2,
  314: 2,
  315: 2,
  316: 4,
  325: 2,
  326: 2,
  327: 2,
  328: 2,
  331: 2,
  332: 2,
  337: 2,
  342: 1,
  343: 1,
  346: 2,
  347: 1,
  350: 4,
  351: 3,
  352: 1,
  353: 2,
  360: 1,
  368: 1,
  369: 1,
  370: 1,
  371: 1,
  372: 1,
  373: 1,
  374: 1,
  375: 1,
  376: 1,
  377: 1,
  378: 1,
  382: 3,
  385: 1,
  392: 1,
  393: 1,
  396: 2,
  397: 2,
  398: 2,
  399: 1,
  400: 1,
  401: 1,
  402: 1,
  403: 1,
  404: 1,
  405: 1,
  406: 1,
  407: 1,
  408: 1,
  409: 1,
  410: 1,
  414: 4,
  415: 1,
  416: 1,
  417: 2,
  420: 1,
  421: 1,
  422: 2,
  424: 1,
  425: 2,
  426: 2,
  427: 2,
  428: 2,
  430: 3,
  438: 3,
  439: 3,
  440: 3,
  443: 2,
  444: 2,
  445: 2,
  446: 2,
  447: 6,
  448: 6,
  449: 2,
  450: 2,
  464: 2,
  468: 3,
  476: 2,
  479: 1,
  480: 2,
  65535: 0
};
function ods_to_csf_formula(le) {
  return le.slice(0, 3) == "of:" && (le = le.slice(3)), le.charCodeAt(0) == 61 && (le = le.slice(1), le.charCodeAt(0) == 61 && (le = le.slice(1))), le = le.replace(/COM\.MICROSOFT\./g, ""), le = le.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function(Y, re) {
    return re.replace(/\./g, "");
  }), le = le.replace(/\$'([^']|'')+'/g, function(Y) {
    return Y.slice(1);
  }), le = le.replace(/\$([^\]\. #$]+)/g, function(Y, re) {
    return re.match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? Y : re;
  }), le = le.replace(/\[.(#[A-Z]*[?!])\]/g, "$1"), le.replace(/[;~]/g, ",").replace(/\|/g, ";");
}
function csf_to_ods_formula(le) {
  var Y = "of:=" + le.replace(crefregex, "$1[.$2$3$4$5]").replace(/\]:\[/g, ":");
  return Y.replace(/;/g, "|").replace(/,/g, ";");
}
function ods_to_csf_3D(le) {
  le = le.replace(/\$'([^']|'')+'/g, function(oe) {
    return oe.slice(1);
  }), le = le.replace(/\$([^\]\. #$]+)/g, function(oe, ue) {
    return ue.match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? oe : ue;
  });
  var Y = le.split(":"), re = Y[0].split(".")[0];
  return [re, Y[0].split(".")[1] + (Y.length > 1 ? ":" + (Y[1].split(".")[1] || Y[1].split(".")[0]) : "")];
}
function csf_to_ods_3D(le) {
  return le.replace(/!/, ".").replace(/:/, ":.");
}
var strs = {}, _ssfopts = {}, browser_has_Map = typeof Map < "u";
function get_sst_id(le, Y, re) {
  var oe = 0, ue = le.length;
  if (re) {
    if (browser_has_Map ? re.has(Y) : Object.prototype.hasOwnProperty.call(re, Y)) {
      for (var fe = browser_has_Map ? re.get(Y) : re[Y]; oe < fe.length; ++oe)
        if (le[fe[oe]].t === Y)
          return le.Count++, fe[oe];
    }
  } else for (; oe < ue; ++oe)
    if (le[oe].t === Y)
      return le.Count++, oe;
  return le[ue] = { t: Y }, le.Count++, le.Unique++, re && (browser_has_Map ? (re.has(Y) || re.set(Y, []), re.get(Y).push(ue)) : (Object.prototype.hasOwnProperty.call(re, Y) || (re[Y] = []), re[Y].push(ue))), ue;
}
function col_obj_w(le, Y) {
  var re = { min: le + 1, max: le + 1 }, oe = -1;
  return Y.MDW && (MDW = Y.MDW), Y.width != null ? re.customWidth = 1 : Y.wpx != null ? oe = px2char(Y.wpx) : Y.wch != null && (oe = Y.wch), oe > -1 ? (re.width = char2width(oe), re.customWidth = 1) : Y.width != null && (re.width = Y.width), Y.hidden && (re.hidden = !0), Y.level != null && (re.outlineLevel = re.level = Y.level), re;
}
function default_margins(le, Y) {
  if (le) {
    var re = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
    Y == "xlml" && (re = [1, 1, 1, 1, 0.5, 0.5]), le.left == null && (le.left = re[0]), le.right == null && (le.right = re[1]), le.top == null && (le.top = re[2]), le.bottom == null && (le.bottom = re[3]), le.header == null && (le.header = re[4]), le.footer == null && (le.footer = re[5]);
  }
}
function get_cell_style(le, Y, re) {
  var oe = re.revssf[Y.z != null ? Y.z : "General"], ue = 60, fe = le.length;
  if (oe == null && re.ssf) {
    for (; ue < 392; ++ue) if (re.ssf[ue] == null) {
      SSF__load(Y.z, ue), re.ssf[ue] = Y.z, re.revssf[Y.z] = oe = ue;
      break;
    }
  }
  for (ue = 0; ue != fe; ++ue) if (le[ue].numFmtId === oe) return ue;
  return le[fe] = {
    numFmtId: oe,
    fontId: 0,
    fillId: 0,
    borderId: 0,
    xfId: 0,
    applyNumberFormat: 1
  }, fe;
}
function safe_format(le, Y, re, oe, ue, fe, he) {
  try {
    oe.cellNF && (le.z = table_fmt[Y]);
  } catch (ve) {
    if (oe.WTF) throw ve;
  }
  if (!(le.t === "z" && !oe.cellStyles)) {
    if (le.t === "d" && typeof le.v == "string" && (le.v = parseDate(le.v)), (!oe || oe.cellText !== !1) && le.t !== "z") try {
      if (table_fmt[Y] == null && SSF__load(SSFImplicit[Y] || "General", Y), le.t === "e") le.w = le.w || BErr[le.v];
      else if (Y === 0)
        if (le.t === "n")
          (le.v | 0) === le.v ? le.w = le.v.toString(10) : le.w = SSF_general_num(le.v);
        else if (le.t === "d") {
          var _e = datenum(le.v, !!he);
          (_e | 0) === _e ? le.w = _e.toString(10) : le.w = SSF_general_num(_e);
        } else {
          if (le.v === void 0) return "";
          le.w = SSF_general(le.v, _ssfopts);
        }
      else le.t === "d" ? le.w = SSF_format(Y, datenum(le.v, !!he), _ssfopts) : le.w = SSF_format(Y, le.v, _ssfopts);
    } catch (ve) {
      if (oe.WTF) throw ve;
    }
    if (oe.cellStyles && re != null)
      try {
        le.s = fe.Fills[re], le.s.fgColor && le.s.fgColor.theme && !le.s.fgColor.rgb && (le.s.fgColor.rgb = rgb_tint(ue.themeElements.clrScheme[le.s.fgColor.theme].rgb, le.s.fgColor.tint || 0), oe.WTF && (le.s.fgColor.raw_rgb = ue.themeElements.clrScheme[le.s.fgColor.theme].rgb)), le.s.bgColor && le.s.bgColor.theme && (le.s.bgColor.rgb = rgb_tint(ue.themeElements.clrScheme[le.s.bgColor.theme].rgb, le.s.bgColor.tint || 0), oe.WTF && (le.s.bgColor.raw_rgb = ue.themeElements.clrScheme[le.s.bgColor.theme].rgb));
      } catch (ve) {
        if (oe.WTF && fe.Fills) throw ve;
      }
  }
}
function check_ws(le, Y, re) {
  if (le && le["!ref"]) {
    var oe = safe_decode_range(le["!ref"]);
    if (oe.e.c < oe.s.c || oe.e.r < oe.s.r) throw new Error("Bad range (" + re + "): " + le["!ref"]);
  }
}
function parse_ws_xml_dim(le, Y) {
  var re = safe_decode_range(Y);
  re.s.r <= re.e.r && re.s.c <= re.e.c && re.s.r >= 0 && re.s.c >= 0 && (le["!ref"] = encode_range(re));
}
var mergecregex = /<(?:\w+:)?mergeCell ref=["'][A-Z0-9:]+['"]\s*[\/]?>/g, hlinkregex = /<(?:\w+:)?hyperlink [^<>]*>/mg, dimregex = /"(\w*:\w*)"/, colregex = /<(?:\w+:)?col\b[^<>]*[\/]?>/g, afregex = /<(?:\w+:)?autoFilter[^>]*/g, marginregex = /<(?:\w+:)?pageMargins[^<>]*\/>/g, sheetprregex = /<(?:\w+:)?sheetPr\b[^<>]*?\/>/;
function parse_ws_xml(le, Y, re, oe, ue, fe, he) {
  if (!le) return le;
  oe || (oe = { "!id": {} });
  var _e = {};
  Y.dense && (_e["!data"] = []);
  var ve = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, xe = "", Ee = "", Se = str_match_xml_ns(le, "sheetData");
  Se ? (xe = le.slice(0, Se.index), Ee = le.slice(Se.index + Se[0].length)) : xe = Ee = le;
  var Te = xe.match(sheetprregex);
  Te ? parse_ws_xml_sheetpr(Te[0], _e, ue, re) : (Te = str_match_xml_ns(xe, "sheetPr")) && parse_ws_xml_sheetpr2(Te[0], Te[1] || "", _e, ue, re);
  var Ce = (xe.match(/<(?:\w*:)?dimension/) || { index: -1 }).index;
  if (Ce > 0) {
    var Ie = xe.slice(Ce, Ce + 50).match(dimregex);
    Ie && !(Y && Y.nodim) && parse_ws_xml_dim(_e, Ie[1]);
  }
  var Ne = str_match_xml_ns(xe, "sheetViews");
  Ne && Ne[1] && parse_ws_xml_sheetviews(Ne[1], ue);
  var Re = [];
  if (Y.cellStyles) {
    var Ae = xe.match(colregex);
    Ae && parse_ws_xml_cols(Re, Ae);
  }
  Se && parse_ws_xml_data(Se[1], _e, Y, ve, fe, he, ue);
  var Pe = Ee.match(afregex);
  Pe && (_e["!autofilter"] = parse_ws_xml_autofilter(Pe[0]));
  var Fe = [], Le = Ee.match(mergecregex);
  if (Le) for (Ce = 0; Ce != Le.length; ++Ce)
    Fe[Ce] = safe_decode_range(Le[Ce].slice(Le[Ce].indexOf("=") + 2));
  var He = Ee.match(hlinkregex);
  He && parse_ws_xml_hlinks(_e, He, oe);
  var Ge = Ee.match(marginregex);
  Ge && (_e["!margins"] = parse_ws_xml_margins(parsexmltag(Ge[0])));
  var Ve;
  if ((Ve = Ee.match(/legacyDrawing r:id="(.*?)"/)) && (_e["!legrel"] = Ve[1]), Y && Y.nodim && (ve.s.c = ve.s.r = 0), !_e["!ref"] && ve.e.c >= ve.s.c && ve.e.r >= ve.s.r && (_e["!ref"] = encode_range(ve)), Y.sheetRows > 0 && _e["!ref"]) {
    var $e = safe_decode_range(_e["!ref"]);
    Y.sheetRows <= +$e.e.r && ($e.e.r = Y.sheetRows - 1, $e.e.r > ve.e.r && ($e.e.r = ve.e.r), $e.e.r < $e.s.r && ($e.s.r = $e.e.r), $e.e.c > ve.e.c && ($e.e.c = ve.e.c), $e.e.c < $e.s.c && ($e.s.c = $e.e.c), _e["!fullref"] = _e["!ref"], _e["!ref"] = encode_range($e));
  }
  return Re.length > 0 && (_e["!cols"] = Re), Fe.length > 0 && (_e["!merges"] = Fe), oe["!id"][_e["!legrel"]] && (_e["!legdrawel"] = oe["!id"][_e["!legrel"]]), _e;
}
function write_ws_xml_merges(le) {
  if (le.length === 0) return "";
  for (var Y = '<mergeCells count="' + le.length + '">', re = 0; re != le.length; ++re) Y += '<mergeCell ref="' + encode_range(le[re]) + '"/>';
  return Y + "</mergeCells>";
}
function parse_ws_xml_sheetpr(le, Y, re, oe) {
  var ue = parsexmltag(le);
  re.Sheets[oe] || (re.Sheets[oe] = {}), ue.codeName && (re.Sheets[oe].CodeName = unescapexml(utf8read(ue.codeName)));
}
function parse_ws_xml_sheetpr2(le, Y, re, oe, ue) {
  parse_ws_xml_sheetpr(le.slice(0, le.indexOf(">")), re, oe, ue);
}
function write_ws_xml_sheetpr(le, Y, re, oe, ue) {
  var fe = !1, he = {}, _e = null;
  if (oe.bookType !== "xlsx" && Y.vbaraw) {
    var ve = Y.SheetNames[re];
    try {
      Y.Workbook && (ve = Y.Workbook.Sheets[re].CodeName || ve);
    } catch {
    }
    fe = !0, he.codeName = utf8write(escapexml(ve));
  }
  if (le && le["!outline"]) {
    var xe = { summaryBelow: 1, summaryRight: 1 };
    le["!outline"].above && (xe.summaryBelow = 0), le["!outline"].left && (xe.summaryRight = 0), _e = (_e || "") + writextag("outlinePr", null, xe);
  }
  !fe && !_e || (ue[ue.length] = writextag("sheetPr", _e, he));
}
var sheetprot_deffalse = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"], sheetprot_deftrue = [
  "formatColumns",
  "formatRows",
  "formatCells",
  "insertColumns",
  "insertRows",
  "insertHyperlinks",
  "deleteColumns",
  "deleteRows",
  "sort",
  "autoFilter",
  "pivotTables"
];
function write_ws_xml_protection(le) {
  var Y = { sheet: 1 };
  return sheetprot_deffalse.forEach(function(re) {
    le[re] != null && le[re] && (Y[re] = "1");
  }), sheetprot_deftrue.forEach(function(re) {
    le[re] != null && !le[re] && (Y[re] = "0");
  }), le.password && (Y.password = crypto_CreatePasswordVerifier_Method1(le.password).toString(16).toUpperCase()), writextag("sheetProtection", null, Y);
}
function parse_ws_xml_hlinks(le, Y, re) {
  for (var oe = le["!data"] != null, ue = 0; ue != Y.length; ++ue) {
    var fe = parsexmltag(utf8read(Y[ue]), !0);
    if (!fe.ref) return;
    var he = ((re || {})["!id"] || [])[fe.id];
    he ? (fe.Target = he.Target, fe.location && (fe.Target += "#" + unescapexml(fe.location))) : (fe.Target = "#" + unescapexml(fe.location), he = { Target: fe.Target, TargetMode: "Internal" }), fe.Rel = he, fe.tooltip && (fe.Tooltip = fe.tooltip, delete fe.tooltip);
    for (var _e = safe_decode_range(fe.ref), ve = _e.s.r; ve <= _e.e.r; ++ve) for (var xe = _e.s.c; xe <= _e.e.c; ++xe) {
      var Ee = encode_col(xe) + encode_row(ve);
      oe ? (le["!data"][ve] || (le["!data"][ve] = []), le["!data"][ve][xe] || (le["!data"][ve][xe] = { t: "z", v: void 0 }), le["!data"][ve][xe].l = fe) : (le[Ee] || (le[Ee] = { t: "z", v: void 0 }), le[Ee].l = fe);
    }
  }
}
function parse_ws_xml_margins(le) {
  var Y = {};
  return ["left", "right", "top", "bottom", "header", "footer"].forEach(function(re) {
    le[re] && (Y[re] = parseFloat(le[re]));
  }), Y;
}
function write_ws_xml_margins(le) {
  return default_margins(le), writextag("pageMargins", null, le);
}
function parse_ws_xml_cols(le, Y) {
  for (var re = !1, oe = 0; oe != Y.length; ++oe) {
    var ue = parsexmltag(Y[oe], !0);
    ue.hidden && (ue.hidden = parsexmlbool(ue.hidden));
    var fe = parseInt(ue.min, 10) - 1, he = parseInt(ue.max, 10) - 1;
    for (ue.outlineLevel && (ue.level = +ue.outlineLevel || 0), delete ue.min, delete ue.max, ue.width = +ue.width, !re && ue.width && (re = !0, find_mdw_colw(ue.width)), process_col(ue); fe <= he; ) le[fe++] = dup(ue);
  }
}
function write_ws_xml_cols(le, Y) {
  for (var re = ["<cols>"], oe, ue = 0; ue != Y.length; ++ue)
    (oe = Y[ue]) && (re[re.length] = writextag("col", null, col_obj_w(ue, oe)));
  return re[re.length] = "</cols>", re.join("");
}
function parse_ws_xml_autofilter(le) {
  var Y = { ref: (le.match(/ref="([^"]*)"/) || [])[1] };
  return Y;
}
function write_ws_xml_autofilter(le, Y, re, oe) {
  var ue = typeof le.ref == "string" ? le.ref : encode_range(le.ref);
  re.Workbook || (re.Workbook = { Sheets: [] }), re.Workbook.Names || (re.Workbook.Names = []);
  var fe = re.Workbook.Names, he = decode_range(ue);
  he.s.r == he.e.r && (he.e.r = decode_range(Y["!ref"]).e.r, ue = encode_range(he));
  for (var _e = 0; _e < fe.length; ++_e) {
    var ve = fe[_e];
    if (ve.Name == "_xlnm._FilterDatabase" && ve.Sheet == oe) {
      ve.Ref = formula_quote_sheet_name(re.SheetNames[oe]) + "!" + fix_range(ue);
      break;
    }
  }
  return _e == fe.length && fe.push({ Name: "_xlnm._FilterDatabase", Sheet: oe, Ref: "'" + re.SheetNames[oe] + "'!" + ue }), writextag("autoFilter", null, { ref: ue });
}
var sviewregex = /<(?:\w:)?sheetView(?:[^<>a-z][^<>]*)?\/?>/g;
function parse_ws_xml_sheetviews(le, Y) {
  Y.Views || (Y.Views = [{}]), (le.match(sviewregex) || []).forEach(function(re, oe) {
    var ue = parsexmltag(re);
    Y.Views[oe] || (Y.Views[oe] = {}), +ue.zoomScale && (Y.Views[oe].zoom = +ue.zoomScale), ue.rightToLeft && parsexmlbool(ue.rightToLeft) && (Y.Views[oe].RTL = !0);
  });
}
function write_ws_xml_sheetviews(le, Y, re, oe) {
  var ue = { workbookViewId: "0" };
  return (((oe || {}).Workbook || {}).Views || [])[0] && (ue.rightToLeft = oe.Workbook.Views[0].RTL ? "1" : "0"), writextag("sheetViews", writextag("sheetView", null, ue), {});
}
function write_ws_xml_cell(le, Y, re, oe, ue, fe, he) {
  if (le.c && re["!comments"].push([Y, le.c]), (le.v === void 0 || le.t === "z" && !(oe || {}).sheetStubs) && typeof le.f != "string" && typeof le.z > "u") return "";
  var _e = "", ve = le.t, xe = le.v;
  if (le.t !== "z") switch (le.t) {
    case "b":
      _e = le.v ? "1" : "0";
      break;
    case "n":
      isNaN(le.v) ? (le.t = "e", _e = BErr[le.v = 36]) : isFinite(le.v) ? _e = "" + le.v : (le.t = "e", _e = BErr[le.v = 7]);
      break;
    case "e":
      _e = BErr[le.v];
      break;
    case "d":
      if (oe && oe.cellDates) {
        var Ee = parseDate(le.v, he);
        _e = Ee.toISOString(), Ee.getUTCFullYear() < 1900 && (_e = _e.slice(_e.indexOf("T") + 1).replace("Z", ""));
      } else
        le = dup(le), le.t = "n", _e = "" + (le.v = datenum(parseDate(le.v, he), he));
      typeof le.z > "u" && (le.z = table_fmt[14]);
      break;
    default:
      _e = le.v;
      break;
  }
  var Se = le.t == "z" || le.v == null ? "" : writetag("v", escapexml(_e)), Te = { r: Y }, Ce = get_cell_style(oe.cellXfs, le, oe);
  switch (Ce !== 0 && (Te.s = Ce), le.t) {
    case "n":
      break;
    case "d":
      Te.t = "d";
      break;
    case "b":
      Te.t = "b";
      break;
    case "e":
      Te.t = "e";
      break;
    case "z":
      break;
    default:
      if (le.v == null) {
        delete le.t;
        break;
      }
      if (le.v.length > 32767) throw new Error("Text length must not exceed 32767 characters");
      if (oe && oe.bookSST) {
        Se = writetag("v", "" + get_sst_id(oe.Strings, le.v, oe.revStrings)), Te.t = "s";
        break;
      } else Te.t = "str";
      break;
  }
  if (le.t != ve && (le.t = ve, le.v = xe), typeof le.f == "string" && le.f) {
    var Ie = le.F && le.F.slice(0, Y.length) == Y ? { t: "array", ref: le.F } : null;
    Se = writextag("f", escapexml(le.f), Ie) + (le.v != null ? Se : "");
  }
  return le.l && (le.l.display = escapexml(_e), re["!links"].push([Y, le.l])), le.D && (Te.cm = 1), writextag("c", Se, Te);
}
var parse_ws_xml_data = /* @__PURE__ */ function() {
  var le = /<(?:\w+:)?c[ \/>]/, Y = /<\/(?:\w+:)?row>/, re = /r=["']([^"']*)["']/, oe = /ref=["']([^"']*)["']/;
  return function(fe, he, _e, ve, xe, Ee, Se) {
    for (var Te = 0, Ce = "", Ie = [], Ne = [], Re = 0, Ae = 0, Pe = 0, Fe = "", Le, He, Ge = 0, Ve = 0, $e, De, Ke = 0, ze = 0, tt = Array.isArray(Ee.CellXf), Xe, mt = [], at = [], qe = he["!data"] != null, st = [], xt = {}, gt = !1, Ze = !!_e.sheetStubs, _t = !!((Se || {}).WBProps || {}).date1904, wt = fe.split(Y), yt = 0, St = wt.length; yt != St; ++yt) {
      Ce = wt[yt].trim();
      var It = Ce.length;
      if (It !== 0) {
        var Bt = 0;
        e: for (Te = 0; Te < It; ++Te) switch (
          /*x.charCodeAt(ri)*/
          Ce[Te]
        ) {
          case ">":
            if (
              /*x.charCodeAt(ri-1) != 47*/
              Ce[Te - 1] != "/"
            ) {
              ++Te;
              break e;
            }
            if (_e && _e.cellStyles) {
              if (He = parsexmltag(Ce.slice(Bt, Te), !0), Ge = He.r != null ? parseInt(He.r, 10) : Ge + 1, Ve = -1, _e.sheetRows && _e.sheetRows < Ge) continue;
              xt = {}, gt = !1, He.ht && (gt = !0, xt.hpt = parseFloat(He.ht), xt.hpx = pt2px(xt.hpt)), He.hidden && parsexmlbool(He.hidden) && (gt = !0, xt.hidden = !0), He.outlineLevel != null && (gt = !0, xt.level = +He.outlineLevel), gt && (st[Ge - 1] = xt);
            }
            break;
          case "<":
            Bt = Te;
            break;
        }
        if (Bt >= Te) break;
        if (He = parsexmltag(Ce.slice(Bt, Te), !0), Ge = He.r != null ? parseInt(He.r, 10) : Ge + 1, Ve = -1, !(_e.sheetRows && _e.sheetRows < Ge)) {
          _e.nodim || (ve.s.r > Ge - 1 && (ve.s.r = Ge - 1), ve.e.r < Ge - 1 && (ve.e.r = Ge - 1)), _e && _e.cellStyles && (xt = {}, gt = !1, He.ht && (gt = !0, xt.hpt = parseFloat(He.ht), xt.hpx = pt2px(xt.hpt)), He.hidden && parsexmlbool(He.hidden) && (gt = !0, xt.hidden = !0), He.outlineLevel != null && (gt = !0, xt.level = +He.outlineLevel), gt && (st[Ge - 1] = xt)), Ie = Ce.slice(Te).split(le);
          for (var Ye = 0; Ye != Ie.length && Ie[Ye].trim().charAt(0) == "<"; ++Ye) ;
          for (Ie = Ie.slice(Ye), Te = 0; Te != Ie.length; ++Te)
            if (Ce = Ie[Te].trim(), Ce.length !== 0) {
              if (Ne = Ce.match(re), Re = Te, Ae = 0, Pe = 0, Ce = "<c " + (Ce.slice(0, 1) == "<" ? ">" : "") + Ce, Ne != null && Ne.length === 2) {
                for (Re = 0, Fe = Ne[1], Ae = 0; Ae != Fe.length && !((Pe = Fe.charCodeAt(Ae) - 64) < 1 || Pe > 26); ++Ae)
                  Re = 26 * Re + Pe;
                --Re, Ve = Re;
              } else ++Ve;
              for (Ae = 0; Ae != Ce.length && Ce.charCodeAt(Ae) !== 62; ++Ae) ;
              if (++Ae, He = parsexmltag(Ce.slice(0, Ae), !0), He.r || (He.r = encode_cell({ r: Ge - 1, c: Ve })), Fe = Ce.slice(Ae), Le = { t: "" }, (Ne = str_match_xml_ns(Fe, "v")) != null && /*::cref != null && */
              Ne[1] !== "" && (Le.v = unescapexml(Ne[1])), _e.cellFormula) {
                if ((Ne = str_match_xml_ns(Fe, "f")) != null) {
                  if (Ne[1] == "")
                    /*::cref != null && cref[0] != null && */
                    Ne[0].indexOf('t="shared"') > -1 && (De = parsexmltag(Ne[0]), at[De.si] && (Le.f = shift_formula_xlsx(at[De.si][1], at[De.si][2], He.r)));
                  else if (Le.f = unescapexml(utf8read(Ne[1]), !0), _e.xlfn || (Le.f = _xlfn(Le.f)), /*::cref != null && cref[0] != null && */
                  Ne[0].indexOf('t="array"') > -1)
                    Le.F = (Fe.match(oe) || [])[1], Le.F.indexOf(":") > -1 && mt.push([safe_decode_range(Le.F), Le.F]);
                  else if (
                    /*::cref != null && cref[0] != null && */
                    Ne[0].indexOf('t="shared"') > -1
                  ) {
                    De = parsexmltag(Ne[0]);
                    var Be = unescapexml(utf8read(Ne[1]));
                    _e.xlfn || (Be = _xlfn(Be)), at[parseInt(De.si, 10)] = [De, Be, He.r];
                  }
                } else (Ne = Fe.match(/<f[^<>]*\/>/)) && (De = parsexmltag(Ne[0]), at[De.si] && (Le.f = shift_formula_xlsx(at[De.si][1], at[De.si][2], He.r)));
                var et = decode_cell(He.r);
                for (Ae = 0; Ae < mt.length; ++Ae)
                  et.r >= mt[Ae][0].s.r && et.r <= mt[Ae][0].e.r && et.c >= mt[Ae][0].s.c && et.c <= mt[Ae][0].e.c && (Le.F = mt[Ae][1]);
              }
              if (He.t == null && Le.v === void 0)
                if (Le.f || Le.F)
                  Le.v = 0, Le.t = "n";
                else if (Ze) Le.t = "z";
                else continue;
              else Le.t = He.t || "n";
              switch (ve.s.c > Ve && (ve.s.c = Ve), ve.e.c < Ve && (ve.e.c = Ve), Le.t) {
                case "n":
                  if (Le.v == "" || Le.v == null) {
                    if (!Ze) continue;
                    Le.t = "z";
                  } else Le.v = parseFloat(Le.v);
                  break;
                case "s":
                  if (typeof Le.v > "u") {
                    if (!Ze) continue;
                    Le.t = "z";
                  } else
                    $e = strs[parseInt(Le.v, 10)], Le.v = $e.t, Le.r = $e.r, _e.cellHTML && (Le.h = $e.h);
                  break;
                case "str":
                  Le.t = "s", Le.v = Le.v != null ? unescapexml(utf8read(Le.v), !0) : "", _e.cellHTML && (Le.h = escapehtml(Le.v));
                  break;
                case "inlineStr":
                  Ne = str_match_xml_ns(Fe, "is"), Le.t = "s", Ne != null && ($e = parse_si(Ne[1])) ? (Le.v = $e.t, _e.cellHTML && (Le.h = $e.h)) : Le.v = "";
                  break;
                case "b":
                  Le.v = parsexmlbool(Le.v);
                  break;
                case "d":
                  _e.cellDates ? Le.v = parseDate(Le.v, _t) : (Le.v = datenum(parseDate(Le.v, _t), _t), Le.t = "n");
                  break;
                /* error string in .w, number in .v */
                case "e":
                  (!_e || _e.cellText !== !1) && (Le.w = Le.v), Le.v = RBErr[Le.v];
                  break;
              }
              if (Ke = ze = 0, Xe = null, tt && He.s !== void 0 && (Xe = Ee.CellXf[He.s], Xe != null && (Xe.numFmtId != null && (Ke = Xe.numFmtId), _e.cellStyles && Xe.fillId != null && (ze = Xe.fillId))), safe_format(Le, Ke, ze, _e, xe, Ee, _t), _e.cellDates && tt && Le.t == "n" && fmt_is_date(table_fmt[Ke]) && (Le.v = numdate(Le.v + (_t ? 1462 : 0)), Le.t = typeof Le.v == "number" ? "n" : "d"), He.cm && _e.xlmeta) {
                var je = (_e.xlmeta.Cell || [])[+He.cm - 1];
                je && je.type == "XLDAPR" && (Le.D = !0);
              }
              var it;
              _e.nodim && (it = decode_cell(He.r), ve.s.r > it.r && (ve.s.r = it.r), ve.e.r < it.r && (ve.e.r = it.r)), qe ? (it = decode_cell(He.r), he["!data"][it.r] || (he["!data"][it.r] = []), he["!data"][it.r][it.c] = Le) : he[He.r] = Le;
            }
        }
      }
    }
    st.length > 0 && (he["!rows"] = st);
  };
}();
function write_ws_xml_data(le, Y, re, oe) {
  var ue = [], fe = [], he = safe_decode_range(le["!ref"]), _e = "", ve, xe = "", Ee = [], Se = 0, Te = 0, Ce = le["!rows"], Ie = le["!data"] != null, Ne = Ie ? le["!data"] : [], Re = { r: xe }, Ae, Pe = -1, Fe = (((oe || {}).Workbook || {}).WBProps || {}).date1904;
  for (Te = he.s.c; Te <= he.e.c; ++Te) Ee[Te] = encode_col(Te);
  for (Se = he.s.r; Se <= he.e.r; ++Se) {
    fe = [], xe = encode_row(Se);
    var Le = Ie ? Ne[Se] : [];
    for (Te = he.s.c; Te <= he.e.c; ++Te) {
      ve = Ee[Te] + xe;
      var He = Ie ? Le[Te] : le[ve];
      He !== void 0 && (_e = write_ws_xml_cell(He, ve, le, Y, re, oe, Fe)) != null && fe.push(_e);
    }
    (fe.length > 0 || Ce && Ce[Se]) && (Re = { r: xe }, Ce && Ce[Se] && (Ae = Ce[Se], Ae.hidden && (Re.hidden = 1), Pe = -1, Ae.hpx ? Pe = px2pt(Ae.hpx) : Ae.hpt && (Pe = Ae.hpt), Pe > -1 && (Re.ht = Pe, Re.customHeight = 1), Ae.level && (Re.outlineLevel = Ae.level)), ue[ue.length] = writextag("row", fe.join(""), Re));
  }
  if (Ce) for (; Se < Ce.length; ++Se)
    Ce && Ce[Se] && (Re = { r: Se + 1 }, Ae = Ce[Se], Ae.hidden && (Re.hidden = 1), Pe = -1, Ae.hpx ? Pe = px2pt(Ae.hpx) : Ae.hpt && (Pe = Ae.hpt), Pe > -1 && (Re.ht = Pe, Re.customHeight = 1), Ae.level && (Re.outlineLevel = Ae.level), ue[ue.length] = writextag("row", "", Re));
  return ue.join("");
}
function write_ws_xml(le, Y, re, oe) {
  var ue = [XML_HEADER, writextag("worksheet", null, {
    xmlns: XMLNS_main[0],
    "xmlns:r": XMLNS.r
  })], fe = re.SheetNames[le], he = 0, _e = "", ve = re.Sheets[fe];
  ve == null && (ve = {});
  var xe = ve["!ref"] || "A1", Ee = safe_decode_range(xe);
  if (Ee.e.c > 16383 || Ee.e.r > 1048575) {
    if (Y.WTF) throw new Error("Range " + xe + " exceeds format limit A1:XFD1048576");
    Ee.e.c = Math.min(Ee.e.c, 16383), Ee.e.r = Math.min(Ee.e.c, 1048575), xe = encode_range(Ee);
  }
  oe || (oe = {}), ve["!comments"] = [];
  var Se = [];
  write_ws_xml_sheetpr(ve, re, le, Y, ue), ue[ue.length] = writextag("dimension", null, { ref: xe }), ue[ue.length] = write_ws_xml_sheetviews(ve, Y, le, re), Y.sheetFormat && (ue[ue.length] = writextag("sheetFormatPr", null, {
    defaultRowHeight: Y.sheetFormat.defaultRowHeight || "16",
    baseColWidth: Y.sheetFormat.baseColWidth || "10",
    outlineLevelRow: Y.sheetFormat.outlineLevelRow || "7"
  })), ve["!cols"] != null && ve["!cols"].length > 0 && (ue[ue.length] = write_ws_xml_cols(ve, ve["!cols"])), ue[he = ue.length] = "<sheetData/>", ve["!links"] = [], ve["!ref"] != null && (_e = write_ws_xml_data(ve, Y, le, re), _e.length > 0 && (ue[ue.length] = _e)), ue.length > he + 1 && (ue[ue.length] = "</sheetData>", ue[he] = ue[he].replace("/>", ">")), ve["!protect"] && (ue[ue.length] = write_ws_xml_protection(ve["!protect"])), ve["!autofilter"] != null && (ue[ue.length] = write_ws_xml_autofilter(ve["!autofilter"], ve, re, le)), ve["!merges"] != null && ve["!merges"].length > 0 && (ue[ue.length] = write_ws_xml_merges(ve["!merges"]));
  var Te = -1, Ce, Ie = -1;
  return (
    /*::(*/
    ve["!links"].length > 0 && (ue[ue.length] = "<hyperlinks>", ve["!links"].forEach(function(Ne) {
      Ne[1].Target && (Ce = { ref: Ne[0] }, Ne[1].Target.charAt(0) != "#" && (Ie = add_rels(oe, -1, escapexml(Ne[1].Target).replace(/#[\s\S]*$/, ""), RELS.HLINK), Ce["r:id"] = "rId" + Ie), (Te = Ne[1].Target.indexOf("#")) > -1 && (Ce.location = escapexml(Ne[1].Target.slice(Te + 1))), Ne[1].Tooltip && (Ce.tooltip = escapexml(Ne[1].Tooltip)), Ce.display = Ne[1].display, ue[ue.length] = writextag("hyperlink", null, Ce));
    }), ue[ue.length] = "</hyperlinks>"), delete ve["!links"], ve["!margins"] != null && (ue[ue.length] = write_ws_xml_margins(ve["!margins"])), (!Y || Y.ignoreEC || Y.ignoreEC == null) && (ue[ue.length] = writetag("ignoredErrors", writextag("ignoredError", null, { numberStoredAsText: 1, sqref: xe }))), Se.length > 0 && (Ie = add_rels(oe, -1, "../drawings/drawing" + (le + 1) + ".xml", RELS.DRAW), ue[ue.length] = writextag("drawing", null, { "r:id": "rId" + Ie }), ve["!drawing"] = Se), ve["!comments"].length > 0 && (Ie = add_rels(oe, -1, "../drawings/vmlDrawing" + (le + 1) + ".vml", RELS.VML), ue[ue.length] = writextag("legacyDrawing", null, { "r:id": "rId" + Ie }), ve["!legacy"] = Ie), ue.length > 1 && (ue[ue.length] = "</worksheet>", ue[1] = ue[1].replace("/>", ">")), ue.join("")
  );
}
function parse_BrtRowHdr(le, Y) {
  var re = {}, oe = le.l + Y;
  re.r = le.read_shift(4), le.l += 4;
  var ue = le.read_shift(2);
  le.l += 1;
  var fe = le.read_shift(1);
  return le.l = oe, fe & 7 && (re.level = fe & 7), fe & 16 && (re.hidden = !0), fe & 32 && (re.hpt = ue / 20), re;
}
function write_BrtRowHdr(le, Y, re) {
  var oe = new_buf(145), ue = (re["!rows"] || [])[le] || {};
  oe.write_shift(4, le), oe.write_shift(4, 0);
  var fe = 320;
  ue.hpx ? fe = px2pt(ue.hpx) * 20 : ue.hpt && (fe = ue.hpt * 20), oe.write_shift(2, fe), oe.write_shift(1, 0);
  var he = 0;
  ue.level && (he |= ue.level), ue.hidden && (he |= 16), (ue.hpx || ue.hpt) && (he |= 32), oe.write_shift(1, he), oe.write_shift(1, 0);
  var _e = 0, ve = oe.l;
  oe.l += 4;
  for (var xe = { r: le, c: 0 }, Ee = re["!data"] != null, Se = 0; Se < 16; ++Se)
    if (!(Y.s.c > Se + 1 << 10 || Y.e.c < Se << 10)) {
      for (var Te = -1, Ce = -1, Ie = Se << 10; Ie < Se + 1 << 10; ++Ie) {
        xe.c = Ie;
        var Ne = Ee ? (re["!data"][xe.r] || [])[xe.c] : re[encode_cell(xe)];
        Ne && (Te < 0 && (Te = Ie), Ce = Ie);
      }
      Te < 0 || (++_e, oe.write_shift(4, Te), oe.write_shift(4, Ce));
    }
  var Re = oe.l;
  return oe.l = ve, oe.write_shift(4, _e), oe.l = Re, oe.length > oe.l ? oe.slice(0, oe.l) : oe;
}
function write_row_header(le, Y, re, oe) {
  var ue = write_BrtRowHdr(oe, re, Y);
  (ue.length > 17 || (Y["!rows"] || [])[oe]) && write_record(le, 0, ue);
}
var parse_BrtWsDim = parse_UncheckedRfX, write_BrtWsDim = write_UncheckedRfX;
function parse_BrtWsFmtInfo() {
}
function parse_BrtWsProp(le, Y) {
  var re = {}, oe = le[le.l];
  return ++le.l, re.above = !(oe & 64), re.left = !(oe & 128), le.l += 18, re.name = parse_XLSBCodeName(le), re;
}
function write_BrtWsProp(le, Y, re) {
  re == null && (re = new_buf(84 + 4 * le.length));
  var oe = 192;
  Y && (Y.above && (oe &= -65), Y.left && (oe &= -129)), re.write_shift(1, oe);
  for (var ue = 1; ue < 3; ++ue) re.write_shift(1, 0);
  return write_BrtColor({ auto: 1 }, re), re.write_shift(-4, -1), re.write_shift(-4, -1), write_XLSBCodeName(le, re), re.slice(0, re.l);
}
function parse_BrtCellBlank(le) {
  var Y = parse_XLSBCell(le);
  return [Y];
}
function write_BrtCellBlank(le, Y, re) {
  return re == null && (re = new_buf(8)), write_XLSBCell(Y, re);
}
function parse_BrtShortBlank(le) {
  var Y = parse_XLSBShortCell(le);
  return [Y];
}
function write_BrtShortBlank(le, Y, re) {
  return re == null && (re = new_buf(4)), write_XLSBShortCell(Y, re);
}
function parse_BrtCellBool(le) {
  var Y = parse_XLSBCell(le), re = le.read_shift(1);
  return [Y, re, "b"];
}
function write_BrtCellBool(le, Y, re) {
  return re == null && (re = new_buf(9)), write_XLSBCell(Y, re), re.write_shift(1, le.v ? 1 : 0), re;
}
function parse_BrtShortBool(le) {
  var Y = parse_XLSBShortCell(le), re = le.read_shift(1);
  return [Y, re, "b"];
}
function write_BrtShortBool(le, Y, re) {
  return re == null && (re = new_buf(5)), write_XLSBShortCell(Y, re), re.write_shift(1, le.v ? 1 : 0), re;
}
function parse_BrtCellError(le) {
  var Y = parse_XLSBCell(le), re = le.read_shift(1);
  return [Y, re, "e"];
}
function write_BrtCellError(le, Y, re) {
  return re == null && (re = new_buf(9)), write_XLSBCell(Y, re), re.write_shift(1, le.v), re;
}
function parse_BrtShortError(le) {
  var Y = parse_XLSBShortCell(le), re = le.read_shift(1);
  return [Y, re, "e"];
}
function write_BrtShortError(le, Y, re) {
  return re == null && (re = new_buf(8)), write_XLSBShortCell(Y, re), re.write_shift(1, le.v), re.write_shift(2, 0), re.write_shift(1, 0), re;
}
function parse_BrtCellIsst(le) {
  var Y = parse_XLSBCell(le), re = le.read_shift(4);
  return [Y, re, "s"];
}
function write_BrtCellIsst(le, Y, re) {
  return re == null && (re = new_buf(12)), write_XLSBCell(Y, re), re.write_shift(4, Y.v), re;
}
function parse_BrtShortIsst(le) {
  var Y = parse_XLSBShortCell(le), re = le.read_shift(4);
  return [Y, re, "s"];
}
function write_BrtShortIsst(le, Y, re) {
  return re == null && (re = new_buf(8)), write_XLSBShortCell(Y, re), re.write_shift(4, Y.v), re;
}
function parse_BrtCellReal(le) {
  var Y = parse_XLSBCell(le), re = parse_Xnum(le);
  return [Y, re, "n"];
}
function write_BrtCellReal(le, Y, re) {
  return re == null && (re = new_buf(16)), write_XLSBCell(Y, re), write_Xnum(le.v, re), re;
}
function parse_BrtShortReal(le) {
  var Y = parse_XLSBShortCell(le), re = parse_Xnum(le);
  return [Y, re, "n"];
}
function write_BrtShortReal(le, Y, re) {
  return re == null && (re = new_buf(12)), write_XLSBShortCell(Y, re), write_Xnum(le.v, re), re;
}
function parse_BrtCellRk(le) {
  var Y = parse_XLSBCell(le), re = parse_RkNumber(le);
  return [Y, re, "n"];
}
function write_BrtCellRk(le, Y, re) {
  return re == null && (re = new_buf(12)), write_XLSBCell(Y, re), write_RkNumber(le.v, re), re;
}
function parse_BrtShortRk(le) {
  var Y = parse_XLSBShortCell(le), re = parse_RkNumber(le);
  return [Y, re, "n"];
}
function write_BrtShortRk(le, Y, re) {
  return re == null && (re = new_buf(8)), write_XLSBShortCell(Y, re), write_RkNumber(le.v, re), re;
}
function parse_BrtCellRString(le) {
  var Y = parse_XLSBCell(le), re = parse_RichStr(le);
  return [Y, re, "is"];
}
function parse_BrtCellSt(le) {
  var Y = parse_XLSBCell(le), re = parse_XLWideString(le);
  return [Y, re, "str"];
}
function write_BrtCellSt(le, Y, re) {
  var oe = le.v == null ? "" : String(le.v);
  return re == null && (re = new_buf(12 + 4 * le.v.length)), write_XLSBCell(Y, re), write_XLWideString(oe, re), re.length > re.l ? re.slice(0, re.l) : re;
}
function parse_BrtShortSt(le) {
  var Y = parse_XLSBShortCell(le), re = parse_XLWideString(le);
  return [Y, re, "str"];
}
function write_BrtShortSt(le, Y, re) {
  var oe = le.v == null ? "" : String(le.v);
  return re == null && (re = new_buf(8 + 4 * oe.length)), write_XLSBShortCell(Y, re), write_XLWideString(oe, re), re.length > re.l ? re.slice(0, re.l) : re;
}
function parse_BrtFmlaBool(le, Y, re) {
  var oe = le.l + Y, ue = parse_XLSBCell(le);
  ue.r = re["!row"];
  var fe = le.read_shift(1), he = [ue, fe, "b"];
  if (re.cellFormula) {
    le.l += 2;
    var _e = parse_XLSBCellParsedFormula(le, oe - le.l, re);
    he[3] = stringify_formula(_e, null, ue, re.supbooks, re);
  } else le.l = oe;
  return he;
}
function parse_BrtFmlaError(le, Y, re) {
  var oe = le.l + Y, ue = parse_XLSBCell(le);
  ue.r = re["!row"];
  var fe = le.read_shift(1), he = [ue, fe, "e"];
  if (re.cellFormula) {
    le.l += 2;
    var _e = parse_XLSBCellParsedFormula(le, oe - le.l, re);
    he[3] = stringify_formula(_e, null, ue, re.supbooks, re);
  } else le.l = oe;
  return he;
}
function parse_BrtFmlaNum(le, Y, re) {
  var oe = le.l + Y, ue = parse_XLSBCell(le);
  ue.r = re["!row"];
  var fe = parse_Xnum(le), he = [ue, fe, "n"];
  if (re.cellFormula) {
    le.l += 2;
    var _e = parse_XLSBCellParsedFormula(le, oe - le.l, re);
    he[3] = stringify_formula(_e, null, ue, re.supbooks, re);
  } else le.l = oe;
  return he;
}
function parse_BrtFmlaString(le, Y, re) {
  var oe = le.l + Y, ue = parse_XLSBCell(le);
  ue.r = re["!row"];
  var fe = parse_XLWideString(le), he = [ue, fe, "str"];
  if (re.cellFormula) {
    le.l += 2;
    var _e = parse_XLSBCellParsedFormula(le, oe - le.l, re);
    he[3] = stringify_formula(_e, null, ue, re.supbooks, re);
  } else le.l = oe;
  return he;
}
var parse_BrtMergeCell = parse_UncheckedRfX, write_BrtMergeCell = write_UncheckedRfX;
function write_BrtBeginMergeCells(le, Y) {
  return Y == null && (Y = new_buf(4)), Y.write_shift(4, le), Y;
}
function parse_BrtHLink(le, Y) {
  var re = le.l + Y, oe = parse_UncheckedRfX(le), ue = parse_XLNullableWideString(le), fe = parse_XLWideString(le), he = parse_XLWideString(le), _e = parse_XLWideString(le);
  le.l = re;
  var ve = { rfx: oe, relId: ue, loc: fe, display: _e };
  return he && (ve.Tooltip = he), ve;
}
function write_BrtHLink(le, Y) {
  var re = new_buf(50 + 4 * (le[1].Target.length + (le[1].Tooltip || "").length));
  write_UncheckedRfX({ s: decode_cell(le[0]), e: decode_cell(le[0]) }, re), write_RelID("rId" + Y, re);
  var oe = le[1].Target.indexOf("#"), ue = oe == -1 ? "" : le[1].Target.slice(oe + 1);
  return write_XLWideString(ue || "", re), write_XLWideString(le[1].Tooltip || "", re), write_XLWideString("", re), re.slice(0, re.l);
}
function parse_BrtPane() {
}
function parse_BrtArrFmla(le, Y, re) {
  var oe = le.l + Y, ue = parse_RfX(le), fe = le.read_shift(1), he = [ue];
  if (he[2] = fe, re.cellFormula) {
    var _e = parse_XLSBArrayParsedFormula(le, oe - le.l, re);
    he[1] = _e;
  } else le.l = oe;
  return he;
}
function parse_BrtShrFmla(le, Y, re) {
  var oe = le.l + Y, ue = parse_UncheckedRfX(le), fe = [ue];
  if (re.cellFormula) {
    var he = parse_XLSBSharedParsedFormula(le, oe - le.l, re);
    fe[1] = he, le.l = oe;
  } else le.l = oe;
  return fe;
}
function write_BrtColInfo(le, Y, re) {
  re == null && (re = new_buf(18));
  var oe = col_obj_w(le, Y);
  re.write_shift(-4, le), re.write_shift(-4, le), re.write_shift(4, (oe.width || 10) * 256), re.write_shift(
    4,
    0
    /*ixfe*/
  );
  var ue = 0;
  return Y.hidden && (ue |= 1), typeof oe.width == "number" && (ue |= 2), Y.level && (ue |= Y.level << 8), re.write_shift(2, ue), re;
}
var BrtMarginKeys = ["left", "right", "top", "bottom", "header", "footer"];
function parse_BrtMargins(le) {
  var Y = {};
  return BrtMarginKeys.forEach(function(re) {
    Y[re] = parse_Xnum(le);
  }), Y;
}
function write_BrtMargins(le, Y) {
  return Y == null && (Y = new_buf(6 * 8)), default_margins(le), BrtMarginKeys.forEach(function(re) {
    write_Xnum(le[re], Y);
  }), Y;
}
function parse_BrtBeginWsView(le) {
  var Y = le.read_shift(2);
  return le.l += 28, { RTL: Y & 32 };
}
function write_BrtBeginWsView(le, Y, re) {
  re == null && (re = new_buf(30));
  var oe = 924;
  return (((Y || {}).Views || [])[0] || {}).RTL && (oe |= 32), re.write_shift(2, oe), re.write_shift(4, 0), re.write_shift(4, 0), re.write_shift(4, 0), re.write_shift(1, 0), re.write_shift(1, 0), re.write_shift(2, 0), re.write_shift(2, 100), re.write_shift(2, 0), re.write_shift(2, 0), re.write_shift(2, 0), re.write_shift(4, 0), re;
}
function write_BrtCellIgnoreEC(le) {
  var Y = new_buf(24);
  return Y.write_shift(4, 4), Y.write_shift(4, 1), write_UncheckedRfX(le, Y), Y;
}
function write_BrtSheetProtection(le, Y) {
  return Y == null && (Y = new_buf(16 * 4 + 2)), Y.write_shift(2, le.password ? crypto_CreatePasswordVerifier_Method1(le.password) : 0), Y.write_shift(4, 1), [
    ["objects", !1],
    // fObjects
    ["scenarios", !1],
    // fScenarios
    ["formatCells", !0],
    // fFormatCells
    ["formatColumns", !0],
    // fFormatColumns
    ["formatRows", !0],
    // fFormatRows
    ["insertColumns", !0],
    // fInsertColumns
    ["insertRows", !0],
    // fInsertRows
    ["insertHyperlinks", !0],
    // fInsertHyperlinks
    ["deleteColumns", !0],
    // fDeleteColumns
    ["deleteRows", !0],
    // fDeleteRows
    ["selectLockedCells", !1],
    // fSelLockedCells
    ["sort", !0],
    // fSort
    ["autoFilter", !0],
    // fAutoFilter
    ["pivotTables", !0],
    // fPivotTables
    ["selectUnlockedCells", !1]
    // fSelUnlockedCells
  ].forEach(function(re) {
    re[1] ? Y.write_shift(4, le[re[0]] != null && !le[re[0]] ? 1 : 0) : Y.write_shift(4, le[re[0]] != null && le[re[0]] ? 0 : 1);
  }), Y;
}
function parse_BrtDVal() {
}
function parse_BrtDVal14() {
}
function parse_ws_bin(le, Y, re, oe, ue, fe, he) {
  if (!le) return le;
  var _e = Y || {};
  oe || (oe = { "!id": {} });
  var ve = {};
  _e.dense && (ve["!data"] = []);
  var xe, Ee = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, Se = !1, Te = !1, Ce, Ie, Ne, Re, Ae, Pe, Fe, Le, He, Ge = [];
  _e.biff = 12, _e["!row"] = 0;
  var Ve = 0, $e = !1, De = [], Ke = {}, ze = _e.supbooks || /*::(*/
  ue.supbooks || [[]];
  if (ze.sharedf = Ke, ze.arrayf = De, ze.SheetNames = ue.SheetNames || ue.Sheets.map(function(gt) {
    return gt.name;
  }), !_e.supbooks && (_e.supbooks = ze, ue.Names))
    for (var tt = 0; tt < ue.Names.length; ++tt) ze[0][tt + 1] = ue.Names[tt];
  var Xe = [], mt = [], at = !1;
  XLSBRecordEnum[16] = { n: "BrtShortReal", f: parse_BrtShortReal };
  var qe, st = 1462 * +!!((ue || {}).WBProps || {}).date1904;
  if (recordhopper(le, function(Ze, _t, wt) {
    if (!Te)
      switch (wt) {
        case 148:
          xe = Ze;
          break;
        case 0:
          Ce = Ze, _e.sheetRows && _e.sheetRows <= Ce.r && (Te = !0), Le = encode_row(Re = Ce.r), _e["!row"] = Ce.r, (Ze.hidden || Ze.hpt || Ze.level != null) && (Ze.hpt && (Ze.hpx = pt2px(Ze.hpt)), mt[Ze.r] = Ze);
          break;
        case 2:
        /* 'BrtCellRk' */
        case 3:
        /* 'BrtCellError' */
        case 4:
        /* 'BrtCellBool' */
        case 5:
        /* 'BrtCellReal' */
        case 6:
        /* 'BrtCellSt' */
        case 7:
        /* 'BrtCellIsst' */
        case 8:
        /* 'BrtFmlaString' */
        case 9:
        /* 'BrtFmlaNum' */
        case 10:
        /* 'BrtFmlaBool' */
        case 11:
        /* 'BrtFmlaError' */
        case 13:
        /* 'BrtShortRk' */
        case 14:
        /* 'BrtShortError' */
        case 15:
        /* 'BrtShortBool' */
        case 16:
        /* 'BrtShortReal' */
        case 17:
        /* 'BrtShortSt' */
        case 18:
        /* 'BrtShortIsst' */
        case 62:
          switch (Ie = { t: Ze[2] }, Ze[2]) {
            case "n":
              Ie.v = Ze[1];
              break;
            case "s":
              Fe = strs[Ze[1]], Ie.v = Fe.t, Ie.r = Fe.r;
              break;
            case "b":
              Ie.v = !!Ze[1];
              break;
            case "e":
              Ie.v = Ze[1], _e.cellText !== !1 && (Ie.w = BErr[Ie.v]);
              break;
            case "str":
              Ie.t = "s", Ie.v = Ze[1];
              break;
            case "is":
              Ie.t = "s", Ie.v = Ze[1].t;
              break;
          }
          if ((Ne = he.CellXf[Ze[0].iStyleRef]) && safe_format(Ie, Ne.numFmtId, null, _e, fe, he, st > 0), Ae = Ze[0].c == -1 ? Ae + 1 : Ze[0].c, _e.dense ? (ve["!data"][Re] || (ve["!data"][Re] = []), ve["!data"][Re][Ae] = Ie) : ve[encode_col(Ae) + Le] = Ie, _e.cellFormula) {
            for ($e = !1, Ve = 0; Ve < De.length; ++Ve) {
              var yt = De[Ve];
              Ce.r >= yt[0].s.r && Ce.r <= yt[0].e.r && Ae >= yt[0].s.c && Ae <= yt[0].e.c && (Ie.F = encode_range(yt[0]), $e = !0);
            }
            !$e && Ze.length > 3 && (Ie.f = Ze[3]);
          }
          if (Ee.s.r > Ce.r && (Ee.s.r = Ce.r), Ee.s.c > Ae && (Ee.s.c = Ae), Ee.e.r < Ce.r && (Ee.e.r = Ce.r), Ee.e.c < Ae && (Ee.e.c = Ae), _e.cellDates && Ne && Ie.t == "n" && fmt_is_date(table_fmt[Ne.numFmtId])) {
            var St = SSF_parse_date_code(Ie.v + st);
            St && (Ie.t = "d", Ie.v = new Date(Date.UTC(St.y, St.m - 1, St.d, St.H, St.M, St.S, St.u)));
          }
          qe && (qe.type == "XLDAPR" && (Ie.D = !0), qe = void 0);
          break;
        case 1:
        /* 'BrtCellBlank' */
        case 12:
          if (!_e.sheetStubs || Se) break;
          Ie = { t: "z", v: void 0 }, Ae = Ze[0].c == -1 ? Ae + 1 : Ze[0].c, _e.dense ? (ve["!data"][Re] || (ve["!data"][Re] = []), ve["!data"][Re][Ae] = Ie) : ve[encode_col(Ae) + Le] = Ie, Ee.s.r > Ce.r && (Ee.s.r = Ce.r), Ee.s.c > Ae && (Ee.s.c = Ae), Ee.e.r < Ce.r && (Ee.e.r = Ce.r), Ee.e.c < Ae && (Ee.e.c = Ae), qe && (qe.type == "XLDAPR" && (Ie.D = !0), qe = void 0);
          break;
        case 176:
          Ge.push(Ze);
          break;
        case 49:
          qe = ((_e.xlmeta || {}).Cell || [])[Ze - 1];
          break;
        case 494:
          var It = oe["!id"][Ze.relId];
          for (It ? (Ze.Target = It.Target, Ze.loc && (Ze.Target += "#" + Ze.loc), Ze.Rel = It) : Ze.relId == "" && (Ze.Target = "#" + Ze.loc), Re = Ze.rfx.s.r; Re <= Ze.rfx.e.r; ++Re) for (Ae = Ze.rfx.s.c; Ae <= Ze.rfx.e.c; ++Ae)
            _e.dense ? (ve["!data"][Re] || (ve["!data"][Re] = []), ve["!data"][Re][Ae] || (ve["!data"][Re][Ae] = { t: "z", v: void 0 }), ve["!data"][Re][Ae].l = Ze) : (Pe = encode_col(Ae) + encode_row(Re), ve[Pe] || (ve[Pe] = { t: "z", v: void 0 }), ve[Pe].l = Ze);
          break;
        case 426:
          if (!_e.cellFormula) break;
          De.push(Ze), He = _e.dense ? ve["!data"][Re][Ae] : ve[encode_col(Ae) + Le], He.f = stringify_formula(Ze[1], Ee, { r: Ce.r, c: Ae }, ze, _e), He.F = encode_range(Ze[0]);
          break;
        case 427:
          if (!_e.cellFormula) break;
          Ke[encode_cell(Ze[0].s)] = Ze[1], He = _e.dense ? ve["!data"][Re][Ae] : ve[encode_col(Ae) + Le], He.f = stringify_formula(Ze[1], Ee, { r: Ce.r, c: Ae }, ze, _e);
          break;
        /* identical to 'ColInfo' in XLS */
        case 60:
          if (!_e.cellStyles) break;
          for (; Ze.e >= Ze.s; )
            Xe[Ze.e--] = { width: Ze.w / 256, hidden: !!(Ze.flags & 1), level: Ze.level }, at || (at = !0, find_mdw_colw(Ze.w / 256)), process_col(Xe[Ze.e + 1]);
          break;
        case 551:
          Ze && (ve["!legrel"] = Ze);
          break;
        case 161:
          ve["!autofilter"] = { ref: encode_range(Ze) };
          break;
        case 476:
          ve["!margins"] = Ze;
          break;
        case 147:
          ue.Sheets[re] || (ue.Sheets[re] = {}), Ze.name && (ue.Sheets[re].CodeName = Ze.name), (Ze.above || Ze.left) && (ve["!outline"] = { above: Ze.above, left: Ze.left });
          break;
        case 137:
          ue.Views || (ue.Views = [{}]), ue.Views[0] || (ue.Views[0] = {}), Ze.RTL && (ue.Views[0].RTL = !0);
          break;
        case 485:
          break;
        case 64:
        /* 'BrtDVal' */
        case 1053:
          break;
        case 151:
          break;
        case 152:
        /* 'BrtSel' */
        case 175:
        /* 'BrtAFilterDateGroupItem' */
        case 644:
        /* 'BrtActiveX' */
        case 625:
        /* 'BrtBigName' */
        case 562:
        /* 'BrtBkHim' */
        case 396:
        /* 'BrtBrk' */
        case 1112:
        /* 'BrtCFIcon' */
        case 1146:
        /* 'BrtCFRuleExt' */
        case 471:
        /* 'BrtCFVO' */
        case 1050:
        /* 'BrtCFVO14' */
        case 649:
        /* 'BrtCellIgnoreEC' */
        case 1105:
        /* 'BrtCellIgnoreEC14' */
        case 589:
        /* 'BrtCellSmartTagProperty' */
        case 607:
        /* 'BrtCellWatch' */
        case 564:
        /* 'BrtColor' */
        case 1055:
        /* 'BrtColor14' */
        case 168:
        /* 'BrtColorFilter' */
        case 174:
        /* 'BrtCustomFilter' */
        case 1180:
        /* 'BrtCustomFilter14' */
        case 499:
        /* 'BrtDRef' */
        case 507:
        /* 'BrtDXF' */
        case 550:
        /* 'BrtDrawing' */
        case 171:
        /* 'BrtDynamicFilter' */
        case 167:
        /* 'BrtFilter' */
        case 1177:
        /* 'BrtFilter14' */
        case 169:
        /* 'BrtIconFilter' */
        case 1181:
        /* 'BrtIconFilter14' */
        case 552:
        /* 'BrtLegacyDrawingHF' */
        case 661:
        /* 'BrtListPart' */
        case 639:
        /* 'BrtOleObject' */
        case 478:
        /* 'BrtPageSetup' */
        case 537:
        /* 'BrtPhoneticInfo' */
        case 477:
        /* 'BrtPrintOptions' */
        case 536:
        /* 'BrtRangeProtection' */
        case 1103:
        /* 'BrtRangeProtection14' */
        case 680:
        /* 'BrtRangeProtectionIso' */
        case 1104:
        /* 'BrtRangeProtectionIso14' */
        case 1024:
        /* 'BrtRwDescent' */
        case 663:
        /* 'BrtSheetCalcProp' */
        case 535:
        /* 'BrtSheetProtection' */
        case 678:
        /* 'BrtSheetProtectionIso' */
        case 504:
        /* 'BrtSlc' */
        case 1043:
        /* 'BrtSparkline' */
        case 428:
        /* 'BrtTable' */
        case 170:
        /* 'BrtTop10Filter' */
        case 3072:
        /* 'BrtUid' */
        case 50:
        /* 'BrtValueMeta' */
        case 2070:
        /* 'BrtWebExtension' */
        case 1045:
          break;
        case 35:
          Se = !0;
          break;
        case 36:
          Se = !1;
          break;
        case 37:
          Se = !0;
          break;
        case 38:
          Se = !1;
          break;
        default:
          if (!_t.T) {
            if (!Se || _e.WTF) throw new Error("Unexpected record 0x" + wt.toString(16));
          }
      }
  }, _e), delete _e.supbooks, delete _e["!row"], !ve["!ref"] && (Ee.s.r < 2e6 || xe && (xe.e.r > 0 || xe.e.c > 0 || xe.s.r > 0 || xe.s.c > 0)) && (ve["!ref"] = encode_range(xe || Ee)), _e.sheetRows && ve["!ref"]) {
    var xt = safe_decode_range(ve["!ref"]);
    _e.sheetRows <= +xt.e.r && (xt.e.r = _e.sheetRows - 1, xt.e.r > Ee.e.r && (xt.e.r = Ee.e.r), xt.e.r < xt.s.r && (xt.s.r = xt.e.r), xt.e.c > Ee.e.c && (xt.e.c = Ee.e.c), xt.e.c < xt.s.c && (xt.s.c = xt.e.c), ve["!fullref"] = ve["!ref"], ve["!ref"] = encode_range(xt));
  }
  return Ge.length > 0 && (ve["!merges"] = Ge), Xe.length > 0 && (ve["!cols"] = Xe), mt.length > 0 && (ve["!rows"] = mt), oe["!id"][ve["!legrel"]] && (ve["!legdrawel"] = oe["!id"][ve["!legrel"]]), ve;
}
function write_ws_bin_cell(le, Y, re, oe, ue, fe, he, _e) {
  var ve = { r: re, c: oe };
  if (Y.c && fe["!comments"].push([encode_cell(ve), Y.c]), Y.v === void 0) return !1;
  var xe = "";
  switch (Y.t) {
    case "b":
      xe = Y.v ? "1" : "0";
      break;
    case "d":
      Y = dup(Y), Y.z = Y.z || table_fmt[14], Y.v = datenum(parseDate(Y.v, _e), _e), Y.t = "n";
      break;
    /* falls through */
    case "n":
    case "e":
      xe = "" + Y.v;
      break;
    default:
      xe = Y.v;
      break;
  }
  switch (ve.s = get_cell_style(ue.cellXfs, Y, ue), Y.l && fe["!links"].push([encode_cell(ve), Y.l]), Y.t) {
    case "s":
    case "str":
      return ue.bookSST ? (xe = get_sst_id(ue.Strings, Y.v == null ? "" : String(Y.v), ue.revStrings), ve.t = "s", ve.v = xe, he ? write_record(le, 18, write_BrtShortIsst(Y, ve)) : write_record(le, 7, write_BrtCellIsst(Y, ve))) : (ve.t = "str", he ? write_record(le, 17, write_BrtShortSt(Y, ve)) : write_record(le, 6, write_BrtCellSt(Y, ve))), !0;
    case "n":
      return Y.v == (Y.v | 0) && Y.v > -1e3 && Y.v < 1e3 ? he ? write_record(le, 13, write_BrtShortRk(Y, ve)) : write_record(le, 2, write_BrtCellRk(Y, ve)) : isFinite(Y.v) ? he ? write_record(le, 16, write_BrtShortReal(Y, ve)) : write_record(le, 5, write_BrtCellReal(Y, ve)) : (ve.t = "e", isNaN(Y.v) ? he ? write_record(le, 14, write_BrtShortError({ v: 36 }, ve)) : write_record(le, 3, write_BrtCellError({ v: 36 }, ve)) : he ? write_record(le, 14, write_BrtShortError({ v: 7 }, ve)) : write_record(le, 3, write_BrtCellError({ v: 7 }, ve))), !0;
    case "b":
      return ve.t = "b", he ? write_record(le, 15, write_BrtShortBool(Y, ve)) : write_record(le, 4, write_BrtCellBool(Y, ve)), !0;
    case "e":
      return ve.t = "e", he ? write_record(le, 14, write_BrtShortError(Y, ve)) : write_record(le, 3, write_BrtCellError(Y, ve)), !0;
  }
  return he ? write_record(le, 12, write_BrtShortBlank(Y, ve)) : write_record(le, 1, write_BrtCellBlank(Y, ve)), !0;
}
function write_CELLTABLE(le, Y, re, oe, ue) {
  var fe = safe_decode_range(Y["!ref"] || "A1"), he = "", _e = [], ve = (((ue || {}).Workbook || {}).WBProps || {}).date1904;
  write_record(
    le,
    145
    /* BrtBeginSheetData */
  );
  var xe = Y["!data"] != null, Ee = xe ? Y["!data"][fe.s.r] : [], Se = fe.e.r;
  Y["!rows"] && (Se = Math.max(fe.e.r, Y["!rows"].length - 1));
  for (var Te = fe.s.r; Te <= Se; ++Te)
    if (he = encode_row(Te), xe && (Ee = Y["!data"][Te]), write_row_header(le, Y, fe, Te), !(xe && !Ee)) {
      var Ce = !1;
      if (Te <= fe.e.r) for (var Ie = fe.s.c; Ie <= fe.e.c; ++Ie) {
        Te === fe.s.r && (_e[Ie] = encode_col(Ie));
        var Ne = xe ? Ee[Ie] : Y[_e[Ie] + he];
        if (!Ne) {
          Ce = !1;
          continue;
        }
        Ce = write_ws_bin_cell(le, Ne, Te, Ie, oe, Y, Ce, ve);
      }
    }
  write_record(
    le,
    146
    /* BrtEndSheetData */
  );
}
function write_MERGECELLS(le, Y) {
  !Y || !Y["!merges"] || (write_record(le, 177, write_BrtBeginMergeCells(Y["!merges"].length)), Y["!merges"].forEach(function(re) {
    write_record(le, 176, write_BrtMergeCell(re));
  }), write_record(
    le,
    178
    /* BrtEndMergeCells */
  ));
}
function write_COLINFOS(le, Y) {
  !Y || !Y["!cols"] || (write_record(
    le,
    390
    /* BrtBeginColInfos */
  ), Y["!cols"].forEach(function(re, oe) {
    re && write_record(le, 60, write_BrtColInfo(oe, re));
  }), write_record(
    le,
    391
    /* BrtEndColInfos */
  ));
}
function write_IGNOREECS(le, Y) {
  !Y || !Y["!ref"] || (write_record(
    le,
    648
    /* BrtBeginCellIgnoreECs */
  ), write_record(le, 649, write_BrtCellIgnoreEC(safe_decode_range(Y["!ref"]))), write_record(
    le,
    650
    /* BrtEndCellIgnoreECs */
  ));
}
function write_HLINKS(le, Y, re) {
  Y["!links"].forEach(function(oe) {
    if (oe[1].Target) {
      var ue = add_rels(re, -1, oe[1].Target.replace(/#[\s\S]*$/, ""), RELS.HLINK);
      write_record(le, 494, write_BrtHLink(oe, ue));
    }
  }), delete Y["!links"];
}
function write_LEGACYDRAWING(le, Y, re, oe) {
  if (Y["!comments"].length > 0) {
    var ue = add_rels(oe, -1, "../drawings/vmlDrawing" + (re + 1) + ".vml", RELS.VML);
    write_record(le, 551, write_RelID("rId" + ue)), Y["!legacy"] = ue;
  }
}
function write_AUTOFILTER(le, Y, re, oe) {
  if (Y["!autofilter"]) {
    var ue = Y["!autofilter"], fe = typeof ue.ref == "string" ? ue.ref : encode_range(ue.ref);
    re.Workbook || (re.Workbook = { Sheets: [] }), re.Workbook.Names || (re.Workbook.Names = []);
    var he = re.Workbook.Names, _e = decode_range(fe);
    _e.s.r == _e.e.r && (_e.e.r = decode_range(Y["!ref"]).e.r, fe = encode_range(_e));
    for (var ve = 0; ve < he.length; ++ve) {
      var xe = he[ve];
      if (xe.Name == "_xlnm._FilterDatabase" && xe.Sheet == oe) {
        xe.Ref = formula_quote_sheet_name(re.SheetNames[oe]) + "!" + fix_range(fe);
        break;
      }
    }
    ve == he.length && he.push({ Name: "_xlnm._FilterDatabase", Sheet: oe, Ref: formula_quote_sheet_name(re.SheetNames[oe]) + "!" + fix_range(fe) }), write_record(le, 161, write_UncheckedRfX(safe_decode_range(fe))), write_record(
      le,
      162
      /* BrtEndAFilter */
    );
  }
}
function write_WSVIEWS2(le, Y, re) {
  write_record(
    le,
    133
    /* BrtBeginWsViews */
  ), write_record(le, 137, write_BrtBeginWsView(Y, re)), write_record(
    le,
    138
    /* BrtEndWsView */
  ), write_record(
    le,
    134
    /* BrtEndWsViews */
  );
}
function write_SHEETPROTECT(le, Y) {
  Y["!protect"] && write_record(le, 535, write_BrtSheetProtection(Y["!protect"]));
}
function write_ws_bin(le, Y, re, oe) {
  var ue = buf_array(), fe = re.SheetNames[le], he = re.Sheets[fe] || {}, _e = fe;
  try {
    re && re.Workbook && (_e = re.Workbook.Sheets[le].CodeName || _e);
  } catch {
  }
  var ve = safe_decode_range(he["!ref"] || "A1");
  if (ve.e.c > 16383 || ve.e.r > 1048575) {
    if (Y.WTF) throw new Error("Range " + (he["!ref"] || "A1") + " exceeds format limit A1:XFD1048576");
    ve.e.c = Math.min(ve.e.c, 16383), ve.e.r = Math.min(ve.e.c, 1048575);
  }
  return he["!links"] = [], he["!comments"] = [], write_record(
    ue,
    129
    /* BrtBeginSheet */
  ), (re.vbaraw || he["!outline"]) && write_record(ue, 147, write_BrtWsProp(_e, he["!outline"])), write_record(ue, 148, write_BrtWsDim(ve)), write_WSVIEWS2(ue, he, re.Workbook), write_COLINFOS(ue, he), write_CELLTABLE(ue, he, le, Y, re), write_SHEETPROTECT(ue, he), write_AUTOFILTER(ue, he, re, le), write_MERGECELLS(ue, he), write_HLINKS(ue, he, oe), he["!margins"] && write_record(ue, 476, write_BrtMargins(he["!margins"])), (!Y || Y.ignoreEC || Y.ignoreEC == null) && write_IGNOREECS(ue, he), write_LEGACYDRAWING(ue, he, le, oe), write_record(
    ue,
    130
    /* BrtEndSheet */
  ), ue.end();
}
function parse_Cache(le) {
  var Y = [], re = le.match(/^<c:numCache>/), oe;
  (le.match(/<c:pt idx="(\d*)"[^<>\/]*><c:v>([^<])<\/c:v><\/c:pt>/mg) || []).forEach(function(fe) {
    var he = fe.match(/<c:pt idx="(\d*)"[^<>\/]*><c:v>([^<]*)<\/c:v><\/c:pt>/);
    he && (Y[+he[1]] = re ? +he[2] : he[2]);
  });
  var ue = unescapexml((str_match_xml(le, "c:formatCode") || ["", "General"])[1]);
  return (str_match_ng(le, "<c:f>", "</c:f>") || []).forEach(function(fe) {
    oe = fe.replace(/<[^<>]*>/g, "");
  }), [Y, ue, oe];
}
function parse_chart(le, Y, re, oe, ue, fe) {
  var he = fe || { "!type": "chart" };
  if (!le) return fe;
  var _e = 0, ve = 0, xe = "A", Ee = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  return (str_match_ng(le, "<c:numCache>", "</c:numCache>") || []).forEach(function(Se) {
    var Te = parse_Cache(Se);
    Ee.s.r = Ee.s.c = 0, Ee.e.c = _e, xe = encode_col(_e), Te[0].forEach(function(Ce, Ie) {
      he["!data"] ? (he["!data"][Ie] || (he["!data"][Ie] = []), he["!data"][Ie][_e] = { t: "n", v: Ce, z: Te[1] }) : he[xe + encode_row(Ie)] = { t: "n", v: Ce, z: Te[1] }, ve = Ie;
    }), Ee.e.r < ve && (Ee.e.r = ve), ++_e;
  }), _e > 0 && (he["!ref"] = encode_range(Ee)), he;
}
function parse_cs_xml(le, Y, re, oe, ue) {
  if (!le) return le;
  oe || (oe = { "!id": {} });
  var fe = { "!type": "chart", "!drawel": null, "!rel": "" }, he, _e = le.match(sheetprregex);
  return _e && parse_ws_xml_sheetpr(_e[0], fe, ue, re), (he = le.match(/drawing r:id="(.*?)"/)) && (fe["!rel"] = he[1]), oe["!id"][fe["!rel"]] && (fe["!drawel"] = oe["!id"][fe["!rel"]]), fe;
}
function parse_BrtCsProp(le, Y) {
  le.l += 10;
  var re = parse_XLWideString(le);
  return { name: re };
}
function parse_cs_bin(le, Y, re, oe, ue) {
  if (!le) return le;
  oe || (oe = { "!id": {} });
  var fe = { "!type": "chart", "!drawel": null, "!rel": "" }, he = !1;
  return recordhopper(le, function(ve, xe, Ee) {
    switch (Ee) {
      case 550:
        fe["!rel"] = ve;
        break;
      case 651:
        ue.Sheets[re] || (ue.Sheets[re] = {}), ve.name && (ue.Sheets[re].CodeName = ve.name);
        break;
      case 562:
      /* 'BrtBkHim' */
      case 652:
      /* 'BrtCsPageSetup' */
      case 669:
      /* 'BrtCsProtection' */
      case 679:
      /* 'BrtCsProtectionIso' */
      case 551:
      /* 'BrtLegacyDrawing' */
      case 552:
      /* 'BrtLegacyDrawingHF' */
      case 476:
      /* 'BrtMargins' */
      case 3072:
        break;
      case 35:
        he = !0;
        break;
      case 36:
        he = !1;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (!(xe.T > 0)) {
          if (!(xe.T < 0)) {
            if (!he || Y.WTF) throw new Error("Unexpected record 0x" + Ee.toString(16));
          }
        }
    }
  }, Y), oe["!id"][fe["!rel"]] && (fe["!drawel"] = oe["!id"][fe["!rel"]]), fe;
}
var WBPropsDef = [
  ["allowRefreshQuery", !1, "bool"],
  ["autoCompressPictures", !0, "bool"],
  ["backupFile", !1, "bool"],
  ["checkCompatibility", !1, "bool"],
  ["CodeName", ""],
  ["date1904", !1, "bool"],
  ["defaultThemeVersion", 0, "int"],
  ["filterPrivacy", !1, "bool"],
  ["hidePivotFieldList", !1, "bool"],
  ["promptedSolutions", !1, "bool"],
  ["publishItems", !1, "bool"],
  ["refreshAllConnections", !1, "bool"],
  ["saveExternalLinkValues", !0, "bool"],
  ["showBorderUnselectedTables", !0, "bool"],
  ["showInkAnnotation", !0, "bool"],
  ["showObjects", "all"],
  ["showPivotChartFilter", !1, "bool"],
  ["updateLinks", "userSet"]
], WBViewDef = [
  ["activeTab", 0, "int"],
  ["autoFilterDateGrouping", !0, "bool"],
  ["firstSheet", 0, "int"],
  ["minimized", !1, "bool"],
  ["showHorizontalScroll", !0, "bool"],
  ["showSheetTabs", !0, "bool"],
  ["showVerticalScroll", !0, "bool"],
  ["tabRatio", 600, "int"],
  ["visibility", "visible"]
  //window{Height,Width}, {x,y}Window
], SheetDef = [
  //['state', 'visible']
], CalcPrDef = [
  ["calcCompleted", "true"],
  ["calcMode", "auto"],
  ["calcOnSave", "true"],
  ["concurrentCalc", "true"],
  ["fullCalcOnLoad", "false"],
  ["fullPrecision", "true"],
  ["iterate", "false"],
  ["iterateCount", "100"],
  ["iterateDelta", "0.001"],
  ["refMode", "A1"]
];
function push_defaults_array(le, Y) {
  for (var re = 0; re != le.length; ++re)
    for (var oe = le[re], ue = 0; ue != Y.length; ++ue) {
      var fe = Y[ue];
      if (oe[fe[0]] == null) oe[fe[0]] = fe[1];
      else switch (fe[2]) {
        case "bool":
          typeof oe[fe[0]] == "string" && (oe[fe[0]] = parsexmlbool(oe[fe[0]]));
          break;
        case "int":
          typeof oe[fe[0]] == "string" && (oe[fe[0]] = parseInt(oe[fe[0]], 10));
          break;
      }
    }
}
function push_defaults(le, Y) {
  for (var re = 0; re != Y.length; ++re) {
    var oe = Y[re];
    if (le[oe[0]] == null) le[oe[0]] = oe[1];
    else switch (oe[2]) {
      case "bool":
        typeof le[oe[0]] == "string" && (le[oe[0]] = parsexmlbool(le[oe[0]]));
        break;
      case "int":
        typeof le[oe[0]] == "string" && (le[oe[0]] = parseInt(le[oe[0]], 10));
        break;
    }
  }
}
function parse_wb_defaults(le) {
  push_defaults(le.WBProps, WBPropsDef), push_defaults(le.CalcPr, CalcPrDef), push_defaults_array(le.WBView, WBViewDef), push_defaults_array(le.Sheets, SheetDef), _ssfopts.date1904 = parsexmlbool(le.WBProps.date1904);
}
function safe1904(le) {
  return !le.Workbook || !le.Workbook.WBProps ? "false" : parsexmlbool(le.Workbook.WBProps.date1904) ? "true" : "false";
}
var badchars = /* @__PURE__ */ ":][*?/\\".split("");
function check_ws_name(le, Y) {
  try {
    if (le == "") throw new Error("Sheet name cannot be blank");
    if (le.length > 31) throw new Error("Sheet name cannot exceed 31 chars");
    if (le.charCodeAt(0) == 39 || le.charCodeAt(le.length - 1) == 39) throw new Error("Sheet name cannot start or end with apostrophe (')");
    if (le.toLowerCase() == "history") throw new Error("Sheet name cannot be 'History'");
    badchars.forEach(function(re) {
      if (le.indexOf(re) != -1)
        throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
    });
  } catch (re) {
    throw re;
  }
  return !0;
}
function check_wb_names(le, Y, re) {
  le.forEach(function(oe, ue) {
    check_ws_name(oe);
    for (var fe = 0; fe < ue; ++fe) if (oe == le[fe]) throw new Error("Duplicate Sheet Name: " + oe);
    if (re) {
      var he = Y && Y[ue] && Y[ue].CodeName || oe;
      if (he.charCodeAt(0) == 95 && he.length > 22) throw new Error("Bad Code Name: Worksheet" + he);
    }
  });
}
function check_wb(le) {
  if (!le || !le.SheetNames || !le.Sheets) throw new Error("Invalid Workbook");
  if (!le.SheetNames.length) throw new Error("Workbook is empty");
  var Y = le.Workbook && le.Workbook.Sheets || [];
  check_wb_names(le.SheetNames, Y, !!le.vbaraw);
  for (var re = 0; re < le.SheetNames.length; ++re) check_ws(le.Sheets[le.SheetNames[re]], le.SheetNames[re], re);
  le.SheetNames.forEach(function(oe, ue) {
    var fe = le.Sheets[oe];
    if (!(!fe || !fe["!autofilter"])) {
      var he;
      le.Workbook || (le.Workbook = {}), le.Workbook.Names || (le.Workbook.Names = []), le.Workbook.Names.forEach(function(ve) {
        ve.Name == "_xlnm._FilterDatabase" && ve.Sheet == ue && (he = ve);
      });
      var _e = formula_quote_sheet_name(oe) + "!" + fix_range(fe["!autofilter"].ref);
      he ? he.Ref = _e : le.Workbook.Names.push({ Name: "_xlnm._FilterDatabase", Sheet: ue, Ref: _e });
    }
  });
}
var wbnsregex = /<\w+:workbook/;
function parse_wb_xml(le, Y) {
  if (!le) throw new Error("Could not find file");
  var re = (
    /*::(*/
    { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, Names: [], xmlns: "" }
  ), oe = !1, ue = "xmlns", fe = {}, he = 0;
  if (le.replace(tagregex, function(ve, xe) {
    var Ee = parsexmltag(ve);
    switch (strip_ns(Ee[0])) {
      case "<?xml":
        break;
      /* 18.2.27 workbook CT_Workbook 1 */
      case "<workbook":
        ve.match(wbnsregex) && (ue = "xmlns" + ve.match(/<(\w+):/)[1]), re.xmlns = Ee[ue];
        break;
      case "</workbook>":
        break;
      /* 18.2.13 fileVersion CT_FileVersion ? */
      case "<fileVersion":
        delete Ee[0], re.AppVersion = Ee;
        break;
      case "<fileVersion/>":
      case "</fileVersion>":
        break;
      /* 18.2.12 fileSharing CT_FileSharing ? */
      case "<fileSharing":
        break;
      case "<fileSharing/>":
        break;
      /* 18.2.28 workbookPr CT_WorkbookPr ? */
      case "<workbookPr":
      case "<workbookPr/>":
        WBPropsDef.forEach(function(Se) {
          if (Ee[Se[0]] != null)
            switch (Se[2]) {
              case "bool":
                re.WBProps[Se[0]] = parsexmlbool(Ee[Se[0]]);
                break;
              case "int":
                re.WBProps[Se[0]] = parseInt(Ee[Se[0]], 10);
                break;
              default:
                re.WBProps[Se[0]] = Ee[Se[0]];
            }
        }), Ee.codeName && (re.WBProps.CodeName = utf8read(Ee.codeName));
        break;
      case "</workbookPr>":
        break;
      /* 18.2.29 workbookProtection CT_WorkbookProtection ? */
      case "<workbookProtection":
        break;
      case "<workbookProtection/>":
        break;
      /* 18.2.1  bookViews CT_BookViews ? */
      case "<bookViews":
      case "<bookViews>":
      case "</bookViews>":
        break;
      /* 18.2.30   workbookView CT_BookView + */
      case "<workbookView":
      case "<workbookView/>":
        delete Ee[0], re.WBView.push(Ee);
        break;
      case "</workbookView>":
        break;
      /* 18.2.20 sheets CT_Sheets 1 */
      case "<sheets":
      case "<sheets>":
      case "</sheets>":
        break;
      // aggregate sheet
      /* 18.2.19   sheet CT_Sheet + */
      case "<sheet":
        switch (Ee.state) {
          case "hidden":
            Ee.Hidden = 1;
            break;
          case "veryHidden":
            Ee.Hidden = 2;
            break;
          default:
            Ee.Hidden = 0;
        }
        delete Ee.state, Ee.name = unescapexml(utf8read(Ee.name)), delete Ee[0], re.Sheets.push(Ee);
        break;
      case "</sheet>":
        break;
      /* 18.2.15 functionGroups CT_FunctionGroups ? */
      case "<functionGroups":
      case "<functionGroups/>":
        break;
      /* 18.2.14   functionGroup CT_FunctionGroup + */
      case "<functionGroup":
        break;
      /* 18.2.9  externalReferences CT_ExternalReferences ? */
      case "<externalReferences":
      case "</externalReferences>":
      case "<externalReferences>":
        break;
      /* 18.2.8    externalReference CT_ExternalReference + */
      case "<externalReference":
        break;
      /* 18.2.6  definedNames CT_DefinedNames ? */
      case "<definedNames/>":
        break;
      case "<definedNames>":
      case "<definedNames":
        oe = !0;
        break;
      case "</definedNames>":
        oe = !1;
        break;
      /* 18.2.5    definedName CT_DefinedName + */
      case "<definedName":
        fe = {}, fe.Name = utf8read(Ee.name), Ee.comment && (fe.Comment = Ee.comment), Ee.localSheetId && (fe.Sheet = +Ee.localSheetId), parsexmlbool(Ee.hidden || "0") && (fe.Hidden = !0), he = xe + ve.length;
        break;
      case "</definedName>":
        fe.Ref = unescapexml(utf8read(le.slice(he, xe))), re.Names.push(fe);
        break;
      case "<definedName/>":
        break;
      /* 18.2.2  calcPr CT_CalcPr ? */
      case "<calcPr":
        delete Ee[0], re.CalcPr = Ee;
        break;
      case "<calcPr/>":
        delete Ee[0], re.CalcPr = Ee;
        break;
      case "</calcPr>":
        break;
      /* 18.2.16 oleSize CT_OleSize ? (ref required) */
      case "<oleSize":
        break;
      /* 18.2.4  customWorkbookViews CT_CustomWorkbookViews ? */
      case "<customWorkbookViews>":
      case "</customWorkbookViews>":
      case "<customWorkbookViews":
        break;
      /* 18.2.3  customWorkbookView CT_CustomWorkbookView + */
      case "<customWorkbookView":
      case "</customWorkbookView>":
        break;
      /* 18.2.18 pivotCaches CT_PivotCaches ? */
      case "<pivotCaches>":
      case "</pivotCaches>":
      case "<pivotCaches":
        break;
      /* 18.2.17 pivotCache CT_PivotCache ? */
      case "<pivotCache":
        break;
      /* 18.2.21 smartTagPr CT_SmartTagPr ? */
      case "<smartTagPr":
      case "<smartTagPr/>":
        break;
      /* 18.2.23 smartTagTypes CT_SmartTagTypes ? */
      case "<smartTagTypes":
      case "<smartTagTypes>":
      case "</smartTagTypes>":
        break;
      /* 18.2.22 smartTagType CT_SmartTagType ? */
      case "<smartTagType":
        break;
      /* 18.2.24 webPublishing CT_WebPublishing ? */
      case "<webPublishing":
      case "<webPublishing/>":
        break;
      /* 18.2.11 fileRecoveryPr CT_FileRecoveryPr ? */
      case "<fileRecoveryPr":
      case "<fileRecoveryPr/>":
        break;
      /* 18.2.26 webPublishObjects CT_WebPublishObjects ? */
      case "<webPublishObjects>":
      case "<webPublishObjects":
      case "</webPublishObjects>":
        break;
      /* 18.2.25 webPublishObject CT_WebPublishObject ? */
      case "<webPublishObject":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      /* 18.2.7  ext CT_Extension + */
      case "<ext":
        oe = !0;
        break;
      //TODO: check with versions of excel
      case "</ext>":
        oe = !1;
        break;
      /* Others */
      case "<ArchID":
        break;
      case "<AlternateContent":
      case "<AlternateContent>":
        oe = !0;
        break;
      case "</AlternateContent>":
        oe = !1;
        break;
      /* TODO */
      case "<revisionPtr":
        break;
      default:
        if (!oe && Y.WTF) throw new Error("unrecognized " + Ee[0] + " in workbook");
    }
    return ve;
  }), XMLNS_main.indexOf(re.xmlns) === -1) throw new Error("Unknown Namespace: " + re.xmlns);
  return parse_wb_defaults(re), re;
}
function write_wb_xml(le) {
  var Y = [XML_HEADER];
  Y[Y.length] = writextag("workbook", null, {
    xmlns: XMLNS_main[0],
    //'xmlns:mx': XMLNS.mx,
    //'xmlns:s': XMLNS_main[0],
    "xmlns:r": XMLNS.r
  });
  var re = le.Workbook && (le.Workbook.Names || []).length > 0, oe = { codeName: "ThisWorkbook" };
  le.Workbook && le.Workbook.WBProps && (WBPropsDef.forEach(function(_e) {
    le.Workbook.WBProps[_e[0]] != null && le.Workbook.WBProps[_e[0]] != _e[1] && (oe[_e[0]] = le.Workbook.WBProps[_e[0]]);
  }), le.Workbook.WBProps.CodeName && (oe.codeName = le.Workbook.WBProps.CodeName, delete oe.CodeName)), Y[Y.length] = writextag("workbookPr", null, oe);
  var ue = le.Workbook && le.Workbook.Sheets || [], fe = 0;
  if (ue && ue[0] && ue[0].Hidden) {
    for (Y[Y.length] = "<bookViews>", fe = 0; fe != le.SheetNames.length && !(!ue[fe] || !ue[fe].Hidden); ++fe)
      ;
    fe == le.SheetNames.length && (fe = 0), Y[Y.length] = '<workbookView firstSheet="' + fe + '" activeTab="' + fe + '"/>', Y[Y.length] = "</bookViews>";
  }
  for (Y[Y.length] = "<sheets>", fe = 0; fe != le.SheetNames.length; ++fe) {
    var he = { name: escapexml(le.SheetNames[fe].slice(0, 31)) };
    if (he.sheetId = "" + (fe + 1), he["r:id"] = "rId" + (fe + 1), ue[fe]) switch (ue[fe].Hidden) {
      case 1:
        he.state = "hidden";
        break;
      case 2:
        he.state = "veryHidden";
        break;
    }
    Y[Y.length] = writextag("sheet", null, he);
  }
  return Y[Y.length] = "</sheets>", re && (Y[Y.length] = "<definedNames>", le.Workbook && le.Workbook.Names && le.Workbook.Names.forEach(function(_e) {
    var ve = { name: _e.Name };
    _e.Comment && (ve.comment = _e.Comment), _e.Sheet != null && (ve.localSheetId = "" + _e.Sheet), _e.Hidden && (ve.hidden = "1"), _e.Ref && (Y[Y.length] = writextag("definedName", escapexml(_e.Ref), ve));
  }), Y[Y.length] = "</definedNames>"), Y.length > 2 && (Y[Y.length] = "</workbook>", Y[1] = Y[1].replace("/>", ">")), Y.join("");
}
function parse_BrtBundleSh(le, Y) {
  var re = {};
  return re.Hidden = le.read_shift(4), re.iTabID = le.read_shift(4), re.strRelID = parse_RelID(le), re.name = parse_XLWideString(le), re;
}
function write_BrtBundleSh(le, Y) {
  return Y || (Y = new_buf(127)), Y.write_shift(4, le.Hidden), Y.write_shift(4, le.iTabID), write_RelID(le.strRelID, Y), write_XLWideString(le.name.slice(0, 31), Y), Y.length > Y.l ? Y.slice(0, Y.l) : Y;
}
function parse_BrtWbProp(le, Y) {
  var re = {}, oe = le.read_shift(4);
  re.defaultThemeVersion = le.read_shift(4);
  var ue = Y > 8 ? parse_XLWideString(le) : "";
  return ue.length > 0 && (re.CodeName = ue), re.autoCompressPictures = !!(oe & 65536), re.backupFile = !!(oe & 64), re.checkCompatibility = !!(oe & 4096), re.date1904 = !!(oe & 1), re.filterPrivacy = !!(oe & 8), re.hidePivotFieldList = !!(oe & 1024), re.promptedSolutions = !!(oe & 16), re.publishItems = !!(oe & 2048), re.refreshAllConnections = !!(oe & 262144), re.saveExternalLinkValues = !!(oe & 128), re.showBorderUnselectedTables = !!(oe & 4), re.showInkAnnotation = !!(oe & 32), re.showObjects = ["all", "placeholders", "none"][oe >> 13 & 3], re.showPivotChartFilter = !!(oe & 32768), re.updateLinks = ["userSet", "never", "always"][oe >> 8 & 3], re;
}
function write_BrtWbProp(le, Y) {
  Y || (Y = new_buf(72));
  var re = 0;
  return le && (le.date1904 && (re |= 1), le.filterPrivacy && (re |= 8)), Y.write_shift(4, re), Y.write_shift(4, 0), write_XLSBCodeName(le && le.CodeName || "ThisWorkbook", Y), Y.slice(0, Y.l);
}
function parse_BrtFRTArchID$(le, Y) {
  var re = {};
  return le.read_shift(4), re.ArchID = le.read_shift(4), le.l += Y - 8, re;
}
function parse_BrtName(le, Y, re) {
  var oe = le.l + Y, ue = le.read_shift(4);
  le.l += 1;
  var fe = le.read_shift(4), he = parse_XLNameWideString(le), _e, ve = "";
  try {
    _e = parse_XLSBNameParsedFormula(le, 0, re);
    try {
      ve = parse_XLNullableWideString(le);
    } catch {
    }
  } catch {
    console.error("Could not parse defined name " + he);
  }
  ue & 32 && (he = "_xlnm." + he), le.l = oe;
  var xe = { Name: he, Ptg: _e, Flags: ue };
  return fe < 268435455 && (xe.Sheet = fe), ve && (xe.Comment = ve), xe;
}
function write_BrtName(le, Y) {
  var re = new_buf(9), oe = 0, ue = le.Name;
  XLSLblBuiltIn.indexOf(ue) > -1 && (oe |= 32, ue = ue.slice(6)), re.write_shift(4, oe), re.write_shift(1, 0), re.write_shift(4, le.Sheet == null ? 4294967295 : le.Sheet);
  var fe = [
    re,
    write_XLWideString(ue),
    write_XLSBNameParsedFormula(le.Ref, Y)
  ];
  if (le.Comment) fe.push(write_XLNullableWideString(le.Comment));
  else {
    var he = new_buf(4);
    he.write_shift(4, 4294967295), fe.push(he);
  }
  return bconcat(fe);
}
function parse_wb_bin(le, Y) {
  var re = { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, xmlns: "" }, oe = [], ue = !1;
  Y || (Y = {}), Y.biff = 12;
  var fe = [], he = [[]];
  return he.SheetNames = [], he.XTI = [], XLSBRecordEnum[16] = { n: "BrtFRTArchID$", f: parse_BrtFRTArchID$ }, recordhopper(le, function(ve, xe, Ee) {
    switch (Ee) {
      case 156:
        he.SheetNames.push(ve.name), re.Sheets.push(ve);
        break;
      case 153:
        re.WBProps = ve;
        break;
      case 39:
        ve.Sheet != null && (Y.SID = ve.Sheet), ve.Ref = ve.Ptg ? stringify_formula(ve.Ptg, null, null, he, Y) : "#REF!", delete Y.SID, delete ve.Ptg, fe.push(ve);
        break;
      case 1036:
        break;
      case 357:
      /* 'BrtSupSelf' */
      case 358:
      /* 'BrtSupSame' */
      case 355:
      /* 'BrtSupBookSrc' */
      case 667:
        he[0].length ? he.push([Ee, ve]) : he[0] = [Ee, ve], he[he.length - 1].XTI = [];
        break;
      case 362:
        he.length === 0 && (he[0] = [], he[0].XTI = []), he[he.length - 1].XTI = he[he.length - 1].XTI.concat(ve), he.XTI = he.XTI.concat(ve);
        break;
      case 361:
        break;
      case 2071:
      /* 'BrtAbsPath15' */
      case 158:
      /* 'BrtBookView' */
      case 143:
      /* 'BrtBeginBundleShs' */
      case 664:
      /* 'BrtBeginFnGroup' */
      case 353:
        break;
      /* case 'BrtModelTimeGroupingCalcCol' */
      case 3072:
      /* 'BrtUid' */
      case 3073:
      /* 'BrtRevisionPtr' */
      case 534:
      /* 'BrtBookProtection' */
      case 677:
      /* 'BrtBookProtectionIso' */
      case 157:
      /* 'BrtCalcProp' */
      case 610:
      /* 'BrtCrashRecErr' */
      case 2050:
      /* 'BrtDecoupledPivotCacheID' */
      case 155:
      /* 'BrtFileRecover' */
      case 548:
      /* 'BrtFileSharing' */
      case 676:
      /* 'BrtFileSharingIso' */
      case 128:
      /* 'BrtFileVersion' */
      case 665:
      /* 'BrtFnGroup' */
      case 2128:
      /* 'BrtModelRelationship' */
      case 2125:
      /* 'BrtModelTable' */
      case 549:
      /* 'BrtOleSize' */
      case 2053:
      /* 'BrtPivotTableRef' */
      case 596:
      /* 'BrtSmartTagType' */
      case 2076:
      /* 'BrtTableSlicerCacheID' */
      case 2075:
      /* 'BrtTableSlicerCacheIDs' */
      case 2082:
      /* 'BrtTimelineCachePivotCacheID' */
      case 397:
      /* 'BrtUserBookView' */
      case 154:
      /* 'BrtWbFactoid' */
      case 1117:
      /* 'BrtWbProp14' */
      case 553:
      /* 'BrtWebOpt' */
      case 2091:
        break;
      case 35:
        oe.push(Ee), ue = !0;
        break;
      case 36:
        oe.pop(), ue = !1;
        break;
      case 37:
        oe.push(Ee), ue = !0;
        break;
      case 38:
        oe.pop(), ue = !1;
        break;
      case 16:
        break;
      default:
        if (!xe.T) {
          if (!ue || Y.WTF && oe[oe.length - 1] != 37 && oe[oe.length - 1] != 35) throw new Error("Unexpected record 0x" + Ee.toString(16));
        }
    }
  }, Y), parse_wb_defaults(re), re.Names = fe, re.supbooks = he, re;
}
function write_BUNDLESHS(le, Y) {
  write_record(
    le,
    143
    /* BrtBeginBundleShs */
  );
  for (var re = 0; re != Y.SheetNames.length; ++re) {
    var oe = Y.Workbook && Y.Workbook.Sheets && Y.Workbook.Sheets[re] && Y.Workbook.Sheets[re].Hidden || 0, ue = { Hidden: oe, iTabID: re + 1, strRelID: "rId" + (re + 1), name: Y.SheetNames[re] };
    write_record(le, 156, write_BrtBundleSh(ue));
  }
  write_record(
    le,
    144
    /* BrtEndBundleShs */
  );
}
function write_BrtFileVersion(le, Y) {
  Y || (Y = new_buf(127));
  for (var re = 0; re != 4; ++re) Y.write_shift(4, 0);
  return write_XLWideString("SheetJS", Y), write_XLWideString(XLSX.version, Y), write_XLWideString(XLSX.version, Y), write_XLWideString("7262", Y), Y.length > Y.l ? Y.slice(0, Y.l) : Y;
}
function write_BrtBookView(le, Y) {
  Y || (Y = new_buf(29)), Y.write_shift(-4, 0), Y.write_shift(-4, 460), Y.write_shift(4, 28800), Y.write_shift(4, 17600), Y.write_shift(4, 500), Y.write_shift(4, le), Y.write_shift(4, le);
  var re = 120;
  return Y.write_shift(1, re), Y.length > Y.l ? Y.slice(0, Y.l) : Y;
}
function write_BOOKVIEWS(le, Y) {
  if (!(!Y.Workbook || !Y.Workbook.Sheets)) {
    for (var re = Y.Workbook.Sheets, oe = 0, ue = -1, fe = -1; oe < re.length; ++oe)
      !re[oe] || !re[oe].Hidden && ue == -1 ? ue = oe : re[oe].Hidden == 1 && fe == -1 && (fe = oe);
    fe > ue || (write_record(
      le,
      135
      /* BrtBeginBookViews */
    ), write_record(le, 158, write_BrtBookView(ue)), write_record(
      le,
      136
      /* BrtEndBookViews */
    ));
  }
}
function write_BRTNAMES(le, Y) {
  !Y.Workbook || !Y.Workbook.Names || Y.Workbook.Names.forEach(function(re) {
    try {
      if (re.Flags & 14) return;
      write_record(le, 39, write_BrtName(re, Y));
    } catch {
      console.error("Could not serialize defined name " + JSON.stringify(re));
    }
  });
}
function write_SELF_EXTERNS_xlsb(le) {
  var Y = le.SheetNames.length, re = new_buf(12 * Y + 28);
  re.write_shift(4, Y + 2), re.write_shift(4, 0), re.write_shift(4, -2), re.write_shift(4, -2), re.write_shift(4, 0), re.write_shift(4, -1), re.write_shift(4, -1);
  for (var oe = 0; oe < Y; ++oe)
    re.write_shift(4, 0), re.write_shift(4, oe), re.write_shift(4, oe);
  return re;
}
function write_EXTERNALS_xlsb(le, Y) {
  write_record(
    le,
    353
    /* BrtBeginExternals */
  ), write_record(
    le,
    357
    /* BrtSupSelf */
  ), write_record(le, 362, write_SELF_EXTERNS_xlsb(Y)), write_record(
    le,
    354
    /* BrtEndExternals */
  );
}
function write_wb_bin(le, Y) {
  var re = buf_array();
  return write_record(
    re,
    131
    /* BrtBeginBook */
  ), write_record(re, 128, write_BrtFileVersion()), write_record(re, 153, write_BrtWbProp(le.Workbook && le.Workbook.WBProps || null)), write_BOOKVIEWS(re, le), write_BUNDLESHS(re, le), write_EXTERNALS_xlsb(re, le), (le.Workbook || {}).Names && write_BRTNAMES(re, le), write_record(
    re,
    132
    /* BrtEndBook */
  ), re.end();
}
function parse_wb(le, Y, re) {
  return Y.slice(-4) === ".bin" ? parse_wb_bin(le, re) : parse_wb_xml(le, re);
}
function parse_ws(le, Y, re, oe, ue, fe, he, _e) {
  return Y.slice(-4) === ".bin" ? parse_ws_bin(le, oe, re, ue, fe, he, _e) : parse_ws_xml(le, oe, re, ue, fe, he, _e);
}
function parse_cs(le, Y, re, oe, ue, fe, he, _e) {
  return Y.slice(-4) === ".bin" ? parse_cs_bin(le, oe, re, ue, fe) : parse_cs_xml(le, oe, re, ue, fe);
}
function parse_ms(le, Y, re, oe, ue, fe, he, _e) {
  return Y.slice(-4) === ".bin" ? parse_ms_bin() : parse_ms_xml();
}
function parse_ds(le, Y, re, oe, ue, fe, he, _e) {
  return Y.slice(-4) === ".bin" ? parse_ds_bin() : parse_ds_xml();
}
function parse_sty(le, Y, re, oe) {
  return Y.slice(-4) === ".bin" ? parse_sty_bin(le, re, oe) : parse_sty_xml(le, re, oe);
}
function parse_sst(le, Y, re) {
  return Y.slice(-4) === ".bin" ? parse_sst_bin(le, re) : parse_sst_xml(le, re);
}
function parse_cmnt(le, Y, re) {
  return Y.slice(-4) === ".bin" ? parse_comments_bin(le, re) : parse_comments_xml(le, re);
}
function parse_cc(le, Y, re) {
  return Y.slice(-4) === ".bin" ? parse_cc_bin(le) : parse_cc_xml(le);
}
function parse_xlink(le, Y, re, oe) {
  return re.slice(-4) === ".bin" ? parse_xlink_bin(le, Y, re, oe) : void 0;
}
function parse_xlmeta(le, Y, re) {
  return Y.slice(-4) === ".bin" ? parse_xlmeta_bin(le, Y, re) : parse_xlmeta_xml(le, Y, re);
}
var attregexg2 = /\b((?:\w+:)?[\w]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g, attregex2 = /\b((?:\w+:)?[\w]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;
function xlml_parsexmltag(le, Y) {
  var re = le.split(/\s+/), oe = [];
  if (oe[0] = re[0], re.length === 1) return oe;
  var ue = le.match(attregexg2), fe, he, _e, ve;
  if (ue) for (ve = 0; ve != ue.length; ++ve)
    fe = ue[ve].match(attregex2), (he = fe[1].indexOf(":")) === -1 ? oe[fe[1]] = fe[2].slice(1, fe[2].length - 1) : (fe[1].slice(0, 6) === "xmlns:" ? _e = "xmlns" + fe[1].slice(6) : _e = fe[1].slice(he + 1), oe[_e] = fe[2].slice(1, fe[2].length - 1));
  return oe;
}
function xlml_parsexmltagobj(le) {
  var Y = le.split(/\s+/), re = {};
  if (Y.length === 1) return re;
  var oe = le.match(attregexg2), ue, fe, he, _e;
  if (oe) for (_e = 0; _e != oe.length; ++_e)
    ue = oe[_e].match(attregex2), (fe = ue[1].indexOf(":")) === -1 ? re[ue[1]] = ue[2].slice(1, ue[2].length - 1) : (ue[1].slice(0, 6) === "xmlns:" ? he = "xmlns" + ue[1].slice(6) : he = ue[1].slice(fe + 1), re[he] = ue[2].slice(1, ue[2].length - 1));
  return re;
}
var XLMLFormatMap;
function xlml_format(le, Y, re) {
  var oe = XLMLFormatMap[le] || unescapexml(le);
  return oe === "General" ? SSF_general(Y) : SSF_format(oe, Y, { date1904: !!re });
}
function xlml_set_custprop(le, Y, re, oe) {
  var ue = oe;
  switch ((re[0].match(/dt:dt="([\w.]+)"/) || ["", ""])[1]) {
    case "boolean":
      ue = parsexmlbool(oe);
      break;
    case "i2":
    case "int":
      ue = parseInt(oe, 10);
      break;
    case "r4":
    case "float":
      ue = parseFloat(oe);
      break;
    case "date":
    case "dateTime.tz":
      ue = parseDate(oe);
      break;
    case "i8":
    case "string":
    case "fixed":
    case "uuid":
    case "bin.base64":
      break;
    default:
      throw new Error("bad custprop:" + re[0]);
  }
  le[unescapexml(Y)] = ue;
}
function safe_format_xlml(le, Y, re, oe) {
  if (le.t !== "z") {
    if (!re || re.cellText !== !1) try {
      le.t === "e" ? le.w = le.w || BErr[le.v] : Y === "General" ? le.t === "n" ? (le.v | 0) === le.v ? le.w = le.v.toString(10) : le.w = SSF_general_num(le.v) : le.w = SSF_general(le.v) : le.w = xlml_format(Y || "General", le.v, oe);
    } catch (he) {
      if (re.WTF) throw he;
    }
    try {
      var ue = XLMLFormatMap[Y] || Y || "General";
      if (re.cellNF && (le.z = ue), re.cellDates && le.t == "n" && fmt_is_date(ue)) {
        var fe = SSF_parse_date_code(le.v + (oe ? 1462 : 0));
        fe && (le.t = "d", le.v = new Date(Date.UTC(fe.y, fe.m - 1, fe.d, fe.H, fe.M, fe.S, fe.u)));
      }
    } catch (he) {
      if (re.WTF) throw he;
    }
  }
}
function process_style_xlml(le, Y, re) {
  if (re.cellStyles && Y.Interior) {
    var oe = Y.Interior;
    oe.Pattern && (oe.patternType = XLMLPatternTypeMap[oe.Pattern] || oe.Pattern);
  }
  le[Y.ID] = Y;
}
function parse_xlml_data(le, Y, re, oe, ue, fe, he, _e, ve, xe, Ee) {
  var Se = "General", Te = oe.StyleID, Ce = {};
  xe = xe || {};
  var Ie = [], Ne = 0;
  for (Te === void 0 && _e && (Te = _e.StyleID), Te === void 0 && he && (Te = he.StyleID); fe[Te] !== void 0; ) {
    var Re = fe[Te];
    if (Re.nf && (Se = Re.nf), Re.Interior && Ie.push(Re.Interior), !Re.Parent) break;
    Te = Re.Parent;
  }
  switch (re.Type) {
    case "Boolean":
      oe.t = "b", oe.v = parsexmlbool(le);
      break;
    case "String":
      oe.t = "s", oe.r = xlml_fixstr(unescapexml(le)), oe.v = le.indexOf("<") > -1 ? unescapexml(Y || le).replace(/<[^<>]*>/g, "") : oe.r;
      break;
    case "DateTime":
      le.slice(-1) != "Z" && (le += "Z"), oe.v = datenum(parseDate(le, Ee), Ee), oe.v !== oe.v && (oe.v = unescapexml(le)), (!Se || Se == "General") && (Se = "yyyy-mm-dd");
    /* falls through */
    case "Number":
      oe.v === void 0 && (oe.v = +le), oe.t || (oe.t = "n");
      break;
    case "Error":
      oe.t = "e", oe.v = RBErr[le], xe.cellText !== !1 && (oe.w = le);
      break;
    default:
      le == "" && Y == "" ? oe.t = "z" : (oe.t = "s", oe.v = xlml_fixstr(Y || le));
      break;
  }
  if (safe_format_xlml(oe, Se, xe, Ee), xe.cellFormula !== !1)
    if (oe.Formula) {
      var Ae = unescapexml(oe.Formula);
      Ae.charCodeAt(0) == 61 && (Ae = Ae.slice(1)), oe.f = rc_to_a1(Ae, ue), delete oe.Formula, oe.ArrayRange == "RC" ? oe.F = rc_to_a1("RC:RC", ue) : oe.ArrayRange && (oe.F = rc_to_a1(oe.ArrayRange, ue), ve.push([safe_decode_range(oe.F), oe.F]));
    } else
      for (Ne = 0; Ne < ve.length; ++Ne)
        ue.r >= ve[Ne][0].s.r && ue.r <= ve[Ne][0].e.r && ue.c >= ve[Ne][0].s.c && ue.c <= ve[Ne][0].e.c && (oe.F = ve[Ne][1]);
  xe.cellStyles && (Ie.forEach(function(Pe) {
    !Ce.patternType && Pe.patternType && (Ce.patternType = Pe.patternType);
  }), oe.s = Ce), oe.StyleID !== void 0 && (oe.ixfe = oe.StyleID);
}
function xlml_prefix_dname(le) {
  return XLSLblBuiltIn.indexOf("_xlnm." + le) > -1 ? "_xlnm." + le : le;
}
function xlml_clean_comment(le) {
  le.t = le.v || "", le.t = le.t.replace(/\r\n/g, `
`).replace(/\r/g, `
`), le.v = le.w = le.ixfe = void 0;
}
function parse_xlml_xml(le, Y) {
  var re = Y || {};
  make_ssf();
  var oe = debom(xlml_normalize(le));
  (re.type == "binary" || re.type == "array" || re.type == "base64") && (typeof $cptable < "u" ? oe = $cptable.utils.decode(65001, char_codes(oe)) : oe = utf8read(oe));
  var ue = oe.slice(0, 1024).toLowerCase(), fe = !1;
  if (ue = ue.replace(/".*?"/g, ""), (ue.indexOf(">") & 1023) > Math.min(ue.indexOf(",") & 1023, ue.indexOf(";") & 1023)) {
    var he = dup(re);
    return he.type = "string", PRN.to_workbook(oe, he);
  }
  if (ue.indexOf("<?xml") == -1 && ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(Dt) {
    ue.indexOf("<" + Dt) >= 0 && (fe = !0);
  }), fe) return html_to_workbook(oe, re);
  XLMLFormatMap = {
    "General Number": "General",
    "General Date": table_fmt[22],
    "Long Date": "dddd, mmmm dd, yyyy",
    "Medium Date": table_fmt[15],
    "Short Date": table_fmt[14],
    "Long Time": table_fmt[19],
    "Medium Time": table_fmt[18],
    "Short Time": table_fmt[20],
    Currency: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    Fixed: table_fmt[2],
    Standard: table_fmt[4],
    Percent: table_fmt[10],
    Scientific: table_fmt[11],
    "Yes/No": '"Yes";"Yes";"No";@',
    "True/False": '"True";"True";"False";@',
    "On/Off": '"Yes";"Yes";"No";@'
  };
  var _e, ve = [], xe, Ee = {}, Se = [], Te = {}, Ce = "";
  re.dense && (Te["!data"] = []);
  var Ie = {}, Ne = {}, Re = xlml_parsexmltag('<Data ss:Type="String">'), Ae = 0, Pe = 0, Fe = 0, Le = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, He = {}, Ge = {}, Ve = "", $e = 0, De = [], Ke = {}, ze = {}, tt = 0, Xe = [], mt = [], at = {}, qe = [], st, xt = !1, gt = [], Ze = [], _t = {}, wt = 0, yt = 0, St = { Sheets: [], WBProps: { date1904: !1 } }, It = {};
  xlmlregex.lastIndex = 0, oe = str_remove_ng(oe, "<!--", "-->");
  for (var Bt = ""; _e = xlmlregex.exec(oe); ) switch (_e[3] = (Bt = _e[3]).toLowerCase()) {
    case "data":
      if (Bt == "data") {
        if (_e[1] === "/") {
          if ((xe = ve.pop())[0] !== _e[3]) throw new Error("Bad state: " + xe.join("|"));
        } else _e[0].charAt(_e[0].length - 2) !== "/" && ve.push([_e[3], !0]);
        break;
      }
      if (ve[ve.length - 1][1]) break;
      _e[1] === "/" ? parse_xlml_data(oe.slice(Ae, _e.index), Ve, Re, ve[ve.length - 1][0] == /*"Comment"*/
      "comment" ? at : Ie, { c: Pe, r: Fe }, He, qe[Pe], Ne, gt, re, St.WBProps.date1904) : (Ve = "", Re = xlml_parsexmltag(_e[0]), Ae = _e.index + _e[0].length);
      break;
    case "cell":
      if (_e[1] === "/")
        if (mt.length > 0 && (Ie.c = mt), (!re.sheetRows || re.sheetRows > Fe) && Ie.v !== void 0 && (re.dense ? (Te["!data"][Fe] || (Te["!data"][Fe] = []), Te["!data"][Fe][Pe] = Ie) : Te[encode_col(Pe) + encode_row(Fe)] = Ie), Ie.HRef && (Ie.l = { Target: unescapexml(Ie.HRef) }, Ie.HRefScreenTip && (Ie.l.Tooltip = Ie.HRefScreenTip), delete Ie.HRef, delete Ie.HRefScreenTip), (Ie.MergeAcross || Ie.MergeDown) && (wt = Pe + (parseInt(Ie.MergeAcross, 10) | 0), yt = Fe + (parseInt(Ie.MergeDown, 10) | 0), (wt > Pe || yt > Fe) && De.push({ s: { c: Pe, r: Fe }, e: { c: wt, r: yt } })), !re.sheetStubs)
          Ie.MergeAcross ? Pe = wt + 1 : ++Pe;
        else if (Ie.MergeAcross || Ie.MergeDown) {
          for (var Ye = Pe; Ye <= wt; ++Ye)
            for (var Be = Fe; Be <= yt; ++Be)
              (Ye > Pe || Be > Fe) && (re.dense ? (Te["!data"][Be] || (Te["!data"][Be] = []), Te["!data"][Be][Ye] = { t: "z" }) : Te[encode_col(Ye) + encode_row(Be)] = { t: "z" });
          Pe = wt + 1;
        } else ++Pe;
      else
        Ie = xlml_parsexmltagobj(_e[0]), Ie.Index && (Pe = +Ie.Index - 1), Pe < Le.s.c && (Le.s.c = Pe), Pe > Le.e.c && (Le.e.c = Pe), _e[0].slice(-2) === "/>" && ++Pe, mt = [];
      break;
    case "row":
      _e[1] === "/" || _e[0].slice(-2) === "/>" ? (Fe < Le.s.r && (Le.s.r = Fe), Fe > Le.e.r && (Le.e.r = Fe), _e[0].slice(-2) === "/>" && (Ne = xlml_parsexmltag(_e[0]), Ne.Index && (Fe = +Ne.Index - 1)), Pe = 0, ++Fe) : (Ne = xlml_parsexmltag(_e[0]), Ne.Index && (Fe = +Ne.Index - 1), _t = {}, (Ne.AutoFitHeight == "0" || Ne.Height) && (_t.hpx = parseInt(Ne.Height, 10), _t.hpt = px2pt(_t.hpx), Ze[Fe] = _t), Ne.Hidden == "1" && (_t.hidden = !0, Ze[Fe] = _t));
      break;
    case "worksheet":
      if (_e[1] === "/") {
        if ((xe = ve.pop())[0] !== _e[3]) throw new Error("Bad state: " + xe.join("|"));
        Se.push(Ce), Le.s.r <= Le.e.r && Le.s.c <= Le.e.c && (Te["!ref"] = encode_range(Le), re.sheetRows && re.sheetRows <= Le.e.r && (Te["!fullref"] = Te["!ref"], Le.e.r = re.sheetRows - 1, Te["!ref"] = encode_range(Le))), De.length && (Te["!merges"] = De), qe.length > 0 && (Te["!cols"] = qe), Ze.length > 0 && (Te["!rows"] = Ze), Ee[Ce] = Te;
      } else
        Le = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, Fe = Pe = 0, ve.push([_e[3], !1]), xe = xlml_parsexmltag(_e[0]), Ce = unescapexml(xe.Name), Te = {}, re.dense && (Te["!data"] = []), De = [], gt = [], Ze = [], It = { name: Ce, Hidden: 0 }, St.Sheets.push(It);
      break;
    case "table":
      if (_e[1] === "/") {
        if ((xe = ve.pop())[0] !== _e[3]) throw new Error("Bad state: " + xe.join("|"));
      } else {
        if (_e[0].slice(-2) == "/>") break;
        ve.push([_e[3], !1]), qe = [], xt = !1;
      }
      break;
    case "style":
      _e[1] === "/" ? process_style_xlml(He, Ge, re) : Ge = xlml_parsexmltag(_e[0]);
      break;
    case "numberformat":
      Ge.nf = unescapexml(xlml_parsexmltag(_e[0]).Format || "General"), XLMLFormatMap[Ge.nf] && (Ge.nf = XLMLFormatMap[Ge.nf]);
      for (var et = 0; et != 392 && table_fmt[et] != Ge.nf; ++et) ;
      if (et == 392) {
        for (et = 57; et != 392; ++et) if (table_fmt[et] == null) {
          SSF__load(Ge.nf, et);
          break;
        }
      }
      break;
    case "column":
      if (ve[ve.length - 1][0] !== /*'Table'*/
      "table" || _e[1] === "/") break;
      if (st = xlml_parsexmltag(_e[0]), st.Hidden && (st.hidden = !0, delete st.Hidden), st.Width && (st.wpx = parseInt(st.Width, 10)), !xt && st.wpx > 10) {
        xt = !0, MDW = DEF_MDW;
        for (var je = 0; je < qe.length; ++je) qe[je] && process_col(qe[je]);
      }
      xt && process_col(st), qe[st.Index - 1 || qe.length] = st;
      for (var it = 0; it < +st.Span; ++it) qe[qe.length] = dup(st);
      break;
    case "namedrange":
      if (_e[1] === "/") break;
      St.Names || (St.Names = []);
      var bt = parsexmltag(_e[0]), rt = {
        Name: xlml_prefix_dname(bt.Name),
        Ref: rc_to_a1(bt.RefersTo.slice(1), { r: 0, c: 0 })
      };
      St.Sheets.length > 0 && (rt.Sheet = St.Sheets.length - 1), St.Names.push(rt);
      break;
    case "namedcell":
      break;
    case "b":
      break;
    case "i":
      break;
    case "u":
      break;
    case "s":
      break;
    case "em":
      break;
    case "h2":
      break;
    case "h3":
      break;
    case "sub":
      break;
    case "sup":
      break;
    case "span":
      break;
    case "alignment":
      break;
    case "borders":
      break;
    case "border":
      break;
    case "font":
      if (_e[0].slice(-2) === "/>") break;
      _e[1] === "/" ? Ve += oe.slice($e, _e.index) : $e = _e.index + _e[0].length;
      break;
    case "interior":
      if (!re.cellStyles) break;
      Ge.Interior = xlml_parsexmltag(_e[0]);
      break;
    case "protection":
      break;
    case "author":
    case "title":
    case "description":
    case "created":
    case "keywords":
    case "subject":
    case "category":
    case "company":
    case "lastauthor":
    case "lastsaved":
    case "lastprinted":
    case "version":
    case "revision":
    case "totaltime":
    case "hyperlinkbase":
    case "manager":
    case "contentstatus":
    case "identifier":
    case "language":
    case "appname":
      if (_e[0].slice(-2) === "/>") break;
      _e[1] === "/" ? xlml_set_prop(Ke, Bt, oe.slice(tt, _e.index)) : tt = _e.index + _e[0].length;
      break;
    case "paragraphs":
      break;
    case "styles":
    case "workbook":
      if (_e[1] === "/") {
        if ((xe = ve.pop())[0] !== _e[3]) throw new Error("Bad state: " + xe.join("|"));
      } else ve.push([_e[3], !1]);
      break;
    case "comment":
      if (_e[1] === "/") {
        if ((xe = ve.pop())[0] !== _e[3]) throw new Error("Bad state: " + xe.join("|"));
        xlml_clean_comment(at), mt.push(at);
      } else
        ve.push([_e[3], !1]), xe = xlml_parsexmltag(_e[0]), parsexmlbool(xe.ShowAlways || "0") || (mt.hidden = !0), at = { a: xe.Author };
      break;
    case "autofilter":
      if (_e[1] === "/") {
        if ((xe = ve.pop())[0] !== _e[3]) throw new Error("Bad state: " + xe.join("|"));
      } else if (_e[0].charAt(_e[0].length - 2) !== "/") {
        var Ct = xlml_parsexmltag(_e[0]);
        Te["!autofilter"] = { ref: rc_to_a1(Ct.Range).replace(/\$/g, "") }, ve.push([_e[3], !0]);
      }
      break;
    case "name":
      break;
    case "datavalidation":
      if (_e[1] === "/") {
        if ((xe = ve.pop())[0] !== _e[3]) throw new Error("Bad state: " + xe.join("|"));
      } else
        _e[0].charAt(_e[0].length - 2) !== "/" && ve.push([_e[3], !0]);
      break;
    case "pixelsperinch":
      break;
    case "componentoptions":
    case "documentproperties":
    case "customdocumentproperties":
    case "officedocumentsettings":
    case "pivottable":
    case "pivotcache":
    case "names":
    case "mapinfo":
    case "pagebreaks":
    case "querytable":
    case "sorting":
    case "schema":
    //case 'data' /*case 'data'*/:
    case "conditionalformatting":
    case "smarttagtype":
    case "smarttags":
    case "excelworkbook":
    case "workbookoptions":
    case "worksheetoptions":
      if (_e[1] === "/") {
        if ((xe = ve.pop())[0] !== _e[3]) throw new Error("Bad state: " + xe.join("|"));
      } else _e[0].charAt(_e[0].length - 2) !== "/" && ve.push([_e[3], !0]);
      break;
    case "null":
      break;
    default:
      if (ve.length == 0 && _e[3] == "document" || ve.length == 0 && _e[3] == "uof") return parse_fods(oe, re);
      var Rt = !0;
      switch (ve[ve.length - 1][0]) {
        /* OfficeDocumentSettings */
        case "officedocumentsettings":
          switch (_e[3]) {
            case "allowpng":
              break;
            case "removepersonalinformation":
              break;
            case "downloadcomponents":
              break;
            case "locationofcomponents":
              break;
            case "colors":
              break;
            case "color":
              break;
            case "index":
              break;
            case "rgb":
              break;
            case "targetscreensize":
              break;
            case "readonlyrecommended":
              break;
            default:
              Rt = !1;
          }
          break;
        /* ComponentOptions */
        case "componentoptions":
          switch (_e[3]) {
            case "toolbar":
              break;
            case "hideofficelogo":
              break;
            case "spreadsheetautofit":
              break;
            case "label":
              break;
            case "caption":
              break;
            case "maxheight":
              break;
            case "maxwidth":
              break;
            case "nextsheetnumber":
              break;
            default:
              Rt = !1;
          }
          break;
        /* ExcelWorkbook */
        case "excelworkbook":
          switch (_e[3]) {
            case "date1904":
              St.WBProps.date1904 = !0;
              break;
            case "hidehorizontalscrollbar":
              break;
            case "hideverticalscrollbar":
              break;
            case "hideworkbooktabs":
              break;
            case "windowheight":
              break;
            case "windowwidth":
              break;
            case "windowtopx":
              break;
            case "windowtopy":
              break;
            case "tabratio":
              break;
            case "protectstructure":
              break;
            case "protectwindow":
              break;
            case "protectwindows":
              break;
            case "activesheet":
              break;
            case "displayinknotes":
              break;
            case "firstvisiblesheet":
              break;
            case "supbook":
              break;
            case "sheetname":
              break;
            case "sheetindex":
              break;
            case "sheetindexfirst":
              break;
            case "sheetindexlast":
              break;
            case "dll":
              break;
            case "acceptlabelsinformulas":
              break;
            case "donotsavelinkvalues":
              break;
            case "iteration":
              break;
            case "maxiterations":
              break;
            case "maxchange":
              break;
            case "path":
              break;
            case "xct":
              break;
            case "count":
              break;
            case "selectedsheets":
              break;
            case "calculation":
              break;
            case "uncalced":
              break;
            case "startupprompt":
              break;
            case "crn":
              break;
            case "externname":
              break;
            case "formula":
              break;
            case "colfirst":
              break;
            case "collast":
              break;
            case "wantadvise":
              break;
            case "boolean":
              break;
            case "error":
              break;
            case "text":
              break;
            case "ole":
              break;
            case "noautorecover":
              break;
            case "publishobjects":
              break;
            case "donotcalculatebeforesave":
              break;
            case "number":
              break;
            case "refmoder1c1":
              break;
            case "embedsavesmarttags":
              break;
            default:
              Rt = !1;
          }
          break;
        /* WorkbookOptions */
        case "workbookoptions":
          switch (_e[3]) {
            case "owcversion":
              break;
            case "height":
              break;
            case "width":
              break;
            default:
              Rt = !1;
          }
          break;
        /* WorksheetOptions */
        case "worksheetoptions":
          switch (_e[3]) {
            case "visible":
              if (_e[0].slice(-2) !== "/>") if (_e[1] === "/") switch (oe.slice(tt, _e.index)) {
                case "SheetHidden":
                  It.Hidden = 1;
                  break;
                case "SheetVeryHidden":
                  It.Hidden = 2;
                  break;
              }
              else tt = _e.index + _e[0].length;
              break;
            case "header":
              Te["!margins"] || default_margins(Te["!margins"] = {}, "xlml"), isNaN(+parsexmltag(_e[0]).Margin) || (Te["!margins"].header = +parsexmltag(_e[0]).Margin);
              break;
            case "footer":
              Te["!margins"] || default_margins(Te["!margins"] = {}, "xlml"), isNaN(+parsexmltag(_e[0]).Margin) || (Te["!margins"].footer = +parsexmltag(_e[0]).Margin);
              break;
            case "pagemargins":
              var Ot = parsexmltag(_e[0]);
              Te["!margins"] || default_margins(Te["!margins"] = {}, "xlml"), isNaN(+Ot.Top) || (Te["!margins"].top = +Ot.Top), isNaN(+Ot.Left) || (Te["!margins"].left = +Ot.Left), isNaN(+Ot.Right) || (Te["!margins"].right = +Ot.Right), isNaN(+Ot.Bottom) || (Te["!margins"].bottom = +Ot.Bottom);
              break;
            case "displayrighttoleft":
              St.Views || (St.Views = []), St.Views[0] || (St.Views[0] = {}), St.Views[0].RTL = !0;
              break;
            case "freezepanes":
              break;
            case "frozennosplit":
              break;
            case "splithorizontal":
            case "splitvertical":
              break;
            case "donotdisplaygridlines":
              break;
            case "activerow":
              break;
            case "activecol":
              break;
            case "toprowbottompane":
              break;
            case "leftcolumnrightpane":
              break;
            case "unsynced":
              break;
            case "print":
              break;
            case "printerrors":
              break;
            case "panes":
              break;
            case "scale":
              break;
            case "pane":
              break;
            case "number":
              break;
            case "layout":
              break;
            case "pagesetup":
              break;
            case "selected":
              break;
            case "protectobjects":
              break;
            case "enableselection":
              break;
            case "protectscenarios":
              break;
            case "validprinterinfo":
              break;
            case "horizontalresolution":
              break;
            case "verticalresolution":
              break;
            case "numberofcopies":
              break;
            case "activepane":
              break;
            case "toprowvisible":
              break;
            case "leftcolumnvisible":
              break;
            case "fittopage":
              break;
            case "rangeselection":
              break;
            case "papersizeindex":
              break;
            case "pagelayoutzoom":
              break;
            case "pagebreakzoom":
              break;
            case "filteron":
              break;
            case "fitwidth":
              break;
            case "fitheight":
              break;
            case "commentslayout":
              break;
            case "zoom":
              break;
            case "lefttoright":
              break;
            case "gridlines":
              break;
            case "allowsort":
              break;
            case "allowfilter":
              break;
            case "allowinsertrows":
              break;
            case "allowdeleterows":
              break;
            case "allowinsertcols":
              break;
            case "allowdeletecols":
              break;
            case "allowinserthyperlinks":
              break;
            case "allowformatcells":
              break;
            case "allowsizecols":
              break;
            case "allowsizerows":
              break;
            case "nosummaryrowsbelowdetail":
              Te["!outline"] || (Te["!outline"] = {}), Te["!outline"].above = !0;
              break;
            case "tabcolorindex":
              break;
            case "donotdisplayheadings":
              break;
            case "showpagelayoutzoom":
              break;
            case "nosummarycolumnsrightdetail":
              Te["!outline"] || (Te["!outline"] = {}), Te["!outline"].left = !0;
              break;
            case "blackandwhite":
              break;
            case "donotdisplayzeros":
              break;
            case "displaypagebreak":
              break;
            case "rowcolheadings":
              break;
            case "donotdisplayoutline":
              break;
            case "noorientation":
              break;
            case "allowusepivottables":
              break;
            case "zeroheight":
              break;
            case "viewablerange":
              break;
            case "selection":
              break;
            case "protectcontents":
              break;
            default:
              Rt = !1;
          }
          break;
        /* PivotTable */
        case "pivottable":
        case "pivotcache":
          switch (_e[3]) {
            case "immediateitemsondrop":
              break;
            case "showpagemultipleitemlabel":
              break;
            case "compactrowindent":
              break;
            case "location":
              break;
            case "pivotfield":
              break;
            case "orientation":
              break;
            case "layoutform":
              break;
            case "layoutsubtotallocation":
              break;
            case "layoutcompactrow":
              break;
            case "position":
              break;
            case "pivotitem":
              break;
            case "datatype":
              break;
            case "datafield":
              break;
            case "sourcename":
              break;
            case "parentfield":
              break;
            case "ptlineitems":
              break;
            case "ptlineitem":
              break;
            case "countofsameitems":
              break;
            case "item":
              break;
            case "itemtype":
              break;
            case "ptsource":
              break;
            case "cacheindex":
              break;
            case "consolidationreference":
              break;
            case "filename":
              break;
            case "reference":
              break;
            case "nocolumngrand":
              break;
            case "norowgrand":
              break;
            case "blanklineafteritems":
              break;
            case "hidden":
              break;
            case "subtotal":
              break;
            case "basefield":
              break;
            case "mapchilditems":
              break;
            case "function":
              break;
            case "refreshonfileopen":
              break;
            case "printsettitles":
              break;
            case "mergelabels":
              break;
            case "defaultversion":
              break;
            case "refreshname":
              break;
            case "refreshdate":
              break;
            case "refreshdatecopy":
              break;
            case "versionlastrefresh":
              break;
            case "versionlastupdate":
              break;
            case "versionupdateablemin":
              break;
            case "versionrefreshablemin":
              break;
            case "calculation":
              break;
            default:
              Rt = !1;
          }
          break;
        /* PageBreaks */
        case "pagebreaks":
          switch (_e[3]) {
            case "colbreaks":
              break;
            case "colbreak":
              break;
            case "rowbreaks":
              break;
            case "rowbreak":
              break;
            case "colstart":
              break;
            case "colend":
              break;
            case "rowend":
              break;
            default:
              Rt = !1;
          }
          break;
        /* AutoFilter */
        case "autofilter":
          switch (_e[3]) {
            case "autofiltercolumn":
              break;
            case "autofiltercondition":
              break;
            case "autofilterand":
              break;
            case "autofilteror":
              break;
            default:
              Rt = !1;
          }
          break;
        /* QueryTable */
        case "querytable":
          switch (_e[3]) {
            case "id":
              break;
            case "autoformatfont":
              break;
            case "autoformatpattern":
              break;
            case "querysource":
              break;
            case "querytype":
              break;
            case "enableredirections":
              break;
            case "refreshedinxl9":
              break;
            case "urlstring":
              break;
            case "htmltables":
              break;
            case "connection":
              break;
            case "commandtext":
              break;
            case "refreshinfo":
              break;
            case "notitles":
              break;
            case "nextid":
              break;
            case "columninfo":
              break;
            case "overwritecells":
              break;
            case "donotpromptforfile":
              break;
            case "textwizardsettings":
              break;
            case "source":
              break;
            case "number":
              break;
            case "decimal":
              break;
            case "thousandseparator":
              break;
            case "trailingminusnumbers":
              break;
            case "formatsettings":
              break;
            case "fieldtype":
              break;
            case "delimiters":
              break;
            case "tab":
              break;
            case "comma":
              break;
            case "autoformatname":
              break;
            case "versionlastedit":
              break;
            case "versionlastrefresh":
              break;
            default:
              Rt = !1;
          }
          break;
        case "datavalidation":
          switch (_e[3]) {
            case "range":
              break;
            case "type":
              break;
            case "min":
              break;
            case "max":
              break;
            case "sort":
              break;
            case "descending":
              break;
            case "order":
              break;
            case "casesensitive":
              break;
            case "value":
              break;
            case "errorstyle":
              break;
            case "errormessage":
              break;
            case "errortitle":
              break;
            case "inputmessage":
              break;
            case "inputtitle":
              break;
            case "combohide":
              break;
            case "inputhide":
              break;
            case "condition":
              break;
            case "qualifier":
              break;
            case "useblank":
              break;
            case "value1":
              break;
            case "value2":
              break;
            case "format":
              break;
            case "cellrangelist":
              break;
            default:
              Rt = !1;
          }
          break;
        case "sorting":
        case "conditionalformatting":
          switch (_e[3]) {
            case "range":
              break;
            case "type":
              break;
            case "min":
              break;
            case "max":
              break;
            case "sort":
              break;
            case "descending":
              break;
            case "order":
              break;
            case "casesensitive":
              break;
            case "value":
              break;
            case "errorstyle":
              break;
            case "errormessage":
              break;
            case "errortitle":
              break;
            case "cellrangelist":
              break;
            case "inputmessage":
              break;
            case "inputtitle":
              break;
            case "combohide":
              break;
            case "inputhide":
              break;
            case "condition":
              break;
            case "qualifier":
              break;
            case "useblank":
              break;
            case "value1":
              break;
            case "value2":
              break;
            case "format":
              break;
            default:
              Rt = !1;
          }
          break;
        /* MapInfo (schema) */
        case "mapinfo":
        case "schema":
        case "data":
          switch (_e[3]) {
            case "map":
              break;
            case "entry":
              break;
            case "range":
              break;
            case "xpath":
              break;
            case "field":
              break;
            case "xsdtype":
              break;
            case "filteron":
              break;
            case "aggregate":
              break;
            case "elementtype":
              break;
            case "attributetype":
              break;
            /* These are from xsd (XML Schema Definition) */
            case "schema":
            case "element":
            case "complextype":
            case "datatype":
            case "all":
            case "attribute":
            case "extends":
              break;
            case "row":
              break;
            default:
              Rt = !1;
          }
          break;
        /* SmartTags (can be anything) */
        case "smarttags":
          break;
        default:
          Rt = !1;
          break;
      }
      if (Rt || _e[3].match(/!\[CDATA/)) break;
      if (!ve[ve.length - 1][1]) throw "Unrecognized tag: " + _e[3] + "|" + ve.join("|");
      if (ve[ve.length - 1][0] === /*'CustomDocumentProperties'*/
      "customdocumentproperties") {
        if (_e[0].slice(-2) === "/>") break;
        _e[1] === "/" ? xlml_set_custprop(ze, Bt, Xe, oe.slice(tt, _e.index)) : (Xe = _e, tt = _e.index + _e[0].length);
        break;
      }
      if (re.WTF) throw "Unrecognized tag: " + _e[3] + "|" + ve.join("|");
  }
  var Mt = {};
  return !re.bookSheets && !re.bookProps && (Mt.Sheets = Ee), Mt.SheetNames = Se, Mt.Workbook = St, Mt.SSF = dup(table_fmt), Mt.Props = Ke, Mt.Custprops = ze, Mt.bookType = "xlml", Mt;
}
function parse_xlml(le, Y) {
  switch (fix_read_opts(Y = Y || {}), Y.type || "base64") {
    case "base64":
      return parse_xlml_xml(Base64_decode(le), Y);
    case "binary":
    case "buffer":
    case "file":
      return parse_xlml_xml(le, Y);
    case "array":
      return parse_xlml_xml(a2s(le), Y);
  }
}
function write_props_xlml(le, Y) {
  var re = [];
  return le.Props && re.push(xlml_write_docprops(le.Props, Y)), le.Custprops && re.push(xlml_write_custprops(le.Props, le.Custprops)), re.join("");
}
function write_wb_xlml(le) {
  return (((le || {}).Workbook || {}).WBProps || {}).date1904 ? '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel"><Date1904/></ExcelWorkbook>' : "";
}
function write_sty_xlml(le, Y) {
  var re = ['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];
  return Y.cellXfs.forEach(function(oe, ue) {
    var fe = [];
    fe.push(writextag("NumberFormat", null, { "ss:Format": escapexml(table_fmt[oe.numFmtId]) }));
    var he = (
      /*::(*/
      { "ss:ID": "s" + (21 + ue) }
    );
    re.push(writextag("Style", fe.join(""), he));
  }), writextag("Styles", re.join(""));
}
function write_name_xlml(le) {
  return writextag("NamedRange", null, { "ss:Name": le.Name.slice(0, 6) == "_xlnm." ? le.Name.slice(6) : le.Name, "ss:RefersTo": "=" + a1_to_rc(le.Ref, { r: 0, c: 0 }) });
}
function write_names_xlml(le) {
  if (!((le || {}).Workbook || {}).Names) return "";
  for (var Y = le.Workbook.Names, re = [], oe = 0; oe < Y.length; ++oe) {
    var ue = Y[oe];
    ue.Sheet == null && (ue.Name.match(/^_xlfn\./) || re.push(write_name_xlml(ue)));
  }
  return writextag("Names", re.join(""));
}
function write_ws_xlml_names(le, Y, re, oe) {
  if (!le || !((oe || {}).Workbook || {}).Names) return "";
  for (var ue = oe.Workbook.Names, fe = [], he = 0; he < ue.length; ++he) {
    var _e = ue[he];
    _e.Sheet == re && (_e.Name.match(/^_xlfn\./) || fe.push(write_name_xlml(_e)));
  }
  return fe.join("");
}
function write_ws_xlml_wsopts(le, Y, re, oe) {
  if (!le) return "";
  var ue = [];
  if (le["!margins"] && (ue.push("<PageSetup>"), le["!margins"].header && ue.push(writextag("Header", null, { "x:Margin": le["!margins"].header })), le["!margins"].footer && ue.push(writextag("Footer", null, { "x:Margin": le["!margins"].footer })), ue.push(writextag("PageMargins", null, {
    "x:Bottom": le["!margins"].bottom || "0.75",
    "x:Left": le["!margins"].left || "0.7",
    "x:Right": le["!margins"].right || "0.7",
    "x:Top": le["!margins"].top || "0.75"
  })), ue.push("</PageSetup>")), oe && oe.Workbook && oe.Workbook.Sheets && oe.Workbook.Sheets[re])
    if (oe.Workbook.Sheets[re].Hidden) ue.push(writextag("Visible", oe.Workbook.Sheets[re].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden", {}));
    else {
      for (var fe = 0; fe < re && !(oe.Workbook.Sheets[fe] && !oe.Workbook.Sheets[fe].Hidden); ++fe) ;
      fe == re && ue.push("<Selected/>");
    }
  return ((((oe || {}).Workbook || {}).Views || [])[0] || {}).RTL && ue.push("<DisplayRightToLeft/>"), le["!protect"] && (ue.push(writetag("ProtectContents", "True")), le["!protect"].objects && ue.push(writetag("ProtectObjects", "True")), le["!protect"].scenarios && ue.push(writetag("ProtectScenarios", "True")), le["!protect"].selectLockedCells != null && !le["!protect"].selectLockedCells ? ue.push(writetag("EnableSelection", "NoSelection")) : le["!protect"].selectUnlockedCells != null && !le["!protect"].selectUnlockedCells && ue.push(writetag("EnableSelection", "UnlockedCells")), [
    ["formatCells", "AllowFormatCells"],
    ["formatColumns", "AllowSizeCols"],
    ["formatRows", "AllowSizeRows"],
    ["insertColumns", "AllowInsertCols"],
    ["insertRows", "AllowInsertRows"],
    ["insertHyperlinks", "AllowInsertHyperlinks"],
    ["deleteColumns", "AllowDeleteCols"],
    ["deleteRows", "AllowDeleteRows"],
    ["sort", "AllowSort"],
    ["autoFilter", "AllowFilter"],
    ["pivotTables", "AllowUsePivotTables"]
  ].forEach(function(he) {
    le["!protect"][he[0]] && ue.push("<" + he[1] + "/>");
  })), ue.length == 0 ? "" : writextag("WorksheetOptions", ue.join(""), { xmlns: XLMLNS.x });
}
function write_ws_xlml_comment(le) {
  return le.map(function(Y) {
    var re = xlml_unfixstr(Y.t || ""), oe = writextag("ss:Data", re, { xmlns: "http://www.w3.org/TR/REC-html40" }), ue = {};
    return Y.a && (ue["ss:Author"] = Y.a), le.hidden || (ue["ss:ShowAlways"] = "1"), writextag("Comment", oe, ue);
  }).join("");
}
function write_ws_xlml_cell(le, Y, re, oe, ue, fe, he) {
  if (!le || le.v == null && le.f == null) return "";
  var _e = {};
  if (le.f && (_e["ss:Formula"] = "=" + escapexml(a1_to_rc(le.f, he))), le.F && le.F.slice(0, Y.length) == Y) {
    var ve = decode_cell(le.F.slice(Y.length + 1));
    _e["ss:ArrayRange"] = "RC:R" + (ve.r == he.r ? "" : "[" + (ve.r - he.r) + "]") + "C" + (ve.c == he.c ? "" : "[" + (ve.c - he.c) + "]");
  }
  if (le.l && le.l.Target && (_e["ss:HRef"] = escapexml(le.l.Target), le.l.Tooltip && (_e["x:HRefScreenTip"] = escapexml(le.l.Tooltip))), re["!merges"])
    for (var xe = re["!merges"], Ee = 0; Ee != xe.length; ++Ee)
      xe[Ee].s.c != he.c || xe[Ee].s.r != he.r || (xe[Ee].e.c > xe[Ee].s.c && (_e["ss:MergeAcross"] = xe[Ee].e.c - xe[Ee].s.c), xe[Ee].e.r > xe[Ee].s.r && (_e["ss:MergeDown"] = xe[Ee].e.r - xe[Ee].s.r));
  var Se = "", Te = "";
  switch (le.t) {
    case "z":
      if (!oe.sheetStubs) return "";
      break;
    case "n":
      isFinite(le.v) ? (Se = "Number", Te = String(le.v)) : (Se = "Error", Te = BErr[isNaN(le.v) ? 36 : 7]);
      break;
    case "b":
      Se = "Boolean", Te = le.v ? "1" : "0";
      break;
    case "e":
      Se = "Error", Te = BErr[le.v];
      break;
    case "d":
      Se = "DateTime", Te = new Date(le.v).toISOString(), le.z == null && (le.z = le.z || table_fmt[14]);
      break;
    case "s":
      Se = "String", Te = escapexlml(le.v || "");
      break;
  }
  var Ce = get_cell_style(oe.cellXfs, le, oe);
  _e["ss:StyleID"] = "s" + (21 + Ce), _e["ss:Index"] = he.c + 1;
  var Ie = le.v != null ? Te : "", Ne = le.t == "z" ? "" : '<Data ss:Type="' + Se + '">' + Ie + "</Data>";
  return (le.c || []).length > 0 && (Ne += write_ws_xlml_comment(le.c)), writextag("Cell", Ne, _e);
}
function write_ws_xlml_row(le, Y) {
  var re = '<Row ss:Index="' + (le + 1) + '"';
  return Y && (Y.hpt && !Y.hpx && (Y.hpx = pt2px(Y.hpt)), Y.hpx && (re += ' ss:AutoFitHeight="0" ss:Height="' + Y.hpx + '"'), Y.hidden && (re += ' ss:Hidden="1"')), re + ">";
}
function write_ws_xlml_table(le, Y, re, oe) {
  if (!le["!ref"]) return "";
  var ue = safe_decode_range(le["!ref"]), fe = le["!merges"] || [], he = 0, _e = [];
  le["!cols"] && le["!cols"].forEach(function(Re, Ae) {
    process_col(Re);
    var Pe = !!Re.width, Fe = col_obj_w(Ae, Re), Le = { "ss:Index": Ae + 1 };
    Pe && (Le["ss:Width"] = width2px(Fe.width)), Re.hidden && (Le["ss:Hidden"] = "1"), _e.push(writextag("Column", null, Le));
  });
  for (var ve = le["!data"] != null, xe = { r: 0, c: 0 }, Ee = ue.s.r; Ee <= ue.e.r; ++Ee) {
    var Se = [write_ws_xlml_row(Ee, (le["!rows"] || [])[Ee])];
    xe.r = Ee;
    for (var Te = ue.s.c; Te <= ue.e.c; ++Te) {
      xe.c = Te;
      var Ce = !1;
      for (he = 0; he != fe.length; ++he)
        if (!(fe[he].s.c > Te) && !(fe[he].s.r > Ee) && !(fe[he].e.c < Te) && !(fe[he].e.r < Ee)) {
          (fe[he].s.c != Te || fe[he].s.r != Ee) && (Ce = !0);
          break;
        }
      if (!Ce) {
        var Ie = encode_col(Te) + encode_row(Ee), Ne = ve ? (le["!data"][Ee] || [])[Te] : le[Ie];
        Se.push(write_ws_xlml_cell(Ne, Ie, le, Y, re, oe, xe));
      }
    }
    Se.push("</Row>"), Se.length > 2 && _e.push(Se.join(""));
  }
  return _e.join("");
}
function write_ws_xlml(le, Y, re) {
  var oe = [], ue = re.SheetNames[le], fe = re.Sheets[ue], he = fe ? write_ws_xlml_names(fe, Y, le, re) : "";
  return he.length > 0 && oe.push("<Names>" + he + "</Names>"), he = fe ? write_ws_xlml_table(fe, Y, le, re) : "", he.length > 0 && oe.push("<Table>" + he + "</Table>"), oe.push(write_ws_xlml_wsopts(fe, Y, le, re)), fe && fe["!autofilter"] && oe.push('<AutoFilter x:Range="' + a1_to_rc(fix_range(fe["!autofilter"].ref), { r: 0, c: 0 }) + '" xmlns="urn:schemas-microsoft-com:office:excel"></AutoFilter>'), oe.join("");
}
function write_xlml(le, Y) {
  Y || (Y = {}), le.SSF || (le.SSF = dup(table_fmt)), le.SSF && (make_ssf(), SSF_load_table(le.SSF), Y.revssf = evert_num(le.SSF), Y.revssf[le.SSF[65535]] = 0, Y.ssf = le.SSF, Y.cellXfs = [], get_cell_style(Y.cellXfs, {}, { revssf: { General: 0 } }));
  var re = [];
  re.push(write_props_xlml(le, Y)), re.push(write_wb_xlml(le)), re.push(""), re.push(write_names_xlml(le));
  for (var oe = 0; oe < le.SheetNames.length; ++oe)
    re.push(writextag("Worksheet", write_ws_xlml(oe, Y, le), { "ss:Name": escapexml(le.SheetNames[oe]) }));
  return re[2] = write_sty_xlml(le, Y), XML_HEADER + writextag("Workbook", re.join(""), {
    xmlns: XLMLNS.ss,
    "xmlns:o": XLMLNS.o,
    "xmlns:x": XLMLNS.x,
    "xmlns:ss": XLMLNS.ss,
    "xmlns:dt": XLMLNS.dt,
    "xmlns:html": XLMLNS.html
  });
}
function parse_compobj(le) {
  var Y = {}, re = le.content;
  if (re.l = 28, Y.AnsiUserType = re.read_shift(0, "lpstr-ansi"), Y.AnsiClipboardFormat = parse_ClipboardFormatOrAnsiString(re), re.length - re.l <= 4) return Y;
  var oe = re.read_shift(4);
  if (oe == 0 || oe > 40 || (re.l -= 4, Y.Reserved1 = re.read_shift(0, "lpstr-ansi"), re.length - re.l <= 4) || (oe = re.read_shift(4), oe !== 1907505652) || (Y.UnicodeClipboardFormat = parse_ClipboardFormatOrUnicodeString(re), oe = re.read_shift(4), oe == 0 || oe > 40)) return Y;
  re.l -= 4, Y.Reserved2 = re.read_shift(0, "lpwstr");
}
var CONTINUE_RT = [60, 1084, 2066, 2165, 2175];
function slurp(le, Y, re, oe, ue) {
  var fe = oe, he = [], _e = re.slice(re.l, re.l + fe);
  if (ue && ue.enc && ue.enc.insitu && _e.length > 0) switch (le) {
    case 9:
    case 521:
    case 1033:
    case 2057:
    case 47:
    case 405:
    case 225:
    case 406:
    case 312:
    case 404:
    case 10:
      break;
    case 133:
      break;
    default:
      ue.enc.insitu(_e);
  }
  he.push(_e), re.l += fe;
  for (var ve = __readUInt16LE(re, re.l), xe = XLSRecordEnum[ve], Ee = 0; xe != null && CONTINUE_RT.indexOf(ve) > -1; )
    fe = __readUInt16LE(re, re.l + 2), Ee = re.l + 4, ve == 2066 ? Ee += 4 : (ve == 2165 || ve == 2175) && (Ee += 12), _e = re.slice(Ee, re.l + 4 + fe), he.push(_e), re.l += 4 + fe, xe = XLSRecordEnum[ve = __readUInt16LE(re, re.l)];
  var Se = bconcat(he);
  prep_blob(Se, 0);
  var Te = 0;
  Se.lens = [];
  for (var Ce = 0; Ce < he.length; ++Ce)
    Se.lens.push(Te), Te += he[Ce].length;
  if (Se.length < oe) throw "XLS Record 0x" + le.toString(16) + " Truncated: " + Se.length + " < " + oe;
  return Y.f(Se, Se.length, ue);
}
function safe_format_xf(le, Y, re) {
  if (le.t !== "z" && le.XF) {
    var oe = 0;
    try {
      oe = le.z || le.XF.numFmtId || 0, Y.cellNF && le.z == null && (le.z = table_fmt[oe]);
    } catch (fe) {
      if (Y.WTF) throw fe;
    }
    if (!Y || Y.cellText !== !1) try {
      le.t === "e" ? le.w = le.w || BErr[le.v] : oe === 0 || oe == "General" ? le.t === "n" ? (le.v | 0) === le.v ? le.w = le.v.toString(10) : le.w = SSF_general_num(le.v) : le.w = SSF_general(le.v) : le.w = SSF_format(oe, le.v, { date1904: !!re, dateNF: Y && Y.dateNF });
    } catch (fe) {
      if (Y.WTF) throw fe;
    }
    if (Y.cellDates && oe && le.t == "n" && fmt_is_date(table_fmt[oe] || String(oe))) {
      var ue = SSF_parse_date_code(le.v + (re ? 1462 : 0));
      ue && (le.t = "d", le.v = new Date(Date.UTC(ue.y, ue.m - 1, ue.d, ue.H, ue.M, ue.S, ue.u)));
    }
  }
}
function make_cell(le, Y, re) {
  return { v: le, ixfe: Y, t: re };
}
function parse_workbook(le, Y) {
  var re = { opts: {} }, oe = {}, ue = {};
  Y.dense && (ue["!data"] = []);
  var fe = {}, he = {}, _e = null, ve = [], xe = "", Ee = {}, Se, Te = "", Ce, Ie, Ne, Re, Ae = {}, Pe = [], Fe, Le, He = [], Ge = [], Ve = { Sheets: [], WBProps: { date1904: !1 }, Views: [{}] }, $e = {}, De = !1, Ke = function(ft) {
    return ft < 8 ? XLSIcv[ft] : ft < 64 && Ge[ft - 8] || XLSIcv[ft];
  }, ze = function(ft, Et) {
    var Lt = ft.XF.data;
    if (!(!Lt || !Lt.patternType || !Et || !Et.cellStyles)) {
      ft.s = {}, ft.s.patternType = Lt.patternType;
      var Kt;
      (Kt = rgb2Hex(Ke(Lt.icvFore))) && (ft.s.fgColor = { rgb: Kt }), (Kt = rgb2Hex(Ke(Lt.icvBack))) && (ft.s.bgColor = { rgb: Kt });
    }
  }, tt = function(ft, Et, Lt) {
    if (!(!De && wt > 1) && !(Lt.sheetRows && ft.r >= Lt.sheetRows)) {
      if (Lt.cellStyles && Et.XF && Et.XF.data && ze(Et, Lt), delete Et.ixfe, delete Et.XF, Se = ft, Te = encode_cell(ft), (!he || !he.s || !he.e) && (he = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }), ft.r < he.s.r && (he.s.r = ft.r), ft.c < he.s.c && (he.s.c = ft.c), ft.r + 1 > he.e.r && (he.e.r = ft.r + 1), ft.c + 1 > he.e.c && (he.e.c = ft.c + 1), Lt.cellFormula && Et.f) {
        for (var Kt = 0; Kt < Pe.length; ++Kt)
          if (!(Pe[Kt][0].s.c > ft.c || Pe[Kt][0].s.r > ft.r) && !(Pe[Kt][0].e.c < ft.c || Pe[Kt][0].e.r < ft.r)) {
            Et.F = encode_range(Pe[Kt][0]), (Pe[Kt][0].s.c != ft.c || Pe[Kt][0].s.r != ft.r) && delete Et.f, Et.f && (Et.f = "" + stringify_formula(Pe[Kt][1], he, ft, Ze, Xe));
            break;
          }
      }
      Lt.dense ? (ue["!data"][ft.r] || (ue["!data"][ft.r] = []), ue["!data"][ft.r][ft.c] = Et) : ue[Te] = Et;
    }
  }, Xe = {
    enc: !1,
    // encrypted
    sbcch: 0,
    // cch in the preceding SupBook
    snames: [],
    // sheetnames
    sharedf: Ae,
    // shared formulae by address
    arrayf: Pe,
    // array formulae array
    rrtabid: [],
    // RRTabId
    lastuser: "",
    // Last User from WriteAccess
    biff: 8,
    // BIFF version
    codepage: 0,
    // CP from CodePage record
    winlocked: 0,
    // fLockWn from WinProtect
    cellStyles: !!Y && !!Y.cellStyles,
    WTF: !!Y && !!Y.wtf
  };
  Y.password && (Xe.password = Y.password);
  var mt, at = [], qe = [], st = [], xt = [], gt = !1, Ze = [];
  Ze.SheetNames = Xe.snames, Ze.sharedf = Xe.sharedf, Ze.arrayf = Xe.arrayf, Ze.names = [], Ze.XTI = [];
  var _t = 0, wt = 0, yt = 0, St = [], It = [], Bt;
  Xe.codepage = 1200, set_cp(1200);
  for (var Ye = !1; le.l < le.length - 1; ) {
    var Be = le.l, et = le.read_shift(2);
    if (et === 0 && _t === 10) break;
    var je = le.l === le.length ? 0 : le.read_shift(2), it = XLSRecordEnum[et];
    if (wt == 0 && [9, 521, 1033, 2057].indexOf(et) == -1) break;
    if (it && it.f) {
      if (Y.bookSheets && _t === 133 && et !== 133)
        break;
      if (_t = et, it.r === 2 || it.r == 12) {
        var bt = le.read_shift(2);
        if (je -= 2, !Xe.enc && bt !== et && ((bt & 255) << 8 | bt >> 8) !== et) throw new Error("rt mismatch: " + bt + "!=" + et);
        it.r == 12 && (le.l += 10, je -= 10);
      }
      var rt = {};
      if (et === 10 ? rt = /*::(*/
      it.f(le, je, Xe) : rt = /*::(*/
      slurp(et, it, le, je, Xe), wt == 0 && [9, 521, 1033, 2057].indexOf(_t) === -1) continue;
      switch (et) {
        case 34:
          re.opts.Date1904 = Ve.WBProps.date1904 = rt;
          break;
        case 134:
          re.opts.WriteProtect = !0;
          break;
        case 47:
          if (Xe.enc || (le.l = 0), Xe.enc = rt, !Y.password) throw new Error("File is password-protected");
          if (rt.valid == null) throw new Error("Encryption scheme unsupported");
          if (!rt.valid) throw new Error("Password is incorrect");
          break;
        case 92:
          Xe.lastuser = rt;
          break;
        case 66:
          var Ct = Number(rt);
          switch (Ct) {
            case 21010:
              Ct = 1200;
              break;
            case 32768:
              Ct = 1e4;
              break;
            case 32769:
              Ct = 1252;
              break;
          }
          set_cp(Xe.codepage = Ct), Ye = !0;
          break;
        case 317:
          Xe.rrtabid = rt;
          break;
        case 25:
          Xe.winlocked = rt;
          break;
        case 439:
          re.opts.RefreshAll = rt;
          break;
        case 12:
          re.opts.CalcCount = rt;
          break;
        case 16:
          re.opts.CalcDelta = rt;
          break;
        case 17:
          re.opts.CalcIter = rt;
          break;
        case 13:
          re.opts.CalcMode = rt;
          break;
        case 14:
          re.opts.CalcPrecision = rt;
          break;
        case 95:
          re.opts.CalcSaveRecalc = rt;
          break;
        case 15:
          Xe.CalcRefMode = rt;
          break;
        // TODO: implement R1C1
        case 2211:
          re.opts.FullCalc = rt;
          break;
        case 129:
          rt.fDialog && (ue["!type"] = "dialog"), rt.fBelow || ((ue["!outline"] || (ue["!outline"] = {})).above = !0), rt.fRight || ((ue["!outline"] || (ue["!outline"] = {})).left = !0);
          break;
        // TODO
        case 67:
        /* BIFF2XF */
        case 579:
        /* BIFF3XF */
        case 1091:
        /* BIFF4XF */
        case 224:
          He.push(rt);
          break;
        case 430:
          Ze.push([rt]), Ze[Ze.length - 1].XTI = [];
          break;
        case 35:
        case 547:
          Ze[Ze.length - 1].push(rt);
          break;
        case 24:
        case 536:
          Bt = {
            Name: rt.Name,
            Ref: stringify_formula(rt.rgce, he, null, Ze, Xe)
          }, rt.itab > 0 && (Bt.Sheet = rt.itab - 1), Ze.names.push(Bt), Ze[0] || (Ze[0] = [], Ze[0].XTI = []), Ze[Ze.length - 1].push(rt), rt.Name == "_xlnm._FilterDatabase" && rt.itab > 0 && rt.rgce && rt.rgce[0] && rt.rgce[0][0] && rt.rgce[0][0][0] == "PtgArea3d" && (It[rt.itab - 1] = { ref: encode_range(rt.rgce[0][0][1][2]) });
          break;
        case 22:
          Xe.ExternCount = rt;
          break;
        case 23:
          Ze.length == 0 && (Ze[0] = [], Ze[0].XTI = []), Ze[Ze.length - 1].XTI = Ze[Ze.length - 1].XTI.concat(rt), Ze.XTI = Ze.XTI.concat(rt);
          break;
        case 2196:
          if (Xe.biff < 8) break;
          Bt != null && (Bt.Comment = rt[1]);
          break;
        case 18:
          ue["!protect"] = rt;
          break;
        /* for sheet or book */
        case 19:
          rt !== 0 && Xe.WTF && console.error("Password verifier: " + rt);
          break;
        case 133:
          fe[Xe.biff == 4 ? Xe.snames.length : rt.pos] = rt, Xe.snames.push(rt.name);
          break;
        case 10:
          {
            if (--wt ? !De : De) break;
            if (he.e) {
              if (he.e.r > 0 && he.e.c > 0) {
                if (he.e.r--, he.e.c--, ue["!ref"] = encode_range(he), Y.sheetRows && Y.sheetRows <= he.e.r) {
                  var Rt = he.e.r;
                  he.e.r = Y.sheetRows - 1, ue["!fullref"] = ue["!ref"], ue["!ref"] = encode_range(he), he.e.r = Rt;
                }
                he.e.r++, he.e.c++;
              }
              at.length > 0 && (ue["!merges"] = at), qe.length > 0 && (ue["!objects"] = qe), st.length > 0 && (ue["!cols"] = st), xt.length > 0 && (ue["!rows"] = xt), Ve.Sheets.push($e);
            }
            xe === "" ? Ee = ue : oe[xe] = ue, ue = {}, Y.dense && (ue["!data"] = []);
          }
          break;
        case 9:
        case 521:
        case 1033:
        case 2057:
          {
            if (Xe.biff === 8 && (Xe.biff = {
              9: 2,
              521: 3,
              1033: 4
            }[et] || {
              512: 2,
              768: 3,
              1024: 4,
              1280: 5,
              1536: 8,
              2: 2,
              7: 2
            }[rt.BIFFVer] || 8), Xe.biffguess = rt.BIFFVer == 0, rt.BIFFVer == 0 && rt.dt == 4096 && (Xe.biff = 5, Ye = !0, set_cp(Xe.codepage = 28591)), Xe.biff == 4 && rt.dt & 256 && (De = !0), Xe.biff == 8 && rt.BIFFVer == 0 && rt.dt == 16 && (Xe.biff = 2), wt++ && !De) break;
            if (ue = {}, Y.dense && (ue["!data"] = []), Xe.biff < 8 && !Ye && (Ye = !0, set_cp(Xe.codepage = Y.codepage || 1252)), Xe.biff == 4 && De)
              xe = (fe[Xe.snames.indexOf(xe) + 1] || { name: "" }).name;
            else if (Xe.biff < 5 || rt.BIFFVer == 0 && rt.dt == 4096) {
              xe === "" && (xe = "Sheet1"), he = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              var Ot = { pos: le.l - je, name: xe };
              fe[Ot.pos] = Ot, Xe.snames.push(xe);
            } else xe = (fe[Be] || { name: "" }).name;
            rt.dt == 32 && (ue["!type"] = "chart"), rt.dt == 64 && (ue["!type"] = "macro"), at = [], qe = [], Xe.arrayf = Pe = [], st = [], xt = [], gt = !1, $e = { Hidden: (fe[Be] || { hs: 0 }).hs, name: xe };
          }
          break;
        case 515:
        case 3:
        case 2:
          ue["!type"] == "chart" && (Y.dense ? (ue["!data"][rt.r] || [])[rt.c] : ue[encode_col(rt.c) + encode_row(rt.r)]) && ++rt.c, Fe = { ixfe: rt.ixfe, XF: He[rt.ixfe] || {}, v: rt.val, t: "n" }, yt > 0 && (Fe.z = Fe.XF && Fe.XF.numFmtId && St[Fe.XF.numFmtId] || St[Fe.ixfe >> 8 & 63]), safe_format_xf(Fe, Y, re.opts.Date1904), tt({ c: rt.c, r: rt.r }, Fe, Y);
          break;
        case 5:
        case 517:
          Fe = { ixfe: rt.ixfe, XF: He[rt.ixfe], v: rt.val, t: rt.t }, yt > 0 && (Fe.z = Fe.XF && Fe.XF.numFmtId && St[Fe.XF.numFmtId] || St[Fe.ixfe >> 8 & 63]), safe_format_xf(Fe, Y, re.opts.Date1904), tt({ c: rt.c, r: rt.r }, Fe, Y);
          break;
        case 638:
          Fe = { ixfe: rt.ixfe, XF: He[rt.ixfe], v: rt.rknum, t: "n" }, yt > 0 && (Fe.z = Fe.XF && Fe.XF.numFmtId && St[Fe.XF.numFmtId] || St[Fe.ixfe >> 8 & 63]), safe_format_xf(Fe, Y, re.opts.Date1904), tt({ c: rt.c, r: rt.r }, Fe, Y);
          break;
        case 189:
          for (var Mt = rt.c; Mt <= rt.C; ++Mt) {
            var Dt = rt.rkrec[Mt - rt.c][0];
            Fe = { ixfe: Dt, XF: He[Dt], v: rt.rkrec[Mt - rt.c][1], t: "n" }, yt > 0 && (Fe.z = Fe.XF && Fe.XF.numFmtId && St[Fe.XF.numFmtId] || St[Fe.ixfe >> 8 & 63]), safe_format_xf(Fe, Y, re.opts.Date1904), tt({ c: Mt, r: rt.r }, Fe, Y);
          }
          break;
        case 6:
        case 518:
        case 1030:
          {
            if (rt.val == "String") {
              _e = rt;
              break;
            }
            if (Fe = make_cell(rt.val, rt.cell.ixfe, rt.tt), Fe.XF = He[Fe.ixfe], Y.cellFormula) {
              var Vt = rt.formula;
              if (Vt && Vt[0] && Vt[0][0] && Vt[0][0][0] == "PtgExp") {
                var Jt = Vt[0][0][1][0], er = Vt[0][0][1][1], Zt = encode_cell({ r: Jt, c: er });
                Ae[Zt] ? Fe.f = "" + stringify_formula(rt.formula, he, rt.cell, Ze, Xe) : Fe.F = ((Y.dense ? (ue["!data"][Jt] || [])[er] : ue[Zt]) || {}).F;
              } else Fe.f = "" + stringify_formula(rt.formula, he, rt.cell, Ze, Xe);
            }
            yt > 0 && (Fe.z = Fe.XF && Fe.XF.numFmtId && St[Fe.XF.numFmtId] || St[Fe.ixfe >> 8 & 63]), safe_format_xf(Fe, Y, re.opts.Date1904), tt(rt.cell, Fe, Y), _e = rt;
          }
          break;
        case 7:
        case 519:
          if (_e)
            _e.val = rt, Fe = make_cell(rt, _e.cell.ixfe, "s"), Fe.XF = He[Fe.ixfe], Y.cellFormula && (Fe.f = "" + stringify_formula(_e.formula, he, _e.cell, Ze, Xe)), yt > 0 && (Fe.z = Fe.XF && Fe.XF.numFmtId && St[Fe.XF.numFmtId] || St[Fe.ixfe >> 8 & 63]), safe_format_xf(Fe, Y, re.opts.Date1904), tt(_e.cell, Fe, Y), _e = null;
          else throw new Error("String record expects Formula");
          break;
        case 33:
        case 545:
          {
            Pe.push(rt);
            var Gt = encode_cell(rt[0].s);
            if (Ce = Y.dense ? (ue["!data"][rt[0].s.r] || [])[rt[0].s.c] : ue[Gt], Y.cellFormula && Ce) {
              if (!_e || !Gt || !Ce) break;
              Ce.f = "" + stringify_formula(rt[1], he, rt[0], Ze, Xe), Ce.F = encode_range(rt[0]);
            }
          }
          break;
        case 1212:
          {
            if (!Y.cellFormula) break;
            if (Te) {
              if (!_e) break;
              Ae[encode_cell(_e.cell)] = rt[0], Ce = Y.dense ? (ue["!data"][_e.cell.r] || [])[_e.cell.c] : ue[encode_cell(_e.cell)], (Ce || {}).f = "" + stringify_formula(rt[0], he, Se, Ze, Xe);
            }
          }
          break;
        case 253:
          Fe = make_cell(ve[rt.isst].t, rt.ixfe, "s"), ve[rt.isst].h && (Fe.h = ve[rt.isst].h), Fe.XF = He[Fe.ixfe], yt > 0 && (Fe.z = Fe.XF && Fe.XF.numFmtId && St[Fe.XF.numFmtId] || St[Fe.ixfe >> 8 & 63]), safe_format_xf(Fe, Y, re.opts.Date1904), tt({ c: rt.c, r: rt.r }, Fe, Y);
          break;
        case 513:
          Y.sheetStubs && (Fe = { ixfe: rt.ixfe, XF: He[rt.ixfe], t: "z" }, yt > 0 && (Fe.z = Fe.XF && Fe.XF.numFmtId && St[Fe.XF.numFmtId] || St[Fe.ixfe >> 8 & 63]), safe_format_xf(Fe, Y, re.opts.Date1904), tt({ c: rt.c, r: rt.r }, Fe, Y));
          break;
        case 190:
          if (Y.sheetStubs)
            for (var Yt = rt.c; Yt <= rt.C; ++Yt) {
              var $t = rt.ixfe[Yt - rt.c];
              Fe = { ixfe: $t, XF: He[$t], t: "z" }, yt > 0 && (Fe.z = Fe.XF && Fe.XF.numFmtId && St[Fe.XF.numFmtId] || St[Fe.ixfe >> 8 & 63]), safe_format_xf(Fe, Y, re.opts.Date1904), tt({ c: Yt, r: rt.r }, Fe, Y);
            }
          break;
        case 214:
        case 516:
        case 4:
          Fe = make_cell(rt.val, rt.ixfe, "s"), Fe.XF = He[Fe.ixfe], yt > 0 && (Fe.z = Fe.XF && Fe.XF.numFmtId && St[Fe.XF.numFmtId] || St[Fe.ixfe >> 8 & 63]), safe_format_xf(Fe, Y, re.opts.Date1904), tt({ c: rt.c, r: rt.r }, Fe, Y);
          break;
        case 0:
        case 512:
          wt === 1 && (he = rt);
          break;
        case 252:
          ve = rt;
          break;
        case 1054:
          if (Xe.biff >= 3 && Xe.biff <= 4) {
            St[yt++] = rt[1];
            for (var ir = 0; ir < yt + 163 && table_fmt[ir] != rt[1]; ++ir) ;
            ir >= 163 && SSF__load(rt[1], yt + 163);
          } else SSF__load(rt[1], rt[0]);
          break;
        case 30:
          {
            St[yt++] = rt;
            for (var Je = 0; Je < yt + 163 && table_fmt[Je] != rt; ++Je) ;
            Je >= 163 && SSF__load(rt, yt + 163);
          }
          break;
        case 229:
          at = at.concat(rt);
          break;
        case 93:
          qe[rt.cmo[0]] = Xe.lastobj = rt;
          break;
        case 438:
          Xe.lastobj.TxO = rt;
          break;
        case 127:
          Xe.lastobj.ImData = rt;
          break;
        case 440:
          for (Re = rt[0].s.r; Re <= rt[0].e.r; ++Re)
            for (Ne = rt[0].s.c; Ne <= rt[0].e.c; ++Ne)
              Ce = Y.dense ? (ue["!data"][Re] || [])[Ne] : ue[encode_cell({ c: Ne, r: Re })], Ce && (Ce.l = rt[1]);
          break;
        case 2048:
          for (Re = rt[0].s.r; Re <= rt[0].e.r; ++Re)
            for (Ne = rt[0].s.c; Ne <= rt[0].e.c; ++Ne)
              Ce = Y.dense ? (ue["!data"][Re] || [])[Ne] : ue[encode_cell({ c: Ne, r: Re })], Ce && Ce.l && (Ce.l.Tooltip = rt[1]);
          break;
        case 28:
          {
            if (Ce = Y.dense ? (ue["!data"][rt[0].r] || [])[rt[0].c] : ue[encode_cell(rt[0])], Ce || (Y.dense ? (ue["!data"][rt[0].r] || (ue["!data"][rt[0].r] = []), Ce = ue["!data"][rt[0].r][rt[0].c] = { t: "z" }) : Ce = ue[encode_cell(rt[0])] = { t: "z" }, he.e.r = Math.max(he.e.r, rt[0].r), he.s.r = Math.min(he.s.r, rt[0].r), he.e.c = Math.max(he.e.c, rt[0].c), he.s.c = Math.min(he.s.c, rt[0].c)), Ce.c || (Ce.c = []), Xe.biff <= 5 && Xe.biff >= 2) Ie = { a: "SheetJ5", t: rt[1] };
            else {
              var Ue = qe[rt[2]];
              Ie = { a: rt[1], t: Ue.TxO.t }, rt[3] != null && !(rt[3] & 2) && (Ce.c.hidden = !0);
            }
            Ce.c.push(Ie);
          }
          break;
        case 2173:
          update_xfext(He[rt.ixfe], rt.ext);
          break;
        case 125:
          {
            if (!Xe.cellStyles) break;
            for (; rt.e >= rt.s; )
              st[rt.e--] = { width: rt.w / 256, level: rt.level || 0, hidden: !!(rt.flags & 1) }, gt || (gt = !0, find_mdw_colw(rt.w / 256)), process_col(st[rt.e + 1]);
          }
          break;
        case 520:
          {
            var We = {};
            rt.level != null && (xt[rt.r] = We, We.level = rt.level), rt.hidden && (xt[rt.r] = We, We.hidden = !0), rt.hpt && (xt[rt.r] = We, We.hpt = rt.hpt, We.hpx = pt2px(rt.hpt));
          }
          break;
        case 38:
        case 39:
        case 40:
        case 41:
          ue["!margins"] || default_margins(ue["!margins"] = {}), ue["!margins"][{ 38: "left", 39: "right", 40: "top", 41: "bottom" }[et]] = rt;
          break;
        case 161:
          ue["!margins"] || default_margins(ue["!margins"] = {}), ue["!margins"].header = rt.header, ue["!margins"].footer = rt.footer;
          break;
        case 574:
          rt.RTL && (Ve.Views[0].RTL = !0);
          break;
        case 146:
          Ge = rt;
          break;
        case 2198:
          mt = rt;
          break;
        case 140:
          Le = rt;
          break;
        case 442:
          xe ? $e.CodeName = rt || $e.name : Ve.WBProps.CodeName = rt || "ThisWorkbook";
          break;
      }
    } else
      it || console.error("Missing Info for XLS Record 0x" + et.toString(16)), le.l += je;
  }
  return re.SheetNames = keys(fe).sort(function(lt, ft) {
    return Number(lt) - Number(ft);
  }).map(function(lt) {
    return fe[lt].name;
  }), Y.bookSheets || (re.Sheets = oe), !re.SheetNames.length && Ee["!ref"] ? (re.SheetNames.push("Sheet1"), re.Sheets && (re.Sheets.Sheet1 = Ee)) : re.Preamble = Ee, re.Sheets && It.forEach(function(lt, ft) {
    re.Sheets[re.SheetNames[ft]]["!autofilter"] = lt;
  }), re.Strings = ve, re.SSF = dup(table_fmt), Xe.enc && (re.Encryption = Xe.enc), mt && (re.Themes = mt), re.Metadata = {}, Le !== void 0 && (re.Metadata.Country = Le), Ze.names.length > 0 && (Ve.Names = Ze.names), re.Workbook = Ve, re;
}
var PSCLSID = {
  SI: "e0859ff2f94f6810ab9108002b27b3d9",
  DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
  UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
};
function parse_xls_props(le, Y, re) {
  var oe = CFB.find(le, "/!DocumentSummaryInformation");
  if (oe && oe.size > 0) try {
    var ue = parse_PropertySetStream(oe, DocSummaryPIDDSI, PSCLSID.DSI);
    for (var fe in ue) Y[fe] = ue[fe];
  } catch (xe) {
    if (re.WTF) throw xe;
  }
  var he = CFB.find(le, "/!SummaryInformation");
  if (he && he.size > 0) try {
    var _e = parse_PropertySetStream(he, SummaryPIDSI, PSCLSID.SI);
    for (var ve in _e) Y[ve] == null && (Y[ve] = _e[ve]);
  } catch (xe) {
    if (re.WTF) throw xe;
  }
  Y.HeadingPairs && Y.TitlesOfParts && (load_props_pairs(Y.HeadingPairs, Y.TitlesOfParts, Y, re), delete Y.HeadingPairs, delete Y.TitlesOfParts);
}
function write_xls_props(le, Y) {
  var re = [], oe = [], ue = [], fe = 0, he, _e = evert_key(DocSummaryPIDDSI, "n"), ve = evert_key(SummaryPIDSI, "n");
  if (le.Props)
    for (he = keys(le.Props), fe = 0; fe < he.length; ++fe) (Object.prototype.hasOwnProperty.call(_e, he[fe]) ? re : Object.prototype.hasOwnProperty.call(ve, he[fe]) ? oe : ue).push([he[fe], le.Props[he[fe]]]);
  if (le.Custprops)
    for (he = keys(le.Custprops), fe = 0; fe < he.length; ++fe) Object.prototype.hasOwnProperty.call(le.Props || {}, he[fe]) || (Object.prototype.hasOwnProperty.call(_e, he[fe]) ? re : Object.prototype.hasOwnProperty.call(ve, he[fe]) ? oe : ue).push([he[fe], le.Custprops[he[fe]]]);
  var xe = [];
  for (fe = 0; fe < ue.length; ++fe)
    XLSPSSkip.indexOf(ue[fe][0]) > -1 || PseudoPropsPairs.indexOf(ue[fe][0]) > -1 || ue[fe][1] != null && xe.push(ue[fe]);
  oe.length && CFB.utils.cfb_add(Y, "/SummaryInformation", write_PropertySetStream(oe, PSCLSID.SI, ve, SummaryPIDSI)), (re.length || xe.length) && CFB.utils.cfb_add(Y, "/DocumentSummaryInformation", write_PropertySetStream(re, PSCLSID.DSI, _e, DocSummaryPIDDSI, xe.length ? xe : null, PSCLSID.UDI));
}
function parse_xlscfb(le, Y) {
  Y || (Y = {}), fix_read_opts(Y), reset_cp(), Y.codepage && set_ansi(Y.codepage);
  var re, oe;
  if (le.FullPaths) {
    if (CFB.find(le, "/encryption")) throw new Error("File is password-protected");
    re = CFB.find(le, "!CompObj"), oe = CFB.find(le, "/Workbook") || CFB.find(le, "/Book");
  } else {
    switch (Y.type) {
      case "base64":
        le = s2a(Base64_decode(le));
        break;
      case "binary":
        le = s2a(le);
        break;
      case "buffer":
        break;
      case "array":
        Array.isArray(le) || (le = Array.prototype.slice.call(le));
        break;
    }
    prep_blob(le, 0), oe = { content: le };
  }
  var ue, fe;
  if (re && parse_compobj(re), Y.bookProps && !Y.bookSheets) ue = {};
  else {
    var he = has_buf ? "buffer" : "array";
    if (oe && oe.content) ue = parse_workbook(oe.content, Y);
    else if ((fe = CFB.find(le, "PerfectOffice_MAIN")) && fe.content) ue = WK_.to_workbook(fe.content, (Y.type = he, Y));
    else if ((fe = CFB.find(le, "NativeContent_MAIN")) && fe.content) ue = WK_.to_workbook(fe.content, (Y.type = he, Y));
    else throw (fe = CFB.find(le, "MN0")) && fe.content ? new Error("Unsupported Works 4 for Mac file") : new Error("Cannot find Workbook stream");
    Y.bookVBA && le.FullPaths && CFB.find(le, "/_VBA_PROJECT_CUR/VBA/dir") && (ue.vbaraw = make_vba_xls(le));
  }
  var _e = {};
  return le.FullPaths && parse_xls_props(
    /*::((*/
    le,
    _e,
    Y
  ), ue.Props = ue.Custprops = _e, Y.bookFiles && (ue.cfb = le), ue;
}
function write_xlscfb(le, Y) {
  var re = Y || {}, oe = CFB.utils.cfb_new({ root: "R" }), ue = "/Workbook";
  switch (re.bookType || "xls") {
    case "xls":
      re.bookType = "biff8";
    /* falls through */
    case "xla":
      re.bookType || (re.bookType = "xla");
    /* falls through */
    case "biff8":
      ue = "/Workbook", re.biff = 8;
      break;
    case "biff5":
      ue = "/Book", re.biff = 5;
      break;
    default:
      throw new Error("invalid type " + re.bookType + " for XLS CFB");
  }
  return CFB.utils.cfb_add(oe, ue, write_biff_buf(le, re)), re.biff == 8 && (le.Props || le.Custprops) && write_xls_props(le, oe), re.biff == 8 && le.vbaraw && fill_vba_xls(oe, CFB.read(le.vbaraw, { type: typeof le.vbaraw == "string" ? "binary" : "buffer" })), oe;
}
var XLSBRecordEnum = {
  0: {
    /* n:"BrtRowHdr", */
    f: parse_BrtRowHdr
  },
  1: {
    /* n:"BrtCellBlank", */
    f: parse_BrtCellBlank
  },
  2: {
    /* n:"BrtCellRk", */
    f: parse_BrtCellRk
  },
  3: {
    /* n:"BrtCellError", */
    f: parse_BrtCellError
  },
  4: {
    /* n:"BrtCellBool", */
    f: parse_BrtCellBool
  },
  5: {
    /* n:"BrtCellReal", */
    f: parse_BrtCellReal
  },
  6: {
    /* n:"BrtCellSt", */
    f: parse_BrtCellSt
  },
  7: {
    /* n:"BrtCellIsst", */
    f: parse_BrtCellIsst
  },
  8: {
    /* n:"BrtFmlaString", */
    f: parse_BrtFmlaString
  },
  9: {
    /* n:"BrtFmlaNum", */
    f: parse_BrtFmlaNum
  },
  10: {
    /* n:"BrtFmlaBool", */
    f: parse_BrtFmlaBool
  },
  11: {
    /* n:"BrtFmlaError", */
    f: parse_BrtFmlaError
  },
  12: {
    /* n:"BrtShortBlank", */
    f: parse_BrtShortBlank
  },
  13: {
    /* n:"BrtShortRk", */
    f: parse_BrtShortRk
  },
  14: {
    /* n:"BrtShortError", */
    f: parse_BrtShortError
  },
  15: {
    /* n:"BrtShortBool", */
    f: parse_BrtShortBool
  },
  16: {
    /* n:"BrtShortReal", */
    f: parse_BrtShortReal
  },
  17: {
    /* n:"BrtShortSt", */
    f: parse_BrtShortSt
  },
  18: {
    /* n:"BrtShortIsst", */
    f: parse_BrtShortIsst
  },
  19: {
    /* n:"BrtSSTItem", */
    f: parse_RichStr
  },
  20: {
    /* n:"BrtPCDIMissing" */
  },
  21: {
    /* n:"BrtPCDINumber" */
  },
  22: {
    /* n:"BrtPCDIBoolean" */
  },
  23: {
    /* n:"BrtPCDIError" */
  },
  24: {
    /* n:"BrtPCDIString" */
  },
  25: {
    /* n:"BrtPCDIDatetime" */
  },
  26: {
    /* n:"BrtPCDIIndex" */
  },
  27: {
    /* n:"BrtPCDIAMissing" */
  },
  28: {
    /* n:"BrtPCDIANumber" */
  },
  29: {
    /* n:"BrtPCDIABoolean" */
  },
  30: {
    /* n:"BrtPCDIAError" */
  },
  31: {
    /* n:"BrtPCDIAString" */
  },
  32: {
    /* n:"BrtPCDIADatetime" */
  },
  33: {
    /* n:"BrtPCRRecord" */
  },
  34: {
    /* n:"BrtPCRRecordDt" */
  },
  35: {
    /* n:"BrtFRTBegin", */
    T: 1
  },
  36: {
    /* n:"BrtFRTEnd", */
    T: -1
  },
  37: {
    /* n:"BrtACBegin", */
    T: 1
  },
  38: {
    /* n:"BrtACEnd", */
    T: -1
  },
  39: {
    /* n:"BrtName", */
    f: parse_BrtName
  },
  40: {
    /* n:"BrtIndexRowBlock" */
  },
  42: {
    /* n:"BrtIndexBlock" */
  },
  43: {
    /* n:"BrtFont", */
    f: parse_BrtFont
  },
  44: {
    /* n:"BrtFmt", */
    f: parse_BrtFmt
  },
  45: {
    /* n:"BrtFill", */
    f: parse_BrtFill
  },
  46: {
    /* n:"BrtBorder", */
    f: parse_BrtBorder
  },
  47: {
    /* n:"BrtXF", */
    f: parse_BrtXF
  },
  48: {
    /* n:"BrtStyle" */
  },
  49: {
    /* n:"BrtCellMeta", */
    f: parse_Int32LE
  },
  50: {
    /* n:"BrtValueMeta" */
  },
  51: {
    /* n:"BrtMdb" */
    f: parse_BrtMdb
  },
  52: {
    /* n:"BrtBeginFmd", */
    T: 1
  },
  53: {
    /* n:"BrtEndFmd", */
    T: -1
  },
  54: {
    /* n:"BrtBeginMdx", */
    T: 1
  },
  55: {
    /* n:"BrtEndMdx", */
    T: -1
  },
  56: {
    /* n:"BrtBeginMdxTuple", */
    T: 1
  },
  57: {
    /* n:"BrtEndMdxTuple", */
    T: -1
  },
  58: {
    /* n:"BrtMdxMbrIstr" */
  },
  59: {
    /* n:"BrtStr" */
  },
  60: {
    /* n:"BrtColInfo", */
    f: parse_ColInfo
  },
  62: {
    /* n:"BrtCellRString", */
    f: parse_BrtCellRString
  },
  63: {
    /* n:"BrtCalcChainItem$", */
    f: parse_BrtCalcChainItem$
  },
  64: {
    /* n:"BrtDVal", */
    f: parse_BrtDVal
  },
  65: {
    /* n:"BrtSxvcellNum" */
  },
  66: {
    /* n:"BrtSxvcellStr" */
  },
  67: {
    /* n:"BrtSxvcellBool" */
  },
  68: {
    /* n:"BrtSxvcellErr" */
  },
  69: {
    /* n:"BrtSxvcellDate" */
  },
  70: {
    /* n:"BrtSxvcellNil" */
  },
  128: {
    /* n:"BrtFileVersion" */
  },
  129: {
    /* n:"BrtBeginSheet", */
    T: 1
  },
  130: {
    /* n:"BrtEndSheet", */
    T: -1
  },
  131: {
    /* n:"BrtBeginBook", */
    T: 1,
    f: parsenoop,
    p: 0
  },
  132: {
    /* n:"BrtEndBook", */
    T: -1
  },
  133: {
    /* n:"BrtBeginWsViews", */
    T: 1
  },
  134: {
    /* n:"BrtEndWsViews", */
    T: -1
  },
  135: {
    /* n:"BrtBeginBookViews", */
    T: 1
  },
  136: {
    /* n:"BrtEndBookViews", */
    T: -1
  },
  137: {
    /* n:"BrtBeginWsView", */
    T: 1,
    f: parse_BrtBeginWsView
  },
  138: {
    /* n:"BrtEndWsView", */
    T: -1
  },
  139: {
    /* n:"BrtBeginCsViews", */
    T: 1
  },
  140: {
    /* n:"BrtEndCsViews", */
    T: -1
  },
  141: {
    /* n:"BrtBeginCsView", */
    T: 1
  },
  142: {
    /* n:"BrtEndCsView", */
    T: -1
  },
  143: {
    /* n:"BrtBeginBundleShs", */
    T: 1
  },
  144: {
    /* n:"BrtEndBundleShs", */
    T: -1
  },
  145: {
    /* n:"BrtBeginSheetData", */
    T: 1
  },
  146: {
    /* n:"BrtEndSheetData", */
    T: -1
  },
  147: {
    /* n:"BrtWsProp", */
    f: parse_BrtWsProp
  },
  148: {
    /* n:"BrtWsDim", */
    f: parse_BrtWsDim,
    p: 16
  },
  151: {
    /* n:"BrtPane", */
    f: parse_BrtPane
  },
  152: {
    /* n:"BrtSel" */
  },
  153: {
    /* n:"BrtWbProp", */
    f: parse_BrtWbProp
  },
  154: {
    /* n:"BrtWbFactoid" */
  },
  155: {
    /* n:"BrtFileRecover" */
  },
  156: {
    /* n:"BrtBundleSh", */
    f: parse_BrtBundleSh
  },
  157: {
    /* n:"BrtCalcProp" */
  },
  158: {
    /* n:"BrtBookView" */
  },
  159: {
    /* n:"BrtBeginSst", */
    T: 1,
    f: parse_BrtBeginSst
  },
  160: {
    /* n:"BrtEndSst", */
    T: -1
  },
  161: {
    /* n:"BrtBeginAFilter", */
    T: 1,
    f: parse_UncheckedRfX
  },
  162: {
    /* n:"BrtEndAFilter", */
    T: -1
  },
  163: {
    /* n:"BrtBeginFilterColumn", */
    T: 1
  },
  164: {
    /* n:"BrtEndFilterColumn", */
    T: -1
  },
  165: {
    /* n:"BrtBeginFilters", */
    T: 1
  },
  166: {
    /* n:"BrtEndFilters", */
    T: -1
  },
  167: {
    /* n:"BrtFilter" */
  },
  168: {
    /* n:"BrtColorFilter" */
  },
  169: {
    /* n:"BrtIconFilter" */
  },
  170: {
    /* n:"BrtTop10Filter" */
  },
  171: {
    /* n:"BrtDynamicFilter" */
  },
  172: {
    /* n:"BrtBeginCustomFilters", */
    T: 1
  },
  173: {
    /* n:"BrtEndCustomFilters", */
    T: -1
  },
  174: {
    /* n:"BrtCustomFilter" */
  },
  175: {
    /* n:"BrtAFilterDateGroupItem" */
  },
  176: {
    /* n:"BrtMergeCell", */
    f: parse_BrtMergeCell
  },
  177: {
    /* n:"BrtBeginMergeCells", */
    T: 1
  },
  178: {
    /* n:"BrtEndMergeCells", */
    T: -1
  },
  179: {
    /* n:"BrtBeginPivotCacheDef", */
    T: 1
  },
  180: {
    /* n:"BrtEndPivotCacheDef", */
    T: -1
  },
  181: {
    /* n:"BrtBeginPCDFields", */
    T: 1
  },
  182: {
    /* n:"BrtEndPCDFields", */
    T: -1
  },
  183: {
    /* n:"BrtBeginPCDField", */
    T: 1
  },
  184: {
    /* n:"BrtEndPCDField", */
    T: -1
  },
  185: {
    /* n:"BrtBeginPCDSource", */
    T: 1
  },
  186: {
    /* n:"BrtEndPCDSource", */
    T: -1
  },
  187: {
    /* n:"BrtBeginPCDSRange", */
    T: 1
  },
  188: {
    /* n:"BrtEndPCDSRange", */
    T: -1
  },
  189: {
    /* n:"BrtBeginPCDFAtbl", */
    T: 1
  },
  190: {
    /* n:"BrtEndPCDFAtbl", */
    T: -1
  },
  191: {
    /* n:"BrtBeginPCDIRun", */
    T: 1
  },
  192: {
    /* n:"BrtEndPCDIRun", */
    T: -1
  },
  193: {
    /* n:"BrtBeginPivotCacheRecords", */
    T: 1
  },
  194: {
    /* n:"BrtEndPivotCacheRecords", */
    T: -1
  },
  195: {
    /* n:"BrtBeginPCDHierarchies", */
    T: 1
  },
  196: {
    /* n:"BrtEndPCDHierarchies", */
    T: -1
  },
  197: {
    /* n:"BrtBeginPCDHierarchy", */
    T: 1
  },
  198: {
    /* n:"BrtEndPCDHierarchy", */
    T: -1
  },
  199: {
    /* n:"BrtBeginPCDHFieldsUsage", */
    T: 1
  },
  200: {
    /* n:"BrtEndPCDHFieldsUsage", */
    T: -1
  },
  201: {
    /* n:"BrtBeginExtConnection", */
    T: 1
  },
  202: {
    /* n:"BrtEndExtConnection", */
    T: -1
  },
  203: {
    /* n:"BrtBeginECDbProps", */
    T: 1
  },
  204: {
    /* n:"BrtEndECDbProps", */
    T: -1
  },
  205: {
    /* n:"BrtBeginECOlapProps", */
    T: 1
  },
  206: {
    /* n:"BrtEndECOlapProps", */
    T: -1
  },
  207: {
    /* n:"BrtBeginPCDSConsol", */
    T: 1
  },
  208: {
    /* n:"BrtEndPCDSConsol", */
    T: -1
  },
  209: {
    /* n:"BrtBeginPCDSCPages", */
    T: 1
  },
  210: {
    /* n:"BrtEndPCDSCPages", */
    T: -1
  },
  211: {
    /* n:"BrtBeginPCDSCPage", */
    T: 1
  },
  212: {
    /* n:"BrtEndPCDSCPage", */
    T: -1
  },
  213: {
    /* n:"BrtBeginPCDSCPItem", */
    T: 1
  },
  214: {
    /* n:"BrtEndPCDSCPItem", */
    T: -1
  },
  215: {
    /* n:"BrtBeginPCDSCSets", */
    T: 1
  },
  216: {
    /* n:"BrtEndPCDSCSets", */
    T: -1
  },
  217: {
    /* n:"BrtBeginPCDSCSet", */
    T: 1
  },
  218: {
    /* n:"BrtEndPCDSCSet", */
    T: -1
  },
  219: {
    /* n:"BrtBeginPCDFGroup", */
    T: 1
  },
  220: {
    /* n:"BrtEndPCDFGroup", */
    T: -1
  },
  221: {
    /* n:"BrtBeginPCDFGItems", */
    T: 1
  },
  222: {
    /* n:"BrtEndPCDFGItems", */
    T: -1
  },
  223: {
    /* n:"BrtBeginPCDFGRange", */
    T: 1
  },
  224: {
    /* n:"BrtEndPCDFGRange", */
    T: -1
  },
  225: {
    /* n:"BrtBeginPCDFGDiscrete", */
    T: 1
  },
  226: {
    /* n:"BrtEndPCDFGDiscrete", */
    T: -1
  },
  227: {
    /* n:"BrtBeginPCDSDTupleCache", */
    T: 1
  },
  228: {
    /* n:"BrtEndPCDSDTupleCache", */
    T: -1
  },
  229: {
    /* n:"BrtBeginPCDSDTCEntries", */
    T: 1
  },
  230: {
    /* n:"BrtEndPCDSDTCEntries", */
    T: -1
  },
  231: {
    /* n:"BrtBeginPCDSDTCEMembers", */
    T: 1
  },
  232: {
    /* n:"BrtEndPCDSDTCEMembers", */
    T: -1
  },
  233: {
    /* n:"BrtBeginPCDSDTCEMember", */
    T: 1
  },
  234: {
    /* n:"BrtEndPCDSDTCEMember", */
    T: -1
  },
  235: {
    /* n:"BrtBeginPCDSDTCQueries", */
    T: 1
  },
  236: {
    /* n:"BrtEndPCDSDTCQueries", */
    T: -1
  },
  237: {
    /* n:"BrtBeginPCDSDTCQuery", */
    T: 1
  },
  238: {
    /* n:"BrtEndPCDSDTCQuery", */
    T: -1
  },
  239: {
    /* n:"BrtBeginPCDSDTCSets", */
    T: 1
  },
  240: {
    /* n:"BrtEndPCDSDTCSets", */
    T: -1
  },
  241: {
    /* n:"BrtBeginPCDSDTCSet", */
    T: 1
  },
  242: {
    /* n:"BrtEndPCDSDTCSet", */
    T: -1
  },
  243: {
    /* n:"BrtBeginPCDCalcItems", */
    T: 1
  },
  244: {
    /* n:"BrtEndPCDCalcItems", */
    T: -1
  },
  245: {
    /* n:"BrtBeginPCDCalcItem", */
    T: 1
  },
  246: {
    /* n:"BrtEndPCDCalcItem", */
    T: -1
  },
  247: {
    /* n:"BrtBeginPRule", */
    T: 1
  },
  248: {
    /* n:"BrtEndPRule", */
    T: -1
  },
  249: {
    /* n:"BrtBeginPRFilters", */
    T: 1
  },
  250: {
    /* n:"BrtEndPRFilters", */
    T: -1
  },
  251: {
    /* n:"BrtBeginPRFilter", */
    T: 1
  },
  252: {
    /* n:"BrtEndPRFilter", */
    T: -1
  },
  253: {
    /* n:"BrtBeginPNames", */
    T: 1
  },
  254: {
    /* n:"BrtEndPNames", */
    T: -1
  },
  255: {
    /* n:"BrtBeginPName", */
    T: 1
  },
  256: {
    /* n:"BrtEndPName", */
    T: -1
  },
  257: {
    /* n:"BrtBeginPNPairs", */
    T: 1
  },
  258: {
    /* n:"BrtEndPNPairs", */
    T: -1
  },
  259: {
    /* n:"BrtBeginPNPair", */
    T: 1
  },
  260: {
    /* n:"BrtEndPNPair", */
    T: -1
  },
  261: {
    /* n:"BrtBeginECWebProps", */
    T: 1
  },
  262: {
    /* n:"BrtEndECWebProps", */
    T: -1
  },
  263: {
    /* n:"BrtBeginEcWpTables", */
    T: 1
  },
  264: {
    /* n:"BrtEndECWPTables", */
    T: -1
  },
  265: {
    /* n:"BrtBeginECParams", */
    T: 1
  },
  266: {
    /* n:"BrtEndECParams", */
    T: -1
  },
  267: {
    /* n:"BrtBeginECParam", */
    T: 1
  },
  268: {
    /* n:"BrtEndECParam", */
    T: -1
  },
  269: {
    /* n:"BrtBeginPCDKPIs", */
    T: 1
  },
  270: {
    /* n:"BrtEndPCDKPIs", */
    T: -1
  },
  271: {
    /* n:"BrtBeginPCDKPI", */
    T: 1
  },
  272: {
    /* n:"BrtEndPCDKPI", */
    T: -1
  },
  273: {
    /* n:"BrtBeginDims", */
    T: 1
  },
  274: {
    /* n:"BrtEndDims", */
    T: -1
  },
  275: {
    /* n:"BrtBeginDim", */
    T: 1
  },
  276: {
    /* n:"BrtEndDim", */
    T: -1
  },
  277: {
    /* n:"BrtIndexPartEnd" */
  },
  278: {
    /* n:"BrtBeginStyleSheet", */
    T: 1
  },
  279: {
    /* n:"BrtEndStyleSheet", */
    T: -1
  },
  280: {
    /* n:"BrtBeginSXView", */
    T: 1
  },
  281: {
    /* n:"BrtEndSXVI", */
    T: -1
  },
  282: {
    /* n:"BrtBeginSXVI", */
    T: 1
  },
  283: {
    /* n:"BrtBeginSXVIs", */
    T: 1
  },
  284: {
    /* n:"BrtEndSXVIs", */
    T: -1
  },
  285: {
    /* n:"BrtBeginSXVD", */
    T: 1
  },
  286: {
    /* n:"BrtEndSXVD", */
    T: -1
  },
  287: {
    /* n:"BrtBeginSXVDs", */
    T: 1
  },
  288: {
    /* n:"BrtEndSXVDs", */
    T: -1
  },
  289: {
    /* n:"BrtBeginSXPI", */
    T: 1
  },
  290: {
    /* n:"BrtEndSXPI", */
    T: -1
  },
  291: {
    /* n:"BrtBeginSXPIs", */
    T: 1
  },
  292: {
    /* n:"BrtEndSXPIs", */
    T: -1
  },
  293: {
    /* n:"BrtBeginSXDI", */
    T: 1
  },
  294: {
    /* n:"BrtEndSXDI", */
    T: -1
  },
  295: {
    /* n:"BrtBeginSXDIs", */
    T: 1
  },
  296: {
    /* n:"BrtEndSXDIs", */
    T: -1
  },
  297: {
    /* n:"BrtBeginSXLI", */
    T: 1
  },
  298: {
    /* n:"BrtEndSXLI", */
    T: -1
  },
  299: {
    /* n:"BrtBeginSXLIRws", */
    T: 1
  },
  300: {
    /* n:"BrtEndSXLIRws", */
    T: -1
  },
  301: {
    /* n:"BrtBeginSXLICols", */
    T: 1
  },
  302: {
    /* n:"BrtEndSXLICols", */
    T: -1
  },
  303: {
    /* n:"BrtBeginSXFormat", */
    T: 1
  },
  304: {
    /* n:"BrtEndSXFormat", */
    T: -1
  },
  305: {
    /* n:"BrtBeginSXFormats", */
    T: 1
  },
  306: {
    /* n:"BrtEndSxFormats", */
    T: -1
  },
  307: {
    /* n:"BrtBeginSxSelect", */
    T: 1
  },
  308: {
    /* n:"BrtEndSxSelect", */
    T: -1
  },
  309: {
    /* n:"BrtBeginISXVDRws", */
    T: 1
  },
  310: {
    /* n:"BrtEndISXVDRws", */
    T: -1
  },
  311: {
    /* n:"BrtBeginISXVDCols", */
    T: 1
  },
  312: {
    /* n:"BrtEndISXVDCols", */
    T: -1
  },
  313: {
    /* n:"BrtEndSXLocation", */
    T: -1
  },
  314: {
    /* n:"BrtBeginSXLocation", */
    T: 1
  },
  315: {
    /* n:"BrtEndSXView", */
    T: -1
  },
  316: {
    /* n:"BrtBeginSXTHs", */
    T: 1
  },
  317: {
    /* n:"BrtEndSXTHs", */
    T: -1
  },
  318: {
    /* n:"BrtBeginSXTH", */
    T: 1
  },
  319: {
    /* n:"BrtEndSXTH", */
    T: -1
  },
  320: {
    /* n:"BrtBeginISXTHRws", */
    T: 1
  },
  321: {
    /* n:"BrtEndISXTHRws", */
    T: -1
  },
  322: {
    /* n:"BrtBeginISXTHCols", */
    T: 1
  },
  323: {
    /* n:"BrtEndISXTHCols", */
    T: -1
  },
  324: {
    /* n:"BrtBeginSXTDMPS", */
    T: 1
  },
  325: {
    /* n:"BrtEndSXTDMPs", */
    T: -1
  },
  326: {
    /* n:"BrtBeginSXTDMP", */
    T: 1
  },
  327: {
    /* n:"BrtEndSXTDMP", */
    T: -1
  },
  328: {
    /* n:"BrtBeginSXTHItems", */
    T: 1
  },
  329: {
    /* n:"BrtEndSXTHItems", */
    T: -1
  },
  330: {
    /* n:"BrtBeginSXTHItem", */
    T: 1
  },
  331: {
    /* n:"BrtEndSXTHItem", */
    T: -1
  },
  332: {
    /* n:"BrtBeginMetadata", */
    T: 1
  },
  333: {
    /* n:"BrtEndMetadata", */
    T: -1
  },
  334: {
    /* n:"BrtBeginEsmdtinfo", */
    T: 1
  },
  335: {
    /* n:"BrtMdtinfo", */
    f: parse_BrtMdtinfo
  },
  336: {
    /* n:"BrtEndEsmdtinfo", */
    T: -1
  },
  337: {
    /* n:"BrtBeginEsmdb", */
    f: parse_BrtBeginEsmdb,
    T: 1
  },
  338: {
    /* n:"BrtEndEsmdb", */
    T: -1
  },
  339: {
    /* n:"BrtBeginEsfmd", */
    T: 1
  },
  340: {
    /* n:"BrtEndEsfmd", */
    T: -1
  },
  341: {
    /* n:"BrtBeginSingleCells", */
    T: 1
  },
  342: {
    /* n:"BrtEndSingleCells", */
    T: -1
  },
  343: {
    /* n:"BrtBeginList", */
    T: 1
  },
  344: {
    /* n:"BrtEndList", */
    T: -1
  },
  345: {
    /* n:"BrtBeginListCols", */
    T: 1
  },
  346: {
    /* n:"BrtEndListCols", */
    T: -1
  },
  347: {
    /* n:"BrtBeginListCol", */
    T: 1
  },
  348: {
    /* n:"BrtEndListCol", */
    T: -1
  },
  349: {
    /* n:"BrtBeginListXmlCPr", */
    T: 1
  },
  350: {
    /* n:"BrtEndListXmlCPr", */
    T: -1
  },
  351: {
    /* n:"BrtListCCFmla" */
  },
  352: {
    /* n:"BrtListTrFmla" */
  },
  353: {
    /* n:"BrtBeginExternals", */
    T: 1
  },
  354: {
    /* n:"BrtEndExternals", */
    T: -1
  },
  355: {
    /* n:"BrtSupBookSrc", */
    f: parse_RelID
  },
  357: {
    /* n:"BrtSupSelf" */
  },
  358: {
    /* n:"BrtSupSame" */
  },
  359: {
    /* n:"BrtSupTabs" */
  },
  360: {
    /* n:"BrtBeginSupBook", */
    T: 1
  },
  361: {
    /* n:"BrtPlaceholderName" */
  },
  362: {
    /* n:"BrtExternSheet", */
    f: parse_ExternSheet
  },
  363: {
    /* n:"BrtExternTableStart" */
  },
  364: {
    /* n:"BrtExternTableEnd" */
  },
  366: {
    /* n:"BrtExternRowHdr" */
  },
  367: {
    /* n:"BrtExternCellBlank" */
  },
  368: {
    /* n:"BrtExternCellReal" */
  },
  369: {
    /* n:"BrtExternCellBool" */
  },
  370: {
    /* n:"BrtExternCellError" */
  },
  371: {
    /* n:"BrtExternCellString" */
  },
  372: {
    /* n:"BrtBeginEsmdx", */
    T: 1
  },
  373: {
    /* n:"BrtEndEsmdx", */
    T: -1
  },
  374: {
    /* n:"BrtBeginMdxSet", */
    T: 1
  },
  375: {
    /* n:"BrtEndMdxSet", */
    T: -1
  },
  376: {
    /* n:"BrtBeginMdxMbrProp", */
    T: 1
  },
  377: {
    /* n:"BrtEndMdxMbrProp", */
    T: -1
  },
  378: {
    /* n:"BrtBeginMdxKPI", */
    T: 1
  },
  379: {
    /* n:"BrtEndMdxKPI", */
    T: -1
  },
  380: {
    /* n:"BrtBeginEsstr", */
    T: 1
  },
  381: {
    /* n:"BrtEndEsstr", */
    T: -1
  },
  382: {
    /* n:"BrtBeginPRFItem", */
    T: 1
  },
  383: {
    /* n:"BrtEndPRFItem", */
    T: -1
  },
  384: {
    /* n:"BrtBeginPivotCacheIDs", */
    T: 1
  },
  385: {
    /* n:"BrtEndPivotCacheIDs", */
    T: -1
  },
  386: {
    /* n:"BrtBeginPivotCacheID", */
    T: 1
  },
  387: {
    /* n:"BrtEndPivotCacheID", */
    T: -1
  },
  388: {
    /* n:"BrtBeginISXVIs", */
    T: 1
  },
  389: {
    /* n:"BrtEndISXVIs", */
    T: -1
  },
  390: {
    /* n:"BrtBeginColInfos", */
    T: 1
  },
  391: {
    /* n:"BrtEndColInfos", */
    T: -1
  },
  392: {
    /* n:"BrtBeginRwBrk", */
    T: 1
  },
  393: {
    /* n:"BrtEndRwBrk", */
    T: -1
  },
  394: {
    /* n:"BrtBeginColBrk", */
    T: 1
  },
  395: {
    /* n:"BrtEndColBrk", */
    T: -1
  },
  396: {
    /* n:"BrtBrk" */
  },
  397: {
    /* n:"BrtUserBookView" */
  },
  398: {
    /* n:"BrtInfo" */
  },
  399: {
    /* n:"BrtCUsr" */
  },
  400: {
    /* n:"BrtUsr" */
  },
  401: {
    /* n:"BrtBeginUsers", */
    T: 1
  },
  403: {
    /* n:"BrtEOF" */
  },
  404: {
    /* n:"BrtUCR" */
  },
  405: {
    /* n:"BrtRRInsDel" */
  },
  406: {
    /* n:"BrtRREndInsDel" */
  },
  407: {
    /* n:"BrtRRMove" */
  },
  408: {
    /* n:"BrtRREndMove" */
  },
  409: {
    /* n:"BrtRRChgCell" */
  },
  410: {
    /* n:"BrtRREndChgCell" */
  },
  411: {
    /* n:"BrtRRHeader" */
  },
  412: {
    /* n:"BrtRRUserView" */
  },
  413: {
    /* n:"BrtRRRenSheet" */
  },
  414: {
    /* n:"BrtRRInsertSh" */
  },
  415: {
    /* n:"BrtRRDefName" */
  },
  416: {
    /* n:"BrtRRNote" */
  },
  417: {
    /* n:"BrtRRConflict" */
  },
  418: {
    /* n:"BrtRRTQSIF" */
  },
  419: {
    /* n:"BrtRRFormat" */
  },
  420: {
    /* n:"BrtRREndFormat" */
  },
  421: {
    /* n:"BrtRRAutoFmt" */
  },
  422: {
    /* n:"BrtBeginUserShViews", */
    T: 1
  },
  423: {
    /* n:"BrtBeginUserShView", */
    T: 1
  },
  424: {
    /* n:"BrtEndUserShView", */
    T: -1
  },
  425: {
    /* n:"BrtEndUserShViews", */
    T: -1
  },
  426: {
    /* n:"BrtArrFmla", */
    f: parse_BrtArrFmla
  },
  427: {
    /* n:"BrtShrFmla", */
    f: parse_BrtShrFmla
  },
  428: {
    /* n:"BrtTable" */
  },
  429: {
    /* n:"BrtBeginExtConnections", */
    T: 1
  },
  430: {
    /* n:"BrtEndExtConnections", */
    T: -1
  },
  431: {
    /* n:"BrtBeginPCDCalcMems", */
    T: 1
  },
  432: {
    /* n:"BrtEndPCDCalcMems", */
    T: -1
  },
  433: {
    /* n:"BrtBeginPCDCalcMem", */
    T: 1
  },
  434: {
    /* n:"BrtEndPCDCalcMem", */
    T: -1
  },
  435: {
    /* n:"BrtBeginPCDHGLevels", */
    T: 1
  },
  436: {
    /* n:"BrtEndPCDHGLevels", */
    T: -1
  },
  437: {
    /* n:"BrtBeginPCDHGLevel", */
    T: 1
  },
  438: {
    /* n:"BrtEndPCDHGLevel", */
    T: -1
  },
  439: {
    /* n:"BrtBeginPCDHGLGroups", */
    T: 1
  },
  440: {
    /* n:"BrtEndPCDHGLGroups", */
    T: -1
  },
  441: {
    /* n:"BrtBeginPCDHGLGroup", */
    T: 1
  },
  442: {
    /* n:"BrtEndPCDHGLGroup", */
    T: -1
  },
  443: {
    /* n:"BrtBeginPCDHGLGMembers", */
    T: 1
  },
  444: {
    /* n:"BrtEndPCDHGLGMembers", */
    T: -1
  },
  445: {
    /* n:"BrtBeginPCDHGLGMember", */
    T: 1
  },
  446: {
    /* n:"BrtEndPCDHGLGMember", */
    T: -1
  },
  447: {
    /* n:"BrtBeginQSI", */
    T: 1
  },
  448: {
    /* n:"BrtEndQSI", */
    T: -1
  },
  449: {
    /* n:"BrtBeginQSIR", */
    T: 1
  },
  450: {
    /* n:"BrtEndQSIR", */
    T: -1
  },
  451: {
    /* n:"BrtBeginDeletedNames", */
    T: 1
  },
  452: {
    /* n:"BrtEndDeletedNames", */
    T: -1
  },
  453: {
    /* n:"BrtBeginDeletedName", */
    T: 1
  },
  454: {
    /* n:"BrtEndDeletedName", */
    T: -1
  },
  455: {
    /* n:"BrtBeginQSIFs", */
    T: 1
  },
  456: {
    /* n:"BrtEndQSIFs", */
    T: -1
  },
  457: {
    /* n:"BrtBeginQSIF", */
    T: 1
  },
  458: {
    /* n:"BrtEndQSIF", */
    T: -1
  },
  459: {
    /* n:"BrtBeginAutoSortScope", */
    T: 1
  },
  460: {
    /* n:"BrtEndAutoSortScope", */
    T: -1
  },
  461: {
    /* n:"BrtBeginConditionalFormatting", */
    T: 1
  },
  462: {
    /* n:"BrtEndConditionalFormatting", */
    T: -1
  },
  463: {
    /* n:"BrtBeginCFRule", */
    T: 1
  },
  464: {
    /* n:"BrtEndCFRule", */
    T: -1
  },
  465: {
    /* n:"BrtBeginIconSet", */
    T: 1
  },
  466: {
    /* n:"BrtEndIconSet", */
    T: -1
  },
  467: {
    /* n:"BrtBeginDatabar", */
    T: 1
  },
  468: {
    /* n:"BrtEndDatabar", */
    T: -1
  },
  469: {
    /* n:"BrtBeginColorScale", */
    T: 1
  },
  470: {
    /* n:"BrtEndColorScale", */
    T: -1
  },
  471: {
    /* n:"BrtCFVO" */
  },
  472: {
    /* n:"BrtExternValueMeta" */
  },
  473: {
    /* n:"BrtBeginColorPalette", */
    T: 1
  },
  474: {
    /* n:"BrtEndColorPalette", */
    T: -1
  },
  475: {
    /* n:"BrtIndexedColor" */
  },
  476: {
    /* n:"BrtMargins", */
    f: parse_BrtMargins
  },
  477: {
    /* n:"BrtPrintOptions" */
  },
  478: {
    /* n:"BrtPageSetup" */
  },
  479: {
    /* n:"BrtBeginHeaderFooter", */
    T: 1
  },
  480: {
    /* n:"BrtEndHeaderFooter", */
    T: -1
  },
  481: {
    /* n:"BrtBeginSXCrtFormat", */
    T: 1
  },
  482: {
    /* n:"BrtEndSXCrtFormat", */
    T: -1
  },
  483: {
    /* n:"BrtBeginSXCrtFormats", */
    T: 1
  },
  484: {
    /* n:"BrtEndSXCrtFormats", */
    T: -1
  },
  485: {
    /* n:"BrtWsFmtInfo", */
    f: parse_BrtWsFmtInfo
  },
  486: {
    /* n:"BrtBeginMgs", */
    T: 1
  },
  487: {
    /* n:"BrtEndMGs", */
    T: -1
  },
  488: {
    /* n:"BrtBeginMGMaps", */
    T: 1
  },
  489: {
    /* n:"BrtEndMGMaps", */
    T: -1
  },
  490: {
    /* n:"BrtBeginMG", */
    T: 1
  },
  491: {
    /* n:"BrtEndMG", */
    T: -1
  },
  492: {
    /* n:"BrtBeginMap", */
    T: 1
  },
  493: {
    /* n:"BrtEndMap", */
    T: -1
  },
  494: {
    /* n:"BrtHLink", */
    f: parse_BrtHLink
  },
  495: {
    /* n:"BrtBeginDCon", */
    T: 1
  },
  496: {
    /* n:"BrtEndDCon", */
    T: -1
  },
  497: {
    /* n:"BrtBeginDRefs", */
    T: 1
  },
  498: {
    /* n:"BrtEndDRefs", */
    T: -1
  },
  499: {
    /* n:"BrtDRef" */
  },
  500: {
    /* n:"BrtBeginScenMan", */
    T: 1
  },
  501: {
    /* n:"BrtEndScenMan", */
    T: -1
  },
  502: {
    /* n:"BrtBeginSct", */
    T: 1
  },
  503: {
    /* n:"BrtEndSct", */
    T: -1
  },
  504: {
    /* n:"BrtSlc" */
  },
  505: {
    /* n:"BrtBeginDXFs", */
    T: 1
  },
  506: {
    /* n:"BrtEndDXFs", */
    T: -1
  },
  507: {
    /* n:"BrtDXF" */
  },
  508: {
    /* n:"BrtBeginTableStyles", */
    T: 1
  },
  509: {
    /* n:"BrtEndTableStyles", */
    T: -1
  },
  510: {
    /* n:"BrtBeginTableStyle", */
    T: 1
  },
  511: {
    /* n:"BrtEndTableStyle", */
    T: -1
  },
  512: {
    /* n:"BrtTableStyleElement" */
  },
  513: {
    /* n:"BrtTableStyleClient" */
  },
  514: {
    /* n:"BrtBeginVolDeps", */
    T: 1
  },
  515: {
    /* n:"BrtEndVolDeps", */
    T: -1
  },
  516: {
    /* n:"BrtBeginVolType", */
    T: 1
  },
  517: {
    /* n:"BrtEndVolType", */
    T: -1
  },
  518: {
    /* n:"BrtBeginVolMain", */
    T: 1
  },
  519: {
    /* n:"BrtEndVolMain", */
    T: -1
  },
  520: {
    /* n:"BrtBeginVolTopic", */
    T: 1
  },
  521: {
    /* n:"BrtEndVolTopic", */
    T: -1
  },
  522: {
    /* n:"BrtVolSubtopic" */
  },
  523: {
    /* n:"BrtVolRef" */
  },
  524: {
    /* n:"BrtVolNum" */
  },
  525: {
    /* n:"BrtVolErr" */
  },
  526: {
    /* n:"BrtVolStr" */
  },
  527: {
    /* n:"BrtVolBool" */
  },
  528: {
    /* n:"BrtBeginCalcChain$", */
    T: 1
  },
  529: {
    /* n:"BrtEndCalcChain$", */
    T: -1
  },
  530: {
    /* n:"BrtBeginSortState", */
    T: 1
  },
  531: {
    /* n:"BrtEndSortState", */
    T: -1
  },
  532: {
    /* n:"BrtBeginSortCond", */
    T: 1
  },
  533: {
    /* n:"BrtEndSortCond", */
    T: -1
  },
  534: {
    /* n:"BrtBookProtection" */
  },
  535: {
    /* n:"BrtSheetProtection" */
  },
  536: {
    /* n:"BrtRangeProtection" */
  },
  537: {
    /* n:"BrtPhoneticInfo" */
  },
  538: {
    /* n:"BrtBeginECTxtWiz", */
    T: 1
  },
  539: {
    /* n:"BrtEndECTxtWiz", */
    T: -1
  },
  540: {
    /* n:"BrtBeginECTWFldInfoLst", */
    T: 1
  },
  541: {
    /* n:"BrtEndECTWFldInfoLst", */
    T: -1
  },
  542: {
    /* n:"BrtBeginECTwFldInfo", */
    T: 1
  },
  548: {
    /* n:"BrtFileSharing" */
  },
  549: {
    /* n:"BrtOleSize" */
  },
  550: {
    /* n:"BrtDrawing", */
    f: parse_RelID
  },
  551: {
    /* n:"BrtLegacyDrawing", */
    f: parse_XLNullableWideString
  },
  552: {
    /* n:"BrtLegacyDrawingHF" */
  },
  553: {
    /* n:"BrtWebOpt" */
  },
  554: {
    /* n:"BrtBeginWebPubItems", */
    T: 1
  },
  555: {
    /* n:"BrtEndWebPubItems", */
    T: -1
  },
  556: {
    /* n:"BrtBeginWebPubItem", */
    T: 1
  },
  557: {
    /* n:"BrtEndWebPubItem", */
    T: -1
  },
  558: {
    /* n:"BrtBeginSXCondFmt", */
    T: 1
  },
  559: {
    /* n:"BrtEndSXCondFmt", */
    T: -1
  },
  560: {
    /* n:"BrtBeginSXCondFmts", */
    T: 1
  },
  561: {
    /* n:"BrtEndSXCondFmts", */
    T: -1
  },
  562: {
    /* n:"BrtBkHim" */
  },
  564: {
    /* n:"BrtColor" */
  },
  565: {
    /* n:"BrtBeginIndexedColors", */
    T: 1
  },
  566: {
    /* n:"BrtEndIndexedColors", */
    T: -1
  },
  569: {
    /* n:"BrtBeginMRUColors", */
    T: 1
  },
  570: {
    /* n:"BrtEndMRUColors", */
    T: -1
  },
  572: {
    /* n:"BrtMRUColor" */
  },
  573: {
    /* n:"BrtBeginDVals", */
    T: 1
  },
  574: {
    /* n:"BrtEndDVals", */
    T: -1
  },
  577: {
    /* n:"BrtSupNameStart" */
  },
  578: {
    /* n:"BrtSupNameValueStart" */
  },
  579: {
    /* n:"BrtSupNameValueEnd" */
  },
  580: {
    /* n:"BrtSupNameNum" */
  },
  581: {
    /* n:"BrtSupNameErr" */
  },
  582: {
    /* n:"BrtSupNameSt" */
  },
  583: {
    /* n:"BrtSupNameNil" */
  },
  584: {
    /* n:"BrtSupNameBool" */
  },
  585: {
    /* n:"BrtSupNameFmla" */
  },
  586: {
    /* n:"BrtSupNameBits" */
  },
  587: {
    /* n:"BrtSupNameEnd" */
  },
  588: {
    /* n:"BrtEndSupBook", */
    T: -1
  },
  589: {
    /* n:"BrtCellSmartTagProperty" */
  },
  590: {
    /* n:"BrtBeginCellSmartTag", */
    T: 1
  },
  591: {
    /* n:"BrtEndCellSmartTag", */
    T: -1
  },
  592: {
    /* n:"BrtBeginCellSmartTags", */
    T: 1
  },
  593: {
    /* n:"BrtEndCellSmartTags", */
    T: -1
  },
  594: {
    /* n:"BrtBeginSmartTags", */
    T: 1
  },
  595: {
    /* n:"BrtEndSmartTags", */
    T: -1
  },
  596: {
    /* n:"BrtSmartTagType" */
  },
  597: {
    /* n:"BrtBeginSmartTagTypes", */
    T: 1
  },
  598: {
    /* n:"BrtEndSmartTagTypes", */
    T: -1
  },
  599: {
    /* n:"BrtBeginSXFilters", */
    T: 1
  },
  600: {
    /* n:"BrtEndSXFilters", */
    T: -1
  },
  601: {
    /* n:"BrtBeginSXFILTER", */
    T: 1
  },
  602: {
    /* n:"BrtEndSXFilter", */
    T: -1
  },
  603: {
    /* n:"BrtBeginFills", */
    T: 1
  },
  604: {
    /* n:"BrtEndFills", */
    T: -1
  },
  605: {
    /* n:"BrtBeginCellWatches", */
    T: 1
  },
  606: {
    /* n:"BrtEndCellWatches", */
    T: -1
  },
  607: {
    /* n:"BrtCellWatch" */
  },
  608: {
    /* n:"BrtBeginCRErrs", */
    T: 1
  },
  609: {
    /* n:"BrtEndCRErrs", */
    T: -1
  },
  610: {
    /* n:"BrtCrashRecErr" */
  },
  611: {
    /* n:"BrtBeginFonts", */
    T: 1
  },
  612: {
    /* n:"BrtEndFonts", */
    T: -1
  },
  613: {
    /* n:"BrtBeginBorders", */
    T: 1
  },
  614: {
    /* n:"BrtEndBorders", */
    T: -1
  },
  615: {
    /* n:"BrtBeginFmts", */
    T: 1
  },
  616: {
    /* n:"BrtEndFmts", */
    T: -1
  },
  617: {
    /* n:"BrtBeginCellXFs", */
    T: 1
  },
  618: {
    /* n:"BrtEndCellXFs", */
    T: -1
  },
  619: {
    /* n:"BrtBeginStyles", */
    T: 1
  },
  620: {
    /* n:"BrtEndStyles", */
    T: -1
  },
  625: {
    /* n:"BrtBigName" */
  },
  626: {
    /* n:"BrtBeginCellStyleXFs", */
    T: 1
  },
  627: {
    /* n:"BrtEndCellStyleXFs", */
    T: -1
  },
  628: {
    /* n:"BrtBeginComments", */
    T: 1
  },
  629: {
    /* n:"BrtEndComments", */
    T: -1
  },
  630: {
    /* n:"BrtBeginCommentAuthors", */
    T: 1
  },
  631: {
    /* n:"BrtEndCommentAuthors", */
    T: -1
  },
  632: {
    /* n:"BrtCommentAuthor", */
    f: parse_BrtCommentAuthor
  },
  633: {
    /* n:"BrtBeginCommentList", */
    T: 1
  },
  634: {
    /* n:"BrtEndCommentList", */
    T: -1
  },
  635: {
    /* n:"BrtBeginComment", */
    T: 1,
    f: parse_BrtBeginComment
  },
  636: {
    /* n:"BrtEndComment", */
    T: -1
  },
  637: {
    /* n:"BrtCommentText", */
    f: parse_BrtCommentText
  },
  638: {
    /* n:"BrtBeginOleObjects", */
    T: 1
  },
  639: {
    /* n:"BrtOleObject" */
  },
  640: {
    /* n:"BrtEndOleObjects", */
    T: -1
  },
  641: {
    /* n:"BrtBeginSxrules", */
    T: 1
  },
  642: {
    /* n:"BrtEndSxRules", */
    T: -1
  },
  643: {
    /* n:"BrtBeginActiveXControls", */
    T: 1
  },
  644: {
    /* n:"BrtActiveX" */
  },
  645: {
    /* n:"BrtEndActiveXControls", */
    T: -1
  },
  646: {
    /* n:"BrtBeginPCDSDTCEMembersSortBy", */
    T: 1
  },
  648: {
    /* n:"BrtBeginCellIgnoreECs", */
    T: 1
  },
  649: {
    /* n:"BrtCellIgnoreEC" */
  },
  650: {
    /* n:"BrtEndCellIgnoreECs", */
    T: -1
  },
  651: {
    /* n:"BrtCsProp", */
    f: parse_BrtCsProp
  },
  652: {
    /* n:"BrtCsPageSetup" */
  },
  653: {
    /* n:"BrtBeginUserCsViews", */
    T: 1
  },
  654: {
    /* n:"BrtEndUserCsViews", */
    T: -1
  },
  655: {
    /* n:"BrtBeginUserCsView", */
    T: 1
  },
  656: {
    /* n:"BrtEndUserCsView", */
    T: -1
  },
  657: {
    /* n:"BrtBeginPcdSFCIEntries", */
    T: 1
  },
  658: {
    /* n:"BrtEndPCDSFCIEntries", */
    T: -1
  },
  659: {
    /* n:"BrtPCDSFCIEntry" */
  },
  660: {
    /* n:"BrtBeginListParts", */
    T: 1
  },
  661: {
    /* n:"BrtListPart" */
  },
  662: {
    /* n:"BrtEndListParts", */
    T: -1
  },
  663: {
    /* n:"BrtSheetCalcProp" */
  },
  664: {
    /* n:"BrtBeginFnGroup", */
    T: 1
  },
  665: {
    /* n:"BrtFnGroup" */
  },
  666: {
    /* n:"BrtEndFnGroup", */
    T: -1
  },
  667: {
    /* n:"BrtSupAddin" */
  },
  668: {
    /* n:"BrtSXTDMPOrder" */
  },
  669: {
    /* n:"BrtCsProtection" */
  },
  671: {
    /* n:"BrtBeginWsSortMap", */
    T: 1
  },
  672: {
    /* n:"BrtEndWsSortMap", */
    T: -1
  },
  673: {
    /* n:"BrtBeginRRSort", */
    T: 1
  },
  674: {
    /* n:"BrtEndRRSort", */
    T: -1
  },
  675: {
    /* n:"BrtRRSortItem" */
  },
  676: {
    /* n:"BrtFileSharingIso" */
  },
  677: {
    /* n:"BrtBookProtectionIso" */
  },
  678: {
    /* n:"BrtSheetProtectionIso" */
  },
  679: {
    /* n:"BrtCsProtectionIso" */
  },
  680: {
    /* n:"BrtRangeProtectionIso" */
  },
  681: {
    /* n:"BrtDValList" */
  },
  1024: {
    /* n:"BrtRwDescent" */
  },
  1025: {
    /* n:"BrtKnownFonts" */
  },
  1026: {
    /* n:"BrtBeginSXTupleSet", */
    T: 1
  },
  1027: {
    /* n:"BrtEndSXTupleSet", */
    T: -1
  },
  1028: {
    /* n:"BrtBeginSXTupleSetHeader", */
    T: 1
  },
  1029: {
    /* n:"BrtEndSXTupleSetHeader", */
    T: -1
  },
  1030: {
    /* n:"BrtSXTupleSetHeaderItem" */
  },
  1031: {
    /* n:"BrtBeginSXTupleSetData", */
    T: 1
  },
  1032: {
    /* n:"BrtEndSXTupleSetData", */
    T: -1
  },
  1033: {
    /* n:"BrtBeginSXTupleSetRow", */
    T: 1
  },
  1034: {
    /* n:"BrtEndSXTupleSetRow", */
    T: -1
  },
  1035: {
    /* n:"BrtSXTupleSetRowItem" */
  },
  1036: {
    /* n:"BrtNameExt" */
  },
  1037: {
    /* n:"BrtPCDH14" */
  },
  1038: {
    /* n:"BrtBeginPCDCalcMem14", */
    T: 1
  },
  1039: {
    /* n:"BrtEndPCDCalcMem14", */
    T: -1
  },
  1040: {
    /* n:"BrtSXTH14" */
  },
  1041: {
    /* n:"BrtBeginSparklineGroup", */
    T: 1
  },
  1042: {
    /* n:"BrtEndSparklineGroup", */
    T: -1
  },
  1043: {
    /* n:"BrtSparkline" */
  },
  1044: {
    /* n:"BrtSXDI14" */
  },
  1045: {
    /* n:"BrtWsFmtInfoEx14" */
  },
  1046: {
    /* n:"BrtBeginConditionalFormatting14", */
    T: 1
  },
  1047: {
    /* n:"BrtEndConditionalFormatting14", */
    T: -1
  },
  1048: {
    /* n:"BrtBeginCFRule14", */
    T: 1
  },
  1049: {
    /* n:"BrtEndCFRule14", */
    T: -1
  },
  1050: {
    /* n:"BrtCFVO14" */
  },
  1051: {
    /* n:"BrtBeginDatabar14", */
    T: 1
  },
  1052: {
    /* n:"BrtBeginIconSet14", */
    T: 1
  },
  1053: {
    /* n:"BrtDVal14", */
    f: parse_BrtDVal14
  },
  1054: {
    /* n:"BrtBeginDVals14", */
    T: 1
  },
  1055: {
    /* n:"BrtColor14" */
  },
  1056: {
    /* n:"BrtBeginSparklines", */
    T: 1
  },
  1057: {
    /* n:"BrtEndSparklines", */
    T: -1
  },
  1058: {
    /* n:"BrtBeginSparklineGroups", */
    T: 1
  },
  1059: {
    /* n:"BrtEndSparklineGroups", */
    T: -1
  },
  1061: {
    /* n:"BrtSXVD14" */
  },
  1062: {
    /* n:"BrtBeginSXView14", */
    T: 1
  },
  1063: {
    /* n:"BrtEndSXView14", */
    T: -1
  },
  1064: {
    /* n:"BrtBeginSXView16", */
    T: 1
  },
  1065: {
    /* n:"BrtEndSXView16", */
    T: -1
  },
  1066: {
    /* n:"BrtBeginPCD14", */
    T: 1
  },
  1067: {
    /* n:"BrtEndPCD14", */
    T: -1
  },
  1068: {
    /* n:"BrtBeginExtConn14", */
    T: 1
  },
  1069: {
    /* n:"BrtEndExtConn14", */
    T: -1
  },
  1070: {
    /* n:"BrtBeginSlicerCacheIDs", */
    T: 1
  },
  1071: {
    /* n:"BrtEndSlicerCacheIDs", */
    T: -1
  },
  1072: {
    /* n:"BrtBeginSlicerCacheID", */
    T: 1
  },
  1073: {
    /* n:"BrtEndSlicerCacheID", */
    T: -1
  },
  1075: {
    /* n:"BrtBeginSlicerCache", */
    T: 1
  },
  1076: {
    /* n:"BrtEndSlicerCache", */
    T: -1
  },
  1077: {
    /* n:"BrtBeginSlicerCacheDef", */
    T: 1
  },
  1078: {
    /* n:"BrtEndSlicerCacheDef", */
    T: -1
  },
  1079: {
    /* n:"BrtBeginSlicersEx", */
    T: 1
  },
  1080: {
    /* n:"BrtEndSlicersEx", */
    T: -1
  },
  1081: {
    /* n:"BrtBeginSlicerEx", */
    T: 1
  },
  1082: {
    /* n:"BrtEndSlicerEx", */
    T: -1
  },
  1083: {
    /* n:"BrtBeginSlicer", */
    T: 1
  },
  1084: {
    /* n:"BrtEndSlicer", */
    T: -1
  },
  1085: {
    /* n:"BrtSlicerCachePivotTables" */
  },
  1086: {
    /* n:"BrtBeginSlicerCacheOlapImpl", */
    T: 1
  },
  1087: {
    /* n:"BrtEndSlicerCacheOlapImpl", */
    T: -1
  },
  1088: {
    /* n:"BrtBeginSlicerCacheLevelsData", */
    T: 1
  },
  1089: {
    /* n:"BrtEndSlicerCacheLevelsData", */
    T: -1
  },
  1090: {
    /* n:"BrtBeginSlicerCacheLevelData", */
    T: 1
  },
  1091: {
    /* n:"BrtEndSlicerCacheLevelData", */
    T: -1
  },
  1092: {
    /* n:"BrtBeginSlicerCacheSiRanges", */
    T: 1
  },
  1093: {
    /* n:"BrtEndSlicerCacheSiRanges", */
    T: -1
  },
  1094: {
    /* n:"BrtBeginSlicerCacheSiRange", */
    T: 1
  },
  1095: {
    /* n:"BrtEndSlicerCacheSiRange", */
    T: -1
  },
  1096: {
    /* n:"BrtSlicerCacheOlapItem" */
  },
  1097: {
    /* n:"BrtBeginSlicerCacheSelections", */
    T: 1
  },
  1098: {
    /* n:"BrtSlicerCacheSelection" */
  },
  1099: {
    /* n:"BrtEndSlicerCacheSelections", */
    T: -1
  },
  1100: {
    /* n:"BrtBeginSlicerCacheNative", */
    T: 1
  },
  1101: {
    /* n:"BrtEndSlicerCacheNative", */
    T: -1
  },
  1102: {
    /* n:"BrtSlicerCacheNativeItem" */
  },
  1103: {
    /* n:"BrtRangeProtection14" */
  },
  1104: {
    /* n:"BrtRangeProtectionIso14" */
  },
  1105: {
    /* n:"BrtCellIgnoreEC14" */
  },
  1111: {
    /* n:"BrtList14" */
  },
  1112: {
    /* n:"BrtCFIcon" */
  },
  1113: {
    /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
    T: 1
  },
  1114: {
    /* n:"BrtEndSlicerCachesPivotCacheIDs", */
    T: -1
  },
  1115: {
    /* n:"BrtBeginSlicers", */
    T: 1
  },
  1116: {
    /* n:"BrtEndSlicers", */
    T: -1
  },
  1117: {
    /* n:"BrtWbProp14" */
  },
  1118: {
    /* n:"BrtBeginSXEdit", */
    T: 1
  },
  1119: {
    /* n:"BrtEndSXEdit", */
    T: -1
  },
  1120: {
    /* n:"BrtBeginSXEdits", */
    T: 1
  },
  1121: {
    /* n:"BrtEndSXEdits", */
    T: -1
  },
  1122: {
    /* n:"BrtBeginSXChange", */
    T: 1
  },
  1123: {
    /* n:"BrtEndSXChange", */
    T: -1
  },
  1124: {
    /* n:"BrtBeginSXChanges", */
    T: 1
  },
  1125: {
    /* n:"BrtEndSXChanges", */
    T: -1
  },
  1126: {
    /* n:"BrtSXTupleItems" */
  },
  1128: {
    /* n:"BrtBeginSlicerStyle", */
    T: 1
  },
  1129: {
    /* n:"BrtEndSlicerStyle", */
    T: -1
  },
  1130: {
    /* n:"BrtSlicerStyleElement" */
  },
  1131: {
    /* n:"BrtBeginStyleSheetExt14", */
    T: 1
  },
  1132: {
    /* n:"BrtEndStyleSheetExt14", */
    T: -1
  },
  1133: {
    /* n:"BrtBeginSlicerCachesPivotCacheID", */
    T: 1
  },
  1134: {
    /* n:"BrtEndSlicerCachesPivotCacheID", */
    T: -1
  },
  1135: {
    /* n:"BrtBeginConditionalFormattings", */
    T: 1
  },
  1136: {
    /* n:"BrtEndConditionalFormattings", */
    T: -1
  },
  1137: {
    /* n:"BrtBeginPCDCalcMemExt", */
    T: 1
  },
  1138: {
    /* n:"BrtEndPCDCalcMemExt", */
    T: -1
  },
  1139: {
    /* n:"BrtBeginPCDCalcMemsExt", */
    T: 1
  },
  1140: {
    /* n:"BrtEndPCDCalcMemsExt", */
    T: -1
  },
  1141: {
    /* n:"BrtPCDField14" */
  },
  1142: {
    /* n:"BrtBeginSlicerStyles", */
    T: 1
  },
  1143: {
    /* n:"BrtEndSlicerStyles", */
    T: -1
  },
  1144: {
    /* n:"BrtBeginSlicerStyleElements", */
    T: 1
  },
  1145: {
    /* n:"BrtEndSlicerStyleElements", */
    T: -1
  },
  1146: {
    /* n:"BrtCFRuleExt" */
  },
  1147: {
    /* n:"BrtBeginSXCondFmt14", */
    T: 1
  },
  1148: {
    /* n:"BrtEndSXCondFmt14", */
    T: -1
  },
  1149: {
    /* n:"BrtBeginSXCondFmts14", */
    T: 1
  },
  1150: {
    /* n:"BrtEndSXCondFmts14", */
    T: -1
  },
  1152: {
    /* n:"BrtBeginSortCond14", */
    T: 1
  },
  1153: {
    /* n:"BrtEndSortCond14", */
    T: -1
  },
  1154: {
    /* n:"BrtEndDVals14", */
    T: -1
  },
  1155: {
    /* n:"BrtEndIconSet14", */
    T: -1
  },
  1156: {
    /* n:"BrtEndDatabar14", */
    T: -1
  },
  1157: {
    /* n:"BrtBeginColorScale14", */
    T: 1
  },
  1158: {
    /* n:"BrtEndColorScale14", */
    T: -1
  },
  1159: {
    /* n:"BrtBeginSxrules14", */
    T: 1
  },
  1160: {
    /* n:"BrtEndSxrules14", */
    T: -1
  },
  1161: {
    /* n:"BrtBeginPRule14", */
    T: 1
  },
  1162: {
    /* n:"BrtEndPRule14", */
    T: -1
  },
  1163: {
    /* n:"BrtBeginPRFilters14", */
    T: 1
  },
  1164: {
    /* n:"BrtEndPRFilters14", */
    T: -1
  },
  1165: {
    /* n:"BrtBeginPRFilter14", */
    T: 1
  },
  1166: {
    /* n:"BrtEndPRFilter14", */
    T: -1
  },
  1167: {
    /* n:"BrtBeginPRFItem14", */
    T: 1
  },
  1168: {
    /* n:"BrtEndPRFItem14", */
    T: -1
  },
  1169: {
    /* n:"BrtBeginCellIgnoreECs14", */
    T: 1
  },
  1170: {
    /* n:"BrtEndCellIgnoreECs14", */
    T: -1
  },
  1171: {
    /* n:"BrtDxf14" */
  },
  1172: {
    /* n:"BrtBeginDxF14s", */
    T: 1
  },
  1173: {
    /* n:"BrtEndDxf14s", */
    T: -1
  },
  1177: {
    /* n:"BrtFilter14" */
  },
  1178: {
    /* n:"BrtBeginCustomFilters14", */
    T: 1
  },
  1180: {
    /* n:"BrtCustomFilter14" */
  },
  1181: {
    /* n:"BrtIconFilter14" */
  },
  1182: {
    /* n:"BrtPivotCacheConnectionName" */
  },
  2048: {
    /* n:"BrtBeginDecoupledPivotCacheIDs", */
    T: 1
  },
  2049: {
    /* n:"BrtEndDecoupledPivotCacheIDs", */
    T: -1
  },
  2050: {
    /* n:"BrtDecoupledPivotCacheID" */
  },
  2051: {
    /* n:"BrtBeginPivotTableRefs", */
    T: 1
  },
  2052: {
    /* n:"BrtEndPivotTableRefs", */
    T: -1
  },
  2053: {
    /* n:"BrtPivotTableRef" */
  },
  2054: {
    /* n:"BrtSlicerCacheBookPivotTables" */
  },
  2055: {
    /* n:"BrtBeginSxvcells", */
    T: 1
  },
  2056: {
    /* n:"BrtEndSxvcells", */
    T: -1
  },
  2057: {
    /* n:"BrtBeginSxRow", */
    T: 1
  },
  2058: {
    /* n:"BrtEndSxRow", */
    T: -1
  },
  2060: {
    /* n:"BrtPcdCalcMem15" */
  },
  2067: {
    /* n:"BrtQsi15" */
  },
  2068: {
    /* n:"BrtBeginWebExtensions", */
    T: 1
  },
  2069: {
    /* n:"BrtEndWebExtensions", */
    T: -1
  },
  2070: {
    /* n:"BrtWebExtension" */
  },
  2071: {
    /* n:"BrtAbsPath15" */
  },
  2072: {
    /* n:"BrtBeginPivotTableUISettings", */
    T: 1
  },
  2073: {
    /* n:"BrtEndPivotTableUISettings", */
    T: -1
  },
  2075: {
    /* n:"BrtTableSlicerCacheIDs" */
  },
  2076: {
    /* n:"BrtTableSlicerCacheID" */
  },
  2077: {
    /* n:"BrtBeginTableSlicerCache", */
    T: 1
  },
  2078: {
    /* n:"BrtEndTableSlicerCache", */
    T: -1
  },
  2079: {
    /* n:"BrtSxFilter15" */
  },
  2080: {
    /* n:"BrtBeginTimelineCachePivotCacheIDs", */
    T: 1
  },
  2081: {
    /* n:"BrtEndTimelineCachePivotCacheIDs", */
    T: -1
  },
  2082: {
    /* n:"BrtTimelineCachePivotCacheID" */
  },
  2083: {
    /* n:"BrtBeginTimelineCacheIDs", */
    T: 1
  },
  2084: {
    /* n:"BrtEndTimelineCacheIDs", */
    T: -1
  },
  2085: {
    /* n:"BrtBeginTimelineCacheID", */
    T: 1
  },
  2086: {
    /* n:"BrtEndTimelineCacheID", */
    T: -1
  },
  2087: {
    /* n:"BrtBeginTimelinesEx", */
    T: 1
  },
  2088: {
    /* n:"BrtEndTimelinesEx", */
    T: -1
  },
  2089: {
    /* n:"BrtBeginTimelineEx", */
    T: 1
  },
  2090: {
    /* n:"BrtEndTimelineEx", */
    T: -1
  },
  2091: {
    /* n:"BrtWorkBookPr15" */
  },
  2092: {
    /* n:"BrtPCDH15" */
  },
  2093: {
    /* n:"BrtBeginTimelineStyle", */
    T: 1
  },
  2094: {
    /* n:"BrtEndTimelineStyle", */
    T: -1
  },
  2095: {
    /* n:"BrtTimelineStyleElement" */
  },
  2096: {
    /* n:"BrtBeginTimelineStylesheetExt15", */
    T: 1
  },
  2097: {
    /* n:"BrtEndTimelineStylesheetExt15", */
    T: -1
  },
  2098: {
    /* n:"BrtBeginTimelineStyles", */
    T: 1
  },
  2099: {
    /* n:"BrtEndTimelineStyles", */
    T: -1
  },
  2100: {
    /* n:"BrtBeginTimelineStyleElements", */
    T: 1
  },
  2101: {
    /* n:"BrtEndTimelineStyleElements", */
    T: -1
  },
  2102: {
    /* n:"BrtDxf15" */
  },
  2103: {
    /* n:"BrtBeginDxfs15", */
    T: 1
  },
  2104: {
    /* n:"BrtEndDxfs15", */
    T: -1
  },
  2105: {
    /* n:"BrtSlicerCacheHideItemsWithNoData" */
  },
  2106: {
    /* n:"BrtBeginItemUniqueNames", */
    T: 1
  },
  2107: {
    /* n:"BrtEndItemUniqueNames", */
    T: -1
  },
  2108: {
    /* n:"BrtItemUniqueName" */
  },
  2109: {
    /* n:"BrtBeginExtConn15", */
    T: 1
  },
  2110: {
    /* n:"BrtEndExtConn15", */
    T: -1
  },
  2111: {
    /* n:"BrtBeginOledbPr15", */
    T: 1
  },
  2112: {
    /* n:"BrtEndOledbPr15", */
    T: -1
  },
  2113: {
    /* n:"BrtBeginDataFeedPr15", */
    T: 1
  },
  2114: {
    /* n:"BrtEndDataFeedPr15", */
    T: -1
  },
  2115: {
    /* n:"BrtTextPr15" */
  },
  2116: {
    /* n:"BrtRangePr15" */
  },
  2117: {
    /* n:"BrtDbCommand15" */
  },
  2118: {
    /* n:"BrtBeginDbTables15", */
    T: 1
  },
  2119: {
    /* n:"BrtEndDbTables15", */
    T: -1
  },
  2120: {
    /* n:"BrtDbTable15" */
  },
  2121: {
    /* n:"BrtBeginDataModel", */
    T: 1
  },
  2122: {
    /* n:"BrtEndDataModel", */
    T: -1
  },
  2123: {
    /* n:"BrtBeginModelTables", */
    T: 1
  },
  2124: {
    /* n:"BrtEndModelTables", */
    T: -1
  },
  2125: {
    /* n:"BrtModelTable" */
  },
  2126: {
    /* n:"BrtBeginModelRelationships", */
    T: 1
  },
  2127: {
    /* n:"BrtEndModelRelationships", */
    T: -1
  },
  2128: {
    /* n:"BrtModelRelationship" */
  },
  2129: {
    /* n:"BrtBeginECTxtWiz15", */
    T: 1
  },
  2130: {
    /* n:"BrtEndECTxtWiz15", */
    T: -1
  },
  2131: {
    /* n:"BrtBeginECTWFldInfoLst15", */
    T: 1
  },
  2132: {
    /* n:"BrtEndECTWFldInfoLst15", */
    T: -1
  },
  2133: {
    /* n:"BrtBeginECTWFldInfo15", */
    T: 1
  },
  2134: {
    /* n:"BrtFieldListActiveItem" */
  },
  2135: {
    /* n:"BrtPivotCacheIdVersion" */
  },
  2136: {
    /* n:"BrtSXDI15" */
  },
  2137: {
    /* n:"BrtBeginModelTimeGroupings", */
    T: 1
  },
  2138: {
    /* n:"BrtEndModelTimeGroupings", */
    T: -1
  },
  2139: {
    /* n:"BrtBeginModelTimeGrouping", */
    T: 1
  },
  2140: {
    /* n:"BrtEndModelTimeGrouping", */
    T: -1
  },
  2141: {
    /* n:"BrtModelTimeGroupingCalcCol" */
  },
  3072: {
    /* n:"BrtUid" */
  },
  3073: {
    /* n:"BrtRevisionPtr" */
  },
  4096: {
    /* n:"BrtBeginDynamicArrayPr", */
    T: 1
  },
  4097: {
    /* n:"BrtEndDynamicArrayPr", */
    T: -1
  },
  5002: {
    /* n:"BrtBeginRichValueBlock", */
    T: 1
  },
  5003: {
    /* n:"BrtEndRichValueBlock", */
    T: -1
  },
  5081: {
    /* n:"BrtBeginRichFilters", */
    T: 1
  },
  5082: {
    /* n:"BrtEndRichFilters", */
    T: -1
  },
  5083: {
    /* n:"BrtRichFilter" */
  },
  5084: {
    /* n:"BrtBeginRichFilterColumn", */
    T: 1
  },
  5085: {
    /* n:"BrtEndRichFilterColumn", */
    T: -1
  },
  5086: {
    /* n:"BrtBeginCustomRichFilters", */
    T: 1
  },
  5087: {
    /* n:"BrtEndCustomRichFilters", */
    T: -1
  },
  5088: {
    /* n:"BrtCustomRichFilter" */
  },
  5089: {
    /* n:"BrtTop10RichFilter" */
  },
  5090: {
    /* n:"BrtDynamicRichFilter" */
  },
  5092: {
    /* n:"BrtBeginRichSortCondition", */
    T: 1
  },
  5093: {
    /* n:"BrtEndRichSortCondition", */
    T: -1
  },
  5094: {
    /* n:"BrtRichFilterDateGroupItem" */
  },
  5095: {
    /* n:"BrtBeginCalcFeatures", */
    T: 1
  },
  5096: {
    /* n:"BrtEndCalcFeatures", */
    T: -1
  },
  5097: {
    /* n:"BrtCalcFeature" */
  },
  5099: {
    /* n:"BrtExternalLinksPr" */
  },
  65535: { n: "" }
}, XLSRecordEnum = {
  /* [MS-XLS] 2.3 Record Enumeration 2021-08-17 */
  6: {
    /* n:"Formula", */
    f: parse_Formula
  },
  10: {
    /* n:"EOF", */
    f: parsenoop2
  },
  12: {
    /* n:"CalcCount", */
    f: parseuint16
  },
  //
  13: {
    /* n:"CalcMode", */
    f: parseuint16
  },
  //
  14: {
    /* n:"CalcPrecision", */
    f: parsebool
  },
  //
  15: {
    /* n:"CalcRefMode", */
    f: parsebool
  },
  //
  16: {
    /* n:"CalcDelta", */
    f: parse_Xnum
  },
  //
  17: {
    /* n:"CalcIter", */
    f: parsebool
  },
  //
  18: {
    /* n:"Protect", */
    f: parsebool
  },
  19: {
    /* n:"Password", */
    f: parseuint16
  },
  20: {
    /* n:"Header", */
    f: parse_XLHeaderFooter
  },
  21: {
    /* n:"Footer", */
    f: parse_XLHeaderFooter
  },
  23: {
    /* n:"ExternSheet", */
    f: parse_ExternSheet
  },
  24: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  25: {
    /* n:"WinProtect", */
    f: parsebool
  },
  26: {
    /* n:"VerticalPageBreaks", */
  },
  27: {
    /* n:"HorizontalPageBreaks", */
  },
  28: {
    /* n:"Note", */
    f: parse_Note
  },
  29: {
    /* n:"Selection", */
  },
  34: {
    /* n:"Date1904", */
    f: parsebool
  },
  35: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  38: {
    /* n:"LeftMargin", */
    f: parse_Xnum
  },
  // *
  39: {
    /* n:"RightMargin", */
    f: parse_Xnum
  },
  // *
  40: {
    /* n:"TopMargin", */
    f: parse_Xnum
  },
  // *
  41: {
    /* n:"BottomMargin", */
    f: parse_Xnum
  },
  // *
  42: {
    /* n:"PrintRowCol", */
    f: parsebool
  },
  43: {
    /* n:"PrintGrid", */
    f: parsebool
  },
  47: {
    /* n:"FilePass", */
    f: parse_FilePass
  },
  49: {
    /* n:"Font", */
    f: parse_Font
  },
  51: {
    /* n:"PrintSize", */
    f: parseuint16
  },
  60: {
    /* n:"Continue", */
  },
  61: {
    /* n:"Window1", */
    f: parse_Window1
  },
  64: {
    /* n:"Backup", */
    f: parsebool
  },
  65: {
    /* n:"Pane", */
    f: parse_Pane
  },
  66: {
    /* n:"CodePage", */
    f: parseuint16
  },
  77: {
    /* n:"Pls", */
  },
  80: {
    /* n:"DCon", */
  },
  81: {
    /* n:"DConRef", */
  },
  82: {
    /* n:"DConName", */
  },
  85: {
    /* n:"DefColWidth", */
    f: parseuint16
  },
  89: {
    /* n:"XCT", */
  },
  90: {
    /* n:"CRN", */
  },
  91: {
    /* n:"FileSharing", */
  },
  92: {
    /* n:"WriteAccess", */
    f: parse_WriteAccess
  },
  93: {
    /* n:"Obj", */
    f: parse_Obj
  },
  94: {
    /* n:"Uncalced", */
  },
  95: {
    /* n:"CalcSaveRecalc", */
    f: parsebool
  },
  //
  96: {
    /* n:"Template", */
  },
  97: {
    /* n:"Intl", */
  },
  99: {
    /* n:"ObjProtect", */
    f: parsebool
  },
  125: {
    /* n:"ColInfo", */
    f: parse_ColInfo
  },
  128: {
    /* n:"Guts", */
    f: parse_Guts
  },
  129: {
    /* n:"WsBool", */
    f: parse_WsBool
  },
  130: {
    /* n:"GridSet", */
    f: parseuint16
  },
  131: {
    /* n:"HCenter", */
    f: parsebool
  },
  132: {
    /* n:"VCenter", */
    f: parsebool
  },
  133: {
    /* n:"BoundSheet8", */
    f: parse_BoundSheet8
  },
  134: {
    /* n:"WriteProtect", */
  },
  140: {
    /* n:"Country", */
    f: parse_Country
  },
  141: {
    /* n:"HideObj", */
    f: parseuint16
  },
  144: {
    /* n:"Sort", */
  },
  146: {
    /* n:"Palette", */
    f: parse_Palette
  },
  151: {
    /* n:"Sync", */
  },
  152: {
    /* n:"LPr", */
  },
  153: {
    /* n:"DxGCol", */
  },
  154: {
    /* n:"FnGroupName", */
  },
  155: {
    /* n:"FilterMode", */
  },
  156: {
    /* n:"BuiltInFnGroupCount", */
    f: parseuint16
  },
  157: {
    /* n:"AutoFilterInfo", */
  },
  158: {
    /* n:"AutoFilter", */
  },
  160: {
    /* n:"Scl", */
    f: parse_Scl
  },
  161: {
    /* n:"Setup", */
    f: parse_Setup
  },
  174: {
    /* n:"ScenMan", */
  },
  175: {
    /* n:"SCENARIO", */
  },
  176: {
    /* n:"SxView", */
  },
  177: {
    /* n:"Sxvd", */
  },
  178: {
    /* n:"SXVI", */
  },
  180: {
    /* n:"SxIvd", */
  },
  181: {
    /* n:"SXLI", */
  },
  182: {
    /* n:"SXPI", */
  },
  184: {
    /* n:"DocRoute", */
  },
  185: {
    /* n:"RecipName", */
  },
  189: {
    /* n:"MulRk", */
    f: parse_MulRk
  },
  190: {
    /* n:"MulBlank", */
    f: parse_MulBlank
  },
  193: {
    /* n:"Mms", */
    f: parsenoop2
  },
  197: {
    /* n:"SXDI", */
  },
  198: {
    /* n:"SXDB", */
  },
  199: {
    /* n:"SXFDB", */
  },
  200: {
    /* n:"SXDBB", */
  },
  201: {
    /* n:"SXNum", */
  },
  202: {
    /* n:"SxBool", */
    f: parsebool
  },
  203: {
    /* n:"SxErr", */
  },
  204: {
    /* n:"SXInt", */
  },
  205: {
    /* n:"SXString", */
  },
  206: {
    /* n:"SXDtr", */
  },
  207: {
    /* n:"SxNil", */
  },
  208: {
    /* n:"SXTbl", */
  },
  209: {
    /* n:"SXTBRGIITM", */
  },
  210: {
    /* n:"SxTbpg", */
  },
  211: {
    /* n:"ObProj", */
  },
  213: {
    /* n:"SXStreamID", */
  },
  215: {
    /* n:"DBCell", */
  },
  216: {
    /* n:"SXRng", */
  },
  217: {
    /* n:"SxIsxoper", */
  },
  218: {
    /* n:"BookBool", */
    f: parseuint16
  },
  220: {
    /* n:"DbOrParamQry", */
  },
  221: {
    /* n:"ScenarioProtect", */
    f: parsebool
  },
  222: {
    /* n:"OleObjectSize", */
  },
  224: {
    /* n:"XF", */
    f: parse_XF
  },
  225: {
    /* n:"InterfaceHdr", */
    f: parse_InterfaceHdr
  },
  226: {
    /* n:"InterfaceEnd", */
    f: parsenoop2
  },
  227: {
    /* n:"SXVS", */
  },
  229: {
    /* n:"MergeCells", */
    f: parse_MergeCells
  },
  233: {
    /* n:"BkHim", */
  },
  235: {
    /* n:"MsoDrawingGroup", */
  },
  236: {
    /* n:"MsoDrawing", */
  },
  237: {
    /* n:"MsoDrawingSelection", */
  },
  239: {
    /* n:"PhoneticInfo", */
  },
  240: {
    /* n:"SxRule", */
  },
  241: {
    /* n:"SXEx", */
  },
  242: {
    /* n:"SxFilt", */
  },
  244: {
    /* n:"SxDXF", */
  },
  245: {
    /* n:"SxItm", */
  },
  246: {
    /* n:"SxName", */
  },
  247: {
    /* n:"SxSelect", */
  },
  248: {
    /* n:"SXPair", */
  },
  249: {
    /* n:"SxFmla", */
  },
  251: {
    /* n:"SxFormat", */
  },
  252: {
    /* n:"SST", */
    f: parse_SST
  },
  253: {
    /* n:"LabelSst", */
    f: parse_LabelSst
  },
  255: {
    /* n:"ExtSST", */
    f: parse_ExtSST
  },
  256: {
    /* n:"SXVDEx", */
  },
  259: {
    /* n:"SXFormula", */
  },
  290: {
    /* n:"SXDBEx", */
  },
  311: {
    /* n:"RRDInsDel", */
  },
  312: {
    /* n:"RRDHead", */
  },
  315: {
    /* n:"RRDChgCell", */
  },
  317: {
    /* n:"RRTabId", */
    f: parseuint16a
  },
  318: {
    /* n:"RRDRenSheet", */
  },
  319: {
    /* n:"RRSort", */
  },
  320: {
    /* n:"RRDMove", */
  },
  330: {
    /* n:"RRFormat", */
  },
  331: {
    /* n:"RRAutoFmt", */
  },
  333: {
    /* n:"RRInsertSh", */
  },
  334: {
    /* n:"RRDMoveBegin", */
  },
  335: {
    /* n:"RRDMoveEnd", */
  },
  336: {
    /* n:"RRDInsDelBegin", */
  },
  337: {
    /* n:"RRDInsDelEnd", */
  },
  338: {
    /* n:"RRDConflict", */
  },
  339: {
    /* n:"RRDDefName", */
  },
  340: {
    /* n:"RRDRstEtxp", */
  },
  351: {
    /* n:"LRng", */
  },
  352: {
    /* n:"UsesELFs", */
    f: parsebool
  },
  353: {
    /* n:"DSF", */
    f: parsenoop2
  },
  401: {
    /* n:"CUsr", */
  },
  402: {
    /* n:"CbUsr", */
  },
  403: {
    /* n:"UsrInfo", */
  },
  404: {
    /* n:"UsrExcl", */
  },
  405: {
    /* n:"FileLock", */
  },
  406: {
    /* n:"RRDInfo", */
  },
  407: {
    /* n:"BCUsrs", */
  },
  408: {
    /* n:"UsrChk", */
  },
  425: {
    /* n:"UserBView", */
  },
  426: {
    /* n:"UserSViewBegin", */
  },
  427: {
    /* n:"UserSViewEnd", */
  },
  428: {
    /* n:"RRDUserView", */
  },
  429: {
    /* n:"Qsi", */
  },
  430: {
    /* n:"SupBook", */
    f: parse_SupBook
  },
  431: {
    /* n:"Prot4Rev", */
    f: parsebool
  },
  432: {
    /* n:"CondFmt", */
  },
  433: {
    /* n:"CF", */
  },
  434: {
    /* n:"DVal", */
  },
  437: {
    /* n:"DConBin", */
  },
  438: {
    /* n:"TxO", */
    f: parse_TxO
  },
  439: {
    /* n:"RefreshAll", */
    f: parsebool
  },
  //
  440: {
    /* n:"HLink", */
    f: parse_HLink
  },
  441: {
    /* n:"Lel", */
  },
  442: {
    /* n:"CodeName", */
    f: parse_XLUnicodeString
  },
  443: {
    /* n:"SXFDBType", */
  },
  444: {
    /* n:"Prot4RevPass", */
    f: parseuint16
  },
  445: {
    /* n:"ObNoMacros", */
  },
  446: {
    /* n:"Dv", */
  },
  448: {
    /* n:"Excel9File", */
    f: parsenoop2
  },
  449: {
    /* n:"RecalcId", */
    f: parse_RecalcId,
    r: 2
  },
  450: {
    /* n:"EntExU2", */
    f: parsenoop2
  },
  512: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  513: {
    /* n:"Blank", */
    f: parse_Blank
  },
  515: {
    /* n:"Number", */
    f: parse_Number
  },
  516: {
    /* n:"Label", */
    f: parse_Label
  },
  517: {
    /* n:"BoolErr", */
    f: parse_BoolErr
  },
  519: {
    /* n:"String", */
    f: parse_String
  },
  520: {
    /* n:"Row", */
    f: parse_Row
  },
  523: {
    /* n:"Index", */
  },
  545: {
    /* n:"Array", */
    f: parse_Array
  },
  549: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  566: {
    /* n:"Table", */
  },
  574: {
    /* n:"Window2", */
    f: parse_Window2
  },
  638: {
    /* n:"RK", */
    f: parse_RK
  },
  659: {
    /* n:"Style", */
  },
  1048: {
    /* n:"BigName", */
  },
  1054: {
    /* n:"Format", */
    f: parse_Format
  },
  1084: {
    /* n:"ContinueBigName", */
  },
  1212: {
    /* n:"ShrFmla", */
    f: parse_ShrFmla
  },
  2048: {
    /* n:"HLinkTooltip", */
    f: parse_HLinkTooltip
  },
  2049: {
    /* n:"WebPub", */
  },
  2050: {
    /* n:"QsiSXTag", */
  },
  2051: {
    /* n:"DBQueryExt", */
  },
  2052: {
    /* n:"ExtString", */
  },
  2053: {
    /* n:"TxtQry", */
  },
  2054: {
    /* n:"Qsir", */
  },
  2055: {
    /* n:"Qsif", */
  },
  2056: {
    /* n:"RRDTQSIF", */
  },
  2057: {
    /* n:"BOF", */
    f: parse_BOF
  },
  2058: {
    /* n:"OleDbConn", */
  },
  2059: {
    /* n:"WOpt", */
  },
  2060: {
    /* n:"SXViewEx", */
  },
  2061: {
    /* n:"SXTH", */
  },
  2062: {
    /* n:"SXPIEx", */
  },
  2063: {
    /* n:"SXVDTEx", */
  },
  2064: {
    /* n:"SXViewEx9", */
  },
  2066: {
    /* n:"ContinueFrt", */
  },
  2067: {
    /* n:"RealTimeData", */
  },
  2128: {
    /* n:"ChartFrtInfo", */
  },
  2129: {
    /* n:"FrtWrapper", */
  },
  2130: {
    /* n:"StartBlock", */
  },
  2131: {
    /* n:"EndBlock", */
  },
  2132: {
    /* n:"StartObject", */
  },
  2133: {
    /* n:"EndObject", */
  },
  2134: {
    /* n:"CatLab", */
  },
  2135: {
    /* n:"YMult", */
  },
  2136: {
    /* n:"SXViewLink", */
  },
  2137: {
    /* n:"PivotChartBits", */
  },
  2138: {
    /* n:"FrtFontList", */
  },
  2146: {
    /* n:"SheetExt", */
  },
  2147: {
    /* n:"BookExt", */
    r: 12
  },
  2148: {
    /* n:"SXAddl", */
  },
  2149: {
    /* n:"CrErr", */
  },
  2150: {
    /* n:"HFPicture", */
  },
  2151: {
    /* n:"FeatHdr", */
    f: parsenoop2
  },
  2152: {
    /* n:"Feat", */
  },
  2154: {
    /* n:"DataLabExt", */
  },
  2155: {
    /* n:"DataLabExtContents", */
  },
  2156: {
    /* n:"CellWatch", */
  },
  2161: {
    /* n:"FeatHdr11", */
  },
  2162: {
    /* n:"Feature11", */
  },
  2164: {
    /* n:"DropDownObjIds", */
  },
  2165: {
    /* n:"ContinueFrt11", */
  },
  2166: {
    /* n:"DConn", */
  },
  2167: {
    /* n:"List12", */
  },
  2168: {
    /* n:"Feature12", */
  },
  2169: {
    /* n:"CondFmt12", */
  },
  2170: {
    /* n:"CF12", */
  },
  2171: {
    /* n:"CFEx", */
  },
  2172: {
    /* n:"XFCRC", */
    f: parse_XFCRC,
    r: 12
  },
  2173: {
    /* n:"XFExt", */
    f: parse_XFExt,
    r: 12
  },
  2174: {
    /* n:"AutoFilter12", */
  },
  2175: {
    /* n:"ContinueFrt12", */
  },
  2180: {
    /* n:"MDTInfo", */
  },
  2181: {
    /* n:"MDXStr", */
  },
  2182: {
    /* n:"MDXTuple", */
  },
  2183: {
    /* n:"MDXSet", */
  },
  2184: {
    /* n:"MDXProp", */
  },
  2185: {
    /* n:"MDXKPI", */
  },
  2186: {
    /* n:"MDB", */
  },
  2187: {
    /* n:"PLV", */
  },
  2188: {
    /* n:"Compat12", */
    f: parsebool,
    r: 12
  },
  2189: {
    /* n:"DXF", */
  },
  2190: {
    /* n:"TableStyles", */
    r: 12
  },
  2191: {
    /* n:"TableStyle", */
  },
  2192: {
    /* n:"TableStyleElement", */
  },
  2194: {
    /* n:"StyleExt", */
  },
  2195: {
    /* n:"NamePublish", */
  },
  2196: {
    /* n:"NameCmt", */
    f: parse_NameCmt,
    r: 12
  },
  2197: {
    /* n:"SortData", */
  },
  2198: {
    /* n:"Theme", */
    f: parse_Theme,
    r: 12
  },
  2199: {
    /* n:"GUIDTypeLib", */
  },
  2200: {
    /* n:"FnGrp12", */
  },
  2201: {
    /* n:"NameFnGrp12", */
  },
  2202: {
    /* n:"MTRSettings", */
    f: parse_MTRSettings,
    r: 12
  },
  2203: {
    /* n:"CompressPictures", */
    f: parsenoop2
  },
  2204: {
    /* n:"HeaderFooter", */
  },
  2205: {
    /* n:"CrtLayout12", */
  },
  2206: {
    /* n:"CrtMlFrt", */
  },
  2207: {
    /* n:"CrtMlFrtContinue", */
  },
  2211: {
    /* n:"ForceFullCalculation", */
    f: parse_ForceFullCalculation
  },
  2212: {
    /* n:"ShapePropsStream", */
  },
  2213: {
    /* n:"TextPropsStream", */
  },
  2214: {
    /* n:"RichTextStream", */
  },
  2215: {
    /* n:"CrtLayout12A", */
  },
  4097: {
    /* n:"Units", */
  },
  4098: {
    /* n:"Chart", */
  },
  4099: {
    /* n:"Series", */
  },
  4102: {
    /* n:"DataFormat", */
  },
  4103: {
    /* n:"LineFormat", */
  },
  4105: {
    /* n:"MarkerFormat", */
  },
  4106: {
    /* n:"AreaFormat", */
  },
  4107: {
    /* n:"PieFormat", */
  },
  4108: {
    /* n:"AttachedLabel", */
  },
  4109: {
    /* n:"SeriesText", */
  },
  4116: {
    /* n:"ChartFormat", */
  },
  4117: {
    /* n:"Legend", */
  },
  4118: {
    /* n:"SeriesList", */
  },
  4119: {
    /* n:"Bar", */
  },
  4120: {
    /* n:"Line", */
  },
  4121: {
    /* n:"Pie", */
  },
  4122: {
    /* n:"Area", */
  },
  4123: {
    /* n:"Scatter", */
  },
  4124: {
    /* n:"CrtLine", */
  },
  4125: {
    /* n:"Axis", */
  },
  4126: {
    /* n:"Tick", */
  },
  4127: {
    /* n:"ValueRange", */
  },
  4128: {
    /* n:"CatSerRange", */
  },
  4129: {
    /* n:"AxisLine", */
  },
  4130: {
    /* n:"CrtLink", */
  },
  4132: {
    /* n:"DefaultText", */
  },
  4133: {
    /* n:"Text", */
  },
  4134: {
    /* n:"FontX", */
    f: parseuint16
  },
  4135: {
    /* n:"ObjectLink", */
  },
  4146: {
    /* n:"Frame", */
  },
  4147: {
    /* n:"Begin", */
  },
  4148: {
    /* n:"End", */
  },
  4149: {
    /* n:"PlotArea", */
  },
  4154: {
    /* n:"Chart3d", */
  },
  4156: {
    /* n:"PicF", */
  },
  4157: {
    /* n:"DropBar", */
  },
  4158: {
    /* n:"Radar", */
  },
  4159: {
    /* n:"Surf", */
  },
  4160: {
    /* n:"RadarArea", */
  },
  4161: {
    /* n:"AxisParent", */
  },
  4163: {
    /* n:"LegendException", */
  },
  4164: {
    /* n:"ShtProps", */
    f: parse_ShtProps
  },
  4165: {
    /* n:"SerToCrt", */
  },
  4166: {
    /* n:"AxesUsed", */
  },
  4168: {
    /* n:"SBaseRef", */
  },
  4170: {
    /* n:"SerParent", */
  },
  4171: {
    /* n:"SerAuxTrend", */
  },
  4174: {
    /* n:"IFmtRecord", */
  },
  4175: {
    /* n:"Pos", */
  },
  4176: {
    /* n:"AlRuns", */
  },
  4177: {
    /* n:"BRAI", */
  },
  4187: {
    /* n:"SerAuxErrBar", */
  },
  4188: {
    /* n:"ClrtClient", */
    f: parse_ClrtClient
  },
  4189: {
    /* n:"SerFmt", */
  },
  4191: {
    /* n:"Chart3DBarShape", */
  },
  4192: {
    /* n:"Fbi", */
  },
  4193: {
    /* n:"BopPop", */
  },
  4194: {
    /* n:"AxcExt", */
  },
  4195: {
    /* n:"Dat", */
  },
  4196: {
    /* n:"PlotGrowth", */
  },
  4197: {
    /* n:"SIIndex", */
  },
  4198: {
    /* n:"GelFrame", */
  },
  4199: {
    /* n:"BopPopCustom", */
  },
  4200: {
    /* n:"Fbi2", */
  },
  0: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  1: {
    /* n:"BIFF2BLANK", */
  },
  2: {
    /* n:"BIFF2INT", */
    f: parse_BIFF2INT
  },
  3: {
    /* n:"BIFF2NUM", */
    f: parse_BIFF2NUM
  },
  4: {
    /* n:"BIFF2STR", */
    f: parse_BIFF2STR
  },
  5: {
    /* n:"BIFF2BOOLERR", */
    f: parse_BIFF2BOOLERR
  },
  7: {
    /* n:"String", */
    f: parse_BIFF2STRING
  },
  8: {
    /* n:"BIFF2ROW", */
  },
  9: {
    /* n:"BOF", */
    f: parse_BOF
  },
  11: {
    /* n:"Index", */
  },
  22: {
    /* n:"ExternCount", */
    f: parseuint16
  },
  30: {
    /* n:"BIFF2FORMAT", */
    f: parse_BIFF2Format
  },
  31: {
    /* n:"BIFF2FMTCNT", */
  },
  /* 16-bit cnt of BIFF2FORMAT records */
  32: {
    /* n:"BIFF2COLINFO", */
  },
  33: {
    /* n:"Array", */
    f: parse_Array
  },
  36: {
    /* n:"COLWIDTH", */
  },
  37: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  // 0x002c ??
  // 0x002d ??
  // 0x002e ??
  // 0x0030 FONTCOUNT: number of fonts
  50: {
    /* n:"BIFF2FONTXTRA", */
    f: parse_BIFF2FONTXTRA
  },
  // 0x0035: INFOOPTS
  // 0x0036: TABLE (BIFF2 only)
  // 0x0037: TABLE2 (BIFF2 only)
  // 0x0038: WNDESK
  // 0x0039 ??
  // 0x003a: BEGINPREF
  // 0x003b: ENDPREF
  62: {
    /* n:"BIFF2WINDOW2", */
  },
  // 0x003f ??
  // 0x0046: SHOWSCROLL
  // 0x0047: SHOWFORMULA
  // 0x0048: STATUSBAR
  // 0x0049: SHORTMENUS
  // 0x004A:
  // 0x004B:
  // 0x004C:
  // 0x004E:
  // 0x004F:
  // 0x0058: TOOLBAR (BIFF3)
  /* - - - */
  52: {
    /* n:"DDEObjName", */
  },
  67: {
    /* n:"BIFF2XF", */
    f: parse_BIFF2XF
  },
  68: {
    /* n:"BIFF2XFINDEX", */
    f: parseuint16
  },
  69: {
    /* n:"BIFF2FONTCLR", */
  },
  86: {
    /* n:"BIFF4FMTCNT", */
  },
  /* 16-bit cnt, similar to BIFF2 */
  126: {
    /* n:"RK", */
  },
  /* Not necessarily same as 0x027e */
  127: {
    /* n:"ImData", */
    f: parse_ImData
  },
  135: {
    /* n:"Addin", */
  },
  136: {
    /* n:"Edg", */
  },
  137: {
    /* n:"Pub", */
  },
  // 0x8A
  // 0x8B LH: alternate menu key flag (BIFF3/4)
  // 0x8E
  143: {
    /* n:"BIFF4SheetInfo", */
    f: parse_BIFF4SheetInfo
  },
  145: {
    /* n:"Sub", */
  },
  // 0x93 STYLE
  148: {
    /* n:"LHRecord", */
  },
  149: {
    /* n:"LHNGraph", */
  },
  150: {
    /* n:"Sound", */
  },
  // 0xA2 FNPROTO: function prototypes (BIFF4)
  // 0xA3
  // 0xA8
  169: {
    /* n:"CoordList", */
  },
  171: {
    /* n:"GCW", */
  },
  188: {
    /* n:"ShrFmla", */
  },
  /* Not necessarily same as 0x04bc */
  191: {
    /* n:"ToolbarHdr", */
  },
  192: {
    /* n:"ToolbarEnd", */
  },
  194: {
    /* n:"AddMenu", */
  },
  195: {
    /* n:"DelMenu", */
  },
  214: {
    /* n:"RString", */
    f: parse_RString
  },
  223: {
    /* n:"UDDesc", */
  },
  234: {
    /* n:"TabIdConf", */
  },
  354: {
    /* n:"XL5Modify", */
  },
  421: {
    /* n:"FileSharing2", */
  },
  518: {
    /* n:"Formula", */
    f: parse_Formula
  },
  521: {
    /* n:"BOF", */
    f: parse_BOF
  },
  536: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  547: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  561: {
    /* n:"Font", */
  },
  579: {
    /* n:"BIFF3XF", */
    f: parse_BIFF3XF
  },
  1030: {
    /* n:"Formula", */
    f: parse_Formula
  },
  1033: {
    /* n:"BOF", */
    f: parse_BOF
  },
  1091: {
    /* n:"BIFF4XF", */
    f: parse_BIFF4XF
  },
  2157: {
    /* n:"FeatInfo", */
  },
  2163: {
    /* n:"FeatInfo11", */
  },
  2177: {
    /* n:"SXAddl12", */
  },
  2240: {
    /* n:"AutoWebPub", */
  },
  2241: {
    /* n:"ListObj", */
  },
  2242: {
    /* n:"ListField", */
  },
  2243: {
    /* n:"ListDV", */
  },
  2244: {
    /* n:"ListCondFmt", */
  },
  2245: {
    /* n:"ListCF", */
  },
  2246: {
    /* n:"FMQry", */
  },
  2247: {
    /* n:"FMSQry", */
  },
  2248: {
    /* n:"PLV", */
  },
  2249: {
    /* n:"LnExt", */
  },
  2250: {
    /* n:"MkrExt", */
  },
  2251: {
    /* n:"CrtCoopt", */
  },
  2262: {
    /* n:"FRTArchId$", */
    r: 12
  },
  /* --- multiplan 4 records --- */
  101: {
    /* n:"", */
  },
  // one per window
  102: {
    /* n:"", */
  },
  // calc settings
  105: {
    /* n:"", */
  },
  // print header
  106: {
    /* n:"", */
  },
  // print footer
  107: {
    /* n:"", */
  },
  // print settings
  109: {
    /* n:"", */
  },
  // one per window
  112: {
    /* n:"", */
  },
  // includes default col width
  114: {
    /* n:"", */
  },
  // includes selected cell
  29282: {}
};
function write_biff_rec(le, Y, re, oe) {
  var ue = Y;
  if (!isNaN(ue)) {
    var fe = oe || (re || []).length || 0, he = le.next(4);
    he.write_shift(2, ue), he.write_shift(2, fe), /*:: len != null &&*/
    fe > 0 && is_buf(re) && le.push(re);
  }
}
function write_biff_continue(le, Y, re, oe) {
  var ue = (re || []).length || 0;
  if (ue <= 8224) return write_biff_rec(le, Y, re, ue);
  var fe = Y;
  if (!isNaN(fe)) {
    for (var he = re.parts || [], _e = 0, ve = 0, xe = 0; xe + (he[_e] || 8224) <= 8224; )
      xe += he[_e] || 8224, _e++;
    var Ee = le.next(4);
    for (Ee.write_shift(2, fe), Ee.write_shift(2, xe), le.push(re.slice(ve, ve + xe)), ve += xe; ve < ue; ) {
      for (Ee = le.next(4), Ee.write_shift(2, 60), xe = 0; xe + (he[_e] || 8224) <= 8224; )
        xe += he[_e] || 8224, _e++;
      Ee.write_shift(2, xe), le.push(re.slice(ve, ve + xe)), ve += xe;
    }
  }
}
function write_BIFF2BERR(le, Y, re, oe) {
  var ue = new_buf(9);
  return write_BIFF2Cell(ue, le, Y), write_Bes(re, oe || "b", ue), ue;
}
function write_BIFF2LABEL(le, Y, re) {
  var oe = new_buf(8 + 2 * re.length);
  return write_BIFF2Cell(oe, le, Y), oe.write_shift(1, re.length), oe.write_shift(re.length, re, "sbcs"), oe.l < oe.length ? oe.slice(0, oe.l) : oe;
}
function write_comments_biff2(le, Y) {
  Y.forEach(function(re) {
    var oe = re[0].map(function(fe) {
      return fe.t;
    }).join("");
    if (oe.length <= 2048) return write_biff_rec(le, 28, write_NOTE_BIFF2(oe, re[1], re[2]));
    write_biff_rec(le, 28, write_NOTE_BIFF2(oe.slice(0, 2048), re[1], re[2], oe.length));
    for (var ue = 2048; ue < oe.length; ue += 2048)
      write_biff_rec(le, 28, write_NOTE_BIFF2(oe.slice(ue, Math.min(ue + 2048, oe.length)), -1, -1, Math.min(2048, oe.length - ue)));
  });
}
function write_ws_biff2_cell(le, Y, re, oe, ue, fe) {
  var he = 0;
  Y.z != null && (he = ue._BIFF2FmtTable.indexOf(Y.z), he == -1 && (ue._BIFF2FmtTable.push(Y.z), he = ue._BIFF2FmtTable.length - 1));
  var _e = 0;
  if (Y.z != null) {
    for (; _e < ue.cellXfs.length && ue.cellXfs[_e].numFmtId != he; ++_e) ;
    _e == ue.cellXfs.length && ue.cellXfs.push({ numFmtId: he });
  }
  if (Y.v != null) switch (Y.t) {
    case "d":
    case "n":
      var ve = Y.t == "d" ? datenum(parseDate(Y.v, fe), fe) : Y.v;
      ue.biff == 2 && ve == (ve | 0) && ve >= 0 && ve < 65536 ? write_biff_rec(le, 2, write_BIFF2INT(re, oe, ve, _e, he)) : isNaN(ve) ? write_biff_rec(le, 5, write_BIFF2BERR(re, oe, 36, "e")) : isFinite(ve) ? write_biff_rec(le, 3, write_BIFF2NUM(re, oe, ve, _e, he)) : write_biff_rec(le, 5, write_BIFF2BERR(re, oe, 7, "e"));
      return;
    case "b":
    case "e":
      write_biff_rec(le, 5, write_BIFF2BERR(re, oe, Y.v, Y.t));
      return;
    /* TODO: codepage, sst */
    case "s":
    case "str":
      write_biff_rec(le, 4, write_BIFF2LABEL(re, oe, Y.v == null ? "" : String(Y.v).slice(0, 255)));
      return;
  }
  write_biff_rec(le, 1, write_BIFF2Cell(null, re, oe));
}
function write_ws_biff2(le, Y, re, oe, ue) {
  var fe = Y["!data"] != null, he = safe_decode_range(Y["!ref"] || "A1"), _e = "", ve = [];
  if (he.e.c > 255 || he.e.r > 16383) {
    if (oe.WTF) throw new Error("Range " + (Y["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    he.e.c = Math.min(he.e.c, 255), he.e.r = Math.min(he.e.r, 16383);
  }
  for (var xe = (((ue || {}).Workbook || {}).WBProps || {}).date1904, Ee = [], Se = [], Te = he.s.c; Te <= he.e.c; ++Te) ve[Te] = encode_col(Te);
  for (var Ce = he.s.r; Ce <= he.e.r; ++Ce)
    for (fe && (Ee = Y["!data"][Ce] || []), _e = encode_row(Ce), Te = he.s.c; Te <= he.e.c; ++Te) {
      var Ie = fe ? Ee[Te] : Y[ve[Te] + _e];
      Ie && (write_ws_biff2_cell(le, Ie, Ce, Te, oe, xe), Ie.c && Se.push([Ie.c, Ce, Te]));
    }
  write_comments_biff2(le, Se);
}
function write_biff2_buf(le, Y) {
  for (var re = Y || {}, oe = buf_array(), ue = 0, fe = 0; fe < le.SheetNames.length; ++fe) le.SheetNames[fe] == re.sheet && (ue = fe);
  if (ue == 0 && re.sheet && le.SheetNames[0] != re.sheet) throw new Error("Sheet not found: " + re.sheet);
  write_biff_rec(oe, re.biff == 4 ? 1033 : re.biff == 3 ? 521 : 9, write_BOF(le, 16, re)), ((le.Workbook || {}).WBProps || {}).date1904 && write_biff_rec(oe, 34, writebool(!0)), re.cellXfs = [{ numFmtId: 0 }], re._BIFF2FmtTable = ["General"], re._Fonts = [];
  var he = buf_array();
  return write_ws_biff2(he, le.Sheets[le.SheetNames[ue]], ue, re, le), re._BIFF2FmtTable.forEach(function(_e) {
    re.biff <= 3 ? write_biff_rec(oe, 30, write_BIFF2Format(_e)) : write_biff_rec(oe, 1054, write_BIFF4Format(_e));
  }), re.cellXfs.forEach(function(_e) {
    switch (re.biff) {
      case 2:
        write_biff_rec(oe, 67, write_BIFF2XF(_e));
        break;
      case 3:
        write_biff_rec(oe, 579, write_BIFF3XF(_e));
        break;
      case 4:
        write_biff_rec(oe, 1091, write_BIFF4XF(_e));
        break;
    }
  }), delete re._BIFF2FmtTable, delete re.cellXfs, delete re._Fonts, oe.push(he.end()), write_biff_rec(oe, 10), oe.end();
}
var b8oid = 1, b8ocnts = [];
function write_MsoDrawingGroup() {
  var le = new_buf(82 + 8 * b8ocnts.length);
  le.write_shift(2, 15), le.write_shift(2, 61440), le.write_shift(4, 74 + 8 * b8ocnts.length);
  {
    le.write_shift(2, 0), le.write_shift(2, 61446), le.write_shift(4, 16 + 8 * b8ocnts.length);
    {
      le.write_shift(4, b8oid), le.write_shift(4, b8ocnts.length + 1);
      for (var Y = 0, re = 0; re < b8ocnts.length; ++re) Y += b8ocnts[re] && b8ocnts[re][1] || 0;
      le.write_shift(4, Y), le.write_shift(4, b8ocnts.length);
    }
    b8ocnts.forEach(function(oe) {
      le.write_shift(4, oe[0]), le.write_shift(4, oe[2]);
    });
  }
  return le.write_shift(2, 51), le.write_shift(2, 61451), le.write_shift(4, 18), le.write_shift(2, 191), le.write_shift(4, 524296), le.write_shift(2, 385), le.write_shift(4, 134217793), le.write_shift(2, 448), le.write_shift(4, 134217792), le.write_shift(2, 64), le.write_shift(2, 61726), le.write_shift(4, 16), le.write_shift(4, 134217741), le.write_shift(4, 134217740), le.write_shift(4, 134217751), le.write_shift(4, 268435703), le;
}
function write_comments_biff8(le, Y) {
  var re = [], oe = 0, ue = buf_array(), fe = b8oid, he;
  Y.forEach(function(ve, xe) {
    var Ee = "", Se = ve[0].map(function(Fe) {
      return Fe.a && !Ee && (Ee = Fe.a), Fe.t;
    }).join("");
    ++b8oid;
    {
      var Te = new_buf(150);
      Te.write_shift(2, 15), Te.write_shift(2, 61444), Te.write_shift(4, 150), Te.write_shift(2, 3234), Te.write_shift(2, 61450), Te.write_shift(4, 8), Te.write_shift(4, b8oid), Te.write_shift(4, 2560), Te.write_shift(2, 227), Te.write_shift(2, 61451), Te.write_shift(4, 84), Te.write_shift(2, 128), Te.write_shift(4, 0), Te.write_shift(2, 139), Te.write_shift(4, 2), Te.write_shift(2, 191), Te.write_shift(4, 524296), Te.write_shift(2, 344), Te.l += 4, Te.write_shift(2, 385), Te.write_shift(4, 134217808), Te.write_shift(2, 387), Te.write_shift(4, 134217808), Te.write_shift(2, 389), Te.write_shift(4, 268435700), Te.write_shift(2, 447), Te.write_shift(4, 1048592), Te.write_shift(2, 448), Te.write_shift(4, 134217809), Te.write_shift(2, 451), Te.write_shift(4, 268435700), Te.write_shift(2, 513), Te.write_shift(4, 134217809), Te.write_shift(2, 515), Te.write_shift(4, 268435700), Te.write_shift(2, 575), Te.write_shift(4, 196609), Te.write_shift(2, 959), Te.write_shift(4, 131072 | (ve[0].hidden ? 2 : 0)), Te.l += 2, Te.write_shift(2, 61456), Te.write_shift(4, 18), Te.write_shift(2, 3), Te.write_shift(2, ve[2] + 2), Te.l += 2, Te.write_shift(2, ve[1] + 1), Te.l += 2, Te.write_shift(2, ve[2] + 4), Te.l += 2, Te.write_shift(2, ve[1] + 5), Te.l += 2, Te.l += 2, Te.write_shift(2, 61457), Te.l += 4, Te.l = 150, xe == 0 ? he = Te : write_biff_rec(ue, 236, Te);
    }
    oe += 150;
    {
      var Ce = new_buf(52);
      Ce.write_shift(2, 21), Ce.write_shift(2, 18), Ce.write_shift(2, 25), Ce.write_shift(2, b8oid), Ce.write_shift(2, 0), Ce.l = 22, Ce.write_shift(2, 13), Ce.write_shift(2, 22), Ce.write_shift(4, 1651663474), Ce.write_shift(4, 2503426821), Ce.write_shift(4, 2150634280), Ce.write_shift(4, 1768515844 + b8oid * 256), Ce.write_shift(2, 0), Ce.write_shift(4, 0), Ce.l += 4, write_biff_rec(ue, 93, Ce);
    }
    {
      var Ie = new_buf(8);
      Ie.l += 2, Ie.write_shift(2, 61453), Ie.l += 4, write_biff_rec(ue, 236, Ie);
    }
    oe += 8;
    {
      var Ne = new_buf(18);
      Ne.write_shift(2, 18), Ne.l += 8, Ne.write_shift(2, Se.length), Ne.write_shift(2, 16), Ne.l += 4, write_biff_rec(ue, 438, Ne);
      {
        var Re = new_buf(1 + Se.length);
        Re.write_shift(1, 0), Re.write_shift(Se.length, Se, "sbcs"), write_biff_rec(ue, 60, Re);
      }
      {
        var Ae = new_buf(16);
        Ae.l += 8, Ae.write_shift(2, Se.length), Ae.l += 6, write_biff_rec(ue, 60, Ae);
      }
    }
    {
      var Pe = new_buf(12 + Ee.length);
      Pe.write_shift(2, ve[1]), Pe.write_shift(2, ve[2]), Pe.write_shift(2, 0 | (ve[0].hidden ? 0 : 2)), Pe.write_shift(2, b8oid), Pe.write_shift(2, Ee.length), Pe.write_shift(1, 0), Pe.write_shift(Ee.length, Ee, "sbcs"), Pe.l++, re.push(Pe);
    }
  });
  {
    var _e = new_buf(80);
    _e.write_shift(2, 15), _e.write_shift(2, 61442), _e.write_shift(4, oe + _e.length - 8), _e.write_shift(2, 16), _e.write_shift(2, 61448), _e.write_shift(4, 8), _e.write_shift(4, Y.length + 1), _e.write_shift(4, b8oid), _e.write_shift(2, 15), _e.write_shift(2, 61443), _e.write_shift(4, oe + 48), _e.write_shift(2, 15), _e.write_shift(2, 61444), _e.write_shift(4, 40), _e.write_shift(2, 1), _e.write_shift(2, 61449), _e.write_shift(4, 16), _e.l += 16, _e.write_shift(2, 2), _e.write_shift(2, 61450), _e.write_shift(4, 8), _e.write_shift(4, fe), _e.write_shift(4, 5), write_biff_rec(
      le,
      236,
      /* hdr */
      he ? bconcat([_e, he]) : _e
    );
  }
  le.push(ue.end()), re.forEach(function(ve) {
    write_biff_rec(le, 28, ve);
  }), b8ocnts.push([fe, Y.length + 1, b8oid]), ++b8oid;
}
function write_FONTS_biff8(le, Y, re) {
  write_biff_rec(le, 49, write_Font({
    sz: 12,
    name: "Arial"
  }, re));
}
function write_FMTS_biff8(le, Y, re) {
  Y && [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(oe) {
    for (var ue = oe[0]; ue <= oe[1]; ++ue) Y[ue] != null && write_biff_rec(le, 1054, write_Format(ue, Y[ue], re));
  });
}
function write_FEAT(le, Y) {
  var re = new_buf(19);
  re.write_shift(4, 2151), re.write_shift(4, 0), re.write_shift(4, 0), re.write_shift(2, 3), re.write_shift(1, 1), re.write_shift(4, 0), write_biff_rec(le, 2151, re), re = new_buf(39), re.write_shift(4, 2152), re.write_shift(4, 0), re.write_shift(4, 0), re.write_shift(2, 3), re.write_shift(1, 0), re.write_shift(4, 0), re.write_shift(2, 1), re.write_shift(4, 4), re.write_shift(2, 0), write_Ref8U(safe_decode_range(Y["!ref"] || "A1"), re), re.write_shift(4, 4), write_biff_rec(le, 2152, re);
}
function write_CELLXFS_biff8(le, Y) {
  for (var re = 0; re < 16; ++re) write_biff_rec(le, 224, write_XF({ numFmtId: 0, style: !0 }, 0, Y));
  Y.cellXfs.forEach(function(oe) {
    write_biff_rec(le, 224, write_XF(oe, 0, Y));
  });
}
function write_ws_biff8_hlinks(le, Y) {
  for (var re = 0; re < Y["!links"].length; ++re) {
    var oe = Y["!links"][re];
    write_biff_rec(le, 440, write_HLink(oe)), oe[1].Tooltip && write_biff_rec(le, 2048, write_HLinkTooltip(oe));
  }
  delete Y["!links"];
}
function write_ws_cols_biff8(le, Y) {
  if (Y) {
    var re = 0;
    Y.forEach(function(oe, ue) {
      ++re <= 256 && oe && write_biff_rec(le, 125, write_ColInfo(col_obj_w(ue, oe), ue));
    });
  }
}
function write_ws_biff8_cell(le, Y, re, oe, ue, fe) {
  var he = 16 + get_cell_style(ue.cellXfs, Y, ue);
  if (Y.v == null && !Y.bf) {
    write_biff_rec(le, 513, write_XLSCell(re, oe, he));
    return;
  }
  if (Y.bf) write_biff_rec(le, 6, write_Formula(Y, re, oe, ue, he));
  else switch (Y.t) {
    case "d":
    case "n":
      var _e = Y.t == "d" ? datenum(parseDate(Y.v, fe), fe) : Y.v;
      isNaN(_e) ? write_biff_rec(le, 517, write_BoolErr(re, oe, 36, he, ue, "e")) : isFinite(_e) ? write_biff_rec(le, 515, write_Number(re, oe, _e, he)) : write_biff_rec(le, 517, write_BoolErr(re, oe, 7, he, ue, "e"));
      break;
    case "b":
    case "e":
      write_biff_rec(le, 517, write_BoolErr(re, oe, Y.v, he, ue, Y.t));
      break;
    /* TODO: codepage, sst */
    case "s":
    case "str":
      if (ue.bookSST) {
        var ve = get_sst_id(ue.Strings, Y.v == null ? "" : String(Y.v), ue.revStrings);
        write_biff_rec(le, 253, write_LabelSst(re, oe, ve, he));
      } else write_biff_rec(le, 516, write_Label(re, oe, (Y.v == null ? "" : String(Y.v)).slice(0, 255), he, ue));
      break;
    default:
      write_biff_rec(le, 513, write_XLSCell(re, oe, he));
  }
}
function write_ws_biff8(le, Y, re) {
  var oe = buf_array(), ue = re.SheetNames[le], fe = re.Sheets[ue] || {}, he = (re || {}).Workbook || {}, _e = (he.Sheets || [])[le] || {}, ve = fe["!data"] != null, xe = Y.biff == 8, Ee = "", Se = [], Te = safe_decode_range(fe["!ref"] || "A1"), Ce = xe ? 65536 : 16384;
  if (Te.e.c > 255 || Te.e.r >= Ce) {
    if (Y.WTF) throw new Error("Range " + (fe["!ref"] || "A1") + " exceeds format limit A1:IV" + Ce);
    Te.e.c = Math.min(Te.e.c, 255), Te.e.r = Math.min(Te.e.r, Ce - 1);
  }
  write_biff_rec(oe, 2057, write_BOF(re, 16, Y)), write_biff_rec(oe, 13, writeuint16(1)), write_biff_rec(oe, 12, writeuint16(100)), write_biff_rec(oe, 15, writebool(!0)), write_biff_rec(oe, 17, writebool(!1)), write_biff_rec(oe, 16, write_Xnum(1e-3)), write_biff_rec(oe, 95, writebool(!0)), write_biff_rec(oe, 42, writebool(!1)), write_biff_rec(oe, 43, writebool(!1)), write_biff_rec(oe, 130, writeuint16(1)), write_biff_rec(oe, 128, write_Guts()), write_biff_rec(oe, 131, writebool(!1)), write_biff_rec(oe, 132, writebool(!1)), xe && write_ws_cols_biff8(oe, fe["!cols"]), write_biff_rec(oe, 512, write_Dimensions(Te, Y));
  var Ie = (((re || {}).Workbook || {}).WBProps || {}).date1904;
  xe && (fe["!links"] = []);
  for (var Ne = Te.s.c; Ne <= Te.e.c; ++Ne) Se[Ne] = encode_col(Ne);
  for (var Re = [], Ae = [], Pe = Te.s.r; Pe <= Te.e.r; ++Pe)
    for (ve && (Ae = fe["!data"][Pe] || []), Ee = encode_row(Pe), Ne = Te.s.c; Ne <= Te.e.c; ++Ne) {
      var Fe = ve ? Ae[Ne] : fe[Se[Ne] + Ee];
      Fe && (write_ws_biff8_cell(oe, Fe, Pe, Ne, Y, Ie), xe && Fe.l && fe["!links"].push([Se[Ne] + Ee, Fe.l]), Fe.c && Re.push([Fe.c, Pe, Ne]));
    }
  var Le = _e.CodeName || _e.name || ue;
  return xe ? write_comments_biff8(oe, Re) : write_comments_biff2(oe, Re), xe && write_biff_rec(oe, 574, write_Window2((he.Views || [])[0])), xe && (fe["!merges"] || []).length && write_biff_rec(oe, 229, write_MergeCells(fe["!merges"])), xe && write_ws_biff8_hlinks(oe, fe), write_biff_rec(oe, 442, write_XLUnicodeString(Le)), xe && write_FEAT(oe, fe), write_biff_rec(
    oe,
    10
    /* EOF */
  ), oe.end();
}
function write_biff8_global(le, Y, re) {
  var oe = buf_array(), ue = (le || {}).Workbook || {}, fe = ue.Sheets || [], he = (
    /*::((*/
    ue.WBProps || {
      /*::CodeName:"ThisWorkbook"*/
    }
  ), _e = re.biff == 8, ve = re.biff == 5;
  if (write_biff_rec(oe, 2057, write_BOF(le, 5, re)), re.bookType == "xla" && write_biff_rec(
    oe,
    135
    /* Addin */
  ), write_biff_rec(oe, 225, _e ? writeuint16(1200) : null), write_biff_rec(oe, 193, writezeroes(2)), ve && write_biff_rec(
    oe,
    191
    /* ToolbarHdr */
  ), ve && write_biff_rec(
    oe,
    192
    /* ToolbarEnd */
  ), write_biff_rec(
    oe,
    226
    /* InterfaceEnd */
  ), write_biff_rec(oe, 92, write_WriteAccess("SheetJS", re)), write_biff_rec(oe, 66, writeuint16(_e ? 1200 : 1252)), _e && write_biff_rec(oe, 353, writeuint16(0)), _e && write_biff_rec(
    oe,
    448
    /* Excel9File */
  ), write_biff_rec(oe, 317, write_RRTabId(le.SheetNames.length)), _e && le.vbaraw && write_biff_rec(
    oe,
    211
    /* ObProj */
  ), _e && le.vbaraw) {
    var xe = he.CodeName || "ThisWorkbook";
    write_biff_rec(oe, 442, write_XLUnicodeString(xe));
  }
  write_biff_rec(oe, 156, writeuint16(17)), write_biff_rec(oe, 25, writebool(!1)), write_biff_rec(oe, 18, writebool(!1)), write_biff_rec(oe, 19, writeuint16(0)), _e && write_biff_rec(oe, 431, writebool(!1)), _e && write_biff_rec(oe, 444, writeuint16(0)), write_biff_rec(oe, 61, write_Window1()), write_biff_rec(oe, 64, writebool(!1)), write_biff_rec(oe, 141, writeuint16(0)), write_biff_rec(oe, 34, writebool(safe1904(le) == "true")), write_biff_rec(oe, 14, writebool(!0)), _e && write_biff_rec(oe, 439, writebool(!1)), write_biff_rec(oe, 218, writeuint16(0)), write_FONTS_biff8(oe, le, re), write_FMTS_biff8(oe, le.SSF, re), write_CELLXFS_biff8(oe, re), _e && write_biff_rec(oe, 352, writebool(!1));
  var Ee = oe.end(), Se = buf_array();
  _e && write_biff_rec(Se, 140, write_Country()), _e && b8ocnts.length && write_biff_rec(Se, 235, write_MsoDrawingGroup()), _e && re.Strings && write_biff_continue(Se, 252, write_SST(re.Strings)), write_biff_rec(
    Se,
    10
    /* EOF */
  );
  var Te = Se.end(), Ce = buf_array(), Ie = 0, Ne = 0;
  for (Ne = 0; Ne < le.SheetNames.length; ++Ne) Ie += (_e ? 12 : 11) + (_e ? 2 : 1) * le.SheetNames[Ne].length;
  var Re = Ee.length + Ie + Te.length;
  for (Ne = 0; Ne < le.SheetNames.length; ++Ne) {
    var Ae = fe[Ne] || {};
    write_biff_rec(Ce, 133, write_BoundSheet8({ pos: Re, hs: Ae.Hidden || 0, dt: 0, name: le.SheetNames[Ne] }, re)), Re += Y[Ne].length;
  }
  var Pe = Ce.end();
  if (Ie != Pe.length) throw new Error("BS8 " + Ie + " != " + Pe.length);
  var Fe = [];
  return Ee.length && Fe.push(Ee), Pe.length && Fe.push(Pe), Te.length && Fe.push(Te), bconcat(Fe);
}
function write_biff8_buf(le, Y) {
  var re = Y || {}, oe = [];
  le && !le.SSF && (le.SSF = dup(table_fmt)), le && le.SSF && (make_ssf(), SSF_load_table(le.SSF), re.revssf = evert_num(le.SSF), re.revssf[le.SSF[65535]] = 0, re.ssf = le.SSF), b8oid = 1, b8ocnts = [], re.Strings = /*::((*/
  [], re.Strings.Count = 0, re.Strings.Unique = 0, fix_write_opts(re), re.cellXfs = [], get_cell_style(re.cellXfs, {}, { revssf: { General: 0 } }), le.Props || (le.Props = {});
  for (var ue = 0; ue < le.SheetNames.length; ++ue) oe[oe.length] = write_ws_biff8(ue, re, le);
  return oe.unshift(write_biff8_global(le, oe, re)), bconcat(oe);
}
function write_biff_buf(le, Y) {
  for (var re = 0; re <= le.SheetNames.length; ++re) {
    var oe = le.Sheets[le.SheetNames[re]];
    if (!(!oe || !oe["!ref"])) {
      var ue = decode_range(oe["!ref"]);
      ue.e.c > 255 && typeof console < "u" && console.error && console.error("Worksheet '" + le.SheetNames[re] + "' extends beyond column IV (255).  Data may be lost."), ue.e.r > 65535 && typeof console < "u" && console.error && console.error("Worksheet '" + le.SheetNames[re] + "' extends beyond row 65536.  Data may be lost.");
    }
  }
  var fe = Y || {};
  switch (fe.biff || 2) {
    case 8:
    case 5:
      return write_biff8_buf(le, Y);
    case 4:
    case 3:
    case 2:
      return write_biff2_buf(le, Y);
  }
  throw new Error("invalid type " + fe.bookType + " for BIFF");
}
function html_to_sheet(le, Y) {
  var re = Y || {}, oe = re.dense != null ? re.dense : DENSE, ue = {};
  oe && (ue["!data"] = []), le = str_remove_ng(le, "<!--", "-->");
  var fe = le.match(/<table/i);
  if (!fe) throw new Error("Invalid HTML: could not find <table>");
  var he = le.match(/<\/table/i), _e = fe.index, ve = he && he.index || le.length, xe = split_regex(le.slice(_e, ve), /(:?<tr[^<>]*>)/i, "<tr>"), Ee = -1, Se = 0, Te = 0, Ce = 0, Ie = { s: { r: 1e7, c: 1e7 }, e: { r: 0, c: 0 } }, Ne = [];
  for (_e = 0; _e < xe.length; ++_e) {
    var Re = xe[_e].trim(), Ae = Re.slice(0, 3).toLowerCase();
    if (Ae == "<tr") {
      if (++Ee, re.sheetRows && re.sheetRows <= Ee) {
        --Ee;
        break;
      }
      Se = 0;
      continue;
    }
    if (!(Ae != "<td" && Ae != "<th")) {
      var Pe = Re.split(/<\/t[dh]>/i);
      for (ve = 0; ve < Pe.length; ++ve) {
        var Fe = Pe[ve].trim();
        if (Fe.match(/<t[dh]/i)) {
          for (var Le = Fe, He = 0; Le.charAt(0) == "<" && (He = Le.indexOf(">")) > -1; ) Le = Le.slice(He + 1);
          for (var Ge = 0; Ge < Ne.length; ++Ge) {
            var Ve = Ne[Ge];
            Ve.s.c == Se && Ve.s.r < Ee && Ee <= Ve.e.r && (Se = Ve.e.c + 1, Ge = -1);
          }
          var $e = parsexmltag(Fe.slice(0, Fe.indexOf(">")));
          Ce = $e.colspan ? +$e.colspan : 1, ((Te = +$e.rowspan) > 1 || Ce > 1) && Ne.push({ s: { r: Ee, c: Se }, e: { r: Ee + (Te || 1) - 1, c: Se + Ce - 1 } });
          var De = $e.t || $e["data-t"] || "";
          if (!Le.length) {
            Se += Ce;
            continue;
          }
          if (Le = htmldecode(Le), Ie.s.r > Ee && (Ie.s.r = Ee), Ie.e.r < Ee && (Ie.e.r = Ee), Ie.s.c > Se && (Ie.s.c = Se), Ie.e.c < Se && (Ie.e.c = Se), !Le.length) {
            Se += Ce;
            continue;
          }
          var Ke = { t: "s", v: Le };
          re.raw || !Le.trim().length || De == "s" || (Le === "TRUE" ? Ke = { t: "b", v: !0 } : Le === "FALSE" ? Ke = { t: "b", v: !1 } : isNaN(fuzzynum(Le)) ? isNaN(fuzzydate(Le).getDate()) ? Le.charCodeAt(0) == 35 && RBErr[Le] != null && (Ke.t = "e", Ke.w = Le, Ke.v = RBErr[Le]) : (Ke = { t: "d", v: parseDate(Le) }, re.UTC === !1 && (Ke.v = utc_to_local(Ke.v)), re.cellDates || (Ke = { t: "n", v: datenum(Ke.v) }), Ke.z = re.dateNF || table_fmt[14]) : Ke = { t: "n", v: fuzzynum(Le) }), Ke.cellText !== !1 && (Ke.w = Le), oe ? (ue["!data"][Ee] || (ue["!data"][Ee] = []), ue["!data"][Ee][Se] = Ke) : ue[encode_cell({ r: Ee, c: Se })] = Ke, Se += Ce;
        }
      }
    }
  }
  return ue["!ref"] = encode_range(Ie), Ne.length && (ue["!merges"] = Ne), ue;
}
function make_html_row(le, Y, re, oe) {
  for (var ue = le["!merges"] || [], fe = [], he = {}, _e = le["!data"] != null, ve = Y.s.c; ve <= Y.e.c; ++ve) {
    for (var xe = 0, Ee = 0, Se = 0; Se < ue.length; ++Se)
      if (!(ue[Se].s.r > re || ue[Se].s.c > ve) && !(ue[Se].e.r < re || ue[Se].e.c < ve)) {
        if (ue[Se].s.r < re || ue[Se].s.c < ve) {
          xe = -1;
          break;
        }
        xe = ue[Se].e.r - ue[Se].s.r + 1, Ee = ue[Se].e.c - ue[Se].s.c + 1;
        break;
      }
    if (!(xe < 0)) {
      var Te = encode_col(ve) + encode_row(re), Ce = _e ? (le["!data"][re] || [])[ve] : le[Te];
      Ce && Ce.t == "n" && Ce.v != null && !isFinite(Ce.v) && (isNaN(Ce.v) ? Ce = { t: "e", v: 36, w: BErr[36] } : Ce = { t: "e", v: 7, w: BErr[7] });
      var Ie = Ce && Ce.v != null && (Ce.h || escapehtml(Ce.w || (format_cell(Ce), Ce.w) || "")) || "";
      he = {}, xe > 1 && (he.rowspan = xe), Ee > 1 && (he.colspan = Ee), oe.editable ? Ie = '<span contenteditable="true">' + Ie + "</span>" : Ce && (he["data-t"] = Ce && Ce.t || "z", Ce.v != null && (he["data-v"] = escapehtml(Ce.v instanceof Date ? Ce.v.toISOString() : Ce.v)), Ce.z != null && (he["data-z"] = Ce.z), Ce.l && (Ce.l.Target || "#").charAt(0) != "#" && (Ie = '<a href="' + escapehtml(Ce.l.Target) + '">' + Ie + "</a>")), he.id = (oe.id || "sjs") + "-" + Te, fe.push(writextag("td", Ie, he));
    }
  }
  var Ne = "<tr>";
  return Ne + fe.join("") + "</tr>";
}
var HTML_BEGIN = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>', HTML_END = "</body></html>";
function html_to_workbook(le, Y) {
  var re = str_match_xml_ig(le, "table");
  if (!re || re.length == 0) throw new Error("Invalid HTML: could not find <table>");
  if (re.length == 1) {
    var oe = sheet_to_workbook(html_to_sheet(re[0], Y), Y);
    return oe.bookType = "html", oe;
  }
  var ue = book_new();
  return re.forEach(function(fe, he) {
    book_append_sheet(ue, html_to_sheet(fe, Y), "Sheet" + (he + 1));
  }), ue.bookType = "html", ue;
}
function make_html_preamble(le, Y, re) {
  var oe = [];
  return oe.join("") + "<table" + (re && re.id ? ' id="' + re.id + '"' : "") + ">";
}
function sheet_to_html(le, Y) {
  var re = Y || {}, oe = re.header != null ? re.header : HTML_BEGIN, ue = re.footer != null ? re.footer : HTML_END, fe = [oe], he = decode_range(le["!ref"] || "A1");
  if (fe.push(make_html_preamble(le, he, re)), le["!ref"]) for (var _e = he.s.r; _e <= he.e.r; ++_e) fe.push(make_html_row(le, he, _e, re));
  return fe.push("</table>" + ue), fe.join("");
}
function sheet_add_dom(le, Y, re) {
  var oe = Y.rows;
  if (!oe)
    throw "Unsupported origin when " + Y.tagName + " is not a TABLE";
  var ue = re || {}, fe = le["!data"] != null, he = 0, _e = 0;
  if (ue.origin != null)
    if (typeof ue.origin == "number") he = ue.origin;
    else {
      var ve = typeof ue.origin == "string" ? decode_cell(ue.origin) : ue.origin;
      he = ve.r, _e = ve.c;
    }
  var xe = Math.min(ue.sheetRows || 1e7, oe.length), Ee = { s: { r: 0, c: 0 }, e: { r: he, c: _e } };
  if (le["!ref"]) {
    var Se = decode_range(le["!ref"]);
    Ee.s.r = Math.min(Ee.s.r, Se.s.r), Ee.s.c = Math.min(Ee.s.c, Se.s.c), Ee.e.r = Math.max(Ee.e.r, Se.e.r), Ee.e.c = Math.max(Ee.e.c, Se.e.c), he == -1 && (Ee.e.r = he = Se.e.r + 1);
  }
  var Te = [], Ce = 0, Ie = le["!rows"] || (le["!rows"] = []), Ne = 0, Re = 0, Ae = 0, Pe = 0, Fe = 0, Le = 0;
  for (le["!cols"] || (le["!cols"] = []); Ne < oe.length && Re < xe; ++Ne) {
    var He = oe[Ne];
    if (is_dom_element_hidden(He)) {
      if (ue.display) continue;
      Ie[Re] = { hidden: !0 };
    }
    var Ge = He.cells;
    for (Ae = Pe = 0; Ae < Ge.length; ++Ae) {
      var Ve = Ge[Ae];
      if (!(ue.display && is_dom_element_hidden(Ve))) {
        var $e = Ve.hasAttribute("data-v") ? Ve.getAttribute("data-v") : Ve.hasAttribute("v") ? Ve.getAttribute("v") : htmldecode(Ve.innerHTML), De = Ve.getAttribute("data-z") || Ve.getAttribute("z");
        for (Ce = 0; Ce < Te.length; ++Ce) {
          var Ke = Te[Ce];
          Ke.s.c == Pe + _e && Ke.s.r < Re + he && Re + he <= Ke.e.r && (Pe = Ke.e.c + 1 - _e, Ce = -1);
        }
        Le = +Ve.getAttribute("colspan") || 1, ((Fe = +Ve.getAttribute("rowspan") || 1) > 1 || Le > 1) && Te.push({ s: { r: Re + he, c: Pe + _e }, e: { r: Re + he + (Fe || 1) - 1, c: Pe + _e + (Le || 1) - 1 } });
        var ze = { t: "s", v: $e }, tt = Ve.getAttribute("data-t") || Ve.getAttribute("t") || "";
        $e != null && ($e.length == 0 ? ze.t = tt || "z" : ue.raw || $e.trim().length == 0 || tt == "s" || (tt == "e" && BErr[+$e] ? ze = { t: "e", v: +$e, w: BErr[+$e] } : $e === "TRUE" ? ze = { t: "b", v: !0 } : $e === "FALSE" ? ze = { t: "b", v: !1 } : isNaN(fuzzynum($e)) ? isNaN(fuzzydate($e).getDate()) ? $e.charCodeAt(0) == 35 && RBErr[$e] != null && (ze = { t: "e", v: RBErr[$e], w: $e }) : (ze = { t: "d", v: parseDate($e) }, ue.UTC && (ze.v = local_to_utc(ze.v)), ue.cellDates || (ze = { t: "n", v: datenum(ze.v) }), ze.z = ue.dateNF || table_fmt[14]) : ze = { t: "n", v: fuzzynum($e) })), ze.z === void 0 && De != null && (ze.z = De);
        var Xe = "", mt = Ve.getElementsByTagName("A");
        if (mt && mt.length) for (var at = 0; at < mt.length && !(mt[at].hasAttribute("href") && (Xe = mt[at].getAttribute("href"), Xe.charAt(0) != "#")); ++at) ;
        Xe && Xe.charAt(0) != "#" && Xe.slice(0, 11).toLowerCase() != "javascript:" && (ze.l = { Target: Xe }), fe ? (le["!data"][Re + he] || (le["!data"][Re + he] = []), le["!data"][Re + he][Pe + _e] = ze) : le[encode_cell({ c: Pe + _e, r: Re + he })] = ze, Ee.e.c < Pe + _e && (Ee.e.c = Pe + _e), Pe += Le;
      }
    }
    ++Re;
  }
  return Te.length && (le["!merges"] = (le["!merges"] || []).concat(Te)), Ee.e.r = Math.max(Ee.e.r, Re - 1 + he), le["!ref"] = encode_range(Ee), Re >= xe && (le["!fullref"] = encode_range((Ee.e.r = oe.length - Ne + Re - 1 + he, Ee))), le;
}
function parse_dom_table(le, Y) {
  var re = Y || {}, oe = {};
  return re.dense && (oe["!data"] = []), sheet_add_dom(oe, le, Y);
}
function table_to_book(le, Y) {
  var re = sheet_to_workbook(parse_dom_table(le, Y), Y);
  return re;
}
function is_dom_element_hidden(le) {
  var Y = "", re = get_get_computed_style_function(le);
  return re && (Y = re(le).getPropertyValue("display")), Y || (Y = le.style && le.style.display), Y === "none";
}
function get_get_computed_style_function(le) {
  return le.ownerDocument.defaultView && typeof le.ownerDocument.defaultView.getComputedStyle == "function" ? le.ownerDocument.defaultView.getComputedStyle : typeof getComputedStyle == "function" ? getComputedStyle : null;
}
function parse_text_p(le) {
  var Y = le.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ").replace(/<text:s\/>/g, " ").replace(/<text:s text:c="(\d+)"\/>/g, function(oe, ue) {
    return Array(parseInt(ue, 10) + 1).join(" ");
  }).replace(/<text:tab[^<>]*\/>/g, "	").replace(/<text:line-break\/>/g, `
`), re = unescapexml(Y.replace(/<[^<>]*>/g, ""));
  return [re];
}
function parse_ods_styles(le, Y, re) {
  var oe = re || {}, ue = xlml_normalize(le);
  xlmlregex.lastIndex = 0, ue = remove_doctype(str_remove_ng(ue, "<!--", "-->"));
  for (var fe, he, _e = "", ve = "", xe, Ee = 0, Se = -1, Te = ""; fe = xlmlregex.exec(ue); )
    switch (fe[3] = fe[3].replace(/_[\s\S]*$/, "")) {
      /* Number Format Definitions */
      case "number-style":
      // <number:number-style> 16.29.2
      case "currency-style":
      // <number:currency-style> 16.29.8
      case "percentage-style":
      // <number:percentage-style> 16.29.10
      case "date-style":
      // <number:date-style> 16.29.11
      case "time-style":
      // <number:time-style> 16.29.19
      case "text-style":
        fe[1] === "/" ? (he["truncate-on-overflow"] == "false" && (_e.match(/h/) ? _e = _e.replace(/h+/, "[$&]") : _e.match(/m/) ? _e = _e.replace(/m+/, "[$&]") : _e.match(/s/) && (_e = _e.replace(/s+/, "[$&]"))), oe[he.name] = _e, _e = "") : fe[0].charAt(fe[0].length - 2) !== "/" && (_e = "", he = parsexmltag(fe[0], !1));
        break;
      // LibreOffice bug https://bugs.documentfoundation.org/show_bug.cgi?id=149484
      case "boolean-style":
        fe[1] === "/" ? (oe[he.name] = "General", _e = "") : fe[0].charAt(fe[0].length - 2) !== "/" && (_e = "", he = parsexmltag(fe[0], !1));
        break;
      /* Number Format Elements */
      case "boolean":
        _e += "General";
        break;
      case "text":
        fe[1] === "/" ? (Te = ue.slice(Se, xlmlregex.lastIndex - fe[0].length), Te == "%" && he[0] == "<number:percentage-style" ? _e += "%" : _e += '"' + Te.replace(/"/g, '""') + '"') : fe[0].charAt(fe[0].length - 2) !== "/" && (Se = xlmlregex.lastIndex);
        break;
      case "day":
        switch (xe = parsexmltag(fe[0], !1), xe.style) {
          case "short":
            _e += "d";
            break;
          case "long":
            _e += "dd";
            break;
          default:
            _e += "dd";
            break;
        }
        break;
      case "day-of-week":
        switch (xe = parsexmltag(fe[0], !1), xe.style) {
          case "short":
            _e += "ddd";
            break;
          case "long":
            _e += "dddd";
            break;
          default:
            _e += "ddd";
            break;
        }
        break;
      case "era":
        switch (xe = parsexmltag(fe[0], !1), xe.style) {
          case "short":
            _e += "ee";
            break;
          case "long":
            _e += "eeee";
            break;
          default:
            _e += "eeee";
            break;
        }
        break;
      case "hours":
        switch (xe = parsexmltag(fe[0], !1), xe.style) {
          case "short":
            _e += "h";
            break;
          case "long":
            _e += "hh";
            break;
          default:
            _e += "hh";
            break;
        }
        break;
      case "minutes":
        switch (xe = parsexmltag(fe[0], !1), xe.style) {
          case "short":
            _e += "m";
            break;
          case "long":
            _e += "mm";
            break;
          default:
            _e += "mm";
            break;
        }
        break;
      case "month":
        switch (xe = parsexmltag(fe[0], !1), xe.textual && (_e += "mm"), xe.style) {
          case "short":
            _e += "m";
            break;
          case "long":
            _e += "mm";
            break;
          default:
            _e += "m";
            break;
        }
        break;
      case "seconds":
        {
          switch (xe = parsexmltag(fe[0], !1), xe.style) {
            case "short":
              _e += "s";
              break;
            case "long":
              _e += "ss";
              break;
            default:
              _e += "ss";
              break;
          }
          xe["decimal-places"] && (_e += "." + fill("0", +xe["decimal-places"]));
        }
        break;
      case "year":
        switch (xe = parsexmltag(fe[0], !1), xe.style) {
          case "short":
            _e += "yy";
            break;
          case "long":
            _e += "yyyy";
            break;
          default:
            _e += "yy";
            break;
        }
        break;
      case "am-pm":
        _e += "AM/PM";
        break;
      case "week-of-year":
      // <number:week-of-year> 16.29.17
      case "quarter":
        console.error("Excel does not support ODS format token " + fe[3]);
        break;
      case "fill-character":
        fe[1] === "/" ? (Te = ue.slice(Se, xlmlregex.lastIndex - fe[0].length), _e += '"' + Te.replace(/"/g, '""') + '"*') : fe[0].charAt(fe[0].length - 2) !== "/" && (Se = xlmlregex.lastIndex);
        break;
      case "scientific-number":
        xe = parsexmltag(fe[0], !1), _e += "0." + fill("0", +xe["min-decimal-places"] || +xe["decimal-places"] || 2) + fill("?", +xe["decimal-places"] - +xe["min-decimal-places"] || 0) + "E" + (parsexmlbool(xe["forced-exponent-sign"]) ? "+" : "") + fill("0", +xe["min-exponent-digits"] || 2);
        break;
      case "fraction":
        xe = parsexmltag(fe[0], !1), +xe["min-integer-digits"] ? _e += fill("0", +xe["min-integer-digits"]) : _e += "#", _e += " ", _e += fill("?", +xe["min-numerator-digits"] || 1), _e += "/", +xe["denominator-value"] ? _e += xe["denominator-value"] : _e += fill("?", +xe["min-denominator-digits"] || 1);
        break;
      case "currency-symbol":
        fe[1] === "/" ? _e += '"' + ue.slice(Se, xlmlregex.lastIndex - fe[0].length).replace(/"/g, '""') + '"' : fe[0].charAt(fe[0].length - 2) !== "/" ? Se = xlmlregex.lastIndex : _e += "$";
        break;
      case "text-properties":
        switch (xe = parsexmltag(fe[0], !1), (xe.color || "").toLowerCase().replace("#", "")) {
          case "ff0000":
          case "red":
            _e = "[Red]" + _e;
            break;
        }
        break;
      case "text-content":
        _e += "@";
        break;
      case "map":
        xe = parsexmltag(fe[0], !1), unescapexml(xe.condition) == "value()>=0" ? _e = oe[xe["apply-style-name"]] + ";" + _e : console.error("ODS number format may be incorrect: " + xe.condition);
        break;
      case "number":
        if (fe[1] === "/") break;
        xe = parsexmltag(fe[0], !1), ve = "", ve += fill("0", +xe["min-integer-digits"] || 1), parsexmlbool(xe.grouping) && (ve = commaify(fill("#", Math.max(0, 4 - ve.length)) + ve)), (+xe["min-decimal-places"] || +xe["decimal-places"]) && (ve += "."), +xe["min-decimal-places"] && (ve += fill("0", +xe["min-decimal-places"] || 1)), +xe["decimal-places"] - (+xe["min-decimal-places"] || 0) && (ve += fill("0", +xe["decimal-places"] - (+xe["min-decimal-places"] || 0))), _e += ve;
        break;
      case "embedded-text":
        fe[1] === "/" ? Ee == 0 ? _e += '"' + ue.slice(Se, xlmlregex.lastIndex - fe[0].length).replace(/"/g, '""') + '"' : _e = _e.slice(0, Ee) + '"' + ue.slice(Se, xlmlregex.lastIndex - fe[0].length).replace(/"/g, '""') + '"' + _e.slice(Ee) : fe[0].charAt(fe[0].length - 2) !== "/" && (Se = xlmlregex.lastIndex, Ee = -+parsexmltag(fe[0], !1).position || 0);
        break;
    }
  return oe;
}
function parse_content_xml(le, Y, re) {
  var oe = Y || {}, ue = xlml_normalize(le), fe = [], he, _e, ve, xe = "", Ee = 0, Se, Te, Ce = {}, Ie = [], Ne = {};
  oe.dense && (Ne["!data"] = []);
  var Re, Ae, Pe = { value: "" }, Fe = {}, Le = "", He = 0, Ge = "", Ve = 0, $e = [], De = [], Ke = -1, ze = -1, tt = { s: { r: 1e6, c: 1e7 }, e: { r: 0, c: 0 } }, Xe = 0, mt = re || {}, at = {}, qe = [], st = {}, xt = 0, gt = 0, Ze = [], _t = 1, wt = 1, yt = [], St = { Names: [], WBProps: {} }, It = {}, Bt = ["", ""], Ye = [], Be = {}, et = "", je = 0, it = !1, bt = !1, rt = 0;
  for (xlmlregex.lastIndex = 0, ue = remove_doctype(str_remove_ng(ue, "<!--", "-->")); Re = xlmlregex.exec(ue); ) switch (Re[3] = Re[3].replace(/_[\s\S]*$/, "")) {
    case "table":
    case "工作表":
      Re[1] === "/" ? (tt.e.c >= tt.s.c && tt.e.r >= tt.s.r ? Ne["!ref"] = encode_range(tt) : Ne["!ref"] = "A1:A1", oe.sheetRows > 0 && oe.sheetRows <= tt.e.r && (Ne["!fullref"] = Ne["!ref"], tt.e.r = oe.sheetRows - 1, Ne["!ref"] = encode_range(tt)), qe.length && (Ne["!merges"] = qe), Ze.length && (Ne["!rows"] = Ze), Se.name = Se.名称 || Se.name, typeof JSON < "u" && JSON.stringify(Se), Ie.push(Se.name), Ce[Se.name] = Ne, bt = !1) : Re[0].charAt(Re[0].length - 2) !== "/" && (Se = parsexmltag(Re[0], !1), Ke = ze = -1, tt.s.r = tt.s.c = 1e7, tt.e.r = tt.e.c = 0, Ne = {}, oe.dense && (Ne["!data"] = []), qe = [], Ze = [], bt = !0);
      break;
    case "table-row-group":
      Re[1] === "/" ? --Xe : ++Xe;
      break;
    case "table-row":
    case "行":
      if (Re[1] === "/") {
        Ke += _t, _t = 1;
        break;
      }
      if (Te = parsexmltag(Re[0], !1), Te.行号 ? Ke = Te.行号 - 1 : Ke == -1 && (Ke = 0), _t = +Te["number-rows-repeated"] || 1, _t < 10) for (rt = 0; rt < _t; ++rt) Xe > 0 && (Ze[Ke + rt] = { level: Xe });
      ze = -1;
      break;
    case "covered-table-cell":
      if (Re[1] !== "/")
        if (++ze, Pe = parsexmltag(Re[0], !1), wt = parseInt(Pe["number-columns-repeated"] || "1", 10) || 1, oe.sheetStubs) {
          for (; wt-- > 0; )
            oe.dense ? (Ne["!data"][Ke] || (Ne["!data"][Ke] = []), Ne["!data"][Ke][ze] = { t: "z" }) : Ne[encode_cell({ r: Ke, c: ze })] = { t: "z" }, ++ze;
          --ze;
        } else ze += wt - 1;
      Le = "", $e = [];
      break;
    /* stub */
    case "table-cell":
    case "数据":
      if (Re[0].charAt(Re[0].length - 2) === "/")
        ++ze, Pe = parsexmltag(Re[0], !1), wt = parseInt(Pe["number-columns-repeated"] || "1", 10) || 1, Ae = {
          t: "z",
          v: null
          /*:: , z:null, w:"",c:[]*/
        }, Pe.formula && oe.cellFormula != !1 && (Ae.f = ods_to_csf_formula(unescapexml(Pe.formula))), Pe["style-name"] && at[Pe["style-name"]] && (Ae.z = at[Pe["style-name"]]), (Pe.数据类型 || Pe["value-type"]) == "string" && (Ae.t = "s", Ae.v = unescapexml(Pe["string-value"] || ""), oe.dense ? (Ne["!data"][Ke] || (Ne["!data"][Ke] = []), Ne["!data"][Ke][ze] = Ae) : Ne[encode_col(ze) + encode_row(Ke)] = Ae), ze += wt - 1;
      else if (Re[1] !== "/") {
        ++ze, Le = Ge = "", He = Ve = 0, $e = [], De = [], wt = 1;
        var Ct = _t ? Ke + _t - 1 : Ke;
        if (ze > tt.e.c && (tt.e.c = ze), ze < tt.s.c && (tt.s.c = ze), Ke < tt.s.r && (tt.s.r = Ke), Ct > tt.e.r && (tt.e.r = Ct), Pe = parsexmltag(Re[0], !1), Fe = parsexmltagraw(Re[0]), Ye = [], Be = {}, Ae = {
          t: Pe.数据类型 || Pe["value-type"],
          v: null
          /*:: , z:null, w:"",c:[]*/
        }, Pe["style-name"] && at[Pe["style-name"]] && (Ae.z = at[Pe["style-name"]]), oe.cellFormula)
          if (Pe.formula && (Pe.formula = unescapexml(Pe.formula)), Pe["number-matrix-columns-spanned"] && Pe["number-matrix-rows-spanned"] && (xt = parseInt(Pe["number-matrix-rows-spanned"], 10) || 0, gt = parseInt(Pe["number-matrix-columns-spanned"], 10) || 0, st = { s: { r: Ke, c: ze }, e: { r: Ke + xt - 1, c: ze + gt - 1 } }, Ae.F = encode_range(st), yt.push([st, Ae.F])), Pe.formula) Ae.f = ods_to_csf_formula(Pe.formula);
          else for (rt = 0; rt < yt.length; ++rt)
            Ke >= yt[rt][0].s.r && Ke <= yt[rt][0].e.r && ze >= yt[rt][0].s.c && ze <= yt[rt][0].e.c && (Ae.F = yt[rt][1]);
        switch ((Pe["number-columns-spanned"] || Pe["number-rows-spanned"]) && (xt = parseInt(Pe["number-rows-spanned"] || "1", 10) || 1, gt = parseInt(Pe["number-columns-spanned"] || "1", 10) || 1, xt * gt > 1 && (st = { s: { r: Ke, c: ze }, e: { r: Ke + xt - 1, c: ze + gt - 1 } }, qe.push(st))), Pe["number-columns-repeated"] && (wt = parseInt(Pe["number-columns-repeated"], 10)), Ae.t) {
          case "boolean":
            Ae.t = "b", Ae.v = parsexmlbool(Pe["boolean-value"]) || +Pe["boolean-value"] >= 1;
            break;
          case "float":
            Ae.t = "n", Ae.v = parseFloat(Pe.value), oe.cellDates && Ae.z && fmt_is_date(Ae.z) && (Ae.v = numdate(Ae.v + (St.WBProps.date1904 ? 1462 : 0)), Ae.t = typeof Ae.v == "number" ? "n" : "d");
            break;
          case "percentage":
            Ae.t = "n", Ae.v = parseFloat(Pe.value);
            break;
          case "currency":
            Ae.t = "n", Ae.v = parseFloat(Pe.value);
            break;
          case "date":
            Ae.t = "d", Ae.v = parseDate(Pe["date-value"], St.WBProps.date1904), oe.cellDates || (Ae.t = "n", Ae.v = datenum(Ae.v, St.WBProps.date1904)), Ae.z || (Ae.z = "m/d/yy");
            break;
          /* NOTE: for `time`, Excel ODS export incorrectly uses durations relative to 1900 epoch even if 1904 is specified */
          case "time":
            Ae.t = "n", Ae.v = parse_isodur(Pe["time-value"]) / 86400, oe.cellDates && (Ae.v = numdate(Ae.v), Ae.t = typeof Ae.v == "number" ? "n" : "d"), Ae.z || (Ae.z = "HH:MM:SS");
            break;
          case "number":
            Ae.t = "n", Ae.v = parseFloat(Pe.数据数值);
            break;
          default:
            if (Ae.t === "string" || Ae.t === "text" || !Ae.t)
              Ae.t = "s", Pe["string-value"] != null && (Le = unescapexml(Pe["string-value"]), $e = []);
            else throw new Error("Unsupported value type " + Ae.t);
        }
      } else {
        if (it = !1, Fe["calcext:value-type"] == "error" && RBErr[Le] != null && (Ae.t = "e", Ae.w = Le, Ae.v = RBErr[Le]), Ae.t === "s" && (Ae.v = Le || "", $e.length && (Ae.R = $e), it = He == 0), It.Target && (Ae.l = It), Ye.length > 0 && (Ae.c = Ye, Ye = []), Le && oe.cellText !== !1 && (Ae.w = Le), it && (Ae.t = "z", delete Ae.v), (!it || oe.sheetStubs) && !(oe.sheetRows && oe.sheetRows <= Ke))
          for (var Rt = 0; Rt < _t; ++Rt) {
            if (wt = parseInt(Pe["number-columns-repeated"] || "1", 10), oe.dense)
              for (Ne["!data"][Ke + Rt] || (Ne["!data"][Ke + Rt] = []), Ne["!data"][Ke + Rt][ze] = Rt == 0 ? Ae : dup(Ae); --wt > 0; ) Ne["!data"][Ke + Rt][ze + wt] = dup(Ae);
            else
              for (Ne[encode_cell({ r: Ke + Rt, c: ze })] = Ae; --wt > 0; ) Ne[encode_cell({ r: Ke + Rt, c: ze + wt })] = dup(Ae);
            tt.e.c <= ze && (tt.e.c = ze);
          }
        wt = parseInt(Pe["number-columns-repeated"] || "1", 10), ze += wt - 1, wt = 0, Ae = {
          /*:: t:"", v:null, z:null, w:"",c:[]*/
        }, Le = "", $e = [];
      }
      It = {};
      break;
    // 9.1.4 <table:table-cell>
    /* pure state */
    case "document":
    // TODO: <office:document> is the root for FODS
    case "document-content":
    case "电子表格文档":
    // 3.1.3.2 <office:document-content>
    case "spreadsheet":
    case "主体":
    // 3.7 <office:spreadsheet>
    case "scripts":
    // 3.12 <office:scripts>
    case "styles":
    // TODO <office:styles>
    case "font-face-decls":
    // 3.14 <office:font-face-decls>
    case "master-styles":
      if (Re[1] === "/") {
        if ((he = fe.pop())[0] !== Re[3]) throw "Bad state: " + he;
      } else Re[0].charAt(Re[0].length - 2) !== "/" && fe.push([Re[3], !0]);
      break;
    case "annotation":
      if (Re[1] === "/") {
        if ((he = fe.pop())[0] !== Re[3]) throw "Bad state: " + he;
        Be.t = Le, $e.length && (Be.R = $e), Be.a = et, Ye.push(Be), Le = Ge, He = Ve, $e = De;
      } else if (Re[0].charAt(Re[0].length - 2) !== "/") {
        fe.push([Re[3], !1]);
        var Ot = parsexmltag(Re[0], !0);
        Ot.display && parsexmlbool(Ot.display) || (Ye.hidden = !0), Ge = Le, Ve = He, De = $e, Le = "", He = 0, $e = [];
      }
      et = "", je = 0;
      break;
    case "creator":
      Re[1] === "/" ? et = ue.slice(je, Re.index) : je = Re.index + Re[0].length;
      break;
    /* ignore state */
    case "meta":
    case "元数据":
    // TODO: <office:meta> <uof:元数据> FODS/UOF
    case "settings":
    // TODO: <office:settings>
    case "config-item-set":
    // TODO: <office:config-item-set>
    case "config-item-map-indexed":
    // TODO: <office:config-item-map-indexed>
    case "config-item-map-entry":
    // TODO: <office:config-item-map-entry>
    case "config-item-map-named":
    // TODO: <office:config-item-map-entry>
    case "shapes":
    // 9.2.8 <table:shapes>
    case "frame":
    // 10.4.2 <draw:frame>
    case "text-box":
    // 10.4.3 <draw:text-box>
    case "image":
    // 10.4.4 <draw:image>
    case "data-pilot-tables":
    // 9.6.2 <table:data-pilot-tables>
    case "list-style":
    // 16.30 <text:list-style>
    case "form":
    // 13.13 <form:form>
    case "dde-links":
    // 9.8 <table:dde-links>
    case "event-listeners":
    // TODO
    case "chart":
      if (Re[1] === "/") {
        if ((he = fe.pop())[0] !== Re[3]) throw "Bad state: " + he;
      } else Re[0].charAt(Re[0].length - 2) !== "/" && fe.push([Re[3], !1]);
      Le = "", He = 0, $e = [];
      break;
    case "scientific-number":
    // <number:scientific-number>
    case "currency-symbol":
    // <number:currency-symbol>
    case "fill-character":
      break;
    case "text-style":
    // 16.27.25 <number:text-style>
    case "boolean-style":
    // 16.27.23 <number:boolean-style>
    case "number-style":
    // 16.27.2 <number:number-style>
    case "currency-style":
    // 16.29.8 <number:currency-style>
    case "percentage-style":
    // 16.27.9 <number:percentage-style>
    case "date-style":
    // 16.27.10 <number:date-style>
    case "time-style":
      if (Re[1] === "/") {
        var Mt = xlmlregex.lastIndex;
        parse_ods_styles(ue.slice(ve, xlmlregex.lastIndex), Y, mt), xlmlregex.lastIndex = Mt;
      } else Re[0].charAt(Re[0].length - 2) !== "/" && (ve = xlmlregex.lastIndex - Re[0].length);
      break;
    case "script":
      break;
    // 3.13 <office:script>
    case "libraries":
      break;
    // TODO: <ooo:libraries>
    case "automatic-styles":
      break;
    // 3.15.3 <office:automatic-styles>
    case "default-style":
    // TODO: <style:default-style>
    case "page-layout":
      break;
    // TODO: <style:page-layout>
    case "style":
      {
        var Dt = parsexmltag(Re[0], !1);
        Dt.family == "table-cell" && mt[Dt["data-style-name"]] && (at[Dt.name] = mt[Dt["data-style-name"]]);
      }
      break;
    case "map":
      break;
    // 16.3 <style:map>
    case "font-face":
      break;
    // 16.21 <style:font-face>
    case "paragraph-properties":
      break;
    // 17.6 <style:paragraph-properties>
    case "table-properties":
      break;
    // 17.15 <style:table-properties>
    case "table-column-properties":
      break;
    // 17.16 <style:table-column-properties>
    case "table-row-properties":
      break;
    // 17.17 <style:table-row-properties>
    case "table-cell-properties":
      break;
    // 17.18 <style:table-cell-properties>
    case "number":
      break;
    case "fraction":
      break;
    // TODO 16.27.6 <number:fraction>
    case "day":
    // 16.27.11 <number:day>
    case "month":
    // 16.27.12 <number:month>
    case "year":
    // 16.27.13 <number:year>
    case "era":
    // 16.27.14 <number:era>
    case "day-of-week":
    // 16.27.15 <number:day-of-week>
    case "week-of-year":
    // 16.27.16 <number:week-of-year>
    case "quarter":
    // 16.27.17 <number:quarter>
    case "hours":
    // 16.27.19 <number:hours>
    case "minutes":
    // 16.27.20 <number:minutes>
    case "seconds":
    // 16.27.21 <number:seconds>
    case "am-pm":
      break;
    case "boolean":
      break;
    // 16.27.24 <number:boolean>
    case "text":
      if (Re[0].slice(-2) === "/>") break;
      if (Re[1] === "/") switch (fe[fe.length - 1][0]) {
        case "number-style":
        case "date-style":
        case "time-style":
          xe += ue.slice(Ee, Re.index);
          break;
      }
      else Ee = Re.index + Re[0].length;
      break;
    case "named-range":
      _e = parsexmltag(Re[0], !1), Bt = ods_to_csf_3D(_e["cell-range-address"]);
      var Vt = { Name: _e.name, Ref: Bt[0] + "!" + Bt[1] };
      bt && (Vt.Sheet = Ie.length), St.Names.push(Vt);
      break;
    case "text-content":
      break;
    // 16.27.27 <number:text-content>
    case "text-properties":
      break;
    // 16.27.27 <style:text-properties>
    case "embedded-text":
      break;
    // 16.27.4 <number:embedded-text>
    case "body":
    case "电子表格":
      break;
    // 3.3 16.9.6 19.726.3
    case "forms":
      break;
    // 12.25.2 13.2
    case "table-column":
      break;
    // 9.1.6 <table:table-column>
    case "table-header-rows":
      break;
    // 9.1.7 <table:table-header-rows>
    case "table-rows":
      break;
    // 9.1.12 <table:table-rows>
    /* TODO: outline levels */
    case "table-column-group":
      break;
    // 9.1.10 <table:table-column-group>
    case "table-header-columns":
      break;
    // 9.1.11 <table:table-header-columns>
    case "table-columns":
      break;
    // 9.1.12 <table:table-columns>
    case "null-date":
      switch (_e = parsexmltag(Re[0], !1), _e["date-value"]) {
        case "1904-01-01":
          St.WBProps.date1904 = !0;
          break;
      }
      break;
    case "graphic-properties":
      break;
    // 17.21 <style:graphic-properties>
    case "calculation-settings":
      break;
    // 9.4.1 <table:calculation-settings>
    case "named-expressions":
      break;
    // 9.4.11 <table:named-expressions>
    case "label-range":
      break;
    // 9.4.9 <table:label-range>
    case "label-ranges":
      break;
    // 9.4.10 <table:label-ranges>
    case "named-expression":
      break;
    // 9.4.13 <table:named-expression>
    case "sort":
      break;
    // 9.4.19 <table:sort>
    case "sort-by":
      break;
    // 9.4.20 <table:sort-by>
    case "sort-groups":
      break;
    // 9.4.22 <table:sort-groups>
    case "tab":
      break;
    // 6.1.4 <text:tab>
    case "line-break":
      break;
    // 6.1.5 <text:line-break>
    case "span":
      break;
    // 6.1.7 <text:span>
    case "p":
    case "文本串":
      if (["master-styles"].indexOf(fe[fe.length - 1][0]) > -1) break;
      if (Re[1] === "/" && (!Pe || !Pe["string-value"])) {
        var Jt = parse_text_p(ue.slice(He, Re.index));
        Le = (Le.length > 0 ? Le + `
` : "") + Jt[0];
      } else Re[0].slice(-2) == "/>" ? Le += `
` : (parsexmltag(Re[0], !1), He = Re.index + Re[0].length);
      break;
    // <text:p>
    case "s":
      break;
    // <text:s>
    case "database-range":
      if (Re[1] === "/") break;
      try {
        Bt = ods_to_csf_3D(parsexmltag(Re[0])["target-range-address"]), Ce[Bt[0]]["!autofilter"] = { ref: Bt[1] };
      } catch {
      }
      break;
    case "date":
      break;
    // <*:date>
    case "object":
      break;
    // 10.4.6.2 <draw:object>
    case "title":
    case "标题":
      break;
    // <*:title> OR <uof:标题>
    case "desc":
      break;
    // <*:desc>
    case "binary-data":
      break;
    // 10.4.5 TODO: b64 blob
    /* 9.2 Advanced Tables */
    case "table-source":
      break;
    // 9.2.6
    case "scenario":
      break;
    // 9.2.6
    case "iteration":
      break;
    // 9.4.3 <table:iteration>
    case "content-validations":
      break;
    // 9.4.4 <table:
    case "content-validation":
      break;
    // 9.4.5 <table:
    case "help-message":
      break;
    // 9.4.6 <table:
    case "error-message":
      break;
    // 9.4.7 <table:
    case "database-ranges":
      break;
    // 9.4.14 <table:database-ranges>
    /* 9.5 Filters */
    case "filter":
      break;
    // 9.5.2 <table:filter>
    case "filter-and":
      break;
    // 9.5.3 <table:filter-and>
    case "filter-or":
      break;
    // 9.5.4 <table:filter-or>
    case "filter-condition":
      break;
    // 9.5.5 <table:filter-condition>
    case "filter-set-item":
      break;
    // 9.5.6 <table:filter-condition>
    case "list-level-style-bullet":
      break;
    // 16.31 <text:
    case "list-level-style-number":
      break;
    // 16.32 <text:
    case "list-level-properties":
      break;
    // 17.19 <style:
    /* 7.3 Document Fields */
    case "sender-firstname":
    // 7.3.6.2
    case "sender-lastname":
    // 7.3.6.3
    case "sender-initials":
    // 7.3.6.4
    case "sender-title":
    // 7.3.6.5
    case "sender-position":
    // 7.3.6.6
    case "sender-email":
    // 7.3.6.7
    case "sender-phone-private":
    // 7.3.6.8
    case "sender-fax":
    // 7.3.6.9
    case "sender-company":
    // 7.3.6.10
    case "sender-phone-work":
    // 7.3.6.11
    case "sender-street":
    // 7.3.6.12
    case "sender-city":
    // 7.3.6.13
    case "sender-postal-code":
    // 7.3.6.14
    case "sender-country":
    // 7.3.6.15
    case "sender-state-or-province":
    // 7.3.6.16
    case "author-name":
    // 7.3.7.1
    case "author-initials":
    // 7.3.7.2
    case "chapter":
    // 7.3.8
    case "file-name":
    // 7.3.9
    case "template-name":
    // 7.3.9
    case "sheet-name":
      break;
    case "event-listener":
      break;
    /* TODO: FODS Properties */
    case "initial-creator":
    case "creation-date":
    case "print-date":
    case "generator":
    case "document-statistic":
    case "user-defined":
    case "editing-duration":
    case "editing-cycles":
      break;
    /* TODO: FODS Config */
    case "config-item":
      break;
    /* TODO: style tokens */
    case "page-number":
      break;
    // TODO <text:page-number>
    case "page-count":
      break;
    // TODO <text:page-count>
    case "time":
      break;
    // TODO <text:time>
    /* 9.3 Advanced Table Cells */
    case "cell-range-source":
      break;
    // 9.3.1 <table:
    case "detective":
      break;
    // 9.3.2 <table:
    case "operation":
      break;
    // 9.3.3 <table:
    case "highlighted-range":
      break;
    // 9.3.4 <table:
    /* 9.6 Data Pilot Tables <table: */
    case "data-pilot-table":
    // 9.6.3
    case "source-cell-range":
    // 9.6.5
    case "source-service":
    // 9.6.6
    case "data-pilot-field":
    // 9.6.7
    case "data-pilot-level":
    // 9.6.8
    case "data-pilot-subtotals":
    // 9.6.9
    case "data-pilot-subtotal":
    // 9.6.10
    case "data-pilot-members":
    // 9.6.11
    case "data-pilot-member":
    // 9.6.12
    case "data-pilot-display-info":
    // 9.6.13
    case "data-pilot-sort-info":
    // 9.6.14
    case "data-pilot-layout-info":
    // 9.6.15
    case "data-pilot-field-reference":
    // 9.6.16
    case "data-pilot-groups":
    // 9.6.17
    case "data-pilot-group":
    // 9.6.18
    case "data-pilot-group-member":
      break;
    /* 10.3 Drawing Shapes */
    case "rect":
      break;
    /* 14.6 DDE Connections */
    case "dde-connection-decls":
    // 14.6.2 <text:
    case "dde-connection-decl":
    // 14.6.3 <text:
    case "dde-link":
    // 14.6.4 <table:
    case "dde-source":
      break;
    case "properties":
      break;
    // 13.7 <form:properties>
    case "property":
      break;
    // 13.8 <form:property>
    case "a":
      if (Re[1] !== "/") {
        if (It = parsexmltag(Re[0], !1), !It.href) break;
        It.Target = unescapexml(It.href), delete It.href, It.Target.charAt(0) == "#" && It.Target.indexOf(".") > -1 ? (Bt = ods_to_csf_3D(It.Target.slice(1)), It.Target = "#" + Bt[0] + "!" + Bt[1]) : It.Target.match(/^\.\.[\\\/]/) && (It.Target = It.Target.slice(3));
      }
      break;
    /* non-standard */
    case "table-protection":
      break;
    case "data-pilot-grand-total":
      break;
    // <table:
    case "office-document-common-attrs":
      break;
    // bare
    default:
      switch (Re[2]) {
        case "dc:":
        // TODO: properties
        case "calcext:":
        // ignore undocumented extensions
        case "loext:":
        // ignore undocumented extensions
        case "ooo:":
        // ignore undocumented extensions
        case "chartooo:":
        // ignore undocumented extensions
        case "draw:":
        // TODO: drawing
        case "style:":
        // TODO: styles
        case "chart:":
        // TODO: charts
        case "form:":
        // TODO: forms
        case "uof:":
        // TODO: uof
        case "表:":
        // TODO: uof
        case "字:":
          break;
        default:
          if (oe.WTF) throw new Error(Re);
      }
  }
  var er = {
    Sheets: Ce,
    SheetNames: Ie,
    Workbook: St
  };
  return oe.bookSheets && delete /*::(*/
  er.Sheets, er;
}
function parse_ods(le, Y) {
  Y = Y || {}, safegetzipfile(le, "META-INF/manifest.xml") && parse_manifest(getzipdata(le, "META-INF/manifest.xml"), Y);
  var re = getzipstr(le, "styles.xml"), oe = re && parse_ods_styles(utf8read(re)), ue = getzipstr(le, "content.xml");
  if (!ue) throw new Error("Missing content.xml in ODS / UOF file");
  var fe = parse_content_xml(utf8read(ue), Y, oe);
  return safegetzipfile(le, "meta.xml") && (fe.Props = parse_core_props(getzipdata(le, "meta.xml"))), fe.bookType = "ods", fe;
}
function parse_fods(le, Y) {
  var re = parse_content_xml(le, Y);
  return re.bookType = "fods", re;
}
var write_styles_ods = /* @__PURE__ */ function() {
  var le = [
    "<office:master-styles>",
    '<style:master-page style:name="mp1" style:page-layout-name="mp1">',
    "<style:header/>",
    '<style:header-left style:display="false"/>',
    "<style:footer/>",
    '<style:footer-left style:display="false"/>',
    "</style:master-page>",
    "</office:master-styles>"
  ].join(""), Y = "<office:document-styles " + wxt_helper({
    "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
    "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
    "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
    "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
    "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
    "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    "xmlns:dc": "http://purl.org/dc/elements/1.1/",
    "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
    "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
    "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
    "office:version": "1.2"
  }) + ">" + le + "</office:document-styles>";
  return function() {
    return XML_HEADER + Y;
  };
}();
function write_number_format_ods(le, Y) {
  var re = "number", oe = "", ue = { "style:name": Y }, fe = "", he = 0;
  le = le.replace(/"[$]"/g, "$");
  e: {
    if (le.indexOf(";") > -1 && (console.error("Unsupported ODS Style Map exported.  Using first branch of " + le), le = le.slice(0, le.indexOf(";"))), le == "@") {
      re = "text", oe = "<number:text-content/>";
      break e;
    }
    if (le.indexOf(/\$/) > -1 && (re = "currency"), le[he] == '"') {
      for (fe = ""; le[++he] != '"' || le[++he] == '"'; ) fe += le[he];
      --he, le[he + 1] == "*" ? (he++, oe += "<number:fill-character>" + escapexml(fe.replace(/""/g, '"')) + "</number:fill-character>") : oe += "<number:text>" + escapexml(fe.replace(/""/g, '"')) + "</number:text>", le = le.slice(he + 1), he = 0;
    }
    var _e = le.match(/# (\?+)\/(\?+)/);
    if (_e) {
      oe += writextag("number:fraction", null, { "number:min-integer-digits": 0, "number:min-numerator-digits": _e[1].length, "number:max-denominator-value": Math.max(+_e[1].replace(/./g, "9"), +_e[2].replace(/./g, "9")) });
      break e;
    }
    if (_e = le.match(/# (\?+)\/(\d+)/)) {
      oe += writextag("number:fraction", null, { "number:min-integer-digits": 0, "number:min-numerator-digits": _e[1].length, "number:denominator-value": +_e[2] });
      break e;
    }
    if (_e = le.match(/\b(\d+)(|\.\d+)%/)) {
      re = "percentage", oe += writextag("number:number", null, { "number:decimal-places": _e[2] && _e.length - 1 || 0, "number:min-decimal-places": _e[2] && _e.length - 1 || 0, "number:min-integer-digits": _e[1].length }) + "<number:text>%</number:text>";
      break e;
    }
    var ve = !1;
    if (["y", "m", "d"].indexOf(le[0]) > -1) {
      re = "date";
      t: for (; he < le.length; ++he) switch (fe = le[he].toLowerCase()) {
        case "h":
        case "s":
          ve = !0, --he;
          break t;
        case "m":
          r: for (var xe = he + 1; xe < le.length; ++xe) switch (le[xe]) {
            case "y":
            case "d":
              break r;
            case "h":
            case "s":
              ve = !0, --he;
              break t;
          }
        /* falls through */
        case "y":
        case "d":
          for (; (le[++he] || "").toLowerCase() == fe[0]; ) fe += fe[0];
          switch (--he, fe) {
            case "y":
            case "yy":
              oe += "<number:year/>";
              break;
            case "yyy":
            case "yyyy":
              oe += '<number:year number:style="long"/>';
              break;
            case "mmmmm":
              console.error("ODS has no equivalent of format |mmmmm|");
            /* falls through */
            case "m":
            case "mm":
            case "mmm":
            case "mmmm":
              oe += '<number:month number:style="' + (fe.length % 2 ? "short" : "long") + '" number:textual="' + (fe.length >= 3 ? "true" : "false") + '"/>';
              break;
            case "d":
            case "dd":
              oe += '<number:day number:style="' + (fe.length % 2 ? "short" : "long") + '"/>';
              break;
            case "ddd":
            case "dddd":
              oe += '<number:day-of-week number:style="' + (fe.length % 2 ? "short" : "long") + '"/>';
              break;
          }
          break;
        case '"':
          for (; le[++he] != '"' || le[++he] == '"'; ) fe += le[he];
          --he, oe += "<number:text>" + escapexml(fe.slice(1).replace(/""/g, '"')) + "</number:text>";
          break;
        case "\\":
          fe = le[++he], oe += "<number:text>" + escapexml(fe) + "</number:text>";
          break;
        case "/":
        case ":":
          oe += "<number:text>" + escapexml(fe) + "</number:text>";
          break;
        default:
          console.error("unrecognized character " + fe + " in ODF format " + le);
      }
      if (!ve) break e;
      le = le.slice(he + 1), he = 0;
    }
    if (le.match(/^\[?[hms]/)) {
      for (re == "number" && (re = "time"), le.match(/\[/) && (le = le.replace(/[\[\]]/g, ""), ue["number:truncate-on-overflow"] = "false"); he < le.length; ++he) switch (fe = le[he].toLowerCase()) {
        case "h":
        case "m":
        case "s":
          for (; (le[++he] || "").toLowerCase() == fe[0]; ) fe += fe[0];
          switch (--he, fe) {
            case "h":
            case "hh":
              oe += '<number:hours number:style="' + (fe.length % 2 ? "short" : "long") + '"/>';
              break;
            case "m":
            case "mm":
              oe += '<number:minutes number:style="' + (fe.length % 2 ? "short" : "long") + '"/>';
              break;
            case "s":
            case "ss":
              if (le[he + 1] == ".") do
                fe += le[he + 1], ++he;
              while (le[he + 1] == "0");
              oe += '<number:seconds number:style="' + (fe.match("ss") ? "long" : "short") + '"' + (fe.match(/\./) ? ' number:decimal-places="' + (fe.match(/0+/) || [""])[0].length + '"' : "") + "/>";
              break;
          }
          break;
        case '"':
          for (; le[++he] != '"' || le[++he] == '"'; ) fe += le[he];
          --he, oe += "<number:text>" + escapexml(fe.slice(1).replace(/""/g, '"')) + "</number:text>";
          break;
        case "/":
        case ":":
          oe += "<number:text>" + escapexml(fe) + "</number:text>";
          break;
        case "a":
          if (le.slice(he, he + 3).toLowerCase() == "a/p") {
            oe += "<number:am-pm/>", he += 2;
            break;
          }
          if (le.slice(he, he + 5).toLowerCase() == "am/pm") {
            oe += "<number:am-pm/>", he += 4;
            break;
          }
        /* falls through */
        default:
          console.error("unrecognized character " + fe + " in ODF format " + le);
      }
      break e;
    }
    if (le.indexOf(/\$/) > -1 && (re = "currency"), le[0] == "$" && (oe += '<number:currency-symbol number:language="en" number:country="US">$</number:currency-symbol>', le = le.slice(1), he = 0), he = 0, le[he] == '"') {
      for (; le[++he] != '"' || le[++he] == '"'; ) fe += le[he];
      --he, le[he + 1] == "*" ? (he++, oe += "<number:fill-character>" + escapexml(fe.replace(/""/g, '"')) + "</number:fill-character>") : oe += "<number:text>" + escapexml(fe.replace(/""/g, '"')) + "</number:text>", le = le.slice(he + 1), he = 0;
    }
    var Ee = le.match(/([#0][0#,]*)(\.[0#]*|)(E[+]?0*|)/i);
    if (!Ee || !Ee[0]) console.error("Could not find numeric part of " + le);
    else {
      var Se = Ee[1].replace(/,/g, "");
      oe += "<number:" + (Ee[3] ? "scientific-" : "") + 'number number:min-integer-digits="' + (Se.indexOf("0") == -1 ? "0" : Se.length - Se.indexOf("0")) + '"' + (Ee[0].indexOf(",") > -1 ? ' number:grouping="true"' : "") + (Ee[2] && ' number:decimal-places="' + (Ee[2].length - 1) + '"' || ' number:decimal-places="0"') + (Ee[3] && Ee[3].indexOf("+") > -1 ? ' number:forced-exponent-sign="true"' : "") + (Ee[3] ? ' number:min-exponent-digits="' + Ee[3].match(/0+/)[0].length + '"' : "") + "></number:" + (Ee[3] ? "scientific-" : "") + "number>", he = Ee.index + Ee[0].length;
    }
    if (le[he] == '"') {
      for (fe = ""; le[++he] != '"' || le[++he] == '"'; ) fe += le[he];
      --he, oe += "<number:text>" + escapexml(fe.replace(/""/g, '"')) + "</number:text>";
    }
  }
  return oe ? writextag("number:" + re + "-style", oe, ue) : (console.error("Could not generate ODS number format for |" + le + "|"), "");
}
function write_names_ods(le, Y, re) {
  for (var oe = [], ue = 0; ue < le.length; ++ue) {
    var fe = le[ue];
    fe && fe.Sheet == (re == -1 ? null : re) && oe.push(fe);
  }
  return oe.length ? `      <table:named-expressions>
` + oe.map(function(he) {
    var _e = (re == -1 ? "$" : "") + csf_to_ods_3D(he.Ref);
    return "        " + writextag("table:named-range", null, {
      "table:name": he.Name,
      "table:cell-range-address": _e,
      "table:base-cell-address": _e.replace(/[\.][^\.]*$/, ".$A$1")
    });
  }).join(`
`) + `
      </table:named-expressions>
` : "";
}
var write_content_ods = /* @__PURE__ */ function() {
  var le = function(ue, fe) {
    return escapexml(ue).replace(/  +/g, function(he) {
      return '<text:s text:c="' + he.length + '"/>';
    }).replace(/\t/g, "<text:tab/>").replace(/\n/g, "</text:p><text:p>").replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>");
  }, Y = `          <table:table-cell />
`, re = function(ue, fe, he, _e, ve, xe) {
    var Ee = [];
    Ee.push('      <table:table table:name="' + escapexml(fe.SheetNames[he]) + `" table:style-name="ta1">
`);
    var Se = 0, Te = 0, Ce = decode_range(ue["!ref"] || "A1"), Ie = ue["!merges"] || [], Ne = 0, Re = ue["!data"] != null;
    if (ue["!cols"])
      for (Te = 0; Te <= Ce.e.c; ++Te) Ee.push("        <table:table-column" + (ue["!cols"][Te] ? ' table:style-name="co' + ue["!cols"][Te].ods + '"' : "") + `></table:table-column>
`);
    var Ae = "", Pe = ue["!rows"] || [];
    for (Se = 0; Se < Ce.s.r; ++Se)
      Ae = Pe[Se] ? ' table:style-name="ro' + Pe[Se].ods + '"' : "", Ee.push("        <table:table-row" + Ae + `></table:table-row>
`);
    for (; Se <= Ce.e.r; ++Se) {
      for (Ae = Pe[Se] ? ' table:style-name="ro' + Pe[Se].ods + '"' : "", Ee.push("        <table:table-row" + Ae + `>
`), Te = 0; Te < Ce.s.c; ++Te) Ee.push(Y);
      for (; Te <= Ce.e.c; ++Te) {
        var Fe = !1, Le = {}, He = "";
        for (Ne = 0; Ne != Ie.length; ++Ne)
          if (!(Ie[Ne].s.c > Te) && !(Ie[Ne].s.r > Se) && !(Ie[Ne].e.c < Te) && !(Ie[Ne].e.r < Se)) {
            (Ie[Ne].s.c != Te || Ie[Ne].s.r != Se) && (Fe = !0), Le["table:number-columns-spanned"] = Ie[Ne].e.c - Ie[Ne].s.c + 1, Le["table:number-rows-spanned"] = Ie[Ne].e.r - Ie[Ne].s.r + 1;
            break;
          }
        if (Fe) {
          Ee.push(`          <table:covered-table-cell/>
`);
          continue;
        }
        var Ge = encode_cell({ r: Se, c: Te }), Ve = Re ? (ue["!data"][Se] || [])[Te] : ue[Ge];
        if (Ve && Ve.f && (Le["table:formula"] = escapexml(csf_to_ods_formula(Ve.f)), Ve.F && Ve.F.slice(0, Ge.length) == Ge)) {
          var $e = decode_range(Ve.F);
          Le["table:number-matrix-columns-spanned"] = $e.e.c - $e.s.c + 1, Le["table:number-matrix-rows-spanned"] = $e.e.r - $e.s.r + 1;
        }
        if (!Ve) {
          Ee.push(Y);
          continue;
        }
        switch (Ve.t) {
          case "b":
            He = Ve.v ? "TRUE" : "FALSE", Le["office:value-type"] = "boolean", Le["office:boolean-value"] = Ve.v ? "true" : "false";
            break;
          case "n":
            isFinite(Ve.v) ? (He = Ve.w || String(Ve.v || 0), Le["office:value-type"] = "float", Le["office:value"] = Ve.v || 0) : (isNaN(Ve.v) ? (He = "#NUM!", Le["table:formula"] = "of:=#NUM!") : (He = "#DIV/0!", Le["table:formula"] = "of:=" + (Ve.v < 0 ? "-" : "") + "1/0"), Le["office:string-value"] = "", Le["office:value-type"] = "string", Le["calcext:value-type"] = "error");
            break;
          case "s":
          case "str":
            He = Ve.v == null ? "" : Ve.v, Le["office:value-type"] = "string";
            break;
          case "d":
            He = Ve.w || parseDate(Ve.v, xe).toISOString(), Le["office:value-type"] = "date", Le["office:date-value"] = parseDate(Ve.v, xe).toISOString(), Le["table:style-name"] = "ce1";
            break;
          //case 'e': // TODO: translate to ODS errors
          default:
            Ee.push(Y);
            continue;
        }
        var De = le(He);
        if (Ve.l && Ve.l.Target) {
          var Ke = Ve.l.Target;
          Ke = Ke.charAt(0) == "#" ? "#" + csf_to_ods_3D(Ke.slice(1)) : Ke, Ke.charAt(0) != "#" && !Ke.match(/^\w+:/) && (Ke = "../" + Ke), De = writextag("text:a", De, { "xlink:href": Ke.replace(/&/g, "&amp;") });
        }
        ve[Ve.z] && (Le["table:style-name"] = "ce" + ve[Ve.z].slice(1));
        var ze = writextag("text:p", De, {});
        if (Ve.c) {
          for (var tt = "", Xe = "", mt = {}, at = 0; at < Ve.c.length; ++at)
            !tt && Ve.c[at].a && (tt = Ve.c[at].a), Xe += "<text:p>" + le(Ve.c[at].t) + "</text:p>";
          Ve.c.hidden || (mt["office:display"] = !0), ze = writextag("office:annotation", Xe, mt) + ze;
        }
        Ee.push("          " + writextag("table:table-cell", ze, Le) + `
`);
      }
      Ee.push(`        </table:table-row>
`);
    }
    return (fe.Workbook || {}).Names && Ee.push(write_names_ods(fe.Workbook.Names, fe.SheetNames, he)), Ee.push(`      </table:table>
`), Ee.join("");
  }, oe = function(ue, fe) {
    ue.push(` <office:automatic-styles>
`);
    var he = 0;
    fe.SheetNames.map(function(Ee) {
      return fe.Sheets[Ee];
    }).forEach(function(Ee) {
      if (Ee && Ee["!cols"]) {
        for (var Se = 0; Se < Ee["!cols"].length; ++Se) if (Ee["!cols"][Se]) {
          var Te = Ee["!cols"][Se];
          if (Te.width == null && Te.wpx == null && Te.wch == null) continue;
          process_col(Te), Te.ods = he;
          var Ce = Ee["!cols"][Se].wpx + "px";
          ue.push('  <style:style style:name="co' + he + `" style:family="table-column">
`), ue.push('   <style:table-column-properties fo:break-before="auto" style:column-width="' + Ce + `"/>
`), ue.push(`  </style:style>
`), ++he;
        }
      }
    });
    var _e = 0;
    fe.SheetNames.map(function(Ee) {
      return fe.Sheets[Ee];
    }).forEach(function(Ee) {
      if (Ee && Ee["!rows"]) {
        for (var Se = 0; Se < Ee["!rows"].length; ++Se) if (Ee["!rows"][Se]) {
          Ee["!rows"][Se].ods = _e;
          var Te = Ee["!rows"][Se].hpx + "px";
          ue.push('  <style:style style:name="ro' + _e + `" style:family="table-row">
`), ue.push('   <style:table-row-properties fo:break-before="auto" style:row-height="' + Te + `"/>
`), ue.push(`  </style:style>
`), ++_e;
        }
      }
    }), ue.push(`  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">
`), ue.push(`   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>
`), ue.push(`  </style:style>
`), ue.push(`  <number:date-style style:name="N37" number:automatic-order="true">
`), ue.push(`   <number:month number:style="long"/>
`), ue.push(`   <number:text>/</number:text>
`), ue.push(`   <number:day number:style="long"/>
`), ue.push(`   <number:text>/</number:text>
`), ue.push(`   <number:year/>
`), ue.push(`  </number:date-style>
`);
    var ve = {}, xe = 69;
    return fe.SheetNames.map(function(Ee) {
      return fe.Sheets[Ee];
    }).forEach(function(Ee) {
      if (Ee) {
        var Se = Ee["!data"] != null;
        if (Ee["!ref"])
          for (var Te = decode_range(Ee["!ref"]), Ce = 0; Ce <= Te.e.r; ++Ce) for (var Ie = 0; Ie <= Te.e.c; ++Ie) {
            var Ne = Se ? (Ee["!data"][Ce] || [])[Ie] : Ee[encode_cell({ r: Ce, c: Ie })];
            if (!(!Ne || !Ne.z || Ne.z.toLowerCase() == "general") && !ve[Ne.z]) {
              var Re = write_number_format_ods(Ne.z, "N" + xe);
              Re && (ve[Ne.z] = "N" + xe, ++xe, ue.push(Re + `
`));
            }
          }
      }
    }), ue.push(`  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>
`), keys(ve).forEach(function(Ee) {
      ue.push('<style:style style:name="ce' + ve[Ee].slice(1) + '" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="' + ve[Ee] + `"/>
`);
    }), ue.push(` </office:automatic-styles>
`), ve;
  };
  return function(fe, he) {
    var _e = [XML_HEADER], ve = wxt_helper({
      "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
      "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
      "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
      "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
      "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
      "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "xmlns:dc": "http://purl.org/dc/elements/1.1/",
      "xmlns:meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
      "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
      "xmlns:presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
      "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
      "xmlns:chart": "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
      "xmlns:dr3d": "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
      "xmlns:math": "http://www.w3.org/1998/Math/MathML",
      "xmlns:form": "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
      "xmlns:script": "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
      "xmlns:ooo": "http://openoffice.org/2004/office",
      "xmlns:ooow": "http://openoffice.org/2004/writer",
      "xmlns:oooc": "http://openoffice.org/2004/calc",
      "xmlns:dom": "http://www.w3.org/2001/xml-events",
      "xmlns:xforms": "http://www.w3.org/2002/xforms",
      "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
      "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
      "xmlns:sheet": "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
      "xmlns:rpt": "http://openoffice.org/2005/report",
      "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
      "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
      "xmlns:grddl": "http://www.w3.org/2003/g/data-view#",
      "xmlns:tableooo": "http://openoffice.org/2009/table",
      "xmlns:drawooo": "http://openoffice.org/2010/draw",
      "xmlns:calcext": "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
      "xmlns:loext": "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
      "xmlns:field": "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
      "xmlns:formx": "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
      "xmlns:css3t": "http://www.w3.org/TR/css3-text/",
      "office:version": "1.2"
    }), xe = wxt_helper({
      "xmlns:config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
      "office:mimetype": "application/vnd.oasis.opendocument.spreadsheet"
    });
    he.bookType == "fods" ? (_e.push("<office:document" + ve + xe + `>
`), _e.push(write_meta_ods().replace(/<office:document-meta[^<>]*?>/, "").replace(/<\/office:document-meta>/, "") + `
`)) : _e.push("<office:document-content" + ve + `>
`);
    var Ee = oe(_e, fe);
    _e.push(`  <office:body>
`), _e.push(`    <office:spreadsheet>
`), ((fe.Workbook || {}).WBProps || {}).date1904 && _e.push(`      <table:calculation-settings table:case-sensitive="false" table:search-criteria-must-apply-to-whole-cell="true" table:use-wildcards="true" table:use-regular-expressions="false" table:automatic-find-labels="false">
        <table:null-date table:date-value="1904-01-01"/>
      </table:calculation-settings>
`);
    for (var Se = 0; Se != fe.SheetNames.length; ++Se) _e.push(re(fe.Sheets[fe.SheetNames[Se]], fe, Se, he, Ee, ((fe.Workbook || {}).WBProps || {}).date1904));
    return (fe.Workbook || {}).Names && _e.push(write_names_ods(fe.Workbook.Names, fe.SheetNames, -1)), _e.push(`    </office:spreadsheet>
`), _e.push(`  </office:body>
`), he.bookType == "fods" ? _e.push("</office:document>") : _e.push("</office:document-content>"), _e.join("");
  };
}();
function write_ods(le, Y) {
  if (Y.bookType == "fods") return write_content_ods(le, Y);
  var re = zip_new(), oe = "", ue = [], fe = [];
  return oe = "mimetype", zip_add_file(re, oe, "application/vnd.oasis.opendocument.spreadsheet"), oe = "content.xml", zip_add_file(re, oe, write_content_ods(le, Y)), ue.push([oe, "text/xml"]), fe.push([oe, "ContentFile"]), oe = "styles.xml", zip_add_file(re, oe, write_styles_ods(le, Y)), ue.push([oe, "text/xml"]), fe.push([oe, "StylesFile"]), oe = "meta.xml", zip_add_file(re, oe, XML_HEADER + write_meta_ods(
    /*::wb, opts*/
  )), ue.push([oe, "text/xml"]), fe.push([oe, "MetadataFile"]), oe = "manifest.rdf", zip_add_file(re, oe, write_rdf(
    fe
    /*, opts*/
  )), ue.push([oe, "application/rdf+xml"]), oe = "META-INF/manifest.xml", zip_add_file(re, oe, write_manifest(
    ue
    /*, opts*/
  )), re;
}
/*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com */
var subarray = function() {
  try {
    return typeof Uint8Array > "u" || typeof Uint8Array.prototype.subarray > "u" ? "slice" : typeof Buffer < "u" ? typeof Buffer.prototype.subarray > "u" ? "slice" : (typeof Buffer.from == "function" ? Buffer.from([72, 62]) : new Buffer([72, 62])) instanceof Uint8Array ? "subarray" : "slice" : "subarray";
  } catch {
    return "slice";
  }
}();
function u8_to_dataview(le) {
  return new DataView(le.buffer, le.byteOffset, le.byteLength);
}
function u8str(le) {
  return typeof TextDecoder < "u" ? new TextDecoder().decode(le) : utf8read(a2s(le));
}
function stru8(le) {
  return typeof TextEncoder < "u" ? new TextEncoder().encode(le) : s2a(utf8write(le));
}
function u8concat(le) {
  for (var Y = 0, re = 0; re < le.length; ++re)
    Y += le[re].length;
  var oe = new Uint8Array(Y), ue = 0;
  for (re = 0; re < le.length; ++re) {
    var fe = le[re], he = fe.length;
    if (he < 250)
      for (var _e = 0; _e < he; ++_e)
        oe[ue++] = fe[_e];
    else
      oe.set(fe, ue), ue += he;
  }
  return oe;
}
function popcnt(le) {
  return le -= le >> 1 & 1431655765, le = (le & 858993459) + (le >> 2 & 858993459), (le + (le >> 4) & 252645135) * 16843009 >>> 24;
}
function readDecimal128LE(le, Y) {
  for (var re = (le[Y + 15] & 127) << 7 | le[Y + 14] >> 1, oe = le[Y + 14] & 1, ue = Y + 13; ue >= Y; --ue)
    oe = oe * 256 + le[ue];
  return (le[Y + 15] & 128 ? -oe : oe) * Math.pow(10, re - 6176);
}
function writeDecimal128LE(le, Y, re) {
  var oe = Math.floor(re == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(re))) + 6176 - 16, ue = re / Math.pow(10, oe - 6176);
  le[Y + 15] |= oe >> 7, le[Y + 14] |= (oe & 127) << 1;
  for (var fe = 0; ue >= 1; ++fe, ue /= 256)
    le[Y + fe] = ue & 255;
  le[Y + 15] |= re >= 0 ? 0 : 128;
}
function parse_varint49(le, Y) {
  var re = Y.l, oe = le[re] & 127;
  e:
    if (le[re++] >= 128 && (oe |= (le[re] & 127) << 7, le[re++] < 128 || (oe |= (le[re] & 127) << 14, le[re++] < 128) || (oe |= (le[re] & 127) << 21, le[re++] < 128) || (oe += (le[re] & 127) * Math.pow(2, 28), ++re, le[re++] < 128) || (oe += (le[re] & 127) * Math.pow(2, 35), ++re, le[re++] < 128) || (oe += (le[re] & 127) * Math.pow(2, 42), ++re, le[re++] < 128)))
      break e;
  return Y.l = re, oe;
}
function write_varint49(le) {
  var Y = new Uint8Array(7);
  Y[0] = le & 127;
  var re = 1;
  e:
    if (le > 127) {
      if (Y[re - 1] |= 128, Y[re] = le >> 7 & 127, ++re, le <= 16383 || (Y[re - 1] |= 128, Y[re] = le >> 14 & 127, ++re, le <= 2097151) || (Y[re - 1] |= 128, Y[re] = le >> 21 & 127, ++re, le <= 268435455) || (Y[re - 1] |= 128, Y[re] = le / 256 >>> 21 & 127, ++re, le <= 34359738367) || (Y[re - 1] |= 128, Y[re] = le / 65536 >>> 21 & 127, ++re, le <= 4398046511103))
        break e;
      Y[re - 1] |= 128, Y[re] = le / 16777216 >>> 21 & 127, ++re;
    }
  return Y[subarray](0, re);
}
function parse_packed_varints(le) {
  for (var Y = { l: 0 }, re = []; Y.l < le.length; )
    re.push(parse_varint49(le, Y));
  return re;
}
function write_packed_varints(le) {
  return u8concat(le.map(function(Y) {
    return write_varint49(Y);
  }));
}
function varint_to_i32(le) {
  var Y = 0, re = le[Y] & 127;
  return le[Y++] < 128 || (re |= (le[Y] & 127) << 7, le[Y++] < 128) || (re |= (le[Y] & 127) << 14, le[Y++] < 128) || (re |= (le[Y] & 127) << 21, le[Y++] < 128) || (re |= (le[Y] & 15) << 28), re;
}
function parse_shallow(le) {
  for (var Y = [], re = { l: 0 }; re.l < le.length; ) {
    var oe = re.l, ue = parse_varint49(le, re), fe = ue & 7;
    ue = ue / 8 | 0;
    var he, _e = re.l;
    switch (fe) {
      case 0:
        {
          for (; le[_e++] >= 128; )
            ;
          he = le[subarray](re.l, _e), re.l = _e;
        }
        break;
      case 1:
        he = le[subarray](_e, _e + 8), re.l = _e + 8;
        break;
      case 2:
        {
          var ve = parse_varint49(le, re);
          he = le[subarray](re.l, re.l + ve), re.l += ve;
        }
        break;
      case 5:
        he = le[subarray](_e, _e + 4), re.l = _e + 4;
        break;
      default:
        throw new Error("PB Type ".concat(fe, " for Field ").concat(ue, " at offset ").concat(oe));
    }
    var xe = { data: he, type: fe };
    Y[ue] == null && (Y[ue] = []), Y[ue].push(xe);
  }
  return Y;
}
function write_shallow(le) {
  var Y = [];
  return le.forEach(function(re, oe) {
    oe != 0 && re.forEach(function(ue) {
      ue.data && (Y.push(write_varint49(oe * 8 + ue.type)), ue.type == 2 && Y.push(write_varint49(ue.data.length)), Y.push(ue.data));
    });
  }), u8concat(Y);
}
function mappa(le, Y) {
  return le?.map(function(re) {
    return Y(re.data);
  }) || [];
}
function parse_iwa_file(le) {
  for (var Y, re = [], oe = { l: 0 }; oe.l < le.length; ) {
    var ue = parse_varint49(le, oe), fe = parse_shallow(le[subarray](oe.l, oe.l + ue));
    oe.l += ue;
    var he = {
      id: varint_to_i32(fe[1][0].data),
      messages: []
    };
    fe[2].forEach(function(_e) {
      var ve = parse_shallow(_e.data), xe = varint_to_i32(ve[3][0].data);
      he.messages.push({
        meta: ve,
        data: le[subarray](oe.l, oe.l + xe)
      }), oe.l += xe;
    }), (Y = fe[3]) != null && Y[0] && (he.merge = varint_to_i32(fe[3][0].data) >>> 0 > 0), re.push(he);
  }
  return re;
}
function write_iwa_file(le) {
  var Y = [];
  return le.forEach(function(re) {
    var oe = [
      [],
      [{ data: write_varint49(re.id), type: 0 }],
      []
    ];
    re.merge != null && (oe[3] = [{ data: write_varint49(+!!re.merge), type: 0 }]);
    var ue = [];
    re.messages.forEach(function(he) {
      ue.push(he.data), he.meta[3] = [{ type: 0, data: write_varint49(he.data.length) }], oe[2].push({ data: write_shallow(he.meta), type: 2 });
    });
    var fe = write_shallow(oe);
    Y.push(write_varint49(fe.length)), Y.push(fe), ue.forEach(function(he) {
      return Y.push(he);
    });
  }), u8concat(Y);
}
function parse_snappy_chunk(le, Y) {
  if (le != 0)
    throw new Error("Unexpected Snappy chunk type ".concat(le));
  for (var re = { l: 0 }, oe = parse_varint49(Y, re), ue = [], fe = re.l; fe < Y.length; ) {
    var he = Y[fe] & 3;
    if (he == 0) {
      var _e = Y[fe++] >> 2;
      if (_e < 60)
        ++_e;
      else {
        var ve = _e - 59;
        _e = Y[fe], ve > 1 && (_e |= Y[fe + 1] << 8), ve > 2 && (_e |= Y[fe + 2] << 16), ve > 3 && (_e |= Y[fe + 3] << 24), _e >>>= 0, _e++, fe += ve;
      }
      ue.push(Y[subarray](fe, fe + _e)), fe += _e;
      continue;
    } else {
      var xe = 0, Ee = 0;
      if (he == 1 ? (Ee = (Y[fe] >> 2 & 7) + 4, xe = (Y[fe++] & 224) << 3, xe |= Y[fe++]) : (Ee = (Y[fe++] >> 2) + 1, he == 2 ? (xe = Y[fe] | Y[fe + 1] << 8, fe += 2) : (xe = (Y[fe] | Y[fe + 1] << 8 | Y[fe + 2] << 16 | Y[fe + 3] << 24) >>> 0, fe += 4)), xe == 0)
        throw new Error("Invalid offset 0");
      for (var Se = ue.length - 1, Te = xe; Se >= 0 && Te >= ue[Se].length; )
        Te -= ue[Se].length, --Se;
      if (Se < 0)
        if (Te == 0)
          Te = ue[Se = 0].length;
        else
          throw new Error("Invalid offset beyond length");
      if (Ee < Te)
        ue.push(ue[Se][subarray](ue[Se].length - Te, ue[Se].length - Te + Ee));
      else {
        for (Te > 0 && (ue.push(ue[Se][subarray](ue[Se].length - Te)), Ee -= Te), ++Se; Ee >= ue[Se].length; )
          ue.push(ue[Se]), Ee -= ue[Se].length, ++Se;
        Ee && ue.push(ue[Se][subarray](0, Ee));
      }
      ue.length > 25 && (ue = [u8concat(ue)]);
    }
  }
  for (var Ce = 0, Ie = 0; Ie < ue.length; ++Ie)
    Ce += ue[Ie].length;
  if (Ce != oe)
    throw new Error("Unexpected length: ".concat(Ce, " != ").concat(oe));
  return ue;
}
function decompress_iwa_file(le) {
  Array.isArray(le) && (le = new Uint8Array(le));
  for (var Y = [], re = 0; re < le.length; ) {
    var oe = le[re++], ue = le[re] | le[re + 1] << 8 | le[re + 2] << 16;
    re += 3, Y.push.apply(Y, parse_snappy_chunk(oe, le[subarray](re, re + ue))), re += ue;
  }
  if (re !== le.length)
    throw new Error("data is not a valid framed stream!");
  return Y.length == 1 ? Y[0] : u8concat(Y);
}
function compress_iwa_file(le) {
  for (var Y = [], re = 0; re < le.length; ) {
    var oe = Math.min(le.length - re, 268435455), ue = new Uint8Array(4);
    Y.push(ue);
    var fe = write_varint49(oe), he = fe.length;
    Y.push(fe), oe <= 60 ? (he++, Y.push(new Uint8Array([oe - 1 << 2]))) : oe <= 256 ? (he += 2, Y.push(new Uint8Array([240, oe - 1 & 255]))) : oe <= 65536 ? (he += 3, Y.push(new Uint8Array([244, oe - 1 & 255, oe - 1 >> 8 & 255]))) : oe <= 16777216 ? (he += 4, Y.push(new Uint8Array([248, oe - 1 & 255, oe - 1 >> 8 & 255, oe - 1 >> 16 & 255]))) : oe <= 4294967296 && (he += 5, Y.push(new Uint8Array([252, oe - 1 & 255, oe - 1 >> 8 & 255, oe - 1 >> 16 & 255, oe - 1 >>> 24 & 255]))), Y.push(le[subarray](re, re + oe)), he += oe, ue[0] = 0, ue[1] = he & 255, ue[2] = he >> 8 & 255, ue[3] = he >> 16 & 255, re += oe;
  }
  return u8concat(Y);
}
var numbers_lut_new = function() {
  return { sst: [], rsst: [], ofmt: [], nfmt: [], fmla: [], ferr: [], cmnt: [] };
};
function numbers_format_cell(le, Y, re, oe, ue) {
  var fe, he, _e, ve, xe = Y & 255, Ee = Y >> 8, Se = Ee >= 5 ? ue : oe;
  e:
    if (re & (Ee > 4 ? 8 : 4) && le.t == "n" && xe == 7) {
      var Te = (fe = Se[7]) != null && fe[0] ? varint_to_i32(Se[7][0].data) : -1;
      if (Te == -1)
        break e;
      var Ce = (he = Se[15]) != null && he[0] ? varint_to_i32(Se[15][0].data) : -1, Ie = (_e = Se[16]) != null && _e[0] ? varint_to_i32(Se[16][0].data) : -1, Ne = (ve = Se[40]) != null && ve[0] ? varint_to_i32(Se[40][0].data) : -1, Re = le.v, Ae = Re;
      t:
        if (Ne) {
          if (Re == 0) {
            Ce = Ie = 2;
            break t;
          }
          Re >= 604800 ? Ce = 1 : Re >= 86400 ? Ce = 2 : Re >= 3600 ? Ce = 4 : Re >= 60 ? Ce = 8 : Re >= 1 ? Ce = 16 : Ce = 32, Math.floor(Re) != Re ? Ie = 32 : Re % 60 ? Ie = 16 : Re % 3600 ? Ie = 8 : Re % 86400 ? Ie = 4 : Re % 604800 && (Ie = 2), Ie < Ce && (Ie = Ce);
        }
      if (Ce == -1 || Ie == -1)
        break e;
      var Pe = [], Fe = [];
      Ce == 1 && (Ae = Re / 604800, Ie == 1 ? Fe.push('d"d"') : (Ae |= 0, Re -= 604800 * Ae), Pe.push(Ae + (Te == 2 ? " week" + (Ae == 1 ? "" : "s") : Te == 1 ? "w" : ""))), Ce <= 2 && Ie >= 2 && (Ae = Re / 86400, Ie > 2 && (Ae |= 0, Re -= 86400 * Ae), Fe.push('d"d"'), Pe.push(Ae + (Te == 2 ? " day" + (Ae == 1 ? "" : "s") : Te == 1 ? "d" : ""))), Ce <= 4 && Ie >= 4 && (Ae = Re / 3600, Ie > 4 && (Ae |= 0, Re -= 3600 * Ae), Fe.push((Ce >= 4 ? "[h]" : "h") + '"h"'), Pe.push(Ae + (Te == 2 ? " hour" + (Ae == 1 ? "" : "s") : Te == 1 ? "h" : ""))), Ce <= 8 && Ie >= 8 && (Ae = Re / 60, Ie > 8 && (Ae |= 0, Re -= 60 * Ae), Fe.push((Ce >= 8 ? "[m]" : "m") + '"m"'), Te == 0 ? Pe.push((Ce == 8 && Ie == 8 || Ae >= 10 ? "" : "0") + Ae) : Pe.push(Ae + (Te == 2 ? " minute" + (Ae == 1 ? "" : "s") : Te == 1 ? "m" : ""))), Ce <= 16 && Ie >= 16 && (Ae = Re, Ie > 16 && (Ae |= 0, Re -= Ae), Fe.push((Ce >= 16 ? "[s]" : "s") + '"s"'), Te == 0 ? Pe.push((Ie == 16 && Ce == 16 || Ae >= 10 ? "" : "0") + Ae) : Pe.push(Ae + (Te == 2 ? " second" + (Ae == 1 ? "" : "s") : Te == 1 ? "s" : ""))), Ie >= 32 && (Ae = Math.round(1e3 * Re), Ce < 32 && Fe.push('.000"ms"'), Te == 0 ? Pe.push((Ae >= 100 ? "" : Ae >= 10 ? "0" : "00") + Ae) : Pe.push(Ae + (Te == 2 ? " millisecond" + (Ae == 1 ? "" : "s") : Te == 1 ? "ms" : ""))), le.w = Pe.join(Te == 0 ? ":" : " "), le.z = Fe.join(Te == 0 ? '":"' : " "), Te == 0 && (le.w = le.w.replace(/:(\d\d\d)$/, ".$1"));
    }
}
function parse_old_storage(le, Y, re, oe) {
  var ue = u8_to_dataview(le), fe = ue.getUint32(4, !0), he = -1, _e = -1, ve = -1, xe = NaN, Ee = 0, Se = new Date(Date.UTC(2001, 0, 1)), Te = re > 1 ? 12 : 8;
  fe & 2 && (ve = ue.getUint32(Te, !0), Te += 4), Te += popcnt(fe & (re > 1 ? 3468 : 396)) * 4, fe & 512 && (he = ue.getUint32(Te, !0), Te += 4), Te += popcnt(fe & (re > 1 ? 12288 : 4096)) * 4, fe & 16 && (_e = ue.getUint32(Te, !0), Te += 4), fe & 32 && (xe = ue.getFloat64(Te, !0), Te += 8), fe & 64 && (Se.setTime(Se.getTime() + (Ee = ue.getFloat64(Te, !0)) * 1e3), Te += 8), re > 1 && (fe = ue.getUint32(8, !0) >>> 16, fe & 255 && (ve == -1 && (ve = ue.getUint32(Te, !0)), Te += 4));
  var Ce, Ie = le[re >= 4 ? 1 : 2];
  switch (Ie) {
    case 0:
      return;
    case 2:
      Ce = { t: "n", v: xe };
      break;
    case 3:
      Ce = { t: "s", v: Y.sst[_e] };
      break;
    case 5:
      oe?.cellDates ? Ce = { t: "d", v: Se } : Ce = { t: "n", v: Ee / 86400 + 35430, z: table_fmt[14] };
      break;
    case 6:
      Ce = { t: "b", v: xe > 0 };
      break;
    case 7:
      Ce = { t: "n", v: xe };
      break;
    case 8:
      Ce = { t: "e", v: 0 };
      break;
    case 9:
      if (he > -1) {
        var Ne = Y.rsst[he];
        Ce = { t: "s", v: Ne.v }, Ne.l && (Ce.l = { Target: Ne.l });
      } else
        throw new Error("Unsupported cell type ".concat(le[subarray](0, 4)));
      break;
    default:
      throw new Error("Unsupported cell type ".concat(le[subarray](0, 4)));
  }
  return ve > -1 && numbers_format_cell(Ce, Ie | re << 8, fe, Y.ofmt[ve], Y.nfmt[ve]), Ie == 7 && (Ce.v /= 86400), Ce;
}
function parse_new_storage(le, Y, re) {
  var oe = u8_to_dataview(le);
  oe.getUint32(4, !0);
  var ue = oe.getUint32(8, !0), fe = 12, he = -1, _e = -1, ve = -1, xe = NaN, Ee = NaN, Se = 0, Te = new Date(Date.UTC(2001, 0, 1));
  ue & 1 && (xe = readDecimal128LE(le, fe), fe += 16), ue & 2 && (Ee = oe.getFloat64(fe, !0), fe += 8), ue & 4 && (Te.setTime(Te.getTime() + (Se = oe.getFloat64(fe, !0)) * 1e3), fe += 8), ue & 8 && (_e = oe.getUint32(fe, !0), fe += 4), ue & 16 && (he = oe.getUint32(fe, !0), fe += 4), fe += popcnt(ue & 480) * 4, ue & 512 && (oe.getUint32(fe, !0), fe += 4), fe += popcnt(ue & 1024) * 4, ue & 2048 && (oe.getUint32(fe, !0), fe += 4);
  var Ce, Ie = le[1];
  switch (Ie) {
    case 0:
      Ce = { t: "z" };
      break;
    case 2:
      Ce = { t: "n", v: xe };
      break;
    case 3:
      Ce = { t: "s", v: Y.sst[_e] };
      break;
    case 5:
      re?.cellDates ? Ce = { t: "d", v: Te } : Ce = { t: "n", v: Se / 86400 + 35430, z: table_fmt[14] };
      break;
    case 6:
      Ce = { t: "b", v: Ee > 0 };
      break;
    case 7:
      Ce = { t: "n", v: Ee };
      break;
    case 8:
      Ce = { t: "e", v: 0 };
      break;
    case 9:
      if (he > -1) {
        var Ne = Y.rsst[he];
        Ce = { t: "s", v: Ne.v }, Ne.l && (Ce.l = { Target: Ne.l });
      } else
        throw new Error("Unsupported cell type ".concat(le[1], " : ").concat(ue & 31, " : ").concat(le[subarray](0, 4)));
      break;
    case 10:
      Ce = { t: "n", v: xe };
      break;
    default:
      throw new Error("Unsupported cell type ".concat(le[1], " : ").concat(ue & 31, " : ").concat(le[subarray](0, 4)));
  }
  if (fe += popcnt(ue & 4096) * 4, ue & 516096 && (ve == -1 && (ve = oe.getUint32(fe, !0)), fe += 4), ue & 524288) {
    var Re = oe.getUint32(fe, !0);
    fe += 4, Y.cmnt[Re] && (Ce.c = iwa_to_s5s_comment(Y.cmnt[Re]));
  }
  return ve > -1 && numbers_format_cell(Ce, Ie | 1280, ue >> 13, Y.ofmt[ve], Y.nfmt[ve]), Ie == 7 && (Ce.v /= 86400), Ce;
}
function write_new_storage(le, Y) {
  var re = new Uint8Array(32), oe = u8_to_dataview(re), ue = 12, fe = 0;
  switch (re[0] = 5, le.t) {
    case "n":
      if (le.z && fmt_is_date(le.z)) {
        re[1] = 5, oe.setFloat64(ue, (numdate(le.v + 1462).getTime() - Date.UTC(2001, 0, 1)) / 1e3, !0), fe |= 4, ue += 8;
        break;
      } else
        re[1] = 2, writeDecimal128LE(re, ue, le.v), fe |= 1, ue += 16;
      break;
    case "b":
      re[1] = 6, oe.setFloat64(ue, le.v ? 1 : 0, !0), fe |= 2, ue += 8;
      break;
    case "s":
      {
        var he = le.v == null ? "" : String(le.v);
        if (le.l) {
          var _e = Y.rsst.findIndex(function(xe) {
            var Ee;
            return xe.v == he && xe.l == ((Ee = le.l) == null ? void 0 : Ee.Target);
          });
          _e == -1 && (Y.rsst[_e = Y.rsst.length] = { v: he, l: le.l.Target }), re[1] = 9, oe.setUint32(ue, _e, !0), fe |= 16, ue += 4;
        } else {
          var ve = Y.sst.indexOf(he);
          ve == -1 && (Y.sst[ve = Y.sst.length] = he), re[1] = 3, oe.setUint32(ue, ve, !0), fe |= 8, ue += 4;
        }
      }
      break;
    case "d":
      re[1] = 5, oe.setFloat64(ue, (le.v.getTime() - Date.UTC(2001, 0, 1)) / 1e3, !0), fe |= 4, ue += 8;
      break;
    case "z":
      re[1] = 0;
      break;
    default:
      throw "unsupported cell type " + le.t;
  }
  return le.c && (Y.cmnt.push(s5s_to_iwa_comment(le.c)), oe.setUint32(ue, Y.cmnt.length - 1, !0), fe |= 524288, ue += 4), oe.setUint32(8, fe, !0), re[subarray](0, ue);
}
function write_old_storage(le, Y) {
  var re = new Uint8Array(32), oe = u8_to_dataview(re), ue = 12, fe = 0, he = "";
  switch (re[0] = 4, le.t) {
    case "n":
      break;
    case "b":
      break;
    case "s":
      if (he = le.v == null ? "" : String(le.v), le.l) {
        var _e = Y.rsst.findIndex(function(xe) {
          var Ee;
          return xe.v == he && xe.l == ((Ee = le.l) == null ? void 0 : Ee.Target);
        });
        _e == -1 && (Y.rsst[_e = Y.rsst.length] = { v: he, l: le.l.Target }), re[1] = 9, oe.setUint32(ue, _e, !0), fe |= 512, ue += 4;
      }
      break;
    case "d":
      break;
    case "e":
      break;
    case "z":
      break;
    default:
      throw "unsupported cell type " + le.t;
  }
  switch (le.c && (oe.setUint32(ue, Y.cmnt.length - 1, !0), fe |= 4096, ue += 4), le.t) {
    case "n":
      re[1] = 2, oe.setFloat64(ue, le.v, !0), fe |= 32, ue += 8;
      break;
    case "b":
      re[1] = 6, oe.setFloat64(ue, le.v ? 1 : 0, !0), fe |= 32, ue += 8;
      break;
    case "s":
      if (he = le.v == null ? "" : String(le.v), !le.l) {
        var ve = Y.sst.indexOf(he);
        ve == -1 && (Y.sst[ve = Y.sst.length] = he), re[1] = 3, oe.setUint32(ue, ve, !0), fe |= 16, ue += 4;
      }
      break;
    case "d":
      re[1] = 5, oe.setFloat64(ue, (le.v.getTime() - Date.UTC(2001, 0, 1)) / 1e3, !0), fe |= 64, ue += 8;
      break;
    case "z":
      re[1] = 0;
      break;
    default:
      throw "unsupported cell type " + le.t;
  }
  return oe.setUint32(8, fe, !0), re[subarray](0, ue);
}
function parse_cell_storage(le, Y, re) {
  switch (le[0]) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return parse_old_storage(le, Y, le[0], re);
    case 5:
      return parse_new_storage(le, Y, re);
    default:
      throw new Error("Unsupported payload version ".concat(le[0]));
  }
}
function parse_TSP_Reference(le) {
  var Y = parse_shallow(le);
  return varint_to_i32(Y[1][0].data);
}
function write_TSP_Reference(le) {
  return write_shallow([
    [],
    [{ type: 0, data: write_varint49(le) }]
  ]);
}
function numbers_add_oref(le, Y) {
  var re, oe = (re = le.messages[0].meta[5]) != null && re[0] ? parse_packed_varints(le.messages[0].meta[5][0].data) : [], ue = oe.indexOf(Y);
  ue == -1 && (oe.push(Y), le.messages[0].meta[5] = [{ type: 2, data: write_packed_varints(oe) }]);
}
function numbers_del_oref(le, Y) {
  var re, oe = (re = le.messages[0].meta[5]) != null && re[0] ? parse_packed_varints(le.messages[0].meta[5][0].data) : [];
  le.messages[0].meta[5] = [{ type: 2, data: write_packed_varints(oe.filter(function(ue) {
    return ue != Y;
  })) }];
}
function parse_TST_TableDataList(le, Y) {
  var re = parse_shallow(Y.data), oe = varint_to_i32(re[1][0].data), ue = re[3], fe = [];
  return (ue || []).forEach(function(he) {
    var _e, ve, xe = parse_shallow(he.data);
    if (xe[1]) {
      var Ee = varint_to_i32(xe[1][0].data) >>> 0;
      switch (oe) {
        case 1:
          fe[Ee] = u8str(xe[3][0].data);
          break;
        case 8:
          {
            var Se = le[parse_TSP_Reference(xe[9][0].data)][0], Te = parse_shallow(Se.data), Ce = le[parse_TSP_Reference(Te[1][0].data)][0], Ie = varint_to_i32(Ce.meta[1][0].data);
            if (Ie != 2001)
              throw new Error("2000 unexpected reference to ".concat(Ie));
            var Ne = parse_shallow(Ce.data), Re = { v: Ne[3].map(function(Fe) {
              return u8str(Fe.data);
            }).join("") };
            fe[Ee] = Re;
            e:
              if ((_e = Ne?.[11]) != null && _e[0]) {
                var Ae = (ve = parse_shallow(Ne[11][0].data)) == null ? void 0 : ve[1];
                if (!Ae)
                  break e;
                Ae.forEach(function(Fe) {
                  var Le, He, Ge, Ve = parse_shallow(Fe.data);
                  if ((Le = Ve[2]) != null && Le[0]) {
                    var $e = le[parse_TSP_Reference((He = Ve[2]) == null ? void 0 : He[0].data)][0], De = varint_to_i32($e.meta[1][0].data);
                    switch (De) {
                      case 2032:
                        var Ke = parse_shallow($e.data);
                        (Ge = Ke?.[2]) != null && Ge[0] && !Re.l && (Re.l = u8str(Ke[2][0].data));
                        break;
                      case 2039:
                        break;
                      default:
                        console.log("unrecognized ObjectAttribute type ".concat(De));
                    }
                  }
                });
              }
          }
          break;
        case 2:
          fe[Ee] = parse_shallow(xe[6][0].data);
          break;
        case 3:
          fe[Ee] = parse_shallow(xe[5][0].data);
          break;
        case 10:
          {
            var Pe = le[parse_TSP_Reference(xe[10][0].data)][0];
            fe[Ee] = parse_TSD_CommentStorageArchive(le, Pe.data);
          }
          break;
        default:
          throw oe;
      }
    }
  }), fe;
}
function parse_TST_TileRowInfo(le, Y) {
  var re, oe, ue, fe, he, _e, ve, xe, Ee, Se, Te, Ce, Ie, Ne, Re = parse_shallow(le), Ae = varint_to_i32(Re[1][0].data) >>> 0, Pe = varint_to_i32(Re[2][0].data) >>> 0, Fe = ((oe = (re = Re[8]) == null ? void 0 : re[0]) == null ? void 0 : oe.data) && varint_to_i32(Re[8][0].data) > 0 || !1, Le, He;
  if ((fe = (ue = Re[7]) == null ? void 0 : ue[0]) != null && fe.data && Y != 0)
    Le = (_e = (he = Re[7]) == null ? void 0 : he[0]) == null ? void 0 : _e.data, He = (xe = (ve = Re[6]) == null ? void 0 : ve[0]) == null ? void 0 : xe.data;
  else if ((Se = (Ee = Re[4]) == null ? void 0 : Ee[0]) != null && Se.data && Y != 1)
    Le = (Ce = (Te = Re[4]) == null ? void 0 : Te[0]) == null ? void 0 : Ce.data, He = (Ne = (Ie = Re[3]) == null ? void 0 : Ie[0]) == null ? void 0 : Ne.data;
  else
    throw "NUMBERS Tile missing ".concat(Y, " cell storage");
  for (var Ge = Fe ? 4 : 1, Ve = u8_to_dataview(Le), $e = [], De = 0; De < Le.length / 2; ++De) {
    var Ke = Ve.getUint16(De * 2, !0);
    Ke < 65535 && $e.push([De, Ke]);
  }
  if ($e.length != Pe)
    throw "Expected ".concat(Pe, " cells, found ").concat($e.length);
  var ze = [];
  for (De = 0; De < $e.length - 1; ++De)
    ze[$e[De][0]] = He[subarray]($e[De][1] * Ge, $e[De + 1][1] * Ge);
  return $e.length >= 1 && (ze[$e[$e.length - 1][0]] = He[subarray]($e[$e.length - 1][1] * Ge)), { R: Ae, cells: ze };
}
function parse_TST_Tile(le, Y) {
  var re, oe = parse_shallow(Y.data), ue = -1;
  (re = oe?.[7]) != null && re[0] && (varint_to_i32(oe[7][0].data) >>> 0 ? ue = 1 : ue = 0);
  var fe = mappa(oe[5], function(he) {
    return parse_TST_TileRowInfo(he, ue);
  });
  return {
    nrows: varint_to_i32(oe[4][0].data) >>> 0,
    data: fe.reduce(function(he, _e) {
      return he[_e.R] || (he[_e.R] = []), _e.cells.forEach(function(ve, xe) {
        if (he[_e.R][xe])
          throw new Error("Duplicate cell r=".concat(_e.R, " c=").concat(xe));
        he[_e.R][xe] = ve;
      }), he;
    }, [])
  };
}
function parse_TSD_CommentStorageArchive(le, Y) {
  var re, oe, ue, fe, he, _e, ve, xe, Ee, Se, Te = { t: "", a: "" }, Ce = parse_shallow(Y);
  if ((oe = (re = Ce?.[1]) == null ? void 0 : re[0]) != null && oe.data && (Te.t = u8str((fe = (ue = Ce?.[1]) == null ? void 0 : ue[0]) == null ? void 0 : fe.data) || ""), (_e = (he = Ce?.[3]) == null ? void 0 : he[0]) != null && _e.data) {
    var Ie = le[parse_TSP_Reference((xe = (ve = Ce?.[3]) == null ? void 0 : ve[0]) == null ? void 0 : xe.data)][0], Ne = parse_shallow(Ie.data);
    (Se = (Ee = Ne[1]) == null ? void 0 : Ee[0]) != null && Se.data && (Te.a = u8str(Ne[1][0].data));
  }
  return Ce?.[4] && (Te.replies = [], Ce[4].forEach(function(Re) {
    var Ae = le[parse_TSP_Reference(Re.data)][0];
    Te.replies.push(parse_TSD_CommentStorageArchive(le, Ae.data));
  })), Te;
}
function iwa_to_s5s_comment(le) {
  var Y = [];
  return Y.push({ t: le.t || "", a: le.a, T: le.replies && le.replies.length > 0 }), le.replies && le.replies.forEach(function(re) {
    Y.push({ t: re.t || "", a: re.a, T: !0 });
  }), Y;
}
function s5s_to_iwa_comment(le) {
  for (var Y = { a: "", t: "", replies: [] }, re = 0; re < le.length; ++re)
    re == 0 ? (Y.a = le[re].a, Y.t = le[re].t) : Y.replies.push({ a: le[re].a, t: le[re].t });
  return Y;
}
function parse_TST_TableModelArchive(le, Y, re, oe) {
  var ue, fe, he, _e, ve, xe, Ee, Se, Te, Ce, Ie, Ne, Re, Ae, Pe = parse_shallow(Y.data), Fe = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  if (Fe.e.r = (varint_to_i32(Pe[6][0].data) >>> 0) - 1, Fe.e.r < 0)
    throw new Error("Invalid row varint ".concat(Pe[6][0].data));
  if (Fe.e.c = (varint_to_i32(Pe[7][0].data) >>> 0) - 1, Fe.e.c < 0)
    throw new Error("Invalid col varint ".concat(Pe[7][0].data));
  re["!ref"] = encode_range(Fe);
  var Le = re["!data"] != null, He = re, Ge = parse_shallow(Pe[4][0].data), Ve = numbers_lut_new();
  (ue = Ge[4]) != null && ue[0] && (Ve.sst = parse_TST_TableDataList(le, le[parse_TSP_Reference(Ge[4][0].data)][0])), (fe = Ge[6]) != null && fe[0] && (Ve.fmla = parse_TST_TableDataList(le, le[parse_TSP_Reference(Ge[6][0].data)][0])), (he = Ge[11]) != null && he[0] && (Ve.ofmt = parse_TST_TableDataList(le, le[parse_TSP_Reference(Ge[11][0].data)][0])), (_e = Ge[12]) != null && _e[0] && (Ve.ferr = parse_TST_TableDataList(le, le[parse_TSP_Reference(Ge[12][0].data)][0])), (ve = Ge[17]) != null && ve[0] && (Ve.rsst = parse_TST_TableDataList(le, le[parse_TSP_Reference(Ge[17][0].data)][0])), (xe = Ge[19]) != null && xe[0] && (Ve.cmnt = parse_TST_TableDataList(le, le[parse_TSP_Reference(Ge[19][0].data)][0])), (Ee = Ge[22]) != null && Ee[0] && (Ve.nfmt = parse_TST_TableDataList(le, le[parse_TSP_Reference(Ge[22][0].data)][0]));
  var $e = parse_shallow(Ge[3][0].data), De = 0;
  if (!((Se = Ge[9]) != null && Se[0]))
    throw "NUMBERS file missing row tree";
  var Ke = parse_shallow(Ge[9][0].data)[1].map(function(at) {
    return parse_shallow(at.data);
  });
  if (Ke.forEach(function(at) {
    De = varint_to_i32(at[1][0].data);
    var qe = varint_to_i32(at[2][0].data), st = $e[1][qe];
    if (!st)
      throw "NUMBERS missing tile " + qe;
    var xt = parse_shallow(st.data), gt = le[parse_TSP_Reference(xt[2][0].data)][0], Ze = varint_to_i32(gt.meta[1][0].data);
    if (Ze != 6002)
      throw new Error("6001 unexpected reference to ".concat(Ze));
    var _t = parse_TST_Tile(le, gt);
    _t.data.forEach(function(wt, yt) {
      wt.forEach(function(St, It) {
        var Bt = parse_cell_storage(St, Ve, oe);
        Bt && (Le ? (He["!data"][De + yt] || (He["!data"][De + yt] = []), He["!data"][De + yt][It] = Bt) : re[encode_col(It) + encode_row(De + yt)] = Bt);
      });
    }), De += _t.nrows;
  }), (Te = Ge[13]) != null && Te[0]) {
    var ze = le[parse_TSP_Reference(Ge[13][0].data)][0], tt = varint_to_i32(ze.meta[1][0].data);
    if (tt != 6144)
      throw new Error("Expected merge type 6144, found ".concat(tt));
    re["!merges"] = (Ce = parse_shallow(ze.data)) == null ? void 0 : Ce[1].map(function(at) {
      var qe = parse_shallow(at.data), st = u8_to_dataview(parse_shallow(qe[1][0].data)[1][0].data), xt = u8_to_dataview(parse_shallow(qe[2][0].data)[1][0].data);
      return {
        s: { r: st.getUint16(0, !0), c: st.getUint16(2, !0) },
        e: {
          r: st.getUint16(0, !0) + xt.getUint16(0, !0) - 1,
          c: st.getUint16(2, !0) + xt.getUint16(2, !0) - 1
        }
      };
    });
  }
  if (!((Ie = re["!merges"]) != null && Ie.length) && ((Ne = Pe[47]) != null && Ne[0])) {
    var Xe = parse_shallow(Pe[47][0].data);
    if ((Re = Xe[2]) != null && Re[0]) {
      var mt = parse_shallow(Xe[2][0].data);
      (Ae = mt[3]) != null && Ae[0] && (re["!merges"] = mappa(mt[3], function(at) {
        var qe, st, xt, gt, Ze, _t = parse_shallow(at), wt = parse_shallow(_t[2][0].data), yt = parse_shallow(wt[1][0].data);
        if ((qe = yt[1]) != null && qe[0]) {
          var St = parse_shallow(yt[1][0].data), It = varint_to_i32(St[1][0].data);
          if (It == 67) {
            var Bt = parse_shallow(St[40][0].data);
            if (!(!((st = Bt[3]) != null && st[0]) || !((xt = Bt[4]) != null && xt[0]))) {
              var Ye = parse_shallow(Bt[3][0].data), Be = parse_shallow(Bt[4][0].data), et = varint_to_i32(Ye[1][0].data), je = (gt = Ye[2]) != null && gt[0] ? varint_to_i32(Ye[2][0].data) : et, it = varint_to_i32(Be[1][0].data), bt = (Ze = Be[2]) != null && Ze[0] ? varint_to_i32(Be[2][0].data) : it;
              return { s: { r: it, c: et }, e: { r: bt, c: je } };
            }
          }
        }
      }).filter(function(at) {
        return at != null;
      }));
    }
  }
}
function parse_TST_TableInfoArchive(le, Y, re) {
  var oe = parse_shallow(Y.data), ue = { "!ref": "A1" };
  re?.dense && (ue["!data"] = []);
  var fe = le[parse_TSP_Reference(oe[2][0].data)], he = varint_to_i32(fe[0].meta[1][0].data);
  if (he != 6001)
    throw new Error("6000 unexpected reference to ".concat(he));
  return parse_TST_TableModelArchive(le, fe[0], ue, re), ue;
}
function parse_TN_SheetArchive(le, Y, re) {
  var oe, ue = parse_shallow(Y.data), fe = {
    name: (oe = ue[1]) != null && oe[0] ? u8str(ue[1][0].data) : "",
    sheets: []
  }, he = mappa(ue[2], parse_TSP_Reference);
  return he.forEach(function(_e) {
    le[_e].forEach(function(ve) {
      var xe = varint_to_i32(ve.meta[1][0].data);
      xe == 6e3 && fe.sheets.push(parse_TST_TableInfoArchive(le, ve, re));
    });
  }), fe;
}
function parse_TN_DocumentArchive(le, Y, re) {
  var oe, ue = book_new();
  ue.Workbook = { WBProps: { date1904: !0 } };
  var fe = parse_shallow(Y.data);
  if ((oe = fe[2]) != null && oe[0])
    throw new Error("Keynote presentations are not supported");
  var he = mappa(fe[1], parse_TSP_Reference);
  if (he.forEach(function(_e) {
    le[_e].forEach(function(ve) {
      var xe = varint_to_i32(ve.meta[1][0].data);
      if (xe == 2) {
        var Ee = parse_TN_SheetArchive(le, ve, re);
        Ee.sheets.forEach(function(Se, Te) {
          book_append_sheet(ue, Se, Te == 0 ? Ee.name : Ee.name + "_" + Te, !0);
        });
      }
    });
  }), ue.SheetNames.length == 0)
    throw new Error("Empty NUMBERS file");
  return ue.bookType = "numbers", ue;
}
function parse_numbers_iwa(le, Y) {
  var re, oe, ue, fe, he, _e, ve, xe = {}, Ee = [];
  if (le.FullPaths.forEach(function(Te) {
    if (Te.match(/\.iwpv2/))
      throw new Error("Unsupported password protection");
  }), le.FileIndex.forEach(function(Te) {
    if (Te.name.match(/\.iwa$/) && Te.content[0] == 0) {
      var Ce;
      try {
        Ce = decompress_iwa_file(Te.content);
      } catch (Ne) {
        return console.log("?? " + Te.content.length + " " + (Ne.message || Ne));
      }
      var Ie;
      try {
        Ie = parse_iwa_file(Ce);
      } catch (Ne) {
        return console.log("## " + (Ne.message || Ne));
      }
      Ie.forEach(function(Ne) {
        xe[Ne.id] = Ne.messages, Ee.push(Ne.id);
      });
    }
  }), !Ee.length)
    throw new Error("File has no messages");
  if ((ue = (oe = (re = xe?.[1]) == null ? void 0 : re[0].meta) == null ? void 0 : oe[1]) != null && ue[0].data && varint_to_i32(xe[1][0].meta[1][0].data) == 1e4)
    throw new Error("Pages documents are not supported");
  var Se = ((ve = (_e = (he = (fe = xe?.[1]) == null ? void 0 : fe[0]) == null ? void 0 : he.meta) == null ? void 0 : _e[1]) == null ? void 0 : ve[0].data) && varint_to_i32(xe[1][0].meta[1][0].data) == 1 && xe[1][0];
  if (Se || Ee.forEach(function(Te) {
    xe[Te].forEach(function(Ce) {
      var Ie = varint_to_i32(Ce.meta[1][0].data) >>> 0;
      if (Ie == 1)
        if (!Se)
          Se = Ce;
        else
          throw new Error("Document has multiple roots");
    });
  }), !Se)
    throw new Error("Cannot find Document root");
  return parse_TN_DocumentArchive(xe, Se, Y);
}
function write_TST_TileRowInfo(le, Y, re) {
  var oe, ue, fe, he = [
    [],
    [{ type: 0, data: write_varint49(0) }],
    [{ type: 0, data: write_varint49(0) }],
    [{ type: 2, data: new Uint8Array([]) }],
    [{ type: 2, data: new Uint8Array(Array.from({ length: 510 }, function() {
      return 255;
    })) }],
    [{ type: 0, data: write_varint49(5) }],
    [{ type: 2, data: new Uint8Array([]) }],
    [{ type: 2, data: new Uint8Array(Array.from({ length: 510 }, function() {
      return 255;
    })) }],
    [{ type: 0, data: write_varint49(1) }]
  ];
  if (!((oe = he[6]) != null && oe[0]) || !((ue = he[7]) != null && ue[0]))
    throw "Mutation only works on post-BNC storages!";
  var _e = 0;
  if (he[7][0].data.length < 2 * le.length) {
    var ve = new Uint8Array(2 * le.length);
    ve.set(he[7][0].data), he[7][0].data = ve;
  }
  if (he[4][0].data.length < 2 * le.length) {
    var xe = new Uint8Array(2 * le.length);
    xe.set(he[4][0].data), he[4][0].data = xe;
  }
  for (var Ee = u8_to_dataview(he[7][0].data), Se = 0, Te = [], Ce = u8_to_dataview(he[4][0].data), Ie = 0, Ne = [], Re = 4, Ae = 0; Ae < le.length; ++Ae) {
    if (le[Ae] == null || le[Ae].t == "z" && !((fe = le[Ae].c) != null && fe.length) || le[Ae].t == "e") {
      Ee.setUint16(Ae * 2, 65535, !0), Ce.setUint16(Ae * 2, 65535);
      continue;
    }
    Ee.setUint16(Ae * 2, Se / Re, !0), Ce.setUint16(Ae * 2, Ie / Re, !0);
    var Pe, Fe;
    switch (le[Ae].t) {
      case "d":
        if (le[Ae].v instanceof Date) {
          Pe = write_new_storage(le[Ae], Y), Fe = write_old_storage(le[Ae], Y);
          break;
        }
        Pe = write_new_storage(le[Ae], Y), Fe = write_old_storage(le[Ae], Y);
        break;
      case "s":
      case "n":
      case "b":
      case "z":
        Pe = write_new_storage(le[Ae], Y), Fe = write_old_storage(le[Ae], Y);
        break;
      default:
        throw new Error("Unsupported value " + le[Ae]);
    }
    Te.push(Pe), Se += Pe.length, Ne.push(Fe), Ie += Fe.length, ++_e;
  }
  for (he[2][0].data = write_varint49(_e), he[5][0].data = write_varint49(5); Ae < he[7][0].data.length / 2; ++Ae)
    Ee.setUint16(Ae * 2, 65535, !0), Ce.setUint16(Ae * 2, 65535, !0);
  return he[6][0].data = u8concat(Te), he[3][0].data = u8concat(Ne), he[8] = [{ type: 0, data: write_varint49(1) }], he;
}
function write_iwam(le, Y) {
  return {
    meta: [
      [],
      [{ type: 0, data: write_varint49(le) }]
    ],
    data: Y
  };
}
function get_unique_msgid(le, Y) {
  Y.last || (Y.last = 927262);
  for (var re = Y.last; re < 2e6; ++re)
    if (!Y[re])
      return Y[Y.last = re] = le, re;
  throw new Error("Too many messages");
}
function build_numbers_deps(le) {
  var Y = {}, re = [];
  return le.FileIndex.map(function(oe, ue) {
    return [oe, le.FullPaths[ue]];
  }).forEach(function(oe) {
    var ue = oe[0], fe = oe[1];
    ue.type == 2 && ue.name.match(/\.iwa/) && ue.content[0] == 0 && parse_iwa_file(decompress_iwa_file(ue.content)).forEach(function(he) {
      re.push(he.id), Y[he.id] = { deps: [], location: fe, type: varint_to_i32(he.messages[0].meta[1][0].data) };
    });
  }), le.FileIndex.forEach(function(oe) {
    oe.name.match(/\.iwa/) && oe.content[0] == 0 && parse_iwa_file(decompress_iwa_file(oe.content)).forEach(function(ue) {
      ue.messages.forEach(function(fe) {
        [5, 6].forEach(function(he) {
          fe.meta[he] && fe.meta[he].forEach(function(_e) {
            Y[ue.id].deps.push(varint_to_i32(_e.data));
          });
        });
      });
    });
  }), Y;
}
function write_TSP_Color_RGB(le, Y, re) {
  return write_shallow([
    [],
    [{ type: 0, data: write_varint49(1) }],
    [],
    [{ type: 5, data: new Uint8Array(Float32Array.from([le / 255]).buffer) }],
    [{ type: 5, data: new Uint8Array(Float32Array.from([Y / 255]).buffer) }],
    [{ type: 5, data: new Uint8Array(Float32Array.from([re / 255]).buffer) }],
    [{ type: 5, data: new Uint8Array(Float32Array.from([1]).buffer) }],
    [],
    [],
    [],
    [],
    [],
    [{ type: 0, data: write_varint49(1) }]
  ]);
}
function get_author_color(le) {
  switch (le) {
    case 0:
      return write_TSP_Color_RGB(99, 222, 171);
    case 1:
      return write_TSP_Color_RGB(162, 197, 240);
    case 2:
      return write_TSP_Color_RGB(255, 189, 189);
  }
  return write_TSP_Color_RGB(Math.random() * 255, Math.random() * 255, Math.random() * 255);
}
function write_numbers_iwa(le, Y) {
  if (!Y || !Y.numbers)
    throw new Error("Must pass a `numbers` option -- check the README");
  var re = CFB.read(Y.numbers, { type: "base64" }), oe = build_numbers_deps(re), ue = numbers_iwa_find(re, oe, 1);
  if (ue == null)
    throw "Could not find message ".concat(1, " in Numbers template");
  var fe = mappa(parse_shallow(ue.messages[0].data)[1], parse_TSP_Reference);
  if (fe.length > 1)
    throw new Error("Template NUMBERS file must have exactly one sheet");
  return le.SheetNames.forEach(function(he, _e) {
    _e >= 1 && (numbers_add_ws(re, oe, _e + 1), ue = numbers_iwa_find(re, oe, 1), fe = mappa(parse_shallow(ue.messages[0].data)[1], parse_TSP_Reference)), write_numbers_ws(re, oe, le.Sheets[he], he, _e, fe[_e]);
  }), re;
}
function numbers_iwa_doit(le, Y, re, oe) {
  var ue = CFB.find(le, Y[re].location);
  if (!ue)
    throw "Could not find ".concat(Y[re].location, " in Numbers template");
  var fe = parse_iwa_file(decompress_iwa_file(ue.content)), he = fe.find(function(_e) {
    return _e.id == re;
  });
  oe(he, fe), ue.content = compress_iwa_file(write_iwa_file(fe)), ue.size = ue.content.length;
}
function numbers_iwa_find(le, Y, re) {
  var oe = CFB.find(le, Y[re].location);
  if (!oe)
    throw "Could not find ".concat(Y[re].location, " in Numbers template");
  var ue = parse_iwa_file(decompress_iwa_file(oe.content)), fe = ue.find(function(he) {
    return he.id == re;
  });
  return fe;
}
function numbers_add_meta(le, Y, re) {
  le[3].push({ type: 2, data: write_shallow([
    [],
    [{ type: 0, data: write_varint49(Y) }],
    [{ type: 2, data: stru8(re.replace(/-[\s\S]*$/, "")) }],
    [{ type: 2, data: stru8(re) }],
    [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
    [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
    [],
    [],
    [],
    [],
    [{ type: 0, data: write_varint49(0) }],
    [],
    [{ type: 0, data: write_varint49(0) }]
  ]) }), le[1] = [{ type: 0, data: write_varint49(Math.max(Y + 1, varint_to_i32(le[1][0].data))) }];
}
function numbers_add_msg(le, Y, re, oe, ue, fe) {
  fe || (fe = get_unique_msgid({ deps: [], location: "", type: Y }, ue));
  var he = "".concat(oe, "-").concat(fe, ".iwa");
  ue[fe].location = "Root Entry" + he, CFB.utils.cfb_add(le, he, compress_iwa_file(write_iwa_file([{
    id: fe,
    messages: [write_iwam(Y, write_shallow(re))]
  }])));
  var _e = he.replace(/^[\/]/, "").replace(/^Index\//, "").replace(/\.iwa$/, "");
  return numbers_iwa_doit(le, ue, 2, function(ve) {
    var xe = parse_shallow(ve.messages[0].data);
    numbers_add_meta(xe, fe || 0, _e), ve.messages[0].data = write_shallow(xe);
  }), fe;
}
function numbers_meta_add_dep(le, Y, re, oe) {
  var ue = Y[re].location.replace(/^Root Entry\//, "").replace(/^Index\//, "").replace(/\.iwa$/, ""), fe = le[3].findIndex(function(_e) {
    var ve, xe, Ee = parse_shallow(_e.data);
    return (ve = Ee[3]) != null && ve[0] ? u8str(Ee[3][0].data) == ue : !!((xe = Ee[2]) != null && xe[0] && u8str(Ee[2][0].data) == ue);
  }), he = parse_shallow(le[3][fe].data);
  he[6] || (he[6] = []), (Array.isArray(oe) ? oe : [oe]).forEach(function(_e) {
    he[6].push({
      type: 2,
      data: write_shallow([
        [],
        [{ type: 0, data: write_varint49(_e) }]
      ])
    });
  }), le[3][fe].data = write_shallow(he);
}
function numbers_meta_del_dep(le, Y, re, oe) {
  var ue = Y[re].location.replace(/^Root Entry\//, "").replace(/^Index\//, "").replace(/\.iwa$/, ""), fe = le[3].findIndex(function(_e) {
    var ve, xe, Ee = parse_shallow(_e.data);
    return (ve = Ee[3]) != null && ve[0] ? u8str(Ee[3][0].data) == ue : !!((xe = Ee[2]) != null && xe[0] && u8str(Ee[2][0].data) == ue);
  }), he = parse_shallow(le[3][fe].data);
  he[6] || (he[6] = []), he[6] = he[6].filter(function(_e) {
    return varint_to_i32(parse_shallow(_e.data)[1][0].data) != oe;
  }), le[3][fe].data = write_shallow(he);
}
function numbers_add_ws(le, Y, re) {
  var oe = -1, ue = -1, fe = {};
  numbers_iwa_doit(le, Y, 1, function(ve, xe) {
    var Ee = parse_shallow(ve.messages[0].data);
    oe = parse_TSP_Reference(parse_shallow(ve.messages[0].data)[1][0].data), ue = get_unique_msgid({ deps: [1], location: Y[oe].location, type: 2 }, Y), fe[oe] = ue, numbers_add_oref(ve, ue), Ee[1].push({ type: 2, data: write_TSP_Reference(ue) });
    var Se = numbers_iwa_find(le, Y, oe);
    Se.id = ue, Y[1].location == Y[ue].location ? xe.push(Se) : numbers_iwa_doit(le, Y, ue, function(Te, Ce) {
      return Ce.push(Se);
    }), ve.messages[0].data = write_shallow(Ee);
  });
  var he = -1;
  numbers_iwa_doit(le, Y, ue, function(ve, xe) {
    for (var Ee = parse_shallow(ve.messages[0].data), Se = 3; Se <= 69; ++Se)
      delete Ee[Se];
    var Te = mappa(Ee[2], parse_TSP_Reference);
    Te.forEach(function(Ie) {
      return numbers_del_oref(ve, Ie);
    }), he = get_unique_msgid({ deps: [ue], location: Y[Te[0]].location, type: Y[Te[0]].type }, Y), numbers_add_oref(ve, he), fe[Te[0]] = he, Ee[2] = [{ type: 2, data: write_TSP_Reference(he) }];
    var Ce = numbers_iwa_find(le, Y, Te[0]);
    Ce.id = he, Y[Te[0]].location == Y[ue].location ? xe.push(Ce) : (numbers_iwa_doit(le, Y, 2, function(Ie) {
      var Ne = parse_shallow(Ie.messages[0].data);
      numbers_meta_add_dep(Ne, Y, ue, he), Ie.messages[0].data = write_shallow(Ne);
    }), numbers_iwa_doit(le, Y, he, function(Ie, Ne) {
      return Ne.push(Ce);
    })), ve.messages[0].data = write_shallow(Ee);
  });
  var _e = -1;
  numbers_iwa_doit(le, Y, he, function(ve, xe) {
    for (var Ee = parse_shallow(ve.messages[0].data), Se = parse_shallow(Ee[1][0].data), Te = 3; Te <= 69; ++Te)
      delete Se[Te];
    var Ce = parse_TSP_Reference(Se[2][0].data);
    Se[2][0].data = write_TSP_Reference(fe[Ce]), Ee[1][0].data = write_shallow(Se);
    var Ie = parse_TSP_Reference(Ee[2][0].data);
    numbers_del_oref(ve, Ie), _e = get_unique_msgid({ deps: [he], location: Y[Ie].location, type: Y[Ie].type }, Y), numbers_add_oref(ve, _e), fe[Ie] = _e, Ee[2][0].data = write_TSP_Reference(_e);
    var Ne = numbers_iwa_find(le, Y, Ie);
    Ne.id = _e, Y[he].location == Y[_e].location ? xe.push(Ne) : numbers_iwa_doit(le, Y, _e, function(Re, Ae) {
      return Ae.push(Ne);
    }), ve.messages[0].data = write_shallow(Ee);
  }), numbers_iwa_doit(le, Y, _e, function(ve, xe) {
    var Ee, Se, Te = parse_shallow(ve.messages[0].data), Ce = u8str(Te[1][0].data), Ie = Ce.replace(/-[A-Z0-9]*/, "-".concat(("0000" + re.toString(16)).slice(-4)));
    if (Te[1][0].data = stru8(Ie), [12, 13, 29, 31, 32, 33, 39, 44, 47, 81, 82, 84].forEach(function(He) {
      return delete Te[He];
    }), Te[45]) {
      var Ne = parse_shallow(Te[45][0].data), Re = parse_TSP_Reference(Ne[1][0].data);
      numbers_del_oref(ve, Re), delete Te[45];
    }
    if (Te[70]) {
      var Ae = parse_shallow(Te[70][0].data);
      (Ee = Ae[2]) == null || Ee.forEach(function(He) {
        var Ge = parse_shallow(He.data);
        [2, 3].map(function(Ve) {
          return Ge[Ve][0];
        }).forEach(function(Ve) {
          var $e = parse_shallow(Ve.data);
          if ($e[8]) {
            var De = parse_TSP_Reference($e[8][0].data);
            numbers_del_oref(ve, De);
          }
        });
      }), delete Te[70];
    }
    [
      46,
      30,
      34,
      35,
      36,
      38,
      48,
      49,
      60,
      61,
      62,
      63,
      64,
      71,
      72,
      73,
      74,
      75,
      85,
      86,
      87,
      88,
      89
    ].forEach(function(He) {
      if (Te[He]) {
        var Ge = parse_TSP_Reference(Te[He][0].data);
        delete Te[He], numbers_del_oref(ve, Ge);
      }
    });
    var Pe = parse_shallow(Te[4][0].data);
    {
      [2, 4, 5, 6, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22].forEach(function(He) {
        var Ge;
        if ((Ge = Pe[He]) != null && Ge[0]) {
          var Ve = parse_TSP_Reference(Pe[He][0].data), $e = get_unique_msgid({ deps: [_e], location: Y[Ve].location, type: Y[Ve].type }, Y);
          numbers_del_oref(ve, Ve), numbers_add_oref(ve, $e), fe[Ve] = $e;
          var De = numbers_iwa_find(le, Y, Ve);
          if (De.id = $e, Y[Ve].location == Y[_e].location)
            xe.push(De);
          else {
            Y[$e].location = Y[Ve].location.replace(Ve.toString(), $e.toString()), Y[$e].location == Y[Ve].location && (Y[$e].location = Y[$e].location.replace(/\.iwa/, "-".concat($e, ".iwa"))), CFB.utils.cfb_add(le, Y[$e].location, compress_iwa_file(write_iwa_file([De])));
            var Ke = Y[$e].location.replace(/^Root Entry\//, "").replace(/^Index\//, "").replace(/\.iwa$/, "");
            numbers_iwa_doit(le, Y, 2, function(ze) {
              var tt = parse_shallow(ze.messages[0].data);
              numbers_add_meta(tt, $e, Ke), numbers_meta_add_dep(tt, Y, _e, $e), ze.messages[0].data = write_shallow(tt);
            });
          }
          Pe[He][0].data = write_TSP_Reference($e);
        }
      });
      var Fe = parse_shallow(Pe[1][0].data);
      (Se = Fe[2]) == null || Se.forEach(function(He) {
        var Ge = parse_TSP_Reference(He.data), Ve = get_unique_msgid({ deps: [_e], location: Y[Ge].location, type: Y[Ge].type }, Y);
        numbers_del_oref(ve, Ge), numbers_add_oref(ve, Ve), fe[Ge] = Ve;
        var $e = numbers_iwa_find(le, Y, Ge);
        if ($e.id = Ve, Y[Ge].location == Y[_e].location)
          xe.push($e);
        else {
          Y[Ve].location = Y[Ge].location.replace(Ge.toString(), Ve.toString()), Y[Ve].location == Y[Ge].location && (Y[Ve].location = Y[Ve].location.replace(/\.iwa/, "-".concat(Ve, ".iwa"))), CFB.utils.cfb_add(le, Y[Ve].location, compress_iwa_file(write_iwa_file([$e])));
          var De = Y[Ve].location.replace(/^Root Entry\//, "").replace(/^Index\//, "").replace(/\.iwa$/, "");
          numbers_iwa_doit(le, Y, 2, function(Ke) {
            var ze = parse_shallow(Ke.messages[0].data);
            numbers_add_meta(ze, Ve, De), numbers_meta_add_dep(ze, Y, _e, Ve), Ke.messages[0].data = write_shallow(ze);
          });
        }
        He.data = write_TSP_Reference(Ve);
      }), Pe[1][0].data = write_shallow(Fe);
      var Le = parse_shallow(Pe[3][0].data);
      Le[1].forEach(function(He) {
        var Ge = parse_shallow(He.data), Ve = parse_TSP_Reference(Ge[2][0].data), $e = fe[Ve];
        if (!fe[Ve]) {
          $e = get_unique_msgid({ deps: [_e], location: "", type: Y[Ve].type }, Y), Y[$e].location = "Root Entry/Index/Tables/Tile-".concat($e, ".iwa"), fe[Ve] = $e;
          var De = numbers_iwa_find(le, Y, Ve);
          De.id = $e, numbers_del_oref(ve, Ve), numbers_add_oref(ve, $e), CFB.utils.cfb_add(le, "/Index/Tables/Tile-".concat($e, ".iwa"), compress_iwa_file(write_iwa_file([De]))), numbers_iwa_doit(le, Y, 2, function(Ke) {
            var ze = parse_shallow(Ke.messages[0].data);
            ze[3].push({ type: 2, data: write_shallow([
              [],
              [{ type: 0, data: write_varint49($e) }],
              [{ type: 2, data: stru8("Tables/Tile") }],
              [{ type: 2, data: stru8("Tables/Tile-".concat($e)) }],
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
              [],
              [],
              [],
              [],
              [{ type: 0, data: write_varint49(0) }],
              [],
              [{ type: 0, data: write_varint49(0) }]
            ]) }), ze[1] = [{ type: 0, data: write_varint49(Math.max($e + 1, varint_to_i32(ze[1][0].data))) }], numbers_meta_add_dep(ze, Y, _e, $e), Ke.messages[0].data = write_shallow(ze);
          });
        }
        Ge[2][0].data = write_TSP_Reference($e), He.data = write_shallow(Ge);
      }), Pe[3][0].data = write_shallow(Le);
    }
    Te[4][0].data = write_shallow(Pe), ve.messages[0].data = write_shallow(Te);
  });
}
function write_numbers_ws(le, Y, re, oe, ue, fe) {
  var he = [];
  numbers_iwa_doit(le, Y, fe, function(xe) {
    var Ee = parse_shallow(xe.messages[0].data);
    Ee[1] = [{ type: 2, data: stru8(oe) }], he = mappa(Ee[2], parse_TSP_Reference), xe.messages[0].data = write_shallow(Ee);
  });
  var _e = numbers_iwa_find(le, Y, he[0]), ve = parse_TSP_Reference(parse_shallow(_e.messages[0].data)[2][0].data);
  numbers_iwa_doit(le, Y, ve, function(xe, Ee) {
    return write_numbers_tma(le, Y, re, xe, Ee, ve);
  });
}
function write_numbers_tma(le, Y, re, oe, ue, fe) {
  if (!re["!ref"])
    throw new Error("Cannot export empty sheet to NUMBERS");
  var he = decode_range(re["!ref"]);
  he.s.r = he.s.c = 0;
  var _e = !1;
  he.e.c > 999 && (_e = !0, he.e.c = 999), he.e.r > 999999 && (_e = !0, he.e.r = 999999), _e && console.error("Truncating to ".concat(encode_range(he)));
  var ve = [];
  if (re["!data"])
    ve = re["!data"];
  else {
    for (var xe = [], Ee = 0; Ee <= he.e.c; ++Ee)
      xe[Ee] = encode_col(Ee);
    for (var Se = 0; Se <= he.e.r; ++Se) {
      ve[Se] = [];
      var Te = "" + (Se + 1);
      for (Ee = 0; Ee <= he.e.c; ++Ee) {
        var Ce = re[xe[Ee] + Te];
        Ce && (ve[Se][Ee] = Ce);
      }
    }
  }
  var Ie = {
    cmnt: [{ a: "~54ee77S~", t: "... the people who are crazy enough to think they can change the world, are the ones who do." }],
    rsst: [{ v: "~54ee77S~", l: "https://sheetjs.com/" }],
    sst: ["~Sh33tJ5~"]
  }, Ne = parse_shallow(oe.messages[0].data);
  {
    Ne[6][0].data = write_varint49(he.e.r + 1), Ne[7][0].data = write_varint49(he.e.c + 1), delete Ne[46];
    var Re = parse_shallow(Ne[4][0].data);
    {
      var Ae = parse_TSP_Reference(parse_shallow(Re[1][0].data)[2][0].data);
      numbers_iwa_doit(le, Y, Ae, function(wt, yt) {
        var St, It = parse_shallow(wt.messages[0].data);
        if ((St = It?.[2]) != null && St[0])
          for (var Bt = 0; Bt < ve.length; ++Bt) {
            var Ye = parse_shallow(It[2][0].data);
            Ye[1][0].data = write_varint49(Bt), Ye[4][0].data = write_varint49(ve[Bt].length), It[2][Bt] = { type: It[2][0].type, data: write_shallow(Ye) };
          }
        wt.messages[0].data = write_shallow(It);
      });
      var Pe = parse_TSP_Reference(Re[2][0].data);
      numbers_iwa_doit(le, Y, Pe, function(wt, yt) {
        for (var St = parse_shallow(wt.messages[0].data), It = 0; It <= he.e.c; ++It) {
          var Bt = parse_shallow(St[2][0].data);
          Bt[1][0].data = write_varint49(It), Bt[4][0].data = write_varint49(he.e.r + 1), St[2][It] = { type: St[2][0].type, data: write_shallow(Bt) };
        }
        wt.messages[0].data = write_shallow(St);
      });
      var Fe = parse_shallow(Re[9][0].data);
      Fe[1] = [];
      var Le = parse_shallow(Re[3][0].data);
      {
        var He = 256;
        Le[2] = [{ type: 0, data: write_varint49(He) }];
        var Ge = parse_TSP_Reference(parse_shallow(Le[1][0].data)[2][0].data), Ve = function() {
          var wt = numbers_iwa_find(le, Y, 2), yt = parse_shallow(wt.messages[0].data), St = yt[3].filter(function(It) {
            return varint_to_i32(parse_shallow(It.data)[1][0].data) == Ge;
          });
          return St?.length ? varint_to_i32(parse_shallow(St[0].data)[12][0].data) : 0;
        }();
        CFB.utils.cfb_del(le, Y[Ge].location), numbers_iwa_doit(le, Y, 2, function(wt) {
          var yt = parse_shallow(wt.messages[0].data);
          yt[3] = yt[3].filter(function(St) {
            return varint_to_i32(parse_shallow(St.data)[1][0].data) != Ge;
          }), numbers_meta_del_dep(yt, Y, fe, Ge), wt.messages[0].data = write_shallow(yt);
        }), numbers_del_oref(oe, Ge), Le[1] = [];
        for (var $e = Math.ceil((he.e.r + 1) / He), De = 0; De < $e; ++De) {
          var Ke = get_unique_msgid({
            deps: [],
            location: "",
            type: 6002
          }, Y);
          Y[Ke].location = "Root Entry/Index/Tables/Tile-".concat(Ke, ".iwa");
          for (var ze = [
            [],
            [{ type: 0, data: write_varint49(0) }],
            [{ type: 0, data: write_varint49(Math.min(he.e.r + 1, (De + 1) * He)) }],
            [{ type: 0, data: write_varint49(0) }],
            [{ type: 0, data: write_varint49(Math.min((De + 1) * He, he.e.r + 1) - De * He) }],
            [],
            [{ type: 0, data: write_varint49(5) }],
            [{ type: 0, data: write_varint49(1) }],
            [{ type: 0, data: write_varint49(1) }]
          ], tt = De * He; tt <= Math.min(he.e.r, (De + 1) * He - 1); ++tt) {
            var Xe = write_TST_TileRowInfo(ve[tt], Ie);
            Xe[1][0].data = write_varint49(tt - De * He), ze[5].push({ data: write_shallow(Xe), type: 2 });
          }
          Le[1].push({ type: 2, data: write_shallow([
            [],
            [{ type: 0, data: write_varint49(De) }],
            [{ type: 2, data: write_TSP_Reference(Ke) }]
          ]) });
          var mt = {
            id: Ke,
            messages: [write_iwam(6002, write_shallow(ze))]
          }, at = compress_iwa_file(write_iwa_file([mt]));
          CFB.utils.cfb_add(le, "/Index/Tables/Tile-".concat(Ke, ".iwa"), at), numbers_iwa_doit(le, Y, 2, function(wt) {
            var yt = parse_shallow(wt.messages[0].data);
            yt[3].push({ type: 2, data: write_shallow([
              [],
              [{ type: 0, data: write_varint49(Ke) }],
              [{ type: 2, data: stru8("Tables/Tile") }],
              [{ type: 2, data: stru8("Tables/Tile-".concat(Ke)) }],
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
              [],
              [],
              [],
              [],
              [{ type: 0, data: write_varint49(0) }],
              [],
              [{ type: 0, data: write_varint49(Ve) }]
            ]) }), yt[1] = [{ type: 0, data: write_varint49(Math.max(Ke + 1, varint_to_i32(yt[1][0].data))) }], numbers_meta_add_dep(yt, Y, fe, Ke), wt.messages[0].data = write_shallow(yt);
          }), numbers_add_oref(oe, Ke), Fe[1].push({ type: 2, data: write_shallow([
            [],
            [{ type: 0, data: write_varint49(De * He) }],
            [{ type: 0, data: write_varint49(De) }]
          ]) });
        }
      }
      if (Re[3][0].data = write_shallow(Le), Re[9][0].data = write_shallow(Fe), Re[10] = [{ type: 2, data: new Uint8Array([]) }], re["!merges"]) {
        var qe = get_unique_msgid({
          type: 6144,
          deps: [fe],
          location: Y[fe].location
        }, Y);
        ue.push({
          id: qe,
          messages: [write_iwam(6144, write_shallow([
            [],
            re["!merges"].map(function(wt) {
              return { type: 2, data: write_shallow([
                [],
                [{ type: 2, data: write_shallow([
                  [],
                  [{ type: 5, data: new Uint8Array(new Uint16Array([wt.s.r, wt.s.c]).buffer) }]
                ]) }],
                [{ type: 2, data: write_shallow([
                  [],
                  [{ type: 5, data: new Uint8Array(new Uint16Array([wt.e.r - wt.s.r + 1, wt.e.c - wt.s.c + 1]).buffer) }]
                ]) }]
              ]) };
            })
          ]))]
        }), Re[13] = [{ type: 2, data: write_TSP_Reference(qe) }], numbers_iwa_doit(le, Y, 2, function(wt) {
          var yt = parse_shallow(wt.messages[0].data);
          numbers_meta_add_dep(yt, Y, fe, qe), wt.messages[0].data = write_shallow(yt);
        }), numbers_add_oref(oe, qe);
      } else
        delete Re[13];
      var st = parse_TSP_Reference(Re[4][0].data);
      numbers_iwa_doit(le, Y, st, function(wt) {
        var yt = parse_shallow(wt.messages[0].data);
        yt[3] = [], Ie.sst.forEach(function(St, It) {
          It != 0 && yt[3].push({ type: 2, data: write_shallow([
            [],
            [{ type: 0, data: write_varint49(It) }],
            [{ type: 0, data: write_varint49(1) }],
            [{ type: 2, data: stru8(St) }]
          ]) });
        }), wt.messages[0].data = write_shallow(yt);
      });
      var xt = parse_TSP_Reference(Re[17][0].data);
      if (numbers_iwa_doit(le, Y, xt, function(wt) {
        var yt = parse_shallow(wt.messages[0].data);
        yt[3] = [];
        var St = [
          904980,
          903835,
          903815,
          903845
        ];
        Ie.rsst.forEach(function(It, Bt) {
          if (Bt != 0) {
            var Ye = [
              [],
              [{ type: 0, data: new Uint8Array([5]) }],
              [],
              [{ type: 2, data: stru8(It.v) }]
            ];
            Ye[10] = [{ type: 0, data: new Uint8Array([1]) }], Ye[19] = [{ type: 2, data: new Uint8Array([10, 6, 8, 0, 18, 2, 101, 110]) }], Ye[5] = [{ type: 2, data: new Uint8Array([10, 8, 8, 0, 18, 4, 8, 155, 149, 55]) }], Ye[2] = [{ type: 2, data: new Uint8Array([8, 148, 158, 55]) }], Ye[6] = [{ type: 2, data: new Uint8Array([10, 6, 8, 0, 16, 0, 24, 0]) }], Ye[7] = [{ type: 2, data: new Uint8Array([10, 8, 8, 0, 18, 4, 8, 135, 149, 55]) }], Ye[8] = [{ type: 2, data: new Uint8Array([10, 8, 8, 0, 18, 4, 8, 165, 149, 55]) }], Ye[14] = [{ type: 2, data: new Uint8Array([10, 6, 8, 0, 16, 0, 24, 0]) }], Ye[24] = [{ type: 2, data: new Uint8Array([10, 6, 8, 0, 16, 0, 24, 0]) }];
            var Be = get_unique_msgid({ deps: [], location: "", type: 2001 }, Y), et = [];
            if (It.l) {
              var je = numbers_add_msg(le, 2032, [
                [],
                [],
                [{ type: 2, data: stru8(It.l) }]
              ], "/Index/Tables/DataList", Y);
              Ye[11] = [];
              var it = [[], []];
              it[1] || (it[1] = []), it[1].push({ type: 2, data: write_shallow([
                [],
                [{ type: 0, data: write_varint49(0) }],
                [{ type: 2, data: write_TSP_Reference(je) }]
              ]) }), Ye[11][0] = { type: 2, data: write_shallow(it) }, et.push(je);
            }
            numbers_add_msg(le, 2001, Ye, "/Index/Tables/DataList", Y, Be), numbers_iwa_doit(le, Y, Be, function(rt) {
              St.forEach(function(Ct) {
                return numbers_add_oref(rt, Ct);
              }), et.forEach(function(Ct) {
                return numbers_add_oref(rt, Ct);
              });
            });
            var bt = numbers_add_msg(le, 6218, [
              [],
              [{ type: 2, data: write_TSP_Reference(Be) }],
              [],
              [{ type: 2, data: new Uint8Array([13, 255, 255, 255, 0, 18, 10, 16, 255, 255, 1, 24, 255, 255, 255, 255, 7]) }]
            ], "/Index/Tables/DataList", Y);
            numbers_iwa_doit(le, Y, bt, function(rt) {
              return numbers_add_oref(rt, Be);
            }), yt[3].push({ type: 2, data: write_shallow([
              [],
              [{ type: 0, data: write_varint49(Bt) }],
              [{ type: 0, data: write_varint49(1) }],
              [],
              [],
              [],
              [],
              [],
              [],
              [{ type: 2, data: write_TSP_Reference(bt) }]
            ]) }), numbers_add_oref(wt, bt), numbers_iwa_doit(le, Y, 2, function(rt) {
              var Ct = parse_shallow(rt.messages[0].data);
              numbers_meta_add_dep(Ct, Y, xt, bt), numbers_meta_add_dep(Ct, Y, bt, Be), numbers_meta_add_dep(Ct, Y, Be, et), numbers_meta_add_dep(Ct, Y, Be, St), rt.messages[0].data = write_shallow(Ct);
            });
          }
        }), wt.messages[0].data = write_shallow(yt);
      }), Ie.cmnt.length > 1) {
        var gt = parse_TSP_Reference(Re[19][0].data), Ze = {}, _t = 0;
        numbers_iwa_doit(le, Y, gt, function(wt) {
          var yt = parse_shallow(wt.messages[0].data);
          yt[3] = [], Ie.cmnt.forEach(function(St, It) {
            if (It != 0) {
              var Bt = [];
              St.replies && St.replies.forEach(function(et) {
                Ze[et.a || ""] || (Ze[et.a || ""] = numbers_add_msg(le, 212, [
                  [],
                  [{ type: 2, data: stru8(et.a || "") }],
                  [{ type: 2, data: get_author_color(++_t) }],
                  [],
                  [{ type: 0, data: write_varint49(0) }]
                ], "/Index/Tables/DataList", Y));
                var je = Ze[et.a || ""], it = numbers_add_msg(le, 3056, [
                  [],
                  [{ type: 2, data: stru8(et.t || "") }],
                  [{ type: 2, data: write_shallow([
                    [],
                    [{ type: 1, data: new Uint8Array([0, 0, 0, 128, 116, 109, 182, 65]) }]
                  ]) }],
                  [{ type: 2, data: write_TSP_Reference(je) }]
                ], "/Index/Tables/DataList", Y);
                numbers_iwa_doit(le, Y, it, function(bt) {
                  return numbers_add_oref(bt, je);
                }), Bt.push(it), numbers_iwa_doit(le, Y, 2, function(bt) {
                  var rt = parse_shallow(bt.messages[0].data);
                  numbers_meta_add_dep(rt, Y, it, je), bt.messages[0].data = write_shallow(rt);
                });
              }), Ze[St.a || ""] || (Ze[St.a || ""] = numbers_add_msg(le, 212, [
                [],
                [{ type: 2, data: stru8(St.a || "") }],
                [{ type: 2, data: get_author_color(++_t) }],
                [],
                [{ type: 0, data: write_varint49(0) }]
              ], "/Index/Tables/DataList", Y));
              var Ye = Ze[St.a || ""], Be = numbers_add_msg(le, 3056, [
                [],
                [{ type: 2, data: stru8(St.t || "") }],
                [{ type: 2, data: write_shallow([
                  [],
                  [{ type: 1, data: new Uint8Array([0, 0, 0, 128, 116, 109, 182, 65]) }]
                ]) }],
                [{ type: 2, data: write_TSP_Reference(Ye) }],
                Bt.map(function(et) {
                  return { type: 2, data: write_TSP_Reference(et) };
                }),
                [{ type: 2, data: write_shallow([
                  [],
                  [{ type: 0, data: write_varint49(It) }],
                  [{ type: 0, data: write_varint49(0) }]
                ]) }]
              ], "/Index/Tables/DataList", Y);
              numbers_iwa_doit(le, Y, Be, function(et) {
                numbers_add_oref(et, Ye), Bt.forEach(function(je) {
                  return numbers_add_oref(et, je);
                });
              }), yt[3].push({ type: 2, data: write_shallow([
                [],
                [{ type: 0, data: write_varint49(It) }],
                [{ type: 0, data: write_varint49(1) }],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [{ type: 2, data: write_TSP_Reference(Be) }]
              ]) }), numbers_add_oref(wt, Be), numbers_iwa_doit(le, Y, 2, function(et) {
                var je = parse_shallow(et.messages[0].data);
                numbers_meta_add_dep(je, Y, gt, Be), numbers_meta_add_dep(je, Y, Be, Ye), Bt.length && numbers_meta_add_dep(je, Y, Be, Bt), et.messages[0].data = write_shallow(je);
              });
            }
          }), yt[2][0].data = write_varint49(Ie.cmnt.length + 1), wt.messages[0].data = write_shallow(yt);
        });
      }
    }
    Ne[4][0].data = write_shallow(Re);
  }
  oe.messages[0].data = write_shallow(Ne);
}
function fix_opts_func(le) {
  return function(re) {
    for (var oe = 0; oe != le.length; ++oe) {
      var ue = le[oe];
      re[ue[0]] === void 0 && (re[ue[0]] = ue[1]), ue[2] === "n" && (re[ue[0]] = Number(re[ue[0]]));
    }
  };
}
function fix_read_opts(le) {
  fix_opts_func([
    ["cellNF", !1],
    /* emit cell number format string as .z */
    ["cellHTML", !0],
    /* emit html string as .h */
    ["cellFormula", !0],
    /* emit formulae as .f */
    ["cellStyles", !1],
    /* emits style/theme as .s */
    ["cellText", !0],
    /* emit formatted text as .w */
    ["cellDates", !1],
    /* emit date cells with type `d` */
    ["sheetStubs", !1],
    /* emit empty cells */
    ["sheetRows", 0, "n"],
    /* read n rows (0 = read all rows) */
    ["bookDeps", !1],
    /* parse calculation chains */
    ["bookSheets", !1],
    /* only try to get sheet names (no Sheets) */
    ["bookProps", !1],
    /* only try to get properties (no Sheets) */
    ["bookFiles", !1],
    /* include raw file structure (keys, files, cfb) */
    ["bookVBA", !1],
    /* include vba raw data (vbaraw) */
    ["password", ""],
    /* password */
    ["WTF", !1]
    /* WTF mode (throws errors) */
  ])(le);
}
function fix_write_opts(le) {
  fix_opts_func([
    ["cellDates", !1],
    /* write date cells with type `d` */
    ["bookSST", !1],
    /* Generate Shared String Table */
    ["bookType", "xlsx"],
    /* Type of workbook (xlsx/m/b) */
    ["compression", !1],
    /* Use file compression */
    ["WTF", !1]
    /* WTF mode (throws errors) */
  ])(le);
}
function get_sheet_type(le) {
  return RELS.WS.indexOf(le) > -1 ? "sheet" : le == RELS.CS ? "chart" : le == RELS.DS ? "dialog" : le == RELS.MS ? "macro" : le && le.length ? le : "sheet";
}
function safe_parse_wbrels(le, Y) {
  if (!le) return 0;
  try {
    le = Y.map(function(oe) {
      return oe.id || (oe.id = oe.strRelID), [oe.name, le["!id"][oe.id].Target, get_sheet_type(le["!id"][oe.id].Type)];
    });
  } catch {
    return null;
  }
  return !le || le.length === 0 ? null : le;
}
function parse_sheet_legacy_drawing(le, Y, re, oe, ue, fe, he, _e) {
  if (!(!le || !le["!legdrawel"])) {
    var ve = resolve_path(le["!legdrawel"].Target, oe), xe = getzipstr(re, ve, !0);
    xe && parse_vml(utf8read(xe), le, _e || []);
  }
}
function safe_parse_sheet(le, Y, re, oe, ue, fe, he, _e, ve, xe, Ee, Se) {
  try {
    fe[oe] = parse_rels(getzipstr(le, re, !0), Y);
    var Te = getzipdata(le, Y), Ce;
    switch (_e) {
      case "sheet":
        Ce = parse_ws(Te, Y, ue, ve, fe[oe], xe, Ee, Se);
        break;
      case "chart":
        if (Ce = parse_cs(Te, Y, ue, ve, fe[oe], xe, Ee, Se), !Ce || !Ce["!drawel"]) break;
        var Ie = resolve_path(Ce["!drawel"].Target, Y), Ne = get_rels_path(Ie), Re = parse_drawing(getzipstr(le, Ie, !0), parse_rels(getzipstr(le, Ne, !0), Ie)), Ae = resolve_path(Re, Ie), Pe = get_rels_path(Ae);
        Ce = parse_chart(getzipstr(le, Ae, !0), Ae, ve, parse_rels(getzipstr(le, Pe, !0), Ae), xe, Ce);
        break;
      case "macro":
        Ce = parse_ms(Te, Y, ue, ve, fe[oe], xe, Ee, Se);
        break;
      case "dialog":
        Ce = parse_ds(Te, Y, ue, ve, fe[oe], xe, Ee, Se);
        break;
      default:
        throw new Error("Unrecognized sheet type " + _e);
    }
    he[oe] = Ce;
    var Fe = [], Le = [];
    fe && fe[oe] && keys(fe[oe]).forEach(function(He) {
      var Ge = "";
      if (fe[oe][He].Type == RELS.CMNT) {
        if (Ge = resolve_path(fe[oe][He].Target, Y), Fe = parse_cmnt(getzipdata(le, Ge, !0), Ge, ve), !Fe || !Fe.length) return;
        sheet_insert_comments(Ce, Fe, !1);
      }
      fe[oe][He].Type == RELS.TCMNT && (Ge = resolve_path(fe[oe][He].Target, Y), Le = Le.concat(parse_tcmnt_xml(getzipdata(le, Ge, !0), ve)));
    }), Le && Le.length && sheet_insert_comments(Ce, Le, !0, ve.people || []), parse_sheet_legacy_drawing(Ce, _e, le, Y, ue, ve, xe, Fe);
  } catch (He) {
    if (ve.WTF) throw He;
  }
}
function strip_front_slash(le) {
  return le.charAt(0) == "/" ? le.slice(1) : le;
}
function parse_zip(le, Y) {
  if (make_ssf(), Y = Y || {}, fix_read_opts(Y), safegetzipfile(le, "META-INF/manifest.xml") || safegetzipfile(le, "objectdata.xml")) return parse_ods(le, Y);
  if (safegetzipfile(le, "Index/Document.iwa")) {
    if (typeof Uint8Array > "u") throw new Error("NUMBERS file parsing requires Uint8Array support");
    if (typeof parse_numbers_iwa < "u") {
      if (le.FileIndex) return parse_numbers_iwa(le, Y);
      var re = CFB.utils.cfb_new();
      return zipentries(le).forEach(function(at) {
        zip_add_file(re, at, getzipbin(le, at));
      }), parse_numbers_iwa(re, Y);
    }
    throw new Error("Unsupported NUMBERS file");
  }
  if (!safegetzipfile(le, "[Content_Types].xml")) {
    if (safegetzipfile(le, "index.xml.gz")) throw new Error("Unsupported NUMBERS 08 file");
    if (safegetzipfile(le, "index.xml")) throw new Error("Unsupported NUMBERS 09 file");
    var oe = CFB.find(le, "Index.zip");
    if (oe)
      return Y = dup(Y), delete Y.type, typeof oe.content == "string" && (Y.type = "binary"), typeof Bun < "u" && Buffer.isBuffer(oe.content) ? readSync(new Uint8Array(oe.content), Y) : readSync(oe.content, Y);
    throw new Error("Unsupported ZIP file");
  }
  var ue = zipentries(le), fe = parse_ct(getzipstr(le, "[Content_Types].xml")), he = !1, _e, ve;
  if (fe.workbooks.length === 0 && (ve = "xl/workbook.xml", getzipdata(le, ve, !0) && fe.workbooks.push(ve)), fe.workbooks.length === 0) {
    if (ve = "xl/workbook.bin", !getzipdata(le, ve, !0)) throw new Error("Could not find workbook");
    fe.workbooks.push(ve), he = !0;
  }
  fe.workbooks[0].slice(-3) == "bin" && (he = !0);
  var xe = {}, Ee = {};
  if (!Y.bookSheets && !Y.bookProps) {
    if (strs = [], fe.sst) try {
      strs = parse_sst(getzipdata(le, strip_front_slash(fe.sst)), fe.sst, Y);
    } catch (at) {
      if (Y.WTF) throw at;
    }
    Y.cellStyles && fe.themes.length && (xe = parse_theme_xml(getzipstr(le, fe.themes[0].replace(/^\//, ""), !0) || "", Y)), fe.style && (Ee = parse_sty(getzipdata(le, strip_front_slash(fe.style)), fe.style, xe, Y));
  }
  fe.links.map(function(at) {
    try {
      var qe = parse_rels(getzipstr(le, get_rels_path(strip_front_slash(at))), at);
      return parse_xlink(getzipdata(le, strip_front_slash(at)), qe, at, Y);
    } catch {
    }
  });
  var Se = parse_wb(getzipdata(le, strip_front_slash(fe.workbooks[0])), fe.workbooks[0], Y), Te = {}, Ce = "";
  fe.coreprops.length && (Ce = getzipdata(le, strip_front_slash(fe.coreprops[0]), !0), Ce && (Te = parse_core_props(Ce)), fe.extprops.length !== 0 && (Ce = getzipdata(le, strip_front_slash(fe.extprops[0]), !0), Ce && parse_ext_props(Ce, Te, Y)));
  var Ie = {};
  (!Y.bookSheets || Y.bookProps) && fe.custprops.length !== 0 && (Ce = getzipstr(le, strip_front_slash(fe.custprops[0]), !0), Ce && (Ie = parse_cust_props(Ce, Y)));
  var Ne = {};
  if ((Y.bookSheets || Y.bookProps) && (Se.Sheets ? _e = Se.Sheets.map(function(qe) {
    return qe.name;
  }) : Te.Worksheets && Te.SheetNames.length > 0 && (_e = Te.SheetNames), Y.bookProps && (Ne.Props = Te, Ne.Custprops = Ie), Y.bookSheets && typeof _e < "u" && (Ne.SheetNames = _e), Y.bookSheets ? Ne.SheetNames : Y.bookProps))
    return Ne;
  _e = {};
  var Re = {};
  Y.bookDeps && fe.calcchain && (Re = parse_cc(getzipdata(le, strip_front_slash(fe.calcchain)), fe.calcchain));
  var Ae = 0, Pe = {}, Fe, Le;
  {
    var He = Se.Sheets;
    Te.Worksheets = He.length, Te.SheetNames = [];
    for (var Ge = 0; Ge != He.length; ++Ge)
      Te.SheetNames[Ge] = He[Ge].name;
  }
  var Ve = he ? "bin" : "xml", $e = fe.workbooks[0].lastIndexOf("/"), De = (fe.workbooks[0].slice(0, $e + 1) + "_rels/" + fe.workbooks[0].slice($e + 1) + ".rels").replace(/^\//, "");
  safegetzipfile(le, De) || (De = "xl/_rels/workbook." + Ve + ".rels");
  var Ke = parse_rels(getzipstr(le, De, !0), De.replace(/_rels.*/, "s5s"));
  (fe.metadata || []).length >= 1 && (Y.xlmeta = parse_xlmeta(getzipdata(le, strip_front_slash(fe.metadata[0])), fe.metadata[0], Y)), (fe.people || []).length >= 1 && (Y.people = parse_people_xml(getzipdata(le, strip_front_slash(fe.people[0])), Y)), Ke && (Ke = safe_parse_wbrels(Ke, Se.Sheets));
  var ze = getzipdata(le, "xl/worksheets/sheet.xml", !0) ? 1 : 0;
  e: for (Ae = 0; Ae != Te.Worksheets; ++Ae) {
    var tt = "sheet";
    if (Ke && Ke[Ae] ? (Fe = "xl/" + Ke[Ae][1].replace(/[\/]?xl\//, ""), safegetzipfile(le, Fe) || (Fe = Ke[Ae][1]), safegetzipfile(le, Fe) || (Fe = De.replace(/_rels\/[\S\s]*$/, "") + Ke[Ae][1]), tt = Ke[Ae][2]) : (Fe = "xl/worksheets/sheet" + (Ae + 1 - ze) + "." + Ve, Fe = Fe.replace(/sheet0\./, "sheet.")), Le = Fe.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels"), Y && Y.sheets != null) switch (typeof Y.sheets) {
      case "number":
        if (Ae != Y.sheets) continue e;
        break;
      case "string":
        if (Te.SheetNames[Ae].toLowerCase() != Y.sheets.toLowerCase()) continue e;
        break;
      default:
        if (Array.isArray && Array.isArray(Y.sheets)) {
          for (var Xe = !1, mt = 0; mt != Y.sheets.length; ++mt)
            typeof Y.sheets[mt] == "number" && Y.sheets[mt] == Ae && (Xe = 1), typeof Y.sheets[mt] == "string" && Y.sheets[mt].toLowerCase() == Te.SheetNames[Ae].toLowerCase() && (Xe = 1);
          if (!Xe) continue e;
        }
    }
    safe_parse_sheet(le, Fe, Le, Te.SheetNames[Ae], Ae, Pe, _e, tt, Y, Se, xe, Ee);
  }
  return Ne = {
    Directory: fe,
    Workbook: Se,
    Props: Te,
    Custprops: Ie,
    Deps: Re,
    Sheets: _e,
    SheetNames: Te.SheetNames,
    Strings: strs,
    Styles: Ee,
    Themes: xe,
    SSF: dup(table_fmt)
  }, Y && Y.bookFiles && (le.files ? (Ne.keys = ue, Ne.files = le.files) : (Ne.keys = [], Ne.files = {}, le.FullPaths.forEach(function(at, qe) {
    at = at.replace(/^Root Entry[\/]/, ""), Ne.keys.push(at), Ne.files[at] = le.FileIndex[qe];
  }))), Y && Y.bookVBA && (fe.vba.length > 0 ? Ne.vbaraw = getzipdata(le, strip_front_slash(fe.vba[0]), !0) : fe.defaults && fe.defaults.bin === CT_VBA && (Ne.vbaraw = getzipdata(le, "xl/vbaProject.bin", !0))), Ne.bookType = he ? "xlsb" : "xlsx", Ne;
}
function parse_xlsxcfb(le, Y) {
  var re = Y || {}, oe = "Workbook", ue = CFB.find(le, oe);
  try {
    if (oe = "/!DataSpaces/Version", ue = CFB.find(le, oe), !ue || !ue.content) throw new Error("ECMA-376 Encrypted file missing " + oe);
    if (parse_DataSpaceVersionInfo(ue.content), oe = "/!DataSpaces/DataSpaceMap", ue = CFB.find(le, oe), !ue || !ue.content) throw new Error("ECMA-376 Encrypted file missing " + oe);
    var fe = parse_DataSpaceMap(ue.content);
    if (fe.length !== 1 || fe[0].comps.length !== 1 || fe[0].comps[0].t !== 0 || fe[0].name !== "StrongEncryptionDataSpace" || fe[0].comps[0].v !== "EncryptedPackage")
      throw new Error("ECMA-376 Encrypted file bad " + oe);
    if (oe = "/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace", ue = CFB.find(le, oe), !ue || !ue.content) throw new Error("ECMA-376 Encrypted file missing " + oe);
    var he = parse_DataSpaceDefinition(ue.content);
    if (he.length != 1 || he[0] != "StrongEncryptionTransform")
      throw new Error("ECMA-376 Encrypted file bad " + oe);
    if (oe = "/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary", ue = CFB.find(le, oe), !ue || !ue.content) throw new Error("ECMA-376 Encrypted file missing " + oe);
    parse_Primary(ue.content);
  } catch {
  }
  if (oe = "/EncryptionInfo", ue = CFB.find(le, oe), !ue || !ue.content) throw new Error("ECMA-376 Encrypted file missing " + oe);
  var _e = parse_EncryptionInfo(ue.content);
  if (oe = "/EncryptedPackage", ue = CFB.find(le, oe), !ue || !ue.content) throw new Error("ECMA-376 Encrypted file missing " + oe);
  if (_e[0] == 4 && typeof decrypt_agile < "u") return decrypt_agile(_e[1], ue.content, re.password || "", re);
  if (_e[0] == 2 && typeof decrypt_std76 < "u") return decrypt_std76(_e[1], ue.content, re.password || "", re);
  throw new Error("File is password-protected");
}
function write_zip_xlsb(le, Y) {
  le && !le.SSF && (le.SSF = dup(table_fmt)), le && le.SSF && (make_ssf(), SSF_load_table(le.SSF), Y.revssf = evert_num(le.SSF), Y.revssf[le.SSF[65535]] = 0, Y.ssf = le.SSF), Y.rels = {}, Y.wbrels = {}, Y.Strings = /*::((*/
  [], Y.Strings.Count = 0, Y.Strings.Unique = 0, browser_has_Map ? Y.revStrings = /* @__PURE__ */ new Map() : (Y.revStrings = {}, Y.revStrings.foo = [], delete Y.revStrings.foo);
  var re = "bin", oe = !0, ue = new_ct();
  fix_write_opts(Y = Y || {});
  var fe = zip_new(), he = "", _e = 0;
  if (Y.cellXfs = [], get_cell_style(Y.cellXfs, {}, { revssf: { General: 0 } }), le.Props || (le.Props = {}), he = "docProps/core.xml", zip_add_file(fe, he, write_core_props(le.Props, Y)), ue.coreprops.push(he), add_rels(Y.rels, 2, he, RELS.CORE_PROPS), he = "docProps/app.xml", !(le.Props && le.Props.SheetNames)) if (!le.Workbook || !le.Workbook.Sheets) le.Props.SheetNames = le.SheetNames;
  else {
    for (var ve = [], xe = 0; xe < le.SheetNames.length; ++xe)
      (le.Workbook.Sheets[xe] || {}).Hidden != 2 && ve.push(le.SheetNames[xe]);
    le.Props.SheetNames = ve;
  }
  le.Props.Worksheets = le.Props.SheetNames.length, zip_add_file(fe, he, write_ext_props(le.Props)), ue.extprops.push(he), add_rels(Y.rels, 3, he, RELS.EXT_PROPS), le.Custprops !== le.Props && keys(le.Custprops || {}).length > 0 && (he = "docProps/custom.xml", zip_add_file(fe, he, write_cust_props(le.Custprops)), ue.custprops.push(he), add_rels(Y.rels, 4, he, RELS.CUST_PROPS));
  var Ee = ["SheetJ5"];
  for (Y.tcid = 0, _e = 1; _e <= le.SheetNames.length; ++_e) {
    var Se = { "!id": {} }, Te = le.Sheets[le.SheetNames[_e - 1]], Ce = (Te || {})["!type"] || "sheet";
    switch (Ce) {
      case "chart":
      /* falls through */
      default:
        he = "xl/worksheets/sheet" + _e + "." + re, zip_add_file(fe, he, write_ws_bin(_e - 1, Y, le, Se)), ue.sheets.push(he), add_rels(Y.wbrels, -1, "worksheets/sheet" + _e + "." + re, RELS.WS[0]);
    }
    if (Te) {
      var Ie = Te["!comments"], Ne = !1, Re = "";
      if (Ie && Ie.length > 0) {
        var Ae = !1;
        Ie.forEach(function(Fe) {
          Fe[1].forEach(function(Le) {
            Le.T == !0 && (Ae = !0);
          });
        }), Ae && (Re = "xl/threadedComments/threadedComment" + _e + ".xml", zip_add_file(fe, Re, write_tcmnt_xml(Ie, Ee, Y)), ue.threadedcomments.push(Re), add_rels(Se, -1, "../threadedComments/threadedComment" + _e + ".xml", RELS.TCMNT)), Re = "xl/comments" + _e + "." + re, zip_add_file(fe, Re, write_comments_bin(Ie)), ue.comments.push(Re), add_rels(Se, -1, "../comments" + _e + "." + re, RELS.CMNT), Ne = !0;
      }
      Te["!legacy"] && Ne && zip_add_file(fe, "xl/drawings/vmlDrawing" + _e + ".vml", write_vml(_e, Te["!comments"])), delete Te["!comments"], delete Te["!legacy"];
    }
    Se["!id"].rId1 && zip_add_file(fe, get_rels_path(he), write_rels(Se));
  }
  Y.Strings != null && Y.Strings.length > 0 && (he = "xl/sharedStrings." + re, zip_add_file(fe, he, write_sst_bin(Y.Strings)), ue.strs.push(he), add_rels(Y.wbrels, -1, "sharedStrings." + re, RELS.SST)), he = "xl/workbook." + re, zip_add_file(fe, he, write_wb_bin(le)), ue.workbooks.push(he), add_rels(Y.rels, 1, he, RELS.WB), he = "xl/theme/theme1.xml";
  var Pe = write_theme(le.Themes, Y);
  return zip_add_file(fe, he, Pe), ue.themes.push(he), add_rels(Y.wbrels, -1, "theme/theme1.xml", RELS.THEME), he = "xl/styles." + re, zip_add_file(fe, he, write_sty_bin(le, Y)), ue.styles.push(he), add_rels(Y.wbrels, -1, "styles." + re, RELS.STY), le.vbaraw && oe && (he = "xl/vbaProject.bin", zip_add_file(fe, he, le.vbaraw), ue.vba.push(he), add_rels(Y.wbrels, -1, "vbaProject.bin", RELS.VBA)), he = "xl/metadata." + re, zip_add_file(fe, he, write_xlmeta_bin()), ue.metadata.push(he), add_rels(Y.wbrels, -1, "metadata." + re, RELS.XLMETA), Ee.length > 1 && (he = "xl/persons/person.xml", zip_add_file(fe, he, write_people_xml(Ee)), ue.people.push(he), add_rels(Y.wbrels, -1, "persons/person.xml", RELS.PEOPLE)), zip_add_file(fe, "[Content_Types].xml", write_ct(ue, Y)), zip_add_file(fe, "_rels/.rels", write_rels(Y.rels)), zip_add_file(fe, "xl/_rels/workbook." + re + ".rels", write_rels(Y.wbrels)), delete Y.revssf, delete Y.ssf, fe;
}
function write_zip_xlsx(le, Y) {
  le && !le.SSF && (le.SSF = dup(table_fmt)), le && le.SSF && (make_ssf(), SSF_load_table(le.SSF), Y.revssf = evert_num(le.SSF), Y.revssf[le.SSF[65535]] = 0, Y.ssf = le.SSF), Y.rels = {}, Y.wbrels = {}, Y.Strings = /*::((*/
  [], Y.Strings.Count = 0, Y.Strings.Unique = 0, browser_has_Map ? Y.revStrings = /* @__PURE__ */ new Map() : (Y.revStrings = {}, Y.revStrings.foo = [], delete Y.revStrings.foo);
  var re = "xml", oe = VBAFMTS.indexOf(Y.bookType) > -1, ue = new_ct();
  fix_write_opts(Y = Y || {});
  var fe = zip_new(), he = "", _e = 0;
  if (Y.cellXfs = [], get_cell_style(Y.cellXfs, {}, { revssf: { General: 0 } }), le.Props || (le.Props = {}), he = "docProps/core.xml", zip_add_file(fe, he, write_core_props(le.Props, Y)), ue.coreprops.push(he), add_rels(Y.rels, 2, he, RELS.CORE_PROPS), he = "docProps/app.xml", !(le.Props && le.Props.SheetNames)) if (!le.Workbook || !le.Workbook.Sheets) le.Props.SheetNames = le.SheetNames;
  else {
    for (var ve = [], xe = 0; xe < le.SheetNames.length; ++xe)
      (le.Workbook.Sheets[xe] || {}).Hidden != 2 && ve.push(le.SheetNames[xe]);
    le.Props.SheetNames = ve;
  }
  le.Props.Worksheets = le.Props.SheetNames.length, zip_add_file(fe, he, write_ext_props(le.Props)), ue.extprops.push(he), add_rels(Y.rels, 3, he, RELS.EXT_PROPS), le.Custprops !== le.Props && keys(le.Custprops || {}).length > 0 && (he = "docProps/custom.xml", zip_add_file(fe, he, write_cust_props(le.Custprops)), ue.custprops.push(he), add_rels(Y.rels, 4, he, RELS.CUST_PROPS));
  var Ee = ["SheetJ5"];
  for (Y.tcid = 0, _e = 1; _e <= le.SheetNames.length; ++_e) {
    var Se = { "!id": {} }, Te = le.Sheets[le.SheetNames[_e - 1]], Ce = (Te || {})["!type"] || "sheet";
    switch (Ce) {
      case "chart":
      /* falls through */
      default:
        he = "xl/worksheets/sheet" + _e + "." + re, zip_add_file(fe, he, write_ws_xml(_e - 1, Y, le, Se)), ue.sheets.push(he), add_rels(Y.wbrels, -1, "worksheets/sheet" + _e + "." + re, RELS.WS[0]);
    }
    if (Te) {
      var Ie = Te["!comments"], Ne = !1, Re = "";
      if (Ie && Ie.length > 0) {
        var Ae = !1;
        Ie.forEach(function(Pe) {
          Pe[1].forEach(function(Fe) {
            Fe.T == !0 && (Ae = !0);
          });
        }), Ae && (Re = "xl/threadedComments/threadedComment" + _e + ".xml", zip_add_file(fe, Re, write_tcmnt_xml(Ie, Ee, Y)), ue.threadedcomments.push(Re), add_rels(Se, -1, "../threadedComments/threadedComment" + _e + ".xml", RELS.TCMNT)), Re = "xl/comments" + _e + "." + re, zip_add_file(fe, Re, write_comments_xml(Ie)), ue.comments.push(Re), add_rels(Se, -1, "../comments" + _e + "." + re, RELS.CMNT), Ne = !0;
      }
      Te["!legacy"] && Ne && zip_add_file(fe, "xl/drawings/vmlDrawing" + _e + ".vml", write_vml(_e, Te["!comments"])), delete Te["!comments"], delete Te["!legacy"];
    }
    Se["!id"].rId1 && zip_add_file(fe, get_rels_path(he), write_rels(Se));
  }
  return Y.Strings != null && Y.Strings.length > 0 && (he = "xl/sharedStrings." + re, zip_add_file(fe, he, write_sst_xml(Y.Strings, Y)), ue.strs.push(he), add_rels(Y.wbrels, -1, "sharedStrings." + re, RELS.SST)), he = "xl/workbook." + re, zip_add_file(fe, he, write_wb_xml(le)), ue.workbooks.push(he), add_rels(Y.rels, 1, he, RELS.WB), he = "xl/theme/theme1.xml", zip_add_file(fe, he, write_theme(le.Themes, Y)), ue.themes.push(he), add_rels(Y.wbrels, -1, "theme/theme1.xml", RELS.THEME), he = "xl/styles." + re, zip_add_file(fe, he, write_sty_xml(le, Y)), ue.styles.push(he), add_rels(Y.wbrels, -1, "styles." + re, RELS.STY), le.vbaraw && oe && (he = "xl/vbaProject.bin", zip_add_file(fe, he, le.vbaraw), ue.vba.push(he), add_rels(Y.wbrels, -1, "vbaProject.bin", RELS.VBA)), he = "xl/metadata." + re, zip_add_file(fe, he, write_xlmeta_xml()), ue.metadata.push(he), add_rels(Y.wbrels, -1, "metadata." + re, RELS.XLMETA), Ee.length > 1 && (he = "xl/persons/person.xml", zip_add_file(fe, he, write_people_xml(Ee)), ue.people.push(he), add_rels(Y.wbrels, -1, "persons/person.xml", RELS.PEOPLE)), zip_add_file(fe, "[Content_Types].xml", write_ct(ue, Y)), zip_add_file(fe, "_rels/.rels", write_rels(Y.rels)), zip_add_file(fe, "xl/_rels/workbook." + re + ".rels", write_rels(Y.wbrels)), delete Y.revssf, delete Y.ssf, fe;
}
function firstbyte(le, Y) {
  var re = "";
  switch ((Y || {}).type || "base64") {
    case "buffer":
      return [le[0], le[1], le[2], le[3], le[4], le[5], le[6], le[7]];
    case "base64":
      re = Base64_decode(le.slice(0, 12));
      break;
    case "binary":
      re = le;
      break;
    case "array":
      return [le[0], le[1], le[2], le[3], le[4], le[5], le[6], le[7]];
    default:
      throw new Error("Unrecognized type " + (Y && Y.type || "undefined"));
  }
  return [re.charCodeAt(0), re.charCodeAt(1), re.charCodeAt(2), re.charCodeAt(3), re.charCodeAt(4), re.charCodeAt(5), re.charCodeAt(6), re.charCodeAt(7)];
}
function read_cfb(le, Y) {
  return CFB.find(le, "EncryptedPackage") ? parse_xlsxcfb(le, Y) : parse_xlscfb(le, Y);
}
function read_zip(le, Y) {
  var re, oe = le, ue = Y || {};
  return ue.type || (ue.type = has_buf && Buffer.isBuffer(le) ? "buffer" : "base64"), re = zip_read(oe, ue), parse_zip(re, ue);
}
function read_plaintext(le, Y) {
  var re = 0;
  e: for (; re < le.length; ) switch (le.charCodeAt(re)) {
    case 10:
    case 13:
    case 32:
      ++re;
      break;
    case 60:
      return parse_xlml(le.slice(re), Y);
    default:
      break e;
  }
  return PRN.to_workbook(le, Y);
}
function read_plaintext_raw(le, Y) {
  var re = "", oe = firstbyte(le, Y);
  switch (Y.type) {
    case "base64":
      re = Base64_decode(le);
      break;
    case "binary":
      re = le;
      break;
    case "buffer":
      re = le.toString("binary");
      break;
    case "array":
      re = cc2str(le);
      break;
    default:
      throw new Error("Unrecognized type " + Y.type);
  }
  return oe[0] == 239 && oe[1] == 187 && oe[2] == 191 && (re = utf8read(re)), Y.type = "binary", read_plaintext(re, Y);
}
function read_utf16(le, Y) {
  var re = le;
  return Y.type == "base64" && (re = Base64_decode(re)), typeof ArrayBuffer < "u" && le instanceof ArrayBuffer && (re = new Uint8Array(le)), re = typeof $cptable < "u" ? $cptable.utils.decode(1200, re.slice(2), "str") : has_buf && Buffer.isBuffer(le) ? le.slice(2).toString("utf16le") : typeof Uint8Array < "u" && re instanceof Uint8Array ? typeof TextDecoder < "u" ? new TextDecoder("utf-16le").decode(re.slice(2)) : utf16lereadu(re.slice(2)) : utf16leread(re.slice(2)), Y.type = "binary", read_plaintext(re, Y);
}
function bstrify(le) {
  return le.match(/[^\x00-\x7F]/) ? utf8write(le) : le;
}
function read_prn(le, Y, re, oe) {
  return oe ? (re.type = "string", PRN.to_workbook(le, re)) : PRN.to_workbook(Y, re);
}
function readSync(le, Y) {
  reset_cp();
  var re = Y || {};
  if (re.codepage && typeof $cptable > "u" && console.error("Codepage tables are not loaded.  Non-ASCII characters may not give expected results"), typeof ArrayBuffer < "u" && le instanceof ArrayBuffer) return readSync(new Uint8Array(le), (re = dup(re), re.type = "array", re));
  if (typeof Int8Array < "u" && le instanceof Int8Array) return readSync(new Uint8Array(le.buffer, le.byteOffset, le.length), re);
  typeof Uint8Array < "u" && le instanceof Uint8Array && !re.type && (re.type = typeof Deno < "u" ? "buffer" : "array");
  var oe = le, ue = [0, 0, 0, 0], fe = !1;
  if (re.cellStyles && (re.cellNF = !0, re.sheetStubs = !0), _ssfopts = {}, re.dateNF && (_ssfopts.dateNF = re.dateNF), re.type || (re.type = has_buf && Buffer.isBuffer(le) ? "buffer" : "base64"), re.type == "file" && (re.type = has_buf ? "buffer" : "binary", oe = read_binary(le), typeof Uint8Array < "u" && !has_buf && (re.type = "array")), re.type == "string" && (fe = !0, re.type = "binary", re.codepage = 65001, oe = bstrify(le)), re.type == "array" && typeof Uint8Array < "u" && le instanceof Uint8Array && typeof ArrayBuffer < "u") {
    var he = new ArrayBuffer(3), _e = new Uint8Array(he);
    if (_e.foo = "bar", !_e.foo)
      return re = dup(re), re.type = "array", readSync(ab2a(oe), re);
  }
  switch ((ue = firstbyte(oe, re))[0]) {
    case 208:
      if (ue[1] === 207 && ue[2] === 17 && ue[3] === 224 && ue[4] === 161 && ue[5] === 177 && ue[6] === 26 && ue[7] === 225) return read_cfb(CFB.read(oe, re), re);
      break;
    case 9:
      if (ue[1] <= 8) return parse_xlscfb(oe, re);
      break;
    case 60:
      return parse_xlml(oe, re);
    case 73:
      if (ue[1] === 73 && ue[2] === 42 && ue[3] === 0) throw new Error("TIFF Image File is not a spreadsheet");
      if (ue[1] === 68) return read_wb_ID(oe, re);
      break;
    case 84:
      if (ue[1] === 65 && ue[2] === 66 && ue[3] === 76) return DIF.to_workbook(oe, re);
      break;
    case 80:
      return ue[1] === 75 && ue[2] < 9 && ue[3] < 9 ? read_zip(oe, re) : read_prn(le, oe, re, fe);
    case 239:
      return ue[3] === 60 ? parse_xlml(oe, re) : read_prn(le, oe, re, fe);
    case 255:
      if (ue[1] === 254)
        return read_utf16(oe, re);
      if (ue[1] === 0 && ue[2] === 2 && ue[3] === 0) return WK_.to_workbook(oe, re);
      break;
    case 0:
      if (ue[1] === 0 && (ue[2] >= 2 && ue[3] === 0 || ue[2] === 0 && (ue[3] === 8 || ue[3] === 9)))
        return WK_.to_workbook(oe, re);
      break;
    case 3:
    case 131:
    case 139:
    case 140:
      return DBF.to_workbook(oe, re);
    case 123:
      if (ue[1] === 92 && ue[2] === 114 && ue[3] === 116) return rtf_to_workbook(oe, re);
      break;
    case 10:
    case 13:
    case 32:
      return read_plaintext_raw(oe, re);
    case 137:
      if (ue[1] === 80 && ue[2] === 78 && ue[3] === 71) throw new Error("PNG Image File is not a spreadsheet");
      break;
    case 8:
      if (ue[1] === 231) throw new Error("Unsupported Multiplan 1.x file!");
      break;
    case 12:
      if (ue[1] === 236) throw new Error("Unsupported Multiplan 2.x file!");
      if (ue[1] === 237) throw new Error("Unsupported Multiplan 3.x file!");
      break;
  }
  return DBF_SUPPORTED_VERSIONS.indexOf(ue[0]) > -1 && ue[2] <= 12 && ue[3] <= 31 ? DBF.to_workbook(oe, re) : read_prn(le, oe, re, fe);
}
function readFileSync(le, Y) {
  var re = Y || {};
  return re.type = "file", readSync(le, re);
}
function write_cfb_ctr(le, Y) {
  switch (Y.type) {
    case "base64":
    case "binary":
      break;
    case "buffer":
    case "array":
      Y.type = "";
      break;
    case "file":
      return write_dl(Y.file, CFB.write(le, { type: has_buf ? "buffer" : "" }));
    case "string":
      throw new Error("'string' output type invalid for '" + Y.bookType + "' files");
    default:
      throw new Error("Unrecognized type " + Y.type);
  }
  return CFB.write(le, Y);
}
function write_zip(le, Y) {
  switch (Y.bookType) {
    case "ods":
      return write_ods(le, Y);
    case "numbers":
      return write_numbers_iwa(le, Y);
    case "xlsb":
      return write_zip_xlsb(le, Y);
    default:
      return write_zip_xlsx(le, Y);
  }
}
function write_zip_type(le, Y) {
  var re = dup(Y || {}), oe = write_zip(le, re);
  return write_zip_denouement(oe, re);
}
function write_zip_typeXLSX(le, Y) {
  var re = dup(Y || {}), oe = write_zip_xlsx(le, re);
  return write_zip_denouement(oe, re);
}
function write_zip_denouement(le, Y) {
  var re = {}, oe = has_buf ? "nodebuffer" : typeof Uint8Array < "u" ? "array" : "string";
  if (Y.compression && (re.compression = "DEFLATE"), Y.password) re.type = oe;
  else switch (Y.type) {
    case "base64":
      re.type = "base64";
      break;
    case "binary":
      re.type = "string";
      break;
    case "string":
      throw new Error("'string' output type invalid for '" + Y.bookType + "' files");
    case "buffer":
    case "file":
      re.type = oe;
      break;
    default:
      throw new Error("Unrecognized type " + Y.type);
  }
  var ue = le.FullPaths ? CFB.write(le, { fileType: "zip", type: (
    /*::(*/
    { nodebuffer: "buffer", string: "binary" }[re.type] || re.type
  ), compression: !!Y.compression }) : le.generate(re);
  if (typeof Deno < "u" && typeof ue == "string") {
    if (Y.type == "binary" || Y.type == "base64") return ue;
    ue = new Uint8Array(s2ab(ue));
  }
  return Y.password && typeof encrypt_agile < "u" ? write_cfb_ctr(encrypt_agile(ue, Y.password), Y) : Y.type === "file" ? write_dl(Y.file, ue) : Y.type == "string" ? utf8read(
    /*::(*/
    ue
    /*:: :any)*/
  ) : ue;
}
function write_cfb_type(le, Y) {
  var re = Y || {}, oe = write_xlscfb(le, re);
  return write_cfb_ctr(oe, re);
}
function write_string_type(le, Y, re) {
  re || (re = "");
  var oe = re + le;
  switch (Y.type) {
    case "base64":
      return Base64_encode(utf8write(oe));
    case "binary":
      return utf8write(oe);
    case "string":
      return le;
    case "file":
      return write_dl(Y.file, oe, "utf8");
    case "buffer":
      return has_buf ? Buffer_from(oe, "utf8") : typeof TextEncoder < "u" ? new TextEncoder().encode(oe) : write_string_type(oe, { type: "binary" }).split("").map(function(ue) {
        return ue.charCodeAt(0);
      });
  }
  throw new Error("Unrecognized type " + Y.type);
}
function write_stxt_type(le, Y) {
  switch (Y.type) {
    case "base64":
      return Base64_encode_pass(le);
    case "binary":
      return le;
    case "string":
      return le;
    /* override in sheet_to_txt */
    case "file":
      return write_dl(Y.file, le, "binary");
    case "buffer":
      return has_buf ? Buffer_from(le, "binary") : le.split("").map(function(re) {
        return re.charCodeAt(0);
      });
  }
  throw new Error("Unrecognized type " + Y.type);
}
function write_binary_type(le, Y) {
  switch (Y.type) {
    case "string":
    case "base64":
    case "binary":
      for (var re = "", oe = 0; oe < le.length; ++oe) re += String.fromCharCode(le[oe]);
      return Y.type == "base64" ? Base64_encode(re) : Y.type == "string" ? utf8read(re) : re;
    case "file":
      return write_dl(Y.file, le);
    case "buffer":
      return le;
    default:
      throw new Error("Unrecognized type " + Y.type);
  }
}
function writeSyncXLSX(le, Y) {
  reset_cp(), check_wb(le);
  var re = dup(Y || {});
  if (re.cellStyles && (re.cellNF = !0, re.sheetStubs = !0), re.type == "array") {
    re.type = "binary";
    var oe = writeSyncXLSX(le, re);
    return re.type = "array", s2ab(oe);
  }
  return write_zip_typeXLSX(le, re);
}
function writeSync(le, Y) {
  reset_cp(), check_wb(le);
  var re = dup(Y || {});
  if (re.cellStyles && (re.cellNF = !0, re.sheetStubs = !0), re.type == "array") {
    re.type = "binary";
    var oe = writeSync(le, re);
    return re.type = "array", s2ab(oe);
  }
  var ue = 0;
  if (re.sheet && (typeof re.sheet == "number" ? ue = re.sheet : ue = le.SheetNames.indexOf(re.sheet), !le.SheetNames[ue]))
    throw new Error("Sheet not found: " + re.sheet + " : " + typeof re.sheet);
  switch (re.bookType || "xlsb") {
    case "xml":
    case "xlml":
      return write_string_type(write_xlml(le, re), re);
    case "slk":
    case "sylk":
      return write_string_type(SYLK.from_sheet(le.Sheets[le.SheetNames[ue]], re, le), re);
    case "htm":
    case "html":
      return write_string_type(sheet_to_html(le.Sheets[le.SheetNames[ue]], re), re);
    case "txt":
      return write_stxt_type(sheet_to_txt(le.Sheets[le.SheetNames[ue]], re), re);
    case "csv":
      return write_string_type(sheet_to_csv(le.Sheets[le.SheetNames[ue]], re), re, "\uFEFF");
    case "dif":
      return write_string_type(DIF.from_sheet(le.Sheets[le.SheetNames[ue]], re), re);
    case "dbf":
      return write_binary_type(DBF.from_sheet(le.Sheets[le.SheetNames[ue]], re), re);
    case "prn":
      return write_string_type(PRN.from_sheet(le.Sheets[le.SheetNames[ue]], re), re);
    case "rtf":
      return write_string_type(sheet_to_rtf(le.Sheets[le.SheetNames[ue]]), re);
    case "eth":
      return write_string_type(ETH.from_sheet(le.Sheets[le.SheetNames[ue]], re), re);
    case "fods":
      return write_string_type(write_ods(le, re), re);
    case "wk1":
      return write_binary_type(WK_.sheet_to_wk1(le.Sheets[le.SheetNames[ue]], re), re);
    case "wk3":
      return write_binary_type(WK_.book_to_wk3(le, re), re);
    case "biff2":
      re.biff || (re.biff = 2);
    /* falls through */
    case "biff3":
      re.biff || (re.biff = 3);
    /* falls through */
    case "biff4":
      return re.biff || (re.biff = 4), write_binary_type(write_biff_buf(le, re), re);
    case "biff5":
      re.biff || (re.biff = 5);
    /* falls through */
    case "biff8":
    case "xla":
    case "xls":
      return re.biff || (re.biff = 8), write_cfb_type(le, re);
    case "xlsx":
    case "xlsm":
    case "xlam":
    case "xlsb":
    case "numbers":
    case "ods":
      return write_zip_type(le, re);
    default:
      throw new Error("Unrecognized bookType |" + re.bookType + "|");
  }
}
function resolve_book_type(le) {
  if (!le.bookType) {
    var Y = {
      xls: "biff8",
      htm: "html",
      slk: "sylk",
      socialcalc: "eth",
      Sh33tJS: "WTF"
    }, re = le.file.slice(le.file.lastIndexOf(".")).toLowerCase();
    re.match(/^\.[a-z]+$/) && (le.bookType = re.slice(1)), le.bookType = Y[le.bookType] || le.bookType;
  }
}
function writeFileSync(le, Y, re) {
  var oe = re || {};
  return oe.type = "file", oe.file = Y, resolve_book_type(oe), writeSync(le, oe);
}
function writeFileSyncXLSX(le, Y, re) {
  var oe = re || {};
  return oe.type = "file", oe.file = Y, resolve_book_type(oe), writeSyncXLSX(le, oe);
}
function writeFileAsync(le, Y, re, oe) {
  var ue = re || {};
  ue.type = "file", ue.file = le, resolve_book_type(ue), ue.type = "buffer";
  var fe = oe;
  return fe instanceof Function || (fe = re), _fs.writeFile(le, writeSync(Y, ue), fe);
}
function make_json_row(le, Y, re, oe, ue, fe, he) {
  var _e = encode_row(re), ve = he.defval, xe = he.raw || !Object.prototype.hasOwnProperty.call(he, "raw"), Ee = !0, Se = le["!data"] != null, Te = ue === 1 ? [] : {};
  if (ue !== 1)
    if (Object.defineProperty) try {
      Object.defineProperty(Te, "__rowNum__", { value: re, enumerable: !1 });
    } catch {
      Te.__rowNum__ = re;
    }
    else Te.__rowNum__ = re;
  if (!Se || le["!data"][re]) for (var Ce = Y.s.c; Ce <= Y.e.c; ++Ce) {
    var Ie = Se ? (le["!data"][re] || [])[Ce] : le[oe[Ce] + _e];
    if (Ie == null || Ie.t === void 0) {
      if (ve === void 0) continue;
      fe[Ce] != null && (Te[fe[Ce]] = ve);
      continue;
    }
    var Ne = Ie.v;
    switch (Ie.t) {
      case "z":
        if (Ne == null) break;
        continue;
      case "e":
        Ne = Ne == 0 ? null : void 0;
        break;
      case "s":
      case "b":
      case "n":
        if (!Ie.z || !fmt_is_date(Ie.z) || (Ne = numdate(Ne), typeof Ne == "number")) break;
      /* falls through */
      case "d":
        he && (he.UTC || he.raw === !1) || (Ne = utc_to_local(new Date(Ne)));
        break;
      default:
        throw new Error("unrecognized type " + Ie.t);
    }
    if (fe[Ce] != null) {
      if (Ne == null)
        if (Ie.t == "e" && Ne === null) Te[fe[Ce]] = null;
        else if (ve !== void 0) Te[fe[Ce]] = ve;
        else if (xe && Ne === null) Te[fe[Ce]] = null;
        else continue;
      else
        Te[fe[Ce]] = (Ie.t === "n" && typeof he.rawNumbers == "boolean" ? he.rawNumbers : xe) ? Ne : format_cell(Ie, Ne, he);
      Ne != null && (Ee = !1);
    }
  }
  return { row: Te, isempty: Ee };
}
function sheet_to_json(le, Y) {
  if (le == null || le["!ref"] == null) return [];
  var re = { t: "n", v: 0 }, oe = 0, ue = 1, fe = [], he = 0, _e = "", ve = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, xe = Y || {}, Ee = xe.range != null ? xe.range : le["!ref"];
  switch (xe.header === 1 ? oe = 1 : xe.header === "A" ? oe = 2 : Array.isArray(xe.header) ? oe = 3 : xe.header == null && (oe = 0), typeof Ee) {
    case "string":
      ve = safe_decode_range(Ee);
      break;
    case "number":
      ve = safe_decode_range(le["!ref"]), ve.s.r = Ee;
      break;
    default:
      ve = Ee;
  }
  oe > 0 && (ue = 0);
  var Se = encode_row(ve.s.r), Te = [], Ce = [], Ie = 0, Ne = 0, Re = le["!data"] != null, Ae = ve.s.r, Pe = 0, Fe = {};
  Re && !le["!data"][Ae] && (le["!data"][Ae] = []);
  var Le = xe.skipHidden && le["!cols"] || [], He = xe.skipHidden && le["!rows"] || [];
  for (Pe = ve.s.c; Pe <= ve.e.c; ++Pe)
    if (!(Le[Pe] || {}).hidden)
      switch (Te[Pe] = encode_col(Pe), re = Re ? le["!data"][Ae][Pe] : le[Te[Pe] + Se], oe) {
        case 1:
          fe[Pe] = Pe - ve.s.c;
          break;
        case 2:
          fe[Pe] = Te[Pe];
          break;
        case 3:
          fe[Pe] = xe.header[Pe - ve.s.c];
          break;
        default:
          if (re == null && (re = { w: "__EMPTY", t: "s" }), _e = he = format_cell(re, null, xe), Ne = Fe[he] || 0, !Ne) Fe[he] = 1;
          else {
            do
              _e = he + "_" + Ne++;
            while (Fe[_e]);
            Fe[he] = Ne, Fe[_e] = 1;
          }
          fe[Pe] = _e;
      }
  for (Ae = ve.s.r + ue; Ae <= ve.e.r; ++Ae)
    if (!(He[Ae] || {}).hidden) {
      var Ge = make_json_row(le, ve, Ae, Te, oe, fe, xe);
      (Ge.isempty === !1 || (oe === 1 ? xe.blankrows !== !1 : xe.blankrows)) && (Ce[Ie++] = Ge.row);
    }
  return Ce.length = Ie, Ce;
}
var qreg = /"/g;
function make_csv_row(le, Y, re, oe, ue, fe, he, _e, ve) {
  for (var xe = !0, Ee = [], Se = "", Te = encode_row(re), Ce = le["!data"] != null, Ie = Ce && le["!data"][re] || [], Ne = Y.s.c; Ne <= Y.e.c; ++Ne)
    if (oe[Ne]) {
      var Re = Ce ? Ie[Ne] : le[oe[Ne] + Te];
      if (Re == null) Se = "";
      else if (Re.v != null) {
        xe = !1, Se = "" + (ve.rawNumbers && Re.t == "n" ? Re.v : format_cell(Re, null, ve));
        for (var Ae = 0, Pe = 0; Ae !== Se.length; ++Ae) if ((Pe = Se.charCodeAt(Ae)) === ue || Pe === fe || Pe === 34 || ve.forceQuotes) {
          Se = '"' + Se.replace(qreg, '""') + '"';
          break;
        }
        Se == "ID" && _e == 0 && Ee.length == 0 && (Se = '"ID"');
      } else Re.f != null && !Re.F ? (xe = !1, Se = "=" + Re.f, Se.indexOf(",") >= 0 && (Se = '"' + Se.replace(qreg, '""') + '"')) : Se = "";
      Ee.push(Se);
    }
  if (ve.strip) for (; Ee[Ee.length - 1] === ""; ) --Ee.length;
  return ve.blankrows === !1 && xe ? null : Ee.join(he);
}
function sheet_to_csv(le, Y) {
  var re = [], oe = Y ?? {};
  if (le == null || le["!ref"] == null) return "";
  for (var ue = safe_decode_range(le["!ref"]), fe = oe.FS !== void 0 ? oe.FS : ",", he = fe.charCodeAt(0), _e = oe.RS !== void 0 ? oe.RS : `
`, ve = _e.charCodeAt(0), xe = "", Ee = [], Se = oe.skipHidden && le["!cols"] || [], Te = oe.skipHidden && le["!rows"] || [], Ce = ue.s.c; Ce <= ue.e.c; ++Ce) (Se[Ce] || {}).hidden || (Ee[Ce] = encode_col(Ce));
  for (var Ie = 0, Ne = ue.s.r; Ne <= ue.e.r; ++Ne)
    (Te[Ne] || {}).hidden || (xe = make_csv_row(le, ue, Ne, Ee, he, ve, fe, Ie, oe), xe != null && (xe || oe.blankrows !== !1) && re.push((Ie++ ? _e : "") + xe));
  return re.join("");
}
function sheet_to_txt(le, Y) {
  Y || (Y = {}), Y.FS = "	", Y.RS = `
`;
  var re = sheet_to_csv(le, Y);
  if (typeof $cptable > "u" || Y.type == "string") return re;
  var oe = $cptable.utils.encode(1200, re, "str");
  return "ÿþ" + oe;
}
function sheet_to_formulae(le, Y) {
  var re = "", oe, ue = "";
  if (le == null || le["!ref"] == null) return [];
  var fe = safe_decode_range(le["!ref"]), he = "", _e = [], ve, xe = [], Ee = le["!data"] != null;
  for (ve = fe.s.c; ve <= fe.e.c; ++ve) _e[ve] = encode_col(ve);
  for (var Se = fe.s.r; Se <= fe.e.r; ++Se)
    for (he = encode_row(Se), ve = fe.s.c; ve <= fe.e.c; ++ve)
      if (re = _e[ve] + he, oe = Ee ? (le["!data"][Se] || [])[ve] : le[re], ue = "", oe !== void 0) {
        if (oe.F != null) {
          if (re = oe.F, !oe.f) continue;
          ue = oe.f, re.indexOf(":") == -1 && (re = re + ":" + re);
        }
        if (oe.f != null) ue = oe.f;
        else {
          if (Y && Y.values === !1) continue;
          if (oe.t == "z") continue;
          if (oe.t == "n" && oe.v != null) ue = "" + oe.v;
          else if (oe.t == "b") ue = oe.v ? "TRUE" : "FALSE";
          else if (oe.w !== void 0) ue = "'" + oe.w;
          else {
            if (oe.v === void 0) continue;
            oe.t == "s" ? ue = "'" + oe.v : ue = "" + oe.v;
          }
        }
        xe[xe.length] = re + "=" + ue;
      }
  return xe;
}
function sheet_add_json(le, Y, re) {
  var oe = re || {}, ue = le ? le["!data"] != null : oe.dense, fe = +!oe.skipHeader, he = le || {};
  !le && ue && (he["!data"] = []);
  var _e = 0, ve = 0;
  if (he && oe.origin != null)
    if (typeof oe.origin == "number") _e = oe.origin;
    else {
      var xe = typeof oe.origin == "string" ? decode_cell(oe.origin) : oe.origin;
      _e = xe.r, ve = xe.c;
    }
  var Ee = { s: { c: 0, r: 0 }, e: { c: ve, r: _e + Y.length - 1 + fe } };
  if (he["!ref"]) {
    var Se = safe_decode_range(he["!ref"]);
    Ee.e.c = Math.max(Ee.e.c, Se.e.c), Ee.e.r = Math.max(Ee.e.r, Se.e.r), _e == -1 && (_e = Se.e.r + 1, Ee.e.r = _e + Y.length - 1 + fe);
  } else
    _e == -1 && (_e = 0, Ee.e.r = Y.length - 1 + fe);
  var Te = oe.header || [], Ce = 0, Ie = [];
  Y.forEach(function(Re, Ae) {
    ue && !he["!data"][_e + Ae + fe] && (he["!data"][_e + Ae + fe] = []), ue && (Ie = he["!data"][_e + Ae + fe]), keys(Re).forEach(function(Pe) {
      (Ce = Te.indexOf(Pe)) == -1 && (Te[Ce = Te.length] = Pe);
      var Fe = Re[Pe], Le = "z", He = "", Ge = ue ? "" : encode_col(ve + Ce) + encode_row(_e + Ae + fe), Ve = ue ? Ie[ve + Ce] : he[Ge];
      Fe && typeof Fe == "object" && !(Fe instanceof Date) ? ue ? Ie[ve + Ce] = Fe : he[Ge] = Fe : (typeof Fe == "number" ? Le = "n" : typeof Fe == "boolean" ? Le = "b" : typeof Fe == "string" ? Le = "s" : Fe instanceof Date ? (Le = "d", oe.UTC || (Fe = local_to_utc(Fe)), oe.cellDates || (Le = "n", Fe = datenum(Fe)), He = Ve != null && Ve.z && fmt_is_date(Ve.z) ? Ve.z : oe.dateNF || table_fmt[14]) : Fe === null && oe.nullError && (Le = "e", Fe = 0), Ve ? (Ve.t = Le, Ve.v = Fe, delete Ve.w, delete Ve.R, He && (Ve.z = He)) : ue ? Ie[ve + Ce] = Ve = { t: Le, v: Fe } : he[Ge] = Ve = { t: Le, v: Fe }, He && (Ve.z = He));
    });
  }), Ee.e.c = Math.max(Ee.e.c, ve + Te.length - 1);
  var Ne = encode_row(_e);
  if (ue && !he["!data"][_e] && (he["!data"][_e] = []), fe) for (Ce = 0; Ce < Te.length; ++Ce)
    ue ? he["!data"][_e][Ce + ve] = { t: "s", v: Te[Ce] } : he[encode_col(Ce + ve) + Ne] = { t: "s", v: Te[Ce] };
  return he["!ref"] = encode_range(Ee), he;
}
function json_to_sheet(le, Y) {
  return sheet_add_json(null, le, Y);
}
function ws_get_cell_stub(le, Y, re) {
  if (typeof Y == "string") {
    if (le["!data"] != null) {
      var oe = decode_cell(Y);
      return le["!data"][oe.r] || (le["!data"][oe.r] = []), le["!data"][oe.r][oe.c] || (le["!data"][oe.r][oe.c] = { t: "z" });
    }
    return le[Y] || (le[Y] = { t: "z" });
  }
  return typeof Y != "number" ? ws_get_cell_stub(le, encode_cell(Y)) : ws_get_cell_stub(le, encode_col(re || 0) + encode_row(Y));
}
function wb_sheet_idx(le, Y) {
  if (typeof Y == "number") {
    if (Y >= 0 && le.SheetNames.length > Y) return Y;
    throw new Error("Cannot find sheet # " + Y);
  } else if (typeof Y == "string") {
    var re = le.SheetNames.indexOf(Y);
    if (re > -1) return re;
    throw new Error("Cannot find sheet name |" + Y + "|");
  } else throw new Error("Cannot find sheet |" + Y + "|");
}
function book_new(le, Y) {
  var re = { SheetNames: [], Sheets: {} };
  return le && book_append_sheet(re, le, Y || "Sheet1"), re;
}
function book_append_sheet(le, Y, re, oe) {
  var ue = 1;
  if (!re) for (; ue <= 65535 && le.SheetNames.indexOf(re = "Sheet" + ue) != -1; ++ue, re = void 0) ;
  if (!re || le.SheetNames.length >= 65535) throw new Error("Too many worksheets");
  if (oe && le.SheetNames.indexOf(re) >= 0 && re.length < 32) {
    var fe = re.match(/\d+$/);
    ue = fe && +fe[0] || 0;
    var he = fe && re.slice(0, fe.index) || re;
    for (++ue; ue <= 65535 && le.SheetNames.indexOf(re = he + ue) != -1; ++ue) ;
  }
  if (check_ws_name(re), le.SheetNames.indexOf(re) >= 0) throw new Error("Worksheet with name |" + re + "| already exists!");
  return le.SheetNames.push(re), le.Sheets[re] = Y, re;
}
function book_set_sheet_visibility(le, Y, re) {
  le.Workbook || (le.Workbook = {}), le.Workbook.Sheets || (le.Workbook.Sheets = []);
  var oe = wb_sheet_idx(le, Y);
  switch (le.Workbook.Sheets[oe] || (le.Workbook.Sheets[oe] = {}), re) {
    case 0:
    case 1:
    case 2:
      break;
    default:
      throw new Error("Bad sheet visibility setting " + re);
  }
  le.Workbook.Sheets[oe].Hidden = re;
}
function cell_set_number_format(le, Y) {
  return le.z = Y, le;
}
function cell_set_hyperlink(le, Y, re) {
  return Y ? (le.l = { Target: Y }, re && (le.l.Tooltip = re)) : delete le.l, le;
}
function cell_set_internal_link(le, Y, re) {
  return cell_set_hyperlink(le, "#" + Y, re);
}
function cell_add_comment(le, Y, re) {
  le.c || (le.c = []), le.c.push({ t: Y, a: re || "SheetJS" });
}
function sheet_set_array_formula(le, Y, re, oe) {
  for (var ue = typeof Y != "string" ? Y : safe_decode_range(Y), fe = typeof Y == "string" ? Y : encode_range(Y), he = ue.s.r; he <= ue.e.r; ++he) for (var _e = ue.s.c; _e <= ue.e.c; ++_e) {
    var ve = ws_get_cell_stub(le, he, _e);
    ve.t = "n", ve.F = fe, delete ve.v, he == ue.s.r && _e == ue.s.c && (ve.f = re, oe && (ve.D = !0));
  }
  var xe = decode_range(le["!ref"]);
  return xe.s.r > ue.s.r && (xe.s.r = ue.s.r), xe.s.c > ue.s.c && (xe.s.c = ue.s.c), xe.e.r < ue.e.r && (xe.e.r = ue.e.r), xe.e.c < ue.e.c && (xe.e.c = ue.e.c), le["!ref"] = encode_range(xe), le;
}
var utils = {
  encode_col,
  encode_row,
  encode_cell,
  encode_range,
  decode_col,
  decode_row,
  split_cell,
  decode_cell,
  decode_range,
  format_cell,
  sheet_new,
  sheet_add_aoa,
  sheet_add_json,
  sheet_add_dom,
  aoa_to_sheet,
  json_to_sheet,
  table_to_sheet: parse_dom_table,
  table_to_book,
  sheet_to_csv,
  sheet_to_txt,
  sheet_to_json,
  sheet_to_html,
  sheet_to_formulae,
  sheet_to_row_object_array: sheet_to_json,
  sheet_get_cell: ws_get_cell_stub,
  book_new,
  book_append_sheet,
  book_set_sheet_visibility,
  cell_set_number_format,
  cell_set_hyperlink,
  cell_set_internal_link,
  cell_add_comment,
  sheet_set_array_formula,
  consts: {
    SHEET_VISIBLE: 0,
    SHEET_HIDDEN: 1,
    SHEET_VERY_HIDDEN: 2
  }
}, _Readable;
function set_readable(le) {
  _Readable = le;
}
function write_csv_stream(le, Y) {
  var re = _Readable(), oe = Y ?? {};
  if (le == null || le["!ref"] == null)
    return re.push(null), re;
  for (var ue = safe_decode_range(le["!ref"]), fe = oe.FS !== void 0 ? oe.FS : ",", he = fe.charCodeAt(0), _e = oe.RS !== void 0 ? oe.RS : `
`, ve = _e.charCodeAt(0), xe = "", Ee = [], Se = oe.skipHidden && le["!cols"] || [], Te = oe.skipHidden && le["!rows"] || [], Ce = ue.s.c; Ce <= ue.e.c; ++Ce) (Se[Ce] || {}).hidden || (Ee[Ce] = encode_col(Ce));
  var Ie = ue.s.r, Ne = !1, Re = 0;
  return re._read = function() {
    if (!Ne)
      return Ne = !0, re.push("\uFEFF");
    for (; Ie <= ue.e.r; )
      if (++Ie, !(Te[Ie - 1] || {}).hidden && (xe = make_csv_row(le, ue, Ie - 1, Ee, he, ve, fe, Re, oe), xe != null && (xe || oe.blankrows !== !1)))
        return re.push((Re++ ? _e : "") + xe);
    return re.push(null);
  }, re;
}
function write_html_stream(le, Y) {
  var re = _Readable(), oe = Y || {}, ue = oe.header != null ? oe.header : HTML_BEGIN, fe = oe.footer != null ? oe.footer : HTML_END;
  re.push(ue);
  var he = decode_range(le["!ref"]);
  re.push(make_html_preamble(le, he, oe));
  var _e = he.s.r, ve = !1;
  return re._read = function() {
    if (_e > he.e.r)
      return ve || (ve = !0, re.push("</table>" + fe)), re.push(null);
    for (; _e <= he.e.r; ) {
      re.push(make_html_row(le, he, _e, oe)), ++_e;
      break;
    }
  }, re;
}
function write_json_stream(le, Y) {
  var re = _Readable({ objectMode: !0 });
  if (le == null || le["!ref"] == null)
    return re.push(null), re;
  var oe = { t: "n", v: 0 }, ue = 0, fe = 1, he = [], _e = 0, ve = "", xe = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, Ee = Y || {}, Se = Ee.range != null ? Ee.range : le["!ref"];
  switch (Ee.header === 1 ? ue = 1 : Ee.header === "A" ? ue = 2 : Array.isArray(Ee.header) && (ue = 3), typeof Se) {
    case "string":
      xe = safe_decode_range(Se);
      break;
    case "number":
      xe = safe_decode_range(le["!ref"]), xe.s.r = Se;
      break;
    default:
      xe = Se;
  }
  ue > 0 && (fe = 0);
  var Te = encode_row(xe.s.r), Ce = [], Ie = 0, Ne = le["!data"] != null, Re = xe.s.r, Ae = 0, Pe = {};
  Ne && !le["!data"][Re] && (le["!data"][Re] = []);
  var Fe = Ee.skipHidden && le["!cols"] || [], Le = Ee.skipHidden && le["!rows"] || [];
  for (Ae = xe.s.c; Ae <= xe.e.c; ++Ae)
    if (!(Fe[Ae] || {}).hidden)
      switch (Ce[Ae] = encode_col(Ae), oe = Ne ? le["!data"][Re][Ae] : le[Ce[Ae] + Te], ue) {
        case 1:
          he[Ae] = Ae - xe.s.c;
          break;
        case 2:
          he[Ae] = Ce[Ae];
          break;
        case 3:
          he[Ae] = Ee.header[Ae - xe.s.c];
          break;
        default:
          if (oe == null && (oe = { w: "__EMPTY", t: "s" }), ve = _e = format_cell(oe, null, Ee), Ie = Pe[_e] || 0, !Ie) Pe[_e] = 1;
          else {
            do
              ve = _e + "_" + Ie++;
            while (Pe[ve]);
            Pe[_e] = Ie, Pe[ve] = 1;
          }
          he[Ae] = ve;
      }
  return Re = xe.s.r + fe, re._read = function() {
    for (; Re <= xe.e.r; )
      if (!(Le[Re - 1] || {}).hidden) {
        var He = make_json_row(le, xe, Re, Ce, ue, he, Ee);
        if (++Re, He.isempty === !1 || (ue === 1 ? Ee.blankrows !== !1 : Ee.blankrows)) {
          re.push(He.row);
          return;
        }
      }
    return re.push(null);
  }, re;
}
function write_xlml_stream(le, Y) {
  var re = _Readable(), oe = Y ?? {}, ue = +oe.stride || 10;
  le.SSF || (le.SSF = dup(table_fmt)), le.SSF && (make_ssf(), SSF_load_table(le.SSF), oe.revssf = evert_num(le.SSF), oe.revssf[le.SSF[65535]] = 0, oe.ssf = le.SSF, oe.cellXfs = [], get_cell_style(oe.cellXfs, {}, { revssf: { General: 0 } })), le.SheetNames.forEach(function(Ae) {
    var Pe = le.Sheets[Ae];
    if (!(!Pe || !Pe["!ref"])) {
      for (var Fe = decode_range(Pe["!ref"]), Le = Pe["!data"] != null, He = Le ? Pe["!data"] : [], Ge = Fe.s.r; Ge <= Fe.e.r; ++Ge)
        if (!(Le && !He[Ge]))
          for (var Ve = Fe.s.c; Ve <= Fe.e.c; ++Ve) {
            var $e = Le ? He[Ge][Ve] : Pe[encode_col(Ve) + encode_row(Ge)];
            $e && ($e.t == "d" && $e.z == null && ($e = dup($e), $e.z = table_fmt[14]), get_cell_style(oe.cellXfs, $e, oe));
          }
    }
  });
  var fe = write_sty_xlml(le, oe), he = 0, _e = 0, ve = le.Sheets[le.SheetNames[_e]], xe = safe_decode_range(ve), Ee = -1, Se = !1, Te = [], Ce = 0, Ie = !1, Ne = [], Re = { r: 0, c: 0 };
  return re._read = function() {
    switch (he) {
      /* header */
      case 0:
        he = 1, re.push(XML_HEADER), re.push("<Workbook" + wxt_helper({
          xmlns: XLMLNS.ss,
          "xmlns:o": XLMLNS.o,
          "xmlns:x": XLMLNS.x,
          "xmlns:ss": XLMLNS.ss,
          "xmlns:dt": XLMLNS.dt,
          "xmlns:html": XLMLNS.html
        }) + ">");
        break;
      /* preamble */
      case 1:
        he = 2, re.push(write_props_xlml(le, oe)), re.push(write_wb_xlml(le));
        break;
      /* style and name tables */
      case 2:
        he = 3, re.push(fe), re.push(write_names_xlml(le));
        break;
      /* worksheet preamble */
      case 3:
        {
          if (Se = !1, _e >= le.SheetNames.length) {
            he = -1, re.push("");
            break;
          }
          if (re.push("<Worksheet" + wxt_helper({ "ss:Name": escapexml(le.SheetNames[_e]) }) + ">"), ve = le.Sheets[le.SheetNames[_e]], !ve)
            return re.push("</Worksheet>"), void ++_e;
          var Ae = write_ws_xlml_names(ve, oe, _e, le);
          if (Ae.length && re.push("<Names>" + Ae + "</Names>"), !ve["!ref"]) return he = 5;
          xe = safe_decode_range(ve["!ref"]), Ee = xe.s.r, he = 4;
        }
        break;
      /* worksheet intramble */
      case 4:
        {
          if (Ee < 0 || Ee > xe.e.r)
            return Se && re.push("</Table>"), void (he = 5);
          Ee <= xe.s.r && (ve["!cols"] && ve["!cols"].forEach(function($e, De) {
            process_col($e);
            var Ke = !!$e.width, ze = col_obj_w(De, $e), tt = { "ss:Index": De + 1 };
            Ke && (tt["ss:Width"] = width2px(ze.width)), $e.hidden && (tt["ss:Hidden"] = "1"), Se || (Se = !0, re.push("<Table>")), re.push(writextag("Column", null, tt));
          }), Ie = ve["!data"] != null, Ie && (Ne = ve["!data"]), Re.r = Re.c = 0);
          for (var Pe = 0; Ee <= xe.e.r && Pe < ue; ++Ee, ++Pe) {
            var Fe = [write_ws_xlml_row(Ee, (ve["!rows"] || [])[Ee])];
            if (Re.r = Ee, !(Ie && !Ne[Ee])) for (var Le = xe.s.c; Le <= xe.e.c; ++Le) {
              Re.c = Le;
              var He = !1;
              for (Ce = 0; Ce != Te.length; ++Ce)
                if (!(Te[Ce].s.c > Le) && !(Te[Ce].s.r > Ee) && !(Te[Ce].e.c < Le) && !(Te[Ce].e.r < Ee)) {
                  (Te[Ce].s.c != Le || Te[Ce].s.r != Ee) && (He = !0);
                  break;
                }
              if (!He) {
                var Ge = encode_col(Le) + encode_row(Ee), Ve = Ie ? Ne[Ee][Le] : ve[Ge];
                Fe.push(write_ws_xlml_cell(Ve, Ge, ve, oe, _e, le, Re));
              }
            }
            Fe.push("</Row>"), Se || (Se = !0, re.push("<Table>")), re.push(Fe.join(""));
          }
        }
        break;
      /* worksheet postamble */
      case 5:
        return re.push(write_ws_xlml_wsopts(ve, oe, _e, le)), ve && ve["!autofilter"] && re.push('<AutoFilter x:Range="' + a1_to_rc(fix_range(ve["!autofilter"].ref), { r: 0, c: 0 }) + '" xmlns="urn:schemas-microsoft-com:office:excel"></AutoFilter>'), re.push("</Worksheet>"), _e++, Ee = -1, void (he = 3);
      /* footer */
      case -1:
        he = -2, re.push("</Workbook>");
        break;
      /* exeunt */
      case -2:
        re.push(null);
        break;
    }
  }, re;
}
var __stream = {
  to_json: write_json_stream,
  to_html: write_html_stream,
  to_csv: write_csv_stream,
  to_xlml: write_xlml_stream,
  set_readable
};
const version = XLSX.version, xlsx = {
  parse_xlscfb,
  parse_zip,
  read: readSync,
  readFile: readFileSync,
  readFileSync,
  write: writeSync,
  writeFile: writeFileSync,
  writeFileSync,
  writeFileAsync,
  writeXLSX: writeSyncXLSX,
  writeFileXLSX: writeFileSyncXLSX,
  utils,
  set_fs,
  set_cptable,
  stream: __stream,
  SSF,
  CFB
}, xlsx$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CFB,
  SSF,
  default: xlsx,
  parse_xlscfb,
  parse_zip,
  read: readSync,
  readFile: readFileSync,
  readFileSync,
  set_cptable,
  set_fs,
  stream: __stream,
  utils,
  version,
  write: writeSync,
  writeFile: writeFileSync,
  writeFileAsync,
  writeFileSync,
  writeFileXLSX: writeFileSyncXLSX,
  writeXLSX: writeSyncXLSX
}, Symbol.toStringTag, { value: "Module" })), state$8 = {
  activeObservers: /* @__PURE__ */ new Set(),
  currentData: [],
  dataTable: null,
  defaultData: [
    ["var_1", "var_2", "var_3"],
    ["sample1", "sample2", "sample3"],
    ["", "", ""],
    ["", "", ""]
  ],
  elements: {},
  logPrefix: "LT Dynamic Content: ",
  options: {
    labels: {
      btnContinue: "Confirm",
      csvUploadHelp: `Add dynamic data to your item by typing directly into the table below. Or, import a file
            (csv, xls, xlsx, ods, and txt are supported).`,
      headerValidationHelp: `The header row must contain only lowercase letters, numbers, and underscores.
            Supports a maximum of 20 columns and 50 rows.`
    }
  },
  renderedCss: !1,
  useElementCache: !1
};
function run$8(le) {
  state$8.options = validateOptions(le), state$8.renderedCss || injectCSS$6(), document.querySelector(".lrn-author").classList.add("lt__dynamicContent"), window.XLSX = xlsx$1, appInstance().on("navigate", re);
  function re() {
    setTimeout(() => {
      ["items/:reference/settings/:tab", void 0].includes(appInstance().getLocation().route) && appInstance().getLocation().location.split("/").pop() === "data-table" && (setObserver(".lrn-author-datatable-editor", setup$1, {
        dispatchEvent: !1,
        root: getElement('[data-tab-content="data-table"]'),
        state: state$8
      }), setObserver(".lrn-author-datatable-preview", actionContinue, {
        dispatchEvent: !1,
        root: getElement('[data-tab-content="data-table"]'),
        state: state$8
      }));
    }, 150), appInstance().on("render:item", () => {
      state$8.currentData = [], state$8.dataTable = null, state$8.elements = {};
    });
  }
}
function setup$1() {
  const le = getElement(".lrn-author-datatable-source"), Y = getElement(".lrn-author-datatable-header"), re = getElement('[data-authorapi-selector="datatable-source-continue"]');
  if (setObserver("#dynamic-content-table", () => {
  }, {
    dispatchEvent: !0,
    name: "lt:datatable:editor",
    root: getElement('[data-tab-content="data-table"]'),
    state: state$8
  }), le) {
    if (!getElement("#dynamic-content-table")) {
      const fe = document.querySelector(".CodeMirror").CodeMirror.getDoc().getValue(), he = getTableTemplate();
      if (re.textContent = state$8.options.labels.btnContinue, Y.insertAdjacentHTML("afterend", he), state$8.options.labels.csvUploadHelp.length) {
        const _e = document.createElement("p");
        _e.className = "lt-dynamic-content-help-text", _e.textContent = state$8.options.labels.csvUploadHelp, Y.appendChild(_e);
      }
      if (state$8.options.labels.headerValidationHelp.length) {
        const _e = document.createElement("p");
        _e.className = "lrn-author-message lrn-author-message-small lrn-author-message-info", _e.textContent = state$8.options.labels.headerValidationHelp, Y.appendChild(_e);
      }
      fe.length && (state$8.currentData = Papa.parse(fe.trim()).data);
    }
    const ue = getElement("#dynamic-content-table");
    if (ue) {
      const fe = state$8.currentData.length ? state$8.currentData : state$8.defaultData, he = debounce$2(updateAPIDataTable, 200), _e = debounce$2(checkHeader, 200);
      state$8.dataTable = ue, state$8.dataTable.updateData(fe), state$8.dataTable.onDataUpdate = (ve) => {
        he(ve), _e(ve);
      }, re.addEventListener("click", actionContinue);
    } else
      logger.error(`${state$8.logPrefix}Dynamic table element not found`);
  } else
    logger.error(`${state$8.logPrefix}Data element not found`);
}
function updateAPIDataTable(le) {
  const Y = {
    delimiter: ",",
    escapeChar: '"',
    header: !0,
    newline: `\r
`,
    quotes: !0,
    quoteChar: '"',
    skipEmptyLines: "greedy"
  }, re = Papa.unparse(le, Y);
  document.querySelector(".CodeMirror").CodeMirror.getDoc().setValue(re), state$8.currentData = le;
}
function checkHeader(le) {
  if (Array.isArray(le) && le.length) {
    for (const [Y, re] of le[0].entries())
      if (!/^[a-z0-9 _]+$/.test(re))
        try {
          state$8.dataTable.updateCell({
            newText: re.replace(/-/g, "_").replace(/[^a-zA-Z0-9 _]/g, "").toLowerCase(),
            rowIndex: 0,
            columnIndex: Y
          });
        } catch (oe) {
          oe.message !== "Cannot read properties of undefined (reading 'settings')" && logger.error(`${state$8.logPrefix}Error updating header cell: ${oe}`);
        }
  }
}
function actionContinue() {
  const le = getElement(".lrn-author-datatable-header");
  le.querySelector(".lrn-author-form-label-name").textContent = state$8.options.labels.headerLabel, setTimeout(() => {
    const Y = getElement('[data-authorapi-selector="datatable-preview-edit"]');
    Y ? Y.addEventListener("click", () => {
      setTimeout(() => {
        le.classList.add("hidden"), setup$1();
      }, 300);
    }) : logger.error(`${state$8.logPrefix}Edit button not found`);
    const re = getElement('[data-authorapi-selector="datatable-preview-reset"]');
    re.addEventListener("click", () => {
      re.classList.contains("lrn-author-btn-confirm-active") && setTimeout(() => {
        state$8.currentData = [], setup$1();
      }, 200);
    });
  }, 300);
}
function getElement(le) {
  if (state$8.useElementCache && state$8.elements[le])
    return state$8.elements[le];
  const Y = document.querySelector(le);
  return Y && (state$8.elements[le] = Y), Y;
}
function getTableTemplate() {
  return `<active-table
        id='dynamic-content-table'
        allowduplicateheaders='false'
        availableDefaultColumnTypes='[]'
        customColumnTypes='[
            {
                "name": "api-column",
                "customTextProcessing": {
                    "changeTextFunc": "(cellText) => cellText.replace(/^\\"(.*)\\"$/, \\"$1\\")"
                }
            }
        ]'
        defaultColumnTypeName="api-column"
        displayHeaderIcons='true'
        dragcolumns='true'
        dragrows='true'
        draganddrop='true'
        enterkeymovedown='true'
        maxcolumns='20'
        maxrows='51'
        preserveNarrowColumns='true'
        spellcheck='false'
        stickyHeader='true'
        files='{
            "buttons": [
                {
                    "position": "top-left",
                    "order": 0,
                    "text": "Import",
                    "import": {
                        "formats": ["csv", "xls", "xlsx", "ods", "txt"]
                    },
                    "styles": {
                        "default":{
                            "backgroundColor":"#eaeaea",
                            "color":"#333"
                        },
                        "hover":{
                            "backgroundColor":"#d9d9d9",
                            "color":"#333"
                        }
                    }
                },
                {
                    "position": "top-left",
                    "order": 1,
                    "text": "Export",
                    "export": {
                        "formats": ["csv", "xlsx", "ods"]
                    },
                    "styles": {
                        "default":{
                            "backgroundColor":"#eaeaea"
                        },
                        "hover":{
                            "backgroundColor":"#d9d9d9"
                        }
                    }
                }
            ]
        }'
        tableStyle='{
            "borderRadius":"4px"
        }'
        overflow='{
            "maxHeight":"${document.querySelector(".lrn-author-item-settings-container").offsetHeight - 230 || 300}px",
            "maxWidth":"481px"
        }'
        framecomponentsstyles='{
            "styles":{
                "default": {"backgroundColor": "#f5f5f5"},
                "hoverColors": {"backgroundColor": "#dedede"}
            },
            "inheritHeaderColors":false
        }'
        rowhoverstyles='{
            "style":{
                "backgroundColor":"#d6d6d630",
                "transitionDuration":"0.05s"
            }
        }'
    ></active-table>`;
}
function validateOptions(le) {
  let Y = le || {};
  return le && typeof le == "object" ? Y = { ...state$8.options, ...le } : Y = { ...state$8.options }, Y;
}
function injectCSS$6() {
  const le = document.createElement("style"), Y = `
/* Learnosity dynamic content styles */
.lt__dynamicContent.lrn-author.lrn-author  {
    .lt-dynamic-content-help-text {
        font-size: 15.4px;
        line-height: 1.4em;
    }

    .lrn-author-datatable-footer {
        justify-content: space-between;
    }

    .lrn-author-api-react-container .lrn-author-item-settings .lrn-author-datatable-footer button:nth-child(2),
    .lrn-author-api-react-container .lrn-author-activity-labels .lrn-author-datatable-footer button:nth-child(2) {
        margin: 0 2px;
    }

    .lrn-author-api-react-container .lrn-author-item-settings,
    .lrn-author-api-react-container .lrn-author-activity-labels {
        .lrn-author-datatable-editor {
            .lrn-author-datatable-header {
                height: auto;
                padding-bottom: 0;
            }

            .lrn-author-datatable-source-wrapper {
                display: none;
            }
        }

        .lrn-author-datatable-header {
            label {
                display: none;
            }
        }
    }
}
`;
  le.setAttribute("data-style", "LT Dynamic Content"), le.textContent = Y, document.head.append(le), state$8.renderedCss = !0;
}
const dynamicContent = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  run: run$8,
  setup: setup$1,
  updateAPIDataTable,
  validateOptions
}, Symbol.toStringTag, { value: "Module" })), state$7 = {
  renderedCss: !1,
  validTypes: ["longtextV2", "plaintext"]
};
function run$7() {
  state$7.renderedCss || injectCSS$5(), setupListeners();
}
function setupListeners() {
  appInstance().on("widgetedit:widget:ready", () => {
    setTimeout(() => {
      const le = type();
      if (state$7.validTypes.includes(le)) {
        const Y = document.querySelector('[data-lrn-qe-input-path="max_length"] input.lrn-qe-input');
        Y && Y.addEventListener("input", () => {
          validateInput(Y);
        });
      }
    }, 500);
  });
}
function validateInput(le) {
  const Y = /^\d+$/, re = /^(0|[1-9]\d*)$/, oe = "lt__input-invalid";
  le.value = le.value.replace(/^0+/, ""), Y.test(le.value) || (le.value = le.value.replace(/[^0-9]/g, "")), le.value.length && !re.test(le.value) ? le.classList.add(oe) : le.classList.remove(oe);
}
function injectCSS$5() {
  const le = document.createElement("style"), Y = `
/* Learnosity essay validate max length styles */
.lrn-qe-ui .lrn-qe-form-group .lrn-qe-form-control.lt__input-invalid,
.lrn-qe-ui .lrn-qe-form-group .lrn-qe-form-control.lt__input-invalid:active:not(:disabled):not([readonly]),
.lrn-qe-ui .lrn-qe-form-group .lrn-qe-form-control.lt__input-invalid:focus:not(:disabled):not([readonly]) {
    border-color: #ff0000;
    outline: 0.0714285714em solid #dd002f;
}
`;
  le.setAttribute("data-style", "LT Essay Max Length"), le.textContent = Y, document.head.append(le), state$7.renderedCss = !0;
}
const essayMaxLength = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  run: run$7
}, Symbol.toStringTag, { value: "Module" }));
function checkAppVersion(le) {
  return le === null && diagnostics()?.versions?.concrete && (le = parseFloat(diagnostics().versions.concrete.replace(/^v/, "").split(".").slice(0, 2).join("")) >= 2227 ? "author-" : ""), le;
}
function _classPrivateFieldLooseBase$7(le, Y) {
  if (!{}.hasOwnProperty.call(le, Y)) throw new TypeError("attempted to use private field on non-instance");
  return le;
}
var id$7 = 0;
function _classPrivateFieldLooseKey$7(le) {
  return "__private_" + id$7++ + "_" + le;
}
function insertReplacement(le, Y, re) {
  const oe = [];
  return le.forEach((ue) => typeof ue != "string" ? oe.push(ue) : Y[Symbol.split](ue).forEach((fe, he, _e) => {
    fe !== "" && oe.push(fe), he < _e.length - 1 && oe.push(re);
  })), oe;
}
/**
 * Takes a string with placeholder variables like `%{smart_count} file selected`
 * and replaces it with values from options `{smart_count: 5}`
 *
 * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
 * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
 *
 * @param phrase that needs interpolation, with placeholders
 * @param options with values that will be used to replace placeholders
 */
function interpolate(le, Y) {
  const re = /\$/g, oe = "$$$$";
  let ue = [le];
  if (Y == null) return ue;
  for (const fe of Object.keys(Y))
    if (fe !== "_") {
      let he = Y[fe];
      typeof he == "string" && (he = re[Symbol.replace](he, oe)), ue = insertReplacement(ue, new RegExp(`%\\{${fe}\\}`, "g"), he);
    }
  return ue;
}
const defaultOnMissingKey = (le) => {
  throw new Error(`missing string: ${le}`);
};
var _onMissingKey = /* @__PURE__ */ _classPrivateFieldLooseKey$7("onMissingKey"), _apply = /* @__PURE__ */ _classPrivateFieldLooseKey$7("apply");
class Translator {
  constructor(Y, re) {
    let {
      onMissingKey: oe = defaultOnMissingKey
    } = re === void 0 ? {} : re;
    Object.defineProperty(this, _apply, {
      value: _apply2
    }), Object.defineProperty(this, _onMissingKey, {
      writable: !0,
      value: void 0
    }), this.locale = {
      strings: {},
      pluralize(ue) {
        return ue === 1 ? 0 : 1;
      }
    }, Array.isArray(Y) ? Y.forEach(_classPrivateFieldLooseBase$7(this, _apply)[_apply], this) : _classPrivateFieldLooseBase$7(this, _apply)[_apply](Y), _classPrivateFieldLooseBase$7(this, _onMissingKey)[_onMissingKey] = oe;
  }
  /**
   * Public translate method
   *
   * @param key
   * @param options with values that will be used later to replace placeholders in string
   * @returns string translated (and interpolated)
   */
  translate(Y, re) {
    return this.translateArray(Y, re).join("");
  }
  /**
   * Get a translation and return the translated and interpolated parts as an array.
   *
   * @returns The translated and interpolated parts, in order.
   */
  translateArray(Y, re) {
    let oe = this.locale.strings[Y];
    if (oe == null && (_classPrivateFieldLooseBase$7(this, _onMissingKey)[_onMissingKey](Y), oe = Y), typeof oe == "object") {
      if (re && typeof re.smart_count < "u") {
        const fe = this.locale.pluralize(re.smart_count);
        return interpolate(oe[fe], re);
      }
      throw new Error("Attempted to use a string with plural forms, but no value was given for %{smart_count}");
    }
    if (typeof oe != "string")
      throw new Error("string was not a string");
    return interpolate(oe, re);
  }
}
function _apply2(le) {
  if (!(le != null && le.strings))
    return;
  const Y = this.locale;
  Object.assign(this.locale, {
    strings: {
      ...Y.strings,
      ...le.strings
    },
    pluralize: le.pluralize || Y.pluralize
  });
}
var namespaceEmitter, hasRequiredNamespaceEmitter;
function requireNamespaceEmitter() {
  return hasRequiredNamespaceEmitter || (hasRequiredNamespaceEmitter = 1, namespaceEmitter = function() {
    var Y = {}, re = Y._fns = {};
    Y.emit = function(he, _e, ve, xe, Ee, Se, Te) {
      var Ce = oe(he);
      Ce.length && ue(he, Ce, [_e, ve, xe, Ee, Se, Te]);
    }, Y.on = function(he, _e) {
      re[he] || (re[he] = []), re[he].push(_e);
    }, Y.once = function(he, _e) {
      function ve() {
        _e.apply(this, arguments), Y.off(he, ve);
      }
      this.on(he, ve);
    }, Y.off = function(he, _e) {
      var ve = [];
      if (he && _e) {
        var xe = this._fns[he], Ee = 0, Se = xe ? xe.length : 0;
        for (Ee; Ee < Se; Ee++)
          xe[Ee] !== _e && ve.push(xe[Ee]);
      }
      ve.length ? this._fns[he] = ve : delete this._fns[he];
    };
    function oe(fe) {
      var he = re[fe] ? re[fe] : [], _e = fe.indexOf(":"), ve = _e === -1 ? [fe] : [fe.substring(0, _e), fe.substring(_e + 1)], xe = Object.keys(re), Ee = 0, Se = xe.length;
      for (Ee; Ee < Se; Ee++) {
        var Te = xe[Ee];
        if (Te === "*" && (he = he.concat(re[Te])), ve.length === 2 && ve[0] === Te) {
          he = he.concat(re[Te]);
          break;
        }
      }
      return he;
    }
    function ue(fe, he, _e) {
      var ve = 0, xe = he.length;
      for (ve; ve < xe && he[ve]; ve++)
        he[ve].event = fe, he[ve].apply(he[ve], _e);
    }
    return Y;
  }), namespaceEmitter;
}
var namespaceEmitterExports = requireNamespaceEmitter();
const ee$1 = /* @__PURE__ */ getDefaultExportFromCjs(namespaceEmitterExports);
let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", nanoid = (le = 21) => {
  let Y = "", re = le | 0;
  for (; re--; )
    Y += urlAlphabet[Math.random() * 64 | 0];
  return Y;
};
var isObject_1, hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject_1;
  hasRequiredIsObject = 1;
  function le(Y) {
    var re = typeof Y;
    return Y != null && (re == "object" || re == "function");
  }
  return isObject_1 = le, isObject_1;
}
var _freeGlobal, hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal) return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var le = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  return _freeGlobal = le, _freeGlobal;
}
var _root, hasRequired_root;
function require_root() {
  if (hasRequired_root) return _root;
  hasRequired_root = 1;
  var le = require_freeGlobal(), Y = typeof self == "object" && self && self.Object === Object && self, re = le || Y || Function("return this")();
  return _root = re, _root;
}
var now_1, hasRequiredNow;
function requireNow() {
  if (hasRequiredNow) return now_1;
  hasRequiredNow = 1;
  var le = require_root(), Y = function() {
    return le.Date.now();
  };
  return now_1 = Y, now_1;
}
var _trimmedEndIndex, hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var le = /\s/;
  function Y(re) {
    for (var oe = re.length; oe-- && le.test(re.charAt(oe)); )
      ;
    return oe;
  }
  return _trimmedEndIndex = Y, _trimmedEndIndex;
}
var _baseTrim, hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim) return _baseTrim;
  hasRequired_baseTrim = 1;
  var le = require_trimmedEndIndex(), Y = /^\s+/;
  function re(oe) {
    return oe && oe.slice(0, le(oe) + 1).replace(Y, "");
  }
  return _baseTrim = re, _baseTrim;
}
var _Symbol, hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol) return _Symbol;
  hasRequired_Symbol = 1;
  var le = require_root(), Y = le.Symbol;
  return _Symbol = Y, _Symbol;
}
var _getRawTag, hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag) return _getRawTag;
  hasRequired_getRawTag = 1;
  var le = require_Symbol(), Y = Object.prototype, re = Y.hasOwnProperty, oe = Y.toString, ue = le ? le.toStringTag : void 0;
  function fe(he) {
    var _e = re.call(he, ue), ve = he[ue];
    try {
      he[ue] = void 0;
      var xe = !0;
    } catch {
    }
    var Ee = oe.call(he);
    return xe && (_e ? he[ue] = ve : delete he[ue]), Ee;
  }
  return _getRawTag = fe, _getRawTag;
}
var _objectToString, hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString) return _objectToString;
  hasRequired_objectToString = 1;
  var le = Object.prototype, Y = le.toString;
  function re(oe) {
    return Y.call(oe);
  }
  return _objectToString = re, _objectToString;
}
var _baseGetTag, hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag) return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var le = require_Symbol(), Y = require_getRawTag(), re = require_objectToString(), oe = "[object Null]", ue = "[object Undefined]", fe = le ? le.toStringTag : void 0;
  function he(_e) {
    return _e == null ? _e === void 0 ? ue : oe : fe && fe in Object(_e) ? Y(_e) : re(_e);
  }
  return _baseGetTag = he, _baseGetTag;
}
var isObjectLike_1, hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike) return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function le(Y) {
    return Y != null && typeof Y == "object";
  }
  return isObjectLike_1 = le, isObjectLike_1;
}
var isSymbol_1, hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var le = require_baseGetTag(), Y = requireIsObjectLike(), re = "[object Symbol]";
  function oe(ue) {
    return typeof ue == "symbol" || Y(ue) && le(ue) == re;
  }
  return isSymbol_1 = oe, isSymbol_1;
}
var toNumber_1, hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber) return toNumber_1;
  hasRequiredToNumber = 1;
  var le = require_baseTrim(), Y = requireIsObject(), re = requireIsSymbol(), oe = NaN, ue = /^[-+]0x[0-9a-f]+$/i, fe = /^0b[01]+$/i, he = /^0o[0-7]+$/i, _e = parseInt;
  function ve(xe) {
    if (typeof xe == "number")
      return xe;
    if (re(xe))
      return oe;
    if (Y(xe)) {
      var Ee = typeof xe.valueOf == "function" ? xe.valueOf() : xe;
      xe = Y(Ee) ? Ee + "" : Ee;
    }
    if (typeof xe != "string")
      return xe === 0 ? xe : +xe;
    xe = le(xe);
    var Se = fe.test(xe);
    return Se || he.test(xe) ? _e(xe.slice(2), Se ? 2 : 8) : ue.test(xe) ? oe : +xe;
  }
  return toNumber_1 = ve, toNumber_1;
}
var debounce_1, hasRequiredDebounce;
function requireDebounce() {
  if (hasRequiredDebounce) return debounce_1;
  hasRequiredDebounce = 1;
  var le = requireIsObject(), Y = requireNow(), re = requireToNumber(), oe = "Expected a function", ue = Math.max, fe = Math.min;
  function he(_e, ve, xe) {
    var Ee, Se, Te, Ce, Ie, Ne, Re = 0, Ae = !1, Pe = !1, Fe = !0;
    if (typeof _e != "function")
      throw new TypeError(oe);
    ve = re(ve) || 0, le(xe) && (Ae = !!xe.leading, Pe = "maxWait" in xe, Te = Pe ? ue(re(xe.maxWait) || 0, ve) : Te, Fe = "trailing" in xe ? !!xe.trailing : Fe);
    function Le(Xe) {
      var mt = Ee, at = Se;
      return Ee = Se = void 0, Re = Xe, Ce = _e.apply(at, mt), Ce;
    }
    function He(Xe) {
      return Re = Xe, Ie = setTimeout($e, ve), Ae ? Le(Xe) : Ce;
    }
    function Ge(Xe) {
      var mt = Xe - Ne, at = Xe - Re, qe = ve - mt;
      return Pe ? fe(qe, Te - at) : qe;
    }
    function Ve(Xe) {
      var mt = Xe - Ne, at = Xe - Re;
      return Ne === void 0 || mt >= ve || mt < 0 || Pe && at >= Te;
    }
    function $e() {
      var Xe = Y();
      if (Ve(Xe))
        return De(Xe);
      Ie = setTimeout($e, Ge(Xe));
    }
    function De(Xe) {
      return Ie = void 0, Fe && Ee ? Le(Xe) : (Ee = Se = void 0, Ce);
    }
    function Ke() {
      Ie !== void 0 && clearTimeout(Ie), Re = 0, Ee = Ne = Se = Ie = void 0;
    }
    function ze() {
      return Ie === void 0 ? Ce : De(Y());
    }
    function tt() {
      var Xe = Y(), mt = Ve(Xe);
      if (Ee = arguments, Se = this, Ne = Xe, mt) {
        if (Ie === void 0)
          return He(Ne);
        if (Pe)
          return clearTimeout(Ie), Ie = setTimeout($e, ve), Le(Ne);
      }
      return Ie === void 0 && (Ie = setTimeout($e, ve)), Ce;
    }
    return tt.cancel = Ke, tt.flush = ze, tt;
  }
  return debounce_1 = he, debounce_1;
}
var throttle_1, hasRequiredThrottle;
function requireThrottle() {
  if (hasRequiredThrottle) return throttle_1;
  hasRequiredThrottle = 1;
  var le = requireDebounce(), Y = requireIsObject(), re = "Expected a function";
  function oe(ue, fe, he) {
    var _e = !0, ve = !0;
    if (typeof ue != "function")
      throw new TypeError(re);
    return Y(he) && (_e = "leading" in he ? !!he.leading : _e, ve = "trailing" in he ? !!he.trailing : ve), le(ue, fe, {
      leading: _e,
      maxWait: fe,
      trailing: ve
    });
  }
  return throttle_1 = oe, throttle_1;
}
var throttleExports = requireThrottle();
const throttle = /* @__PURE__ */ getDefaultExportFromCjs(throttleExports);
function _classPrivateFieldLooseBase$6(le, Y) {
  if (!{}.hasOwnProperty.call(le, Y)) throw new TypeError("attempted to use private field on non-instance");
  return le;
}
var id$6 = 0;
function _classPrivateFieldLooseKey$6(le) {
  return "__private_" + id$6++ + "_" + le;
}
const packageJson$6 = {
  version: "4.2.0"
};
var _callbacks = /* @__PURE__ */ _classPrivateFieldLooseKey$6("callbacks"), _publish = /* @__PURE__ */ _classPrivateFieldLooseKey$6("publish");
class DefaultStore {
  constructor() {
    Object.defineProperty(this, _publish, {
      value: _publish2
    }), this.state = {}, Object.defineProperty(this, _callbacks, {
      writable: !0,
      value: /* @__PURE__ */ new Set()
    });
  }
  getState() {
    return this.state;
  }
  setState(Y) {
    const re = {
      ...this.state
    }, oe = {
      ...this.state,
      ...Y
    };
    this.state = oe, _classPrivateFieldLooseBase$6(this, _publish)[_publish](re, oe, Y);
  }
  subscribe(Y) {
    return _classPrivateFieldLooseBase$6(this, _callbacks)[_callbacks].add(Y), () => {
      _classPrivateFieldLooseBase$6(this, _callbacks)[_callbacks].delete(Y);
    };
  }
}
function _publish2() {
  for (var le = arguments.length, Y = new Array(le), re = 0; re < le; re++)
    Y[re] = arguments[re];
  _classPrivateFieldLooseBase$6(this, _callbacks)[_callbacks].forEach((oe) => {
    oe(...Y);
  });
}
DefaultStore.VERSION = packageJson$6.version;
function getFileNameAndExtension(le) {
  const Y = le.lastIndexOf(".");
  return Y === -1 || Y === le.length - 1 ? {
    name: le,
    extension: void 0
  } : {
    name: le.slice(0, Y),
    extension: le.slice(Y + 1)
  };
}
const mimeTypes = {
  __proto__: null,
  md: "text/markdown",
  markdown: "text/markdown",
  mp4: "video/mp4",
  mp3: "audio/mp3",
  svg: "image/svg+xml",
  jpg: "image/jpeg",
  png: "image/png",
  webp: "image/webp",
  gif: "image/gif",
  heic: "image/heic",
  heif: "image/heif",
  yaml: "text/yaml",
  yml: "text/yaml",
  csv: "text/csv",
  tsv: "text/tab-separated-values",
  tab: "text/tab-separated-values",
  avi: "video/x-msvideo",
  mks: "video/x-matroska",
  mkv: "video/x-matroska",
  mov: "video/quicktime",
  dicom: "application/dicom",
  doc: "application/msword",
  msg: "application/vnd.ms-outlook",
  docm: "application/vnd.ms-word.document.macroenabled.12",
  docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  dot: "application/msword",
  dotm: "application/vnd.ms-word.template.macroenabled.12",
  dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
  xla: "application/vnd.ms-excel",
  xlam: "application/vnd.ms-excel.addin.macroenabled.12",
  xlc: "application/vnd.ms-excel",
  xlf: "application/x-xliff+xml",
  xlm: "application/vnd.ms-excel",
  xls: "application/vnd.ms-excel",
  xlsb: "application/vnd.ms-excel.sheet.binary.macroenabled.12",
  xlsm: "application/vnd.ms-excel.sheet.macroenabled.12",
  xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  xlt: "application/vnd.ms-excel",
  xltm: "application/vnd.ms-excel.template.macroenabled.12",
  xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
  xlw: "application/vnd.ms-excel",
  txt: "text/plain",
  text: "text/plain",
  conf: "text/plain",
  log: "text/plain",
  pdf: "application/pdf",
  zip: "application/zip",
  "7z": "application/x-7z-compressed",
  rar: "application/x-rar-compressed",
  tar: "application/x-tar",
  gz: "application/gzip",
  dmg: "application/x-apple-diskimage"
};
function getFileType(le) {
  var Y;
  if (le.type) return le.type;
  const re = le.name ? (Y = getFileNameAndExtension(le.name).extension) == null ? void 0 : Y.toLowerCase() : null;
  return re && re in mimeTypes ? mimeTypes[re] : "application/octet-stream";
}
function encodeCharacter(le) {
  return le.charCodeAt(0).toString(32);
}
function encodeFilename(le) {
  let Y = "";
  return le.replace(/[^A-Z0-9]/gi, (re) => (Y += `-${encodeCharacter(re)}`, "/")) + Y;
}
function generateFileID(le, Y) {
  let re = Y || "uppy";
  return typeof le.name == "string" && (re += `-${encodeFilename(le.name.toLowerCase())}`), le.type !== void 0 && (re += `-${le.type}`), le.meta && typeof le.meta.relativePath == "string" && (re += `-${encodeFilename(le.meta.relativePath.toLowerCase())}`), le.data.size !== void 0 && (re += `-${le.data.size}`), le.data.lastModified !== void 0 && (re += `-${le.data.lastModified}`), re;
}
function hasFileStableId(le) {
  return !le.isRemote || !le.remote ? !1 : (/* @__PURE__ */ new Set(["box", "dropbox", "drive", "facebook", "unsplash"])).has(le.remote.provider);
}
function getSafeFileId(le, Y) {
  if (hasFileStableId(le)) return le.id;
  const re = getFileType(le);
  return generateFileID({
    ...le,
    type: re
  }, Y);
}
function supportsUploadProgress(le) {
  if (le == null && typeof navigator < "u" && (le = navigator.userAgent), !le) return !0;
  const Y = /Edge\/(\d+\.\d+)/.exec(le);
  if (!Y) return !0;
  const oe = Y[1].split(".", 2), ue = parseInt(oe[0], 10), fe = parseInt(oe[1], 10);
  return ue < 15 || ue === 15 && fe < 15063 || ue > 18 || ue === 18 && fe >= 18218;
}
function getFileName(le, Y) {
  return Y.name ? Y.name : le.split("/")[0] === "image" ? `${le.split("/")[0]}.${le.split("/")[1]}` : "noname";
}
function pad(le) {
  return le < 10 ? `0${le}` : le.toString();
}
function getTimeStamp() {
  const le = /* @__PURE__ */ new Date(), Y = pad(le.getHours()), re = pad(le.getMinutes()), oe = pad(le.getSeconds());
  return `${Y}:${re}:${oe}`;
}
const justErrorsLogger = {
  debug: () => {
  },
  warn: () => {
  },
  error: function() {
    for (var le = arguments.length, Y = new Array(le), re = 0; re < le; re++)
      Y[re] = arguments[re];
    return console.error(`[Uppy] [${getTimeStamp()}]`, ...Y);
  }
}, debugLogger = {
  debug: function() {
    for (var le = arguments.length, Y = new Array(le), re = 0; re < le; re++)
      Y[re] = arguments[re];
    return console.debug(`[Uppy] [${getTimeStamp()}]`, ...Y);
  },
  warn: function() {
    for (var le = arguments.length, Y = new Array(le), re = 0; re < le; re++)
      Y[re] = arguments[re];
    return console.warn(`[Uppy] [${getTimeStamp()}]`, ...Y);
  },
  error: function() {
    for (var le = arguments.length, Y = new Array(le), re = 0; re < le; re++)
      Y[re] = arguments[re];
    return console.error(`[Uppy] [${getTimeStamp()}]`, ...Y);
  }
};
var prettierBytes$1, hasRequiredPrettierBytes;
function requirePrettierBytes() {
  return hasRequiredPrettierBytes || (hasRequiredPrettierBytes = 1, prettierBytes$1 = function(Y) {
    if (typeof Y != "number" || Number.isNaN(Y))
      throw new TypeError(`Expected a number, got ${typeof Y}`);
    const re = Y < 0;
    let oe = Math.abs(Y);
    if (re && (oe = -oe), oe === 0)
      return "0 B";
    const ue = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"], fe = Math.min(Math.floor(Math.log(oe) / Math.log(1024)), ue.length - 1), he = Number(oe / 1024 ** fe), _e = ue[fe];
    return `${he >= 10 || he % 1 === 0 ? Math.round(he) : he.toFixed(1)} ${_e}`;
  }), prettierBytes$1;
}
var prettierBytesExports = requirePrettierBytes();
const prettierBytes = /* @__PURE__ */ getDefaultExportFromCjs(prettierBytesExports);
var wildcard, hasRequiredWildcard;
function requireWildcard() {
  if (hasRequiredWildcard) return wildcard;
  hasRequiredWildcard = 1;
  function le(Y, re) {
    this.text = Y = Y || "", this.hasWild = ~Y.indexOf("*"), this.separator = re, this.parts = Y.split(re);
  }
  return le.prototype.match = function(Y) {
    var re = !0, oe = this.parts, ue, fe = oe.length, he;
    if (typeof Y == "string" || Y instanceof String)
      if (!this.hasWild && this.text != Y)
        re = !1;
      else {
        for (he = (Y || "").split(this.separator), ue = 0; re && ue < fe; ue++)
          oe[ue] !== "*" && (ue < he.length ? re = oe[ue] === he[ue] : re = !1);
        re = re && he;
      }
    else if (typeof Y.splice == "function")
      for (re = [], ue = Y.length; ue--; )
        this.match(Y[ue]) && (re[re.length] = Y[ue]);
    else if (typeof Y == "object") {
      re = {};
      for (var _e in Y)
        this.match(_e) && (re[_e] = Y[_e]);
    }
    return re;
  }, wildcard = function(Y, re, oe) {
    var ue = new le(Y, oe || /[\/\.]/);
    return typeof re < "u" ? ue.match(re) : ue;
  }, wildcard;
}
var mimeMatch, hasRequiredMimeMatch;
function requireMimeMatch() {
  if (hasRequiredMimeMatch) return mimeMatch;
  hasRequiredMimeMatch = 1;
  var le = requireWildcard(), Y = /[\/\+\.]/;
  return mimeMatch = function(re, oe) {
    function ue(fe) {
      var he = le(fe, re, Y);
      return he && he.length >= 2;
    }
    return oe ? ue(oe.split(";")[0]) : ue;
  }, mimeMatch;
}
var mimeMatchExports = requireMimeMatch();
const match$1 = /* @__PURE__ */ getDefaultExportFromCjs(mimeMatchExports), defaultOptions$6 = {
  maxFileSize: null,
  minFileSize: null,
  maxTotalFileSize: null,
  maxNumberOfFiles: null,
  minNumberOfFiles: null,
  allowedFileTypes: null,
  requiredMetaFields: []
};
class RestrictionError extends Error {
  constructor(Y, re) {
    var oe;
    super(Y), this.isRestriction = !0, this.isUserFacing = (oe = re?.isUserFacing) != null ? oe : !0, re != null && re.file && (this.file = re.file);
  }
}
class Restricter {
  constructor(Y, re) {
    this.getI18n = re, this.getOpts = () => {
      var oe;
      const ue = Y();
      if (((oe = ue.restrictions) == null ? void 0 : oe.allowedFileTypes) != null && !Array.isArray(ue.restrictions.allowedFileTypes))
        throw new TypeError("`restrictions.allowedFileTypes` must be an array");
      return ue;
    };
  }
  // Because these operations are slow, we cannot run them for every file (if we are adding multiple files)
  validateAggregateRestrictions(Y, re) {
    const {
      maxTotalFileSize: oe,
      maxNumberOfFiles: ue
    } = this.getOpts().restrictions;
    if (ue && Y.filter((he) => !he.isGhost).length + re.length > ue)
      throw new RestrictionError(`${this.getI18n()("youCanOnlyUploadX", {
        smart_count: ue
      })}`);
    if (oe) {
      const fe = [...Y, ...re].reduce((he, _e) => {
        var ve;
        return he + ((ve = _e.size) != null ? ve : 0);
      }, 0);
      if (fe > oe)
        throw new RestrictionError(this.getI18n()("aggregateExceedsSize", {
          sizeAllowed: prettierBytes(oe),
          size: prettierBytes(fe)
        }));
    }
  }
  validateSingleFile(Y) {
    const {
      maxFileSize: re,
      minFileSize: oe,
      allowedFileTypes: ue
    } = this.getOpts().restrictions;
    if (ue && !ue.some((_e) => _e.includes("/") ? Y.type ? match$1(Y.type.replace(/;.*?$/, ""), _e) : !1 : _e[0] === "." && Y.extension ? Y.extension.toLowerCase() === _e.slice(1).toLowerCase() : !1)) {
      const _e = ue.join(", ");
      throw new RestrictionError(this.getI18n()("youCanOnlyUploadFileTypes", {
        types: _e
      }), {
        file: Y
      });
    }
    if (re && Y.size != null && Y.size > re) {
      var fe;
      throw new RestrictionError(this.getI18n()("exceedsSize", {
        size: prettierBytes(re),
        file: (fe = Y.name) != null ? fe : this.getI18n()("unnamed")
      }), {
        file: Y
      });
    }
    if (oe && Y.size != null && Y.size < oe)
      throw new RestrictionError(this.getI18n()("inferiorSize", {
        size: prettierBytes(oe)
      }), {
        file: Y
      });
  }
  validate(Y, re) {
    re.forEach((oe) => {
      this.validateSingleFile(oe);
    }), this.validateAggregateRestrictions(Y, re);
  }
  validateMinNumberOfFiles(Y) {
    const {
      minNumberOfFiles: re
    } = this.getOpts().restrictions;
    if (re && Object.keys(Y).length < re)
      throw new RestrictionError(this.getI18n()("youHaveToAtLeastSelectX", {
        smart_count: re
      }));
  }
  getMissingRequiredMetaFields(Y) {
    var re;
    const oe = new RestrictionError(this.getI18n()("missingRequiredMetaFieldOnFile", {
      fileName: (re = Y.name) != null ? re : this.getI18n()("unnamed")
    })), {
      requiredMetaFields: ue
    } = this.getOpts().restrictions, fe = [];
    for (const he of ue)
      (!Object.hasOwn(Y.meta, he) || Y.meta[he] === "") && fe.push(he);
    return {
      missingFields: fe,
      error: oe
    };
  }
}
const locale$5 = {
  strings: {
    addBulkFilesFailed: {
      0: "Failed to add %{smart_count} file due to an internal error",
      1: "Failed to add %{smart_count} files due to internal errors"
    },
    youCanOnlyUploadX: {
      0: "You can only upload %{smart_count} file",
      1: "You can only upload %{smart_count} files"
    },
    youHaveToAtLeastSelectX: {
      0: "You have to select at least %{smart_count} file",
      1: "You have to select at least %{smart_count} files"
    },
    aggregateExceedsSize: "You selected %{size} of files, but maximum allowed size is %{sizeAllowed}",
    exceedsSize: "%{file} exceeds maximum allowed size of %{size}",
    missingRequiredMetaField: "Missing required meta fields",
    missingRequiredMetaFieldOnFile: "Missing required meta fields in %{fileName}",
    inferiorSize: "This file is smaller than the allowed size of %{size}",
    youCanOnlyUploadFileTypes: "You can only upload: %{types}",
    noMoreFilesAllowed: "Cannot add more files",
    noDuplicates: "Cannot add the duplicate file '%{fileName}', it already exists",
    companionError: "Connection with Companion failed",
    authAborted: "Authentication aborted",
    companionUnauthorizeHint: "To unauthorize to your %{provider} account, please go to %{url}",
    failedToUpload: "Failed to upload %{file}",
    noInternetConnection: "No Internet connection",
    connectedToInternet: "Connected to the Internet",
    // Strings for remote providers
    noFilesFound: "You have no files or folders here",
    noSearchResults: "Unfortunately, there are no results for this search",
    selectX: {
      0: "Select %{smart_count}",
      1: "Select %{smart_count}"
    },
    allFilesFromFolderNamed: "All files from folder %{name}",
    openFolderNamed: "Open folder %{name}",
    cancel: "Cancel",
    logOut: "Log out",
    logIn: "Log in",
    pickFiles: "Pick files",
    pickPhotos: "Pick photos",
    filter: "Filter",
    resetFilter: "Reset filter",
    loading: "Loading...",
    loadedXFiles: "Loaded %{numFiles} files",
    authenticateWithTitle: "Please authenticate with %{pluginName} to select files",
    authenticateWith: "Connect to %{pluginName}",
    signInWithGoogle: "Sign in with Google",
    searchImages: "Search for images",
    enterTextToSearch: "Enter text to search for images",
    search: "Search",
    resetSearch: "Reset search",
    emptyFolderAdded: "No files were added from empty folder",
    addedNumFiles: "Added %{numFiles} file(s)",
    folderAlreadyAdded: 'The folder "%{folder}" was already added',
    folderAdded: {
      0: "Added %{smart_count} file from %{folder}",
      1: "Added %{smart_count} files from %{folder}"
    },
    additionalRestrictionsFailed: "%{count} additional restrictions were not fulfilled",
    unnamed: "Unnamed",
    pleaseWait: "Please wait"
  }
};
function _classPrivateFieldLooseBase$5(le, Y) {
  if (!{}.hasOwnProperty.call(le, Y)) throw new TypeError("attempted to use private field on non-instance");
  return le;
}
var id$5 = 0;
function _classPrivateFieldLooseKey$5(le) {
  return "__private_" + id$5++ + "_" + le;
}
const packageJson$5 = {
  version: "4.4.6"
}, defaultUploadState = {
  totalProgress: 0,
  allowNewUpload: !0,
  error: null,
  recoveredState: null
};
var _plugins = /* @__PURE__ */ _classPrivateFieldLooseKey$5("plugins"), _restricter = /* @__PURE__ */ _classPrivateFieldLooseKey$5("restricter"), _storeUnsubscribe = /* @__PURE__ */ _classPrivateFieldLooseKey$5("storeUnsubscribe"), _emitter = /* @__PURE__ */ _classPrivateFieldLooseKey$5("emitter"), _preProcessors = /* @__PURE__ */ _classPrivateFieldLooseKey$5("preProcessors"), _uploaders = /* @__PURE__ */ _classPrivateFieldLooseKey$5("uploaders"), _postProcessors = /* @__PURE__ */ _classPrivateFieldLooseKey$5("postProcessors"), _informAndEmit = /* @__PURE__ */ _classPrivateFieldLooseKey$5("informAndEmit"), _checkRequiredMetaFieldsOnFile = /* @__PURE__ */ _classPrivateFieldLooseKey$5("checkRequiredMetaFieldsOnFile"), _checkRequiredMetaFields = /* @__PURE__ */ _classPrivateFieldLooseKey$5("checkRequiredMetaFields"), _assertNewUploadAllowed = /* @__PURE__ */ _classPrivateFieldLooseKey$5("assertNewUploadAllowed"), _transformFile = /* @__PURE__ */ _classPrivateFieldLooseKey$5("transformFile"), _startIfAutoProceed = /* @__PURE__ */ _classPrivateFieldLooseKey$5("startIfAutoProceed"), _checkAndUpdateFileState = /* @__PURE__ */ _classPrivateFieldLooseKey$5("checkAndUpdateFileState"), _getFilesToRetry = /* @__PURE__ */ _classPrivateFieldLooseKey$5("getFilesToRetry"), _doRetryAll = /* @__PURE__ */ _classPrivateFieldLooseKey$5("doRetryAll"), _handleUploadProgress = /* @__PURE__ */ _classPrivateFieldLooseKey$5("handleUploadProgress"), _updateTotalProgress = /* @__PURE__ */ _classPrivateFieldLooseKey$5("updateTotalProgress"), _updateTotalProgressThrottled = /* @__PURE__ */ _classPrivateFieldLooseKey$5("updateTotalProgressThrottled"), _calculateTotalProgress = /* @__PURE__ */ _classPrivateFieldLooseKey$5("calculateTotalProgress"), _addListeners = /* @__PURE__ */ _classPrivateFieldLooseKey$5("addListeners"), _updateOnlineStatus = /* @__PURE__ */ _classPrivateFieldLooseKey$5("updateOnlineStatus"), _requestClientById = /* @__PURE__ */ _classPrivateFieldLooseKey$5("requestClientById"), _createUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$5("createUpload"), _getUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$5("getUpload"), _removeUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$5("removeUpload"), _runUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$5("runUpload");
class Uppy {
  /**
   * Instantiate Uppy
   */
  constructor(Y) {
    Object.defineProperty(this, _runUpload, {
      value: _runUpload2
    }), Object.defineProperty(this, _removeUpload, {
      value: _removeUpload2
    }), Object.defineProperty(this, _getUpload, {
      value: _getUpload2
    }), Object.defineProperty(this, _createUpload, {
      value: _createUpload2
    }), Object.defineProperty(this, _addListeners, {
      value: _addListeners2
    }), Object.defineProperty(this, _calculateTotalProgress, {
      value: _calculateTotalProgress2
    }), Object.defineProperty(this, _updateTotalProgress, {
      value: _updateTotalProgress2
    }), Object.defineProperty(this, _doRetryAll, {
      value: _doRetryAll2
    }), Object.defineProperty(this, _getFilesToRetry, {
      value: _getFilesToRetry2
    }), Object.defineProperty(this, _checkAndUpdateFileState, {
      value: _checkAndUpdateFileState2
    }), Object.defineProperty(this, _startIfAutoProceed, {
      value: _startIfAutoProceed2
    }), Object.defineProperty(this, _transformFile, {
      value: _transformFile2
    }), Object.defineProperty(this, _assertNewUploadAllowed, {
      value: _assertNewUploadAllowed2
    }), Object.defineProperty(this, _checkRequiredMetaFields, {
      value: _checkRequiredMetaFields2
    }), Object.defineProperty(this, _checkRequiredMetaFieldsOnFile, {
      value: _checkRequiredMetaFieldsOnFile2
    }), Object.defineProperty(this, _informAndEmit, {
      value: _informAndEmit2
    }), Object.defineProperty(this, _plugins, {
      writable: !0,
      value: /* @__PURE__ */ Object.create(null)
    }), Object.defineProperty(this, _restricter, {
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, _storeUnsubscribe, {
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, _emitter, {
      writable: !0,
      value: ee$1()
    }), Object.defineProperty(this, _preProcessors, {
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, _uploaders, {
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, _postProcessors, {
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), this.scheduledAutoProceed = null, this.wasOffline = !1, Object.defineProperty(this, _handleUploadProgress, {
      writable: !0,
      value: (ue, fe) => {
        const he = ue ? this.getFile(ue.id) : void 0;
        if (ue == null || !he) {
          this.log(`Not setting progress for a file that has been removed: ${ue?.id}`);
          return;
        }
        if (he.progress.percentage === 100) {
          this.log(`Not setting progress for a file that has been already uploaded: ${ue.id}`);
          return;
        }
        const _e = {
          bytesTotal: fe.bytesTotal,
          // bytesTotal may be null or zero; in that case we can't divide by it
          percentage: fe.bytesTotal != null && Number.isFinite(fe.bytesTotal) && fe.bytesTotal > 0 ? Math.round(fe.bytesUploaded / fe.bytesTotal * 100) : void 0
        };
        he.progress.uploadStarted != null ? this.setFileState(ue.id, {
          progress: {
            ...he.progress,
            ..._e,
            bytesUploaded: fe.bytesUploaded
          }
        }) : this.setFileState(ue.id, {
          progress: {
            ...he.progress,
            ..._e
          }
        }), _classPrivateFieldLooseBase$5(this, _updateTotalProgressThrottled)[_updateTotalProgressThrottled]();
      }
    }), Object.defineProperty(this, _updateTotalProgressThrottled, {
      writable: !0,
      value: throttle(() => _classPrivateFieldLooseBase$5(this, _updateTotalProgress)[_updateTotalProgress](), 500, {
        leading: !0,
        trailing: !0
      })
    }), Object.defineProperty(this, _updateOnlineStatus, {
      writable: !0,
      value: this.updateOnlineStatus.bind(this)
    }), Object.defineProperty(this, _requestClientById, {
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), this.defaultLocale = locale$5;
    const re = {
      id: "uppy",
      autoProceed: !1,
      allowMultipleUploadBatches: !0,
      debug: !1,
      restrictions: defaultOptions$6,
      meta: {},
      onBeforeFileAdded: (ue, fe) => !Object.hasOwn(fe, ue.id),
      onBeforeUpload: (ue) => ue,
      store: new DefaultStore(),
      logger: justErrorsLogger,
      infoTimeout: 5e3
    }, oe = {
      ...re,
      ...Y
    };
    this.opts = {
      ...oe,
      restrictions: {
        ...re.restrictions,
        ...Y && Y.restrictions
      }
    }, Y && Y.logger && Y.debug ? this.log("You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.", "warning") : Y && Y.debug && (this.opts.logger = debugLogger), this.log(`Using Core v${Uppy.VERSION}`), this.i18nInit(), this.store = this.opts.store, this.setState({
      ...defaultUploadState,
      plugins: {},
      files: {},
      currentUploads: {},
      capabilities: {
        uploadProgress: supportsUploadProgress(),
        individualCancellation: !0,
        resumableUploads: !1
      },
      meta: {
        ...this.opts.meta
      },
      info: []
    }), _classPrivateFieldLooseBase$5(this, _restricter)[_restricter] = new Restricter(() => this.opts, () => this.i18n), _classPrivateFieldLooseBase$5(this, _storeUnsubscribe)[_storeUnsubscribe] = this.store.subscribe((ue, fe, he) => {
      this.emit("state-update", ue, fe, he), this.updateAll(fe);
    }), this.opts.debug && typeof window < "u" && (window[this.opts.id] = this), _classPrivateFieldLooseBase$5(this, _addListeners)[_addListeners]();
  }
  emit(Y) {
    for (var re = arguments.length, oe = new Array(re > 1 ? re - 1 : 0), ue = 1; ue < re; ue++)
      oe[ue - 1] = arguments[ue];
    _classPrivateFieldLooseBase$5(this, _emitter)[_emitter].emit(Y, ...oe);
  }
  on(Y, re) {
    return _classPrivateFieldLooseBase$5(this, _emitter)[_emitter].on(Y, re), this;
  }
  once(Y, re) {
    return _classPrivateFieldLooseBase$5(this, _emitter)[_emitter].once(Y, re), this;
  }
  off(Y, re) {
    return _classPrivateFieldLooseBase$5(this, _emitter)[_emitter].off(Y, re), this;
  }
  /**
   * Iterate on all plugins and run `update` on them.
   * Called each time state changes.
   *
   */
  updateAll(Y) {
    this.iteratePlugins((re) => {
      re.update(Y);
    });
  }
  /**
   * Updates state with a patch
   */
  setState(Y) {
    this.store.setState(Y);
  }
  /**
   * Returns current state.
   */
  getState() {
    return this.store.getState();
  }
  patchFilesState(Y) {
    const re = this.getState().files;
    this.setState({
      files: {
        ...re,
        ...Object.fromEntries(Object.entries(Y).map((oe) => {
          let [ue, fe] = oe;
          return [ue, {
            ...re[ue],
            ...fe
          }];
        }))
      }
    });
  }
  /**
   * Shorthand to set state for a specific file.
   */
  setFileState(Y, re) {
    if (!this.getState().files[Y])
      throw new Error(`Can’t set state for ${Y} (the file could have been removed)`);
    this.patchFilesState({
      [Y]: re
    });
  }
  i18nInit() {
    const Y = (oe) => this.log(`Missing i18n string: ${oe}`, "error"), re = new Translator([this.defaultLocale, this.opts.locale], {
      onMissingKey: Y
    });
    this.i18n = re.translate.bind(re), this.i18nArray = re.translateArray.bind(re), this.locale = re.locale;
  }
  setOptions(Y) {
    this.opts = {
      ...this.opts,
      ...Y,
      restrictions: {
        ...this.opts.restrictions,
        ...Y?.restrictions
      }
    }, Y.meta && this.setMeta(Y.meta), this.i18nInit(), Y.locale && this.iteratePlugins((re) => {
      re.setOptions(Y);
    }), this.setState(void 0);
  }
  resetProgress() {
    const Y = {
      percentage: 0,
      bytesUploaded: !1,
      uploadComplete: !1,
      uploadStarted: null
    }, re = {
      ...this.getState().files
    }, oe = /* @__PURE__ */ Object.create(null);
    Object.keys(re).forEach((ue) => {
      oe[ue] = {
        ...re[ue],
        progress: {
          ...re[ue].progress,
          ...Y
        },
        // @ts-expect-error these typed are inserted
        // into the namespace in their respective packages
        // but core isn't ware of those
        tus: void 0,
        transloadit: void 0
      };
    }), this.setState({
      files: oe,
      ...defaultUploadState
    });
  }
  clear() {
    const {
      capabilities: Y,
      currentUploads: re
    } = this.getState();
    if (Object.keys(re).length > 0 && !Y.individualCancellation)
      throw new Error("The installed uploader plugin does not allow removing files during an upload.");
    this.setState({
      ...defaultUploadState,
      files: {}
    });
  }
  addPreProcessor(Y) {
    _classPrivateFieldLooseBase$5(this, _preProcessors)[_preProcessors].add(Y);
  }
  removePreProcessor(Y) {
    return _classPrivateFieldLooseBase$5(this, _preProcessors)[_preProcessors].delete(Y);
  }
  addPostProcessor(Y) {
    _classPrivateFieldLooseBase$5(this, _postProcessors)[_postProcessors].add(Y);
  }
  removePostProcessor(Y) {
    return _classPrivateFieldLooseBase$5(this, _postProcessors)[_postProcessors].delete(Y);
  }
  addUploader(Y) {
    _classPrivateFieldLooseBase$5(this, _uploaders)[_uploaders].add(Y);
  }
  removeUploader(Y) {
    return _classPrivateFieldLooseBase$5(this, _uploaders)[_uploaders].delete(Y);
  }
  setMeta(Y) {
    const re = {
      ...this.getState().meta,
      ...Y
    }, oe = {
      ...this.getState().files
    };
    Object.keys(oe).forEach((ue) => {
      oe[ue] = {
        ...oe[ue],
        meta: {
          ...oe[ue].meta,
          ...Y
        }
      };
    }), this.log("Adding metadata:"), this.log(Y), this.setState({
      meta: re,
      files: oe
    });
  }
  setFileMeta(Y, re) {
    const oe = {
      ...this.getState().files
    };
    if (!oe[Y]) {
      this.log(`Was trying to set metadata for a file that has been removed: ${Y}`);
      return;
    }
    const ue = {
      ...oe[Y].meta,
      ...re
    };
    oe[Y] = {
      ...oe[Y],
      meta: ue
    }, this.setState({
      files: oe
    });
  }
  /**
   * Get a file object.
   */
  getFile(Y) {
    return this.getState().files[Y];
  }
  /**
   * Get all files in an array.
   */
  getFiles() {
    const {
      files: Y
    } = this.getState();
    return Object.values(Y);
  }
  getFilesByIds(Y) {
    return Y.map((re) => this.getFile(re));
  }
  getObjectOfFilesPerState() {
    const {
      files: Y,
      totalProgress: re,
      error: oe
    } = this.getState(), ue = Object.values(Y), fe = [], he = [], _e = [], ve = [], xe = [], Ee = [], Se = [], Te = [], Ce = [];
    for (const Ie of ue) {
      const {
        progress: Ne
      } = Ie;
      !Ne.uploadComplete && Ne.uploadStarted && (fe.push(Ie), Ie.isPaused || Te.push(Ie)), Ne.uploadStarted || he.push(Ie), (Ne.uploadStarted || Ne.preprocess || Ne.postprocess) && _e.push(Ie), Ne.uploadStarted && ve.push(Ie), Ie.isPaused && xe.push(Ie), Ne.uploadComplete && Ee.push(Ie), Ie.error && Se.push(Ie), (Ne.preprocess || Ne.postprocess) && Ce.push(Ie);
    }
    return {
      newFiles: he,
      startedFiles: _e,
      uploadStartedFiles: ve,
      pausedFiles: xe,
      completeFiles: Ee,
      erroredFiles: Se,
      inProgressFiles: fe,
      inProgressNotPausedFiles: Te,
      processingFiles: Ce,
      isUploadStarted: ve.length > 0,
      isAllComplete: re === 100 && Ee.length === ue.length && Ce.length === 0,
      isAllErrored: !!oe && Se.length === ue.length,
      isAllPaused: fe.length !== 0 && xe.length === fe.length,
      isUploadInProgress: fe.length > 0,
      isSomeGhost: ue.some((Ie) => Ie.isGhost)
    };
  }
  validateRestrictions(Y, re) {
    re === void 0 && (re = this.getFiles());
    try {
      _classPrivateFieldLooseBase$5(this, _restricter)[_restricter].validate(re, [Y]);
    } catch (oe) {
      return oe;
    }
    return null;
  }
  validateSingleFile(Y) {
    try {
      _classPrivateFieldLooseBase$5(this, _restricter)[_restricter].validateSingleFile(Y);
    } catch (re) {
      return re.message;
    }
    return null;
  }
  validateAggregateRestrictions(Y) {
    const re = this.getFiles();
    try {
      _classPrivateFieldLooseBase$5(this, _restricter)[_restricter].validateAggregateRestrictions(re, Y);
    } catch (oe) {
      return oe.message;
    }
    return null;
  }
  checkIfFileAlreadyExists(Y) {
    const {
      files: re
    } = this.getState();
    return !!(re[Y] && !re[Y].isGhost);
  }
  /**
   * Add a new file to `state.files`. This will run `onBeforeFileAdded`,
   * try to guess file type in a clever way, check file against restrictions,
   * and start an upload if `autoProceed === true`.
   */
  addFile(Y) {
    _classPrivateFieldLooseBase$5(this, _assertNewUploadAllowed)[_assertNewUploadAllowed](Y);
    const {
      nextFilesState: re,
      validFilesToAdd: oe,
      errors: ue
    } = _classPrivateFieldLooseBase$5(this, _checkAndUpdateFileState)[_checkAndUpdateFileState]([Y]), fe = ue.filter((_e) => _e.isRestriction);
    if (_classPrivateFieldLooseBase$5(this, _informAndEmit)[_informAndEmit](fe), ue.length > 0) throw ue[0];
    this.setState({
      files: re
    });
    const [he] = oe;
    return this.emit("file-added", he), this.emit("files-added", oe), this.log(`Added file: ${he.name}, ${he.id}, mime type: ${he.type}`), _classPrivateFieldLooseBase$5(this, _startIfAutoProceed)[_startIfAutoProceed](), he.id;
  }
  /**
   * Add multiple files to `state.files`. See the `addFile()` documentation.
   *
   * If an error occurs while adding a file, it is logged and the user is notified.
   * This is good for UI plugins, but not for programmatic use.
   * Programmatic users should usually still use `addFile()` on individual files.
   */
  addFiles(Y) {
    _classPrivateFieldLooseBase$5(this, _assertNewUploadAllowed)[_assertNewUploadAllowed]();
    const {
      nextFilesState: re,
      validFilesToAdd: oe,
      errors: ue
    } = _classPrivateFieldLooseBase$5(this, _checkAndUpdateFileState)[_checkAndUpdateFileState](Y), fe = ue.filter((_e) => _e.isRestriction);
    _classPrivateFieldLooseBase$5(this, _informAndEmit)[_informAndEmit](fe);
    const he = ue.filter((_e) => !_e.isRestriction);
    if (he.length > 0) {
      let _e = `Multiple errors occurred while adding files:
`;
      if (he.forEach((ve) => {
        _e += `
 * ${ve.message}`;
      }), this.info({
        message: this.i18n("addBulkFilesFailed", {
          smart_count: he.length
        }),
        details: _e
      }, "error", this.opts.infoTimeout), typeof AggregateError == "function")
        throw new AggregateError(he, _e);
      {
        const ve = new Error(_e);
        throw ve.errors = he, ve;
      }
    }
    this.setState({
      files: re
    }), oe.forEach((_e) => {
      this.emit("file-added", _e);
    }), this.emit("files-added", oe), oe.length > 5 ? this.log(`Added batch of ${oe.length} files`) : Object.values(oe).forEach((_e) => {
      this.log(`Added file: ${_e.name}
 id: ${_e.id}
 type: ${_e.type}`);
    }), oe.length > 0 && _classPrivateFieldLooseBase$5(this, _startIfAutoProceed)[_startIfAutoProceed]();
  }
  removeFiles(Y) {
    const {
      files: re,
      currentUploads: oe
    } = this.getState(), ue = {
      ...re
    }, fe = {
      ...oe
    }, he = /* @__PURE__ */ Object.create(null);
    Y.forEach((Ee) => {
      re[Ee] && (he[Ee] = re[Ee], delete ue[Ee]);
    });
    function _e(Ee) {
      return he[Ee] === void 0;
    }
    Object.keys(fe).forEach((Ee) => {
      const Se = oe[Ee].fileIDs.filter(_e);
      if (Se.length === 0) {
        delete fe[Ee];
        return;
      }
      const {
        capabilities: Te
      } = this.getState();
      if (Se.length !== oe[Ee].fileIDs.length && !Te.individualCancellation)
        throw new Error("The installed uploader plugin does not allow removing files during an upload.");
      fe[Ee] = {
        ...oe[Ee],
        fileIDs: Se
      };
    });
    const ve = {
      currentUploads: fe,
      files: ue
    };
    Object.keys(ue).length === 0 && (ve.allowNewUpload = !0, ve.error = null, ve.recoveredState = null), this.setState(ve), _classPrivateFieldLooseBase$5(this, _updateTotalProgressThrottled)[_updateTotalProgressThrottled]();
    const xe = Object.keys(he);
    xe.forEach((Ee) => {
      this.emit("file-removed", he[Ee]);
    }), xe.length > 5 ? this.log(`Removed ${xe.length} files`) : this.log(`Removed files: ${xe.join(", ")}`);
  }
  removeFile(Y) {
    this.removeFiles([Y]);
  }
  pauseResume(Y) {
    if (!this.getState().capabilities.resumableUploads || this.getFile(Y).progress.uploadComplete)
      return;
    const re = this.getFile(Y), ue = !(re.isPaused || !1);
    return this.setFileState(Y, {
      isPaused: ue
    }), this.emit("upload-pause", re, ue), ue;
  }
  pauseAll() {
    const Y = {
      ...this.getState().files
    };
    Object.keys(Y).filter((oe) => !Y[oe].progress.uploadComplete && Y[oe].progress.uploadStarted).forEach((oe) => {
      const ue = {
        ...Y[oe],
        isPaused: !0
      };
      Y[oe] = ue;
    }), this.setState({
      files: Y
    }), this.emit("pause-all");
  }
  resumeAll() {
    const Y = {
      ...this.getState().files
    };
    Object.keys(Y).filter((oe) => !Y[oe].progress.uploadComplete && Y[oe].progress.uploadStarted).forEach((oe) => {
      const ue = {
        ...Y[oe],
        isPaused: !1,
        error: null
      };
      Y[oe] = ue;
    }), this.setState({
      files: Y
    }), this.emit("resume-all");
  }
  async retryAll() {
    const Y = await _classPrivateFieldLooseBase$5(this, _doRetryAll)[_doRetryAll]();
    return this.emit("complete", Y), Y;
  }
  cancelAll() {
    this.emit("cancel-all");
    const {
      files: Y
    } = this.getState(), re = Object.keys(Y);
    re.length && this.removeFiles(re), this.setState(defaultUploadState);
  }
  retryUpload(Y) {
    this.setFileState(Y, {
      error: null,
      isPaused: !1
    }), this.emit("upload-retry", this.getFile(Y));
    const re = _classPrivateFieldLooseBase$5(this, _createUpload)[_createUpload]([Y], {
      forceAllowNewUpload: !0
      // create new upload even if allowNewUpload: false
    });
    return _classPrivateFieldLooseBase$5(this, _runUpload)[_runUpload](re);
  }
  logout() {
    this.iteratePlugins((Y) => {
      var re;
      (re = Y.provider) == null || re.logout == null || re.logout();
    });
  }
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/explicit-module-boundary-types
  [Symbol.for("uppy test: updateTotalProgress")]() {
    return _classPrivateFieldLooseBase$5(this, _updateTotalProgress)[_updateTotalProgress]();
  }
  updateOnlineStatus() {
    var Y;
    ((Y = window.navigator.onLine) != null ? Y : !0) ? (this.emit("is-online"), this.wasOffline && (this.emit("back-online"), this.info(this.i18n("connectedToInternet"), "success", 3e3), this.wasOffline = !1)) : (this.emit("is-offline"), this.info(this.i18n("noInternetConnection"), "error", 0), this.wasOffline = !0);
  }
  getID() {
    return this.opts.id;
  }
  /**
   * Registers a plugin with Core.
   */
  use(Y) {
    if (typeof Y != "function") {
      const ve = `Expected a plugin class, but got ${Y === null ? "null" : typeof Y}. Please verify that the plugin was imported and spelled correctly.`;
      throw new TypeError(ve);
    }
    for (var re = arguments.length, oe = new Array(re > 1 ? re - 1 : 0), ue = 1; ue < re; ue++)
      oe[ue - 1] = arguments[ue];
    const fe = new Y(this, ...oe), he = fe.id;
    if (!he)
      throw new Error("Your plugin must have an id");
    if (!fe.type)
      throw new Error("Your plugin must have a type");
    const _e = this.getPlugin(he);
    if (_e) {
      const ve = `Already found a plugin named '${_e.id}'. Tried to use: '${he}'.
Uppy plugins must have unique \`id\` options.`;
      throw new Error(ve);
    }
    return Y.VERSION && this.log(`Using ${he} v${Y.VERSION}`), fe.type in _classPrivateFieldLooseBase$5(this, _plugins)[_plugins] ? _classPrivateFieldLooseBase$5(this, _plugins)[_plugins][fe.type].push(fe) : _classPrivateFieldLooseBase$5(this, _plugins)[_plugins][fe.type] = [fe], fe.install(), this.emit("plugin-added", fe), this;
  }
  /**
   * Find one Plugin by name.
   */
  getPlugin(Y) {
    for (const re of Object.values(_classPrivateFieldLooseBase$5(this, _plugins)[_plugins])) {
      const oe = re.find((ue) => ue.id === Y);
      if (oe != null) return oe;
    }
  }
  [Symbol.for("uppy test: getPlugins")](Y) {
    return _classPrivateFieldLooseBase$5(this, _plugins)[_plugins][Y];
  }
  /**
   * Iterate through all `use`d plugins.
   *
   */
  iteratePlugins(Y) {
    Object.values(_classPrivateFieldLooseBase$5(this, _plugins)[_plugins]).flat(1).forEach(Y);
  }
  /**
   * Uninstall and remove a plugin.
   *
   * @param {object} instance The plugin instance to remove.
   */
  removePlugin(Y) {
    this.log(`Removing plugin ${Y.id}`), this.emit("plugin-remove", Y), Y.uninstall && Y.uninstall();
    const re = _classPrivateFieldLooseBase$5(this, _plugins)[_plugins][Y.type], oe = re.findIndex((he) => he.id === Y.id);
    oe !== -1 && re.splice(oe, 1);
    const fe = {
      plugins: {
        ...this.getState().plugins,
        [Y.id]: void 0
      }
    };
    this.setState(fe);
  }
  /**
   * Uninstall all plugins and close down this Uppy instance.
   */
  destroy() {
    this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`), this.cancelAll(), _classPrivateFieldLooseBase$5(this, _storeUnsubscribe)[_storeUnsubscribe](), this.iteratePlugins((Y) => {
      this.removePlugin(Y);
    }), typeof window < "u" && window.removeEventListener && (window.removeEventListener("online", _classPrivateFieldLooseBase$5(this, _updateOnlineStatus)[_updateOnlineStatus]), window.removeEventListener("offline", _classPrivateFieldLooseBase$5(this, _updateOnlineStatus)[_updateOnlineStatus]));
  }
  hideInfo() {
    const {
      info: Y
    } = this.getState();
    this.setState({
      info: Y.slice(1)
    }), this.emit("info-hidden");
  }
  /**
   * Set info message in `state.info`, so that UI plugins like `Informer`
   * can display the message.
   */
  info(Y, re, oe) {
    re === void 0 && (re = "info"), oe === void 0 && (oe = 3e3);
    const ue = typeof Y == "object";
    this.setState({
      info: [...this.getState().info, {
        type: re,
        message: ue ? Y.message : Y,
        details: ue ? Y.details : null
      }]
    }), setTimeout(() => this.hideInfo(), oe), this.emit("info-visible");
  }
  /**
   * Passes messages to a function, provided in `opts.logger`.
   * If `opts.logger: Uppy.debugLogger` or `opts.debug: true`, logs to the browser console.
   */
  log(Y, re) {
    const {
      logger: oe
    } = this.opts;
    switch (re) {
      case "error":
        oe.error(Y);
        break;
      case "warning":
        oe.warn(Y);
        break;
      default:
        oe.debug(Y);
        break;
    }
  }
  registerRequestClient(Y, re) {
    _classPrivateFieldLooseBase$5(this, _requestClientById)[_requestClientById].set(Y, re);
  }
  /** @protected */
  getRequestClientForFile(Y) {
    if (!Y.remote) throw new Error(`Tried to get RequestClient for a non-remote file ${Y.id}`);
    const re = _classPrivateFieldLooseBase$5(this, _requestClientById)[_requestClientById].get(Y.remote.requestClientId);
    if (re == null) throw new Error(`requestClientId "${Y.remote.requestClientId}" not registered for file "${Y.id}"`);
    return re;
  }
  /**
   * Restore an upload by its ID.
   */
  restore(Y) {
    return this.log(`Core: attempting to restore upload "${Y}"`), this.getState().currentUploads[Y] ? _classPrivateFieldLooseBase$5(this, _runUpload)[_runUpload](Y) : (_classPrivateFieldLooseBase$5(this, _removeUpload)[_removeUpload](Y), Promise.reject(new Error("Nonexistent upload")));
  }
  [Symbol.for("uppy test: createUpload")]() {
    return _classPrivateFieldLooseBase$5(this, _createUpload)[_createUpload](...arguments);
  }
  /**
   * Add data to an upload's result object.
   */
  addResultData(Y, re) {
    if (!_classPrivateFieldLooseBase$5(this, _getUpload)[_getUpload](Y)) {
      this.log(`Not setting result for an upload that has been removed: ${Y}`);
      return;
    }
    const {
      currentUploads: oe
    } = this.getState(), ue = {
      ...oe[Y],
      result: {
        ...oe[Y].result,
        ...re
      }
    };
    this.setState({
      currentUploads: {
        ...oe,
        [Y]: ue
      }
    });
  }
  /**
   * Start an upload for all the files that are not currently being uploaded.
   */
  async upload() {
    var Y;
    (Y = _classPrivateFieldLooseBase$5(this, _plugins)[_plugins].uploader) != null && Y.length || this.log("No uploader type plugins are used", "warning");
    let {
      files: re
    } = this.getState();
    if (_classPrivateFieldLooseBase$5(this, _getFilesToRetry)[_getFilesToRetry]().length > 0) {
      const fe = await _classPrivateFieldLooseBase$5(this, _doRetryAll)[_doRetryAll]();
      if (!(this.getFiles().filter((_e) => _e.progress.uploadStarted == null).length > 0))
        return this.emit("complete", fe), fe;
      ({
        files: re
      } = this.getState());
    }
    const ue = this.opts.onBeforeUpload(re);
    return ue === !1 ? Promise.reject(new Error("Not starting the upload because onBeforeUpload returned false")) : (ue && typeof ue == "object" && (re = ue, this.setState({
      files: re
    })), Promise.resolve().then(() => _classPrivateFieldLooseBase$5(this, _restricter)[_restricter].validateMinNumberOfFiles(re)).catch((fe) => {
      throw _classPrivateFieldLooseBase$5(this, _informAndEmit)[_informAndEmit]([fe]), fe;
    }).then(() => {
      if (!_classPrivateFieldLooseBase$5(this, _checkRequiredMetaFields)[_checkRequiredMetaFields](re))
        throw new RestrictionError(this.i18n("missingRequiredMetaField"));
    }).catch((fe) => {
      throw fe;
    }).then(async () => {
      const {
        currentUploads: fe
      } = this.getState(), he = Object.values(fe).flatMap((Ee) => Ee.fileIDs), _e = [];
      Object.keys(re).forEach((Ee) => {
        const Se = this.getFile(Ee);
        !Se.progress.uploadStarted && he.indexOf(Ee) === -1 && _e.push(Se.id);
      });
      const ve = _classPrivateFieldLooseBase$5(this, _createUpload)[_createUpload](_e), xe = await _classPrivateFieldLooseBase$5(this, _runUpload)[_runUpload](ve);
      return this.emit("complete", xe), xe;
    }).catch((fe) => {
      throw this.emit("error", fe), this.log(fe, "error"), fe;
    }));
  }
}
function _informAndEmit2(le) {
  for (const fe of le)
    fe.isRestriction ? this.emit("restriction-failed", fe.file, fe) : this.emit("error", fe, fe.file), this.log(fe, "warning");
  const Y = le.filter((fe) => fe.isUserFacing), re = 4, oe = Y.slice(0, re), ue = Y.slice(re);
  oe.forEach((fe) => {
    let {
      message: he,
      details: _e = ""
    } = fe;
    this.info({
      message: he,
      details: _e
    }, "error", this.opts.infoTimeout);
  }), ue.length > 0 && this.info({
    message: this.i18n("additionalRestrictionsFailed", {
      count: ue.length
    })
  });
}
function _checkRequiredMetaFieldsOnFile2(le) {
  const {
    missingFields: Y,
    error: re
  } = _classPrivateFieldLooseBase$5(this, _restricter)[_restricter].getMissingRequiredMetaFields(le);
  return Y.length > 0 ? (this.setFileState(le.id, {
    missingRequiredMetaFields: Y
  }), this.log(re.message), this.emit("restriction-failed", le, re), !1) : (Y.length === 0 && le.missingRequiredMetaFields && this.setFileState(le.id, {
    missingRequiredMetaFields: []
  }), !0);
}
function _checkRequiredMetaFields2(le) {
  let Y = !0;
  for (const re of Object.values(le))
    _classPrivateFieldLooseBase$5(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](re) || (Y = !1);
  return Y;
}
function _assertNewUploadAllowed2(le) {
  const {
    allowNewUpload: Y
  } = this.getState();
  if (Y === !1) {
    const re = new RestrictionError(this.i18n("noMoreFilesAllowed"), {
      file: le
    });
    throw _classPrivateFieldLooseBase$5(this, _informAndEmit)[_informAndEmit]([re]), re;
  }
}
function _transformFile2(le) {
  const Y = le instanceof File ? {
    name: le.name,
    type: le.type,
    size: le.size,
    data: le
  } : le, re = getFileType(Y), oe = getFileName(re, Y), ue = getFileNameAndExtension(oe).extension, fe = getSafeFileId(Y, this.getID()), he = Y.meta || {};
  he.name = oe, he.type = re;
  const _e = Number.isFinite(Y.data.size) ? Y.data.size : null;
  return {
    source: Y.source || "",
    id: fe,
    name: oe,
    extension: ue || "",
    meta: {
      ...this.getState().meta,
      ...he
    },
    type: re,
    data: Y.data,
    progress: {
      percentage: 0,
      bytesUploaded: !1,
      bytesTotal: _e,
      uploadComplete: !1,
      uploadStarted: null
    },
    size: _e,
    isGhost: !1,
    isRemote: Y.isRemote || !1,
    remote: Y.remote,
    preview: Y.preview
  };
}
function _startIfAutoProceed2() {
  this.opts.autoProceed && !this.scheduledAutoProceed && (this.scheduledAutoProceed = setTimeout(() => {
    this.scheduledAutoProceed = null, this.upload().catch((le) => {
      le.isRestriction || this.log(le.stack || le.message || le);
    });
  }, 4));
}
function _checkAndUpdateFileState2(le) {
  const {
    files: Y
  } = this.getState(), re = {
    ...Y
  }, oe = [], ue = [];
  for (const _e of le)
    try {
      var fe;
      let ve = _classPrivateFieldLooseBase$5(this, _transformFile)[_transformFile](_e);
      const xe = (fe = Y[ve.id]) == null ? void 0 : fe.isGhost;
      xe && (ve = {
        ...Y[ve.id],
        isGhost: !1,
        data: _e.data
      }, this.log(`Replaced the blob in the restored ghost file: ${ve.name}, ${ve.id}`));
      const Ee = this.opts.onBeforeFileAdded(ve, re);
      if (!Ee && this.checkIfFileAlreadyExists(ve.id)) {
        var he;
        throw new RestrictionError(this.i18n("noDuplicates", {
          fileName: (he = ve.name) != null ? he : this.i18n("unnamed")
        }), {
          file: _e
        });
      }
      if (Ee === !1 && !xe)
        throw new RestrictionError("Cannot add the file because onBeforeFileAdded returned false.", {
          isUserFacing: !1,
          file: _e
        });
      typeof Ee == "object" && Ee !== null && (ve = Ee), _classPrivateFieldLooseBase$5(this, _restricter)[_restricter].validateSingleFile(ve), re[ve.id] = ve, oe.push(ve);
    } catch (ve) {
      ue.push(ve);
    }
  try {
    _classPrivateFieldLooseBase$5(this, _restricter)[_restricter].validateAggregateRestrictions(Object.values(Y), oe);
  } catch (_e) {
    return ue.push(_e), {
      nextFilesState: Y,
      validFilesToAdd: [],
      errors: ue
    };
  }
  return {
    nextFilesState: re,
    validFilesToAdd: oe,
    errors: ue
  };
}
function _getFilesToRetry2() {
  const {
    files: le
  } = this.getState();
  return Object.keys(le).filter((Y) => le[Y].error);
}
async function _doRetryAll2() {
  const le = _classPrivateFieldLooseBase$5(this, _getFilesToRetry)[_getFilesToRetry](), Y = {
    ...this.getState().files
  };
  if (le.forEach((oe) => {
    Y[oe] = {
      ...Y[oe],
      isPaused: !1,
      error: null
    };
  }), this.setState({
    files: Y,
    error: null
  }), this.emit("retry-all", this.getFilesByIds(le)), le.length === 0)
    return {
      successful: [],
      failed: []
    };
  const re = _classPrivateFieldLooseBase$5(this, _createUpload)[_createUpload](le, {
    forceAllowNewUpload: !0
    // create new upload even if allowNewUpload: false
  });
  return _classPrivateFieldLooseBase$5(this, _runUpload)[_runUpload](re);
}
function _updateTotalProgress2() {
  const le = _classPrivateFieldLooseBase$5(this, _calculateTotalProgress)[_calculateTotalProgress]();
  let Y = null;
  le != null && (Y = Math.round(le * 100), Y > 100 ? Y = 100 : Y < 0 && (Y = 0)), this.emit("progress", Y ?? 0), this.setState({
    totalProgress: Y ?? 0
  });
}
function _calculateTotalProgress2() {
  const Y = this.getFiles().filter((_e) => _e.progress.uploadStarted || _e.progress.preprocess || _e.progress.postprocess);
  if (Y.length === 0)
    return 0;
  if (Y.every((_e) => _e.progress.uploadComplete))
    return 1;
  const re = (_e) => _e.progress.bytesTotal != null && _e.progress.bytesTotal !== 0, oe = Y.filter(re), ue = Y.filter((_e) => !re(_e));
  if (oe.every((_e) => _e.progress.uploadComplete) && ue.length > 0 && !ue.every((_e) => _e.progress.uploadComplete))
    return null;
  const fe = oe.reduce((_e, ve) => {
    var xe;
    return _e + ((xe = ve.progress.bytesTotal) != null ? xe : 0);
  }, 0), he = oe.reduce((_e, ve) => _e + (ve.progress.bytesUploaded || 0), 0);
  return fe === 0 ? 0 : he / fe;
}
function _addListeners2() {
  const le = (oe, ue, fe) => {
    let he = oe.message || "Unknown error";
    oe.details && (he += ` ${oe.details}`), this.setState({
      error: he
    }), ue != null && ue.id in this.getState().files && this.setFileState(ue.id, {
      error: he,
      response: fe
    });
  };
  this.on("error", le), this.on("upload-error", (oe, ue, fe) => {
    if (le(ue, oe, fe), typeof ue == "object" && ue.message) {
      var he;
      this.log(ue.message, "error");
      const _e = new Error(this.i18n("failedToUpload", {
        file: (he = oe?.name) != null ? he : ""
      }));
      _e.isUserFacing = !0, _e.details = ue.message, ue.details && (_e.details += ` ${ue.details}`), _classPrivateFieldLooseBase$5(this, _informAndEmit)[_informAndEmit]([_e]);
    } else
      _classPrivateFieldLooseBase$5(this, _informAndEmit)[_informAndEmit]([ue]);
  });
  let Y = null;
  this.on("upload-stalled", (oe, ue) => {
    const {
      message: fe
    } = oe, he = ue.map((_e) => _e.meta.name).join(", ");
    Y || (this.info({
      message: fe,
      details: he
    }, "warning", this.opts.infoTimeout), Y = setTimeout(() => {
      Y = null;
    }, this.opts.infoTimeout)), this.log(`${fe} ${he}`.trim(), "warning");
  }), this.on("upload", () => {
    this.setState({
      error: null
    });
  });
  const re = (oe) => {
    const ue = oe.filter((he) => {
      const _e = he != null && this.getFile(he.id);
      return _e || this.log(`Not setting progress for a file that has been removed: ${he?.id}`), _e;
    }), fe = Object.fromEntries(ue.map((he) => [he.id, {
      progress: {
        uploadStarted: Date.now(),
        uploadComplete: !1,
        bytesUploaded: 0,
        bytesTotal: he.size
      }
    }]));
    this.patchFilesState(fe);
  };
  this.on("upload-start", re), this.on("upload-progress", _classPrivateFieldLooseBase$5(this, _handleUploadProgress)[_handleUploadProgress]), this.on("upload-success", (oe, ue) => {
    if (oe == null || !this.getFile(oe.id)) {
      this.log(`Not setting progress for a file that has been removed: ${oe?.id}`);
      return;
    }
    const fe = this.getFile(oe.id).progress;
    this.setFileState(oe.id, {
      progress: {
        ...fe,
        postprocess: _classPrivateFieldLooseBase$5(this, _postProcessors)[_postProcessors].size > 0 ? {
          mode: "indeterminate"
        } : void 0,
        uploadComplete: !0,
        percentage: 100,
        bytesUploaded: fe.bytesTotal
      },
      response: ue,
      uploadURL: ue.uploadURL,
      isPaused: !1
    }), oe.size == null && this.setFileState(oe.id, {
      size: ue.bytesUploaded || fe.bytesTotal
    }), _classPrivateFieldLooseBase$5(this, _updateTotalProgressThrottled)[_updateTotalProgressThrottled]();
  }), this.on("preprocess-progress", (oe, ue) => {
    if (oe == null || !this.getFile(oe.id)) {
      this.log(`Not setting progress for a file that has been removed: ${oe?.id}`);
      return;
    }
    this.setFileState(oe.id, {
      progress: {
        ...this.getFile(oe.id).progress,
        preprocess: ue
      }
    });
  }), this.on("preprocess-complete", (oe) => {
    if (oe == null || !this.getFile(oe.id)) {
      this.log(`Not setting progress for a file that has been removed: ${oe?.id}`);
      return;
    }
    const ue = {
      ...this.getState().files
    };
    ue[oe.id] = {
      ...ue[oe.id],
      progress: {
        ...ue[oe.id].progress
      }
    }, delete ue[oe.id].progress.preprocess, this.setState({
      files: ue
    });
  }), this.on("postprocess-progress", (oe, ue) => {
    if (oe == null || !this.getFile(oe.id)) {
      this.log(`Not setting progress for a file that has been removed: ${oe?.id}`);
      return;
    }
    this.setFileState(oe.id, {
      progress: {
        ...this.getState().files[oe.id].progress,
        postprocess: ue
      }
    });
  }), this.on("postprocess-complete", (oe) => {
    if (oe == null || !this.getFile(oe.id)) {
      this.log(`Not setting progress for a file that has been removed: ${oe?.id}`);
      return;
    }
    const ue = {
      ...this.getState().files
    };
    ue[oe.id] = {
      ...ue[oe.id],
      progress: {
        ...ue[oe.id].progress
      }
    }, delete ue[oe.id].progress.postprocess, this.setState({
      files: ue
    });
  }), this.on("restored", () => {
    _classPrivateFieldLooseBase$5(this, _updateTotalProgressThrottled)[_updateTotalProgressThrottled]();
  }), this.on("dashboard:file-edit-complete", (oe) => {
    oe && _classPrivateFieldLooseBase$5(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](oe);
  }), typeof window < "u" && window.addEventListener && (window.addEventListener("online", _classPrivateFieldLooseBase$5(this, _updateOnlineStatus)[_updateOnlineStatus]), window.addEventListener("offline", _classPrivateFieldLooseBase$5(this, _updateOnlineStatus)[_updateOnlineStatus]), setTimeout(_classPrivateFieldLooseBase$5(this, _updateOnlineStatus)[_updateOnlineStatus], 3e3));
}
function _createUpload2(le, Y) {
  Y === void 0 && (Y = {});
  const {
    forceAllowNewUpload: re = !1
  } = Y, {
    allowNewUpload: oe,
    currentUploads: ue
  } = this.getState();
  if (!oe && !re)
    throw new Error("Cannot create a new upload: already uploading.");
  const fe = nanoid();
  return this.emit("upload", fe, this.getFilesByIds(le)), this.setState({
    allowNewUpload: this.opts.allowMultipleUploadBatches !== !1 && this.opts.allowMultipleUploads !== !1,
    currentUploads: {
      ...ue,
      [fe]: {
        fileIDs: le,
        step: 0,
        result: {}
      }
    }
  }), fe;
}
function _getUpload2(le) {
  const {
    currentUploads: Y
  } = this.getState();
  return Y[le];
}
function _removeUpload2(le) {
  const Y = {
    ...this.getState().currentUploads
  };
  delete Y[le], this.setState({
    currentUploads: Y
  });
}
async function _runUpload2(le) {
  const Y = () => {
    const {
      currentUploads: fe
    } = this.getState();
    return fe[le];
  };
  let re = Y();
  const oe = [..._classPrivateFieldLooseBase$5(this, _preProcessors)[_preProcessors], ..._classPrivateFieldLooseBase$5(this, _uploaders)[_uploaders], ..._classPrivateFieldLooseBase$5(this, _postProcessors)[_postProcessors]];
  try {
    for (let fe = re.step || 0; fe < oe.length && re; fe++) {
      const he = oe[fe];
      this.setState({
        currentUploads: {
          ...this.getState().currentUploads,
          [le]: {
            ...re,
            step: fe
          }
        }
      });
      const {
        fileIDs: _e
      } = re;
      await he(_e, le), re = Y();
    }
  } catch (fe) {
    throw _classPrivateFieldLooseBase$5(this, _removeUpload)[_removeUpload](le), fe;
  }
  if (re) {
    re.fileIDs.forEach((ve) => {
      const xe = this.getFile(ve);
      xe && xe.progress.postprocess && this.emit("postprocess-complete", xe);
    });
    const fe = re.fileIDs.map((ve) => this.getFile(ve)), he = fe.filter((ve) => !ve.error), _e = fe.filter((ve) => ve.error);
    this.addResultData(le, {
      successful: he,
      failed: _e,
      uploadID: le
    }), re = Y();
  }
  let ue;
  return re && (ue = re.result, _classPrivateFieldLooseBase$5(this, _removeUpload)[_removeUpload](le)), ue == null && (this.log(`Not setting result for an upload that has been removed: ${le}`), ue = {
    successful: [],
    failed: [],
    uploadID: le
  }), ue;
}
Uppy.VERSION = packageJson$5.version;
var n$1, l$2, u$2, i$2, r$2, o$2, e$2, f$2, c$2, s$2, a$2, p$2 = {}, v$2 = [], y$2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, w$2 = Array.isArray;
function d$2(le, Y) {
  for (var re in Y) le[re] = Y[re];
  return le;
}
function g$2(le) {
  le && le.parentNode && le.parentNode.removeChild(le);
}
function _$1(le, Y, re) {
  var oe, ue, fe, he = {};
  for (fe in Y) fe == "key" ? oe = Y[fe] : fe == "ref" ? ue = Y[fe] : he[fe] = Y[fe];
  if (arguments.length > 2 && (he.children = arguments.length > 3 ? n$1.call(arguments, 2) : re), typeof le == "function" && le.defaultProps != null) for (fe in le.defaultProps) he[fe] === void 0 && (he[fe] = le.defaultProps[fe]);
  return m$2(le, he, oe, ue, null);
}
function m$2(le, Y, re, oe, ue) {
  var fe = { type: le, props: Y, key: re, ref: oe, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: ue ?? ++u$2, __i: -1, __u: 0 };
  return ue == null && l$2.vnode != null && l$2.vnode(fe), fe;
}
function b$1() {
  return { current: null };
}
function k$2(le) {
  return le.children;
}
function x(le, Y) {
  this.props = le, this.context = Y;
}
function S$1(le, Y) {
  if (Y == null) return le.__ ? S$1(le.__, le.__i + 1) : null;
  for (var re; Y < le.__k.length; Y++) if ((re = le.__k[Y]) != null && re.__e != null) return re.__e;
  return typeof le.type == "function" ? S$1(le) : null;
}
function C$1(le) {
  var Y, re;
  if ((le = le.__) != null && le.__c != null) {
    for (le.__e = le.__c.base = null, Y = 0; Y < le.__k.length; Y++) if ((re = le.__k[Y]) != null && re.__e != null) {
      le.__e = le.__c.base = re.__e;
      break;
    }
    return C$1(le);
  }
}
function M$1(le) {
  (!le.__d && (le.__d = !0) && i$2.push(le) && !$$2.__r++ || r$2 != l$2.debounceRendering) && ((r$2 = l$2.debounceRendering) || o$2)($$2);
}
function $$2() {
  for (var le, Y, re, oe, ue, fe, he, _e = 1; i$2.length; ) i$2.length > _e && i$2.sort(e$2), le = i$2.shift(), _e = i$2.length, le.__d && (re = void 0, ue = (oe = (Y = le).__v).__e, fe = [], he = [], Y.__P && ((re = d$2({}, oe)).__v = oe.__v + 1, l$2.vnode && l$2.vnode(re), O$1(Y.__P, re, oe, Y.__n, Y.__P.namespaceURI, 32 & oe.__u ? [ue] : null, fe, ue ?? S$1(oe), !!(32 & oe.__u), he), re.__v = oe.__v, re.__.__k[re.__i] = re, z$2(fe, re, he), re.__e != ue && C$1(re)));
  $$2.__r = 0;
}
function I$1(le, Y, re, oe, ue, fe, he, _e, ve, xe, Ee) {
  var Se, Te, Ce, Ie, Ne, Re, Ae = oe && oe.__k || v$2, Pe = Y.length;
  for (ve = P$2(re, Y, Ae, ve, Pe), Se = 0; Se < Pe; Se++) (Ce = re.__k[Se]) != null && (Te = Ce.__i == -1 ? p$2 : Ae[Ce.__i] || p$2, Ce.__i = Se, Re = O$1(le, Ce, Te, ue, fe, he, _e, ve, xe, Ee), Ie = Ce.__e, Ce.ref && Te.ref != Ce.ref && (Te.ref && q$3(Te.ref, null, Ce), Ee.push(Ce.ref, Ce.__c || Ie, Ce)), Ne == null && Ie != null && (Ne = Ie), 4 & Ce.__u || Te.__k === Ce.__k ? ve = A$2(Ce, ve, le) : typeof Ce.type == "function" && Re !== void 0 ? ve = Re : Ie && (ve = Ie.nextSibling), Ce.__u &= -7);
  return re.__e = Ne, ve;
}
function P$2(le, Y, re, oe, ue) {
  var fe, he, _e, ve, xe, Ee = re.length, Se = Ee, Te = 0;
  for (le.__k = new Array(ue), fe = 0; fe < ue; fe++) (he = Y[fe]) != null && typeof he != "boolean" && typeof he != "function" ? (ve = fe + Te, (he = le.__k[fe] = typeof he == "string" || typeof he == "number" || typeof he == "bigint" || he.constructor == String ? m$2(null, he, null, null, null) : w$2(he) ? m$2(k$2, { children: he }, null, null, null) : he.constructor == null && he.__b > 0 ? m$2(he.type, he.props, he.key, he.ref ? he.ref : null, he.__v) : he).__ = le, he.__b = le.__b + 1, _e = null, (xe = he.__i = L$1(he, re, ve, Se)) != -1 && (Se--, (_e = re[xe]) && (_e.__u |= 2)), _e == null || _e.__v == null ? (xe == -1 && (ue > Ee ? Te-- : ue < Ee && Te++), typeof he.type != "function" && (he.__u |= 4)) : xe != ve && (xe == ve - 1 ? Te-- : xe == ve + 1 ? Te++ : (xe > ve ? Te-- : Te++, he.__u |= 4))) : le.__k[fe] = null;
  if (Se) for (fe = 0; fe < Ee; fe++) (_e = re[fe]) != null && (2 & _e.__u) == 0 && (_e.__e == oe && (oe = S$1(_e)), B$3(_e, _e));
  return oe;
}
function A$2(le, Y, re) {
  var oe, ue;
  if (typeof le.type == "function") {
    for (oe = le.__k, ue = 0; oe && ue < oe.length; ue++) oe[ue] && (oe[ue].__ = le, Y = A$2(oe[ue], Y, re));
    return Y;
  }
  le.__e != Y && (Y && le.type && !re.contains(Y) && (Y = S$1(le)), re.insertBefore(le.__e, Y || null), Y = le.__e);
  do
    Y = Y && Y.nextSibling;
  while (Y != null && Y.nodeType == 8);
  return Y;
}
function H$2(le, Y) {
  return Y = Y || [], le == null || typeof le == "boolean" || (w$2(le) ? le.some(function(re) {
    H$2(re, Y);
  }) : Y.push(le)), Y;
}
function L$1(le, Y, re, oe) {
  var ue, fe, he = le.key, _e = le.type, ve = Y[re];
  if (ve === null && le.key == null || ve && he == ve.key && _e == ve.type && (2 & ve.__u) == 0) return re;
  if (oe > (ve != null && (2 & ve.__u) == 0 ? 1 : 0)) for (ue = re - 1, fe = re + 1; ue >= 0 || fe < Y.length; ) {
    if (ue >= 0) {
      if ((ve = Y[ue]) && (2 & ve.__u) == 0 && he == ve.key && _e == ve.type) return ue;
      ue--;
    }
    if (fe < Y.length) {
      if ((ve = Y[fe]) && (2 & ve.__u) == 0 && he == ve.key && _e == ve.type) return fe;
      fe++;
    }
  }
  return -1;
}
function T$3(le, Y, re) {
  Y[0] == "-" ? le.setProperty(Y, re ?? "") : le[Y] = re == null ? "" : typeof re != "number" || y$2.test(Y) ? re : re + "px";
}
function j$3(le, Y, re, oe, ue) {
  var fe, he;
  e: if (Y == "style") if (typeof re == "string") le.style.cssText = re;
  else {
    if (typeof oe == "string" && (le.style.cssText = oe = ""), oe) for (Y in oe) re && Y in re || T$3(le.style, Y, "");
    if (re) for (Y in re) oe && re[Y] == oe[Y] || T$3(le.style, Y, re[Y]);
  }
  else if (Y[0] == "o" && Y[1] == "n") fe = Y != (Y = Y.replace(f$2, "$1")), he = Y.toLowerCase(), Y = he in le || Y == "onFocusOut" || Y == "onFocusIn" ? he.slice(2) : Y.slice(2), le.l || (le.l = {}), le.l[Y + fe] = re, re ? oe ? re.u = oe.u : (re.u = c$2, le.addEventListener(Y, fe ? a$2 : s$2, fe)) : le.removeEventListener(Y, fe ? a$2 : s$2, fe);
  else {
    if (ue == "http://www.w3.org/2000/svg") Y = Y.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if (Y != "width" && Y != "height" && Y != "href" && Y != "list" && Y != "form" && Y != "tabIndex" && Y != "download" && Y != "rowSpan" && Y != "colSpan" && Y != "role" && Y != "popover" && Y in le) try {
      le[Y] = re ?? "";
      break e;
    } catch {
    }
    typeof re == "function" || (re == null || re === !1 && Y[4] != "-" ? le.removeAttribute(Y) : le.setAttribute(Y, Y == "popover" && re == 1 ? "" : re));
  }
}
function F$2(le) {
  return function(Y) {
    if (this.l) {
      var re = this.l[Y.type + le];
      if (Y.t == null) Y.t = c$2++;
      else if (Y.t < re.u) return;
      return re(l$2.event ? l$2.event(Y) : Y);
    }
  };
}
function O$1(le, Y, re, oe, ue, fe, he, _e, ve, xe) {
  var Ee, Se, Te, Ce, Ie, Ne, Re, Ae, Pe, Fe, Le, He, Ge, Ve, $e, De, Ke, ze = Y.type;
  if (Y.constructor != null) return null;
  128 & re.__u && (ve = !!(32 & re.__u), fe = [_e = Y.__e = re.__e]), (Ee = l$2.__b) && Ee(Y);
  e: if (typeof ze == "function") try {
    if (Ae = Y.props, Pe = "prototype" in ze && ze.prototype.render, Fe = (Ee = ze.contextType) && oe[Ee.__c], Le = Ee ? Fe ? Fe.props.value : Ee.__ : oe, re.__c ? Re = (Se = Y.__c = re.__c).__ = Se.__E : (Pe ? Y.__c = Se = new ze(Ae, Le) : (Y.__c = Se = new x(Ae, Le), Se.constructor = ze, Se.render = D$2), Fe && Fe.sub(Se), Se.props = Ae, Se.state || (Se.state = {}), Se.context = Le, Se.__n = oe, Te = Se.__d = !0, Se.__h = [], Se._sb = []), Pe && Se.__s == null && (Se.__s = Se.state), Pe && ze.getDerivedStateFromProps != null && (Se.__s == Se.state && (Se.__s = d$2({}, Se.__s)), d$2(Se.__s, ze.getDerivedStateFromProps(Ae, Se.__s))), Ce = Se.props, Ie = Se.state, Se.__v = Y, Te) Pe && ze.getDerivedStateFromProps == null && Se.componentWillMount != null && Se.componentWillMount(), Pe && Se.componentDidMount != null && Se.__h.push(Se.componentDidMount);
    else {
      if (Pe && ze.getDerivedStateFromProps == null && Ae !== Ce && Se.componentWillReceiveProps != null && Se.componentWillReceiveProps(Ae, Le), !Se.__e && Se.shouldComponentUpdate != null && Se.shouldComponentUpdate(Ae, Se.__s, Le) === !1 || Y.__v == re.__v) {
        for (Y.__v != re.__v && (Se.props = Ae, Se.state = Se.__s, Se.__d = !1), Y.__e = re.__e, Y.__k = re.__k, Y.__k.some(function(tt) {
          tt && (tt.__ = Y);
        }), He = 0; He < Se._sb.length; He++) Se.__h.push(Se._sb[He]);
        Se._sb = [], Se.__h.length && he.push(Se);
        break e;
      }
      Se.componentWillUpdate != null && Se.componentWillUpdate(Ae, Se.__s, Le), Pe && Se.componentDidUpdate != null && Se.__h.push(function() {
        Se.componentDidUpdate(Ce, Ie, Ne);
      });
    }
    if (Se.context = Le, Se.props = Ae, Se.__P = le, Se.__e = !1, Ge = l$2.__r, Ve = 0, Pe) {
      for (Se.state = Se.__s, Se.__d = !1, Ge && Ge(Y), Ee = Se.render(Se.props, Se.state, Se.context), $e = 0; $e < Se._sb.length; $e++) Se.__h.push(Se._sb[$e]);
      Se._sb = [];
    } else do
      Se.__d = !1, Ge && Ge(Y), Ee = Se.render(Se.props, Se.state, Se.context), Se.state = Se.__s;
    while (Se.__d && ++Ve < 25);
    Se.state = Se.__s, Se.getChildContext != null && (oe = d$2(d$2({}, oe), Se.getChildContext())), Pe && !Te && Se.getSnapshotBeforeUpdate != null && (Ne = Se.getSnapshotBeforeUpdate(Ce, Ie)), De = Ee, Ee != null && Ee.type === k$2 && Ee.key == null && (De = N$2(Ee.props.children)), _e = I$1(le, w$2(De) ? De : [De], Y, re, oe, ue, fe, he, _e, ve, xe), Se.base = Y.__e, Y.__u &= -161, Se.__h.length && he.push(Se), Re && (Se.__E = Se.__ = null);
  } catch (tt) {
    if (Y.__v = null, ve || fe != null) if (tt.then) {
      for (Y.__u |= ve ? 160 : 128; _e && _e.nodeType == 8 && _e.nextSibling; ) _e = _e.nextSibling;
      fe[fe.indexOf(_e)] = null, Y.__e = _e;
    } else for (Ke = fe.length; Ke--; ) g$2(fe[Ke]);
    else Y.__e = re.__e, Y.__k = re.__k;
    l$2.__e(tt, Y, re);
  }
  else fe == null && Y.__v == re.__v ? (Y.__k = re.__k, Y.__e = re.__e) : _e = Y.__e = V$2(re.__e, Y, re, oe, ue, fe, he, ve, xe);
  return (Ee = l$2.diffed) && Ee(Y), 128 & Y.__u ? void 0 : _e;
}
function z$2(le, Y, re) {
  for (var oe = 0; oe < re.length; oe++) q$3(re[oe], re[++oe], re[++oe]);
  l$2.__c && l$2.__c(Y, le), le.some(function(ue) {
    try {
      le = ue.__h, ue.__h = [], le.some(function(fe) {
        fe.call(ue);
      });
    } catch (fe) {
      l$2.__e(fe, ue.__v);
    }
  });
}
function N$2(le) {
  return typeof le != "object" || le == null || le.__b && le.__b > 0 ? le : w$2(le) ? le.map(N$2) : d$2({}, le);
}
function V$2(le, Y, re, oe, ue, fe, he, _e, ve) {
  var xe, Ee, Se, Te, Ce, Ie, Ne, Re = re.props, Ae = Y.props, Pe = Y.type;
  if (Pe == "svg" ? ue = "http://www.w3.org/2000/svg" : Pe == "math" ? ue = "http://www.w3.org/1998/Math/MathML" : ue || (ue = "http://www.w3.org/1999/xhtml"), fe != null) {
    for (xe = 0; xe < fe.length; xe++) if ((Ce = fe[xe]) && "setAttribute" in Ce == !!Pe && (Pe ? Ce.localName == Pe : Ce.nodeType == 3)) {
      le = Ce, fe[xe] = null;
      break;
    }
  }
  if (le == null) {
    if (Pe == null) return document.createTextNode(Ae);
    le = document.createElementNS(ue, Pe, Ae.is && Ae), _e && (l$2.__m && l$2.__m(Y, fe), _e = !1), fe = null;
  }
  if (Pe == null) Re === Ae || _e && le.data == Ae || (le.data = Ae);
  else {
    if (fe = fe && n$1.call(le.childNodes), Re = re.props || p$2, !_e && fe != null) for (Re = {}, xe = 0; xe < le.attributes.length; xe++) Re[(Ce = le.attributes[xe]).name] = Ce.value;
    for (xe in Re) if (Ce = Re[xe], xe != "children") {
      if (xe == "dangerouslySetInnerHTML") Se = Ce;
      else if (!(xe in Ae)) {
        if (xe == "value" && "defaultValue" in Ae || xe == "checked" && "defaultChecked" in Ae) continue;
        j$3(le, xe, null, Ce, ue);
      }
    }
    for (xe in Ae) Ce = Ae[xe], xe == "children" ? Te = Ce : xe == "dangerouslySetInnerHTML" ? Ee = Ce : xe == "value" ? Ie = Ce : xe == "checked" ? Ne = Ce : _e && typeof Ce != "function" || Re[xe] === Ce || j$3(le, xe, Ce, Re[xe], ue);
    if (Ee) _e || Se && (Ee.__html == Se.__html || Ee.__html == le.innerHTML) || (le.innerHTML = Ee.__html), Y.__k = [];
    else if (Se && (le.innerHTML = ""), I$1(Y.type == "template" ? le.content : le, w$2(Te) ? Te : [Te], Y, re, oe, Pe == "foreignObject" ? "http://www.w3.org/1999/xhtml" : ue, fe, he, fe ? fe[0] : re.__k && S$1(re, 0), _e, ve), fe != null) for (xe = fe.length; xe--; ) g$2(fe[xe]);
    _e || (xe = "value", Pe == "progress" && Ie == null ? le.removeAttribute("value") : Ie != null && (Ie !== le[xe] || Pe == "progress" && !Ie || Pe == "option" && Ie != Re[xe]) && j$3(le, xe, Ie, Re[xe], ue), xe = "checked", Ne != null && Ne != le[xe] && j$3(le, xe, Ne, Re[xe], ue));
  }
  return le;
}
function q$3(le, Y, re) {
  try {
    if (typeof le == "function") {
      var oe = typeof le.__u == "function";
      oe && le.__u(), oe && Y == null || (le.__u = le(Y));
    } else le.current = Y;
  } catch (ue) {
    l$2.__e(ue, re);
  }
}
function B$3(le, Y, re) {
  var oe, ue;
  if (l$2.unmount && l$2.unmount(le), (oe = le.ref) && (oe.current && oe.current != le.__e || q$3(oe, null, Y)), (oe = le.__c) != null) {
    if (oe.componentWillUnmount) try {
      oe.componentWillUnmount();
    } catch (fe) {
      l$2.__e(fe, Y);
    }
    oe.base = oe.__P = null;
  }
  if (oe = le.__k) for (ue = 0; ue < oe.length; ue++) oe[ue] && B$3(oe[ue], Y, re || typeof le.type != "function");
  re || g$2(le.__e), le.__c = le.__ = le.__e = void 0;
}
function D$2(le, Y, re) {
  return this.constructor(le, re);
}
function E$2(le, Y, re) {
  var oe, ue, fe, he;
  Y == document && (Y = document.documentElement), l$2.__ && l$2.__(le, Y), ue = (oe = !1) ? null : Y.__k, fe = [], he = [], O$1(Y, le = Y.__k = _$1(k$2, null, [le]), ue || p$2, p$2, Y.namespaceURI, ue ? null : Y.firstChild ? n$1.call(Y.childNodes) : null, fe, ue ? ue.__e : Y.firstChild, oe, he), z$2(fe, le, he);
}
function J$2(le, Y, re) {
  var oe, ue, fe, he, _e = d$2({}, le.props);
  for (fe in le.type && le.type.defaultProps && (he = le.type.defaultProps), Y) fe == "key" ? oe = Y[fe] : fe == "ref" ? ue = Y[fe] : _e[fe] = Y[fe] === void 0 && he != null ? he[fe] : Y[fe];
  return arguments.length > 2 && (_e.children = arguments.length > 3 ? n$1.call(arguments, 2) : re), m$2(le.type, _e, oe || le.key, ue || le.ref, null);
}
n$1 = v$2.slice, l$2 = { __e: function(le, Y, re, oe) {
  for (var ue, fe, he; Y = Y.__; ) if ((ue = Y.__c) && !ue.__) try {
    if ((fe = ue.constructor) && fe.getDerivedStateFromError != null && (ue.setState(fe.getDerivedStateFromError(le)), he = ue.__d), ue.componentDidCatch != null && (ue.componentDidCatch(le, oe || {}), he = ue.__d), he) return ue.__E = ue;
  } catch (_e) {
    le = _e;
  }
  throw le;
} }, u$2 = 0, x.prototype.setState = function(le, Y) {
  var re;
  re = this.__s != null && this.__s != this.state ? this.__s : this.__s = d$2({}, this.state), typeof le == "function" && (le = le(d$2({}, re), this.props)), le && d$2(re, le), le != null && this.__v && (Y && this._sb.push(Y), M$1(this));
}, x.prototype.forceUpdate = function(le) {
  this.__v && (this.__e = !0, le && this.__h.push(le), M$1(this));
}, x.prototype.render = k$2, i$2 = [], o$2 = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e$2 = function(le, Y) {
  return le.__v.__b - Y.__v.__b;
}, $$2.__r = 0, f$2 = /(PointerCapture)$|Capture$/i, c$2 = 0, s$2 = F$2(!1), a$2 = F$2(!0);
var t$1, r$1, u$1, i$1, o$1 = 0, f$1 = [], c$1 = l$2, e$1 = c$1.__b, a$1 = c$1.__r, v$1 = c$1.diffed, l$1 = c$1.__c, m$1 = c$1.unmount, s$1 = c$1.__;
function p$1(le, Y) {
  c$1.__h && c$1.__h(r$1, le, o$1 || Y), o$1 = 0;
  var re = r$1.__H || (r$1.__H = { __: [], __h: [] });
  return le >= re.__.length && re.__.push({}), re.__[le];
}
function d$1(le) {
  return o$1 = 1, h$1(D$1, le);
}
function h$1(le, Y, re) {
  var oe = p$1(t$1++, 2);
  if (oe.t = le, !oe.__c && (oe.__ = [re ? re(Y) : D$1(void 0, Y), function(_e) {
    var ve = oe.__N ? oe.__N[0] : oe.__[0], xe = oe.t(ve, _e);
    ve !== xe && (oe.__N = [xe, oe.__[1]], oe.__c.setState({}));
  }], oe.__c = r$1, !r$1.__f)) {
    var ue = function(_e, ve, xe) {
      if (!oe.__c.__H) return !0;
      var Ee = oe.__c.__H.__.filter(function(Te) {
        return !!Te.__c;
      });
      if (Ee.every(function(Te) {
        return !Te.__N;
      })) return !fe || fe.call(this, _e, ve, xe);
      var Se = oe.__c.props !== _e;
      return Ee.forEach(function(Te) {
        if (Te.__N) {
          var Ce = Te.__[0];
          Te.__ = Te.__N, Te.__N = void 0, Ce !== Te.__[0] && (Se = !0);
        }
      }), fe && fe.call(this, _e, ve, xe) || Se;
    };
    r$1.__f = !0;
    var fe = r$1.shouldComponentUpdate, he = r$1.componentWillUpdate;
    r$1.componentWillUpdate = function(_e, ve, xe) {
      if (this.__e) {
        var Ee = fe;
        fe = void 0, ue(_e, ve, xe), fe = Ee;
      }
      he && he.call(this, _e, ve, xe);
    }, r$1.shouldComponentUpdate = ue;
  }
  return oe.__N || oe.__;
}
function y$1(le, Y) {
  var re = p$1(t$1++, 3);
  !c$1.__s && C(re.__H, Y) && (re.__ = le, re.u = Y, r$1.__H.__h.push(re));
}
function A$1(le) {
  return o$1 = 5, T$2(function() {
    return { current: le };
  }, []);
}
function T$2(le, Y) {
  var re = p$1(t$1++, 7);
  return C(re.__H, Y) && (re.__ = le(), re.__H = Y, re.__h = le), re.__;
}
function q$2(le, Y) {
  return o$1 = 8, T$2(function() {
    return le;
  }, Y);
}
function j$2() {
  for (var le; le = f$1.shift(); ) if (le.__P && le.__H) try {
    le.__H.__h.forEach(z$1), le.__H.__h.forEach(B$2), le.__H.__h = [];
  } catch (Y) {
    le.__H.__h = [], c$1.__e(Y, le.__v);
  }
}
c$1.__b = function(le) {
  r$1 = null, e$1 && e$1(le);
}, c$1.__ = function(le, Y) {
  le && Y.__k && Y.__k.__m && (le.__m = Y.__k.__m), s$1 && s$1(le, Y);
}, c$1.__r = function(le) {
  a$1 && a$1(le), t$1 = 0;
  var Y = (r$1 = le.__c).__H;
  Y && (u$1 === r$1 ? (Y.__h = [], r$1.__h = [], Y.__.forEach(function(re) {
    re.__N && (re.__ = re.__N), re.u = re.__N = void 0;
  })) : (Y.__h.forEach(z$1), Y.__h.forEach(B$2), Y.__h = [], t$1 = 0)), u$1 = r$1;
}, c$1.diffed = function(le) {
  v$1 && v$1(le);
  var Y = le.__c;
  Y && Y.__H && (Y.__H.__h.length && (f$1.push(Y) !== 1 && i$1 === c$1.requestAnimationFrame || ((i$1 = c$1.requestAnimationFrame) || w$1)(j$2)), Y.__H.__.forEach(function(re) {
    re.u && (re.__H = re.u), re.u = void 0;
  })), u$1 = r$1 = null;
}, c$1.__c = function(le, Y) {
  Y.some(function(re) {
    try {
      re.__h.forEach(z$1), re.__h = re.__h.filter(function(oe) {
        return !oe.__ || B$2(oe);
      });
    } catch (oe) {
      Y.some(function(ue) {
        ue.__h && (ue.__h = []);
      }), Y = [], c$1.__e(oe, re.__v);
    }
  }), l$1 && l$1(le, Y);
}, c$1.unmount = function(le) {
  m$1 && m$1(le);
  var Y, re = le.__c;
  re && re.__H && (re.__H.__.forEach(function(oe) {
    try {
      z$1(oe);
    } catch (ue) {
      Y = ue;
    }
  }), re.__H = void 0, Y && c$1.__e(Y, re.__v));
};
var k$1 = typeof requestAnimationFrame == "function";
function w$1(le) {
  var Y, re = function() {
    clearTimeout(oe), k$1 && cancelAnimationFrame(Y), setTimeout(le);
  }, oe = setTimeout(re, 35);
  k$1 && (Y = requestAnimationFrame(re));
}
function z$1(le) {
  var Y = r$1, re = le.__c;
  typeof re == "function" && (le.__c = void 0, re()), r$1 = Y;
}
function B$2(le) {
  var Y = r$1;
  le.__c = le.__(), r$1 = Y;
}
function C(le, Y) {
  return !le || le.length !== Y.length || Y.some(function(re, oe) {
    return re !== le[oe];
  });
}
function D$1(le, Y) {
  return typeof Y == "function" ? Y(le) : Y;
}
function g$1(le, Y) {
  for (var re in Y) le[re] = Y[re];
  return le;
}
function E$1(le, Y) {
  for (var re in le) if (re !== "__source" && !(re in Y)) return !0;
  for (var oe in Y) if (oe !== "__source" && le[oe] !== Y[oe]) return !0;
  return !1;
}
function N$1(le, Y) {
  this.props = le, this.context = Y;
}
(N$1.prototype = new x()).isPureReactComponent = !0, N$1.prototype.shouldComponentUpdate = function(le, Y) {
  return E$1(this.props, le) || E$1(this.state, Y);
};
var T$1 = l$2.__b;
l$2.__b = function(le) {
  le.type && le.type.__f && le.ref && (le.props.ref = le.ref, le.ref = null), T$1 && T$1(le);
};
var F$1 = l$2.__e;
l$2.__e = function(le, Y, re, oe) {
  if (le.then) {
    for (var ue, fe = Y; fe = fe.__; ) if ((ue = fe.__c) && ue.__c) return Y.__e == null && (Y.__e = re.__e, Y.__k = re.__k), ue.__c(le, Y);
  }
  F$1(le, Y, re, oe);
};
var U = l$2.unmount;
function V$1(le, Y, re) {
  return le && (le.__c && le.__c.__H && (le.__c.__H.__.forEach(function(oe) {
    typeof oe.__c == "function" && oe.__c();
  }), le.__c.__H = null), (le = g$1({}, le)).__c != null && (le.__c.__P === re && (le.__c.__P = Y), le.__c.__e = !0, le.__c = null), le.__k = le.__k && le.__k.map(function(oe) {
    return V$1(oe, Y, re);
  })), le;
}
function W$1(le, Y, re) {
  return le && re && (le.__v = null, le.__k = le.__k && le.__k.map(function(oe) {
    return W$1(oe, Y, re);
  }), le.__c && le.__c.__P === Y && (le.__e && re.appendChild(le.__e), le.__c.__e = !0, le.__c.__P = re)), le;
}
function P$1() {
  this.__u = 0, this.o = null, this.__b = null;
}
function j$1(le) {
  var Y = le.__.__c;
  return Y && Y.__a && Y.__a(le);
}
function B$1() {
  this.i = null, this.l = null;
}
l$2.unmount = function(le) {
  var Y = le.__c;
  Y && Y.__R && Y.__R(), Y && 32 & le.__u && (le.type = null), U && U(le);
}, (P$1.prototype = new x()).__c = function(le, Y) {
  var re = Y.__c, oe = this;
  oe.o == null && (oe.o = []), oe.o.push(re);
  var ue = j$1(oe.__v), fe = !1, he = function() {
    fe || (fe = !0, re.__R = null, ue ? ue(_e) : _e());
  };
  re.__R = he;
  var _e = function() {
    if (!--oe.__u) {
      if (oe.state.__a) {
        var ve = oe.state.__a;
        oe.__v.__k[0] = W$1(ve, ve.__c.__P, ve.__c.__O);
      }
      var xe;
      for (oe.setState({ __a: oe.__b = null }); xe = oe.o.pop(); ) xe.forceUpdate();
    }
  };
  oe.__u++ || 32 & Y.__u || oe.setState({ __a: oe.__b = oe.__v.__k[0] }), le.then(he, he);
}, P$1.prototype.componentWillUnmount = function() {
  this.o = [];
}, P$1.prototype.render = function(le, Y) {
  if (this.__b) {
    if (this.__v.__k) {
      var re = document.createElement("div"), oe = this.__v.__k[0].__c;
      this.__v.__k[0] = V$1(this.__b, re, oe.__O = oe.__P);
    }
    this.__b = null;
  }
  var ue = Y.__a && _$1(k$2, null, le.fallback);
  return ue && (ue.__u &= -33), [_$1(k$2, null, Y.__a ? null : le.children), ue];
};
var H$1 = function(le, Y, re) {
  if (++re[1] === re[0] && le.l.delete(Y), le.props.revealOrder && (le.props.revealOrder[0] !== "t" || !le.l.size)) for (re = le.i; re; ) {
    for (; re.length > 3; ) re.pop()();
    if (re[1] < re[0]) break;
    le.i = re = re[2];
  }
};
(B$1.prototype = new x()).__a = function(le) {
  var Y = this, re = j$1(Y.__v), oe = Y.l.get(le);
  return oe[0]++, function(ue) {
    var fe = function() {
      Y.props.revealOrder ? (oe.push(ue), H$1(Y, le, oe)) : ue();
    };
    re ? re(fe) : fe();
  };
}, B$1.prototype.render = function(le) {
  this.i = null, this.l = /* @__PURE__ */ new Map();
  var Y = H$2(le.children);
  le.revealOrder && le.revealOrder[0] === "b" && Y.reverse();
  for (var re = Y.length; re--; ) this.l.set(Y[re], this.i = [1, 0, this.i]);
  return le.children;
}, B$1.prototype.componentDidUpdate = B$1.prototype.componentDidMount = function() {
  var le = this;
  this.l.forEach(function(Y, re) {
    H$1(le, re, Y);
  });
};
var q$1 = typeof Symbol < "u" && Symbol.for && Symbol.for("react.element") || 60103, G = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, J$1 = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, K$1 = /[A-Z0-9]/g, Q$1 = typeof document < "u", X$1 = function(le) {
  return (typeof Symbol < "u" && typeof Symbol() == "symbol" ? /fil|che|rad/ : /fil|che|ra/).test(le);
};
function nn(le, Y, re) {
  return Y.__k == null && (Y.textContent = ""), E$2(le, Y), typeof re == "function" && re(), le ? le.__c : null;
}
x.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(le) {
  Object.defineProperty(x.prototype, le, { configurable: !0, get: function() {
    return this["UNSAFE_" + le];
  }, set: function(Y) {
    Object.defineProperty(this, le, { configurable: !0, writable: !0, value: Y });
  } });
});
var en = l$2.event;
function rn() {
}
function un() {
  return this.cancelBubble;
}
function on() {
  return this.defaultPrevented;
}
l$2.event = function(le) {
  return en && (le = en(le)), le.persist = rn, le.isPropagationStopped = un, le.isDefaultPrevented = on, le.nativeEvent = le;
};
var cn = { enumerable: !1, configurable: !0, get: function() {
  return this.class;
} }, fn = l$2.vnode;
l$2.vnode = function(le) {
  typeof le.type == "string" && function(Y) {
    var re = Y.props, oe = Y.type, ue = {}, fe = oe.indexOf("-") === -1;
    for (var he in re) {
      var _e = re[he];
      if (!(he === "value" && "defaultValue" in re && _e == null || Q$1 && he === "children" && oe === "noscript" || he === "class" || he === "className")) {
        var ve = he.toLowerCase();
        he === "defaultValue" && "value" in re && re.value == null ? he = "value" : he === "download" && _e === !0 ? _e = "" : ve === "translate" && _e === "no" ? _e = !1 : ve[0] === "o" && ve[1] === "n" ? ve === "ondoubleclick" ? he = "ondblclick" : ve !== "onchange" || oe !== "input" && oe !== "textarea" || X$1(re.type) ? ve === "onfocus" ? he = "onfocusin" : ve === "onblur" ? he = "onfocusout" : J$1.test(he) && (he = ve) : ve = he = "oninput" : fe && G.test(he) ? he = he.replace(K$1, "-$&").toLowerCase() : _e === null && (_e = void 0), ve === "oninput" && ue[he = ve] && (he = "oninputCapture"), ue[he] = _e;
      }
    }
    oe == "select" && ue.multiple && Array.isArray(ue.value) && (ue.value = H$2(re.children).forEach(function(xe) {
      xe.props.selected = ue.value.indexOf(xe.props.value) != -1;
    })), oe == "select" && ue.defaultValue != null && (ue.value = H$2(re.children).forEach(function(xe) {
      xe.props.selected = ue.multiple ? ue.defaultValue.indexOf(xe.props.value) != -1 : ue.defaultValue == xe.props.value;
    })), re.class && !re.className ? (ue.class = re.class, Object.defineProperty(ue, "className", cn)) : (re.className && !re.class || re.class && re.className) && (ue.class = ue.className = re.className), Y.props = ue;
  }(le), le.$$typeof = q$1, fn && fn(le);
};
var an = l$2.__r;
l$2.__r = function(le) {
  an && an(le), le.__c;
};
var sn = l$2.diffed;
l$2.diffed = function(le) {
  sn && sn(le);
  var Y = le.props, re = le.__e;
  re != null && le.type === "textarea" && "value" in Y && Y.value !== re.value && (re.value = Y.value == null ? "" : Y.value);
};
function isDOMElement(le) {
  return typeof le != "object" || le === null || !("nodeType" in le) ? !1 : le.nodeType === Node.ELEMENT_NODE;
}
function findDOMElement(le, Y) {
  return Y === void 0 && (Y = document), typeof le == "string" ? Y.querySelector(le) : isDOMElement(le) ? le : null;
}
function getTextDirection(le) {
  for (var Y; le && !le.dir; )
    le = le.parentNode;
  return (Y = le) == null ? void 0 : Y.dir;
}
class BasePlugin {
  constructor(Y, re) {
    this.uppy = Y, this.opts = re ?? {};
  }
  getPluginState() {
    const {
      plugins: Y
    } = this.uppy.getState();
    return Y?.[this.id] || {};
  }
  setPluginState(Y) {
    const {
      plugins: re
    } = this.uppy.getState();
    this.uppy.setState({
      plugins: {
        ...re,
        [this.id]: {
          ...re[this.id],
          ...Y
        }
      }
    });
  }
  setOptions(Y) {
    this.opts = {
      ...this.opts,
      ...Y
    }, this.setPluginState(void 0), this.i18nInit();
  }
  i18nInit() {
    const Y = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = Y.translate.bind(Y), this.i18nArray = Y.translateArray.bind(Y), this.setPluginState(void 0);
  }
  /**
   * Extendable methods
   * ==================
   * These methods are here to serve as an overview of the extendable methods as well as
   * making them not conditional in use, such as `if (this.afterUpdate)`.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  addTarget(Y) {
    throw new Error("Extend the addTarget method to add your plugin to another plugin's target");
  }
  install() {
  }
  uninstall() {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  update(Y) {
  }
  // Called after every state update, after everything's mounted. Debounced.
  afterUpdate() {
  }
}
function _classPrivateFieldLooseBase$4(le, Y) {
  if (!{}.hasOwnProperty.call(le, Y)) throw new TypeError("attempted to use private field on non-instance");
  return le;
}
var id$4 = 0;
function _classPrivateFieldLooseKey$4(le) {
  return "__private_" + id$4++ + "_" + le;
}
function debounce$1(le) {
  let Y = null, re;
  return function() {
    for (var oe = arguments.length, ue = new Array(oe), fe = 0; fe < oe; fe++)
      ue[fe] = arguments[fe];
    return re = ue, Y || (Y = Promise.resolve().then(() => (Y = null, le(...re)))), Y;
  };
}
var _updateUI = /* @__PURE__ */ _classPrivateFieldLooseKey$4("updateUI");
class UIPlugin extends BasePlugin {
  constructor() {
    super(...arguments), Object.defineProperty(this, _updateUI, {
      writable: !0,
      value: void 0
    });
  }
  getTargetPlugin(Y) {
    let re;
    if (typeof Y?.addTarget == "function")
      re = Y, re instanceof UIPlugin || console.warn(new Error("The provided plugin is not an instance of UIPlugin. This is an indication of a bug with the way Uppy is bundled.", {
        cause: {
          targetPlugin: re,
          UIPlugin
        }
      }));
    else if (typeof Y == "function") {
      const oe = Y;
      this.uppy.iteratePlugins((ue) => {
        ue instanceof oe && (re = ue);
      });
    }
    return re;
  }
  /**
   * Check if supplied `target` is a DOM element or an `object`.
   * If it’s an object — target is a plugin, and we search `plugins`
   * for a plugin with same name and return its target.
   */
  mount(Y, re) {
    const oe = re.id, ue = findDOMElement(Y);
    if (ue) {
      this.isTargetDOMEl = !0;
      const _e = document.createElement("div");
      return _e.classList.add("uppy-Root"), _classPrivateFieldLooseBase$4(this, _updateUI)[_updateUI] = debounce$1((ve) => {
        this.uppy.getPlugin(this.id) && (nn(this.render(ve, _e), _e), this.afterUpdate());
      }), this.uppy.log(`Installing ${oe} to a DOM element '${Y}'`), this.opts.replaceTargetContent && (ue.innerHTML = ""), nn(this.render(this.uppy.getState(), _e), _e), this.el = _e, ue.appendChild(_e), _e.dir = this.opts.direction || getTextDirection(_e) || "ltr", this.onMount(), this.el;
    }
    const fe = this.getTargetPlugin(Y);
    if (fe)
      return this.uppy.log(`Installing ${oe} to ${fe.id}`), this.parent = fe, this.el = fe.addTarget(re), this.onMount(), this.el;
    this.uppy.log(`Not installing ${oe}`);
    let he = `Invalid target option given to ${oe}.`;
    throw typeof Y == "function" ? he += " The given target is not a Plugin class. Please check that you're not specifying a React Component instead of a plugin. If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly." : he += "If you meant to target an HTML element, please make sure that the element exists. Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. (see https://github.com/transloadit/uppy/issues/1042)\n\nIf you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.", new Error(he);
  }
  /**
   * Called when plugin is mounted, whether in DOM or into another plugin.
   * Needed because sometimes plugins are mounted separately/after `install`,
   * so this.el and this.parent might not be available in `install`.
   * This is the case with @uppy/react plugins, for example.
   */
  render(Y, re) {
    throw new Error("Extend the render method to add your plugin to a DOM element");
  }
  update(Y) {
    if (this.el != null) {
      var re, oe;
      (re = (oe = _classPrivateFieldLooseBase$4(this, _updateUI))[_updateUI]) == null || re.call(oe, Y);
    }
  }
  unmount() {
    if (this.isTargetDOMEl) {
      var Y;
      (Y = this.el) == null || Y.remove();
    }
    this.onUnmount();
  }
  onMount() {
  }
  onUnmount() {
  }
}
function emaFilter(le, Y, re, oe) {
  return le === Y ? le : oe === 0 ? Y : le + (Y - le) * 2 ** (-oe / re);
}
const statusBarStates = {
  STATE_ERROR: "error",
  STATE_WAITING: "waiting",
  STATE_PREPROCESSING: "preprocessing",
  STATE_UPLOADING: "uploading",
  STATE_POSTPROCESSING: "postprocessing",
  STATE_COMPLETE: "complete"
};
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var hasRequiredClassnames;
function requireClassnames() {
  return hasRequiredClassnames || (hasRequiredClassnames = 1, function(le) {
    (function() {
      var Y = {}.hasOwnProperty;
      function re() {
        for (var fe = "", he = 0; he < arguments.length; he++) {
          var _e = arguments[he];
          _e && (fe = ue(fe, oe(_e)));
        }
        return fe;
      }
      function oe(fe) {
        if (typeof fe == "string" || typeof fe == "number")
          return fe;
        if (typeof fe != "object")
          return "";
        if (Array.isArray(fe))
          return re.apply(null, fe);
        if (fe.toString !== Object.prototype.toString && !fe.toString.toString().includes("[native code]"))
          return fe.toString();
        var he = "";
        for (var _e in fe)
          Y.call(fe, _e) && fe[_e] && (he = ue(he, _e));
        return he;
      }
      function ue(fe, he) {
        return he ? fe ? fe + " " + he : fe + he : fe;
      }
      le.exports ? (re.default = re, le.exports = re) : window.classNames = re;
    })();
  }(classnames)), classnames.exports;
}
var classnamesExports = requireClassnames();
const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
function calculateProcessingProgress(le) {
  const Y = [];
  let re = "indeterminate", oe;
  for (const {
    progress: fe
  } of Object.values(le)) {
    const {
      preprocess: he,
      postprocess: _e
    } = fe;
    oe == null && (he || _e) && ({
      mode: re,
      message: oe
    } = he || _e), he?.mode === "determinate" && Y.push(he.value), _e?.mode === "determinate" && Y.push(_e.value);
  }
  const ue = Y.reduce((fe, he) => fe + he / Y.length, 0);
  return {
    mode: re,
    message: oe,
    value: ue
  };
}
function secondsToTime(le) {
  const Y = Math.floor(le / 3600) % 24, re = Math.floor(le / 60) % 60, oe = Math.floor(le % 60);
  return {
    hours: Y,
    minutes: re,
    seconds: oe
  };
}
function prettyETA(le) {
  const Y = secondsToTime(le), re = Y.hours === 0 ? "" : `${Y.hours}h`, oe = Y.minutes === 0 ? "" : `${Y.hours === 0 ? Y.minutes : ` ${Y.minutes.toString(10).padStart(2, "0")}`}m`, ue = Y.hours !== 0 ? "" : `${Y.minutes === 0 ? Y.seconds : ` ${Y.seconds.toString(10).padStart(2, "0")}`}s`;
  return `${re}${oe}${ue}`;
}
const DOT = "·", renderDot = () => ` ${DOT} `;
function UploadBtn(le) {
  const {
    newFiles: Y,
    isUploadStarted: re,
    recoveredState: oe,
    i18n: ue,
    uploadState: fe,
    isSomeGhost: he,
    startUpload: _e
  } = le, ve = classNames("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--upload", {
    "uppy-c-btn-primary": fe === statusBarStates.STATE_WAITING
  }, {
    "uppy-StatusBar-actionBtn--disabled": he
  }), xe = Y && re && !oe ? ue("uploadXNewFiles", {
    smart_count: Y
  }) : ue("uploadXFiles", {
    smart_count: Y
  });
  return _$1("button", {
    type: "button",
    className: ve,
    "aria-label": ue("uploadXFiles", {
      smart_count: Y
    }),
    onClick: _e,
    disabled: he,
    "data-uppy-super-focusable": !0
  }, xe);
}
function RetryBtn(le) {
  const {
    i18n: Y,
    uppy: re
  } = le;
  return _$1("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--retry",
    "aria-label": Y("retryUpload"),
    onClick: () => re.retryAll().catch(() => {
    }),
    "data-uppy-super-focusable": !0,
    "data-cy": "retry"
  }, _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "8",
    height: "10",
    viewBox: "0 0 8 10"
  }, _$1("path", {
    d: "M4 2.408a2.75 2.75 0 1 0 2.75 2.75.626.626 0 0 1 1.25.018v.023a4 4 0 1 1-4-4.041V.25a.25.25 0 0 1 .389-.208l2.299 1.533a.25.25 0 0 1 0 .416l-2.3 1.533A.25.25 0 0 1 4 3.316v-.908z"
  })), Y("retry"));
}
function CancelBtn(le) {
  const {
    i18n: Y,
    uppy: re
  } = le;
  return _$1("button", {
    type: "button",
    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    title: Y("cancel"),
    "aria-label": Y("cancel"),
    onClick: () => re.cancelAll(),
    "data-cy": "cancel",
    "data-uppy-super-focusable": !0
  }, _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, _$1("g", {
    fill: "none",
    fillRule: "evenodd"
  }, _$1("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), _$1("path", {
    fill: "#FFF",
    d: "M9.283 8l2.567 2.567-1.283 1.283L8 9.283 5.433 11.85 4.15 10.567 6.717 8 4.15 5.433 5.433 4.15 8 6.717l2.567-2.567 1.283 1.283z"
  }))));
}
function PauseResumeButton(le) {
  const {
    isAllPaused: Y,
    i18n: re,
    isAllComplete: oe,
    resumableUploads: ue,
    uppy: fe
  } = le, he = re(Y ? "resume" : "pause");
  function _e() {
    if (!oe) {
      if (!ue) {
        fe.cancelAll();
        return;
      }
      if (Y) {
        fe.resumeAll();
        return;
      }
      fe.pauseAll();
    }
  }
  return _$1("button", {
    title: he,
    "aria-label": he,
    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    type: "button",
    onClick: _e,
    "data-cy": "togglePauseResume",
    "data-uppy-super-focusable": !0
  }, _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, _$1("g", {
    fill: "none",
    fillRule: "evenodd"
  }, _$1("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), _$1("path", {
    fill: "#FFF",
    d: Y ? "M6 4.25L11.5 8 6 11.75z" : "M5 4.5h2v7H5v-7zm4 0h2v7H9v-7z"
  }))));
}
function DoneBtn(le) {
  const {
    i18n: Y,
    doneButtonHandler: re
  } = le;
  return _$1("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--done",
    onClick: re,
    "data-uppy-super-focusable": !0
  }, Y("done"));
}
function LoadingSpinner() {
  return _$1("svg", {
    className: "uppy-StatusBar-spinner",
    "aria-hidden": "true",
    focusable: "false",
    width: "14",
    height: "14"
  }, _$1("path", {
    d: "M13.983 6.547c-.12-2.509-1.64-4.893-3.939-5.936-2.48-1.127-5.488-.656-7.556 1.094C.524 3.367-.398 6.048.162 8.562c.556 2.495 2.46 4.52 4.94 5.183 2.932.784 5.61-.602 7.256-3.015-1.493 1.993-3.745 3.309-6.298 2.868-2.514-.434-4.578-2.349-5.153-4.84a6.226 6.226 0 0 1 2.98-6.778C6.34.586 9.74 1.1 11.373 3.493c.407.596.693 1.282.842 1.988.127.598.073 1.197.161 1.794.078.525.543 1.257 1.15.864.525-.341.49-1.05.456-1.592-.007-.15.02.3 0 0",
    fillRule: "evenodd"
  }));
}
function ProgressBarProcessing(le) {
  const {
    progress: Y
  } = le, {
    value: re,
    mode: oe,
    message: ue
  } = Y;
  return _$1("div", {
    className: "uppy-StatusBar-content"
  }, _$1(LoadingSpinner, null), oe === "determinate" ? `${Math.round(re * 100)}% · ` : "", ue);
}
function ProgressDetails(le) {
  const {
    numUploads: Y,
    complete: re,
    totalUploadedSize: oe,
    totalSize: ue,
    totalETA: fe,
    i18n: he
  } = le, _e = Y > 1, ve = prettierBytes(oe);
  return _$1("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, _e && he("filesUploadedOfTotal", {
    complete: re,
    smart_count: Y
  }), _$1("span", {
    className: "uppy-StatusBar-additionalInfo"
  }, _e && renderDot(), ue != null ? he("dataUploadedOfTotal", {
    complete: ve,
    total: prettierBytes(ue)
  }) : he("dataUploadedOfUnknown", {
    complete: ve
  }), renderDot(), fe != null && he("xTimeLeft", {
    time: prettyETA(fe)
  })));
}
function FileUploadCount(le) {
  const {
    i18n: Y,
    complete: re,
    numUploads: oe
  } = le;
  return _$1("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, Y("filesUploadedOfTotal", {
    complete: re,
    smart_count: oe
  }));
}
function UploadNewlyAddedFiles(le) {
  const {
    i18n: Y,
    newFiles: re,
    startUpload: oe
  } = le, ue = classNames("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--uploadNewlyAdded");
  return _$1("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, _$1("div", {
    className: "uppy-StatusBar-statusSecondaryHint"
  }, Y("xMoreFilesAdded", {
    smart_count: re
  })), _$1("button", {
    type: "button",
    className: ue,
    "aria-label": Y("uploadXFiles", {
      smart_count: re
    }),
    onClick: oe
  }, Y("upload")));
}
function ProgressBarUploading(le) {
  const {
    i18n: Y,
    supportsUploadProgress: re,
    totalProgress: oe,
    showProgressDetails: ue,
    isUploadStarted: fe,
    isAllComplete: he,
    isAllPaused: _e,
    newFiles: ve,
    numUploads: xe,
    complete: Ee,
    totalUploadedSize: Se,
    totalSize: Te,
    totalETA: Ce,
    startUpload: Ie
  } = le, Ne = ve && fe;
  if (!fe || he)
    return null;
  const Re = Y(_e ? "paused" : "uploading");
  function Ae() {
    return !_e && !Ne && ue ? re ? _$1(ProgressDetails, {
      numUploads: xe,
      complete: Ee,
      totalUploadedSize: Se,
      totalSize: Te,
      totalETA: Ce,
      i18n: Y
    }) : _$1(FileUploadCount, {
      i18n: Y,
      complete: Ee,
      numUploads: xe
    }) : null;
  }
  return _$1("div", {
    className: "uppy-StatusBar-content",
    "aria-label": Re,
    title: Re
  }, _e ? null : _$1(LoadingSpinner, null), _$1("div", {
    className: "uppy-StatusBar-status"
  }, _$1("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, re && oe !== 0 ? `${Re}: ${oe}%` : Re), Ae(), Ne ? _$1(UploadNewlyAddedFiles, {
    i18n: Y,
    newFiles: ve,
    startUpload: Ie
  }) : null));
}
function ProgressBarComplete(le) {
  const {
    i18n: Y
  } = le;
  return _$1("div", {
    className: "uppy-StatusBar-content",
    role: "status",
    title: Y("complete")
  }, _$1("div", {
    className: "uppy-StatusBar-status"
  }, _$1("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
    width: "15",
    height: "11",
    viewBox: "0 0 15 11"
  }, _$1("path", {
    d: "M.414 5.843L1.627 4.63l3.472 3.472L13.202 0l1.212 1.213L5.1 10.528z"
  })), Y("complete"))));
}
function ProgressBarError(le) {
  const {
    error: Y,
    i18n: re,
    complete: oe,
    numUploads: ue
  } = le;
  function fe() {
    const he = `${re("uploadFailed")} 

 ${Y}`;
    alert(he);
  }
  return _$1("div", {
    className: "uppy-StatusBar-content",
    title: re("uploadFailed")
  }, _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
    width: "11",
    height: "11",
    viewBox: "0 0 11 11"
  }, _$1("path", {
    d: "M4.278 5.5L0 1.222 1.222 0 5.5 4.278 9.778 0 11 1.222 6.722 5.5 11 9.778 9.778 11 5.5 6.722 1.222 11 0 9.778z"
  })), _$1("div", {
    className: "uppy-StatusBar-status"
  }, _$1("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, re("uploadFailed"), _$1("button", {
    className: "uppy-u-reset uppy-StatusBar-details",
    "aria-label": re("showErrorDetails"),
    "data-microtip-position": "top-right",
    "data-microtip-size": "medium",
    onClick: fe,
    type: "button"
  }, "?")), _$1(FileUploadCount, {
    i18n: re,
    complete: oe,
    numUploads: ue
  })));
}
const {
  STATE_ERROR,
  STATE_WAITING,
  STATE_PREPROCESSING,
  STATE_UPLOADING,
  STATE_POSTPROCESSING,
  STATE_COMPLETE
} = statusBarStates;
function StatusBarUI(le) {
  let {
    newFiles: Y,
    allowNewUpload: re,
    isUploadInProgress: oe,
    isAllPaused: ue,
    resumableUploads: fe,
    error: he,
    hideUploadButton: _e = void 0,
    hidePauseResumeButton: ve = !1,
    hideCancelButton: xe = !1,
    hideRetryButton: Ee = !1,
    recoveredState: Se,
    uploadState: Te,
    totalProgress: Ce,
    files: Ie,
    supportsUploadProgress: Ne,
    hideAfterFinish: Re = !1,
    isSomeGhost: Ae,
    doneButtonHandler: Pe = void 0,
    isUploadStarted: Fe,
    i18n: Le,
    startUpload: He,
    uppy: Ge,
    isAllComplete: Ve,
    showProgressDetails: $e = void 0,
    numUploads: De,
    complete: Ke,
    totalSize: ze,
    totalETA: tt,
    totalUploadedSize: Xe
  } = le;
  function mt() {
    switch (Te) {
      case STATE_POSTPROCESSING:
      case STATE_PREPROCESSING: {
        const et = calculateProcessingProgress(Ie);
        return et.mode === "determinate" ? et.value * 100 : Ce;
      }
      case STATE_ERROR:
        return null;
      case STATE_UPLOADING:
        return Ne ? Ce : null;
      default:
        return Ce;
    }
  }
  function at() {
    switch (Te) {
      case STATE_POSTPROCESSING:
      case STATE_PREPROCESSING: {
        const {
          mode: et
        } = calculateProcessingProgress(Ie);
        return et === "indeterminate";
      }
      case STATE_UPLOADING:
        return !Ne;
      default:
        return !1;
    }
  }
  const qe = mt(), st = qe ?? 100, xt = !he && Y && (!oe && !ue || Se) && re && !_e, gt = !xe && Te !== STATE_WAITING && Te !== STATE_COMPLETE, Ze = fe && !ve && Te === STATE_UPLOADING, _t = he && !Ve && !Ee, wt = Pe && Te === STATE_COMPLETE, yt = classNames("uppy-StatusBar-progress", {
    "is-indeterminate": at()
  }), St = classNames("uppy-StatusBar", `is-${Te}`, {
    "has-ghosts": Ae
  }), It = (() => {
    switch (Te) {
      case STATE_PREPROCESSING:
      case STATE_POSTPROCESSING:
        return _$1(ProgressBarProcessing, {
          progress: calculateProcessingProgress(Ie)
        });
      case STATE_COMPLETE:
        return _$1(ProgressBarComplete, {
          i18n: Le
        });
      case STATE_ERROR:
        return _$1(ProgressBarError, {
          error: he,
          i18n: Le,
          numUploads: De,
          complete: Ke
        });
      case STATE_UPLOADING:
        return _$1(ProgressBarUploading, {
          i18n: Le,
          supportsUploadProgress: Ne,
          totalProgress: Ce,
          showProgressDetails: $e,
          isUploadStarted: Fe,
          isAllComplete: Ve,
          isAllPaused: ue,
          newFiles: Y,
          numUploads: De,
          complete: Ke,
          totalUploadedSize: Xe,
          totalSize: ze,
          totalETA: tt,
          startUpload: He
        });
      default:
        return null;
    }
  })();
  return !(xt || _t || Ze || gt || wt) && !It || Te === STATE_COMPLETE && Re ? null : _$1("div", {
    className: St
  }, _$1("div", {
    className: yt,
    style: {
      width: `${st}%`
    },
    role: "progressbar",
    "aria-label": `${st}%`,
    "aria-valuetext": `${st}%`,
    "aria-valuemin": 0,
    "aria-valuemax": 100,
    "aria-valuenow": qe
  }), It, _$1("div", {
    className: "uppy-StatusBar-actions"
  }, xt ? _$1(UploadBtn, {
    newFiles: Y,
    isUploadStarted: Fe,
    recoveredState: Se,
    i18n: Le,
    isSomeGhost: Ae,
    startUpload: He,
    uploadState: Te
  }) : null, _t ? _$1(RetryBtn, {
    i18n: Le,
    uppy: Ge
  }) : null, Ze ? _$1(PauseResumeButton, {
    isAllPaused: ue,
    i18n: Le,
    isAllComplete: Ve,
    resumableUploads: fe,
    uppy: Ge
  }) : null, gt ? _$1(CancelBtn, {
    i18n: Le,
    uppy: Ge
  }) : null, wt ? _$1(DoneBtn, {
    i18n: Le,
    doneButtonHandler: Pe
  }) : null));
}
const locale$4 = {
  strings: {
    // Shown in the status bar while files are being uploaded.
    uploading: "Uploading",
    // Shown in the status bar once all files have been uploaded.
    complete: "Complete",
    // Shown in the status bar if an upload failed.
    uploadFailed: "Upload failed",
    // Shown in the status bar while the upload is paused.
    paused: "Paused",
    // Used as the label for the button that retries an upload.
    retry: "Retry",
    // Used as the label for the button that cancels an upload.
    cancel: "Cancel",
    // Used as the label for the button that pauses an upload.
    pause: "Pause",
    // Used as the label for the button that resumes an upload.
    resume: "Resume",
    // Used as the label for the button that resets the upload state after an upload
    done: "Done",
    // When `showProgressDetails` is set, shows the number of files that have been fully uploaded so far.
    filesUploadedOfTotal: {
      0: "%{complete} of %{smart_count} file uploaded",
      1: "%{complete} of %{smart_count} files uploaded"
    },
    // When `showProgressDetails` is set, shows the amount of bytes that have been uploaded so far.
    dataUploadedOfTotal: "%{complete} of %{total}",
    dataUploadedOfUnknown: "%{complete} of unknown",
    // When `showProgressDetails` is set, shows an estimation of how long the upload will take to complete.
    xTimeLeft: "%{time} left",
    // Used as the label for the button that starts an upload.
    uploadXFiles: {
      0: "Upload %{smart_count} file",
      1: "Upload %{smart_count} files"
    },
    // Used as the label for the button that starts an upload, if another upload has been started in the past
    // and new files were added later.
    uploadXNewFiles: {
      0: "Upload +%{smart_count} file",
      1: "Upload +%{smart_count} files"
    },
    upload: "Upload",
    retryUpload: "Retry upload",
    xMoreFilesAdded: {
      0: "%{smart_count} more file added",
      1: "%{smart_count} more files added"
    },
    showErrorDetails: "Show error details"
  }
};
function _classPrivateFieldLooseBase$3(le, Y) {
  if (!{}.hasOwnProperty.call(le, Y)) throw new TypeError("attempted to use private field on non-instance");
  return le;
}
var id$3 = 0;
function _classPrivateFieldLooseKey$3(le) {
  return "__private_" + id$3++ + "_" + le;
}
const packageJson$4 = {
  version: "4.1.3"
}, speedFilterHalfLife = 2e3, ETAFilterHalfLife = 2e3;
function getUploadingState$1(le, Y, re, oe) {
  if (le)
    return statusBarStates.STATE_ERROR;
  if (Y)
    return statusBarStates.STATE_COMPLETE;
  if (re)
    return statusBarStates.STATE_WAITING;
  let ue = statusBarStates.STATE_WAITING;
  const fe = Object.keys(oe);
  for (let he = 0; he < fe.length; he++) {
    const {
      progress: _e
    } = oe[fe[he]];
    if (_e.uploadStarted && !_e.uploadComplete)
      return statusBarStates.STATE_UPLOADING;
    _e.preprocess && (ue = statusBarStates.STATE_PREPROCESSING), _e.postprocess && ue !== statusBarStates.STATE_PREPROCESSING && (ue = statusBarStates.STATE_POSTPROCESSING);
  }
  return ue;
}
const defaultOptions$5 = {
  hideUploadButton: !1,
  hideRetryButton: !1,
  hidePauseResumeButton: !1,
  hideCancelButton: !1,
  showProgressDetails: !1,
  hideAfterFinish: !0,
  doneButtonHandler: null
};
var _lastUpdateTime = /* @__PURE__ */ _classPrivateFieldLooseKey$3("lastUpdateTime"), _previousUploadedBytes = /* @__PURE__ */ _classPrivateFieldLooseKey$3("previousUploadedBytes"), _previousSpeed = /* @__PURE__ */ _classPrivateFieldLooseKey$3("previousSpeed"), _previousETA = /* @__PURE__ */ _classPrivateFieldLooseKey$3("previousETA"), _computeSmoothETA = /* @__PURE__ */ _classPrivateFieldLooseKey$3("computeSmoothETA"), _onUploadStart = /* @__PURE__ */ _classPrivateFieldLooseKey$3("onUploadStart");
class StatusBar extends UIPlugin {
  constructor(Y, re) {
    super(Y, {
      ...defaultOptions$5,
      ...re
    }), Object.defineProperty(this, _computeSmoothETA, {
      value: _computeSmoothETA2
    }), Object.defineProperty(this, _lastUpdateTime, {
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, _previousUploadedBytes, {
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, _previousSpeed, {
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, _previousETA, {
      writable: !0,
      value: void 0
    }), this.startUpload = () => this.uppy.upload().catch(() => {
    }), Object.defineProperty(this, _onUploadStart, {
      writable: !0,
      value: () => {
        const {
          recoveredState: oe
        } = this.uppy.getState();
        if (_classPrivateFieldLooseBase$3(this, _previousSpeed)[_previousSpeed] = null, _classPrivateFieldLooseBase$3(this, _previousETA)[_previousETA] = null, oe) {
          _classPrivateFieldLooseBase$3(this, _previousUploadedBytes)[_previousUploadedBytes] = Object.values(oe.files).reduce((ue, fe) => {
            let {
              progress: he
            } = fe;
            return ue + he.bytesUploaded;
          }, 0), this.uppy.emit("restore-confirmed");
          return;
        }
        _classPrivateFieldLooseBase$3(this, _lastUpdateTime)[_lastUpdateTime] = performance.now(), _classPrivateFieldLooseBase$3(this, _previousUploadedBytes)[_previousUploadedBytes] = 0;
      }
    }), this.id = this.opts.id || "StatusBar", this.title = "StatusBar", this.type = "progressindicator", this.defaultLocale = locale$4, this.i18nInit(), this.render = this.render.bind(this), this.install = this.install.bind(this);
  }
  render(Y) {
    const {
      capabilities: re,
      files: oe,
      allowNewUpload: ue,
      totalProgress: fe,
      error: he,
      recoveredState: _e
    } = Y, {
      newFiles: ve,
      startedFiles: xe,
      completeFiles: Ee,
      isUploadStarted: Se,
      isAllComplete: Te,
      isAllPaused: Ce,
      isUploadInProgress: Ie,
      isSomeGhost: Ne
    } = this.uppy.getObjectOfFilesPerState(), Re = _e ? Object.values(oe) : ve, Ae = !!re.resumableUploads, Pe = re.uploadProgress !== !1;
    let Fe = null, Le = 0;
    xe.every((Ge) => Ge.progress.bytesTotal != null && Ge.progress.bytesTotal !== 0) ? (Fe = 0, xe.forEach((Ge) => {
      Fe += Ge.progress.bytesTotal || 0, Le += Ge.progress.bytesUploaded || 0;
    })) : xe.forEach((Ge) => {
      Le += Ge.progress.bytesUploaded || 0;
    });
    const He = _classPrivateFieldLooseBase$3(this, _computeSmoothETA)[_computeSmoothETA]({
      uploaded: Le,
      total: Fe
    });
    return StatusBarUI({
      error: he,
      uploadState: getUploadingState$1(he, Te, _e, Y.files || {}),
      allowNewUpload: ue,
      totalProgress: fe,
      totalSize: Fe,
      totalUploadedSize: Le,
      isAllComplete: !1,
      isAllPaused: Ce,
      isUploadStarted: Se,
      isUploadInProgress: Ie,
      isSomeGhost: Ne,
      recoveredState: _e,
      complete: Ee.length,
      newFiles: Re.length,
      numUploads: xe.length,
      totalETA: He,
      files: oe,
      i18n: this.i18n,
      uppy: this.uppy,
      startUpload: this.startUpload,
      doneButtonHandler: this.opts.doneButtonHandler,
      resumableUploads: Ae,
      supportsUploadProgress: Pe,
      showProgressDetails: this.opts.showProgressDetails,
      hideUploadButton: this.opts.hideUploadButton,
      hideRetryButton: this.opts.hideRetryButton,
      hidePauseResumeButton: this.opts.hidePauseResumeButton,
      hideCancelButton: this.opts.hideCancelButton,
      hideAfterFinish: this.opts.hideAfterFinish
    });
  }
  onMount() {
    const Y = this.el;
    getTextDirection(Y) || (Y.dir = "ltr");
  }
  install() {
    const {
      target: Y
    } = this.opts;
    Y && this.mount(Y, this), this.uppy.on("upload", _classPrivateFieldLooseBase$3(this, _onUploadStart)[_onUploadStart]), _classPrivateFieldLooseBase$3(this, _lastUpdateTime)[_lastUpdateTime] = performance.now(), _classPrivateFieldLooseBase$3(this, _previousUploadedBytes)[_previousUploadedBytes] = this.uppy.getFiles().reduce((re, oe) => re + oe.progress.bytesUploaded, 0);
  }
  uninstall() {
    this.unmount(), this.uppy.off("upload", _classPrivateFieldLooseBase$3(this, _onUploadStart)[_onUploadStart]);
  }
}
function _computeSmoothETA2(le) {
  var Y, re;
  if (le.total == null || le.total === 0)
    return null;
  const oe = le.total - le.uploaded;
  if (oe <= 0)
    return null;
  (re = (Y = _classPrivateFieldLooseBase$3(this, _lastUpdateTime))[_lastUpdateTime]) != null || (Y[_lastUpdateTime] = performance.now());
  const ue = performance.now() - _classPrivateFieldLooseBase$3(this, _lastUpdateTime)[_lastUpdateTime];
  if (ue === 0) {
    var fe;
    return Math.round(((fe = _classPrivateFieldLooseBase$3(this, _previousETA)[_previousETA]) != null ? fe : 0) / 100) / 10;
  }
  const he = le.uploaded - _classPrivateFieldLooseBase$3(this, _previousUploadedBytes)[_previousUploadedBytes];
  if (_classPrivateFieldLooseBase$3(this, _previousUploadedBytes)[_previousUploadedBytes] = le.uploaded, he <= 0) {
    var _e;
    return Math.round(((_e = _classPrivateFieldLooseBase$3(this, _previousETA)[_previousETA]) != null ? _e : 0) / 100) / 10;
  }
  const ve = he / ue, xe = _classPrivateFieldLooseBase$3(this, _previousSpeed)[_previousSpeed] == null ? ve : emaFilter(ve, _classPrivateFieldLooseBase$3(this, _previousSpeed)[_previousSpeed], speedFilterHalfLife, ue);
  _classPrivateFieldLooseBase$3(this, _previousSpeed)[_previousSpeed] = xe;
  const Ee = oe / xe, Se = Math.max(_classPrivateFieldLooseBase$3(this, _previousETA)[_previousETA] - ue, 0), Te = _classPrivateFieldLooseBase$3(this, _previousETA)[_previousETA] == null ? Ee : emaFilter(Ee, Se, ETAFilterHalfLife, ue);
  return _classPrivateFieldLooseBase$3(this, _previousETA)[_previousETA] = Te, _classPrivateFieldLooseBase$3(this, _lastUpdateTime)[_lastUpdateTime] = performance.now(), Math.round(Te / 100) / 10;
}
StatusBar.VERSION = packageJson$4.version;
const TRANSITION_MS = 300;
class FadeIn extends x {
  constructor() {
    super(...arguments), this.ref = b$1();
  }
  componentWillEnter(Y) {
    this.ref.current.style.opacity = "1", this.ref.current.style.transform = "none", setTimeout(Y, TRANSITION_MS);
  }
  componentWillLeave(Y) {
    this.ref.current.style.opacity = "0", this.ref.current.style.transform = "translateY(350%)", setTimeout(Y, TRANSITION_MS);
  }
  render() {
    const {
      children: Y
    } = this.props;
    return _$1("div", {
      className: "uppy-Informer-animated",
      ref: this.ref
    }, Y);
  }
}
function assign$1(le, Y) {
  return Object.assign(le, Y);
}
function getKey(le, Y) {
  var re;
  return (re = le?.key) != null ? re : Y;
}
function linkRef(le, Y) {
  const re = le._ptgLinkedRefs || (le._ptgLinkedRefs = {});
  return re[Y] || (re[Y] = (oe) => {
    le.refs[Y] = oe;
  });
}
function getChildMapping(le) {
  const Y = {};
  for (let re = 0; re < le.length; re++)
    if (le[re] != null) {
      const oe = getKey(le[re], re.toString(36));
      Y[oe] = le[re];
    }
  return Y;
}
function mergeChildMappings(le, Y) {
  le = le || {}, Y = Y || {};
  const re = (he) => Y.hasOwnProperty(he) ? Y[he] : le[he], oe = {};
  let ue = [];
  for (const he in le)
    Y.hasOwnProperty(he) ? ue.length && (oe[he] = ue, ue = []) : ue.push(he);
  const fe = {};
  for (const he in Y) {
    if (oe.hasOwnProperty(he))
      for (let _e = 0; _e < oe[he].length; _e++) {
        const ve = oe[he][_e];
        fe[oe[he][_e]] = re(ve);
      }
    fe[he] = re(he);
  }
  for (let he = 0; he < ue.length; he++)
    fe[ue[he]] = re(ue[he]);
  return fe;
}
const identity = (le) => le;
class TransitionGroup extends x {
  constructor(Y, re) {
    super(Y, re), this.refs = {}, this.state = {
      children: getChildMapping(H$2(H$2(this.props.children)) || [])
    }, this.performAppear = this.performAppear.bind(this), this.performEnter = this.performEnter.bind(this), this.performLeave = this.performLeave.bind(this);
  }
  componentWillMount() {
    this.currentlyTransitioningKeys = {}, this.keysToAbortLeave = [], this.keysToEnter = [], this.keysToLeave = [];
  }
  componentDidMount() {
    const Y = this.state.children;
    for (const re in Y)
      Y[re] && this.performAppear(re);
  }
  componentWillReceiveProps(Y) {
    const re = getChildMapping(H$2(Y.children) || []), oe = this.state.children;
    this.setState((fe) => ({
      children: mergeChildMappings(fe.children, re)
    }));
    let ue;
    for (ue in re)
      if (re.hasOwnProperty(ue)) {
        const fe = oe && oe.hasOwnProperty(ue);
        re[ue] && fe && this.currentlyTransitioningKeys[ue] ? (this.keysToEnter.push(ue), this.keysToAbortLeave.push(ue)) : re[ue] && !fe && !this.currentlyTransitioningKeys[ue] && this.keysToEnter.push(ue);
      }
    for (ue in oe)
      if (oe.hasOwnProperty(ue)) {
        const fe = re && re.hasOwnProperty(ue);
        oe[ue] && !fe && !this.currentlyTransitioningKeys[ue] && this.keysToLeave.push(ue);
      }
  }
  componentDidUpdate() {
    const {
      keysToEnter: Y
    } = this;
    this.keysToEnter = [], Y.forEach(this.performEnter);
    const {
      keysToLeave: re
    } = this;
    this.keysToLeave = [], re.forEach(this.performLeave);
  }
  _finishAbort(Y) {
    const re = this.keysToAbortLeave.indexOf(Y);
    re !== -1 && this.keysToAbortLeave.splice(re, 1);
  }
  performAppear(Y) {
    this.currentlyTransitioningKeys[Y] = !0;
    const re = this.refs[Y];
    re != null && re.componentWillAppear ? re.componentWillAppear(this._handleDoneAppearing.bind(this, Y)) : this._handleDoneAppearing(Y);
  }
  _handleDoneAppearing(Y) {
    const re = this.refs[Y];
    re != null && re.componentDidAppear && re.componentDidAppear(), delete this.currentlyTransitioningKeys[Y], this._finishAbort(Y);
    const oe = getChildMapping(H$2(this.props.children) || []);
    (!oe || !oe.hasOwnProperty(Y)) && this.performLeave(Y);
  }
  performEnter(Y) {
    this.currentlyTransitioningKeys[Y] = !0;
    const re = this.refs[Y];
    re != null && re.componentWillEnter ? re.componentWillEnter(this._handleDoneEntering.bind(this, Y)) : this._handleDoneEntering(Y);
  }
  _handleDoneEntering(Y) {
    const re = this.refs[Y];
    re != null && re.componentDidEnter && re.componentDidEnter(), delete this.currentlyTransitioningKeys[Y], this._finishAbort(Y);
    const oe = getChildMapping(H$2(this.props.children) || []);
    (!oe || !oe.hasOwnProperty(Y)) && this.performLeave(Y);
  }
  performLeave(Y) {
    if (this.keysToAbortLeave.indexOf(Y) !== -1)
      return;
    this.currentlyTransitioningKeys[Y] = !0;
    const oe = this.refs[Y];
    oe != null && oe.componentWillLeave ? oe.componentWillLeave(this._handleDoneLeaving.bind(this, Y)) : this._handleDoneLeaving(Y);
  }
  _handleDoneLeaving(Y) {
    if (this.keysToAbortLeave.indexOf(Y) !== -1)
      return;
    const oe = this.refs[Y];
    oe != null && oe.componentDidLeave && oe.componentDidLeave(), delete this.currentlyTransitioningKeys[Y];
    const ue = getChildMapping(H$2(this.props.children) || []);
    if (ue && ue.hasOwnProperty(Y))
      this.performEnter(Y);
    else {
      const fe = assign$1({}, this.state.children);
      delete fe[Y], this.setState({
        children: fe
      });
    }
  }
  render(Y, re) {
    let {
      childFactory: oe,
      transitionLeave: ue,
      transitionName: fe,
      transitionAppear: he,
      transitionEnter: _e,
      transitionLeaveTimeout: ve,
      transitionEnterTimeout: xe,
      transitionAppearTimeout: Ee,
      component: Se,
      ...Te
    } = Y, {
      children: Ce
    } = re;
    const Ie = Object.entries(Ce).map((Ne) => {
      let [Re, Ae] = Ne;
      if (!Ae) return;
      const Pe = linkRef(this, Re);
      return J$2(oe(Ae), {
        ref: Pe,
        key: Re
      });
    }).filter(Boolean);
    return _$1(Se, Te, Ie);
  }
}
TransitionGroup.defaultProps = {
  component: "span",
  childFactory: identity
};
const packageJson$3 = {
  version: "4.2.1"
};
class Informer extends UIPlugin {
  constructor(Y, re) {
    super(Y, re), this.render = (oe) => _$1("div", {
      className: "uppy uppy-Informer"
    }, _$1(TransitionGroup, null, oe.info.map((ue) => _$1(FadeIn, {
      key: ue.message
    }, _$1("p", {
      role: "alert"
    }, ue.message, " ", ue.details && _$1("span", {
      "aria-label": ue.details,
      "data-microtip-position": "top-left",
      "data-microtip-size": "medium",
      role: "tooltip",
      onClick: () => (
        // eslint-disable-next-line no-alert
        alert(`${ue.message} 

 ${ue.details}`)
      )
    }, "?")))))), this.type = "progressindicator", this.id = this.opts.id || "Informer", this.title = "Informer";
  }
  install() {
    const {
      target: Y
    } = this.opts;
    Y && this.mount(Y, this);
  }
}
Informer.VERSION = packageJson$3.version;
const DATA_URL_PATTERN = /^data:([^/]+\/[^,;]+(?:[^,]*?))(;base64)?,([\s\S]*)$/;
function dataURItoBlob(le, Y, re) {
  var oe, ue;
  const fe = DATA_URL_PATTERN.exec(le), he = (oe = (ue = Y.mimeType) != null ? ue : fe?.[1]) != null ? oe : "plain/text";
  let _e;
  if (fe?.[2] != null) {
    const ve = atob(decodeURIComponent(fe[3])), xe = new Uint8Array(ve.length);
    for (let Ee = 0; Ee < ve.length; Ee++)
      xe[Ee] = ve.charCodeAt(Ee);
    _e = [xe];
  } else fe?.[3] != null && (_e = [decodeURIComponent(fe[3])]);
  return new Blob(_e, {
    type: he
  });
}
function isObjectURL(le) {
  return le.startsWith("blob:");
}
function isPreviewSupported(le) {
  return le ? /^[^/]+\/(jpe?g|gif|png|svg|svg\+xml|bmp|webp|avif)$/.test(le) : !1;
}
function e(le, Y, re) {
  return Y in le ? Object.defineProperty(le, Y, { value: re, enumerable: !0, configurable: !0, writable: !0 }) : le[Y] = re, le;
}
var t = typeof self < "u" ? self : global;
const s = typeof navigator < "u", i = s && typeof HTMLImageElement > "u", n = !(typeof global > "u" || typeof process > "u" || !process.versions || !process.versions.node), r = t.Buffer, a = !!r, h = (le) => le !== void 0;
function f(le) {
  return le === void 0 || (le instanceof Map ? le.size === 0 : Object.values(le).filter(h).length === 0);
}
function l(le) {
  let Y = new Error(le);
  throw delete Y.stack, Y;
}
function o(le) {
  let Y = function(re) {
    let oe = 0;
    return re.ifd0.enabled && (oe += 1024), re.exif.enabled && (oe += 2048), re.makerNote && (oe += 2048), re.userComment && (oe += 1024), re.gps.enabled && (oe += 512), re.interop.enabled && (oe += 100), re.ifd1.enabled && (oe += 1024), oe + 2048;
  }(le);
  return le.jfif.enabled && (Y += 50), le.xmp.enabled && (Y += 2e4), le.iptc.enabled && (Y += 14e3), le.icc.enabled && (Y += 6e3), Y;
}
const u = (le) => String.fromCharCode.apply(null, le), d = typeof TextDecoder < "u" ? new TextDecoder("utf-8") : void 0;
class c {
  static from(Y, re) {
    return Y instanceof this && Y.le === re ? Y : new c(Y, void 0, void 0, re);
  }
  constructor(Y, re = 0, oe, ue) {
    if (typeof ue == "boolean" && (this.le = ue), Array.isArray(Y) && (Y = new Uint8Array(Y)), Y === 0) this.byteOffset = 0, this.byteLength = 0;
    else if (Y instanceof ArrayBuffer) {
      oe === void 0 && (oe = Y.byteLength - re);
      let fe = new DataView(Y, re, oe);
      this._swapDataView(fe);
    } else if (Y instanceof Uint8Array || Y instanceof DataView || Y instanceof c) {
      oe === void 0 && (oe = Y.byteLength - re), (re += Y.byteOffset) + oe > Y.byteOffset + Y.byteLength && l("Creating view outside of available memory in ArrayBuffer");
      let fe = new DataView(Y.buffer, re, oe);
      this._swapDataView(fe);
    } else if (typeof Y == "number") {
      let fe = new DataView(new ArrayBuffer(Y));
      this._swapDataView(fe);
    } else l("Invalid input argument for BufferView: " + Y);
  }
  _swapArrayBuffer(Y) {
    this._swapDataView(new DataView(Y));
  }
  _swapBuffer(Y) {
    this._swapDataView(new DataView(Y.buffer, Y.byteOffset, Y.byteLength));
  }
  _swapDataView(Y) {
    this.dataView = Y, this.buffer = Y.buffer, this.byteOffset = Y.byteOffset, this.byteLength = Y.byteLength;
  }
  _lengthToEnd(Y) {
    return this.byteLength - Y;
  }
  set(Y, re, oe = c) {
    return Y instanceof DataView || Y instanceof c ? Y = new Uint8Array(Y.buffer, Y.byteOffset, Y.byteLength) : Y instanceof ArrayBuffer && (Y = new Uint8Array(Y)), Y instanceof Uint8Array || l("BufferView.set(): Invalid data argument."), this.toUint8().set(Y, re), new oe(this, re, Y.byteLength);
  }
  subarray(Y, re) {
    return re = re || this._lengthToEnd(Y), new c(this, Y, re);
  }
  toUint8() {
    return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);
  }
  getUint8Array(Y, re) {
    return new Uint8Array(this.buffer, this.byteOffset + Y, re);
  }
  getString(Y = 0, re = this.byteLength) {
    return ue = this.getUint8Array(Y, re), d ? d.decode(ue) : a ? Buffer.from(ue).toString("utf8") : decodeURIComponent(escape(u(ue)));
    var ue;
  }
  getLatin1String(Y = 0, re = this.byteLength) {
    let oe = this.getUint8Array(Y, re);
    return u(oe);
  }
  getUnicodeString(Y = 0, re = this.byteLength) {
    const oe = [];
    for (let ue = 0; ue < re && Y + ue < this.byteLength; ue += 2) oe.push(this.getUint16(Y + ue));
    return u(oe);
  }
  getInt8(Y) {
    return this.dataView.getInt8(Y);
  }
  getUint8(Y) {
    return this.dataView.getUint8(Y);
  }
  getInt16(Y, re = this.le) {
    return this.dataView.getInt16(Y, re);
  }
  getInt32(Y, re = this.le) {
    return this.dataView.getInt32(Y, re);
  }
  getUint16(Y, re = this.le) {
    return this.dataView.getUint16(Y, re);
  }
  getUint32(Y, re = this.le) {
    return this.dataView.getUint32(Y, re);
  }
  getFloat32(Y, re = this.le) {
    return this.dataView.getFloat32(Y, re);
  }
  getFloat64(Y, re = this.le) {
    return this.dataView.getFloat64(Y, re);
  }
  getFloat(Y, re = this.le) {
    return this.dataView.getFloat32(Y, re);
  }
  getDouble(Y, re = this.le) {
    return this.dataView.getFloat64(Y, re);
  }
  getUintBytes(Y, re, oe) {
    switch (re) {
      case 1:
        return this.getUint8(Y, oe);
      case 2:
        return this.getUint16(Y, oe);
      case 4:
        return this.getUint32(Y, oe);
      case 8:
        return this.getUint64 && this.getUint64(Y, oe);
    }
  }
  getUint(Y, re, oe) {
    switch (re) {
      case 8:
        return this.getUint8(Y, oe);
      case 16:
        return this.getUint16(Y, oe);
      case 32:
        return this.getUint32(Y, oe);
      case 64:
        return this.getUint64 && this.getUint64(Y, oe);
    }
  }
  toString(Y) {
    return this.dataView.toString(Y, this.constructor.name);
  }
  ensureChunk() {
  }
}
function p(le, Y) {
  l(`${le} '${Y}' was not loaded, try using full build of exifr.`);
}
class g extends Map {
  constructor(Y) {
    super(), this.kind = Y;
  }
  get(Y, re) {
    return this.has(Y) || p(this.kind, Y), re && (Y in re || function(oe, ue) {
      l(`Unknown ${oe} '${ue}'.`);
    }(this.kind, Y), re[Y].enabled || p(this.kind, Y)), super.get(Y);
  }
  keyList() {
    return Array.from(this.keys());
  }
}
var m = new g("file parser"), y = new g("segment parser"), b = new g("file reader");
let w = t.fetch;
function k(le, Y) {
  return (re = le).startsWith("data:") || re.length > 1e4 ? v(le, Y, "base64") : n && le.includes("://") ? O(le, Y, "url", S) : n ? v(le, Y, "fs") : s ? O(le, Y, "url", S) : void l("Invalid input argument");
  var re;
}
async function O(le, Y, re, oe) {
  return b.has(re) ? v(le, Y, re) : oe ? async function(ue, fe) {
    let he = await fe(ue);
    return new c(he);
  }(le, oe) : void l(`Parser ${re} is not loaded`);
}
async function v(le, Y, re) {
  let oe = new (b.get(re))(le, Y);
  return await oe.read(), oe;
}
const S = (le) => w(le).then((Y) => Y.arrayBuffer()), A = (le) => new Promise((Y, re) => {
  let oe = new FileReader();
  oe.onloadend = () => Y(oe.result || new ArrayBuffer()), oe.onerror = re, oe.readAsArrayBuffer(le);
}), B = /* @__PURE__ */ new Map(), V = /* @__PURE__ */ new Map(), I = /* @__PURE__ */ new Map(), L = ["chunked", "firstChunkSize", "firstChunkSizeNode", "firstChunkSizeBrowser", "chunkSize", "chunkLimit"], T = ["jfif", "xmp", "icc", "iptc", "ihdr"], z = ["tiff", ...T], P = ["ifd0", "ifd1", "exif", "gps", "interop"], F = [...z, ...P], j = ["makerNote", "userComment"], E = ["translateKeys", "translateValues", "reviveValues", "multiSegment"], M = [...E, "sanitize", "mergeOutput", "silentErrors"];
class _ {
  get translate() {
    return this.translateKeys || this.translateValues || this.reviveValues;
  }
}
class D extends _ {
  get needed() {
    return this.enabled || this.deps.size > 0;
  }
  constructor(Y, re, oe, ue) {
    if (super(), e(this, "enabled", !1), e(this, "skip", /* @__PURE__ */ new Set()), e(this, "pick", /* @__PURE__ */ new Set()), e(this, "deps", /* @__PURE__ */ new Set()), e(this, "translateKeys", !1), e(this, "translateValues", !1), e(this, "reviveValues", !1), this.key = Y, this.enabled = re, this.parse = this.enabled, this.applyInheritables(ue), this.canBeFiltered = P.includes(Y), this.canBeFiltered && (this.dict = B.get(Y)), oe !== void 0) if (Array.isArray(oe)) this.parse = this.enabled = !0, this.canBeFiltered && oe.length > 0 && this.translateTagSet(oe, this.pick);
    else if (typeof oe == "object") {
      if (this.enabled = !0, this.parse = oe.parse !== !1, this.canBeFiltered) {
        let { pick: fe, skip: he } = oe;
        fe && fe.length > 0 && this.translateTagSet(fe, this.pick), he && he.length > 0 && this.translateTagSet(he, this.skip);
      }
      this.applyInheritables(oe);
    } else oe === !0 || oe === !1 ? this.parse = this.enabled = oe : l(`Invalid options argument: ${oe}`);
  }
  applyInheritables(Y) {
    let re, oe;
    for (re of E) oe = Y[re], oe !== void 0 && (this[re] = oe);
  }
  translateTagSet(Y, re) {
    if (this.dict) {
      let oe, ue, { tagKeys: fe, tagValues: he } = this.dict;
      for (oe of Y) typeof oe == "string" ? (ue = he.indexOf(oe), ue === -1 && (ue = fe.indexOf(Number(oe))), ue !== -1 && re.add(Number(fe[ue]))) : re.add(oe);
    } else for (let oe of Y) re.add(oe);
  }
  finalizeFilters() {
    !this.enabled && this.deps.size > 0 ? (this.enabled = !0, X(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && X(this.pick, this.deps);
  }
}
var N = { jfif: !1, tiff: !0, xmp: !1, icc: !1, iptc: !1, ifd0: !0, ifd1: !1, exif: !0, gps: !0, interop: !1, ihdr: void 0, makerNote: !1, userComment: !1, multiSegment: !1, skip: [], pick: [], translateKeys: !0, translateValues: !0, reviveValues: !0, sanitize: !0, mergeOutput: !0, silentErrors: !0, chunked: !0, firstChunkSize: void 0, firstChunkSizeNode: 512, firstChunkSizeBrowser: 65536, chunkSize: 65536, chunkLimit: 5 }, $$1 = /* @__PURE__ */ new Map();
class R extends _ {
  static useCached(Y) {
    let re = $$1.get(Y);
    return re !== void 0 || (re = new this(Y), $$1.set(Y, re)), re;
  }
  constructor(Y) {
    super(), Y === !0 ? this.setupFromTrue() : Y === void 0 ? this.setupFromUndefined() : Array.isArray(Y) ? this.setupFromArray(Y) : typeof Y == "object" ? this.setupFromObject(Y) : l(`Invalid options argument ${Y}`), this.firstChunkSize === void 0 && (this.firstChunkSize = s ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), this.mergeOutput && (this.ifd1.enabled = !1), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), this.checkLoadedPlugins();
  }
  setupFromUndefined() {
    let Y;
    for (Y of L) this[Y] = N[Y];
    for (Y of M) this[Y] = N[Y];
    for (Y of j) this[Y] = N[Y];
    for (Y of F) this[Y] = new D(Y, N[Y], void 0, this);
  }
  setupFromTrue() {
    let Y;
    for (Y of L) this[Y] = N[Y];
    for (Y of M) this[Y] = N[Y];
    for (Y of j) this[Y] = !0;
    for (Y of F) this[Y] = new D(Y, !0, void 0, this);
  }
  setupFromArray(Y) {
    let re;
    for (re of L) this[re] = N[re];
    for (re of M) this[re] = N[re];
    for (re of j) this[re] = N[re];
    for (re of F) this[re] = new D(re, !1, void 0, this);
    this.setupGlobalFilters(Y, void 0, P);
  }
  setupFromObject(Y) {
    let re;
    for (re of (P.ifd0 = P.ifd0 || P.image, P.ifd1 = P.ifd1 || P.thumbnail, Object.assign(this, Y), L)) this[re] = W(Y[re], N[re]);
    for (re of M) this[re] = W(Y[re], N[re]);
    for (re of j) this[re] = W(Y[re], N[re]);
    for (re of z) this[re] = new D(re, N[re], Y[re], this);
    for (re of P) this[re] = new D(re, N[re], Y[re], this.tiff);
    this.setupGlobalFilters(Y.pick, Y.skip, P, F), Y.tiff === !0 ? this.batchEnableWithBool(P, !0) : Y.tiff === !1 ? this.batchEnableWithUserValue(P, Y) : Array.isArray(Y.tiff) ? this.setupGlobalFilters(Y.tiff, void 0, P) : typeof Y.tiff == "object" && this.setupGlobalFilters(Y.tiff.pick, Y.tiff.skip, P);
  }
  batchEnableWithBool(Y, re) {
    for (let oe of Y) this[oe].enabled = re;
  }
  batchEnableWithUserValue(Y, re) {
    for (let oe of Y) {
      let ue = re[oe];
      this[oe].enabled = ue !== !1 && ue !== void 0;
    }
  }
  setupGlobalFilters(Y, re, oe, ue = oe) {
    if (Y && Y.length) {
      for (let he of ue) this[he].enabled = !1;
      let fe = K(Y, oe);
      for (let [he, _e] of fe) X(this[he].pick, _e), this[he].enabled = !0;
    } else if (re && re.length) {
      let fe = K(re, oe);
      for (let [he, _e] of fe) X(this[he].skip, _e);
    }
  }
  filterNestedSegmentTags() {
    let { ifd0: Y, exif: re, xmp: oe, iptc: ue, icc: fe } = this;
    this.makerNote ? re.deps.add(37500) : re.skip.add(37500), this.userComment ? re.deps.add(37510) : re.skip.add(37510), oe.enabled || Y.skip.add(700), ue.enabled || Y.skip.add(33723), fe.enabled || Y.skip.add(34675);
  }
  traverseTiffDependencyTree() {
    let { ifd0: Y, exif: re, gps: oe, interop: ue } = this;
    ue.needed && (re.deps.add(40965), Y.deps.add(40965)), re.needed && Y.deps.add(34665), oe.needed && Y.deps.add(34853), this.tiff.enabled = P.some((fe) => this[fe].enabled === !0) || this.makerNote || this.userComment;
    for (let fe of P) this[fe].finalizeFilters();
  }
  get onlyTiff() {
    return !T.map((Y) => this[Y].enabled).some((Y) => Y === !0) && this.tiff.enabled;
  }
  checkLoadedPlugins() {
    for (let Y of z) this[Y].enabled && !y.has(Y) && p("segment parser", Y);
  }
}
function K(le, Y) {
  let re, oe, ue, fe, he = [];
  for (ue of Y) {
    for (fe of (re = B.get(ue), oe = [], re)) (le.includes(fe[0]) || le.includes(fe[1])) && oe.push(fe[0]);
    oe.length && he.push([ue, oe]);
  }
  return he;
}
function W(le, Y) {
  return le !== void 0 ? le : Y !== void 0 ? Y : void 0;
}
function X(le, Y) {
  for (let re of Y) le.add(re);
}
e(R, "default", N);
class H {
  constructor(Y) {
    e(this, "parsers", {}), e(this, "output", {}), e(this, "errors", []), e(this, "pushToErrors", (re) => this.errors.push(re)), this.options = R.useCached(Y);
  }
  async read(Y) {
    this.file = await function(re, oe) {
      return typeof re == "string" ? k(re, oe) : s && !i && re instanceof HTMLImageElement ? k(re.src, oe) : re instanceof Uint8Array || re instanceof ArrayBuffer || re instanceof DataView ? new c(re) : s && re instanceof Blob ? O(re, oe, "blob", A) : void l("Invalid input argument");
    }(Y, this.options);
  }
  setup() {
    if (this.fileParser) return;
    let { file: Y } = this, re = Y.getUint16(0);
    for (let [oe, ue] of m) if (ue.canHandle(Y, re)) return this.fileParser = new ue(this.options, this.file, this.parsers), Y[oe] = !0;
    this.file.close && this.file.close(), l("Unknown file format");
  }
  async parse() {
    let { output: Y, errors: re } = this;
    return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), re.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), this.options.silentErrors && re.length > 0 && (Y.errors = re), f(oe = Y) ? void 0 : oe;
    var oe;
  }
  async executeParsers() {
    let { output: Y } = this;
    await this.fileParser.parse();
    let re = Object.values(this.parsers).map(async (oe) => {
      let ue = await oe.parse();
      oe.assignToOutput(Y, ue);
    });
    this.options.silentErrors && (re = re.map((oe) => oe.catch(this.pushToErrors))), await Promise.all(re);
  }
  async extractThumbnail() {
    this.setup();
    let { options: Y, file: re } = this, oe = y.get("tiff", Y);
    var ue;
    if (re.tiff ? ue = { start: 0, type: "tiff" } : re.jpeg && (ue = await this.fileParser.getOrFindSegment("tiff")), ue === void 0) return;
    let fe = await this.fileParser.ensureSegmentChunk(ue), he = this.parsers.tiff = new oe(fe, Y, re), _e = await he.extractThumbnail();
    return re.close && re.close(), _e;
  }
}
class J {
  static findPosition(Y, re) {
    let oe = Y.getUint16(re + 2) + 2, ue = typeof this.headerLength == "function" ? this.headerLength(Y, re, oe) : this.headerLength, fe = re + ue, he = oe - ue;
    return { offset: re, length: oe, headerLength: ue, start: fe, size: he, end: fe + he };
  }
  static parse(Y, re = {}) {
    return new this(Y, new R({ [this.type]: re }), Y).parse();
  }
  normalizeInput(Y) {
    return Y instanceof c ? Y : new c(Y);
  }
  constructor(Y, re = {}, oe) {
    e(this, "errors", []), e(this, "raw", /* @__PURE__ */ new Map()), e(this, "handleError", (ue) => {
      if (!this.options.silentErrors) throw ue;
      this.errors.push(ue.message);
    }), this.chunk = this.normalizeInput(Y), this.file = oe, this.type = this.constructor.type, this.globalOptions = this.options = re, this.localOptions = re[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;
  }
  translate() {
    this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));
  }
  get output() {
    return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0;
  }
  translateBlock(Y, re) {
    let oe = I.get(re), ue = V.get(re), fe = B.get(re), he = this.options[re], _e = he.reviveValues && !!oe, ve = he.translateValues && !!ue, xe = he.translateKeys && !!fe, Ee = {};
    for (let [Se, Te] of Y) _e && oe.has(Se) ? Te = oe.get(Se)(Te) : ve && ue.has(Se) && (Te = this.translateValue(Te, ue.get(Se))), xe && fe.has(Se) && (Se = fe.get(Se) || Se), Ee[Se] = Te;
    return Ee;
  }
  translateValue(Y, re) {
    return re[Y] || re.DEFAULT || Y;
  }
  assignToOutput(Y, re) {
    this.assignObjectToOutput(Y, this.constructor.type, re);
  }
  assignObjectToOutput(Y, re, oe) {
    if (this.globalOptions.mergeOutput) return Object.assign(Y, oe);
    Y[re] ? Object.assign(Y[re], oe) : Y[re] = oe;
  }
}
e(J, "headerLength", 4), e(J, "type", void 0), e(J, "multiSegment", !1), e(J, "canHandle", () => !1);
function q(le) {
  return le === 192 || le === 194 || le === 196 || le === 219 || le === 221 || le === 218 || le === 254;
}
function Q(le) {
  return le >= 224 && le <= 239;
}
function Z(le, Y, re) {
  for (let [oe, ue] of y) if (ue.canHandle(le, Y, re)) return oe;
}
class ee extends class {
  constructor(Y, re, oe) {
    e(this, "errors", []), e(this, "ensureSegmentChunk", async (ue) => {
      let fe = ue.start, he = ue.size || 65536;
      if (this.file.chunked) if (this.file.available(fe, he)) ue.chunk = this.file.subarray(fe, he);
      else try {
        ue.chunk = await this.file.readChunk(fe, he);
      } catch (_e) {
        l(`Couldn't read segment: ${JSON.stringify(ue)}. ${_e.message}`);
      }
      else this.file.byteLength > fe + he ? ue.chunk = this.file.subarray(fe, he) : ue.size === void 0 ? ue.chunk = this.file.subarray(fe) : l("Segment unreachable: " + JSON.stringify(ue));
      return ue.chunk;
    }), this.extendOptions && this.extendOptions(Y), this.options = Y, this.file = re, this.parsers = oe;
  }
  injectSegment(Y, re) {
    this.options[Y].enabled && this.createParser(Y, re);
  }
  createParser(Y, re) {
    let oe = new (y.get(Y))(re, this.options, this.file);
    return this.parsers[Y] = oe;
  }
  createParsers(Y) {
    for (let re of Y) {
      let { type: oe, chunk: ue } = re, fe = this.options[oe];
      if (fe && fe.enabled) {
        let he = this.parsers[oe];
        he && he.append || he || this.createParser(oe, ue);
      }
    }
  }
  async readSegments(Y) {
    let re = Y.map(this.ensureSegmentChunk);
    await Promise.all(re);
  }
} {
  constructor(...Y) {
    super(...Y), e(this, "appSegments", []), e(this, "jpegSegments", []), e(this, "unknownSegments", []);
  }
  static canHandle(Y, re) {
    return re === 65496;
  }
  async parse() {
    await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), this.createParsers(this.mergedAppSegments || this.appSegments);
  }
  setupSegmentFinderArgs(Y) {
    Y === !0 ? (this.findAll = !0, this.wanted = new Set(y.keyList())) : (Y = Y === void 0 ? y.keyList().filter((re) => this.options[re].enabled) : Y.filter((re) => this.options[re].enabled && y.has(re)), this.findAll = !1, this.remaining = new Set(Y), this.wanted = new Set(Y)), this.unfinishedMultiSegment = !1;
  }
  async findAppSegments(Y = 0, re) {
    this.setupSegmentFinderArgs(re);
    let { file: oe, findAll: ue, wanted: fe, remaining: he } = this;
    if (!ue && this.file.chunked && (ue = Array.from(fe).some((_e) => {
      let ve = y.get(_e), xe = this.options[_e];
      return ve.multiSegment && xe.multiSegment;
    }), ue && await this.file.readWhole()), Y = this.findAppSegmentsInRange(Y, oe.byteLength), !this.options.onlyTiff && oe.chunked) {
      let _e = !1;
      for (; he.size > 0 && !_e && (oe.canReadNextChunk || this.unfinishedMultiSegment); ) {
        let { nextChunkOffset: ve } = oe, xe = this.appSegments.some((Ee) => !this.file.available(Ee.offset || Ee.start, Ee.length || Ee.size));
        if (_e = Y > ve && !xe ? !await oe.readNextChunk(Y) : !await oe.readNextChunk(ve), (Y = this.findAppSegmentsInRange(Y, oe.byteLength)) === void 0) return;
      }
    }
  }
  findAppSegmentsInRange(Y, re) {
    re -= 2;
    let oe, ue, fe, he, _e, ve, { file: xe, findAll: Ee, wanted: Se, remaining: Te, options: Ce } = this;
    for (; Y < re; Y++) if (xe.getUint8(Y) === 255) {
      if (oe = xe.getUint8(Y + 1), Q(oe)) {
        if (ue = xe.getUint16(Y + 2), fe = Z(xe, Y, ue), fe && Se.has(fe) && (he = y.get(fe), _e = he.findPosition(xe, Y), ve = Ce[fe], _e.type = fe, this.appSegments.push(_e), !Ee && (he.multiSegment && ve.multiSegment ? (this.unfinishedMultiSegment = _e.chunkNumber < _e.chunkCount, this.unfinishedMultiSegment || Te.delete(fe)) : Te.delete(fe), Te.size === 0))) break;
        Ce.recordUnknownSegments && (_e = J.findPosition(xe, Y), _e.marker = oe, this.unknownSegments.push(_e)), Y += ue + 1;
      } else if (q(oe)) {
        if (ue = xe.getUint16(Y + 2), oe === 218 && Ce.stopAfterSos !== !1) return;
        Ce.recordJpegSegments && this.jpegSegments.push({ offset: Y, length: ue, marker: oe }), Y += ue + 1;
      }
    }
    return Y;
  }
  mergeMultiSegments() {
    if (!this.appSegments.some((re) => re.multiSegment)) return;
    let Y = function(re, oe) {
      let ue, fe, he, _e = /* @__PURE__ */ new Map();
      for (let ve = 0; ve < re.length; ve++) ue = re[ve], fe = ue[oe], _e.has(fe) ? he = _e.get(fe) : _e.set(fe, he = []), he.push(ue);
      return Array.from(_e);
    }(this.appSegments, "type");
    this.mergedAppSegments = Y.map(([re, oe]) => {
      let ue = y.get(re, this.options);
      return ue.handleMultiSegments ? { type: re, chunk: ue.handleMultiSegments(oe) } : oe[0];
    });
  }
  getSegment(Y) {
    return this.appSegments.find((re) => re.type === Y);
  }
  async getOrFindSegment(Y) {
    let re = this.getSegment(Y);
    return re === void 0 && (await this.findAppSegments(0, [Y]), re = this.getSegment(Y)), re;
  }
}
e(ee, "type", "jpeg"), m.set("jpeg", ee);
const te = [void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4];
class se extends J {
  parseHeader() {
    var Y = this.chunk.getUint16();
    Y === 18761 ? this.le = !0 : Y === 19789 && (this.le = !1), this.chunk.le = this.le, this.headerParsed = !0;
  }
  parseTags(Y, re, oe = /* @__PURE__ */ new Map()) {
    let { pick: ue, skip: fe } = this.options[re];
    ue = new Set(ue);
    let he = ue.size > 0, _e = fe.size === 0, ve = this.chunk.getUint16(Y);
    Y += 2;
    for (let xe = 0; xe < ve; xe++) {
      let Ee = this.chunk.getUint16(Y);
      if (he) {
        if (ue.has(Ee) && (oe.set(Ee, this.parseTag(Y, Ee, re)), ue.delete(Ee), ue.size === 0)) break;
      } else !_e && fe.has(Ee) || oe.set(Ee, this.parseTag(Y, Ee, re));
      Y += 12;
    }
    return oe;
  }
  parseTag(Y, re, oe) {
    let { chunk: ue } = this, fe = ue.getUint16(Y + 2), he = ue.getUint32(Y + 4), _e = te[fe];
    if (_e * he <= 4 ? Y += 8 : Y = ue.getUint32(Y + 8), (fe < 1 || fe > 13) && l(`Invalid TIFF value type. block: ${oe.toUpperCase()}, tag: ${re.toString(16)}, type: ${fe}, offset ${Y}`), Y > ue.byteLength && l(`Invalid TIFF value offset. block: ${oe.toUpperCase()}, tag: ${re.toString(16)}, type: ${fe}, offset ${Y} is outside of chunk size ${ue.byteLength}`), fe === 1) return ue.getUint8Array(Y, he);
    if (fe === 2) return (ve = function(xe) {
      for (; xe.endsWith("\0"); ) xe = xe.slice(0, -1);
      return xe;
    }(ve = ue.getString(Y, he)).trim()) === "" ? void 0 : ve;
    var ve;
    if (fe === 7) return ue.getUint8Array(Y, he);
    if (he === 1) return this.parseTagValue(fe, Y);
    {
      let xe = new (function(Se) {
        switch (Se) {
          case 1:
            return Uint8Array;
          case 3:
            return Uint16Array;
          case 4:
            return Uint32Array;
          case 5:
            return Array;
          case 6:
            return Int8Array;
          case 8:
            return Int16Array;
          case 9:
            return Int32Array;
          case 10:
            return Array;
          case 11:
            return Float32Array;
          case 12:
            return Float64Array;
          default:
            return Array;
        }
      }(fe))(he), Ee = _e;
      for (let Se = 0; Se < he; Se++) xe[Se] = this.parseTagValue(fe, Y), Y += Ee;
      return xe;
    }
  }
  parseTagValue(Y, re) {
    let { chunk: oe } = this;
    switch (Y) {
      case 1:
        return oe.getUint8(re);
      case 3:
        return oe.getUint16(re);
      case 4:
        return oe.getUint32(re);
      case 5:
        return oe.getUint32(re) / oe.getUint32(re + 4);
      case 6:
        return oe.getInt8(re);
      case 8:
        return oe.getInt16(re);
      case 9:
        return oe.getInt32(re);
      case 10:
        return oe.getInt32(re) / oe.getInt32(re + 4);
      case 11:
        return oe.getFloat(re);
      case 12:
        return oe.getDouble(re);
      case 13:
        return oe.getUint32(re);
      default:
        l(`Invalid tiff type ${Y}`);
    }
  }
}
class ie extends se {
  static canHandle(Y, re) {
    return Y.getUint8(re + 1) === 225 && Y.getUint32(re + 4) === 1165519206 && Y.getUint16(re + 8) === 0;
  }
  async parse() {
    this.parseHeader();
    let { options: Y } = this;
    return Y.ifd0.enabled && await this.parseIfd0Block(), Y.exif.enabled && await this.safeParse("parseExifBlock"), Y.gps.enabled && await this.safeParse("parseGpsBlock"), Y.interop.enabled && await this.safeParse("parseInteropBlock"), Y.ifd1.enabled && await this.safeParse("parseThumbnailBlock"), this.createOutput();
  }
  safeParse(Y) {
    let re = this[Y]();
    return re.catch !== void 0 && (re = re.catch(this.handleError)), re;
  }
  findIfd0Offset() {
    this.ifd0Offset === void 0 && (this.ifd0Offset = this.chunk.getUint32(4));
  }
  findIfd1Offset() {
    if (this.ifd1Offset === void 0) {
      this.findIfd0Offset();
      let Y = this.chunk.getUint16(this.ifd0Offset), re = this.ifd0Offset + 2 + 12 * Y;
      this.ifd1Offset = this.chunk.getUint32(re);
    }
  }
  parseBlock(Y, re) {
    let oe = /* @__PURE__ */ new Map();
    return this[re] = oe, this.parseTags(Y, re, oe), oe;
  }
  async parseIfd0Block() {
    if (this.ifd0) return;
    let { file: Y } = this;
    this.findIfd0Offset(), this.ifd0Offset < 8 && l("Malformed EXIF data"), !Y.chunked && this.ifd0Offset > Y.byteLength && l(`IFD0 offset points to outside of file.
this.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${Y.byteLength}`), Y.tiff && await Y.ensureChunk(this.ifd0Offset, o(this.options));
    let re = this.parseBlock(this.ifd0Offset, "ifd0");
    return re.size !== 0 ? (this.exifOffset = re.get(34665), this.interopOffset = re.get(40965), this.gpsOffset = re.get(34853), this.xmp = re.get(700), this.iptc = re.get(33723), this.icc = re.get(34675), this.options.sanitize && (re.delete(34665), re.delete(40965), re.delete(34853), re.delete(700), re.delete(33723), re.delete(34675)), re) : void 0;
  }
  async parseExifBlock() {
    if (this.exif || (this.ifd0 || await this.parseIfd0Block(), this.exifOffset === void 0)) return;
    this.file.tiff && await this.file.ensureChunk(this.exifOffset, o(this.options));
    let Y = this.parseBlock(this.exifOffset, "exif");
    return this.interopOffset || (this.interopOffset = Y.get(40965)), this.makerNote = Y.get(37500), this.userComment = Y.get(37510), this.options.sanitize && (Y.delete(40965), Y.delete(37500), Y.delete(37510)), this.unpack(Y, 41728), this.unpack(Y, 41729), Y;
  }
  unpack(Y, re) {
    let oe = Y.get(re);
    oe && oe.length === 1 && Y.set(re, oe[0]);
  }
  async parseGpsBlock() {
    if (this.gps || (this.ifd0 || await this.parseIfd0Block(), this.gpsOffset === void 0)) return;
    let Y = this.parseBlock(this.gpsOffset, "gps");
    return Y && Y.has(2) && Y.has(4) && (Y.set("latitude", ne(...Y.get(2), Y.get(1))), Y.set("longitude", ne(...Y.get(4), Y.get(3)))), Y;
  }
  async parseInteropBlock() {
    if (!this.interop && (this.ifd0 || await this.parseIfd0Block(), this.interopOffset !== void 0 || this.exif || await this.parseExifBlock(), this.interopOffset !== void 0)) return this.parseBlock(this.interopOffset, "interop");
  }
  async parseThumbnailBlock(Y = !1) {
    if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || Y)) return this.findIfd1Offset(), this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, "ifd1"), this.ifd1Parsed = !0), this.ifd1;
  }
  async extractThumbnail() {
    if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || await this.parseThumbnailBlock(!0), this.ifd1 === void 0) return;
    let Y = this.ifd1.get(513), re = this.ifd1.get(514);
    return this.chunk.getUint8Array(Y, re);
  }
  get image() {
    return this.ifd0;
  }
  get thumbnail() {
    return this.ifd1;
  }
  createOutput() {
    let Y, re, oe, ue = {};
    for (re of P) if (Y = this[re], !f(Y)) if (oe = this.canTranslate ? this.translateBlock(Y, re) : Object.fromEntries(Y), this.options.mergeOutput) {
      if (re === "ifd1") continue;
      Object.assign(ue, oe);
    } else ue[re] = oe;
    return this.makerNote && (ue.makerNote = this.makerNote), this.userComment && (ue.userComment = this.userComment), ue;
  }
  assignToOutput(Y, re) {
    if (this.globalOptions.mergeOutput) Object.assign(Y, re);
    else for (let [oe, ue] of Object.entries(re)) this.assignObjectToOutput(Y, oe, ue);
  }
}
function ne(le, Y, re, oe) {
  var ue = le + Y / 60 + re / 3600;
  return oe !== "S" && oe !== "W" || (ue *= -1), ue;
}
e(ie, "type", "tiff"), e(ie, "headerLength", 10), y.set("tiff", ie);
const ae = { ifd0: !1, ifd1: !1, exif: !1, gps: !1, interop: !1, sanitize: !1, reviveValues: !0, translateKeys: !1, translateValues: !1, mergeOutput: !1 };
Object.assign({}, ae, { firstChunkSize: 4e4, gps: [1, 2, 3, 4] });
Object.assign({}, ae, { tiff: !1, ifd1: !0, mergeOutput: !1 });
const de = Object.assign({}, ae, { firstChunkSize: 4e4, ifd0: [274] });
async function ce(le) {
  let Y = new H(de);
  await Y.read(le);
  let re = await Y.parse();
  if (re && re.ifd0) return re.ifd0[274];
}
const pe = Object.freeze({ 1: { dimensionSwapped: !1, scaleX: 1, scaleY: 1, deg: 0, rad: 0 }, 2: { dimensionSwapped: !1, scaleX: -1, scaleY: 1, deg: 0, rad: 0 }, 3: { dimensionSwapped: !1, scaleX: 1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 4: { dimensionSwapped: !1, scaleX: -1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 5: { dimensionSwapped: !0, scaleX: 1, scaleY: -1, deg: 90, rad: 90 * Math.PI / 180 }, 6: { dimensionSwapped: !0, scaleX: 1, scaleY: 1, deg: 90, rad: 90 * Math.PI / 180 }, 7: { dimensionSwapped: !0, scaleX: 1, scaleY: -1, deg: 270, rad: 270 * Math.PI / 180 }, 8: { dimensionSwapped: !0, scaleX: 1, scaleY: 1, deg: 270, rad: 270 * Math.PI / 180 } });
let ge = !0, me = !0;
if (typeof navigator == "object") {
  let le = navigator.userAgent;
  if (le.includes("iPad") || le.includes("iPhone")) {
    let Y = le.match(/OS (\d+)_(\d+)/);
    if (Y) {
      let [, re, oe] = Y;
      ge = Number(re) + 0.1 * Number(oe) < 13.4, me = !1;
    }
  } else if (le.includes("OS X 10")) {
    let [, Y] = le.match(/OS X 10[_.](\d+)/);
    ge = me = Number(Y) < 15;
  }
  if (le.includes("Chrome/")) {
    let [, Y] = le.match(/Chrome\/(\d+)/);
    ge = me = Number(Y) < 81;
  } else if (le.includes("Firefox/")) {
    let [, Y] = le.match(/Firefox\/(\d+)/);
    ge = me = Number(Y) < 77;
  }
}
async function ye(le) {
  let Y = await ce(le);
  return Object.assign({ canvas: ge, css: me }, pe[Y]);
}
class be extends c {
  constructor(...Y) {
    super(...Y), e(this, "ranges", new we()), this.byteLength !== 0 && this.ranges.add(0, this.byteLength);
  }
  _tryExtend(Y, re, oe) {
    if (Y === 0 && this.byteLength === 0 && oe) {
      let ue = new DataView(oe.buffer || oe, oe.byteOffset, oe.byteLength);
      this._swapDataView(ue);
    } else {
      let ue = Y + re;
      if (ue > this.byteLength) {
        let { dataView: fe } = this._extend(ue);
        this._swapDataView(fe);
      }
    }
  }
  _extend(Y) {
    let re;
    re = a ? r.allocUnsafe(Y) : new Uint8Array(Y);
    let oe = new DataView(re.buffer, re.byteOffset, re.byteLength);
    return re.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), { uintView: re, dataView: oe };
  }
  subarray(Y, re, oe = !1) {
    return re = re || this._lengthToEnd(Y), oe && this._tryExtend(Y, re), this.ranges.add(Y, re), super.subarray(Y, re);
  }
  set(Y, re, oe = !1) {
    oe && this._tryExtend(re, Y.byteLength, Y);
    let ue = super.set(Y, re);
    return this.ranges.add(re, ue.byteLength), ue;
  }
  async ensureChunk(Y, re) {
    this.chunked && (this.ranges.available(Y, re) || await this.readChunk(Y, re));
  }
  available(Y, re) {
    return this.ranges.available(Y, re);
  }
}
class we {
  constructor() {
    e(this, "list", []);
  }
  get length() {
    return this.list.length;
  }
  add(Y, re, oe = 0) {
    let ue = Y + re, fe = this.list.filter((he) => ke(Y, he.offset, ue) || ke(Y, he.end, ue));
    if (fe.length > 0) {
      Y = Math.min(Y, ...fe.map((_e) => _e.offset)), ue = Math.max(ue, ...fe.map((_e) => _e.end)), re = ue - Y;
      let he = fe.shift();
      he.offset = Y, he.length = re, he.end = ue, this.list = this.list.filter((_e) => !fe.includes(_e));
    } else this.list.push({ offset: Y, length: re, end: ue });
  }
  available(Y, re) {
    let oe = Y + re;
    return this.list.some((ue) => ue.offset <= Y && oe <= ue.end);
  }
}
function ke(le, Y, re) {
  return le <= Y && Y <= re;
}
class Oe extends be {
  constructor(Y, re) {
    super(0), e(this, "chunksRead", 0), this.input = Y, this.options = re;
  }
  async readWhole() {
    this.chunked = !1, await this.readChunk(this.nextChunkOffset);
  }
  async readChunked() {
    this.chunked = !0, await this.readChunk(0, this.options.firstChunkSize);
  }
  async readNextChunk(Y = this.nextChunkOffset) {
    if (this.fullyRead) return this.chunksRead++, !1;
    let re = this.options.chunkSize, oe = await this.readChunk(Y, re);
    return !!oe && oe.byteLength === re;
  }
  async readChunk(Y, re) {
    if (this.chunksRead++, (re = this.safeWrapAddress(Y, re)) !== 0) return this._readChunk(Y, re);
  }
  safeWrapAddress(Y, re) {
    return this.size !== void 0 && Y + re > this.size ? Math.max(0, this.size - Y) : re;
  }
  get nextChunkOffset() {
    if (this.ranges.list.length !== 0) return this.ranges.list[0].length;
  }
  get canReadNextChunk() {
    return this.chunksRead < this.options.chunkLimit;
  }
  get fullyRead() {
    return this.size !== void 0 && this.nextChunkOffset === this.size;
  }
  read() {
    return this.options.chunked ? this.readChunked() : this.readWhole();
  }
  close() {
  }
}
b.set("blob", class extends Oe {
  async readWhole() {
    this.chunked = !1;
    let le = await A(this.input);
    this._swapArrayBuffer(le);
  }
  readChunked() {
    return this.chunked = !0, this.size = this.input.size, super.readChunked();
  }
  async _readChunk(le, Y) {
    let re = Y ? le + Y : void 0, oe = this.input.slice(le, re), ue = await A(oe);
    return this.set(ue, le, !0);
  }
});
const locale$3 = {
  strings: {
    generatingThumbnails: "Generating thumbnails..."
  }
}, packageJson$2 = {
  version: "4.1.1"
};
function canvasToBlob$1(le, Y, re) {
  try {
    le.getContext("2d").getImageData(0, 0, 1, 1);
  } catch (oe) {
    if (oe.code === 18)
      return Promise.reject(new Error("cannot read image, probably an svg with external resources"));
  }
  return le.toBlob ? new Promise((oe) => {
    le.toBlob(oe, Y, re);
  }).then((oe) => {
    if (oe === null)
      throw new Error("cannot read image, probably an svg with external resources");
    return oe;
  }) : Promise.resolve().then(() => dataURItoBlob(le.toDataURL(Y, re), {})).then((oe) => {
    if (oe === null)
      throw new Error("could not extract blob, probably an old browser");
    return oe;
  });
}
function rotateImage(le, Y) {
  let re = le.width, oe = le.height;
  (Y.deg === 90 || Y.deg === 270) && (re = le.height, oe = le.width);
  const ue = document.createElement("canvas");
  ue.width = re, ue.height = oe;
  const fe = ue.getContext("2d");
  return fe.translate(re / 2, oe / 2), Y.canvas && (fe.rotate(Y.rad), fe.scale(Y.scaleX, Y.scaleY)), fe.drawImage(le, -le.width / 2, -le.height / 2, le.width, le.height), ue;
}
function protect(le) {
  const Y = le.width / le.height, re = 5e6, oe = 4096;
  let ue = Math.floor(Math.sqrt(re * Y)), fe = Math.floor(re / Math.sqrt(re * Y));
  if (ue > oe && (ue = oe, fe = Math.round(ue / Y)), fe > oe && (fe = oe, ue = Math.round(Y * fe)), le.width > ue) {
    const he = document.createElement("canvas");
    return he.width = ue, he.height = fe, he.getContext("2d").drawImage(le, 0, 0, ue, fe), he;
  }
  return le;
}
const defaultOptions$4 = {
  thumbnailWidth: null,
  thumbnailHeight: null,
  thumbnailType: "image/jpeg",
  waitForThumbnailsBeforeUpload: !1,
  lazy: !1
};
class ThumbnailGenerator extends UIPlugin {
  constructor(Y, re) {
    if (super(Y, {
      ...defaultOptions$4,
      ...re
    }), this.onFileAdded = (oe) => {
      !oe.preview && oe.data && isPreviewSupported(oe.type) && !oe.isRemote && this.addToQueue(oe.id);
    }, this.onCancelRequest = (oe) => {
      const ue = this.queue.indexOf(oe.id);
      ue !== -1 && this.queue.splice(ue, 1);
    }, this.onFileRemoved = (oe) => {
      const ue = this.queue.indexOf(oe.id);
      ue !== -1 && this.queue.splice(ue, 1), oe.preview && isObjectURL(oe.preview) && URL.revokeObjectURL(oe.preview);
    }, this.onRestored = () => {
      this.uppy.getFiles().filter((ue) => ue.isRestored).forEach((ue) => {
        (!ue.preview || isObjectURL(ue.preview)) && this.addToQueue(ue.id);
      });
    }, this.onAllFilesRemoved = () => {
      this.queue = [];
    }, this.waitUntilAllProcessed = (oe) => {
      oe.forEach((fe) => {
        const he = this.uppy.getFile(fe);
        this.uppy.emit("preprocess-progress", he, {
          mode: "indeterminate",
          message: this.i18n("generatingThumbnails")
        });
      });
      const ue = () => {
        oe.forEach((fe) => {
          const he = this.uppy.getFile(fe);
          this.uppy.emit("preprocess-complete", he);
        });
      };
      return new Promise((fe) => {
        this.queueProcessing ? this.uppy.once("thumbnail:all-generated", () => {
          ue(), fe();
        }) : (ue(), fe());
      });
    }, this.type = "modifier", this.id = this.opts.id || "ThumbnailGenerator", this.title = "Thumbnail Generator", this.queue = [], this.queueProcessing = !1, this.defaultThumbnailDimension = 200, this.thumbnailType = this.opts.thumbnailType, this.defaultLocale = locale$3, this.i18nInit(), this.opts.lazy && this.opts.waitForThumbnailsBeforeUpload)
      throw new Error("ThumbnailGenerator: The `lazy` and `waitForThumbnailsBeforeUpload` options are mutually exclusive. Please ensure at most one of them is set to `true`.");
  }
  createThumbnail(Y, re, oe) {
    const ue = URL.createObjectURL(Y.data), fe = new Promise((_e, ve) => {
      const xe = new Image();
      xe.src = ue, xe.addEventListener("load", () => {
        URL.revokeObjectURL(ue), _e(xe);
      }), xe.addEventListener("error", (Ee) => {
        URL.revokeObjectURL(ue), ve(Ee.error || new Error("Could not create thumbnail"));
      });
    }), he = ye(Y.data).catch(() => 1);
    return Promise.all([fe, he]).then((_e) => {
      let [ve, xe] = _e;
      const Ee = this.getProportionalDimensions(ve, re, oe, xe.deg), Se = rotateImage(ve, xe), Te = this.resizeImage(Se, Ee.width, Ee.height);
      return canvasToBlob$1(Te, this.thumbnailType, 80);
    }).then((_e) => URL.createObjectURL(_e));
  }
  /**
   * Get the new calculated dimensions for the given image and a target width
   * or height. If both width and height are given, only width is taken into
   * account. If neither width nor height are given, the default dimension
   * is used.
   */
  getProportionalDimensions(Y, re, oe, ue) {
    let fe = Y.width / Y.height;
    return (ue === 90 || ue === 270) && (fe = Y.height / Y.width), re != null ? {
      width: re,
      height: Math.round(re / fe)
    } : oe != null ? {
      width: Math.round(oe * fe),
      height: oe
    } : {
      width: this.defaultThumbnailDimension,
      height: Math.round(this.defaultThumbnailDimension / fe)
    };
  }
  /**
   * Resize an image to the target `width` and `height`.
   *
   * Returns a Canvas with the resized image on it.
   */
  // eslint-disable-next-line class-methods-use-this
  resizeImage(Y, re, oe) {
    let ue = protect(Y), fe = Math.ceil(Math.log2(ue.width / re));
    fe < 1 && (fe = 1);
    let he = re * 2 ** (fe - 1), _e = oe * 2 ** (fe - 1);
    const ve = 2;
    for (; fe--; ) {
      const xe = document.createElement("canvas");
      xe.width = he, xe.height = _e, xe.getContext("2d").drawImage(ue, 0, 0, he, _e), ue = xe, he = Math.round(he / ve), _e = Math.round(_e / ve);
    }
    return ue;
  }
  /**
   * Set the preview URL for a file.
   */
  setPreviewURL(Y, re) {
    this.uppy.setFileState(Y, {
      preview: re
    });
  }
  addToQueue(Y) {
    this.queue.push(Y), this.queueProcessing === !1 && this.processQueue();
  }
  processQueue() {
    if (this.queueProcessing = !0, this.queue.length > 0) {
      const Y = this.uppy.getFile(this.queue.shift());
      return Y ? this.requestThumbnail(Y).catch(() => {
      }).then(() => this.processQueue()) : (this.uppy.log("[ThumbnailGenerator] file was removed before a thumbnail could be generated, but not removed from the queue. This is probably a bug", "error"), Promise.resolve());
    }
    return this.queueProcessing = !1, this.uppy.log("[ThumbnailGenerator] Emptied thumbnail queue"), this.uppy.emit("thumbnail:all-generated"), Promise.resolve();
  }
  requestThumbnail(Y) {
    return isPreviewSupported(Y.type) && !Y.isRemote ? this.createThumbnail(Y, this.opts.thumbnailWidth, this.opts.thumbnailHeight).then((re) => {
      this.setPreviewURL(Y.id, re), this.uppy.log(`[ThumbnailGenerator] Generated thumbnail for ${Y.id}`), this.uppy.emit("thumbnail:generated", this.uppy.getFile(Y.id), re);
    }).catch((re) => {
      this.uppy.log(`[ThumbnailGenerator] Failed thumbnail for ${Y.id}:`, "warning"), this.uppy.log(re, "warning"), this.uppy.emit("thumbnail:error", this.uppy.getFile(Y.id), re);
    }) : Promise.resolve();
  }
  install() {
    this.uppy.on("file-removed", this.onFileRemoved), this.uppy.on("cancel-all", this.onAllFilesRemoved), this.opts.lazy ? (this.uppy.on("thumbnail:request", this.onFileAdded), this.uppy.on("thumbnail:cancel", this.onCancelRequest)) : (this.uppy.on("thumbnail:request", this.onFileAdded), this.uppy.on("file-added", this.onFileAdded), this.uppy.on("restored", this.onRestored)), this.opts.waitForThumbnailsBeforeUpload && this.uppy.addPreProcessor(this.waitUntilAllProcessed);
  }
  uninstall() {
    this.uppy.off("file-removed", this.onFileRemoved), this.uppy.off("cancel-all", this.onAllFilesRemoved), this.opts.lazy ? (this.uppy.off("thumbnail:request", this.onFileAdded), this.uppy.off("thumbnail:cancel", this.onCancelRequest)) : (this.uppy.off("thumbnail:request", this.onFileAdded), this.uppy.off("file-added", this.onFileAdded), this.uppy.off("restored", this.onRestored)), this.opts.waitForThumbnailsBeforeUpload && this.uppy.removePreProcessor(this.waitUntilAllProcessed);
  }
}
ThumbnailGenerator.VERSION = packageJson$2.version;
function findAllDOMElements(le) {
  if (typeof le == "string") {
    const Y = document.querySelectorAll(le);
    return Y.length === 0 ? null : Array.from(Y);
  }
  return typeof le == "object" && isDOMElement(le) ? [le] : null;
}
const toArray$2 = Array.from;
function getFilesAndDirectoriesFromDirectory(le, Y, re, oe) {
  let {
    onSuccess: ue
  } = oe;
  le.readEntries(
    (fe) => {
      const he = [...Y, ...fe];
      fe.length ? queueMicrotask(() => {
        getFilesAndDirectoriesFromDirectory(le, he, re, {
          onSuccess: ue
        });
      }) : ue(he);
    },
    // Make sure we resolve on error anyway, it's fine if only one directory couldn't be parsed!
    (fe) => {
      re(fe), ue(Y);
    }
  );
}
function getAsFileSystemHandleFromEntry(le, Y) {
  return le == null ? le : {
    kind: (
      // eslint-disable-next-line no-nested-ternary
      le.isFile ? "file" : le.isDirectory ? "directory" : void 0
    ),
    name: le.name,
    getFile() {
      return new Promise((re, oe) => le.file(re, oe));
    },
    async *values() {
      const re = le.createReader();
      yield* await new Promise((ue) => {
        getFilesAndDirectoriesFromDirectory(re, [], Y, {
          onSuccess: (fe) => ue(fe.map((he) => getAsFileSystemHandleFromEntry(he, Y)))
        });
      });
    },
    isSameEntry: void 0
  };
}
function createPromiseToAddFileOrParseDirectory(le, Y, re) {
  try {
    return re === void 0 && (re = void 0), async function* () {
      const oe = () => `${Y}/${le.name}`;
      if (le.kind === "file") {
        const ue = await le.getFile();
        ue != null ? (ue.relativePath = Y ? oe() : null, yield ue) : re != null && (yield re);
      } else if (le.kind === "directory")
        for await (const ue of le.values())
          yield* createPromiseToAddFileOrParseDirectory(ue, Y ? oe() : le.name);
      else re != null && (yield re);
    }();
  } catch (oe) {
    return Promise.reject(oe);
  }
}
async function* getFilesFromDataTransfer(le, Y) {
  const re = await Promise.all(Array.from(le.items, async (oe) => {
    let ue;
    return ue ?? (ue = getAsFileSystemHandleFromEntry(typeof oe.getAsEntry == "function" ? oe.getAsEntry() : oe.webkitGetAsEntry(), Y)), {
      fileSystemHandle: ue,
      lastResortFile: oe.getAsFile()
      // can be used as a fallback in case other methods fail
    };
  }));
  for (const {
    lastResortFile: oe,
    fileSystemHandle: ue
  } of re)
    if (ue != null)
      try {
        yield* createPromiseToAddFileOrParseDirectory(ue, "", oe);
      } catch (fe) {
        oe != null ? yield oe : Y(fe);
      }
    else oe != null && (yield oe);
}
function fallbackApi(le) {
  const Y = toArray$2(le.files);
  return Promise.resolve(Y);
}
async function getDroppedFiles(le, Y) {
  var re;
  const oe = (re = Y?.logDropError) != null ? re : Function.prototype;
  try {
    const ue = [];
    for await (const fe of getFilesFromDataTransfer(le, oe))
      ue.push(fe);
    return ue;
  } catch {
    return fallbackApi(le);
  }
}
function _extends$2() {
  return _extends$2 = Object.assign ? Object.assign.bind() : function(le) {
    for (var Y = 1; Y < arguments.length; Y++) {
      var re = arguments[Y];
      for (var oe in re) ({}).hasOwnProperty.call(re, oe) && (le[oe] = re[oe]);
    }
    return le;
  }, _extends$2.apply(null, arguments);
}
const STYLE_INNER = {
  position: "relative",
  // Disabled for our use case: the wrapper elements around FileList already deal with overflow,
  // and this additional property would hide things that we want to show.
  //
  // overflow: 'hidden',
  width: "100%",
  minHeight: "100%"
}, STYLE_CONTENT = {
  position: "absolute",
  top: 0,
  left: 0,
  // Because the `top` value gets set to some offset, this `height` being 100% would make the scrollbar
  // stretch far beyond the content. For our use case, the content div actually can get its height from
  // the elements inside it, so we don't need to specify a `height` property at all.
  //
  // height: '100%',
  width: "100%",
  overflow: "visible"
};
class VirtualList extends x {
  constructor(Y) {
    super(Y), this.handleScroll = () => {
      this.setState({
        offset: this.base.scrollTop
      });
    }, this.handleResize = () => {
      this.resize();
    }, this.focusElement = null, this.state = {
      offset: 0,
      height: 0
    };
  }
  componentDidMount() {
    this.resize(), window.addEventListener("resize", this.handleResize);
  }
  // TODO: refactor to stable lifecycle method
  // eslint-disable-next-line
  componentWillUpdate() {
    this.base.contains(document.activeElement) && (this.focusElement = document.activeElement);
  }
  componentDidUpdate() {
    this.focusElement && this.focusElement.parentNode && document.activeElement !== this.focusElement && this.focusElement.focus(), this.focusElement = null, this.resize();
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.handleResize);
  }
  resize() {
    const {
      height: Y
    } = this.state;
    Y !== this.base.offsetHeight && this.setState({
      height: this.base.offsetHeight
    });
  }
  render(Y) {
    let {
      data: re,
      rowHeight: oe,
      renderRow: ue,
      overscanCount: fe = 10,
      ...he
    } = Y;
    const {
      offset: _e,
      height: ve
    } = this.state;
    let xe = Math.floor(_e / oe), Ee = Math.floor(ve / oe);
    fe && (xe = Math.max(0, xe - xe % fe), Ee += fe);
    const Se = xe + Ee + 4, Te = re.slice(xe, Se), Ce = {
      ...STYLE_INNER,
      height: re.length * oe
    }, Ie = {
      ...STYLE_CONTENT,
      top: xe * oe
    };
    return (
      // eslint-disable-next-line react/jsx-props-no-spreading
      _$1("div", _extends$2({
        onScroll: this.handleScroll
      }, he), _$1("div", {
        role: "presentation",
        style: Ce
      }, _$1("div", {
        role: "presentation",
        style: Ie
      }, Te.map(ue))))
    );
  }
}
var eventemitter3 = { exports: {} }, hasRequiredEventemitter3;
function requireEventemitter3() {
  return hasRequiredEventemitter3 || (hasRequiredEventemitter3 = 1, function(le) {
    var Y = Object.prototype.hasOwnProperty, re = "~";
    function oe() {
    }
    Object.create && (oe.prototype = /* @__PURE__ */ Object.create(null), new oe().__proto__ || (re = !1));
    function ue(ve, xe, Ee) {
      this.fn = ve, this.context = xe, this.once = Ee || !1;
    }
    function fe(ve, xe, Ee, Se, Te) {
      if (typeof Ee != "function")
        throw new TypeError("The listener must be a function");
      var Ce = new ue(Ee, Se || ve, Te), Ie = re ? re + xe : xe;
      return ve._events[Ie] ? ve._events[Ie].fn ? ve._events[Ie] = [ve._events[Ie], Ce] : ve._events[Ie].push(Ce) : (ve._events[Ie] = Ce, ve._eventsCount++), ve;
    }
    function he(ve, xe) {
      --ve._eventsCount === 0 ? ve._events = new oe() : delete ve._events[xe];
    }
    function _e() {
      this._events = new oe(), this._eventsCount = 0;
    }
    _e.prototype.eventNames = function() {
      var xe = [], Ee, Se;
      if (this._eventsCount === 0) return xe;
      for (Se in Ee = this._events)
        Y.call(Ee, Se) && xe.push(re ? Se.slice(1) : Se);
      return Object.getOwnPropertySymbols ? xe.concat(Object.getOwnPropertySymbols(Ee)) : xe;
    }, _e.prototype.listeners = function(xe) {
      var Ee = re ? re + xe : xe, Se = this._events[Ee];
      if (!Se) return [];
      if (Se.fn) return [Se.fn];
      for (var Te = 0, Ce = Se.length, Ie = new Array(Ce); Te < Ce; Te++)
        Ie[Te] = Se[Te].fn;
      return Ie;
    }, _e.prototype.listenerCount = function(xe) {
      var Ee = re ? re + xe : xe, Se = this._events[Ee];
      return Se ? Se.fn ? 1 : Se.length : 0;
    }, _e.prototype.emit = function(xe, Ee, Se, Te, Ce, Ie) {
      var Ne = re ? re + xe : xe;
      if (!this._events[Ne]) return !1;
      var Re = this._events[Ne], Ae = arguments.length, Pe, Fe;
      if (Re.fn) {
        switch (Re.once && this.removeListener(xe, Re.fn, void 0, !0), Ae) {
          case 1:
            return Re.fn.call(Re.context), !0;
          case 2:
            return Re.fn.call(Re.context, Ee), !0;
          case 3:
            return Re.fn.call(Re.context, Ee, Se), !0;
          case 4:
            return Re.fn.call(Re.context, Ee, Se, Te), !0;
          case 5:
            return Re.fn.call(Re.context, Ee, Se, Te, Ce), !0;
          case 6:
            return Re.fn.call(Re.context, Ee, Se, Te, Ce, Ie), !0;
        }
        for (Fe = 1, Pe = new Array(Ae - 1); Fe < Ae; Fe++)
          Pe[Fe - 1] = arguments[Fe];
        Re.fn.apply(Re.context, Pe);
      } else {
        var Le = Re.length, He;
        for (Fe = 0; Fe < Le; Fe++)
          switch (Re[Fe].once && this.removeListener(xe, Re[Fe].fn, void 0, !0), Ae) {
            case 1:
              Re[Fe].fn.call(Re[Fe].context);
              break;
            case 2:
              Re[Fe].fn.call(Re[Fe].context, Ee);
              break;
            case 3:
              Re[Fe].fn.call(Re[Fe].context, Ee, Se);
              break;
            case 4:
              Re[Fe].fn.call(Re[Fe].context, Ee, Se, Te);
              break;
            default:
              if (!Pe) for (He = 1, Pe = new Array(Ae - 1); He < Ae; He++)
                Pe[He - 1] = arguments[He];
              Re[Fe].fn.apply(Re[Fe].context, Pe);
          }
      }
      return !0;
    }, _e.prototype.on = function(xe, Ee, Se) {
      return fe(this, xe, Ee, Se, !1);
    }, _e.prototype.once = function(xe, Ee, Se) {
      return fe(this, xe, Ee, Se, !0);
    }, _e.prototype.removeListener = function(xe, Ee, Se, Te) {
      var Ce = re ? re + xe : xe;
      if (!this._events[Ce]) return this;
      if (!Ee)
        return he(this, Ce), this;
      var Ie = this._events[Ce];
      if (Ie.fn)
        Ie.fn === Ee && (!Te || Ie.once) && (!Se || Ie.context === Se) && he(this, Ce);
      else {
        for (var Ne = 0, Re = [], Ae = Ie.length; Ne < Ae; Ne++)
          (Ie[Ne].fn !== Ee || Te && !Ie[Ne].once || Se && Ie[Ne].context !== Se) && Re.push(Ie[Ne]);
        Re.length ? this._events[Ce] = Re.length === 1 ? Re[0] : Re : he(this, Ce);
      }
      return this;
    }, _e.prototype.removeAllListeners = function(xe) {
      var Ee;
      return xe ? (Ee = re ? re + xe : xe, this._events[Ee] && he(this, Ee)) : (this._events = new oe(), this._eventsCount = 0), this;
    }, _e.prototype.off = _e.prototype.removeListener, _e.prototype.addListener = _e.prototype.on, _e.prefixed = re, _e.EventEmitter = _e, le.exports = _e;
  }(eventemitter3)), eventemitter3.exports;
}
var eventemitter3Exports = requireEventemitter3();
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
function defaultPickerIcon() {
  return _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "30",
    height: "30",
    viewBox: "0 0 30 30"
  }, _$1("path", {
    d: "M15 30c8.284 0 15-6.716 15-15 0-8.284-6.716-15-15-15C6.716 0 0 6.716 0 15c0 8.284 6.716 15 15 15zm4.258-12.676v6.846h-8.426v-6.846H5.204l9.82-12.364 9.82 12.364H19.26z"
  }));
}
var safeIsNaN = Number.isNaN || function le(Y) {
  return typeof Y == "number" && Y !== Y;
};
function isEqual$1(le, Y) {
  return !!(le === Y || safeIsNaN(le) && safeIsNaN(Y));
}
function areInputsEqual(le, Y) {
  if (le.length !== Y.length)
    return !1;
  for (var re = 0; re < le.length; re++)
    if (!isEqual$1(le[re], Y[re]))
      return !1;
  return !0;
}
function memoizeOne(le, Y) {
  Y === void 0 && (Y = areInputsEqual);
  var re = null;
  function oe() {
    for (var ue = [], fe = 0; fe < arguments.length; fe++)
      ue[fe] = arguments[fe];
    if (re && re.lastThis === this && Y(ue, re.lastArgs))
      return re.lastResult;
    var he = le.apply(this, ue);
    return re = {
      lastResult: he,
      lastArgs: ue,
      lastThis: this
    }, he;
  }
  return oe.clear = function() {
    re = null;
  }, oe;
}
const FOCUSABLE_ELEMENTS = ['a[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'area[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', "input:not([disabled]):not([inert]):not([aria-hidden])", "select:not([disabled]):not([inert]):not([aria-hidden])", "textarea:not([disabled]):not([inert]):not([aria-hidden])", "button:not([disabled]):not([inert]):not([aria-hidden])", 'iframe:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'object:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'embed:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[contenteditable]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[tabindex]:not([tabindex^="-"]):not([inert]):not([aria-hidden])'];
function getActiveOverlayEl(le, Y) {
  if (Y) {
    const re = le.querySelector(`[data-uppy-paneltype="${Y}"]`);
    if (re) return re;
  }
  return le;
}
function focusOnFirstNode(le, Y) {
  const re = Y[0];
  re && (re.focus(), le.preventDefault());
}
function focusOnLastNode(le, Y) {
  const re = Y[Y.length - 1];
  re && (re.focus(), le.preventDefault());
}
function isFocusInOverlay(le) {
  return le.contains(document.activeElement);
}
function trapFocus(le, Y, re) {
  const oe = getActiveOverlayEl(re, Y), ue = toArray$2(oe.querySelectorAll(FOCUSABLE_ELEMENTS)), fe = ue.indexOf(document.activeElement);
  isFocusInOverlay(oe) ? le.shiftKey && fe === 0 ? focusOnLastNode(le, ue) : !le.shiftKey && fe === ue.length - 1 && focusOnFirstNode(le, ue) : focusOnFirstNode(le, ue);
}
function forInline(le, Y, re) {
  Y === null || trapFocus(le, Y, re);
}
var debounceExports = requireDebounce();
const debounce = /* @__PURE__ */ getDefaultExportFromCjs(debounceExports);
function createSuperFocus() {
  let le = !1;
  return debounce((re, oe) => {
    const ue = getActiveOverlayEl(re, oe), fe = ue.contains(document.activeElement);
    if (fe && le) return;
    const he = ue.querySelector("[data-uppy-super-focusable]");
    if (!(fe && !he))
      if (he)
        he.focus({
          preventScroll: !0
        }), le = !0;
      else {
        const _e = ue.querySelector(FOCUSABLE_ELEMENTS);
        _e?.focus({
          preventScroll: !0
        }), le = !1;
      }
  }, 260);
}
function isDragDropSupported() {
  const le = document.body;
  return !(!("draggable" in le) || !("ondragstart" in le && "ondrop" in le) || !("FormData" in window) || !("FileReader" in window));
}
function shallowEqualObjects(le, Y) {
  if (le === Y)
    return !0;
  if (!le || !Y)
    return !1;
  const re = Object.keys(le), oe = Object.keys(Y), ue = re.length;
  if (oe.length !== ue)
    return !1;
  for (let fe = 0; fe < ue; fe++) {
    const he = re[fe];
    if (le[he] !== Y[he] || !Object.prototype.hasOwnProperty.call(Y, he))
      return !1;
  }
  return !0;
}
function iconImage() {
  return _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, _$1("g", {
    fill: "#686DE0",
    fillRule: "evenodd"
  }, _$1("path", {
    d: "M5 7v10h15V7H5zm0-1h15a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1z",
    fillRule: "nonzero"
  }), _$1("path", {
    d: "M6.35 17.172l4.994-5.026a.5.5 0 0 1 .707 0l2.16 2.16 3.505-3.505a.5.5 0 0 1 .707 0l2.336 2.31-.707.72-1.983-1.97-3.505 3.505a.5.5 0 0 1-.707 0l-2.16-2.159-3.938 3.939-1.409.026z",
    fillRule: "nonzero"
  }), _$1("circle", {
    cx: "7.5",
    cy: "9.5",
    r: "1.5"
  })));
}
function iconAudio() {
  return _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, _$1("path", {
    d: "M9.5 18.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V7.25a.5.5 0 0 1 .379-.485l9-2.25A.5.5 0 0 1 18.5 5v11.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V8.67l-8 2v7.97zm8-11v-2l-8 2v2l8-2zM7 19.64c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1zm9-2c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1z",
    fill: "#049BCF",
    fillRule: "nonzero"
  }));
}
function iconVideo() {
  return _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, _$1("path", {
    d: "M16 11.834l4.486-2.691A1 1 0 0 1 22 10v6a1 1 0 0 1-1.514.857L16 14.167V17a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2.834zM15 9H5v8h10V9zm1 4l5 3v-6l-5 3z",
    fill: "#19AF67",
    fillRule: "nonzero"
  }));
}
function iconPDF() {
  return _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, _$1("path", {
    d: "M9.766 8.295c-.691-1.843-.539-3.401.747-3.726 1.643-.414 2.505.938 2.39 3.299-.039.79-.194 1.662-.537 3.148.324.49.66.967 1.055 1.51.17.231.382.488.629.757 1.866-.128 3.653.114 4.918.655 1.487.635 2.192 1.685 1.614 2.84-.566 1.133-1.839 1.084-3.416.249-1.141-.604-2.457-1.634-3.51-2.707a13.467 13.467 0 0 0-2.238.426c-1.392 4.051-4.534 6.453-5.707 4.572-.986-1.58 1.38-4.206 4.914-5.375.097-.322.185-.656.264-1.001.08-.353.306-1.31.407-1.737-.678-1.059-1.2-2.031-1.53-2.91zm2.098 4.87c-.033.144-.068.287-.104.427l.033-.01-.012.038a14.065 14.065 0 0 1 1.02-.197l-.032-.033.052-.004a7.902 7.902 0 0 1-.208-.271c-.197-.27-.38-.526-.555-.775l-.006.028-.002-.003c-.076.323-.148.632-.186.8zm5.77 2.978c1.143.605 1.832.632 2.054.187.26-.519-.087-1.034-1.113-1.473-.911-.39-2.175-.608-3.55-.608.845.766 1.787 1.459 2.609 1.894zM6.559 18.789c.14.223.693.16 1.425-.413.827-.648 1.61-1.747 2.208-3.206-2.563 1.064-4.102 2.867-3.633 3.62zm5.345-10.97c.088-1.793-.351-2.48-1.146-2.28-.473.119-.564 1.05-.056 2.405.213.566.52 1.188.908 1.859.18-.858.268-1.453.294-1.984z",
    fill: "#E2514A",
    fillRule: "nonzero"
  }));
}
function iconArchive() {
  return _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, _$1("path", {
    d: "M10.45 2.05h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V2.55a.5.5 0 0 1 .5-.5zm2.05 1.024h1.05a.5.5 0 0 1 .5.5V3.6a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5v-.001zM10.45 0h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 3.074h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 1.024h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm-2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-1.656 3.074l-.82 5.946c.52.302 1.174.458 1.976.458.803 0 1.455-.156 1.975-.458l-.82-5.946h-2.311zm0-1.025h2.312c.512 0 .946.378 1.015.885l.82 5.946c.056.412-.142.817-.501 1.026-.686.398-1.515.597-2.49.597-.974 0-1.804-.199-2.49-.597a1.025 1.025 0 0 1-.5-1.026l.819-5.946c.07-.507.503-.885 1.015-.885zm.545 6.6a.5.5 0 0 1-.397-.561l.143-.999a.5.5 0 0 1 .495-.429h.74a.5.5 0 0 1 .495.43l.143.998a.5.5 0 0 1-.397.561c-.404.08-.819.08-1.222 0z",
    fill: "#00C469",
    fillRule: "nonzero"
  }));
}
function iconFile() {
  return _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, _$1("g", {
    fill: "#A7AFB7",
    fillRule: "nonzero"
  }, _$1("path", {
    d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z"
  }), _$1("path", {
    d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z"
  })));
}
function iconText() {
  return _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, _$1("path", {
    d: "M4.5 7h13a.5.5 0 1 1 0 1h-13a.5.5 0 0 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h10a.5.5 0 1 1 0 1h-10a.5.5 0 1 1 0-1z",
    fill: "#5A5E69",
    fillRule: "nonzero"
  }));
}
function getIconByMime(le) {
  const Y = {
    color: "#838999",
    icon: iconFile()
  };
  if (!le) return Y;
  const re = le.split("/")[0], oe = le.split("/")[1];
  return re === "text" ? {
    color: "#5a5e69",
    icon: iconText()
  } : re === "image" ? {
    color: "#686de0",
    icon: iconImage()
  } : re === "audio" ? {
    color: "#068dbb",
    icon: iconAudio()
  } : re === "video" ? {
    color: "#19af67",
    icon: iconVideo()
  } : re === "application" && oe === "pdf" ? {
    color: "#e25149",
    icon: iconPDF()
  } : re === "application" && ["zip", "x-7z-compressed", "x-zip-compressed", "x-rar-compressed", "x-tar", "x-gzip", "x-apple-diskimage"].indexOf(oe) !== -1 ? {
    color: "#00C469",
    icon: iconArchive()
  } : Y;
}
function FilePreview(le) {
  const {
    file: Y
  } = le;
  if (Y.preview)
    return _$1("img", {
      draggable: !1,
      className: "uppy-Dashboard-Item-previewImg",
      alt: Y.name,
      src: Y.preview
    });
  const {
    color: re,
    icon: oe
  } = getIconByMime(Y.type);
  return _$1("div", {
    className: "uppy-Dashboard-Item-previewIconWrap"
  }, _$1("span", {
    className: "uppy-Dashboard-Item-previewIcon",
    style: {
      color: re
    }
  }, oe), _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-Dashboard-Item-previewIconBg",
    width: "58",
    height: "76",
    viewBox: "0 0 58 76"
  }, _$1("rect", {
    fill: "#FFF",
    width: "58",
    height: "76",
    rx: "3",
    fillRule: "evenodd"
  })));
}
const metaFieldIdToName = (le, Y) => (typeof Y == "function" ? Y() : Y).filter((ue) => ue.id === le)[0].name;
function MetaErrorMessage(le) {
  const {
    file: Y,
    toggleFileCard: re,
    i18n: oe,
    metaFields: ue
  } = le, {
    missingRequiredMetaFields: fe
  } = Y;
  if (!(fe != null && fe.length))
    return null;
  const he = fe.map((_e) => metaFieldIdToName(_e, ue)).join(", ");
  return _$1("div", {
    className: "uppy-Dashboard-Item-errorMessage"
  }, oe("missingRequiredMetaFields", {
    smart_count: fe.length,
    fields: he
  }), " ", _$1("button", {
    type: "button",
    class: "uppy-u-reset uppy-Dashboard-Item-errorMessageBtn",
    onClick: () => re(!0, Y.id)
  }, oe("editFile")));
}
function FilePreviewAndLink(le) {
  const {
    file: Y,
    i18n: re,
    toggleFileCard: oe,
    metaFields: ue,
    showLinkToFileUploadResult: fe
  } = le, _e = Y.preview ? "rgba(255, 255, 255, 0.5)" : getIconByMime(Y.type).color;
  return _$1("div", {
    className: "uppy-Dashboard-Item-previewInnerWrap",
    style: {
      backgroundColor: _e
    }
  }, fe && Y.uploadURL && _$1("a", {
    className: "uppy-Dashboard-Item-previewLink",
    href: Y.uploadURL,
    rel: "noreferrer noopener",
    target: "_blank",
    "aria-label": Y.meta.name
  }, _$1("span", {
    hidden: !0
  }, Y.meta.name)), _$1(FilePreview, {
    file: Y
  }), _$1(MetaErrorMessage, {
    file: Y,
    i18n: re,
    toggleFileCard: oe,
    metaFields: ue
  }));
}
function onPauseResumeCancelRetry(le) {
  if (!le.isUploaded) {
    if (le.error && !le.hideRetryButton) {
      le.uppy.retryUpload(le.file.id);
      return;
    }
    le.resumableUploads && !le.hidePauseResumeButton ? le.uppy.pauseResume(le.file.id) : le.individualCancellation && !le.hideCancelButton && le.uppy.removeFile(le.file.id);
  }
}
function progressIndicatorTitle(le) {
  return le.isUploaded ? le.i18n("uploadComplete") : le.error ? le.i18n("retryUpload") : le.resumableUploads ? le.file.isPaused ? le.i18n("resumeUpload") : le.i18n("pauseUpload") : le.individualCancellation ? le.i18n("cancelUpload") : "";
}
function ProgressIndicatorButton(le) {
  return _$1("div", {
    className: "uppy-Dashboard-Item-progress"
  }, _$1("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-progressIndicator",
    type: "button",
    "aria-label": progressIndicatorTitle(le),
    title: progressIndicatorTitle(le),
    onClick: () => onPauseResumeCancelRetry(le)
  }, le.children));
}
function ProgressCircleContainer(le) {
  let {
    children: Y
  } = le;
  return _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "70",
    height: "70",
    viewBox: "0 0 36 36",
    className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--circle"
  }, Y);
}
function ProgressCircle(le) {
  let {
    progress: Y
  } = le;
  const re = 2 * Math.PI * 15;
  return _$1("g", null, _$1("circle", {
    className: "uppy-Dashboard-Item-progressIcon--bg",
    r: "15",
    cx: "18",
    cy: "18",
    "stroke-width": "2",
    fill: "none"
  }), _$1("circle", {
    className: "uppy-Dashboard-Item-progressIcon--progress",
    r: "15",
    cx: "18",
    cy: "18",
    transform: "rotate(-90, 18, 18)",
    fill: "none",
    "stroke-width": "2",
    "stroke-dasharray": re,
    "stroke-dashoffset": re - re / 100 * Y
  }));
}
function FileProgress(le) {
  return !le.file.progress.uploadStarted || le.file.progress.percentage === void 0 ? null : le.isUploaded ? _$1("div", {
    className: "uppy-Dashboard-Item-progress"
  }, _$1("div", {
    className: "uppy-Dashboard-Item-progressIndicator"
  }, _$1(ProgressCircleContainer, null, _$1("circle", {
    r: "15",
    cx: "18",
    cy: "18",
    fill: "#1bb240"
  }), _$1("polygon", {
    className: "uppy-Dashboard-Item-progressIcon--check",
    transform: "translate(2, 3)",
    points: "14 22.5 7 15.2457065 8.99985857 13.1732815 14 18.3547104 22.9729883 9 25 11.1005634"
  })))) : le.recoveredState ? null : le.error && !le.hideRetryButton ? (
    // eslint-disable-next-line react/jsx-props-no-spreading
    _$1(ProgressIndicatorButton, le, _$1("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--retry",
      width: "28",
      height: "31",
      viewBox: "0 0 16 19"
    }, _$1("path", {
      d: "M16 11a8 8 0 1 1-8-8v2a6 6 0 1 0 6 6h2z"
    }), _$1("path", {
      d: "M7.9 3H10v2H7.9z"
    }), _$1("path", {
      d: "M8.536.5l3.535 3.536-1.414 1.414L7.12 1.914z"
    }), _$1("path", {
      d: "M10.657 2.621l1.414 1.415L8.536 7.57 7.12 6.157z"
    })))
  ) : le.resumableUploads && !le.hidePauseResumeButton ? (
    // eslint-disable-next-line react/jsx-props-no-spreading
    _$1(ProgressIndicatorButton, le, _$1(ProgressCircleContainer, null, _$1(ProgressCircle, {
      progress: le.file.progress.percentage
    }), le.file.isPaused ? _$1("polygon", {
      className: "uppy-Dashboard-Item-progressIcon--play",
      transform: "translate(3, 3)",
      points: "12 20 12 10 20 15"
    }) : _$1("g", {
      className: "uppy-Dashboard-Item-progressIcon--pause",
      transform: "translate(14.5, 13)"
    }, _$1("rect", {
      x: "0",
      y: "0",
      width: "2",
      height: "10",
      rx: "0"
    }), _$1("rect", {
      x: "5",
      y: "0",
      width: "2",
      height: "10",
      rx: "0"
    }))))
  ) : !le.resumableUploads && le.individualCancellation && !le.hideCancelButton ? (
    // eslint-disable-next-line react/jsx-props-no-spreading
    _$1(ProgressIndicatorButton, le, _$1(ProgressCircleContainer, null, _$1(ProgressCircle, {
      progress: le.file.progress.percentage
    }), _$1("polygon", {
      className: "cancel",
      transform: "translate(2, 2)",
      points: "19.8856516 11.0625 16 14.9481516 12.1019737 11.0625 11.0625 12.1143484 14.9481516 16 11.0625 19.8980263 12.1019737 20.9375 16 17.0518484 19.8856516 20.9375 20.9375 19.8980263 17.0518484 16 20.9375 12"
    })))
  ) : _$1("div", {
    className: "uppy-Dashboard-Item-progress"
  }, _$1("div", {
    className: "uppy-Dashboard-Item-progressIndicator"
  }, _$1(ProgressCircleContainer, null, _$1(ProgressCircle, {
    progress: le.file.progress.percentage
  }))));
}
const separator = "...";
function truncateString(le, Y) {
  if (Y === 0) return "";
  if (le.length <= Y) return le;
  if (Y <= separator.length + 1) return `${le.slice(0, Y - 1)}…`;
  const re = Y - separator.length, oe = Math.ceil(re / 2), ue = Math.floor(re / 2);
  return le.slice(0, oe) + separator + le.slice(-ue);
}
const renderFileName = (le) => {
  const {
    author: Y,
    name: re
  } = le.file.meta;
  function oe() {
    return le.isSingleFile && le.containerHeight >= 350 ? 90 : le.containerWidth <= 352 ? 35 : le.containerWidth <= 576 ? 60 : Y ? 20 : 30;
  }
  return _$1("div", {
    className: "uppy-Dashboard-Item-name",
    title: re
  }, truncateString(re, oe()));
}, renderAuthor = (le) => {
  var Y;
  const {
    author: re
  } = le.file.meta, oe = (Y = le.file.remote) == null ? void 0 : Y.providerName, ue = "·";
  return re ? _$1("div", {
    className: "uppy-Dashboard-Item-author"
  }, _$1("a", {
    href: `${re.url}?utm_source=Companion&utm_medium=referral`,
    target: "_blank",
    rel: "noopener noreferrer"
  }, truncateString(re.name, 13)), oe ? _$1(Fragment, null, ` ${ue} `, oe, ` ${ue} `) : null) : null;
}, renderFileSize = (le) => le.file.size && _$1("div", {
  className: "uppy-Dashboard-Item-statusSize"
}, prettierBytes(le.file.size)), ReSelectButton = (le) => le.file.isGhost && _$1("span", null, " • ", _$1("button", {
  className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-reSelect",
  type: "button",
  onClick: () => le.toggleAddFilesPanel(!0)
}, le.i18n("reSelect"))), ErrorButton = (le) => {
  let {
    file: Y,
    onClick: re
  } = le;
  return Y.error ? _$1("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-errorDetails",
    "aria-label": Y.error,
    "data-microtip-position": "bottom",
    "data-microtip-size": "medium",
    onClick: re,
    type: "button"
  }, "?") : null;
};
function FileInfo(le) {
  const {
    file: Y,
    i18n: re,
    toggleFileCard: oe,
    metaFields: ue,
    toggleAddFilesPanel: fe,
    isSingleFile: he,
    containerHeight: _e,
    containerWidth: ve
  } = le;
  return _$1("div", {
    className: "uppy-Dashboard-Item-fileInfo",
    "data-uppy-file-source": Y.source
  }, _$1("div", {
    className: "uppy-Dashboard-Item-fileName"
  }, renderFileName({
    file: Y,
    isSingleFile: he,
    containerHeight: _e,
    containerWidth: ve
  }), _$1(ErrorButton, {
    file: Y,
    onClick: () => alert(Y.error)
  })), _$1("div", {
    className: "uppy-Dashboard-Item-status"
  }, renderAuthor({
    file: Y
  }), renderFileSize({
    file: Y
  }), ReSelectButton({
    file: Y,
    toggleAddFilesPanel: fe,
    i18n: re
  })), _$1(MetaErrorMessage, {
    file: Y,
    i18n: re,
    toggleFileCard: oe,
    metaFields: ue
  }));
}
function copyToClipboard(le, Y) {
  return Y === void 0 && (Y = "Copy the URL below"), new Promise((re) => {
    const oe = document.createElement("textarea");
    oe.setAttribute("style", {
      position: "fixed",
      top: 0,
      left: 0,
      width: "2em",
      height: "2em",
      padding: 0,
      border: "none",
      outline: "none",
      boxShadow: "none",
      background: "transparent"
    }), oe.value = le, document.body.appendChild(oe), oe.select();
    const ue = () => {
      document.body.removeChild(oe), window.prompt(Y, le), re();
    };
    try {
      return document.execCommand("copy") ? (document.body.removeChild(oe), re()) : ue();
    } catch {
      return document.body.removeChild(oe), ue();
    }
  });
}
function EditButton(le) {
  let {
    file: Y,
    uploadInProgressOrComplete: re,
    metaFields: oe,
    canEditFile: ue,
    i18n: fe,
    onClick: he
  } = le;
  return !re && oe && oe.length > 0 || !re && ue(Y) ? _$1("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-action uppy-Dashboard-Item-action--edit",
    type: "button",
    "aria-label": fe("editFileWithFilename", {
      file: Y.meta.name
    }),
    title: fe("editFileWithFilename", {
      file: Y.meta.name
    }),
    onClick: () => he()
  }, _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "14",
    height: "14",
    viewBox: "0 0 14 14"
  }, _$1("g", {
    fillRule: "evenodd"
  }, _$1("path", {
    d: "M1.5 10.793h2.793A1 1 0 0 0 5 10.5L11.5 4a1 1 0 0 0 0-1.414L9.707.793a1 1 0 0 0-1.414 0l-6.5 6.5A1 1 0 0 0 1.5 8v2.793zm1-1V8L9 1.5l1.793 1.793-6.5 6.5H2.5z",
    fillRule: "nonzero"
  }), _$1("rect", {
    x: "1",
    y: "12.293",
    width: "11",
    height: "1",
    rx: ".5"
  }), _$1("path", {
    fillRule: "nonzero",
    d: "M6.793 2.5L9.5 5.207l.707-.707L7.5 1.793z"
  })))) : null;
}
function RemoveButton(le) {
  let {
    i18n: Y,
    onClick: re,
    file: oe
  } = le;
  return _$1("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--remove",
    type: "button",
    "aria-label": Y("removeFile", {
      file: oe.meta.name
    }),
    title: Y("removeFile", {
      file: oe.meta.name
    }),
    onClick: () => re()
  }, _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "18",
    height: "18",
    viewBox: "0 0 18 18"
  }, _$1("path", {
    d: "M9 0C4.034 0 0 4.034 0 9s4.034 9 9 9 9-4.034 9-9-4.034-9-9-9z"
  }), _$1("path", {
    fill: "#FFF",
    d: "M13 12.222l-.778.778L9 9.778 5.778 13 5 12.222 8.222 9 5 5.778 5.778 5 9 8.222 12.222 5l.778.778L9.778 9z"
  })));
}
function CopyLinkButton(le) {
  let {
    file: Y,
    uppy: re,
    i18n: oe
  } = le;
  const ue = (fe) => {
    copyToClipboard(Y.uploadURL, oe("copyLinkToClipboardFallback")).then(() => {
      re.log("Link copied to clipboard."), re.info(oe("copyLinkToClipboardSuccess"), "info", 3e3);
    }).catch(re.log).then(() => fe.target.focus({
      preventScroll: !0
    }));
  };
  return _$1("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--copyLink",
    type: "button",
    "aria-label": oe("copyLink"),
    title: oe("copyLink"),
    onClick: (fe) => ue(fe)
  }, _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "14",
    height: "14",
    viewBox: "0 0 14 12"
  }, _$1("path", {
    d: "M7.94 7.703a2.613 2.613 0 0 1-.626 2.681l-.852.851a2.597 2.597 0 0 1-1.849.766A2.616 2.616 0 0 1 2.764 7.54l.852-.852a2.596 2.596 0 0 1 2.69-.625L5.267 7.099a1.44 1.44 0 0 0-.833.407l-.852.851a1.458 1.458 0 0 0 1.03 2.486c.39 0 .755-.152 1.03-.426l.852-.852c.231-.231.363-.522.406-.824l1.04-1.038zm4.295-5.937A2.596 2.596 0 0 0 10.387 1c-.698 0-1.355.272-1.849.766l-.852.851a2.614 2.614 0 0 0-.624 2.688l1.036-1.036c.041-.304.173-.6.407-.833l.852-.852c.275-.275.64-.426 1.03-.426a1.458 1.458 0 0 1 1.03 2.486l-.852.851a1.442 1.442 0 0 1-.824.406l-1.04 1.04a2.596 2.596 0 0 0 2.683-.628l.851-.85a2.616 2.616 0 0 0 0-3.697zm-6.88 6.883a.577.577 0 0 0 .82 0l3.474-3.474a.579.579 0 1 0-.819-.82L5.355 7.83a.579.579 0 0 0 0 .819z"
  })));
}
function Buttons(le) {
  const {
    uppy: Y,
    file: re,
    uploadInProgressOrComplete: oe,
    canEditFile: ue,
    metaFields: fe,
    showLinkToFileUploadResult: he,
    showRemoveButton: _e,
    i18n: ve,
    toggleFileCard: xe,
    openFileEditor: Ee
  } = le;
  return _$1("div", {
    className: "uppy-Dashboard-Item-actionWrapper"
  }, _$1(EditButton, {
    i18n: ve,
    file: re,
    uploadInProgressOrComplete: oe,
    canEditFile: ue,
    metaFields: fe,
    onClick: () => {
      fe && fe.length > 0 ? xe(!0, re.id) : Ee(re);
    }
  }), he && re.uploadURL ? _$1(CopyLinkButton, {
    file: re,
    uppy: Y,
    i18n: ve
  }) : null, _e ? _$1(RemoveButton, {
    i18n: ve,
    file: re,
    onClick: () => Y.removeFile(re.id)
  }) : null);
}
class FileItem extends x {
  componentDidMount() {
    const {
      file: Y
    } = this.props;
    Y.preview || this.props.handleRequestThumbnail(Y);
  }
  shouldComponentUpdate(Y) {
    return !shallowEqualObjects(this.props, Y);
  }
  // VirtualList mounts FileItems again and they emit `thumbnail:request`
  // Otherwise thumbnails are broken or missing after Golden Retriever restores files
  componentDidUpdate() {
    const {
      file: Y
    } = this.props;
    Y.preview || this.props.handleRequestThumbnail(Y);
  }
  componentWillUnmount() {
    const {
      file: Y
    } = this.props;
    Y.preview || this.props.handleCancelThumbnail(Y);
  }
  render() {
    const {
      file: Y
    } = this.props, re = Y.progress.preprocess || Y.progress.postprocess, oe = !!Y.progress.uploadComplete && !re && !Y.error, ue = !!Y.progress.uploadStarted || !!re, fe = Y.progress.uploadStarted && !Y.progress.uploadComplete || re, he = Y.error || !1, {
      isGhost: _e
    } = Y;
    let ve = (this.props.individualCancellation || !fe) && !oe;
    oe && this.props.showRemoveButtonAfterComplete && (ve = !0);
    const xe = classNames({
      "uppy-Dashboard-Item": !0,
      "is-inprogress": fe && !this.props.recoveredState,
      "is-processing": re,
      "is-complete": oe,
      "is-error": !!he,
      "is-resumable": this.props.resumableUploads,
      "is-noIndividualCancellation": !this.props.individualCancellation,
      "is-ghost": _e
    });
    return _$1("div", {
      className: xe,
      id: `uppy_${Y.id}`,
      role: this.props.role
    }, _$1("div", {
      className: "uppy-Dashboard-Item-preview"
    }, _$1(FilePreviewAndLink, {
      file: Y,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
      i18n: this.props.i18n,
      toggleFileCard: this.props.toggleFileCard,
      metaFields: this.props.metaFields
    }), _$1(FileProgress, {
      uppy: this.props.uppy,
      file: Y,
      error: he,
      isUploaded: oe,
      hideRetryButton: this.props.hideRetryButton,
      hideCancelButton: this.props.hideCancelButton,
      hidePauseResumeButton: this.props.hidePauseResumeButton,
      recoveredState: this.props.recoveredState,
      resumableUploads: this.props.resumableUploads,
      individualCancellation: this.props.individualCancellation,
      i18n: this.props.i18n
    })), _$1("div", {
      className: "uppy-Dashboard-Item-fileInfoAndButtons"
    }, _$1(FileInfo, {
      file: Y,
      containerWidth: this.props.containerWidth,
      containerHeight: this.props.containerHeight,
      i18n: this.props.i18n,
      toggleAddFilesPanel: this.props.toggleAddFilesPanel,
      toggleFileCard: this.props.toggleFileCard,
      metaFields: this.props.metaFields,
      isSingleFile: this.props.isSingleFile
    }), _$1(Buttons, {
      file: Y,
      metaFields: this.props.metaFields,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
      showRemoveButton: ve,
      canEditFile: this.props.canEditFile,
      uploadInProgressOrComplete: ue,
      toggleFileCard: this.props.toggleFileCard,
      openFileEditor: this.props.openFileEditor,
      uppy: this.props.uppy,
      i18n: this.props.i18n
    })));
  }
}
function chunks(le, Y) {
  const re = [];
  let oe = [];
  return le.forEach((ue) => {
    oe.length < Y ? oe.push(ue) : (re.push(oe), oe = [ue]);
  }), oe.length && re.push(oe), re;
}
function FileList(le) {
  let {
    id: Y,
    i18n: re,
    uppy: oe,
    files: ue,
    resumableUploads: fe,
    hideRetryButton: he,
    hidePauseResumeButton: _e,
    hideCancelButton: ve,
    showLinkToFileUploadResult: xe,
    showRemoveButtonAfterComplete: Ee,
    metaFields: Se,
    isSingleFile: Te,
    toggleFileCard: Ce,
    handleRequestThumbnail: Ie,
    handleCancelThumbnail: Ne,
    recoveredState: Re,
    individualCancellation: Ae,
    itemsPerRow: Pe,
    openFileEditor: Fe,
    canEditFile: Le,
    toggleAddFilesPanel: He,
    containerWidth: Ge,
    containerHeight: Ve
  } = le;
  const $e = Pe === 1 ? (
    // Mobile
    71
  ) : 200, De = T$2(() => {
    const ze = (Xe, mt) => Number(ue[mt].isGhost) - Number(ue[Xe].isGhost), tt = Object.keys(ue);
    return Re && tt.sort(ze), chunks(tt, Pe);
  }, [ue, Pe, Re]), Ke = (ze) => _$1("div", {
    class: "uppy-Dashboard-filesInner",
    role: "presentation",
    key: ze[0]
  }, ze.map((tt) => _$1(FileItem, {
    key: tt,
    uppy: oe,
    id: Y,
    i18n: re,
    resumableUploads: fe,
    individualCancellation: Ae,
    hideRetryButton: he,
    hidePauseResumeButton: _e,
    hideCancelButton: ve,
    showLinkToFileUploadResult: xe,
    showRemoveButtonAfterComplete: Ee,
    metaFields: Se,
    recoveredState: Re,
    isSingleFile: Te,
    containerWidth: Ge,
    containerHeight: Ve,
    toggleFileCard: Ce,
    handleRequestThumbnail: Ie,
    handleCancelThumbnail: Ne,
    role: "listitem",
    openFileEditor: Fe,
    canEditFile: Le,
    toggleAddFilesPanel: He,
    file: ue[tt]
  })));
  return Te ? _$1("div", {
    class: "uppy-Dashboard-files"
  }, Ke(De[0])) : _$1(VirtualList, {
    class: "uppy-Dashboard-files",
    role: "list",
    data: De,
    renderRow: Ke,
    rowHeight: $e
  });
}
class AddFiles extends x {
  constructor() {
    super(...arguments), this.fileInput = null, this.folderInput = null, this.mobilePhotoFileInput = null, this.mobileVideoFileInput = null, this.triggerFileInputClick = () => {
      var Y;
      (Y = this.fileInput) == null || Y.click();
    }, this.triggerFolderInputClick = () => {
      var Y;
      (Y = this.folderInput) == null || Y.click();
    }, this.triggerVideoCameraInputClick = () => {
      var Y;
      (Y = this.mobileVideoFileInput) == null || Y.click();
    }, this.triggerPhotoCameraInputClick = () => {
      var Y;
      (Y = this.mobilePhotoFileInput) == null || Y.click();
    }, this.onFileInputChange = (Y) => {
      this.props.handleInputChange(Y), Y.currentTarget.value = "";
    }, this.renderHiddenInput = (Y, re) => {
      var oe;
      return _$1("input", {
        className: "uppy-Dashboard-input",
        hidden: !0,
        "aria-hidden": "true",
        tabIndex: -1,
        webkitdirectory: Y,
        type: "file",
        name: "files[]",
        multiple: this.props.maxNumberOfFiles !== 1,
        onChange: this.onFileInputChange,
        accept: (oe = this.props.allowedFileTypes) == null ? void 0 : oe.join(", "),
        ref: re
      });
    }, this.renderHiddenCameraInput = (Y, re, oe) => {
      const fe = {
        photo: "image/*",
        video: "video/*"
      }[Y];
      return _$1("input", {
        className: "uppy-Dashboard-input",
        hidden: !0,
        "aria-hidden": "true",
        tabIndex: -1,
        type: "file",
        name: `camera-${Y}`,
        onChange: this.onFileInputChange,
        capture: re,
        accept: fe,
        ref: oe
      });
    }, this.renderMyDeviceAcquirer = () => _$1("div", {
      className: "uppy-DashboardTab",
      role: "presentation",
      "data-uppy-acquirer-id": "MyDevice"
    }, _$1("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
      role: "tab",
      tabIndex: 0,
      "data-uppy-super-focusable": !0,
      onClick: this.triggerFileInputClick
    }, _$1("div", {
      className: "uppy-DashboardTab-inner"
    }, _$1("svg", {
      className: "uppy-DashboardTab-iconMyDevice",
      "aria-hidden": "true",
      focusable: "false",
      width: "32",
      height: "32",
      viewBox: "0 0 32 32"
    }, _$1("path", {
      d: "M8.45 22.087l-1.305-6.674h17.678l-1.572 6.674H8.45zm4.975-12.412l1.083 1.765a.823.823 0 00.715.386h7.951V13.5H8.587V9.675h4.838zM26.043 13.5h-1.195v-2.598c0-.463-.336-.75-.798-.75h-8.356l-1.082-1.766A.823.823 0 0013.897 8H7.728c-.462 0-.815.256-.815.718V13.5h-.956a.97.97 0 00-.746.37.972.972 0 00-.19.81l1.724 8.565c.095.44.484.755.933.755H24c.44 0 .824-.3.929-.727l2.043-8.568a.972.972 0 00-.176-.825.967.967 0 00-.753-.38z",
      fill: "currentcolor",
      "fill-rule": "evenodd"
    }))), _$1("div", {
      className: "uppy-DashboardTab-name"
    }, this.props.i18n("myDevice")))), this.renderPhotoCamera = () => _$1("div", {
      className: "uppy-DashboardTab",
      role: "presentation",
      "data-uppy-acquirer-id": "MobilePhotoCamera"
    }, _$1("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
      role: "tab",
      tabIndex: 0,
      "data-uppy-super-focusable": !0,
      onClick: this.triggerPhotoCameraInputClick
    }, _$1("div", {
      className: "uppy-DashboardTab-inner"
    }, _$1("svg", {
      "aria-hidden": "true",
      focusable: "false",
      width: "32",
      height: "32",
      viewBox: "0 0 32 32"
    }, _$1("path", {
      d: "M23.5 9.5c1.417 0 2.5 1.083 2.5 2.5v9.167c0 1.416-1.083 2.5-2.5 2.5h-15c-1.417 0-2.5-1.084-2.5-2.5V12c0-1.417 1.083-2.5 2.5-2.5h2.917l1.416-2.167C13 7.167 13.25 7 13.5 7h5c.25 0 .5.167.667.333L20.583 9.5H23.5zM16 11.417a4.706 4.706 0 00-4.75 4.75 4.704 4.704 0 004.75 4.75 4.703 4.703 0 004.75-4.75c0-2.663-2.09-4.75-4.75-4.75zm0 7.825c-1.744 0-3.076-1.332-3.076-3.074 0-1.745 1.333-3.077 3.076-3.077 1.744 0 3.074 1.333 3.074 3.076s-1.33 3.075-3.074 3.075z",
      fill: "#02B383",
      "fill-rule": "nonzero"
    }))), _$1("div", {
      className: "uppy-DashboardTab-name"
    }, this.props.i18n("takePictureBtn")))), this.renderVideoCamera = () => _$1("div", {
      className: "uppy-DashboardTab",
      role: "presentation",
      "data-uppy-acquirer-id": "MobileVideoCamera"
    }, _$1("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
      role: "tab",
      tabIndex: 0,
      "data-uppy-super-focusable": !0,
      onClick: this.triggerVideoCameraInputClick
    }, _$1("div", {
      className: "uppy-DashboardTab-inner"
    }, _$1("svg", {
      "aria-hidden": "true",
      width: "32",
      height: "32",
      viewBox: "0 0 32 32"
    }, _$1("path", {
      fill: "#FF675E",
      fillRule: "nonzero",
      d: "m21.254 14.277 2.941-2.588c.797-.313 1.243.818 1.09 1.554-.01 2.094.02 4.189-.017 6.282-.126.915-1.145 1.08-1.58.34l-2.434-2.142c-.192.287-.504 1.305-.738.468-.104-1.293-.028-2.596-.05-3.894.047-.312.381.823.426 1.069.063-.384.206-.744.362-1.09zm-12.939-3.73c3.858.013 7.717-.025 11.574.02.912.129 1.492 1.237 1.351 2.217-.019 2.412.04 4.83-.03 7.239-.17 1.025-1.166 1.59-2.029 1.429-3.705-.012-7.41.025-11.114-.019-.913-.129-1.492-1.237-1.352-2.217.018-2.404-.036-4.813.029-7.214.136-.82.83-1.473 1.571-1.454z "
    }))), _$1("div", {
      className: "uppy-DashboardTab-name"
    }, this.props.i18n("recordVideoBtn")))), this.renderBrowseButton = (Y, re) => {
      const oe = this.props.acquirers.length;
      return _$1("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-Dashboard-browse",
        onClick: re,
        "data-uppy-super-focusable": oe === 0
      }, Y);
    }, this.renderDropPasteBrowseTagline = (Y) => {
      const re = this.renderBrowseButton(this.props.i18n("browseFiles"), this.triggerFileInputClick), oe = this.renderBrowseButton(this.props.i18n("browseFolders"), this.triggerFolderInputClick), ue = this.props.fileManagerSelectionType, fe = ue.charAt(0).toUpperCase() + ue.slice(1);
      return _$1(
        "div",
        {
          class: "uppy-Dashboard-AddFiles-title"
        },
        // eslint-disable-next-line no-nested-ternary
        this.props.disableLocalFiles ? this.props.i18n("importFiles") : Y > 0 ? this.props.i18nArray(`dropPasteImport${fe}`, {
          browseFiles: re,
          browseFolders: oe,
          browse: re
        }) : this.props.i18nArray(`dropPaste${fe}`, {
          browseFiles: re,
          browseFolders: oe,
          browse: re
        })
      );
    }, this.renderAcquirer = (Y) => {
      var re;
      return _$1("div", {
        className: "uppy-DashboardTab",
        role: "presentation",
        "data-uppy-acquirer-id": Y.id
      }, _$1("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
        role: "tab",
        tabIndex: 0,
        "data-cy": Y.id,
        "aria-controls": `uppy-DashboardContent-panel--${Y.id}`,
        "aria-selected": ((re = this.props.activePickerPanel) == null ? void 0 : re.id) === Y.id,
        "data-uppy-super-focusable": !0,
        onClick: () => this.props.showPanel(Y.id)
      }, _$1("div", {
        className: "uppy-DashboardTab-inner"
      }, Y.icon()), _$1("div", {
        className: "uppy-DashboardTab-name"
      }, Y.name)));
    }, this.renderAcquirers = (Y) => {
      const re = [...Y], oe = re.splice(Y.length - 2, Y.length);
      return _$1(k$2, null, re.map((ue) => this.renderAcquirer(ue)), _$1("span", {
        role: "presentation",
        style: {
          "white-space": "nowrap"
        }
      }, oe.map((ue) => this.renderAcquirer(ue))));
    }, this.renderSourcesList = (Y, re) => {
      const {
        showNativePhotoCameraButton: oe,
        showNativeVideoCameraButton: ue
      } = this.props;
      let fe = [];
      const he = "myDevice";
      re || fe.push({
        key: he,
        elements: this.renderMyDeviceAcquirer()
      }), oe && fe.push({
        key: "nativePhotoCameraButton",
        elements: this.renderPhotoCamera()
      }), ue && fe.push({
        key: "nativePhotoCameraButton",
        elements: this.renderVideoCamera()
      }), fe.push(...Y.map((Ee) => ({
        key: Ee.id,
        elements: this.renderAcquirer(Ee)
      }))), fe.length === 1 && fe[0].key === he && (fe = []);
      const ve = [...fe], xe = ve.splice(fe.length - 2, fe.length);
      return _$1(k$2, null, this.renderDropPasteBrowseTagline(fe.length), _$1("div", {
        className: "uppy-Dashboard-AddFiles-list",
        role: "tablist"
      }, ve.map((Ee) => {
        let {
          key: Se,
          elements: Te
        } = Ee;
        return _$1(k$2, {
          key: Se
        }, Te);
      }), _$1("span", {
        role: "presentation",
        style: {
          "white-space": "nowrap"
        }
      }, xe.map((Ee) => {
        let {
          key: Se,
          elements: Te
        } = Ee;
        return _$1(k$2, {
          key: Se
        }, Te);
      }))));
    };
  }
  [Symbol.for("uppy test: disable unused locale key warning")]() {
    this.props.i18nArray("dropPasteBoth"), this.props.i18nArray("dropPasteFiles"), this.props.i18nArray("dropPasteFolders"), this.props.i18nArray("dropPasteImportBoth"), this.props.i18nArray("dropPasteImportFiles"), this.props.i18nArray("dropPasteImportFolders");
  }
  renderPoweredByUppy() {
    const {
      i18nArray: Y
    } = this.props, re = _$1("span", null, _$1("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-Dashboard-poweredByIcon",
      width: "11",
      height: "11",
      viewBox: "0 0 11 11"
    }, _$1("path", {
      d: "M7.365 10.5l-.01-4.045h2.612L5.5.806l-4.467 5.65h2.604l.01 4.044h3.718z",
      fillRule: "evenodd"
    })), _$1("span", {
      className: "uppy-Dashboard-poweredByUppy"
    }, "Uppy")), oe = Y("poweredBy", {
      uppy: re
    });
    return _$1("a", {
      tabIndex: -1,
      href: "https://uppy.io",
      rel: "noreferrer noopener",
      target: "_blank",
      className: "uppy-Dashboard-poweredBy"
    }, oe);
  }
  render() {
    const {
      showNativePhotoCameraButton: Y,
      showNativeVideoCameraButton: re,
      nativeCameraFacingMode: oe
    } = this.props;
    return _$1("div", {
      className: "uppy-Dashboard-AddFiles"
    }, this.renderHiddenInput(!1, (ue) => {
      this.fileInput = ue;
    }), this.renderHiddenInput(!0, (ue) => {
      this.folderInput = ue;
    }), Y && this.renderHiddenCameraInput("photo", oe, (ue) => {
      this.mobilePhotoFileInput = ue;
    }), re && this.renderHiddenCameraInput("video", oe, (ue) => {
      this.mobileVideoFileInput = ue;
    }), this.renderSourcesList(this.props.acquirers, this.props.disableLocalFiles), _$1("div", {
      className: "uppy-Dashboard-AddFiles-info"
    }, this.props.note && _$1("div", {
      className: "uppy-Dashboard-note"
    }, this.props.note), this.props.proudlyDisplayPoweredByUppy && this.renderPoweredByUppy()));
  }
}
const AddFilesPanel = (le) => _$1("div", {
  className: classNames("uppy-Dashboard-AddFilesPanel", le.className),
  "data-uppy-panelType": "AddFiles",
  "aria-hidden": !le.showAddFilesPanel
}, _$1("div", {
  className: "uppy-DashboardContent-bar"
}, _$1("div", {
  className: "uppy-DashboardContent-title",
  role: "heading",
  "aria-level": "1"
}, le.i18n("addingMoreFiles")), _$1("button", {
  className: "uppy-DashboardContent-back",
  type: "button",
  onClick: () => le.toggleAddFilesPanel(!1)
}, le.i18n("back"))), _$1(AddFiles, le));
function ignoreEvent(le) {
  const {
    tagName: Y
  } = le.target;
  if (Y === "INPUT" || Y === "TEXTAREA") {
    le.stopPropagation();
    return;
  }
  le.preventDefault(), le.stopPropagation();
}
function PickerPanelContent(le) {
  let {
    activePickerPanel: Y,
    className: re,
    hideAllPanels: oe,
    i18n: ue,
    state: fe,
    uppy: he
  } = le;
  const _e = A$1(null);
  return _$1("div", {
    className: classNames("uppy-DashboardContent-panel", re),
    role: "tabpanel",
    "data-uppy-panelType": "PickerPanel",
    id: `uppy-DashboardContent-panel--${Y.id}`,
    onDragOver: ignoreEvent,
    onDragLeave: ignoreEvent,
    onDrop: ignoreEvent,
    onPaste: ignoreEvent
  }, _$1("div", {
    className: "uppy-DashboardContent-bar"
  }, _$1("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, ue("importFrom", {
    name: Y.name
  })), _$1("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: oe
  }, ue("cancel"))), _$1("div", {
    ref: _e,
    className: "uppy-DashboardContent-panelBody"
  }, he.getPlugin(Y.id).render(fe, _e.current)));
}
function EditorPanel(le) {
  const Y = le.files[le.fileCardFor], re = () => {
    le.uppy.emit("file-editor:cancel", Y), le.closeFileEditor();
  };
  return _$1("div", {
    className: classNames("uppy-DashboardContent-panel", le.className),
    role: "tabpanel",
    "data-uppy-panelType": "FileEditor",
    id: "uppy-DashboardContent-panel--editor"
  }, _$1("div", {
    className: "uppy-DashboardContent-bar"
  }, _$1("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, le.i18nArray("editing", {
    file: _$1("span", {
      className: "uppy-DashboardContent-titleFile"
    }, Y.meta ? Y.meta.name : Y.name)
  })), _$1("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: re
  }, le.i18n("cancel")), _$1("button", {
    className: "uppy-DashboardContent-save",
    type: "button",
    onClick: le.saveFileEditor
  }, le.i18n("save"))), _$1("div", {
    className: "uppy-DashboardContent-panelBody"
  }, le.editors.map((oe) => le.uppy.getPlugin(oe.id).render(le.state))));
}
const uploadStates = {
  STATE_ERROR: "error",
  STATE_WAITING: "waiting",
  STATE_PREPROCESSING: "preprocessing",
  STATE_UPLOADING: "uploading",
  STATE_POSTPROCESSING: "postprocessing",
  STATE_COMPLETE: "complete",
  STATE_PAUSED: "paused"
};
function getUploadingState(le, Y, re, oe) {
  if (oe === void 0 && (oe = {}), le)
    return uploadStates.STATE_ERROR;
  if (Y)
    return uploadStates.STATE_COMPLETE;
  if (re)
    return uploadStates.STATE_PAUSED;
  let ue = uploadStates.STATE_WAITING;
  const fe = Object.keys(oe);
  for (let he = 0; he < fe.length; he++) {
    const {
      progress: _e
    } = oe[fe[he]];
    if (_e.uploadStarted && !_e.uploadComplete)
      return uploadStates.STATE_UPLOADING;
    _e.preprocess && ue !== uploadStates.STATE_UPLOADING && (ue = uploadStates.STATE_PREPROCESSING), _e.postprocess && ue !== uploadStates.STATE_UPLOADING && ue !== uploadStates.STATE_PREPROCESSING && (ue = uploadStates.STATE_POSTPROCESSING);
  }
  return ue;
}
function UploadStatus(le) {
  let {
    files: Y,
    i18n: re,
    isAllComplete: oe,
    isAllErrored: ue,
    isAllPaused: fe,
    inProgressNotPausedFiles: he,
    newFiles: _e,
    processingFiles: ve
  } = le;
  switch (getUploadingState(ue, oe, fe, Y)) {
    case "uploading":
      return re("uploadingXFiles", {
        smart_count: he.length
      });
    case "preprocessing":
    case "postprocessing":
      return re("processingXFiles", {
        smart_count: ve.length
      });
    case "paused":
      return re("uploadPaused");
    case "waiting":
      return re("xFilesSelected", {
        smart_count: _e.length
      });
    case "complete":
      return re("uploadComplete");
    case "error":
      return re("error");
  }
}
function PanelTopBar(le) {
  const {
    i18n: Y,
    isAllComplete: re,
    hideCancelButton: oe,
    maxNumberOfFiles: ue,
    toggleAddFilesPanel: fe,
    uppy: he
  } = le;
  let {
    allowNewUpload: _e
  } = le;
  return _e && ue && (_e = le.totalFileCount < le.maxNumberOfFiles), _$1("div", {
    className: "uppy-DashboardContent-bar"
  }, !re && !oe ? _$1("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: () => he.cancelAll()
  }, Y("cancel")) : _$1("div", null), _$1("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, _$1(UploadStatus, le)), _e ? _$1("button", {
    className: "uppy-DashboardContent-addMore",
    type: "button",
    "aria-label": Y("addMoreFiles"),
    title: Y("addMoreFiles"),
    onClick: () => fe(!0)
  }, _$1("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "15",
    height: "15",
    viewBox: "0 0 15 15"
  }, _$1("path", {
    d: "M8 6.5h6a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H8v6a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V8h-6a.5.5 0 0 1-.5-.5V7a.5.5 0 0 1 .5-.5h6v-6A.5.5 0 0 1 7 0h.5a.5.5 0 0 1 .5.5v6z"
  })), _$1("span", {
    className: "uppy-DashboardContent-addMoreCaption"
  }, Y("addMore"))) : _$1("div", null));
}
function RenderMetaFields(le) {
  const {
    computedMetaFields: Y,
    requiredMetaFields: re,
    updateMeta: oe,
    form: ue,
    formState: fe
  } = le, he = {
    text: "uppy-u-reset uppy-c-textInput uppy-Dashboard-FileCard-input"
  };
  return Y.map((_e) => {
    const ve = `uppy-Dashboard-FileCard-input-${_e.id}`, xe = re.includes(_e.id);
    return _$1("fieldset", {
      key: _e.id,
      className: "uppy-Dashboard-FileCard-fieldset"
    }, _$1("label", {
      className: "uppy-Dashboard-FileCard-label",
      htmlFor: ve
    }, _e.name), _e.render !== void 0 ? _e.render({
      value: fe[_e.id],
      onChange: (Ee) => oe(Ee, _e.id),
      fieldCSSClasses: he,
      required: xe,
      form: ue.id
    }, _$1) : _$1("input", {
      className: he.text,
      id: ve,
      form: ue.id,
      type: _e.type || "text",
      required: xe,
      value: fe[_e.id],
      placeholder: _e.placeholder,
      onInput: (Ee) => oe(Ee.target.value, _e.id),
      "data-uppy-super-focusable": !0
    }));
  });
}
function FileCard(le) {
  var Y;
  const {
    files: re,
    fileCardFor: oe,
    toggleFileCard: ue,
    saveFileCard: fe,
    metaFields: he,
    requiredMetaFields: _e,
    openFileEditor: ve,
    i18n: xe,
    i18nArray: Ee,
    className: Se,
    canEditFile: Te
  } = le, Ce = () => typeof he == "function" ? he(re[oe]) : he, Ie = re[oe], Ne = (Y = Ce()) != null ? Y : [], Re = Te(Ie), Ae = {};
  Ne.forEach(($e) => {
    var De;
    Ae[$e.id] = (De = Ie.meta[$e.id]) != null ? De : "";
  });
  const [Pe, Fe] = d$1(Ae), Le = q$2(($e) => {
    $e.preventDefault(), fe(Pe, oe);
  }, [fe, Pe, oe]), He = ($e, De) => {
    Fe({
      ...Pe,
      [De]: $e
    });
  }, Ge = () => {
    ue(!1);
  }, [Ve] = d$1(() => {
    const $e = document.createElement("form");
    return $e.setAttribute("tabindex", "-1"), $e.id = nanoid(), $e;
  });
  return y$1(() => (document.body.appendChild(Ve), Ve.addEventListener("submit", Le), () => {
    Ve.removeEventListener("submit", Le), document.body.removeChild(Ve);
  }), [Ve, Le]), _$1("div", {
    className: classNames("uppy-Dashboard-FileCard", Se),
    "data-uppy-panelType": "FileCard",
    onDragOver: ignoreEvent,
    onDragLeave: ignoreEvent,
    onDrop: ignoreEvent,
    onPaste: ignoreEvent
  }, _$1("div", {
    className: "uppy-DashboardContent-bar"
  }, _$1("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, Ee("editing", {
    file: _$1("span", {
      className: "uppy-DashboardContent-titleFile"
    }, Ie.meta ? Ie.meta.name : Ie.name)
  })), _$1("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    form: Ve.id,
    title: xe("finishEditingFile"),
    onClick: Ge
  }, xe("cancel"))), _$1("div", {
    className: "uppy-Dashboard-FileCard-inner"
  }, _$1("div", {
    className: "uppy-Dashboard-FileCard-preview",
    style: {
      backgroundColor: getIconByMime(Ie.type).color
    }
  }, _$1(FilePreview, {
    file: Ie
  }), Re && _$1("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-Dashboard-FileCard-edit",
    onClick: ($e) => {
      Le($e), ve(Ie);
    }
  }, xe("editImage"))), _$1("div", {
    className: "uppy-Dashboard-FileCard-info"
  }, _$1(RenderMetaFields, {
    computedMetaFields: Ne,
    requiredMetaFields: _e,
    updateMeta: He,
    form: Ve,
    formState: Pe
  })), _$1("div", {
    className: "uppy-Dashboard-FileCard-actions"
  }, _$1("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Dashboard-FileCard-actionsBtn",
    type: "submit",
    form: Ve.id
  }, xe("saveChanges")), _$1("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-link uppy-Dashboard-FileCard-actionsBtn",
    type: "button",
    onClick: Ge,
    form: Ve.id
  }, xe("cancel")))));
}
const transitionName = "uppy-transition-slideDownUp", duration = 250;
function Slide(le) {
  let {
    children: Y
  } = le;
  const [re, oe] = d$1(null), [ue, fe] = d$1(""), he = A$1(), _e = A$1(), ve = A$1(), xe = () => {
    fe(`${transitionName}-enter`), cancelAnimationFrame(ve.current), clearTimeout(_e.current), _e.current = void 0, ve.current = requestAnimationFrame(() => {
      fe(`${transitionName}-enter ${transitionName}-enter-active`), he.current = setTimeout(() => {
        fe("");
      }, duration);
    });
  }, Ee = () => {
    fe(`${transitionName}-leave`), cancelAnimationFrame(ve.current), clearTimeout(he.current), he.current = void 0, ve.current = requestAnimationFrame(() => {
      fe(`${transitionName}-leave ${transitionName}-leave-active`), _e.current = setTimeout(() => {
        oe(null), fe("");
      }, duration);
    });
  };
  return y$1(() => {
    const Se = H$2(Y)[0];
    re !== Se && (Se && !re ? xe() : re && !Se && !_e.current && Ee(), oe(Se));
  }, [Y, re]), y$1(() => () => {
    clearTimeout(he.current), clearTimeout(_e.current), cancelAnimationFrame(ve.current);
  }, []), re ? J$2(re, {
    className: classNames(ue, re.props.className)
  }) : null;
}
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(le) {
    for (var Y = 1; Y < arguments.length; Y++) {
      var re = arguments[Y];
      for (var oe in re) ({}).hasOwnProperty.call(re, oe) && (le[oe] = re[oe]);
    }
    return le;
  }, _extends$1.apply(null, arguments);
}
const WIDTH_XL = 900, WIDTH_LG = 700, WIDTH_MD = 576, HEIGHT_MD = 330;
function Dashboard$1(le) {
  const Y = le.totalFileCount === 0, re = le.totalFileCount === 1, oe = le.containerWidth > WIDTH_MD, ue = le.containerHeight > HEIGHT_MD, fe = classNames({
    "uppy-Dashboard": !0,
    "uppy-Dashboard--isDisabled": le.disabled,
    "uppy-Dashboard--animateOpenClose": le.animateOpenClose,
    "uppy-Dashboard--isClosing": le.isClosing,
    "uppy-Dashboard--isDraggingOver": le.isDraggingOver,
    "uppy-Dashboard--modal": !le.inline,
    "uppy-size--md": le.containerWidth > WIDTH_MD,
    "uppy-size--lg": le.containerWidth > WIDTH_LG,
    "uppy-size--xl": le.containerWidth > WIDTH_XL,
    "uppy-size--height-md": le.containerHeight > HEIGHT_MD,
    // We might want to enable this in the future
    // 'uppy-size--height-lg': props.containerHeight > HEIGHT_LG,
    // 'uppy-size--height-xl': props.containerHeight > HEIGHT_XL,
    "uppy-Dashboard--isAddFilesPanelVisible": le.showAddFilesPanel,
    "uppy-Dashboard--isInnerWrapVisible": le.areInsidesReadyToBeVisible,
    // Only enable “centered single file” mode when Dashboard is tall enough
    "uppy-Dashboard--singleFile": le.singleFileFullScreen && re && ue
  });
  let he = 1;
  le.containerWidth > WIDTH_XL ? he = 5 : le.containerWidth > WIDTH_LG ? he = 4 : le.containerWidth > WIDTH_MD && (he = 3);
  const _e = le.showSelectedFiles && !Y, ve = le.recoveredState ? Object.keys(le.recoveredState.files).length : null, xe = le.files ? Object.keys(le.files).filter((Te) => le.files[Te].isGhost).length : 0, Ee = () => xe > 0 ? le.i18n("recoveredXFiles", {
    smart_count: xe
  }) : le.i18n("recoveredAllFiles");
  return _$1("div", {
    className: fe,
    "data-uppy-theme": le.theme,
    "data-uppy-num-acquirers": le.acquirers.length,
    "data-uppy-drag-drop-supported": !le.disableLocalFiles && isDragDropSupported(),
    "aria-hidden": le.inline ? "false" : le.isHidden,
    "aria-disabled": le.disabled,
    "aria-label": le.inline ? le.i18n("dashboardTitle") : le.i18n("dashboardWindowTitle"),
    onPaste: le.handlePaste,
    onDragOver: le.handleDragOver,
    onDragLeave: le.handleDragLeave,
    onDrop: le.handleDrop
  }, _$1("div", {
    "aria-hidden": "true",
    className: "uppy-Dashboard-overlay",
    tabIndex: -1,
    onClick: le.handleClickOutside
  }), _$1("div", {
    className: "uppy-Dashboard-inner",
    "aria-modal": !le.inline && "true",
    role: le.inline ? void 0 : "dialog",
    style: {
      width: le.inline && le.width ? le.width : "",
      height: le.inline && le.height ? le.height : ""
    }
  }, le.inline ? null : _$1("button", {
    className: "uppy-u-reset uppy-Dashboard-close",
    type: "button",
    "aria-label": le.i18n("closeModal"),
    title: le.i18n("closeModal"),
    onClick: le.closeModal
  }, _$1("span", {
    "aria-hidden": "true"
  }, "×")), _$1("div", {
    className: "uppy-Dashboard-innerWrap"
  }, _$1("div", {
    className: "uppy-Dashboard-dropFilesHereHint"
  }, le.i18n("dropHint")), _e && _$1(PanelTopBar, le), ve && _$1("div", {
    className: "uppy-Dashboard-serviceMsg"
  }, _$1("svg", {
    className: "uppy-Dashboard-serviceMsg-icon",
    "aria-hidden": "true",
    focusable: "false",
    width: "21",
    height: "16",
    viewBox: "0 0 24 19"
  }, _$1("g", {
    transform: "translate(0 -1)",
    fill: "none",
    fillRule: "evenodd"
  }, _$1("path", {
    d: "M12.857 1.43l10.234 17.056A1 1 0 0122.234 20H1.766a1 1 0 01-.857-1.514L11.143 1.429a1 1 0 011.714 0z",
    fill: "#FFD300"
  }), _$1("path", {
    fill: "#000",
    d: "M11 6h2l-.3 8h-1.4z"
  }), _$1("circle", {
    fill: "#000",
    cx: "12",
    cy: "17",
    r: "1"
  }))), _$1("strong", {
    className: "uppy-Dashboard-serviceMsg-title"
  }, le.i18n("sessionRestored")), _$1("div", {
    className: "uppy-Dashboard-serviceMsg-text"
  }, Ee())), _e ? _$1(FileList, {
    id: le.id,
    i18n: le.i18n,
    uppy: le.uppy,
    files: le.files,
    resumableUploads: le.resumableUploads,
    hideRetryButton: le.hideRetryButton,
    hidePauseResumeButton: le.hidePauseResumeButton,
    hideCancelButton: le.hideCancelButton,
    showLinkToFileUploadResult: le.showLinkToFileUploadResult,
    showRemoveButtonAfterComplete: le.showRemoveButtonAfterComplete,
    metaFields: le.metaFields,
    toggleFileCard: le.toggleFileCard,
    handleRequestThumbnail: le.handleRequestThumbnail,
    handleCancelThumbnail: le.handleCancelThumbnail,
    recoveredState: le.recoveredState,
    individualCancellation: le.individualCancellation,
    openFileEditor: le.openFileEditor,
    canEditFile: le.canEditFile,
    toggleAddFilesPanel: le.toggleAddFilesPanel,
    isSingleFile: re,
    itemsPerRow: he,
    containerWidth: le.containerWidth,
    containerHeight: le.containerHeight
  }) : _$1(AddFiles, {
    i18n: le.i18n,
    i18nArray: le.i18nArray,
    acquirers: le.acquirers,
    handleInputChange: le.handleInputChange,
    maxNumberOfFiles: le.maxNumberOfFiles,
    allowedFileTypes: le.allowedFileTypes,
    showNativePhotoCameraButton: le.showNativePhotoCameraButton,
    showNativeVideoCameraButton: le.showNativeVideoCameraButton,
    nativeCameraFacingMode: le.nativeCameraFacingMode,
    showPanel: le.showPanel,
    activePickerPanel: le.activePickerPanel,
    disableLocalFiles: le.disableLocalFiles,
    fileManagerSelectionType: le.fileManagerSelectionType,
    note: le.note,
    proudlyDisplayPoweredByUppy: le.proudlyDisplayPoweredByUppy
  }), _$1(Slide, null, le.showAddFilesPanel ? _$1(AddFilesPanel, _extends$1({
    key: "AddFiles"
  }, le, {
    isSizeMD: oe
  })) : null), _$1(Slide, null, le.fileCardFor ? _$1(FileCard, _extends$1({
    key: "FileCard"
  }, le)) : null), _$1(Slide, null, le.activePickerPanel ? _$1(PickerPanelContent, _extends$1({
    key: "Picker"
  }, le)) : null), _$1(Slide, null, le.showFileEditor ? _$1(EditorPanel, _extends$1({
    key: "Editor"
  }, le)) : null), _$1("div", {
    className: "uppy-Dashboard-progressindicators"
  }, le.progressindicators.map((Te) => le.uppy.getPlugin(Te.id).render(le.state))))));
}
const locale$2 = {
  strings: {
    // When `inline: false`, used as the screen reader label for the button that closes the modal.
    closeModal: "Close Modal",
    // Used as the screen reader label for the plus (+) button that shows the “Add more files” screen
    addMoreFiles: "Add more files",
    addingMoreFiles: "Adding more files",
    // Used as the header for import panels, e.g., “Import from Google Drive”.
    importFrom: "Import from %{name}",
    // When `inline: false`, used as the screen reader label for the dashboard modal.
    dashboardWindowTitle: "Uppy Dashboard Window (Press escape to close)",
    // When `inline: true`, used as the screen reader label for the dashboard area.
    dashboardTitle: "Uppy Dashboard",
    // Shown in the Informer when a link to a file was copied to the clipboard.
    copyLinkToClipboardSuccess: "Link copied to clipboard.",
    // Used when a link cannot be copied automatically — the user has to select the text from the
    // input element below this string.
    copyLinkToClipboardFallback: "Copy the URL below",
    // Used as the hover title and screen reader label for buttons that copy a file link.
    copyLink: "Copy link",
    back: "Back",
    // Used as the screen reader label for buttons that remove a file.
    removeFile: "Remove file",
    // Used as the screen reader label for buttons that open the metadata editor panel for a file.
    editFile: "Edit file",
    editImage: "Edit image",
    // Shown in the panel header for the metadata editor. Rendered as “Editing image.png”.
    editing: "Editing %{file}",
    // Shown on the main upload screen when an upload error occurs
    error: "Error",
    // Used as the screen reader label for the button that saves metadata edits and returns to the
    // file list view.
    finishEditingFile: "Finish editing file",
    saveChanges: "Save changes",
    // Used as the label for the tab button that opens the system file selection dialog.
    myDevice: "My Device",
    dropHint: "Drop your files here",
    // Used as the hover text and screen reader label for file progress indicators when
    // they have been fully uploaded.
    uploadComplete: "Upload complete",
    uploadPaused: "Upload paused",
    // Used as the hover text and screen reader label for the buttons to resume paused uploads.
    resumeUpload: "Resume upload",
    // Used as the hover text and screen reader label for the buttons to pause uploads.
    pauseUpload: "Pause upload",
    // Used as the hover text and screen reader label for the buttons to retry failed uploads.
    retryUpload: "Retry upload",
    // Used as the hover text and screen reader label for the buttons to cancel uploads.
    cancelUpload: "Cancel upload",
    // Used in a title, how many files are currently selected
    xFilesSelected: {
      0: "%{smart_count} file selected",
      1: "%{smart_count} files selected"
    },
    uploadingXFiles: {
      0: "Uploading %{smart_count} file",
      1: "Uploading %{smart_count} files"
    },
    processingXFiles: {
      0: "Processing %{smart_count} file",
      1: "Processing %{smart_count} files"
    },
    // The "powered by Uppy" link at the bottom of the Dashboard.
    poweredBy: "Powered by %{uppy}",
    addMore: "Add more",
    editFileWithFilename: "Edit file %{file}",
    save: "Save",
    cancel: "Cancel",
    dropPasteFiles: "Drop files here or %{browseFiles}",
    dropPasteFolders: "Drop files here or %{browseFolders}",
    dropPasteBoth: "Drop files here, %{browseFiles} or %{browseFolders}",
    dropPasteImportFiles: "Drop files here, %{browseFiles} or import from:",
    dropPasteImportFolders: "Drop files here, %{browseFolders} or import from:",
    dropPasteImportBoth: "Drop files here, %{browseFiles}, %{browseFolders} or import from:",
    importFiles: "Import files from:",
    browseFiles: "browse files",
    browseFolders: "browse folders",
    recoveredXFiles: {
      0: "We could not fully recover 1 file. Please re-select it and resume the upload.",
      1: "We could not fully recover %{smart_count} files. Please re-select them and resume the upload."
    },
    recoveredAllFiles: "We restored all files. You can now resume the upload.",
    sessionRestored: "Session restored",
    reSelect: "Re-select",
    missingRequiredMetaFields: {
      0: "Missing required meta field: %{fields}.",
      1: "Missing required meta fields: %{fields}."
    },
    // Used for native device camera buttons on mobile
    takePictureBtn: "Take Picture",
    recordVideoBtn: "Record Video"
  }
};
function _classPrivateFieldLooseBase$2(le, Y) {
  if (!{}.hasOwnProperty.call(le, Y)) throw new TypeError("attempted to use private field on non-instance");
  return le;
}
var id$2 = 0;
function _classPrivateFieldLooseKey$2(le) {
  return "__private_" + id$2++ + "_" + le;
}
const packageJson$1 = {
  version: "4.3.4"
}, memoize = memoizeOne.default || memoizeOne, TAB_KEY = 9, ESC_KEY = 27;
function createPromise() {
  const le = {};
  return le.promise = new Promise((Y, re) => {
    le.resolve = Y, le.reject = re;
  }), le;
}
const defaultOptions$3 = {
  target: "body",
  metaFields: [],
  thumbnailWidth: 280,
  thumbnailType: "image/jpeg",
  waitForThumbnailsBeforeUpload: !1,
  defaultPickerIcon,
  showLinkToFileUploadResult: !1,
  showProgressDetails: !1,
  hideUploadButton: !1,
  hideCancelButton: !1,
  hideRetryButton: !1,
  hidePauseResumeButton: !1,
  hideProgressAfterFinish: !1,
  note: null,
  singleFileFullScreen: !0,
  disableStatusBar: !1,
  disableInformer: !1,
  disableThumbnailGenerator: !1,
  fileManagerSelectionType: "files",
  proudlyDisplayPoweredByUppy: !0,
  showSelectedFiles: !0,
  showRemoveButtonAfterComplete: !1,
  showNativePhotoCameraButton: !1,
  showNativeVideoCameraButton: !1,
  theme: "light",
  autoOpen: null,
  disabled: !1,
  disableLocalFiles: !1,
  nativeCameraFacingMode: "",
  onDragLeave: () => {
  },
  onDragOver: () => {
  },
  onDrop: () => {
  },
  plugins: [],
  // Dynamic default options, they have to be defined in the constructor (because
  // they require access to the `this` keyword), but we still want them to
  // appear in the default options so TS knows they'll be defined.
  doneButtonHandler: void 0,
  onRequestCloseModal: null,
  // defaultModalOptions
  inline: !1,
  animateOpenClose: !0,
  browserBackButtonClose: !1,
  closeAfterFinish: !1,
  closeModalOnClickOutside: !1,
  disablePageScrollWhenModalOpen: !0,
  trigger: null,
  // defaultInlineOptions
  width: 750,
  height: 550
};
var _disabledNodes = /* @__PURE__ */ _classPrivateFieldLooseKey$2("disabledNodes"), _generateLargeThumbnailIfSingleFile = /* @__PURE__ */ _classPrivateFieldLooseKey$2("generateLargeThumbnailIfSingleFile"), _openFileEditorWhenFilesAdded = /* @__PURE__ */ _classPrivateFieldLooseKey$2("openFileEditorWhenFilesAdded"), _attachRenderFunctionToTarget = /* @__PURE__ */ _classPrivateFieldLooseKey$2("attachRenderFunctionToTarget"), _isTargetSupported = /* @__PURE__ */ _classPrivateFieldLooseKey$2("isTargetSupported"), _getAcquirers = /* @__PURE__ */ _classPrivateFieldLooseKey$2("getAcquirers"), _getProgressIndicators = /* @__PURE__ */ _classPrivateFieldLooseKey$2("getProgressIndicators"), _getEditors = /* @__PURE__ */ _classPrivateFieldLooseKey$2("getEditors"), _addSpecifiedPluginsFromOptions = /* @__PURE__ */ _classPrivateFieldLooseKey$2("addSpecifiedPluginsFromOptions"), _autoDiscoverPlugins = /* @__PURE__ */ _classPrivateFieldLooseKey$2("autoDiscoverPlugins"), _addSupportedPluginIfNoTarget = /* @__PURE__ */ _classPrivateFieldLooseKey$2("addSupportedPluginIfNoTarget"), _getStatusBarOpts = /* @__PURE__ */ _classPrivateFieldLooseKey$2("getStatusBarOpts"), _getThumbnailGeneratorOpts = /* @__PURE__ */ _classPrivateFieldLooseKey$2("getThumbnailGeneratorOpts"), _getInformerOpts = /* @__PURE__ */ _classPrivateFieldLooseKey$2("getInformerOpts"), _getStatusBarId = /* @__PURE__ */ _classPrivateFieldLooseKey$2("getStatusBarId"), _getThumbnailGeneratorId = /* @__PURE__ */ _classPrivateFieldLooseKey$2("getThumbnailGeneratorId"), _getInformerId = /* @__PURE__ */ _classPrivateFieldLooseKey$2("getInformerId");
class Dashboard extends UIPlugin {
  // Timeouts
  constructor(Y, re) {
    var oe, ue, fe;
    const he = (oe = re?.autoOpen) != null ? oe : null;
    super(Y, {
      ...defaultOptions$3,
      ...re,
      autoOpen: he
    }), Object.defineProperty(this, _getInformerId, {
      value: _getInformerId2
    }), Object.defineProperty(this, _getThumbnailGeneratorId, {
      value: _getThumbnailGeneratorId2
    }), Object.defineProperty(this, _getStatusBarId, {
      value: _getStatusBarId2
    }), Object.defineProperty(this, _getInformerOpts, {
      value: _getInformerOpts2
    }), Object.defineProperty(this, _getThumbnailGeneratorOpts, {
      value: _getThumbnailGeneratorOpts2
    }), Object.defineProperty(this, _getStatusBarOpts, {
      value: _getStatusBarOpts2
    }), Object.defineProperty(this, _disabledNodes, {
      writable: !0,
      value: void 0
    }), this.modalName = `uppy-Dashboard-${nanoid()}`, this.superFocus = createSuperFocus(), this.ifFocusedOnUppyRecently = !1, this.removeTarget = (_e) => {
      const xe = this.getPluginState().targets.filter((Ee) => Ee.id !== _e.id);
      this.setPluginState({
        targets: xe
      });
    }, this.addTarget = (_e) => {
      const ve = _e.id || _e.constructor.name, xe = _e.title || ve, Ee = _e.type;
      if (Ee !== "acquirer" && Ee !== "progressindicator" && Ee !== "editor")
        return this.uppy.log("Dashboard: can only be targeted by plugins of types: acquirer, progressindicator, editor", "error"), null;
      const Se = {
        id: ve,
        name: xe,
        type: Ee
      }, Ce = this.getPluginState().targets.slice();
      return Ce.push(Se), this.setPluginState({
        targets: Ce
      }), this.el;
    }, this.hideAllPanels = () => {
      var _e;
      const ve = this.getPluginState(), xe = {
        activePickerPanel: void 0,
        showAddFilesPanel: !1,
        activeOverlayType: null,
        fileCardFor: null,
        showFileEditor: !1
      };
      ve.activePickerPanel === xe.activePickerPanel && ve.showAddFilesPanel === xe.showAddFilesPanel && ve.showFileEditor === xe.showFileEditor && ve.activeOverlayType === xe.activeOverlayType || (this.setPluginState(xe), this.uppy.emit("dashboard:close-panel", (_e = ve.activePickerPanel) == null ? void 0 : _e.id));
    }, this.showPanel = (_e) => {
      const {
        targets: ve
      } = this.getPluginState(), xe = ve.find((Ee) => Ee.type === "acquirer" && Ee.id === _e);
      this.setPluginState({
        activePickerPanel: xe,
        activeOverlayType: "PickerPanel"
      }), this.uppy.emit("dashboard:show-panel", _e);
    }, this.canEditFile = (_e) => {
      const {
        targets: ve
      } = this.getPluginState();
      return _classPrivateFieldLooseBase$2(this, _getEditors)[_getEditors](ve).some((Ee) => this.uppy.getPlugin(Ee.id).canEditFile(_e));
    }, this.openFileEditor = (_e) => {
      const {
        targets: ve
      } = this.getPluginState(), xe = _classPrivateFieldLooseBase$2(this, _getEditors)[_getEditors](ve);
      this.setPluginState({
        showFileEditor: !0,
        fileCardFor: _e.id || null,
        activeOverlayType: "FileEditor"
      }), xe.forEach((Ee) => {
        this.uppy.getPlugin(Ee.id).selectFile(_e);
      });
    }, this.closeFileEditor = () => {
      const {
        metaFields: _e
      } = this.getPluginState();
      _e && _e.length > 0 ? this.setPluginState({
        showFileEditor: !1,
        activeOverlayType: "FileCard"
      }) : this.setPluginState({
        showFileEditor: !1,
        fileCardFor: null,
        activeOverlayType: "AddFiles"
      });
    }, this.saveFileEditor = () => {
      const {
        targets: _e
      } = this.getPluginState();
      _classPrivateFieldLooseBase$2(this, _getEditors)[_getEditors](_e).forEach((xe) => {
        this.uppy.getPlugin(xe.id).save();
      }), this.closeFileEditor();
    }, this.openModal = () => {
      const {
        promise: _e,
        resolve: ve
      } = createPromise();
      if (this.savedScrollPosition = window.pageYOffset, this.savedActiveElement = document.activeElement, this.opts.disablePageScrollWhenModalOpen && document.body.classList.add("uppy-Dashboard-isFixed"), this.opts.animateOpenClose && this.getPluginState().isClosing) {
        const xe = () => {
          this.setPluginState({
            isHidden: !1
          }), this.el.removeEventListener("animationend", xe, !1), ve();
        };
        this.el.addEventListener("animationend", xe, !1);
      } else
        this.setPluginState({
          isHidden: !1
        }), ve();
      return this.opts.browserBackButtonClose && this.updateBrowserHistory(), document.addEventListener("keydown", this.handleKeyDownInModal), this.uppy.emit("dashboard:modal-open"), _e;
    }, this.closeModal = (_e) => {
      var ve;
      const xe = (ve = _e?.manualClose) != null ? ve : !0, {
        isHidden: Ee,
        isClosing: Se
      } = this.getPluginState();
      if (Ee || Se)
        return;
      const {
        promise: Te,
        resolve: Ce
      } = createPromise();
      if (this.opts.disablePageScrollWhenModalOpen && document.body.classList.remove("uppy-Dashboard-isFixed"), this.opts.animateOpenClose) {
        this.setPluginState({
          isClosing: !0
        });
        const Ne = () => {
          this.setPluginState({
            isHidden: !0,
            isClosing: !1
          }), this.superFocus.cancel(), this.savedActiveElement.focus(), this.el.removeEventListener("animationend", Ne, !1), Ce();
        };
        this.el.addEventListener("animationend", Ne, !1);
      } else
        this.setPluginState({
          isHidden: !0
        }), this.superFocus.cancel(), this.savedActiveElement.focus(), Ce();
      if (document.removeEventListener("keydown", this.handleKeyDownInModal), xe && this.opts.browserBackButtonClose) {
        var Ie;
        (Ie = history.state) != null && Ie[this.modalName] && history.back();
      }
      return this.uppy.emit("dashboard:modal-closed"), Te;
    }, this.isModalOpen = () => !this.getPluginState().isHidden || !1, this.requestCloseModal = () => this.opts.onRequestCloseModal ? this.opts.onRequestCloseModal() : this.closeModal(), this.setDarkModeCapability = (_e) => {
      const {
        capabilities: ve
      } = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...ve,
          darkMode: _e
        }
      });
    }, this.handleSystemDarkModeChange = (_e) => {
      const ve = _e.matches;
      this.uppy.log(`[Dashboard] Dark mode is ${ve ? "on" : "off"}`), this.setDarkModeCapability(ve);
    }, this.toggleFileCard = (_e, ve) => {
      const xe = this.uppy.getFile(ve);
      _e ? this.uppy.emit("dashboard:file-edit-start", xe) : this.uppy.emit("dashboard:file-edit-complete", xe), this.setPluginState({
        fileCardFor: _e ? ve : null,
        activeOverlayType: _e ? "FileCard" : null
      });
    }, this.toggleAddFilesPanel = (_e) => {
      this.setPluginState({
        showAddFilesPanel: _e,
        activeOverlayType: _e ? "AddFiles" : null
      });
    }, this.addFiles = (_e) => {
      const ve = _e.map((xe) => ({
        source: this.id,
        name: xe.name,
        type: xe.type,
        data: xe,
        meta: {
          // path of the file relative to the ancestor directory the user selected.
          // e.g. 'docs/Old Prague/airbnb.pdf'
          relativePath: xe.relativePath || xe.webkitRelativePath || null
        }
      }));
      try {
        this.uppy.addFiles(ve);
      } catch (xe) {
        this.uppy.log(xe);
      }
    }, this.startListeningToResize = () => {
      this.resizeObserver = new ResizeObserver((_e) => {
        const ve = _e[0], {
          width: xe,
          height: Ee
        } = ve.contentRect;
        this.setPluginState({
          containerWidth: xe,
          containerHeight: Ee,
          areInsidesReadyToBeVisible: !0
        });
      }), this.resizeObserver.observe(this.el.querySelector(".uppy-Dashboard-inner")), this.makeDashboardInsidesVisibleAnywayTimeout = setTimeout(() => {
        const _e = this.getPluginState(), ve = !this.opts.inline && _e.isHidden;
        // We might want to enable this in the future
        // if ResizeObserver hasn't yet fired,
        !_e.areInsidesReadyToBeVisible && // and it's not due to the modal being closed
        !ve && (this.uppy.log("[Dashboard] resize event didn’t fire on time: defaulted to mobile layout", "warning"), this.setPluginState({
          areInsidesReadyToBeVisible: !0
        }));
      }, 1e3);
    }, this.stopListeningToResize = () => {
      this.resizeObserver.disconnect(), clearTimeout(this.makeDashboardInsidesVisibleAnywayTimeout);
    }, this.recordIfFocusedOnUppyRecently = (_e) => {
      this.el.contains(_e.target) ? this.ifFocusedOnUppyRecently = !0 : (this.ifFocusedOnUppyRecently = !1, this.superFocus.cancel());
    }, this.disableInteractiveElements = (_e) => {
      var ve;
      const xe = ["a[href]", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", '[role="button"]:not([disabled])'], Ee = (ve = _classPrivateFieldLooseBase$2(this, _disabledNodes)[_disabledNodes]) != null ? ve : toArray$2(this.el.querySelectorAll(xe)).filter((Se) => !Se.classList.contains("uppy-Dashboard-close"));
      for (const Se of Ee)
        Se.tagName === "A" ? Se.setAttribute("aria-disabled", _e) : Se.disabled = _e;
      _e ? _classPrivateFieldLooseBase$2(this, _disabledNodes)[_disabledNodes] = Ee : _classPrivateFieldLooseBase$2(this, _disabledNodes)[_disabledNodes] = null, this.dashboardIsDisabled = _e;
    }, this.updateBrowserHistory = () => {
      var _e;
      (_e = history.state) != null && _e[this.modalName] || history.pushState({
        // eslint-disable-next-line no-restricted-globals
        ...history.state,
        [this.modalName]: !0
      }, ""), window.addEventListener("popstate", this.handlePopState, !1);
    }, this.handlePopState = (_e) => {
      var ve;
      this.isModalOpen() && (!_e.state || !_e.state[this.modalName]) && this.closeModal({
        manualClose: !1
      }), !this.isModalOpen() && (ve = _e.state) != null && ve[this.modalName] && history.back();
    }, this.handleKeyDownInModal = (_e) => {
      _e.keyCode === ESC_KEY && this.requestCloseModal(), _e.keyCode === TAB_KEY && trapFocus(_e, this.getPluginState().activeOverlayType, this.el);
    }, this.handleClickOutside = () => {
      this.opts.closeModalOnClickOutside && this.requestCloseModal();
    }, this.handlePaste = (_e) => {
      this.uppy.iteratePlugins((xe) => {
        xe.type === "acquirer" && (xe.handleRootPaste == null || xe.handleRootPaste(_e));
      });
      const ve = toArray$2(_e.clipboardData.files);
      ve.length > 0 && (this.uppy.log("[Dashboard] Files pasted"), this.addFiles(ve));
    }, this.handleInputChange = (_e) => {
      _e.preventDefault();
      const ve = toArray$2(_e.currentTarget.files || []);
      ve.length > 0 && (this.uppy.log("[Dashboard] Files selected through input"), this.addFiles(ve));
    }, this.handleDragOver = (_e) => {
      _e.preventDefault(), _e.stopPropagation();
      const ve = () => {
        let Te = !0;
        return this.uppy.iteratePlugins((Ce) => {
          Ce.canHandleRootDrop != null && Ce.canHandleRootDrop(_e) && (Te = !0);
        }), Te;
      }, xe = () => {
        const {
          types: Te
        } = _e.dataTransfer;
        return Te.some((Ce) => Ce === "Files");
      }, Ee = ve(), Se = xe();
      if (!Ee && !Se || this.opts.disabled || // opts.disableLocalFiles should only be taken into account if no plugins
      // can handle the datatransfer
      this.opts.disableLocalFiles && (Se || !Ee) || !this.uppy.getState().allowNewUpload) {
        _e.dataTransfer.dropEffect = "none";
        return;
      }
      _e.dataTransfer.dropEffect = "copy", this.setPluginState({
        isDraggingOver: !0
      }), this.opts.onDragOver(_e);
    }, this.handleDragLeave = (_e) => {
      _e.preventDefault(), _e.stopPropagation(), this.setPluginState({
        isDraggingOver: !1
      }), this.opts.onDragLeave(_e);
    }, this.handleDrop = async (_e) => {
      _e.preventDefault(), _e.stopPropagation(), this.setPluginState({
        isDraggingOver: !1
      }), this.uppy.iteratePlugins((Se) => {
        Se.type === "acquirer" && (Se.handleRootDrop == null || Se.handleRootDrop(_e));
      });
      let ve = !1;
      const xe = (Se) => {
        this.uppy.log(Se, "error"), ve || (this.uppy.info(Se.message, "error"), ve = !0);
      };
      this.uppy.log("[Dashboard] Processing dropped files");
      const Ee = await getDroppedFiles(_e.dataTransfer, {
        logDropError: xe
      });
      Ee.length > 0 && (this.uppy.log("[Dashboard] Files dropped"), this.addFiles(Ee)), this.opts.onDrop(_e);
    }, this.handleRequestThumbnail = (_e) => {
      this.opts.waitForThumbnailsBeforeUpload || this.uppy.emit("thumbnail:request", _e);
    }, this.handleCancelThumbnail = (_e) => {
      this.opts.waitForThumbnailsBeforeUpload || this.uppy.emit("thumbnail:cancel", _e);
    }, this.handleKeyDownInInline = (_e) => {
      _e.keyCode === TAB_KEY && forInline(_e, this.getPluginState().activeOverlayType, this.el);
    }, this.handlePasteOnBody = (_e) => {
      this.el.contains(document.activeElement) && this.handlePaste(_e);
    }, this.handleComplete = (_e) => {
      let {
        failed: ve
      } = _e;
      this.opts.closeAfterFinish && !(ve != null && ve.length) && this.requestCloseModal();
    }, this.handleCancelRestore = () => {
      this.uppy.emit("restore-canceled");
    }, Object.defineProperty(this, _generateLargeThumbnailIfSingleFile, {
      writable: !0,
      value: () => {
        if (this.opts.disableThumbnailGenerator)
          return;
        const _e = 600, ve = this.uppy.getFiles();
        if (ve.length === 1) {
          const xe = this.uppy.getPlugin(`${this.id}:ThumbnailGenerator`);
          xe?.setOptions({
            thumbnailWidth: _e
          });
          const Ee = {
            ...ve[0],
            preview: void 0
          };
          xe?.requestThumbnail(Ee).then(() => {
            xe?.setOptions({
              thumbnailWidth: this.opts.thumbnailWidth
            });
          });
        }
      }
    }), Object.defineProperty(this, _openFileEditorWhenFilesAdded, {
      writable: !0,
      value: (_e) => {
        const ve = _e[0], {
          metaFields: xe
        } = this.getPluginState(), Ee = xe && xe.length > 0, Se = this.canEditFile(ve);
        Ee && this.opts.autoOpen === "metaEditor" ? this.toggleFileCard(!0, ve.id) : Se && this.opts.autoOpen === "imageEditor" && this.openFileEditor(ve);
      }
    }), this.initEvents = () => {
      if (this.opts.trigger && !this.opts.inline) {
        const _e = findAllDOMElements(this.opts.trigger);
        _e ? _e.forEach((ve) => ve.addEventListener("click", this.openModal)) : this.uppy.log("Dashboard modal trigger not found. Make sure `trigger` is set in Dashboard options, unless you are planning to call `dashboard.openModal()` method yourself", "warning");
      }
      this.startListeningToResize(), document.addEventListener("paste", this.handlePasteOnBody), this.uppy.on("plugin-added", _classPrivateFieldLooseBase$2(this, _addSupportedPluginIfNoTarget)[_addSupportedPluginIfNoTarget]), this.uppy.on("plugin-remove", this.removeTarget), this.uppy.on("file-added", this.hideAllPanels), this.uppy.on("dashboard:modal-closed", this.hideAllPanels), this.uppy.on("complete", this.handleComplete), this.uppy.on("files-added", _classPrivateFieldLooseBase$2(this, _generateLargeThumbnailIfSingleFile)[_generateLargeThumbnailIfSingleFile]), this.uppy.on("file-removed", _classPrivateFieldLooseBase$2(this, _generateLargeThumbnailIfSingleFile)[_generateLargeThumbnailIfSingleFile]), document.addEventListener("focus", this.recordIfFocusedOnUppyRecently, !0), document.addEventListener("click", this.recordIfFocusedOnUppyRecently, !0), this.opts.inline && this.el.addEventListener("keydown", this.handleKeyDownInInline), this.opts.autoOpen && this.uppy.on("files-added", _classPrivateFieldLooseBase$2(this, _openFileEditorWhenFilesAdded)[_openFileEditorWhenFilesAdded]);
    }, this.removeEvents = () => {
      const _e = findAllDOMElements(this.opts.trigger);
      !this.opts.inline && _e && _e.forEach((ve) => ve.removeEventListener("click", this.openModal)), this.stopListeningToResize(), document.removeEventListener("paste", this.handlePasteOnBody), window.removeEventListener("popstate", this.handlePopState, !1), this.uppy.off("plugin-added", _classPrivateFieldLooseBase$2(this, _addSupportedPluginIfNoTarget)[_addSupportedPluginIfNoTarget]), this.uppy.off("plugin-remove", this.removeTarget), this.uppy.off("file-added", this.hideAllPanels), this.uppy.off("dashboard:modal-closed", this.hideAllPanels), this.uppy.off("complete", this.handleComplete), this.uppy.off("files-added", _classPrivateFieldLooseBase$2(this, _generateLargeThumbnailIfSingleFile)[_generateLargeThumbnailIfSingleFile]), this.uppy.off("file-removed", _classPrivateFieldLooseBase$2(this, _generateLargeThumbnailIfSingleFile)[_generateLargeThumbnailIfSingleFile]), document.removeEventListener("focus", this.recordIfFocusedOnUppyRecently), document.removeEventListener("click", this.recordIfFocusedOnUppyRecently), this.opts.inline && this.el.removeEventListener("keydown", this.handleKeyDownInInline), this.opts.autoOpen && this.uppy.off("files-added", _classPrivateFieldLooseBase$2(this, _openFileEditorWhenFilesAdded)[_openFileEditorWhenFilesAdded]);
    }, this.superFocusOnEachUpdate = () => {
      const _e = this.el.contains(document.activeElement), ve = document.activeElement === document.body || document.activeElement === null, xe = this.uppy.getState().info.length === 0, Ee = !this.opts.inline;
      // If update is connected to showing the Informer - let the screen reader calmly read it.
      xe && // If we are in a modal - always superfocus without concern for other elements
      // on the page (user is unlikely to want to interact with the rest of the page)
      (Ee || // If we are already inside of Uppy, or
      _e || // If we are not focused on anything BUT we have already, at least once, focused on uppy
      //   1. We focus when isFocusNowhere, because when the element we were focused
      //      on disappears (e.g. an overlay), - focus gets lost. If user is typing
      //      something somewhere else on the page, - focus won't be 'nowhere'.
      //   2. We only focus when focus is nowhere AND this.ifFocusedOnUppyRecently,
      //      to avoid focus jumps if we do something else on the page.
      //   [Practical check] Without '&& this.ifFocusedOnUppyRecently', in Safari, in inline mode,
      //                     when file is uploading, - navigate via tab to the checkbox,
      //                     try to press space multiple times. Focus will jump to Uppy.
      ve && this.ifFocusedOnUppyRecently) ? this.superFocus(this.el, this.getPluginState().activeOverlayType) : this.superFocus.cancel();
    }, this.afterUpdate = () => {
      if (this.opts.disabled && !this.dashboardIsDisabled) {
        this.disableInteractiveElements(!0);
        return;
      }
      !this.opts.disabled && this.dashboardIsDisabled && this.disableInteractiveElements(!1), this.superFocusOnEachUpdate();
    }, this.saveFileCard = (_e, ve) => {
      this.uppy.setFileMeta(ve, _e), this.toggleFileCard(!1, ve);
    }, Object.defineProperty(this, _attachRenderFunctionToTarget, {
      writable: !0,
      value: (_e) => {
        const ve = this.uppy.getPlugin(_e.id);
        return {
          ..._e,
          icon: ve.icon || this.opts.defaultPickerIcon,
          render: ve.render
        };
      }
    }), Object.defineProperty(this, _isTargetSupported, {
      writable: !0,
      value: (_e) => {
        const ve = this.uppy.getPlugin(_e.id);
        return typeof ve.isSupported != "function" ? !0 : ve.isSupported();
      }
    }), Object.defineProperty(this, _getAcquirers, {
      writable: !0,
      value: memoize((_e) => _e.filter((ve) => ve.type === "acquirer" && _classPrivateFieldLooseBase$2(this, _isTargetSupported)[_isTargetSupported](ve)).map(_classPrivateFieldLooseBase$2(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget]))
    }), Object.defineProperty(this, _getProgressIndicators, {
      writable: !0,
      value: memoize((_e) => _e.filter((ve) => ve.type === "progressindicator").map(_classPrivateFieldLooseBase$2(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget]))
    }), Object.defineProperty(this, _getEditors, {
      writable: !0,
      value: memoize((_e) => _e.filter((ve) => ve.type === "editor").map(_classPrivateFieldLooseBase$2(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget]))
    }), this.render = (_e) => {
      const ve = this.getPluginState(), {
        files: xe,
        capabilities: Ee,
        allowNewUpload: Se
      } = _e, {
        newFiles: Te,
        uploadStartedFiles: Ce,
        completeFiles: Ie,
        erroredFiles: Ne,
        inProgressFiles: Re,
        inProgressNotPausedFiles: Ae,
        processingFiles: Pe,
        isUploadStarted: Fe,
        isAllComplete: Le,
        isAllPaused: He
      } = this.uppy.getObjectOfFilesPerState(), Ge = _classPrivateFieldLooseBase$2(this, _getAcquirers)[_getAcquirers](ve.targets), Ve = _classPrivateFieldLooseBase$2(this, _getProgressIndicators)[_getProgressIndicators](ve.targets), $e = _classPrivateFieldLooseBase$2(this, _getEditors)[_getEditors](ve.targets);
      let De;
      return this.opts.theme === "auto" ? De = Ee.darkMode ? "dark" : "light" : De = this.opts.theme, ["files", "folders", "both"].indexOf(this.opts.fileManagerSelectionType) < 0 && (this.opts.fileManagerSelectionType = "files", console.warn(`Unsupported option for "fileManagerSelectionType". Using default of "${this.opts.fileManagerSelectionType}".`)), Dashboard$1({
        state: _e,
        isHidden: ve.isHidden,
        files: xe,
        newFiles: Te,
        uploadStartedFiles: Ce,
        completeFiles: Ie,
        erroredFiles: Ne,
        inProgressFiles: Re,
        inProgressNotPausedFiles: Ae,
        processingFiles: Pe,
        isUploadStarted: Fe,
        isAllComplete: Le,
        isAllPaused: He,
        totalFileCount: Object.keys(xe).length,
        totalProgress: _e.totalProgress,
        allowNewUpload: Se,
        acquirers: Ge,
        theme: De,
        disabled: this.opts.disabled,
        disableLocalFiles: this.opts.disableLocalFiles,
        direction: this.opts.direction,
        activePickerPanel: ve.activePickerPanel,
        showFileEditor: ve.showFileEditor,
        saveFileEditor: this.saveFileEditor,
        closeFileEditor: this.closeFileEditor,
        disableInteractiveElements: this.disableInteractiveElements,
        animateOpenClose: this.opts.animateOpenClose,
        isClosing: ve.isClosing,
        progressindicators: Ve,
        editors: $e,
        autoProceed: this.uppy.opts.autoProceed,
        id: this.id,
        closeModal: this.requestCloseModal,
        handleClickOutside: this.handleClickOutside,
        handleInputChange: this.handleInputChange,
        handlePaste: this.handlePaste,
        inline: this.opts.inline,
        showPanel: this.showPanel,
        hideAllPanels: this.hideAllPanels,
        i18n: this.i18n,
        i18nArray: this.i18nArray,
        uppy: this.uppy,
        note: this.opts.note,
        recoveredState: _e.recoveredState,
        metaFields: ve.metaFields,
        resumableUploads: Ee.resumableUploads || !1,
        individualCancellation: Ee.individualCancellation,
        isMobileDevice: Ee.isMobileDevice,
        fileCardFor: ve.fileCardFor,
        toggleFileCard: this.toggleFileCard,
        toggleAddFilesPanel: this.toggleAddFilesPanel,
        showAddFilesPanel: ve.showAddFilesPanel,
        saveFileCard: this.saveFileCard,
        openFileEditor: this.openFileEditor,
        canEditFile: this.canEditFile,
        width: this.opts.width,
        height: this.opts.height,
        showLinkToFileUploadResult: this.opts.showLinkToFileUploadResult,
        fileManagerSelectionType: this.opts.fileManagerSelectionType,
        proudlyDisplayPoweredByUppy: this.opts.proudlyDisplayPoweredByUppy,
        hideCancelButton: this.opts.hideCancelButton,
        hideRetryButton: this.opts.hideRetryButton,
        hidePauseResumeButton: this.opts.hidePauseResumeButton,
        showRemoveButtonAfterComplete: this.opts.showRemoveButtonAfterComplete,
        containerWidth: ve.containerWidth,
        containerHeight: ve.containerHeight,
        areInsidesReadyToBeVisible: ve.areInsidesReadyToBeVisible,
        parentElement: this.el,
        allowedFileTypes: this.uppy.opts.restrictions.allowedFileTypes,
        maxNumberOfFiles: this.uppy.opts.restrictions.maxNumberOfFiles,
        requiredMetaFields: this.uppy.opts.restrictions.requiredMetaFields,
        showSelectedFiles: this.opts.showSelectedFiles,
        showNativePhotoCameraButton: this.opts.showNativePhotoCameraButton,
        showNativeVideoCameraButton: this.opts.showNativeVideoCameraButton,
        nativeCameraFacingMode: this.opts.nativeCameraFacingMode,
        singleFileFullScreen: this.opts.singleFileFullScreen,
        handleCancelRestore: this.handleCancelRestore,
        handleRequestThumbnail: this.handleRequestThumbnail,
        handleCancelThumbnail: this.handleCancelThumbnail,
        // drag props
        isDraggingOver: ve.isDraggingOver,
        handleDragOver: this.handleDragOver,
        handleDragLeave: this.handleDragLeave,
        handleDrop: this.handleDrop
      });
    }, Object.defineProperty(this, _addSpecifiedPluginsFromOptions, {
      writable: !0,
      value: () => {
        const {
          plugins: _e
        } = this.opts;
        _e.forEach((ve) => {
          const xe = this.uppy.getPlugin(ve);
          xe ? xe.mount(this, xe) : this.uppy.log(`[Uppy] Dashboard could not find plugin '${ve}', make sure to uppy.use() the plugins you are specifying`, "warning");
        });
      }
    }), Object.defineProperty(this, _autoDiscoverPlugins, {
      writable: !0,
      value: () => {
        this.uppy.iteratePlugins(_classPrivateFieldLooseBase$2(this, _addSupportedPluginIfNoTarget)[_addSupportedPluginIfNoTarget]);
      }
    }), Object.defineProperty(this, _addSupportedPluginIfNoTarget, {
      writable: !0,
      value: (_e) => {
        var ve;
        const xe = ["acquirer", "editor"];
        _e && !((ve = _e.opts) != null && ve.target) && xe.includes(_e.type) && (this.getPluginState().targets.some((Se) => _e.id === Se.id) || _e.mount(this, _e));
      }
    }), this.install = () => {
      this.setPluginState({
        isHidden: !0,
        fileCardFor: null,
        activeOverlayType: null,
        showAddFilesPanel: !1,
        activePickerPanel: void 0,
        showFileEditor: !1,
        metaFields: this.opts.metaFields,
        targets: [],
        // We'll make them visible once .containerWidth is determined
        areInsidesReadyToBeVisible: !1,
        isDraggingOver: !1
      });
      const {
        inline: _e,
        closeAfterFinish: ve
      } = this.opts;
      if (_e && ve)
        throw new Error("[Dashboard] `closeAfterFinish: true` cannot be used on an inline Dashboard, because an inline Dashboard cannot be closed at all. Either set `inline: false`, or disable the `closeAfterFinish` option.");
      const {
        allowMultipleUploads: xe,
        allowMultipleUploadBatches: Ee
      } = this.uppy.opts;
      (xe || Ee) && ve && this.uppy.log("[Dashboard] When using `closeAfterFinish`, we recommended setting the `allowMultipleUploadBatches` option to `false` in the Uppy constructor. See https://uppy.io/docs/uppy/#allowMultipleUploads-true", "warning");
      const {
        target: Se
      } = this.opts;
      Se && this.mount(Se, this), this.opts.disableStatusBar || this.uppy.use(StatusBar, {
        id: _classPrivateFieldLooseBase$2(this, _getStatusBarId)[_getStatusBarId](),
        target: this,
        ..._classPrivateFieldLooseBase$2(this, _getStatusBarOpts)[_getStatusBarOpts]()
      }), this.opts.disableInformer || this.uppy.use(Informer, {
        id: _classPrivateFieldLooseBase$2(this, _getInformerId)[_getInformerId](),
        target: this,
        ..._classPrivateFieldLooseBase$2(this, _getInformerOpts)[_getInformerOpts]()
      }), this.opts.disableThumbnailGenerator || this.uppy.use(ThumbnailGenerator, {
        id: _classPrivateFieldLooseBase$2(this, _getThumbnailGeneratorId)[_getThumbnailGeneratorId](),
        ..._classPrivateFieldLooseBase$2(this, _getThumbnailGeneratorOpts)[_getThumbnailGeneratorOpts]()
      }), this.darkModeMediaQuery = typeof window < "u" && window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)") : null;
      const Te = this.darkModeMediaQuery ? this.darkModeMediaQuery.matches : !1;
      if (this.uppy.log(`[Dashboard] Dark mode is ${Te ? "on" : "off"}`), this.setDarkModeCapability(Te), this.opts.theme === "auto") {
        var Ce;
        (Ce = this.darkModeMediaQuery) == null || Ce.addListener(this.handleSystemDarkModeChange);
      }
      _classPrivateFieldLooseBase$2(this, _addSpecifiedPluginsFromOptions)[_addSpecifiedPluginsFromOptions](), _classPrivateFieldLooseBase$2(this, _autoDiscoverPlugins)[_autoDiscoverPlugins](), this.initEvents();
    }, this.uninstall = () => {
      if (!this.opts.disableInformer) {
        const xe = this.uppy.getPlugin(`${this.id}:Informer`);
        xe && this.uppy.removePlugin(xe);
      }
      if (!this.opts.disableStatusBar) {
        const xe = this.uppy.getPlugin(`${this.id}:StatusBar`);
        xe && this.uppy.removePlugin(xe);
      }
      if (!this.opts.disableThumbnailGenerator) {
        const xe = this.uppy.getPlugin(`${this.id}:ThumbnailGenerator`);
        xe && this.uppy.removePlugin(xe);
      }
      const {
        plugins: _e
      } = this.opts;
      if (_e.forEach((xe) => {
        const Ee = this.uppy.getPlugin(xe);
        Ee && Ee.unmount();
      }), this.opts.theme === "auto") {
        var ve;
        (ve = this.darkModeMediaQuery) == null || ve.removeListener(this.handleSystemDarkModeChange);
      }
      this.opts.disablePageScrollWhenModalOpen && document.body.classList.remove("uppy-Dashboard-isFixed"), this.unmount(), this.removeEvents();
    }, this.id = this.opts.id || "Dashboard", this.title = "Dashboard", this.type = "orchestrator", this.defaultLocale = locale$2, this.opts.doneButtonHandler === void 0 && (this.opts.doneButtonHandler = () => {
      this.uppy.clear(), this.requestCloseModal();
    }), (fe = (ue = this.opts).onRequestCloseModal) != null || (ue.onRequestCloseModal = () => this.closeModal()), this.i18nInit();
  }
  setOptions(Y) {
    var re, oe;
    super.setOptions(Y), (re = this.uppy.getPlugin(_classPrivateFieldLooseBase$2(this, _getStatusBarId)[_getStatusBarId]())) == null || re.setOptions(_classPrivateFieldLooseBase$2(this, _getStatusBarOpts)[_getStatusBarOpts]()), (oe = this.uppy.getPlugin(_classPrivateFieldLooseBase$2(this, _getThumbnailGeneratorId)[_getThumbnailGeneratorId]())) == null || oe.setOptions(_classPrivateFieldLooseBase$2(this, _getThumbnailGeneratorOpts)[_getThumbnailGeneratorOpts]());
  }
}
function _getStatusBarOpts2() {
  const {
    hideUploadButton: le,
    hideRetryButton: Y,
    hidePauseResumeButton: re,
    hideCancelButton: oe,
    showProgressDetails: ue,
    hideProgressAfterFinish: fe,
    locale: he,
    doneButtonHandler: _e
  } = this.opts;
  return {
    hideUploadButton: le,
    hideRetryButton: Y,
    hidePauseResumeButton: re,
    hideCancelButton: oe,
    showProgressDetails: ue,
    hideAfterFinish: fe,
    locale: he,
    doneButtonHandler: _e
  };
}
function _getThumbnailGeneratorOpts2() {
  const {
    thumbnailWidth: le,
    thumbnailHeight: Y,
    thumbnailType: re,
    waitForThumbnailsBeforeUpload: oe
  } = this.opts;
  return {
    thumbnailWidth: le,
    thumbnailHeight: Y,
    thumbnailType: re,
    waitForThumbnailsBeforeUpload: oe,
    // If we don't block on thumbnails, we can lazily generate them
    lazy: !oe
  };
}
function _getInformerOpts2() {
  return {
    // currently no options
  };
}
function _getStatusBarId2() {
  return `${this.id}:StatusBar`;
}
function _getThumbnailGeneratorId2() {
  return `${this.id}:ThumbnailGenerator`;
}
function _getInformerId2() {
  return `${this.id}:Informer`;
}
Dashboard.VERSION = packageJson$1.version;
function _classPrivateFieldLooseBase$1(le, Y) {
  if (!{}.hasOwnProperty.call(le, Y)) throw new TypeError("attempted to use private field on non-instance");
  return le;
}
var id$1 = 0;
function _classPrivateFieldLooseKey$1(le) {
  return "__private_" + id$1++ + "_" + le;
}
function createCancelError(le) {
  return new Error("Cancelled", {
    cause: le
  });
}
function abortOn(le) {
  if (le != null) {
    var Y;
    const re = () => this.abort(le.reason);
    le.addEventListener("abort", re, {
      once: !0
    });
    const oe = () => {
      le.removeEventListener("abort", re);
    };
    (Y = this.then) == null || Y.call(this, oe, oe);
  }
  return this;
}
var _activeRequests = /* @__PURE__ */ _classPrivateFieldLooseKey$1("activeRequests"), _queuedHandlers = /* @__PURE__ */ _classPrivateFieldLooseKey$1("queuedHandlers"), _paused = /* @__PURE__ */ _classPrivateFieldLooseKey$1("paused"), _pauseTimer = /* @__PURE__ */ _classPrivateFieldLooseKey$1("pauseTimer"), _downLimit = /* @__PURE__ */ _classPrivateFieldLooseKey$1("downLimit"), _upperLimit = /* @__PURE__ */ _classPrivateFieldLooseKey$1("upperLimit"), _rateLimitingTimer = /* @__PURE__ */ _classPrivateFieldLooseKey$1("rateLimitingTimer"), _call = /* @__PURE__ */ _classPrivateFieldLooseKey$1("call"), _queueNext = /* @__PURE__ */ _classPrivateFieldLooseKey$1("queueNext"), _next = /* @__PURE__ */ _classPrivateFieldLooseKey$1("next"), _queue = /* @__PURE__ */ _classPrivateFieldLooseKey$1("queue"), _dequeue = /* @__PURE__ */ _classPrivateFieldLooseKey$1("dequeue"), _resume = /* @__PURE__ */ _classPrivateFieldLooseKey$1("resume"), _increaseLimit = /* @__PURE__ */ _classPrivateFieldLooseKey$1("increaseLimit");
class RateLimitedQueue {
  constructor(Y) {
    Object.defineProperty(this, _dequeue, {
      value: _dequeue2
    }), Object.defineProperty(this, _queue, {
      value: _queue2
    }), Object.defineProperty(this, _next, {
      value: _next2
    }), Object.defineProperty(this, _queueNext, {
      value: _queueNext2
    }), Object.defineProperty(this, _call, {
      value: _call2
    }), Object.defineProperty(this, _activeRequests, {
      writable: !0,
      value: 0
    }), Object.defineProperty(this, _queuedHandlers, {
      writable: !0,
      value: []
    }), Object.defineProperty(this, _paused, {
      writable: !0,
      value: !1
    }), Object.defineProperty(this, _pauseTimer, {
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, _downLimit, {
      writable: !0,
      value: 1
    }), Object.defineProperty(this, _upperLimit, {
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, _rateLimitingTimer, {
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, _resume, {
      writable: !0,
      value: () => this.resume()
    }), Object.defineProperty(this, _increaseLimit, {
      writable: !0,
      value: () => {
        if (_classPrivateFieldLooseBase$1(this, _paused)[_paused]) {
          _classPrivateFieldLooseBase$1(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase$1(this, _increaseLimit)[_increaseLimit], 0);
          return;
        }
        _classPrivateFieldLooseBase$1(this, _downLimit)[_downLimit] = this.limit, this.limit = Math.ceil((_classPrivateFieldLooseBase$1(this, _upperLimit)[_upperLimit] + _classPrivateFieldLooseBase$1(this, _downLimit)[_downLimit]) / 2);
        for (let re = _classPrivateFieldLooseBase$1(this, _downLimit)[_downLimit]; re <= this.limit; re++)
          _classPrivateFieldLooseBase$1(this, _queueNext)[_queueNext]();
        _classPrivateFieldLooseBase$1(this, _upperLimit)[_upperLimit] - _classPrivateFieldLooseBase$1(this, _downLimit)[_downLimit] > 3 ? _classPrivateFieldLooseBase$1(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase$1(this, _increaseLimit)[_increaseLimit], 2e3) : _classPrivateFieldLooseBase$1(this, _downLimit)[_downLimit] = Math.floor(_classPrivateFieldLooseBase$1(this, _downLimit)[_downLimit] / 2);
      }
    }), typeof Y != "number" || Y === 0 ? this.limit = 1 / 0 : this.limit = Y;
  }
  run(Y, re) {
    return !_classPrivateFieldLooseBase$1(this, _paused)[_paused] && _classPrivateFieldLooseBase$1(this, _activeRequests)[_activeRequests] < this.limit ? _classPrivateFieldLooseBase$1(this, _call)[_call](Y) : _classPrivateFieldLooseBase$1(this, _queue)[_queue](Y, re);
  }
  wrapSyncFunction(Y, re) {
    var oe = this;
    return function() {
      for (var ue = arguments.length, fe = new Array(ue), he = 0; he < ue; he++)
        fe[he] = arguments[he];
      const _e = oe.run(() => (Y(...fe), queueMicrotask(() => _e.done()), () => {
      }), re);
      return {
        abortOn,
        abort() {
          _e.abort();
        }
      };
    };
  }
  wrapPromiseFunction(Y, re) {
    var oe = this;
    return function() {
      for (var ue = arguments.length, fe = new Array(ue), he = 0; he < ue; he++)
        fe[he] = arguments[he];
      let _e;
      const ve = new Promise((xe, Ee) => {
        _e = oe.run(() => {
          let Se, Te;
          try {
            Te = Promise.resolve(Y(...fe));
          } catch (Ce) {
            Te = Promise.reject(Ce);
          }
          return Te.then((Ce) => {
            Se ? Ee(Se) : (_e.done(), xe(Ce));
          }, (Ce) => {
            Se ? Ee(Se) : (_e.done(), Ee(Ce));
          }), (Ce) => {
            Se = createCancelError(Ce);
          };
        }, re);
      });
      return ve.abort = (xe) => {
        _e.abort(xe);
      }, ve.abortOn = abortOn, ve;
    };
  }
  resume() {
    _classPrivateFieldLooseBase$1(this, _paused)[_paused] = !1, clearTimeout(_classPrivateFieldLooseBase$1(this, _pauseTimer)[_pauseTimer]);
    for (let Y = 0; Y < this.limit; Y++)
      _classPrivateFieldLooseBase$1(this, _queueNext)[_queueNext]();
  }
  /**
   * Freezes the queue for a while or indefinitely.
   *
   * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.
   *                                    If omitted, the queue won't resume automatically.
   */
  pause(Y) {
    Y === void 0 && (Y = null), _classPrivateFieldLooseBase$1(this, _paused)[_paused] = !0, clearTimeout(_classPrivateFieldLooseBase$1(this, _pauseTimer)[_pauseTimer]), Y != null && (_classPrivateFieldLooseBase$1(this, _pauseTimer)[_pauseTimer] = setTimeout(_classPrivateFieldLooseBase$1(this, _resume)[_resume], Y));
  }
  /**
   * Pauses the queue for a duration, and lower the limit of concurrent requests
   * when the queue resumes. When the queue resumes, it tries to progressively
   * increase the limit in `this.#increaseLimit` until another call is made to
   * `this.rateLimit`.
   * Call this function when using the RateLimitedQueue for network requests and
   * the remote server responds with 429 HTTP code.
   *
   * @param {number} duration in milliseconds.
   */
  rateLimit(Y) {
    clearTimeout(_classPrivateFieldLooseBase$1(this, _rateLimitingTimer)[_rateLimitingTimer]), this.pause(Y), this.limit > 1 && Number.isFinite(this.limit) && (_classPrivateFieldLooseBase$1(this, _upperLimit)[_upperLimit] = this.limit - 1, this.limit = _classPrivateFieldLooseBase$1(this, _downLimit)[_downLimit], _classPrivateFieldLooseBase$1(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase$1(this, _increaseLimit)[_increaseLimit], Y));
  }
  get isPaused() {
    return _classPrivateFieldLooseBase$1(this, _paused)[_paused];
  }
}
function _call2(le) {
  _classPrivateFieldLooseBase$1(this, _activeRequests)[_activeRequests] += 1;
  let Y = !1, re;
  try {
    re = le();
  } catch (oe) {
    throw _classPrivateFieldLooseBase$1(this, _activeRequests)[_activeRequests] -= 1, oe;
  }
  return {
    abort: (oe) => {
      Y || (Y = !0, _classPrivateFieldLooseBase$1(this, _activeRequests)[_activeRequests] -= 1, re?.(oe), _classPrivateFieldLooseBase$1(this, _queueNext)[_queueNext]());
    },
    done: () => {
      Y || (Y = !0, _classPrivateFieldLooseBase$1(this, _activeRequests)[_activeRequests] -= 1, _classPrivateFieldLooseBase$1(this, _queueNext)[_queueNext]());
    }
  };
}
function _queueNext2() {
  queueMicrotask(() => _classPrivateFieldLooseBase$1(this, _next)[_next]());
}
function _next2() {
  if (_classPrivateFieldLooseBase$1(this, _paused)[_paused] || _classPrivateFieldLooseBase$1(this, _activeRequests)[_activeRequests] >= this.limit || _classPrivateFieldLooseBase$1(this, _queuedHandlers)[_queuedHandlers].length === 0)
    return;
  const le = _classPrivateFieldLooseBase$1(this, _queuedHandlers)[_queuedHandlers].shift();
  if (le == null)
    throw new Error("Invariant violation: next is null");
  const Y = _classPrivateFieldLooseBase$1(this, _call)[_call](le.fn);
  le.abort = Y.abort, le.done = Y.done;
}
function _queue2(le, Y) {
  const re = {
    fn: le,
    priority: Y?.priority || 0,
    abort: () => {
      _classPrivateFieldLooseBase$1(this, _dequeue)[_dequeue](re);
    },
    done: () => {
      throw new Error("Cannot mark a queued request as done: this indicates a bug");
    }
  }, oe = _classPrivateFieldLooseBase$1(this, _queuedHandlers)[_queuedHandlers].findIndex((ue) => re.priority > ue.priority);
  return oe === -1 ? _classPrivateFieldLooseBase$1(this, _queuedHandlers)[_queuedHandlers].push(re) : _classPrivateFieldLooseBase$1(this, _queuedHandlers)[_queuedHandlers].splice(oe, 0, re), re;
}
function _dequeue2(le) {
  const Y = _classPrivateFieldLooseBase$1(this, _queuedHandlers)[_queuedHandlers].indexOf(le);
  Y !== -1 && _classPrivateFieldLooseBase$1(this, _queuedHandlers)[_queuedHandlers].splice(Y, 1);
}
/*!
 * Compressor.js v1.2.1
 * https://fengyuanchen.github.io/compressorjs
 *
 * Copyright 2018-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2023-02-28T14:09:41.732Z
 */
function ownKeys$1(le, Y) {
  var re = Object.keys(le);
  if (Object.getOwnPropertySymbols) {
    var oe = Object.getOwnPropertySymbols(le);
    Y && (oe = oe.filter(function(ue) {
      return Object.getOwnPropertyDescriptor(le, ue).enumerable;
    })), re.push.apply(re, oe);
  }
  return re;
}
function _objectSpread2$1(le) {
  for (var Y = 1; Y < arguments.length; Y++) {
    var re = arguments[Y] != null ? arguments[Y] : {};
    Y % 2 ? ownKeys$1(Object(re), !0).forEach(function(oe) {
      _defineProperty$1(le, oe, re[oe]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(le, Object.getOwnPropertyDescriptors(re)) : ownKeys$1(Object(re)).forEach(function(oe) {
      Object.defineProperty(le, oe, Object.getOwnPropertyDescriptor(re, oe));
    });
  }
  return le;
}
function _classCallCheck$1(le, Y) {
  if (!(le instanceof Y))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1(le, Y) {
  for (var re = 0; re < Y.length; re++) {
    var oe = Y[re];
    oe.enumerable = oe.enumerable || !1, oe.configurable = !0, "value" in oe && (oe.writable = !0), Object.defineProperty(le, _toPropertyKey$1(oe.key), oe);
  }
}
function _createClass$1(le, Y, re) {
  return Y && _defineProperties$1(le.prototype, Y), re && _defineProperties$1(le, re), Object.defineProperty(le, "prototype", {
    writable: !1
  }), le;
}
function _defineProperty$1(le, Y, re) {
  return Y = _toPropertyKey$1(Y), Y in le ? Object.defineProperty(le, Y, {
    value: re,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : le[Y] = re, le;
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(le) {
    for (var Y = 1; Y < arguments.length; Y++) {
      var re = arguments[Y];
      for (var oe in re)
        Object.prototype.hasOwnProperty.call(re, oe) && (le[oe] = re[oe]);
    }
    return le;
  }, _extends.apply(this, arguments);
}
function _toPrimitive$1(le, Y) {
  if (typeof le != "object" || le === null) return le;
  var re = le[Symbol.toPrimitive];
  if (re !== void 0) {
    var oe = re.call(le, Y);
    if (typeof oe != "object") return oe;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(le);
}
function _toPropertyKey$1(le) {
  var Y = _toPrimitive$1(le, "string");
  return typeof Y == "symbol" ? Y : String(Y);
}
var canvasToBlob = { exports: {} };
(function(le) {
  typeof window > "u" || function(Y) {
    var re = Y.HTMLCanvasElement && Y.HTMLCanvasElement.prototype, oe = Y.Blob && function() {
      try {
        return !!new Blob();
      } catch {
        return !1;
      }
    }(), ue = oe && Y.Uint8Array && function() {
      try {
        return new Blob([new Uint8Array(100)]).size === 100;
      } catch {
        return !1;
      }
    }(), fe = Y.BlobBuilder || Y.WebKitBlobBuilder || Y.MozBlobBuilder || Y.MSBlobBuilder, he = /^data:((.*?)(;charset=.*?)?)(;base64)?,/, _e = (oe || fe) && Y.atob && Y.ArrayBuffer && Y.Uint8Array && function(ve) {
      var xe, Ee, Se, Te, Ce, Ie, Ne, Re, Ae;
      if (xe = ve.match(he), !xe)
        throw new Error("invalid data URI");
      for (Ee = xe[2] ? xe[1] : "text/plain" + (xe[3] || ";charset=US-ASCII"), Se = !!xe[4], Te = ve.slice(xe[0].length), Se ? Ce = atob(Te) : Ce = decodeURIComponent(Te), Ie = new ArrayBuffer(Ce.length), Ne = new Uint8Array(Ie), Re = 0; Re < Ce.length; Re += 1)
        Ne[Re] = Ce.charCodeAt(Re);
      return oe ? new Blob([ue ? Ne : Ie], {
        type: Ee
      }) : (Ae = new fe(), Ae.append(Ie), Ae.getBlob(Ee));
    };
    Y.HTMLCanvasElement && !re.toBlob && (re.mozGetAsFile ? re.toBlob = function(ve, xe, Ee) {
      var Se = this;
      setTimeout(function() {
        Ee && re.toDataURL && _e ? ve(_e(Se.toDataURL(xe, Ee))) : ve(Se.mozGetAsFile("blob", xe));
      });
    } : re.toDataURL && _e && (re.msToBlob ? re.toBlob = function(ve, xe, Ee) {
      var Se = this;
      setTimeout(function() {
        (xe && xe !== "image/png" || Ee) && re.toDataURL && _e ? ve(_e(Se.toDataURL(xe, Ee))) : ve(Se.msToBlob(xe));
      });
    } : re.toBlob = function(ve, xe, Ee) {
      var Se = this;
      setTimeout(function() {
        ve(_e(Se.toDataURL(xe, Ee)));
      });
    })), le.exports ? le.exports = _e : Y.dataURLtoBlob = _e;
  }(window);
})(canvasToBlob);
var toBlob = canvasToBlob.exports, isBlob = function le(Y) {
  return typeof Blob > "u" ? !1 : Y instanceof Blob || Object.prototype.toString.call(Y) === "[object Blob]";
}, DEFAULTS$1 = {
  /**
   * Indicates if output the original image instead of the compressed one
   * when the size of the compressed image is greater than the original one's
   * @type {boolean}
   */
  strict: !0,
  /**
   * Indicates if read the image's Exif Orientation information,
   * and then rotate or flip the image automatically.
   * @type {boolean}
   */
  checkOrientation: !0,
  /**
   * Indicates if retain the image's Exif information after compressed.
   * @type {boolean}
  */
  retainExif: !1,
  /**
   * The max width of the output image.
   * @type {number}
   */
  maxWidth: 1 / 0,
  /**
   * The max height of the output image.
   * @type {number}
   */
  maxHeight: 1 / 0,
  /**
   * The min width of the output image.
   * @type {number}
   */
  minWidth: 0,
  /**
   * The min height of the output image.
   * @type {number}
   */
  minHeight: 0,
  /**
   * The width of the output image.
   * If not specified, the natural width of the source image will be used.
   * @type {number}
   */
  width: void 0,
  /**
   * The height of the output image.
   * If not specified, the natural height of the source image will be used.
   * @type {number}
   */
  height: void 0,
  /**
   * Sets how the size of the image should be resized to the container
   * specified by the `width` and `height` options.
   * @type {string}
   */
  resize: "none",
  /**
   * The quality of the output image.
   * It must be a number between `0` and `1`,
   * and only available for `image/jpeg` and `image/webp` images.
   * Check out {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob canvas.toBlob}.
   * @type {number}
   */
  quality: 0.8,
  /**
   * The mime type of the output image.
   * By default, the original mime type of the source image file will be used.
   * @type {string}
   */
  mimeType: "auto",
  /**
   * Files whose file type is included in this list,
   * and whose file size exceeds the `convertSize` value will be converted to JPEGs.
   * @type {string｜Array}
   */
  convertTypes: ["image/png"],
  /**
   * PNG files over this size (5 MB by default) will be converted to JPEGs.
   * To disable this, just set the value to `Infinity`.
   * @type {number}
   */
  convertSize: 5e6,
  /**
   * The hook function to execute before draw the image into the canvas for compression.
   * @type {Function}
   * @param {CanvasRenderingContext2D} context - The 2d rendering context of the canvas.
   * @param {HTMLCanvasElement} canvas - The canvas for compression.
   * @example
   * function (context, canvas) {
   *   context.fillStyle = '#fff';
   * }
   */
  beforeDraw: null,
  /**
   * The hook function to execute after drew the image into the canvas for compression.
   * @type {Function}
   * @param {CanvasRenderingContext2D} context - The 2d rendering context of the canvas.
   * @param {HTMLCanvasElement} canvas - The canvas for compression.
   * @example
   * function (context, canvas) {
   *   context.filter = 'grayscale(100%)';
   * }
   */
  drew: null,
  /**
   * The hook function to execute when success to compress the image.
   * @type {Function}
   * @param {File} file - The compressed image File object.
   * @example
   * function (file) {
   *   console.log(file);
   * }
   */
  success: null,
  /**
   * The hook function to execute when fail to compress the image.
   * @type {Function}
   * @param {Error} err - An Error object.
   * @example
   * function (err) {
   *   console.log(err.message);
   * }
   */
  error: null
}, IS_BROWSER$1 = typeof window < "u" && typeof window.document < "u", WINDOW$1 = IS_BROWSER$1 ? window : {}, isPositiveNumber$1 = function le(Y) {
  return Y > 0 && Y < 1 / 0;
}, slice$1 = Array.prototype.slice;
function toArray$1(le) {
  return Array.from ? Array.from(le) : slice$1.call(le);
}
var REGEXP_IMAGE_TYPE = /^image\/.+$/;
function isImageType(le) {
  return REGEXP_IMAGE_TYPE.test(le);
}
function imageTypeToExtension(le) {
  var Y = isImageType(le) ? le.substr(6) : "";
  return Y === "jpeg" && (Y = "jpg"), ".".concat(Y);
}
var fromCharCode$1 = String.fromCharCode;
function getStringFromCharCode$1(le, Y, re) {
  var oe = "", ue;
  for (re += Y, ue = Y; ue < re; ue += 1)
    oe += fromCharCode$1(le.getUint8(ue));
  return oe;
}
var btoa$1 = WINDOW$1.btoa;
function arrayBufferToDataURL$1(le, Y) {
  for (var re = [], oe = 8192, ue = new Uint8Array(le); ue.length > 0; )
    re.push(fromCharCode$1.apply(null, toArray$1(ue.subarray(0, oe)))), ue = ue.subarray(oe);
  return "data:".concat(Y, ";base64,").concat(btoa$1(re.join("")));
}
function resetAndGetOrientation$1(le) {
  var Y = new DataView(le), re;
  try {
    var oe, ue, fe;
    if (Y.getUint8(0) === 255 && Y.getUint8(1) === 216)
      for (var he = Y.byteLength, _e = 2; _e + 1 < he; ) {
        if (Y.getUint8(_e) === 255 && Y.getUint8(_e + 1) === 225) {
          ue = _e;
          break;
        }
        _e += 1;
      }
    if (ue) {
      var ve = ue + 4, xe = ue + 10;
      if (getStringFromCharCode$1(Y, ve, 4) === "Exif") {
        var Ee = Y.getUint16(xe);
        if (oe = Ee === 18761, (oe || Ee === 19789) && Y.getUint16(xe + 2, oe) === 42) {
          var Se = Y.getUint32(xe + 4, oe);
          Se >= 8 && (fe = xe + Se);
        }
      }
    }
    if (fe) {
      var Te = Y.getUint16(fe, oe), Ce, Ie;
      for (Ie = 0; Ie < Te; Ie += 1)
        if (Ce = fe + Ie * 12 + 2, Y.getUint16(Ce, oe) === 274) {
          Ce += 8, re = Y.getUint16(Ce, oe), Y.setUint16(Ce, 1, oe);
          break;
        }
    }
  } catch {
    re = 1;
  }
  return re;
}
function parseOrientation$1(le) {
  var Y = 0, re = 1, oe = 1;
  switch (le) {
    // Flip horizontal
    case 2:
      re = -1;
      break;
    // Rotate left 180°
    case 3:
      Y = -180;
      break;
    // Flip vertical
    case 4:
      oe = -1;
      break;
    // Flip vertical and rotate right 90°
    case 5:
      Y = 90, oe = -1;
      break;
    // Rotate right 90°
    case 6:
      Y = 90;
      break;
    // Flip horizontal and rotate right 90°
    case 7:
      Y = 90, re = -1;
      break;
    // Rotate left 90°
    case 8:
      Y = -90;
      break;
  }
  return {
    rotate: Y,
    scaleX: re,
    scaleY: oe
  };
}
var REGEXP_DECIMALS$1 = /\.\d*(?:0|9){12}\d*$/;
function normalizeDecimalNumber$1(le) {
  var Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11;
  return REGEXP_DECIMALS$1.test(le) ? Math.round(le * Y) / Y : le;
}
function getAdjustedSizes$1(le) {
  var Y = le.aspectRatio, re = le.height, oe = le.width, ue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none", fe = isPositiveNumber$1(oe), he = isPositiveNumber$1(re);
  if (fe && he) {
    var _e = re * Y;
    (ue === "contain" || ue === "none") && _e > oe || ue === "cover" && _e < oe ? re = oe / Y : oe = re * Y;
  } else fe ? re = oe / Y : he && (oe = re * Y);
  return {
    width: oe,
    height: re
  };
}
function getExif(le) {
  for (var Y = toArray$1(new Uint8Array(le)), re = Y.length, oe = [], ue = 0; ue + 3 < re; ) {
    var fe = Y[ue], he = Y[ue + 1];
    if (fe === 255 && he === 218)
      break;
    if (fe === 255 && he === 216)
      ue += 2;
    else {
      var _e = Y[ue + 2] * 256 + Y[ue + 3], ve = ue + _e + 2, xe = Y.slice(ue, ve);
      oe.push(xe), ue = ve;
    }
  }
  return oe.reduce(function(Ee, Se) {
    return Se[0] === 255 && Se[1] === 225 ? Ee.concat(Se) : Ee;
  }, []);
}
function insertExif(le, Y) {
  var re = toArray$1(new Uint8Array(le));
  if (re[2] !== 255 || re[3] !== 224)
    return le;
  var oe = re[4] * 256 + re[5], ue = [255, 216].concat(Y, re.slice(4 + oe));
  return new Uint8Array(ue);
}
var ArrayBuffer$1 = WINDOW$1.ArrayBuffer, FileReader$1 = WINDOW$1.FileReader, URL$1 = WINDOW$1.URL || WINDOW$1.webkitURL, REGEXP_EXTENSION = /\.\w+$/, AnotherCompressor = WINDOW$1.Compressor, Compressor$1 = /* @__PURE__ */ function() {
  function le(Y, re) {
    _classCallCheck$1(this, le), this.file = Y, this.exif = [], this.image = new Image(), this.options = _objectSpread2$1(_objectSpread2$1({}, DEFAULTS$1), re), this.aborted = !1, this.result = null, this.init();
  }
  return _createClass$1(le, [{
    key: "init",
    value: function() {
      var re = this, oe = this.file, ue = this.options;
      if (!isBlob(oe)) {
        this.fail(new Error("The first argument must be a File or Blob object."));
        return;
      }
      var fe = oe.type;
      if (!isImageType(fe)) {
        this.fail(new Error("The first argument must be an image File or Blob object."));
        return;
      }
      if (!URL$1 || !FileReader$1) {
        this.fail(new Error("The current browser does not support image compression."));
        return;
      }
      ArrayBuffer$1 || (ue.checkOrientation = !1, ue.retainExif = !1);
      var he = fe === "image/jpeg", _e = he && ue.checkOrientation, ve = he && ue.retainExif;
      if (URL$1 && !_e && !ve)
        this.load({
          url: URL$1.createObjectURL(oe)
        });
      else {
        var xe = new FileReader$1();
        this.reader = xe, xe.onload = function(Ee) {
          var Se = Ee.target, Te = Se.result, Ce = {}, Ie = 1;
          _e && (Ie = resetAndGetOrientation$1(Te), Ie > 1 && _extends(Ce, parseOrientation$1(Ie))), ve && (re.exif = getExif(Te)), _e || ve ? !URL$1 || Ie > 1 ? Ce.url = arrayBufferToDataURL$1(Te, fe) : Ce.url = URL$1.createObjectURL(oe) : Ce.url = Te, re.load(Ce);
        }, xe.onabort = function() {
          re.fail(new Error("Aborted to read the image with FileReader."));
        }, xe.onerror = function() {
          re.fail(new Error("Failed to read the image with FileReader."));
        }, xe.onloadend = function() {
          re.reader = null;
        }, _e || ve ? xe.readAsArrayBuffer(oe) : xe.readAsDataURL(oe);
      }
    }
  }, {
    key: "load",
    value: function(re) {
      var oe = this, ue = this.file, fe = this.image;
      fe.onload = function() {
        oe.draw(_objectSpread2$1(_objectSpread2$1({}, re), {}, {
          naturalWidth: fe.naturalWidth,
          naturalHeight: fe.naturalHeight
        }));
      }, fe.onabort = function() {
        oe.fail(new Error("Aborted to load the image."));
      }, fe.onerror = function() {
        oe.fail(new Error("Failed to load the image."));
      }, WINDOW$1.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW$1.navigator.userAgent) && (fe.crossOrigin = "anonymous"), fe.alt = ue.name, fe.src = re.url;
    }
  }, {
    key: "draw",
    value: function(re) {
      var oe = this, ue = re.naturalWidth, fe = re.naturalHeight, he = re.rotate, _e = he === void 0 ? 0 : he, ve = re.scaleX, xe = ve === void 0 ? 1 : ve, Ee = re.scaleY, Se = Ee === void 0 ? 1 : Ee, Te = this.file, Ce = this.image, Ie = this.options, Ne = document.createElement("canvas"), Re = Ne.getContext("2d"), Ae = Math.abs(_e) % 180 === 90, Pe = (Ie.resize === "contain" || Ie.resize === "cover") && isPositiveNumber$1(Ie.width) && isPositiveNumber$1(Ie.height), Fe = Math.max(Ie.maxWidth, 0) || 1 / 0, Le = Math.max(Ie.maxHeight, 0) || 1 / 0, He = Math.max(Ie.minWidth, 0) || 0, Ge = Math.max(Ie.minHeight, 0) || 0, Ve = ue / fe, $e = Ie.width, De = Ie.height;
      if (Ae) {
        var Ke = [Le, Fe];
        Fe = Ke[0], Le = Ke[1];
        var ze = [Ge, He];
        He = ze[0], Ge = ze[1];
        var tt = [De, $e];
        $e = tt[0], De = tt[1];
      }
      Pe && (Ve = $e / De);
      var Xe = getAdjustedSizes$1({
        aspectRatio: Ve,
        width: Fe,
        height: Le
      }, "contain");
      Fe = Xe.width, Le = Xe.height;
      var mt = getAdjustedSizes$1({
        aspectRatio: Ve,
        width: He,
        height: Ge
      }, "cover");
      if (He = mt.width, Ge = mt.height, Pe) {
        var at = getAdjustedSizes$1({
          aspectRatio: Ve,
          width: $e,
          height: De
        }, Ie.resize);
        $e = at.width, De = at.height;
      } else {
        var qe = getAdjustedSizes$1({
          aspectRatio: Ve,
          width: $e,
          height: De
        }), st = qe.width;
        $e = st === void 0 ? ue : st;
        var xt = qe.height;
        De = xt === void 0 ? fe : xt;
      }
      $e = Math.floor(normalizeDecimalNumber$1(Math.min(Math.max($e, He), Fe))), De = Math.floor(normalizeDecimalNumber$1(Math.min(Math.max(De, Ge), Le)));
      var gt = -$e / 2, Ze = -De / 2, _t = $e, wt = De, yt = [];
      if (Pe) {
        var St = 0, It = 0, Bt = ue, Ye = fe, Be = getAdjustedSizes$1({
          aspectRatio: Ve,
          width: ue,
          height: fe
        }, {
          contain: "cover",
          cover: "contain"
        }[Ie.resize]);
        Bt = Be.width, Ye = Be.height, St = (ue - Bt) / 2, It = (fe - Ye) / 2, yt.push(St, It, Bt, Ye);
      }
      if (yt.push(gt, Ze, _t, wt), Ae) {
        var et = [De, $e];
        $e = et[0], De = et[1];
      }
      Ne.width = $e, Ne.height = De, isImageType(Ie.mimeType) || (Ie.mimeType = Te.type);
      var je = "transparent";
      Te.size > Ie.convertSize && Ie.convertTypes.indexOf(Ie.mimeType) >= 0 && (Ie.mimeType = "image/jpeg");
      var it = Ie.mimeType === "image/jpeg";
      if (it && (je = "#fff"), Re.fillStyle = je, Re.fillRect(0, 0, $e, De), Ie.beforeDraw && Ie.beforeDraw.call(this, Re, Ne), !this.aborted && (Re.save(), Re.translate($e / 2, De / 2), Re.rotate(_e * Math.PI / 180), Re.scale(xe, Se), Re.drawImage.apply(Re, [Ce].concat(yt)), Re.restore(), Ie.drew && Ie.drew.call(this, Re, Ne), !this.aborted)) {
        var bt = function(Ct) {
          if (!oe.aborted) {
            var Rt = function(Vt) {
              return oe.done({
                naturalWidth: ue,
                naturalHeight: fe,
                result: Vt
              });
            };
            if (Ct && it && Ie.retainExif && oe.exif && oe.exif.length > 0) {
              var Ot = function(Vt) {
                return Rt(toBlob(arrayBufferToDataURL$1(insertExif(Vt, oe.exif), Ie.mimeType)));
              };
              if (Ct.arrayBuffer)
                Ct.arrayBuffer().then(Ot).catch(function() {
                  oe.fail(new Error("Failed to read the compressed image with Blob.arrayBuffer()."));
                });
              else {
                var Mt = new FileReader$1();
                oe.reader = Mt, Mt.onload = function(Dt) {
                  var Vt = Dt.target;
                  Ot(Vt.result);
                }, Mt.onabort = function() {
                  oe.fail(new Error("Aborted to read the compressed image with FileReader."));
                }, Mt.onerror = function() {
                  oe.fail(new Error("Failed to read the compressed image with FileReader."));
                }, Mt.onloadend = function() {
                  oe.reader = null;
                }, Mt.readAsArrayBuffer(Ct);
              }
            } else
              Rt(Ct);
          }
        };
        Ne.toBlob ? Ne.toBlob(bt, Ie.mimeType, Ie.quality) : bt(toBlob(Ne.toDataURL(Ie.mimeType, Ie.quality)));
      }
    }
  }, {
    key: "done",
    value: function(re) {
      var oe = re.naturalWidth, ue = re.naturalHeight, fe = re.result, he = this.file, _e = this.image, ve = this.options;
      if (URL$1 && _e.src.indexOf("blob:") === 0 && URL$1.revokeObjectURL(_e.src), fe)
        if (ve.strict && !ve.retainExif && fe.size > he.size && ve.mimeType === he.type && !(ve.width > oe || ve.height > ue || ve.minWidth > oe || ve.minHeight > ue || ve.maxWidth < oe || ve.maxHeight < ue))
          fe = he;
        else {
          var xe = /* @__PURE__ */ new Date();
          fe.lastModified = xe.getTime(), fe.lastModifiedDate = xe, fe.name = he.name, fe.name && fe.type !== he.type && (fe.name = fe.name.replace(REGEXP_EXTENSION, imageTypeToExtension(fe.type)));
        }
      else
        fe = he;
      this.result = fe, ve.success && ve.success.call(this, fe);
    }
  }, {
    key: "fail",
    value: function(re) {
      var oe = this.options;
      if (oe.error)
        oe.error.call(this, re);
      else
        throw re;
    }
  }, {
    key: "abort",
    value: function() {
      this.aborted || (this.aborted = !0, this.reader ? this.reader.abort() : this.image.complete ? this.fail(new Error("The compression process has been aborted.")) : (this.image.onload = null, this.image.onabort()));
    }
    /**
     * Get the no conflict compressor class.
     * @returns {Compressor} The compressor class.
     */
  }], [{
    key: "noConflict",
    value: function() {
      return window.Compressor = AnotherCompressor, le;
    }
    /**
     * Change the default options.
     * @param {Object} options - The new default options.
     */
  }, {
    key: "setDefaults",
    value: function(re) {
      _extends(DEFAULTS$1, re);
    }
  }]), le;
}();
const locale$1 = {
  strings: {
    // Shown in the Status Bar
    compressingImages: "Compressing images...",
    compressedX: "Saved %{size} by compressing images"
  }
};
function _classPrivateFieldLooseBase(le, Y) {
  if (!{}.hasOwnProperty.call(le, Y)) throw new TypeError("attempted to use private field on non-instance");
  return le;
}
var id = 0;
function _classPrivateFieldLooseKey(le) {
  return "__private_" + id++ + "_" + le;
}
const defaultOptions$2 = {
  quality: 0.6,
  limit: 10
};
var _RateLimitedQueue = /* @__PURE__ */ _classPrivateFieldLooseKey("RateLimitedQueue");
class Compressor extends BasePlugin {
  constructor(Y, re) {
    super(Y, {
      ...defaultOptions$2,
      ...re
    }), Object.defineProperty(this, _RateLimitedQueue, {
      writable: !0,
      value: void 0
    }), this.id = this.opts.id || "Compressor", this.type = "modifier", this.defaultLocale = locale$1, _classPrivateFieldLooseBase(this, _RateLimitedQueue)[_RateLimitedQueue] = new RateLimitedQueue(this.opts.limit), this.i18nInit(), this.prepareUpload = this.prepareUpload.bind(this), this.compress = this.compress.bind(this);
  }
  compress(Y) {
    return new Promise((re, oe) => {
      new Compressor$1(Y, {
        ...this.opts,
        success: re,
        error: oe
      });
    });
  }
  async prepareUpload(Y) {
    let re = 0;
    const oe = [], ue = _classPrivateFieldLooseBase(this, _RateLimitedQueue)[_RateLimitedQueue].wrapPromiseFunction(async (he) => {
      try {
        const _e = await this.compress(he.data), ve = he.data.size - _e.size;
        this.uppy.log(`[Image Compressor] Image ${he.id} compressed by ${prettierBytes(ve)}`), re += ve;
        const {
          name: xe,
          type: Ee,
          size: Se
        } = _e, Te = getFileNameAndExtension(xe), Ie = `${getFileNameAndExtension(he.meta.name).name}.${Te.extension}`;
        this.uppy.setFileState(he.id, {
          ...xe && {
            name: xe
          },
          ...Te.extension && {
            extension: Te.extension
          },
          ...Ee && {
            type: Ee
          },
          ...Se && {
            size: Se
          },
          data: _e,
          meta: {
            ...he.meta,
            type: Ee,
            name: Ie
          }
        }), oe.push(he);
      } catch (_e) {
        this.uppy.log(`[Image Compressor] Failed to compress ${he.id}:`, "warning"), this.uppy.log(_e, "warning");
      }
    }), fe = Y.map((he) => {
      var _e;
      const ve = this.uppy.getFile(he);
      return this.uppy.emit("preprocess-progress", ve, {
        mode: "indeterminate",
        message: this.i18n("compressingImages")
      }), ve.isRemote || (ve.data.type || (ve.data = ve.data.slice(0, ve.data.size, ve.type)), !((_e = ve.type) != null && _e.startsWith("image/"))) ? Promise.resolve() : ue(ve);
    });
    await Promise.all(fe), this.uppy.emit("compressor:complete", oe), re > 1024 && this.uppy.info(this.i18n("compressedX", {
      size: prettierBytes(re)
    }), "info");
    for (const he of Y) {
      const _e = this.uppy.getFile(he);
      this.uppy.emit("preprocess-complete", _e);
    }
  }
  install() {
    this.uppy.addPreProcessor(this.prepareUpload);
  }
  uninstall() {
    this.uppy.removePreProcessor(this.prepareUpload);
  }
}
/*!
 * Cropper.js v1.6.2
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2024-04-21T07:43:05.335Z
 */
function ownKeys(le, Y) {
  var re = Object.keys(le);
  if (Object.getOwnPropertySymbols) {
    var oe = Object.getOwnPropertySymbols(le);
    Y && (oe = oe.filter(function(ue) {
      return Object.getOwnPropertyDescriptor(le, ue).enumerable;
    })), re.push.apply(re, oe);
  }
  return re;
}
function _objectSpread2(le) {
  for (var Y = 1; Y < arguments.length; Y++) {
    var re = arguments[Y] != null ? arguments[Y] : {};
    Y % 2 ? ownKeys(Object(re), !0).forEach(function(oe) {
      _defineProperty(le, oe, re[oe]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(le, Object.getOwnPropertyDescriptors(re)) : ownKeys(Object(re)).forEach(function(oe) {
      Object.defineProperty(le, oe, Object.getOwnPropertyDescriptor(re, oe));
    });
  }
  return le;
}
function _toPrimitive(le, Y) {
  if (typeof le != "object" || !le) return le;
  var re = le[Symbol.toPrimitive];
  if (re !== void 0) {
    var oe = re.call(le, Y);
    if (typeof oe != "object") return oe;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(le);
}
function _toPropertyKey(le) {
  var Y = _toPrimitive(le, "string");
  return typeof Y == "symbol" ? Y : Y + "";
}
function _typeof(le) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Y) {
    return typeof Y;
  } : function(Y) {
    return Y && typeof Symbol == "function" && Y.constructor === Symbol && Y !== Symbol.prototype ? "symbol" : typeof Y;
  }, _typeof(le);
}
function _classCallCheck(le, Y) {
  if (!(le instanceof Y))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(le, Y) {
  for (var re = 0; re < Y.length; re++) {
    var oe = Y[re];
    oe.enumerable = oe.enumerable || !1, oe.configurable = !0, "value" in oe && (oe.writable = !0), Object.defineProperty(le, _toPropertyKey(oe.key), oe);
  }
}
function _createClass(le, Y, re) {
  return Y && _defineProperties(le.prototype, Y), re && _defineProperties(le, re), Object.defineProperty(le, "prototype", {
    writable: !1
  }), le;
}
function _defineProperty(le, Y, re) {
  return Y = _toPropertyKey(Y), Y in le ? Object.defineProperty(le, Y, {
    value: re,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : le[Y] = re, le;
}
function _toConsumableArray(le) {
  return _arrayWithoutHoles(le) || _iterableToArray(le) || _unsupportedIterableToArray(le) || _nonIterableSpread();
}
function _arrayWithoutHoles(le) {
  if (Array.isArray(le)) return _arrayLikeToArray(le);
}
function _iterableToArray(le) {
  if (typeof Symbol < "u" && le[Symbol.iterator] != null || le["@@iterator"] != null) return Array.from(le);
}
function _unsupportedIterableToArray(le, Y) {
  if (le) {
    if (typeof le == "string") return _arrayLikeToArray(le, Y);
    var re = Object.prototype.toString.call(le).slice(8, -1);
    if (re === "Object" && le.constructor && (re = le.constructor.name), re === "Map" || re === "Set") return Array.from(le);
    if (re === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(re)) return _arrayLikeToArray(le, Y);
  }
}
function _arrayLikeToArray(le, Y) {
  (Y == null || Y > le.length) && (Y = le.length);
  for (var re = 0, oe = new Array(Y); re < Y; re++) oe[re] = le[re];
  return oe;
}
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var IS_BROWSER = typeof window < "u" && typeof window.document < "u", WINDOW = IS_BROWSER ? window : {}, IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? "ontouchstart" in WINDOW.document.documentElement : !1, HAS_POINTER_EVENT = IS_BROWSER ? "PointerEvent" in WINDOW : !1, NAMESPACE = "cropper", ACTION_ALL = "all", ACTION_CROP = "crop", ACTION_MOVE = "move", ACTION_ZOOM = "zoom", ACTION_EAST = "e", ACTION_WEST = "w", ACTION_SOUTH = "s", ACTION_NORTH = "n", ACTION_NORTH_EAST = "ne", ACTION_NORTH_WEST = "nw", ACTION_SOUTH_EAST = "se", ACTION_SOUTH_WEST = "sw", CLASS_CROP = "".concat(NAMESPACE, "-crop"), CLASS_DISABLED = "".concat(NAMESPACE, "-disabled"), CLASS_HIDDEN = "".concat(NAMESPACE, "-hidden"), CLASS_HIDE = "".concat(NAMESPACE, "-hide"), CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible"), CLASS_MODAL = "".concat(NAMESPACE, "-modal"), CLASS_MOVE = "".concat(NAMESPACE, "-move"), DATA_ACTION = "".concat(NAMESPACE, "Action"), DATA_PREVIEW = "".concat(NAMESPACE, "Preview"), DRAG_MODE_CROP = "crop", DRAG_MODE_MOVE = "move", DRAG_MODE_NONE = "none", EVENT_CROP = "crop", EVENT_CROP_END = "cropend", EVENT_CROP_MOVE = "cropmove", EVENT_CROP_START = "cropstart", EVENT_DBLCLICK = "dblclick", EVENT_TOUCH_START = IS_TOUCH_DEVICE ? "touchstart" : "mousedown", EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? "touchmove" : "mousemove", EVENT_TOUCH_END = IS_TOUCH_DEVICE ? "touchend touchcancel" : "mouseup", EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? "pointerdown" : EVENT_TOUCH_START, EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? "pointermove" : EVENT_TOUCH_MOVE, EVENT_POINTER_UP = HAS_POINTER_EVENT ? "pointerup pointercancel" : EVENT_TOUCH_END, EVENT_READY = "ready", EVENT_RESIZE = "resize", EVENT_WHEEL = "wheel", EVENT_ZOOM = "zoom", MIME_TYPE_JPEG = "image/jpeg", REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/, REGEXP_DATA_URL = /^data:/, REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/, REGEXP_TAG_NAME = /^img|canvas$/i, MIN_CONTAINER_WIDTH = 200, MIN_CONTAINER_HEIGHT = 100, DEFAULTS = {
  // Define the view mode of the cropper
  viewMode: 0,
  // 0, 1, 2, 3
  // Define the dragging mode of the cropper
  dragMode: DRAG_MODE_CROP,
  // 'crop', 'move' or 'none'
  // Define the initial aspect ratio of the crop box
  initialAspectRatio: NaN,
  // Define the aspect ratio of the crop box
  aspectRatio: NaN,
  // An object with the previous cropping result data
  data: null,
  // A selector for adding extra containers to preview
  preview: "",
  // Re-render the cropper when resize the window
  responsive: !0,
  // Restore the cropped area after resize the window
  restore: !0,
  // Check if the current image is a cross-origin image
  checkCrossOrigin: !0,
  // Check the current image's Exif Orientation information
  checkOrientation: !0,
  // Show the black modal
  modal: !0,
  // Show the dashed lines for guiding
  guides: !0,
  // Show the center indicator for guiding
  center: !0,
  // Show the white modal to highlight the crop box
  highlight: !0,
  // Show the grid background
  background: !0,
  // Enable to crop the image automatically when initialize
  autoCrop: !0,
  // Define the percentage of automatic cropping area when initializes
  autoCropArea: 0.8,
  // Enable to move the image
  movable: !0,
  // Enable to rotate the image
  rotatable: !0,
  // Enable to scale the image
  scalable: !0,
  // Enable to zoom the image
  zoomable: !0,
  // Enable to zoom the image by dragging touch
  zoomOnTouch: !0,
  // Enable to zoom the image by wheeling mouse
  zoomOnWheel: !0,
  // Define zoom ratio when zoom the image by wheeling mouse
  wheelZoomRatio: 0.1,
  // Enable to move the crop box
  cropBoxMovable: !0,
  // Enable to resize the crop box
  cropBoxResizable: !0,
  // Toggle drag mode between "crop" and "move" when click twice on the cropper
  toggleDragModeOnDblclick: !0,
  // Size limitation
  minCanvasWidth: 0,
  minCanvasHeight: 0,
  minCropBoxWidth: 0,
  minCropBoxHeight: 0,
  minContainerWidth: MIN_CONTAINER_WIDTH,
  minContainerHeight: MIN_CONTAINER_HEIGHT,
  // Shortcuts of events
  ready: null,
  cropstart: null,
  cropmove: null,
  cropend: null,
  crop: null,
  zoom: null
}, TEMPLATE = '<div class="cropper-container" touch-action="none"><div class="cropper-wrap-box"><div class="cropper-canvas"></div></div><div class="cropper-drag-box"></div><div class="cropper-crop-box"><span class="cropper-view-box"></span><span class="cropper-dashed dashed-h"></span><span class="cropper-dashed dashed-v"></span><span class="cropper-center"></span><span class="cropper-face"></span><span class="cropper-line line-e" data-cropper-action="e"></span><span class="cropper-line line-n" data-cropper-action="n"></span><span class="cropper-line line-w" data-cropper-action="w"></span><span class="cropper-line line-s" data-cropper-action="s"></span><span class="cropper-point point-e" data-cropper-action="e"></span><span class="cropper-point point-n" data-cropper-action="n"></span><span class="cropper-point point-w" data-cropper-action="w"></span><span class="cropper-point point-s" data-cropper-action="s"></span><span class="cropper-point point-ne" data-cropper-action="ne"></span><span class="cropper-point point-nw" data-cropper-action="nw"></span><span class="cropper-point point-sw" data-cropper-action="sw"></span><span class="cropper-point point-se" data-cropper-action="se"></span></div></div>', isNaN$1 = Number.isNaN || WINDOW.isNaN;
function isNumber(le) {
  return typeof le == "number" && !isNaN$1(le);
}
var isPositiveNumber = function le(Y) {
  return Y > 0 && Y < 1 / 0;
};
function isUndefined(le) {
  return typeof le > "u";
}
function isObject(le) {
  return _typeof(le) === "object" && le !== null;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function isPlainObject(le) {
  if (!isObject(le))
    return !1;
  try {
    var Y = le.constructor, re = Y.prototype;
    return Y && re && hasOwnProperty.call(re, "isPrototypeOf");
  } catch {
    return !1;
  }
}
function isFunction(le) {
  return typeof le == "function";
}
var slice = Array.prototype.slice;
function toArray(le) {
  return Array.from ? Array.from(le) : slice.call(le);
}
function forEach(le, Y) {
  return le && isFunction(Y) && (Array.isArray(le) || isNumber(le.length) ? toArray(le).forEach(function(re, oe) {
    Y.call(le, re, oe, le);
  }) : isObject(le) && Object.keys(le).forEach(function(re) {
    Y.call(le, le[re], re, le);
  })), le;
}
var assign = Object.assign || function le(Y) {
  for (var re = arguments.length, oe = new Array(re > 1 ? re - 1 : 0), ue = 1; ue < re; ue++)
    oe[ue - 1] = arguments[ue];
  return isObject(Y) && oe.length > 0 && oe.forEach(function(fe) {
    isObject(fe) && Object.keys(fe).forEach(function(he) {
      Y[he] = fe[he];
    });
  }), Y;
}, REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
function normalizeDecimalNumber(le) {
  var Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11;
  return REGEXP_DECIMALS.test(le) ? Math.round(le * Y) / Y : le;
}
var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;
function setStyle(le, Y) {
  var re = le.style;
  forEach(Y, function(oe, ue) {
    REGEXP_SUFFIX.test(ue) && isNumber(oe) && (oe = "".concat(oe, "px")), re[ue] = oe;
  });
}
function hasClass(le, Y) {
  return le.classList ? le.classList.contains(Y) : le.className.indexOf(Y) > -1;
}
function addClass(le, Y) {
  if (Y) {
    if (isNumber(le.length)) {
      forEach(le, function(oe) {
        addClass(oe, Y);
      });
      return;
    }
    if (le.classList) {
      le.classList.add(Y);
      return;
    }
    var re = le.className.trim();
    re ? re.indexOf(Y) < 0 && (le.className = "".concat(re, " ").concat(Y)) : le.className = Y;
  }
}
function removeClass(le, Y) {
  if (Y) {
    if (isNumber(le.length)) {
      forEach(le, function(re) {
        removeClass(re, Y);
      });
      return;
    }
    if (le.classList) {
      le.classList.remove(Y);
      return;
    }
    le.className.indexOf(Y) >= 0 && (le.className = le.className.replace(Y, ""));
  }
}
function toggleClass(le, Y, re) {
  if (Y) {
    if (isNumber(le.length)) {
      forEach(le, function(oe) {
        toggleClass(oe, Y, re);
      });
      return;
    }
    re ? addClass(le, Y) : removeClass(le, Y);
  }
}
var REGEXP_CAMEL_CASE = /([a-z\d])([A-Z])/g;
function toParamCase(le) {
  return le.replace(REGEXP_CAMEL_CASE, "$1-$2").toLowerCase();
}
function getData(le, Y) {
  return isObject(le[Y]) ? le[Y] : le.dataset ? le.dataset[Y] : le.getAttribute("data-".concat(toParamCase(Y)));
}
function setData(le, Y, re) {
  isObject(re) ? le[Y] = re : le.dataset ? le.dataset[Y] = re : le.setAttribute("data-".concat(toParamCase(Y)), re);
}
function removeData(le, Y) {
  if (isObject(le[Y]))
    try {
      delete le[Y];
    } catch {
      le[Y] = void 0;
    }
  else if (le.dataset)
    try {
      delete le.dataset[Y];
    } catch {
      le.dataset[Y] = void 0;
    }
  else
    le.removeAttribute("data-".concat(toParamCase(Y)));
}
var REGEXP_SPACES = /\s\s*/, onceSupported = function() {
  var le = !1;
  if (IS_BROWSER) {
    var Y = !1, re = function() {
    }, oe = Object.defineProperty({}, "once", {
      get: function() {
        return le = !0, Y;
      },
      /**
       * This setter can fix a `TypeError` in strict mode
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
       * @param {boolean} value - The value to set
       */
      set: function(fe) {
        Y = fe;
      }
    });
    WINDOW.addEventListener("test", re, oe), WINDOW.removeEventListener("test", re, oe);
  }
  return le;
}();
function removeListener(le, Y, re) {
  var oe = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, ue = re;
  Y.trim().split(REGEXP_SPACES).forEach(function(fe) {
    if (!onceSupported) {
      var he = le.listeners;
      he && he[fe] && he[fe][re] && (ue = he[fe][re], delete he[fe][re], Object.keys(he[fe]).length === 0 && delete he[fe], Object.keys(he).length === 0 && delete le.listeners);
    }
    le.removeEventListener(fe, ue, oe);
  });
}
function addListener(le, Y, re) {
  var oe = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, ue = re;
  Y.trim().split(REGEXP_SPACES).forEach(function(fe) {
    if (oe.once && !onceSupported) {
      var he = le.listeners, _e = he === void 0 ? {} : he;
      ue = function() {
        delete _e[fe][re], le.removeEventListener(fe, ue, oe);
        for (var xe = arguments.length, Ee = new Array(xe), Se = 0; Se < xe; Se++)
          Ee[Se] = arguments[Se];
        re.apply(le, Ee);
      }, _e[fe] || (_e[fe] = {}), _e[fe][re] && le.removeEventListener(fe, _e[fe][re], oe), _e[fe][re] = ue, le.listeners = _e;
    }
    le.addEventListener(fe, ue, oe);
  });
}
function dispatchEvent(le, Y, re) {
  var oe;
  return isFunction(Event) && isFunction(CustomEvent) ? oe = new CustomEvent(Y, {
    detail: re,
    bubbles: !0,
    cancelable: !0
  }) : (oe = document.createEvent("CustomEvent"), oe.initCustomEvent(Y, !0, !0, re)), le.dispatchEvent(oe);
}
function getOffset(le) {
  var Y = le.getBoundingClientRect();
  return {
    left: Y.left + (window.pageXOffset - document.documentElement.clientLeft),
    top: Y.top + (window.pageYOffset - document.documentElement.clientTop)
  };
}
var location = WINDOW.location, REGEXP_ORIGINS = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
function isCrossOriginURL(le) {
  var Y = le.match(REGEXP_ORIGINS);
  return Y !== null && (Y[1] !== location.protocol || Y[2] !== location.hostname || Y[3] !== location.port);
}
function addTimestamp(le) {
  var Y = "timestamp=".concat((/* @__PURE__ */ new Date()).getTime());
  return le + (le.indexOf("?") === -1 ? "?" : "&") + Y;
}
function getTransforms(le) {
  var Y = le.rotate, re = le.scaleX, oe = le.scaleY, ue = le.translateX, fe = le.translateY, he = [];
  isNumber(ue) && ue !== 0 && he.push("translateX(".concat(ue, "px)")), isNumber(fe) && fe !== 0 && he.push("translateY(".concat(fe, "px)")), isNumber(Y) && Y !== 0 && he.push("rotate(".concat(Y, "deg)")), isNumber(re) && re !== 1 && he.push("scaleX(".concat(re, ")")), isNumber(oe) && oe !== 1 && he.push("scaleY(".concat(oe, ")"));
  var _e = he.length ? he.join(" ") : "none";
  return {
    WebkitTransform: _e,
    msTransform: _e,
    transform: _e
  };
}
function getMaxZoomRatio(le) {
  var Y = _objectSpread2({}, le), re = 0;
  return forEach(le, function(oe, ue) {
    delete Y[ue], forEach(Y, function(fe) {
      var he = Math.abs(oe.startX - fe.startX), _e = Math.abs(oe.startY - fe.startY), ve = Math.abs(oe.endX - fe.endX), xe = Math.abs(oe.endY - fe.endY), Ee = Math.sqrt(he * he + _e * _e), Se = Math.sqrt(ve * ve + xe * xe), Te = (Se - Ee) / Ee;
      Math.abs(Te) > Math.abs(re) && (re = Te);
    });
  }), re;
}
function getPointer(le, Y) {
  var re = le.pageX, oe = le.pageY, ue = {
    endX: re,
    endY: oe
  };
  return Y ? ue : _objectSpread2({
    startX: re,
    startY: oe
  }, ue);
}
function getPointersCenter(le) {
  var Y = 0, re = 0, oe = 0;
  return forEach(le, function(ue) {
    var fe = ue.startX, he = ue.startY;
    Y += fe, re += he, oe += 1;
  }), Y /= oe, re /= oe, {
    pageX: Y,
    pageY: re
  };
}
function getAdjustedSizes(le) {
  var Y = le.aspectRatio, re = le.height, oe = le.width, ue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "contain", fe = isPositiveNumber(oe), he = isPositiveNumber(re);
  if (fe && he) {
    var _e = re * Y;
    ue === "contain" && _e > oe || ue === "cover" && _e < oe ? re = oe / Y : oe = re * Y;
  } else fe ? re = oe / Y : he && (oe = re * Y);
  return {
    width: oe,
    height: re
  };
}
function getRotatedSizes(le) {
  var Y = le.width, re = le.height, oe = le.degree;
  if (oe = Math.abs(oe) % 180, oe === 90)
    return {
      width: re,
      height: Y
    };
  var ue = oe % 90 * Math.PI / 180, fe = Math.sin(ue), he = Math.cos(ue), _e = Y * he + re * fe, ve = Y * fe + re * he;
  return oe > 90 ? {
    width: ve,
    height: _e
  } : {
    width: _e,
    height: ve
  };
}
function getSourceCanvas(le, Y, re, oe) {
  var ue = Y.aspectRatio, fe = Y.naturalWidth, he = Y.naturalHeight, _e = Y.rotate, ve = _e === void 0 ? 0 : _e, xe = Y.scaleX, Ee = xe === void 0 ? 1 : xe, Se = Y.scaleY, Te = Se === void 0 ? 1 : Se, Ce = re.aspectRatio, Ie = re.naturalWidth, Ne = re.naturalHeight, Re = oe.fillColor, Ae = Re === void 0 ? "transparent" : Re, Pe = oe.imageSmoothingEnabled, Fe = Pe === void 0 ? !0 : Pe, Le = oe.imageSmoothingQuality, He = Le === void 0 ? "low" : Le, Ge = oe.maxWidth, Ve = Ge === void 0 ? 1 / 0 : Ge, $e = oe.maxHeight, De = $e === void 0 ? 1 / 0 : $e, Ke = oe.minWidth, ze = Ke === void 0 ? 0 : Ke, tt = oe.minHeight, Xe = tt === void 0 ? 0 : tt, mt = document.createElement("canvas"), at = mt.getContext("2d"), qe = getAdjustedSizes({
    aspectRatio: Ce,
    width: Ve,
    height: De
  }), st = getAdjustedSizes({
    aspectRatio: Ce,
    width: ze,
    height: Xe
  }, "cover"), xt = Math.min(qe.width, Math.max(st.width, Ie)), gt = Math.min(qe.height, Math.max(st.height, Ne)), Ze = getAdjustedSizes({
    aspectRatio: ue,
    width: Ve,
    height: De
  }), _t = getAdjustedSizes({
    aspectRatio: ue,
    width: ze,
    height: Xe
  }, "cover"), wt = Math.min(Ze.width, Math.max(_t.width, fe)), yt = Math.min(Ze.height, Math.max(_t.height, he)), St = [-wt / 2, -yt / 2, wt, yt];
  return mt.width = normalizeDecimalNumber(xt), mt.height = normalizeDecimalNumber(gt), at.fillStyle = Ae, at.fillRect(0, 0, xt, gt), at.save(), at.translate(xt / 2, gt / 2), at.rotate(ve * Math.PI / 180), at.scale(Ee, Te), at.imageSmoothingEnabled = Fe, at.imageSmoothingQuality = He, at.drawImage.apply(at, [le].concat(_toConsumableArray(St.map(function(It) {
    return Math.floor(normalizeDecimalNumber(It));
  })))), at.restore(), mt;
}
var fromCharCode = String.fromCharCode;
function getStringFromCharCode(le, Y, re) {
  var oe = "";
  re += Y;
  for (var ue = Y; ue < re; ue += 1)
    oe += fromCharCode(le.getUint8(ue));
  return oe;
}
var REGEXP_DATA_URL_HEAD = /^data:.*,/;
function dataURLToArrayBuffer(le) {
  var Y = le.replace(REGEXP_DATA_URL_HEAD, ""), re = atob(Y), oe = new ArrayBuffer(re.length), ue = new Uint8Array(oe);
  return forEach(ue, function(fe, he) {
    ue[he] = re.charCodeAt(he);
  }), oe;
}
function arrayBufferToDataURL(le, Y) {
  for (var re = [], oe = 8192, ue = new Uint8Array(le); ue.length > 0; )
    re.push(fromCharCode.apply(null, toArray(ue.subarray(0, oe)))), ue = ue.subarray(oe);
  return "data:".concat(Y, ";base64,").concat(btoa(re.join("")));
}
function resetAndGetOrientation(le) {
  var Y = new DataView(le), re;
  try {
    var oe, ue, fe;
    if (Y.getUint8(0) === 255 && Y.getUint8(1) === 216)
      for (var he = Y.byteLength, _e = 2; _e + 1 < he; ) {
        if (Y.getUint8(_e) === 255 && Y.getUint8(_e + 1) === 225) {
          ue = _e;
          break;
        }
        _e += 1;
      }
    if (ue) {
      var ve = ue + 4, xe = ue + 10;
      if (getStringFromCharCode(Y, ve, 4) === "Exif") {
        var Ee = Y.getUint16(xe);
        if (oe = Ee === 18761, (oe || Ee === 19789) && Y.getUint16(xe + 2, oe) === 42) {
          var Se = Y.getUint32(xe + 4, oe);
          Se >= 8 && (fe = xe + Se);
        }
      }
    }
    if (fe) {
      var Te = Y.getUint16(fe, oe), Ce, Ie;
      for (Ie = 0; Ie < Te; Ie += 1)
        if (Ce = fe + Ie * 12 + 2, Y.getUint16(Ce, oe) === 274) {
          Ce += 8, re = Y.getUint16(Ce, oe), Y.setUint16(Ce, 1, oe);
          break;
        }
    }
  } catch {
    re = 1;
  }
  return re;
}
function parseOrientation(le) {
  var Y = 0, re = 1, oe = 1;
  switch (le) {
    // Flip horizontal
    case 2:
      re = -1;
      break;
    // Rotate left 180°
    case 3:
      Y = -180;
      break;
    // Flip vertical
    case 4:
      oe = -1;
      break;
    // Flip vertical and rotate right 90°
    case 5:
      Y = 90, oe = -1;
      break;
    // Rotate right 90°
    case 6:
      Y = 90;
      break;
    // Flip horizontal and rotate right 90°
    case 7:
      Y = 90, re = -1;
      break;
    // Rotate left 90°
    case 8:
      Y = -90;
      break;
  }
  return {
    rotate: Y,
    scaleX: re,
    scaleY: oe
  };
}
var render = {
  render: function le() {
    this.initContainer(), this.initCanvas(), this.initCropBox(), this.renderCanvas(), this.cropped && this.renderCropBox();
  },
  initContainer: function le() {
    var Y = this.element, re = this.options, oe = this.container, ue = this.cropper, fe = Number(re.minContainerWidth), he = Number(re.minContainerHeight);
    addClass(ue, CLASS_HIDDEN), removeClass(Y, CLASS_HIDDEN);
    var _e = {
      width: Math.max(oe.offsetWidth, fe >= 0 ? fe : MIN_CONTAINER_WIDTH),
      height: Math.max(oe.offsetHeight, he >= 0 ? he : MIN_CONTAINER_HEIGHT)
    };
    this.containerData = _e, setStyle(ue, {
      width: _e.width,
      height: _e.height
    }), addClass(Y, CLASS_HIDDEN), removeClass(ue, CLASS_HIDDEN);
  },
  // Canvas (image wrapper)
  initCanvas: function le() {
    var Y = this.containerData, re = this.imageData, oe = this.options.viewMode, ue = Math.abs(re.rotate) % 180 === 90, fe = ue ? re.naturalHeight : re.naturalWidth, he = ue ? re.naturalWidth : re.naturalHeight, _e = fe / he, ve = Y.width, xe = Y.height;
    Y.height * _e > Y.width ? oe === 3 ? ve = Y.height * _e : xe = Y.width / _e : oe === 3 ? xe = Y.width / _e : ve = Y.height * _e;
    var Ee = {
      aspectRatio: _e,
      naturalWidth: fe,
      naturalHeight: he,
      width: ve,
      height: xe
    };
    this.canvasData = Ee, this.limited = oe === 1 || oe === 2, this.limitCanvas(!0, !0), Ee.width = Math.min(Math.max(Ee.width, Ee.minWidth), Ee.maxWidth), Ee.height = Math.min(Math.max(Ee.height, Ee.minHeight), Ee.maxHeight), Ee.left = (Y.width - Ee.width) / 2, Ee.top = (Y.height - Ee.height) / 2, Ee.oldLeft = Ee.left, Ee.oldTop = Ee.top, this.initialCanvasData = assign({}, Ee);
  },
  limitCanvas: function le(Y, re) {
    var oe = this.options, ue = this.containerData, fe = this.canvasData, he = this.cropBoxData, _e = oe.viewMode, ve = fe.aspectRatio, xe = this.cropped && he;
    if (Y) {
      var Ee = Number(oe.minCanvasWidth) || 0, Se = Number(oe.minCanvasHeight) || 0;
      _e > 1 ? (Ee = Math.max(Ee, ue.width), Se = Math.max(Se, ue.height), _e === 3 && (Se * ve > Ee ? Ee = Se * ve : Se = Ee / ve)) : _e > 0 && (Ee ? Ee = Math.max(Ee, xe ? he.width : 0) : Se ? Se = Math.max(Se, xe ? he.height : 0) : xe && (Ee = he.width, Se = he.height, Se * ve > Ee ? Ee = Se * ve : Se = Ee / ve));
      var Te = getAdjustedSizes({
        aspectRatio: ve,
        width: Ee,
        height: Se
      });
      Ee = Te.width, Se = Te.height, fe.minWidth = Ee, fe.minHeight = Se, fe.maxWidth = 1 / 0, fe.maxHeight = 1 / 0;
    }
    if (re)
      if (_e > (xe ? 0 : 1)) {
        var Ce = ue.width - fe.width, Ie = ue.height - fe.height;
        fe.minLeft = Math.min(0, Ce), fe.minTop = Math.min(0, Ie), fe.maxLeft = Math.max(0, Ce), fe.maxTop = Math.max(0, Ie), xe && this.limited && (fe.minLeft = Math.min(he.left, he.left + (he.width - fe.width)), fe.minTop = Math.min(he.top, he.top + (he.height - fe.height)), fe.maxLeft = he.left, fe.maxTop = he.top, _e === 2 && (fe.width >= ue.width && (fe.minLeft = Math.min(0, Ce), fe.maxLeft = Math.max(0, Ce)), fe.height >= ue.height && (fe.minTop = Math.min(0, Ie), fe.maxTop = Math.max(0, Ie))));
      } else
        fe.minLeft = -fe.width, fe.minTop = -fe.height, fe.maxLeft = ue.width, fe.maxTop = ue.height;
  },
  renderCanvas: function le(Y, re) {
    var oe = this.canvasData, ue = this.imageData;
    if (re) {
      var fe = getRotatedSizes({
        width: ue.naturalWidth * Math.abs(ue.scaleX || 1),
        height: ue.naturalHeight * Math.abs(ue.scaleY || 1),
        degree: ue.rotate || 0
      }), he = fe.width, _e = fe.height, ve = oe.width * (he / oe.naturalWidth), xe = oe.height * (_e / oe.naturalHeight);
      oe.left -= (ve - oe.width) / 2, oe.top -= (xe - oe.height) / 2, oe.width = ve, oe.height = xe, oe.aspectRatio = he / _e, oe.naturalWidth = he, oe.naturalHeight = _e, this.limitCanvas(!0, !1);
    }
    (oe.width > oe.maxWidth || oe.width < oe.minWidth) && (oe.left = oe.oldLeft), (oe.height > oe.maxHeight || oe.height < oe.minHeight) && (oe.top = oe.oldTop), oe.width = Math.min(Math.max(oe.width, oe.minWidth), oe.maxWidth), oe.height = Math.min(Math.max(oe.height, oe.minHeight), oe.maxHeight), this.limitCanvas(!1, !0), oe.left = Math.min(Math.max(oe.left, oe.minLeft), oe.maxLeft), oe.top = Math.min(Math.max(oe.top, oe.minTop), oe.maxTop), oe.oldLeft = oe.left, oe.oldTop = oe.top, setStyle(this.canvas, assign({
      width: oe.width,
      height: oe.height
    }, getTransforms({
      translateX: oe.left,
      translateY: oe.top
    }))), this.renderImage(Y), this.cropped && this.limited && this.limitCropBox(!0, !0);
  },
  renderImage: function le(Y) {
    var re = this.canvasData, oe = this.imageData, ue = oe.naturalWidth * (re.width / re.naturalWidth), fe = oe.naturalHeight * (re.height / re.naturalHeight);
    assign(oe, {
      width: ue,
      height: fe,
      left: (re.width - ue) / 2,
      top: (re.height - fe) / 2
    }), setStyle(this.image, assign({
      width: oe.width,
      height: oe.height
    }, getTransforms(assign({
      translateX: oe.left,
      translateY: oe.top
    }, oe)))), Y && this.output();
  },
  initCropBox: function le() {
    var Y = this.options, re = this.canvasData, oe = Y.aspectRatio || Y.initialAspectRatio, ue = Number(Y.autoCropArea) || 0.8, fe = {
      width: re.width,
      height: re.height
    };
    oe && (re.height * oe > re.width ? fe.height = fe.width / oe : fe.width = fe.height * oe), this.cropBoxData = fe, this.limitCropBox(!0, !0), fe.width = Math.min(Math.max(fe.width, fe.minWidth), fe.maxWidth), fe.height = Math.min(Math.max(fe.height, fe.minHeight), fe.maxHeight), fe.width = Math.max(fe.minWidth, fe.width * ue), fe.height = Math.max(fe.minHeight, fe.height * ue), fe.left = re.left + (re.width - fe.width) / 2, fe.top = re.top + (re.height - fe.height) / 2, fe.oldLeft = fe.left, fe.oldTop = fe.top, this.initialCropBoxData = assign({}, fe);
  },
  limitCropBox: function le(Y, re) {
    var oe = this.options, ue = this.containerData, fe = this.canvasData, he = this.cropBoxData, _e = this.limited, ve = oe.aspectRatio;
    if (Y) {
      var xe = Number(oe.minCropBoxWidth) || 0, Ee = Number(oe.minCropBoxHeight) || 0, Se = _e ? Math.min(ue.width, fe.width, fe.width + fe.left, ue.width - fe.left) : ue.width, Te = _e ? Math.min(ue.height, fe.height, fe.height + fe.top, ue.height - fe.top) : ue.height;
      xe = Math.min(xe, ue.width), Ee = Math.min(Ee, ue.height), ve && (xe && Ee ? Ee * ve > xe ? Ee = xe / ve : xe = Ee * ve : xe ? Ee = xe / ve : Ee && (xe = Ee * ve), Te * ve > Se ? Te = Se / ve : Se = Te * ve), he.minWidth = Math.min(xe, Se), he.minHeight = Math.min(Ee, Te), he.maxWidth = Se, he.maxHeight = Te;
    }
    re && (_e ? (he.minLeft = Math.max(0, fe.left), he.minTop = Math.max(0, fe.top), he.maxLeft = Math.min(ue.width, fe.left + fe.width) - he.width, he.maxTop = Math.min(ue.height, fe.top + fe.height) - he.height) : (he.minLeft = 0, he.minTop = 0, he.maxLeft = ue.width - he.width, he.maxTop = ue.height - he.height));
  },
  renderCropBox: function le() {
    var Y = this.options, re = this.containerData, oe = this.cropBoxData;
    (oe.width > oe.maxWidth || oe.width < oe.minWidth) && (oe.left = oe.oldLeft), (oe.height > oe.maxHeight || oe.height < oe.minHeight) && (oe.top = oe.oldTop), oe.width = Math.min(Math.max(oe.width, oe.minWidth), oe.maxWidth), oe.height = Math.min(Math.max(oe.height, oe.minHeight), oe.maxHeight), this.limitCropBox(!1, !0), oe.left = Math.min(Math.max(oe.left, oe.minLeft), oe.maxLeft), oe.top = Math.min(Math.max(oe.top, oe.minTop), oe.maxTop), oe.oldLeft = oe.left, oe.oldTop = oe.top, Y.movable && Y.cropBoxMovable && setData(this.face, DATA_ACTION, oe.width >= re.width && oe.height >= re.height ? ACTION_MOVE : ACTION_ALL), setStyle(this.cropBox, assign({
      width: oe.width,
      height: oe.height
    }, getTransforms({
      translateX: oe.left,
      translateY: oe.top
    }))), this.cropped && this.limited && this.limitCanvas(!0, !0), this.disabled || this.output();
  },
  output: function le() {
    this.preview(), dispatchEvent(this.element, EVENT_CROP, this.getData());
  }
}, preview = {
  initPreview: function le() {
    var Y = this.element, re = this.crossOrigin, oe = this.options.preview, ue = re ? this.crossOriginUrl : this.url, fe = Y.alt || "The image to preview", he = document.createElement("img");
    if (re && (he.crossOrigin = re), he.src = ue, he.alt = fe, this.viewBox.appendChild(he), this.viewBoxImage = he, !!oe) {
      var _e = oe;
      typeof oe == "string" ? _e = Y.ownerDocument.querySelectorAll(oe) : oe.querySelector && (_e = [oe]), this.previews = _e, forEach(_e, function(ve) {
        var xe = document.createElement("img");
        setData(ve, DATA_PREVIEW, {
          width: ve.offsetWidth,
          height: ve.offsetHeight,
          html: ve.innerHTML
        }), re && (xe.crossOrigin = re), xe.src = ue, xe.alt = fe, xe.style.cssText = 'display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;"', ve.innerHTML = "", ve.appendChild(xe);
      });
    }
  },
  resetPreview: function le() {
    forEach(this.previews, function(Y) {
      var re = getData(Y, DATA_PREVIEW);
      setStyle(Y, {
        width: re.width,
        height: re.height
      }), Y.innerHTML = re.html, removeData(Y, DATA_PREVIEW);
    });
  },
  preview: function le() {
    var Y = this.imageData, re = this.canvasData, oe = this.cropBoxData, ue = oe.width, fe = oe.height, he = Y.width, _e = Y.height, ve = oe.left - re.left - Y.left, xe = oe.top - re.top - Y.top;
    !this.cropped || this.disabled || (setStyle(this.viewBoxImage, assign({
      width: he,
      height: _e
    }, getTransforms(assign({
      translateX: -ve,
      translateY: -xe
    }, Y)))), forEach(this.previews, function(Ee) {
      var Se = getData(Ee, DATA_PREVIEW), Te = Se.width, Ce = Se.height, Ie = Te, Ne = Ce, Re = 1;
      ue && (Re = Te / ue, Ne = fe * Re), fe && Ne > Ce && (Re = Ce / fe, Ie = ue * Re, Ne = Ce), setStyle(Ee, {
        width: Ie,
        height: Ne
      }), setStyle(Ee.getElementsByTagName("img")[0], assign({
        width: he * Re,
        height: _e * Re
      }, getTransforms(assign({
        translateX: -ve * Re,
        translateY: -xe * Re
      }, Y))));
    }));
  }
}, events = {
  bind: function le() {
    var Y = this.element, re = this.options, oe = this.cropper;
    isFunction(re.cropstart) && addListener(Y, EVENT_CROP_START, re.cropstart), isFunction(re.cropmove) && addListener(Y, EVENT_CROP_MOVE, re.cropmove), isFunction(re.cropend) && addListener(Y, EVENT_CROP_END, re.cropend), isFunction(re.crop) && addListener(Y, EVENT_CROP, re.crop), isFunction(re.zoom) && addListener(Y, EVENT_ZOOM, re.zoom), addListener(oe, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this)), re.zoomable && re.zoomOnWheel && addListener(oe, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
      passive: !1,
      capture: !0
    }), re.toggleDragModeOnDblclick && addListener(oe, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this)), addListener(Y.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this)), addListener(Y.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this)), re.responsive && addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
  },
  unbind: function le() {
    var Y = this.element, re = this.options, oe = this.cropper;
    isFunction(re.cropstart) && removeListener(Y, EVENT_CROP_START, re.cropstart), isFunction(re.cropmove) && removeListener(Y, EVENT_CROP_MOVE, re.cropmove), isFunction(re.cropend) && removeListener(Y, EVENT_CROP_END, re.cropend), isFunction(re.crop) && removeListener(Y, EVENT_CROP, re.crop), isFunction(re.zoom) && removeListener(Y, EVENT_ZOOM, re.zoom), removeListener(oe, EVENT_POINTER_DOWN, this.onCropStart), re.zoomable && re.zoomOnWheel && removeListener(oe, EVENT_WHEEL, this.onWheel, {
      passive: !1,
      capture: !0
    }), re.toggleDragModeOnDblclick && removeListener(oe, EVENT_DBLCLICK, this.onDblclick), removeListener(Y.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove), removeListener(Y.ownerDocument, EVENT_POINTER_UP, this.onCropEnd), re.responsive && removeListener(window, EVENT_RESIZE, this.onResize);
  }
}, handlers = {
  resize: function le() {
    if (!this.disabled) {
      var Y = this.options, re = this.container, oe = this.containerData, ue = re.offsetWidth / oe.width, fe = re.offsetHeight / oe.height, he = Math.abs(ue - 1) > Math.abs(fe - 1) ? ue : fe;
      if (he !== 1) {
        var _e, ve;
        Y.restore && (_e = this.getCanvasData(), ve = this.getCropBoxData()), this.render(), Y.restore && (this.setCanvasData(forEach(_e, function(xe, Ee) {
          _e[Ee] = xe * he;
        })), this.setCropBoxData(forEach(ve, function(xe, Ee) {
          ve[Ee] = xe * he;
        })));
      }
    }
  },
  dblclick: function le() {
    this.disabled || this.options.dragMode === DRAG_MODE_NONE || this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
  },
  wheel: function le(Y) {
    var re = this, oe = Number(this.options.wheelZoomRatio) || 0.1, ue = 1;
    this.disabled || (Y.preventDefault(), !this.wheeling && (this.wheeling = !0, setTimeout(function() {
      re.wheeling = !1;
    }, 50), Y.deltaY ? ue = Y.deltaY > 0 ? 1 : -1 : Y.wheelDelta ? ue = -Y.wheelDelta / 120 : Y.detail && (ue = Y.detail > 0 ? 1 : -1), this.zoom(-ue * oe, Y)));
  },
  cropStart: function le(Y) {
    var re = Y.buttons, oe = Y.button;
    if (!(this.disabled || (Y.type === "mousedown" || Y.type === "pointerdown" && Y.pointerType === "mouse") && // No primary button (Usually the left button)
    (isNumber(re) && re !== 1 || isNumber(oe) && oe !== 0 || Y.ctrlKey))) {
      var ue = this.options, fe = this.pointers, he;
      Y.changedTouches ? forEach(Y.changedTouches, function(_e) {
        fe[_e.identifier] = getPointer(_e);
      }) : fe[Y.pointerId || 0] = getPointer(Y), Object.keys(fe).length > 1 && ue.zoomable && ue.zoomOnTouch ? he = ACTION_ZOOM : he = getData(Y.target, DATA_ACTION), REGEXP_ACTIONS.test(he) && dispatchEvent(this.element, EVENT_CROP_START, {
        originalEvent: Y,
        action: he
      }) !== !1 && (Y.preventDefault(), this.action = he, this.cropping = !1, he === ACTION_CROP && (this.cropping = !0, addClass(this.dragBox, CLASS_MODAL)));
    }
  },
  cropMove: function le(Y) {
    var re = this.action;
    if (!(this.disabled || !re)) {
      var oe = this.pointers;
      Y.preventDefault(), dispatchEvent(this.element, EVENT_CROP_MOVE, {
        originalEvent: Y,
        action: re
      }) !== !1 && (Y.changedTouches ? forEach(Y.changedTouches, function(ue) {
        assign(oe[ue.identifier] || {}, getPointer(ue, !0));
      }) : assign(oe[Y.pointerId || 0] || {}, getPointer(Y, !0)), this.change(Y));
    }
  },
  cropEnd: function le(Y) {
    if (!this.disabled) {
      var re = this.action, oe = this.pointers;
      Y.changedTouches ? forEach(Y.changedTouches, function(ue) {
        delete oe[ue.identifier];
      }) : delete oe[Y.pointerId || 0], re && (Y.preventDefault(), Object.keys(oe).length || (this.action = ""), this.cropping && (this.cropping = !1, toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal)), dispatchEvent(this.element, EVENT_CROP_END, {
        originalEvent: Y,
        action: re
      }));
    }
  }
}, change = {
  change: function le(Y) {
    var re = this.options, oe = this.canvasData, ue = this.containerData, fe = this.cropBoxData, he = this.pointers, _e = this.action, ve = re.aspectRatio, xe = fe.left, Ee = fe.top, Se = fe.width, Te = fe.height, Ce = xe + Se, Ie = Ee + Te, Ne = 0, Re = 0, Ae = ue.width, Pe = ue.height, Fe = !0, Le;
    !ve && Y.shiftKey && (ve = Se && Te ? Se / Te : 1), this.limited && (Ne = fe.minLeft, Re = fe.minTop, Ae = Ne + Math.min(ue.width, oe.width, oe.left + oe.width), Pe = Re + Math.min(ue.height, oe.height, oe.top + oe.height));
    var He = he[Object.keys(he)[0]], Ge = {
      x: He.endX - He.startX,
      y: He.endY - He.startY
    }, Ve = function(De) {
      switch (De) {
        case ACTION_EAST:
          Ce + Ge.x > Ae && (Ge.x = Ae - Ce);
          break;
        case ACTION_WEST:
          xe + Ge.x < Ne && (Ge.x = Ne - xe);
          break;
        case ACTION_NORTH:
          Ee + Ge.y < Re && (Ge.y = Re - Ee);
          break;
        case ACTION_SOUTH:
          Ie + Ge.y > Pe && (Ge.y = Pe - Ie);
          break;
      }
    };
    switch (_e) {
      // Move crop box
      case ACTION_ALL:
        xe += Ge.x, Ee += Ge.y;
        break;
      // Resize crop box
      case ACTION_EAST:
        if (Ge.x >= 0 && (Ce >= Ae || ve && (Ee <= Re || Ie >= Pe))) {
          Fe = !1;
          break;
        }
        Ve(ACTION_EAST), Se += Ge.x, Se < 0 && (_e = ACTION_WEST, Se = -Se, xe -= Se), ve && (Te = Se / ve, Ee += (fe.height - Te) / 2);
        break;
      case ACTION_NORTH:
        if (Ge.y <= 0 && (Ee <= Re || ve && (xe <= Ne || Ce >= Ae))) {
          Fe = !1;
          break;
        }
        Ve(ACTION_NORTH), Te -= Ge.y, Ee += Ge.y, Te < 0 && (_e = ACTION_SOUTH, Te = -Te, Ee -= Te), ve && (Se = Te * ve, xe += (fe.width - Se) / 2);
        break;
      case ACTION_WEST:
        if (Ge.x <= 0 && (xe <= Ne || ve && (Ee <= Re || Ie >= Pe))) {
          Fe = !1;
          break;
        }
        Ve(ACTION_WEST), Se -= Ge.x, xe += Ge.x, Se < 0 && (_e = ACTION_EAST, Se = -Se, xe -= Se), ve && (Te = Se / ve, Ee += (fe.height - Te) / 2);
        break;
      case ACTION_SOUTH:
        if (Ge.y >= 0 && (Ie >= Pe || ve && (xe <= Ne || Ce >= Ae))) {
          Fe = !1;
          break;
        }
        Ve(ACTION_SOUTH), Te += Ge.y, Te < 0 && (_e = ACTION_NORTH, Te = -Te, Ee -= Te), ve && (Se = Te * ve, xe += (fe.width - Se) / 2);
        break;
      case ACTION_NORTH_EAST:
        if (ve) {
          if (Ge.y <= 0 && (Ee <= Re || Ce >= Ae)) {
            Fe = !1;
            break;
          }
          Ve(ACTION_NORTH), Te -= Ge.y, Ee += Ge.y, Se = Te * ve;
        } else
          Ve(ACTION_NORTH), Ve(ACTION_EAST), Ge.x >= 0 ? Ce < Ae ? Se += Ge.x : Ge.y <= 0 && Ee <= Re && (Fe = !1) : Se += Ge.x, Ge.y <= 0 ? Ee > Re && (Te -= Ge.y, Ee += Ge.y) : (Te -= Ge.y, Ee += Ge.y);
        Se < 0 && Te < 0 ? (_e = ACTION_SOUTH_WEST, Te = -Te, Se = -Se, Ee -= Te, xe -= Se) : Se < 0 ? (_e = ACTION_NORTH_WEST, Se = -Se, xe -= Se) : Te < 0 && (_e = ACTION_SOUTH_EAST, Te = -Te, Ee -= Te);
        break;
      case ACTION_NORTH_WEST:
        if (ve) {
          if (Ge.y <= 0 && (Ee <= Re || xe <= Ne)) {
            Fe = !1;
            break;
          }
          Ve(ACTION_NORTH), Te -= Ge.y, Ee += Ge.y, Se = Te * ve, xe += fe.width - Se;
        } else
          Ve(ACTION_NORTH), Ve(ACTION_WEST), Ge.x <= 0 ? xe > Ne ? (Se -= Ge.x, xe += Ge.x) : Ge.y <= 0 && Ee <= Re && (Fe = !1) : (Se -= Ge.x, xe += Ge.x), Ge.y <= 0 ? Ee > Re && (Te -= Ge.y, Ee += Ge.y) : (Te -= Ge.y, Ee += Ge.y);
        Se < 0 && Te < 0 ? (_e = ACTION_SOUTH_EAST, Te = -Te, Se = -Se, Ee -= Te, xe -= Se) : Se < 0 ? (_e = ACTION_NORTH_EAST, Se = -Se, xe -= Se) : Te < 0 && (_e = ACTION_SOUTH_WEST, Te = -Te, Ee -= Te);
        break;
      case ACTION_SOUTH_WEST:
        if (ve) {
          if (Ge.x <= 0 && (xe <= Ne || Ie >= Pe)) {
            Fe = !1;
            break;
          }
          Ve(ACTION_WEST), Se -= Ge.x, xe += Ge.x, Te = Se / ve;
        } else
          Ve(ACTION_SOUTH), Ve(ACTION_WEST), Ge.x <= 0 ? xe > Ne ? (Se -= Ge.x, xe += Ge.x) : Ge.y >= 0 && Ie >= Pe && (Fe = !1) : (Se -= Ge.x, xe += Ge.x), Ge.y >= 0 ? Ie < Pe && (Te += Ge.y) : Te += Ge.y;
        Se < 0 && Te < 0 ? (_e = ACTION_NORTH_EAST, Te = -Te, Se = -Se, Ee -= Te, xe -= Se) : Se < 0 ? (_e = ACTION_SOUTH_EAST, Se = -Se, xe -= Se) : Te < 0 && (_e = ACTION_NORTH_WEST, Te = -Te, Ee -= Te);
        break;
      case ACTION_SOUTH_EAST:
        if (ve) {
          if (Ge.x >= 0 && (Ce >= Ae || Ie >= Pe)) {
            Fe = !1;
            break;
          }
          Ve(ACTION_EAST), Se += Ge.x, Te = Se / ve;
        } else
          Ve(ACTION_SOUTH), Ve(ACTION_EAST), Ge.x >= 0 ? Ce < Ae ? Se += Ge.x : Ge.y >= 0 && Ie >= Pe && (Fe = !1) : Se += Ge.x, Ge.y >= 0 ? Ie < Pe && (Te += Ge.y) : Te += Ge.y;
        Se < 0 && Te < 0 ? (_e = ACTION_NORTH_WEST, Te = -Te, Se = -Se, Ee -= Te, xe -= Se) : Se < 0 ? (_e = ACTION_SOUTH_WEST, Se = -Se, xe -= Se) : Te < 0 && (_e = ACTION_NORTH_EAST, Te = -Te, Ee -= Te);
        break;
      // Move canvas
      case ACTION_MOVE:
        this.move(Ge.x, Ge.y), Fe = !1;
        break;
      // Zoom canvas
      case ACTION_ZOOM:
        this.zoom(getMaxZoomRatio(he), Y), Fe = !1;
        break;
      // Create crop box
      case ACTION_CROP:
        if (!Ge.x || !Ge.y) {
          Fe = !1;
          break;
        }
        Le = getOffset(this.cropper), xe = He.startX - Le.left, Ee = He.startY - Le.top, Se = fe.minWidth, Te = fe.minHeight, Ge.x > 0 ? _e = Ge.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST : Ge.x < 0 && (xe -= Se, _e = Ge.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST), Ge.y < 0 && (Ee -= Te), this.cropped || (removeClass(this.cropBox, CLASS_HIDDEN), this.cropped = !0, this.limited && this.limitCropBox(!0, !0));
        break;
    }
    Fe && (fe.width = Se, fe.height = Te, fe.left = xe, fe.top = Ee, this.action = _e, this.renderCropBox()), forEach(he, function($e) {
      $e.startX = $e.endX, $e.startY = $e.endY;
    });
  }
}, methods = {
  // Show the crop box manually
  crop: function le() {
    return this.ready && !this.cropped && !this.disabled && (this.cropped = !0, this.limitCropBox(!0, !0), this.options.modal && addClass(this.dragBox, CLASS_MODAL), removeClass(this.cropBox, CLASS_HIDDEN), this.setCropBoxData(this.initialCropBoxData)), this;
  },
  // Reset the image and crop box to their initial states
  reset: function le() {
    return this.ready && !this.disabled && (this.imageData = assign({}, this.initialImageData), this.canvasData = assign({}, this.initialCanvasData), this.cropBoxData = assign({}, this.initialCropBoxData), this.renderCanvas(), this.cropped && this.renderCropBox()), this;
  },
  // Clear the crop box
  clear: function le() {
    return this.cropped && !this.disabled && (assign(this.cropBoxData, {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    }), this.cropped = !1, this.renderCropBox(), this.limitCanvas(!0, !0), this.renderCanvas(), removeClass(this.dragBox, CLASS_MODAL), addClass(this.cropBox, CLASS_HIDDEN)), this;
  },
  /**
   * Replace the image's src and rebuild the cropper
   * @param {string} url - The new URL.
   * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.
   * @returns {Cropper} this
   */
  replace: function le(Y) {
    var re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return !this.disabled && Y && (this.isImg && (this.element.src = Y), re ? (this.url = Y, this.image.src = Y, this.ready && (this.viewBoxImage.src = Y, forEach(this.previews, function(oe) {
      oe.getElementsByTagName("img")[0].src = Y;
    }))) : (this.isImg && (this.replaced = !0), this.options.data = null, this.uncreate(), this.load(Y))), this;
  },
  // Enable (unfreeze) the cropper
  enable: function le() {
    return this.ready && this.disabled && (this.disabled = !1, removeClass(this.cropper, CLASS_DISABLED)), this;
  },
  // Disable (freeze) the cropper
  disable: function le() {
    return this.ready && !this.disabled && (this.disabled = !0, addClass(this.cropper, CLASS_DISABLED)), this;
  },
  /**
   * Destroy the cropper and remove the instance from the image
   * @returns {Cropper} this
   */
  destroy: function le() {
    var Y = this.element;
    return Y[NAMESPACE] ? (Y[NAMESPACE] = void 0, this.isImg && this.replaced && (Y.src = this.originalUrl), this.uncreate(), this) : this;
  },
  /**
   * Move the canvas with relative offsets
   * @param {number} offsetX - The relative offset distance on the x-axis.
   * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.
   * @returns {Cropper} this
   */
  move: function le(Y) {
    var re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Y, oe = this.canvasData, ue = oe.left, fe = oe.top;
    return this.moveTo(isUndefined(Y) ? Y : ue + Number(Y), isUndefined(re) ? re : fe + Number(re));
  },
  /**
   * Move the canvas to an absolute point
   * @param {number} x - The x-axis coordinate.
   * @param {number} [y=x] - The y-axis coordinate.
   * @returns {Cropper} this
   */
  moveTo: function le(Y) {
    var re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Y, oe = this.canvasData, ue = !1;
    return Y = Number(Y), re = Number(re), this.ready && !this.disabled && this.options.movable && (isNumber(Y) && (oe.left = Y, ue = !0), isNumber(re) && (oe.top = re, ue = !0), ue && this.renderCanvas(!0)), this;
  },
  /**
   * Zoom the canvas with a relative ratio
   * @param {number} ratio - The target ratio.
   * @param {Event} _originalEvent - The original event if any.
   * @returns {Cropper} this
   */
  zoom: function le(Y, re) {
    var oe = this.canvasData;
    return Y = Number(Y), Y < 0 ? Y = 1 / (1 - Y) : Y = 1 + Y, this.zoomTo(oe.width * Y / oe.naturalWidth, null, re);
  },
  /**
   * Zoom the canvas to an absolute ratio
   * @param {number} ratio - The target ratio.
   * @param {Object} pivot - The zoom pivot point coordinate.
   * @param {Event} _originalEvent - The original event if any.
   * @returns {Cropper} this
   */
  zoomTo: function le(Y, re, oe) {
    var ue = this.options, fe = this.canvasData, he = fe.width, _e = fe.height, ve = fe.naturalWidth, xe = fe.naturalHeight;
    if (Y = Number(Y), Y >= 0 && this.ready && !this.disabled && ue.zoomable) {
      var Ee = ve * Y, Se = xe * Y;
      if (dispatchEvent(this.element, EVENT_ZOOM, {
        ratio: Y,
        oldRatio: he / ve,
        originalEvent: oe
      }) === !1)
        return this;
      if (oe) {
        var Te = this.pointers, Ce = getOffset(this.cropper), Ie = Te && Object.keys(Te).length ? getPointersCenter(Te) : {
          pageX: oe.pageX,
          pageY: oe.pageY
        };
        fe.left -= (Ee - he) * ((Ie.pageX - Ce.left - fe.left) / he), fe.top -= (Se - _e) * ((Ie.pageY - Ce.top - fe.top) / _e);
      } else isPlainObject(re) && isNumber(re.x) && isNumber(re.y) ? (fe.left -= (Ee - he) * ((re.x - fe.left) / he), fe.top -= (Se - _e) * ((re.y - fe.top) / _e)) : (fe.left -= (Ee - he) / 2, fe.top -= (Se - _e) / 2);
      fe.width = Ee, fe.height = Se, this.renderCanvas(!0);
    }
    return this;
  },
  /**
   * Rotate the canvas with a relative degree
   * @param {number} degree - The rotate degree.
   * @returns {Cropper} this
   */
  rotate: function le(Y) {
    return this.rotateTo((this.imageData.rotate || 0) + Number(Y));
  },
  /**
   * Rotate the canvas to an absolute degree
   * @param {number} degree - The rotate degree.
   * @returns {Cropper} this
   */
  rotateTo: function le(Y) {
    return Y = Number(Y), isNumber(Y) && this.ready && !this.disabled && this.options.rotatable && (this.imageData.rotate = Y % 360, this.renderCanvas(!0, !0)), this;
  },
  /**
   * Scale the image on the x-axis.
   * @param {number} scaleX - The scale ratio on the x-axis.
   * @returns {Cropper} this
   */
  scaleX: function le(Y) {
    var re = this.imageData.scaleY;
    return this.scale(Y, isNumber(re) ? re : 1);
  },
  /**
   * Scale the image on the y-axis.
   * @param {number} scaleY - The scale ratio on the y-axis.
   * @returns {Cropper} this
   */
  scaleY: function le(Y) {
    var re = this.imageData.scaleX;
    return this.scale(isNumber(re) ? re : 1, Y);
  },
  /**
   * Scale the image
   * @param {number} scaleX - The scale ratio on the x-axis.
   * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
   * @returns {Cropper} this
   */
  scale: function le(Y) {
    var re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Y, oe = this.imageData, ue = !1;
    return Y = Number(Y), re = Number(re), this.ready && !this.disabled && this.options.scalable && (isNumber(Y) && (oe.scaleX = Y, ue = !0), isNumber(re) && (oe.scaleY = re, ue = !0), ue && this.renderCanvas(!0, !0)), this;
  },
  /**
   * Get the cropped area position and size data (base on the original image)
   * @param {boolean} [rounded=false] - Indicate if round the data values or not.
   * @returns {Object} The result cropped data.
   */
  getData: function le() {
    var Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, re = this.options, oe = this.imageData, ue = this.canvasData, fe = this.cropBoxData, he;
    if (this.ready && this.cropped) {
      he = {
        x: fe.left - ue.left,
        y: fe.top - ue.top,
        width: fe.width,
        height: fe.height
      };
      var _e = oe.width / oe.naturalWidth;
      if (forEach(he, function(Ee, Se) {
        he[Se] = Ee / _e;
      }), Y) {
        var ve = Math.round(he.y + he.height), xe = Math.round(he.x + he.width);
        he.x = Math.round(he.x), he.y = Math.round(he.y), he.width = xe - he.x, he.height = ve - he.y;
      }
    } else
      he = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    return re.rotatable && (he.rotate = oe.rotate || 0), re.scalable && (he.scaleX = oe.scaleX || 1, he.scaleY = oe.scaleY || 1), he;
  },
  /**
   * Set the cropped area position and size with new data
   * @param {Object} data - The new data.
   * @returns {Cropper} this
   */
  setData: function le(Y) {
    var re = this.options, oe = this.imageData, ue = this.canvasData, fe = {};
    if (this.ready && !this.disabled && isPlainObject(Y)) {
      var he = !1;
      re.rotatable && isNumber(Y.rotate) && Y.rotate !== oe.rotate && (oe.rotate = Y.rotate, he = !0), re.scalable && (isNumber(Y.scaleX) && Y.scaleX !== oe.scaleX && (oe.scaleX = Y.scaleX, he = !0), isNumber(Y.scaleY) && Y.scaleY !== oe.scaleY && (oe.scaleY = Y.scaleY, he = !0)), he && this.renderCanvas(!0, !0);
      var _e = oe.width / oe.naturalWidth;
      isNumber(Y.x) && (fe.left = Y.x * _e + ue.left), isNumber(Y.y) && (fe.top = Y.y * _e + ue.top), isNumber(Y.width) && (fe.width = Y.width * _e), isNumber(Y.height) && (fe.height = Y.height * _e), this.setCropBoxData(fe);
    }
    return this;
  },
  /**
   * Get the container size data.
   * @returns {Object} The result container data.
   */
  getContainerData: function le() {
    return this.ready ? assign({}, this.containerData) : {};
  },
  /**
   * Get the image position and size data.
   * @returns {Object} The result image data.
   */
  getImageData: function le() {
    return this.sized ? assign({}, this.imageData) : {};
  },
  /**
   * Get the canvas position and size data.
   * @returns {Object} The result canvas data.
   */
  getCanvasData: function le() {
    var Y = this.canvasData, re = {};
    return this.ready && forEach(["left", "top", "width", "height", "naturalWidth", "naturalHeight"], function(oe) {
      re[oe] = Y[oe];
    }), re;
  },
  /**
   * Set the canvas position and size with new data.
   * @param {Object} data - The new canvas data.
   * @returns {Cropper} this
   */
  setCanvasData: function le(Y) {
    var re = this.canvasData, oe = re.aspectRatio;
    return this.ready && !this.disabled && isPlainObject(Y) && (isNumber(Y.left) && (re.left = Y.left), isNumber(Y.top) && (re.top = Y.top), isNumber(Y.width) ? (re.width = Y.width, re.height = Y.width / oe) : isNumber(Y.height) && (re.height = Y.height, re.width = Y.height * oe), this.renderCanvas(!0)), this;
  },
  /**
   * Get the crop box position and size data.
   * @returns {Object} The result crop box data.
   */
  getCropBoxData: function le() {
    var Y = this.cropBoxData, re;
    return this.ready && this.cropped && (re = {
      left: Y.left,
      top: Y.top,
      width: Y.width,
      height: Y.height
    }), re || {};
  },
  /**
   * Set the crop box position and size with new data.
   * @param {Object} data - The new crop box data.
   * @returns {Cropper} this
   */
  setCropBoxData: function le(Y) {
    var re = this.cropBoxData, oe = this.options.aspectRatio, ue, fe;
    return this.ready && this.cropped && !this.disabled && isPlainObject(Y) && (isNumber(Y.left) && (re.left = Y.left), isNumber(Y.top) && (re.top = Y.top), isNumber(Y.width) && Y.width !== re.width && (ue = !0, re.width = Y.width), isNumber(Y.height) && Y.height !== re.height && (fe = !0, re.height = Y.height), oe && (ue ? re.height = re.width / oe : fe && (re.width = re.height * oe)), this.renderCropBox()), this;
  },
  /**
   * Get a canvas drawn the cropped image.
   * @param {Object} [options={}] - The config options.
   * @returns {HTMLCanvasElement} - The result canvas.
   */
  getCroppedCanvas: function le() {
    var Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!this.ready || !window.HTMLCanvasElement)
      return null;
    var re = this.canvasData, oe = getSourceCanvas(this.image, this.imageData, re, Y);
    if (!this.cropped)
      return oe;
    var ue = this.getData(Y.rounded), fe = ue.x, he = ue.y, _e = ue.width, ve = ue.height, xe = oe.width / Math.floor(re.naturalWidth);
    xe !== 1 && (fe *= xe, he *= xe, _e *= xe, ve *= xe);
    var Ee = _e / ve, Se = getAdjustedSizes({
      aspectRatio: Ee,
      width: Y.maxWidth || 1 / 0,
      height: Y.maxHeight || 1 / 0
    }), Te = getAdjustedSizes({
      aspectRatio: Ee,
      width: Y.minWidth || 0,
      height: Y.minHeight || 0
    }, "cover"), Ce = getAdjustedSizes({
      aspectRatio: Ee,
      width: Y.width || (xe !== 1 ? oe.width : _e),
      height: Y.height || (xe !== 1 ? oe.height : ve)
    }), Ie = Ce.width, Ne = Ce.height;
    Ie = Math.min(Se.width, Math.max(Te.width, Ie)), Ne = Math.min(Se.height, Math.max(Te.height, Ne));
    var Re = document.createElement("canvas"), Ae = Re.getContext("2d");
    Re.width = normalizeDecimalNumber(Ie), Re.height = normalizeDecimalNumber(Ne), Ae.fillStyle = Y.fillColor || "transparent", Ae.fillRect(0, 0, Ie, Ne);
    var Pe = Y.imageSmoothingEnabled, Fe = Pe === void 0 ? !0 : Pe, Le = Y.imageSmoothingQuality;
    Ae.imageSmoothingEnabled = Fe, Le && (Ae.imageSmoothingQuality = Le);
    var He = oe.width, Ge = oe.height, Ve = fe, $e = he, De, Ke, ze, tt, Xe, mt;
    Ve <= -_e || Ve > He ? (Ve = 0, De = 0, ze = 0, Xe = 0) : Ve <= 0 ? (ze = -Ve, Ve = 0, De = Math.min(He, _e + Ve), Xe = De) : Ve <= He && (ze = 0, De = Math.min(_e, He - Ve), Xe = De), De <= 0 || $e <= -ve || $e > Ge ? ($e = 0, Ke = 0, tt = 0, mt = 0) : $e <= 0 ? (tt = -$e, $e = 0, Ke = Math.min(Ge, ve + $e), mt = Ke) : $e <= Ge && (tt = 0, Ke = Math.min(ve, Ge - $e), mt = Ke);
    var at = [Ve, $e, De, Ke];
    if (Xe > 0 && mt > 0) {
      var qe = Ie / _e;
      at.push(ze * qe, tt * qe, Xe * qe, mt * qe);
    }
    return Ae.drawImage.apply(Ae, [oe].concat(_toConsumableArray(at.map(function(st) {
      return Math.floor(normalizeDecimalNumber(st));
    })))), Re;
  },
  /**
   * Change the aspect ratio of the crop box.
   * @param {number} aspectRatio - The new aspect ratio.
   * @returns {Cropper} this
   */
  setAspectRatio: function le(Y) {
    var re = this.options;
    return !this.disabled && !isUndefined(Y) && (re.aspectRatio = Math.max(0, Y) || NaN, this.ready && (this.initCropBox(), this.cropped && this.renderCropBox())), this;
  },
  /**
   * Change the drag mode.
   * @param {string} mode - The new drag mode.
   * @returns {Cropper} this
   */
  setDragMode: function le(Y) {
    var re = this.options, oe = this.dragBox, ue = this.face;
    if (this.ready && !this.disabled) {
      var fe = Y === DRAG_MODE_CROP, he = re.movable && Y === DRAG_MODE_MOVE;
      Y = fe || he ? Y : DRAG_MODE_NONE, re.dragMode = Y, setData(oe, DATA_ACTION, Y), toggleClass(oe, CLASS_CROP, fe), toggleClass(oe, CLASS_MOVE, he), re.cropBoxMovable || (setData(ue, DATA_ACTION, Y), toggleClass(ue, CLASS_CROP, fe), toggleClass(ue, CLASS_MOVE, he));
    }
    return this;
  }
}, AnotherCropper = WINDOW.Cropper, Cropper = /* @__PURE__ */ function() {
  function le(Y) {
    var re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (_classCallCheck(this, le), !Y || !REGEXP_TAG_NAME.test(Y.tagName))
      throw new Error("The first argument is required and must be an <img> or <canvas> element.");
    this.element = Y, this.options = assign({}, DEFAULTS, isPlainObject(re) && re), this.cropped = !1, this.disabled = !1, this.pointers = {}, this.ready = !1, this.reloading = !1, this.replaced = !1, this.sized = !1, this.sizing = !1, this.init();
  }
  return _createClass(le, [{
    key: "init",
    value: function() {
      var re = this.element, oe = re.tagName.toLowerCase(), ue;
      if (!re[NAMESPACE]) {
        if (re[NAMESPACE] = this, oe === "img") {
          if (this.isImg = !0, ue = re.getAttribute("src") || "", this.originalUrl = ue, !ue)
            return;
          ue = re.src;
        } else oe === "canvas" && window.HTMLCanvasElement && (ue = re.toDataURL());
        this.load(ue);
      }
    }
  }, {
    key: "load",
    value: function(re) {
      var oe = this;
      if (re) {
        this.url = re, this.imageData = {};
        var ue = this.element, fe = this.options;
        if (!fe.rotatable && !fe.scalable && (fe.checkOrientation = !1), !fe.checkOrientation || !window.ArrayBuffer) {
          this.clone();
          return;
        }
        if (REGEXP_DATA_URL.test(re)) {
          REGEXP_DATA_URL_JPEG.test(re) ? this.read(dataURLToArrayBuffer(re)) : this.clone();
          return;
        }
        var he = new XMLHttpRequest(), _e = this.clone.bind(this);
        this.reloading = !0, this.xhr = he, he.onabort = _e, he.onerror = _e, he.ontimeout = _e, he.onprogress = function() {
          he.getResponseHeader("content-type") !== MIME_TYPE_JPEG && he.abort();
        }, he.onload = function() {
          oe.read(he.response);
        }, he.onloadend = function() {
          oe.reloading = !1, oe.xhr = null;
        }, fe.checkCrossOrigin && isCrossOriginURL(re) && ue.crossOrigin && (re = addTimestamp(re)), he.open("GET", re, !0), he.responseType = "arraybuffer", he.withCredentials = ue.crossOrigin === "use-credentials", he.send();
      }
    }
  }, {
    key: "read",
    value: function(re) {
      var oe = this.options, ue = this.imageData, fe = resetAndGetOrientation(re), he = 0, _e = 1, ve = 1;
      if (fe > 1) {
        this.url = arrayBufferToDataURL(re, MIME_TYPE_JPEG);
        var xe = parseOrientation(fe);
        he = xe.rotate, _e = xe.scaleX, ve = xe.scaleY;
      }
      oe.rotatable && (ue.rotate = he), oe.scalable && (ue.scaleX = _e, ue.scaleY = ve), this.clone();
    }
  }, {
    key: "clone",
    value: function() {
      var re = this.element, oe = this.url, ue = re.crossOrigin, fe = oe;
      this.options.checkCrossOrigin && isCrossOriginURL(oe) && (ue || (ue = "anonymous"), fe = addTimestamp(oe)), this.crossOrigin = ue, this.crossOriginUrl = fe;
      var he = document.createElement("img");
      ue && (he.crossOrigin = ue), he.src = fe || oe, he.alt = re.alt || "The image to crop", this.image = he, he.onload = this.start.bind(this), he.onerror = this.stop.bind(this), addClass(he, CLASS_HIDE), re.parentNode.insertBefore(he, re.nextSibling);
    }
  }, {
    key: "start",
    value: function() {
      var re = this, oe = this.image;
      oe.onload = null, oe.onerror = null, this.sizing = !0;
      var ue = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent), fe = function(xe, Ee) {
        assign(re.imageData, {
          naturalWidth: xe,
          naturalHeight: Ee,
          aspectRatio: xe / Ee
        }), re.initialImageData = assign({}, re.imageData), re.sizing = !1, re.sized = !0, re.build();
      };
      if (oe.naturalWidth && !ue) {
        fe(oe.naturalWidth, oe.naturalHeight);
        return;
      }
      var he = document.createElement("img"), _e = document.body || document.documentElement;
      this.sizingImage = he, he.onload = function() {
        fe(he.width, he.height), ue || _e.removeChild(he);
      }, he.src = oe.src, ue || (he.style.cssText = "left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;", _e.appendChild(he));
    }
  }, {
    key: "stop",
    value: function() {
      var re = this.image;
      re.onload = null, re.onerror = null, re.parentNode.removeChild(re), this.image = null;
    }
  }, {
    key: "build",
    value: function() {
      if (!(!this.sized || this.ready)) {
        var re = this.element, oe = this.options, ue = this.image, fe = re.parentNode, he = document.createElement("div");
        he.innerHTML = TEMPLATE;
        var _e = he.querySelector(".".concat(NAMESPACE, "-container")), ve = _e.querySelector(".".concat(NAMESPACE, "-canvas")), xe = _e.querySelector(".".concat(NAMESPACE, "-drag-box")), Ee = _e.querySelector(".".concat(NAMESPACE, "-crop-box")), Se = Ee.querySelector(".".concat(NAMESPACE, "-face"));
        this.container = fe, this.cropper = _e, this.canvas = ve, this.dragBox = xe, this.cropBox = Ee, this.viewBox = _e.querySelector(".".concat(NAMESPACE, "-view-box")), this.face = Se, ve.appendChild(ue), addClass(re, CLASS_HIDDEN), fe.insertBefore(_e, re.nextSibling), removeClass(ue, CLASS_HIDE), this.initPreview(), this.bind(), oe.initialAspectRatio = Math.max(0, oe.initialAspectRatio) || NaN, oe.aspectRatio = Math.max(0, oe.aspectRatio) || NaN, oe.viewMode = Math.max(0, Math.min(3, Math.round(oe.viewMode))) || 0, addClass(Ee, CLASS_HIDDEN), oe.guides || addClass(Ee.getElementsByClassName("".concat(NAMESPACE, "-dashed")), CLASS_HIDDEN), oe.center || addClass(Ee.getElementsByClassName("".concat(NAMESPACE, "-center")), CLASS_HIDDEN), oe.background && addClass(_e, "".concat(NAMESPACE, "-bg")), oe.highlight || addClass(Se, CLASS_INVISIBLE), oe.cropBoxMovable && (addClass(Se, CLASS_MOVE), setData(Se, DATA_ACTION, ACTION_ALL)), oe.cropBoxResizable || (addClass(Ee.getElementsByClassName("".concat(NAMESPACE, "-line")), CLASS_HIDDEN), addClass(Ee.getElementsByClassName("".concat(NAMESPACE, "-point")), CLASS_HIDDEN)), this.render(), this.ready = !0, this.setDragMode(oe.dragMode), oe.autoCrop && this.crop(), this.setData(oe.data), isFunction(oe.ready) && addListener(re, EVENT_READY, oe.ready, {
          once: !0
        }), dispatchEvent(re, EVENT_READY);
      }
    }
  }, {
    key: "unbuild",
    value: function() {
      if (this.ready) {
        this.ready = !1, this.unbind(), this.resetPreview();
        var re = this.cropper.parentNode;
        re && re.removeChild(this.cropper), removeClass(this.element, CLASS_HIDDEN);
      }
    }
  }, {
    key: "uncreate",
    value: function() {
      this.ready ? (this.unbuild(), this.ready = !1, this.cropped = !1) : this.sizing ? (this.sizingImage.onload = null, this.sizing = !1, this.sized = !1) : this.reloading ? (this.xhr.onabort = null, this.xhr.abort()) : this.image && this.stop();
    }
    /**
     * Get the no conflict cropper class.
     * @returns {Cropper} The cropper class.
     */
  }], [{
    key: "noConflict",
    value: function() {
      return window.Cropper = AnotherCropper, le;
    }
    /**
     * Change the default options.
     * @param {Object} options - The new default options.
     */
  }, {
    key: "setDefaults",
    value: function(re) {
      assign(DEFAULTS, isPlainObject(re) && re);
    }
  }]);
}();
assign(Cropper.prototype, render, preview, events, handlers, change, methods);
function getCanvasDataThatFitsPerfectlyIntoContainer(le, Y) {
  const re = le.width / Y.width, oe = le.height / Y.height, ue = Math.min(re, oe), fe = Y.width * ue, he = Y.height * ue, _e = (le.width - fe) / 2, ve = (le.height - he) / 2;
  return {
    width: fe,
    height: he,
    left: _e,
    top: ve
  };
}
function toRadians(le) {
  return le * (Math.PI / 180);
}
function getScaleFactorThatRemovesDarkCorners(le, Y, re) {
  const oe = Math.abs(toRadians(re));
  return Math.max((Math.sin(oe) * le + Math.cos(oe) * Y) / Y, (Math.sin(oe) * Y + Math.cos(oe) * le) / le);
}
function limitCropboxMovementOnMove(le, Y, re) {
  return Y.left < le.left ? {
    left: le.left,
    width: re.width
  } : Y.top < le.top ? {
    top: le.top,
    height: re.height
  } : Y.left + Y.width > le.left + le.width ? {
    left: le.left + le.width - re.width,
    width: re.width
  } : Y.top + Y.height > le.top + le.height ? {
    top: le.top + le.height - re.height,
    height: re.height
  } : null;
}
function limitCropboxMovementOnResize(le, Y, re) {
  return Y.left < le.left ? {
    left: le.left,
    width: re.left + re.width - le.left
  } : Y.top < le.top ? {
    top: le.top,
    height: re.top + re.height - le.top
  } : Y.left + Y.width > le.left + le.width ? {
    left: re.left,
    width: le.left + le.width - re.left
  } : Y.top + Y.height > le.top + le.height ? {
    top: re.top,
    height: le.top + le.height - re.top
  } : null;
}
let Editor$1 = class extends x {
  constructor(Y) {
    super(Y), this.onRotate90Deg = () => {
      const {
        angle90Deg: re
      } = this.state, oe = re - 90;
      this.setState({
        angle90Deg: oe,
        angleGranular: 0
      }), this.cropper.scale(1), this.cropper.rotateTo(oe);
      const ue = this.cropper.getCanvasData(), fe = this.cropper.getContainerData(), he = getCanvasDataThatFitsPerfectlyIntoContainer(fe, ue);
      this.cropper.setCanvasData(he), this.cropper.setCropBoxData(he);
    }, this.onRotateGranular = (re) => {
      const oe = Number(re.target.value);
      this.setState({
        angleGranular: oe
      });
      const {
        angle90Deg: ue
      } = this.state, fe = ue + oe;
      this.cropper.rotateTo(fe);
      const he = this.cropper.getImageData(), _e = getScaleFactorThatRemovesDarkCorners(he.naturalWidth, he.naturalHeight, oe), ve = this.cropper.getImageData().scaleX < 0 ? -_e : _e;
      this.cropper.scale(ve, _e);
    }, this.state = {
      angle90Deg: 0,
      angleGranular: 0,
      prevCropboxData: null
    }, this.storePrevCropboxData = this.storePrevCropboxData.bind(this), this.limitCropboxMovement = this.limitCropboxMovement.bind(this);
  }
  componentDidMount() {
    const {
      opts: Y,
      storeCropperInstance: re
    } = this.props;
    this.cropper = new Cropper(this.imgElement, Y.cropperOptions), this.imgElement.addEventListener("cropstart", this.storePrevCropboxData), this.imgElement.addEventListener("cropend", this.limitCropboxMovement), re(this.cropper);
  }
  componentWillUnmount() {
    this.cropper.destroy(), this.imgElement.removeEventListener("cropstart", this.storePrevCropboxData), this.imgElement.removeEventListener("cropend", this.limitCropboxMovement);
  }
  // eslint-disable-next-line react/sort-comp
  storePrevCropboxData() {
    this.setState({
      prevCropboxData: this.cropper.getCropBoxData()
    });
  }
  limitCropboxMovement(Y) {
    const re = this.cropper.getCanvasData(), oe = this.cropper.getCropBoxData(), {
      prevCropboxData: ue
    } = this.state;
    if (Y.detail.action === "all") {
      const fe = limitCropboxMovementOnMove(re, oe, ue);
      fe && this.cropper.setCropBoxData(fe);
    } else {
      const fe = limitCropboxMovementOnResize(re, oe, ue);
      fe && this.cropper.setCropBoxData(fe);
    }
  }
  renderGranularRotate() {
    const {
      i18n: Y
    } = this.props, {
      angleGranular: re
    } = this.state;
    return _$1("label", {
      role: "tooltip",
      "aria-label": `${re}º`,
      "data-microtip-position": "top",
      className: "uppy-ImageCropper-rangeWrapper"
    }, _$1("input", {
      className: "uppy-ImageCropper-range uppy-u-reset",
      type: "range",
      onInput: this.onRotateGranular,
      onChange: this.onRotateGranular,
      value: re,
      min: "-45",
      max: "45",
      "aria-label": Y("rotate")
    }));
  }
  renderRevert() {
    const {
      i18n: Y,
      opts: re
    } = this.props;
    return _$1("button", {
      role: "button tooltip",
      "data-microtip-position": "top",
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": Y("revert"),
      onClick: () => {
        this.cropper.reset(), this.cropper.setAspectRatio(re.cropperOptions.initialAspectRatio), this.setState({
          angle90Deg: 0,
          angleGranular: 0
        });
      }
    }, _$1("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, _$1("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), _$1("path", {
      d: "M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"
    })));
  }
  renderRotate() {
    const {
      i18n: Y
    } = this.props;
    return _$1("button", {
      role: "button tooltip",
      "data-microtip-position": "top",
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": Y("rotate"),
      onClick: this.onRotate90Deg
    }, _$1("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, _$1("path", {
      d: "M0 0h24v24H0V0zm0 0h24v24H0V0z",
      fill: "none"
    }), _$1("path", {
      d: "M14 10a2 2 0 012 2v7a2 2 0 01-2 2H6a2 2 0 01-2-2v-7a2 2 0 012-2h8zm0 1.75H6a.25.25 0 00-.243.193L5.75 12v7a.25.25 0 00.193.243L6 19.25h8a.25.25 0 00.243-.193L14.25 19v-7a.25.25 0 00-.193-.243L14 11.75zM12 .76V4c2.3 0 4.61.88 6.36 2.64a8.95 8.95 0 012.634 6.025L21 13a1 1 0 01-1.993.117L19 13h-.003a6.979 6.979 0 00-2.047-4.95 6.97 6.97 0 00-4.652-2.044L12 6v3.24L7.76 5 12 .76z"
    })));
  }
  renderFlip() {
    const {
      i18n: Y
    } = this.props;
    return _$1("button", {
      role: "button tooltip",
      "data-microtip-position": "top",
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": Y("flipHorizontal"),
      onClick: () => this.cropper.scaleX(-this.cropper.getData().scaleX || -1)
    }, _$1("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, _$1("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), _$1("path", {
      d: "M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z"
    })));
  }
  renderZoomIn() {
    const {
      i18n: Y
    } = this.props;
    return _$1("button", {
      role: "button tooltip",
      "data-microtip-position": "top",
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": Y("zoomIn"),
      onClick: () => this.cropper.zoom(0.1)
    }, _$1("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      height: "24",
      viewBox: "0 0 24 24",
      width: "24"
    }, _$1("path", {
      d: "M0 0h24v24H0V0z",
      fill: "none"
    }), _$1("path", {
      d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
    }), _$1("path", {
      d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"
    })));
  }
  renderZoomOut() {
    const {
      i18n: Y
    } = this.props;
    return _$1("button", {
      role: "button tooltip",
      "data-microtip-position": "top",
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": Y("zoomOut"),
      onClick: () => this.cropper.zoom(-0.1)
    }, _$1("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, _$1("path", {
      d: "M0 0h24v24H0V0z",
      fill: "none"
    }), _$1("path", {
      d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z"
    })));
  }
  renderCropSquare() {
    const {
      i18n: Y
    } = this.props;
    return _$1("button", {
      role: "button tooltip",
      "data-microtip-position": "top",
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": Y("aspectRatioSquare"),
      onClick: () => this.cropper.setAspectRatio(1)
    }, _$1("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, _$1("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), _$1("path", {
      d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
    })));
  }
  renderCropWidescreen() {
    const {
      i18n: Y
    } = this.props;
    return _$1("button", {
      role: "button tooltip",
      "data-microtip-position": "top",
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": Y("aspectRatioLandscape"),
      onClick: () => this.cropper.setAspectRatio(16 / 9)
    }, _$1("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, _$1("path", {
      d: "M 19,4.9999992 V 17.000001 H 4.9999998 V 6.9999992 H 19 m 0,-2 H 4.9999998 c -1.0999999,0 -1.9999999,0.9000001 -1.9999999,2 V 17.000001 c 0,1.1 0.9,2 1.9999999,2 H 19 c 1.1,0 2,-0.9 2,-2 V 6.9999992 c 0,-1.0999999 -0.9,-2 -2,-2 z"
    }), _$1("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    })));
  }
  renderCropWidescreenVertical() {
    const {
      i18n: Y
    } = this.props;
    return _$1("button", {
      role: "button tooltip",
      "data-microtip-position": "top",
      type: "button",
      "aria-label": Y("aspectRatioPortrait"),
      className: "uppy-u-reset uppy-c-btn",
      onClick: () => this.cropper.setAspectRatio(9 / 16)
    }, _$1("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, _$1("path", {
      d: "M 19.000001,19 H 6.999999 V 5 h 10.000002 v 14 m 2,0 V 5 c 0,-1.0999999 -0.9,-1.9999999 -2,-1.9999999 H 6.999999 c -1.1,0 -2,0.9 -2,1.9999999 v 14 c 0,1.1 0.9,2 2,2 h 10.000002 c 1.1,0 2,-0.9 2,-2 z"
    }), _$1("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    })));
  }
  render() {
    const {
      currentImage: Y,
      opts: re
    } = this.props, {
      actions: oe
    } = re, ue = URL.createObjectURL(Y.data);
    return _$1("div", {
      className: "uppy-ImageCropper"
    }, _$1("div", {
      className: "uppy-ImageCropper-container"
    }, _$1("img", {
      className: "uppy-ImageCropper-image",
      alt: Y.name,
      src: ue,
      ref: (fe) => {
        this.imgElement = fe;
      }
    })), _$1("div", {
      className: "uppy-ImageCropper-controls"
    }, oe.revert && this.renderRevert(), oe.rotate && this.renderRotate(), oe.granularRotate && this.renderGranularRotate(), oe.flip && this.renderFlip(), oe.zoomIn && this.renderZoomIn(), oe.zoomOut && this.renderZoomOut(), oe.cropSquare && this.renderCropSquare(), oe.cropWidescreen && this.renderCropWidescreen(), oe.cropWidescreenVertical && this.renderCropWidescreenVertical()));
  }
};
const locale = {
  strings: {
    revert: "Reset",
    rotate: "Rotate 90°",
    zoomIn: "Zoom in",
    zoomOut: "Zoom out",
    flipHorizontal: "Flip horizontally",
    aspectRatioSquare: "Crop square",
    aspectRatioLandscape: "Crop landscape (16:9)",
    aspectRatioPortrait: "Crop portrait (9:16)"
  }
}, packageJson = {
  version: "3.3.3"
}, defaultCropperOptions = {
  viewMode: 0,
  background: !1,
  autoCropArea: 1,
  responsive: !0,
  minCropBoxWidth: 70,
  minCropBoxHeight: 70,
  croppedCanvasOptions: {},
  initialAspectRatio: 0
}, defaultActions = {
  revert: !0,
  rotate: !0,
  granularRotate: !0,
  flip: !0,
  zoomIn: !0,
  zoomOut: !0,
  cropSquare: !0,
  cropWidescreen: !0,
  cropWidescreenVertical: !0
}, defaultOptions$1 = {
  // `quality: 1` increases the image size by orders of magnitude - 0.8 seems to be the sweet spot.
  // see https://github.com/fengyuanchen/cropperjs/issues/538#issuecomment-1776279427
  quality: 0.8,
  actions: defaultActions,
  cropperOptions: defaultCropperOptions
};
class ImageEditor extends UIPlugin {
  constructor(Y, re) {
    super(Y, {
      ...defaultOptions$1,
      ...re,
      actions: {
        ...defaultActions,
        ...re?.actions
      },
      cropperOptions: {
        ...defaultCropperOptions,
        ...re?.cropperOptions
      }
    }), this.save = () => {
      const oe = (he) => {
        var _e;
        const {
          currentImage: ve
        } = this.getPluginState();
        this.uppy.setFileState(ve.id, {
          // Reinserting image's name and type, because .toBlob loses both.
          data: new File([he], (_e = ve.name) != null ? _e : this.i18n("unnamed"), {
            type: he.type
          }),
          size: he.size,
          preview: void 0
        });
        const xe = this.uppy.getFile(ve.id);
        this.uppy.emit("thumbnail:request", xe), this.setPluginState({
          currentImage: xe
        }), this.uppy.emit("file-editor:complete", xe);
      }, {
        currentImage: ue
      } = this.getPluginState(), fe = this.cropper.getCroppedCanvas({});
      fe.width % 2 !== 0 && this.cropper.setData({
        width: fe.width - 1
      }), fe.height % 2 !== 0 && this.cropper.setData({
        height: fe.height - 1
      }), this.cropper.getCroppedCanvas(this.opts.cropperOptions.croppedCanvasOptions).toBlob(oe, ue.type, this.opts.quality);
    }, this.storeCropperInstance = (oe) => {
      this.cropper = oe;
    }, this.selectFile = (oe) => {
      this.uppy.emit("file-editor:start", oe), this.setPluginState({
        currentImage: oe
      });
    }, this.id = this.opts.id || "ImageEditor", this.title = "Image Editor", this.type = "editor", this.defaultLocale = locale, this.i18nInit();
  }
  // eslint-disable-next-line class-methods-use-this
  canEditFile(Y) {
    if (!Y.type || Y.isRemote)
      return !1;
    const re = Y.type.split("/")[1];
    return !!/^(jpe?g|gif|png|bmp|webp)$/.test(re);
  }
  install() {
    this.setPluginState({
      currentImage: null
    });
    const {
      target: Y
    } = this.opts;
    Y && this.mount(Y, this);
  }
  uninstall() {
    const {
      currentImage: Y
    } = this.getPluginState();
    if (Y) {
      const re = this.uppy.getFile(Y.id);
      this.uppy.emit("file-editor:cancel", re);
    }
    this.unmount();
  }
  render() {
    const {
      currentImage: Y
    } = this.getPluginState();
    return Y === null || Y.isRemote ? null : _$1(Editor$1, {
      currentImage: Y,
      storeCropperInstance: this.storeCropperInstance,
      save: this.save,
      opts: this.opts,
      i18n: this.i18n
    });
  }
}
ImageEditor.VERSION = packageJson.version;
const uppyCore = ".uppy-Root{box-sizing:border-box;color:#333;font-family:-apple-system,system-ui,BlinkMacSystemFont,Segoe UI,Segoe UI Symbol,Segoe UI Emoji,Apple Color Emoji,Roboto,Helvetica,Arial,sans-serif;line-height:1;position:relative;text-align:left;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.uppy-Root[dir=rtl],[dir=rtl] .uppy-Root{text-align:right}.uppy-Root *,.uppy-Root :after,.uppy-Root :before{box-sizing:inherit}.uppy-Root [hidden]{display:none}.uppy-u-reset{all:initial;-webkit-appearance:none;appearance:none;box-sizing:border-box;font-family:-apple-system,system-ui,BlinkMacSystemFont,Segoe UI,Segoe UI Symbol,Segoe UI Emoji,Apple Color Emoji,Roboto,Helvetica,Arial,sans-serif;line-height:1}[dir=rtl] .uppy-u-reset{text-align:right}.uppy-c-textInput{background-color:#fff;border:1px solid #ddd;border-radius:4px;font-family:inherit;font-size:14px;line-height:1.5;padding:6px 8px}.uppy-size--md .uppy-c-textInput{padding:8px 10px}.uppy-c-textInput:focus{border-color:#1269cf99;box-shadow:0 0 0 3px #1269cf26;outline:none}[data-uppy-theme=dark] .uppy-c-textInput{background-color:#333;border-color:#333;color:#eaeaea}[data-uppy-theme=dark] .uppy-c-textInput:focus{border-color:#525252;box-shadow:none}.uppy-c-icon{display:inline-block;max-height:100%;max-width:100%;overflow:hidden;fill:currentColor}.uppy-c-btn{align-items:center;color:inherit;display:inline-flex;font-family:inherit;font-size:inherit;font-weight:500;justify-content:center;line-height:1;transition-duration:.3s;transition-property:background-color,color;-webkit-user-select:none;user-select:none;white-space:nowrap}.uppy-c-btn,[dir=rtl] .uppy-c-btn{text-align:center}.uppy-c-btn:not(:disabled):not(.disabled){cursor:pointer}.uppy-c-btn::-moz-focus-inner{border:0}.uppy-c-btn-primary{background-color:#1269cf;border-radius:4px;color:#fff;font-size:14px;padding:10px 18px}.uppy-c-btn-primary:not(:disabled):hover{background-color:#0e51a0}.uppy-c-btn-primary:focus{box-shadow:0 0 0 3px #1269cf66;outline:none}.uppy-size--md .uppy-c-btn-primary{padding:13px 22px}[data-uppy-theme=dark] .uppy-c-btn-primary{color:#eaeaea}[data-uppy-theme=dark] .uppy-c-btn-primary:focus{outline:none}[data-uppy-theme=dark] .uppy-c-btn-primary::-moz-focus-inner{border:0}[data-uppy-theme=dark] .uppy-c-btn-primary:focus{box-shadow:0 0 0 2px #aae1ffd9}.uppy-c-btn-primary.uppy-c-btn--disabled{background-color:#8eb2db}.uppy-c-btn-link{background-color:initial;border-radius:4px;color:#525252;font-size:14px;line-height:1;padding:10px 15px}.uppy-c-btn-link:hover{color:#333}.uppy-c-btn-link:focus{box-shadow:0 0 0 3px #1269cf40;outline:none}.uppy-size--md .uppy-c-btn-link{padding:13px 18px}[data-uppy-theme=dark] .uppy-c-btn-link{color:#eaeaea}[data-uppy-theme=dark] .uppy-c-btn-link:focus{outline:none}[data-uppy-theme=dark] .uppy-c-btn-link::-moz-focus-inner{border:0}[data-uppy-theme=dark] .uppy-c-btn-link:focus{box-shadow:0 0 0 2px #aae1ffd9}[data-uppy-theme=dark] .uppy-c-btn-link:hover{color:#939393}", uppyDashboard = `@charset "UTF-8";.uppy-Informer{bottom:60px;left:0;position:absolute;right:0;text-align:center;z-index:1005}.uppy-Informer span>div{margin-bottom:6px}.uppy-Informer-animated{opacity:0;transform:translateY(350%);transition:all .3s ease-in;z-index:-1000}.uppy-Informer p{background-color:#757575;border-radius:18px;color:#fff;display:inline-block;font-size:12px;font-weight:400;line-height:1.4;margin:0;max-width:90%;padding:6px 15px}.uppy-size--md .uppy-Informer p{font-size:14px;line-height:1.3;max-width:500px;padding:10px 20px}[data-uppy-theme=dark] .uppy-Informer p{background-color:#333}[dir=ltr] .uppy-Informer p span{left:3px}[dir=rtl] .uppy-Informer p span{right:3px}[dir=ltr] .uppy-Informer p span{margin-left:-1px}[dir=rtl] .uppy-Informer p span{margin-right:-1px}.uppy-Informer p span{background-color:#fff;border-radius:50%;color:#525252;display:inline-block;font-size:10px;height:13px;line-height:12px;position:relative;top:-1px;vertical-align:middle;width:13px}.uppy-Informer p span:hover{cursor:help}.uppy-Informer p span:after{line-height:1.3;word-wrap:break-word}.uppy-Root [aria-label][role~=tooltip]{position:relative}.uppy-Root [aria-label][role~=tooltip]:after,.uppy-Root [aria-label][role~=tooltip]:before{-webkit-backface-visibility:hidden;backface-visibility:hidden;box-sizing:border-box;opacity:0;pointer-events:none;position:absolute;transform:translateZ(0);transform-origin:top;transition:all var(--microtip-transition-duration,.18s) var(--microtip-transition-easing,ease-in-out) var(--microtip-transition-delay,0s);will-change:transform;z-index:10}.uppy-Root [aria-label][role~=tooltip]:before{background-size:100% auto!important;content:""}.uppy-Root [aria-label][role~=tooltip]:after{background:#111111e6;border-radius:4px;box-sizing:initial;color:#fff;content:attr(aria-label);font-size:var(--microtip-font-size,13px);font-weight:var(--microtip-font-weight,normal);padding:.5em 1em;text-transform:var(--microtip-text-transform,none);white-space:nowrap}.uppy-Root [aria-label][role~=tooltip]:focus:after,.uppy-Root [aria-label][role~=tooltip]:focus:before,.uppy-Root [aria-label][role~=tooltip]:hover:after,.uppy-Root [aria-label][role~=tooltip]:hover:before{opacity:1;pointer-events:auto}.uppy-Root [role~=tooltip][data-microtip-position|=top]:before{background:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='36' height='12'%3E%3Cpath fill='rgba(17, 17, 17, 0.9)' d='M2.658 0h32.004c-6 0-11.627 12.002-16.002 12.002S8.594 0 2.658 0'/%3E%3C/svg%3E") no-repeat;bottom:100%;height:6px;left:50%;margin-bottom:5px;transform:translate3d(-50%,0,0);width:18px}.uppy-Root [role~=tooltip][data-microtip-position|=top]:after{bottom:100%;left:50%;margin-bottom:11px;transform:translate3d(-50%,0,0)}.uppy-Root [role~=tooltip][data-microtip-position=top]:hover:after,.uppy-Root [role~=tooltip][data-microtip-position|=top]:hover:before{transform:translate3d(-50%,-5px,0)}.uppy-Root [role~=tooltip][data-microtip-position=top-left]:after{bottom:100%;transform:translate3d(calc(-100% + 16px),0,0)}.uppy-Root [role~=tooltip][data-microtip-position=top-left]:hover:after{transform:translate3d(calc(-100% + 16px),-5px,0)}.uppy-Root [role~=tooltip][data-microtip-position=top-right]:after{bottom:100%;transform:translate3d(-16px,0,0)}.uppy-Root [role~=tooltip][data-microtip-position=top-right]:hover:after{transform:translate3d(-16px,-5px,0)}.uppy-Root [role~=tooltip][data-microtip-position|=bottom]:before{background:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='36' height='12'%3E%3Cpath fill='rgba(17, 17, 17, 0.9)' d='M33.342 12H1.338c6 0 11.627-12.002 16.002-12.002S27.406 12 33.342 12'/%3E%3C/svg%3E") no-repeat;bottom:auto;height:6px;left:50%;margin-bottom:0;margin-top:5px;top:100%;transform:translate3d(-50%,-10px,0);width:18px}.uppy-Root [role~=tooltip][data-microtip-position|=bottom]:after{left:50%;margin-top:11px;top:100%;transform:translate3d(-50%,-10px,0)}.uppy-Root [role~=tooltip][data-microtip-position=bottom]:hover:after,.uppy-Root [role~=tooltip][data-microtip-position|=bottom]:hover:before{transform:translate3d(-50%,0,0)}.uppy-Root [role~=tooltip][data-microtip-position=bottom-left]:after{top:100%;transform:translate3d(calc(-100% + 16px),-10px,0)}.uppy-Root [role~=tooltip][data-microtip-position=bottom-left]:hover:after{transform:translate3d(calc(-100% + 16px),0,0)}.uppy-Root [role~=tooltip][data-microtip-position=bottom-right]:after{top:100%;transform:translate3d(-16px,-10px,0)}.uppy-Root [role~=tooltip][data-microtip-position=bottom-right]:hover:after{transform:translate3d(-16px,0,0)}.uppy-Root [role~=tooltip][data-microtip-position=left]:after,.uppy-Root [role~=tooltip][data-microtip-position=left]:before{inset:50% 100% auto auto;transform:translate3d(10px,-50%,0)}.uppy-Root [role~=tooltip][data-microtip-position=left]:before{background:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='36'%3E%3Cpath fill='rgba(17, 17, 17, 0.9)' d='M0 33.342V1.338c0 6 12.002 11.627 12.002 16.002S0 27.406 0 33.342'/%3E%3C/svg%3E") no-repeat;height:18px;margin-bottom:0;margin-right:5px;width:6px}.uppy-Root [role~=tooltip][data-microtip-position=left]:after{margin-right:11px}.uppy-Root [role~=tooltip][data-microtip-position=left]:hover:after,.uppy-Root [role~=tooltip][data-microtip-position=left]:hover:before{transform:translate3d(0,-50%,0)}.uppy-Root [role~=tooltip][data-microtip-position=right]:after,.uppy-Root [role~=tooltip][data-microtip-position=right]:before{bottom:auto;left:100%;top:50%;transform:translate3d(-10px,-50%,0)}.uppy-Root [role~=tooltip][data-microtip-position=right]:before{background:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='36'%3E%3Cpath fill='rgba(17, 17, 17, 0.9)' d='M12 2.658v32.004c0-6-12.002-11.627-12.002-16.002S12 8.594 12 2.658'/%3E%3C/svg%3E") no-repeat;height:18px;margin-bottom:0;margin-left:5px;width:6px}.uppy-Root [role~=tooltip][data-microtip-position=right]:after{margin-left:11px}.uppy-Root [role~=tooltip][data-microtip-position=right]:hover:after,.uppy-Root [role~=tooltip][data-microtip-position=right]:hover:before{transform:translate3d(0,-50%,0)}.uppy-Root [role~=tooltip][data-microtip-size=small]:after{white-space:normal;width:80px}.uppy-Root [role~=tooltip][data-microtip-size=medium]:after{white-space:normal;width:150px}.uppy-Root [role~=tooltip][data-microtip-size=large]:after{white-space:normal;width:260px}.uppy-StatusBar{background-color:#fff;color:#fff;display:flex;font-size:12px;font-weight:400;height:46px;line-height:40px;position:relative;transition:height .2s;z-index:1001}[data-uppy-theme=dark] .uppy-StatusBar{background-color:#1f1f1f}.uppy-StatusBar:before{background-color:#eaeaea;content:"";height:2px;inset:0;position:absolute;width:100%}[data-uppy-theme=dark] .uppy-StatusBar:before{background-color:#757575}.uppy-StatusBar[aria-hidden=true]{height:0;overflow-y:hidden}.uppy-StatusBar.is-complete .uppy-StatusBar-progress{background-color:#1bb240}.uppy-StatusBar.is-error .uppy-StatusBar-progress{background-color:#e32437}.uppy-StatusBar.is-complete .uppy-StatusBar-statusIndicator{color:#1bb240}.uppy-StatusBar.is-error .uppy-StatusBar-statusIndicator{color:#e32437}.uppy-StatusBar:not([aria-hidden=true]).is-waiting{background-color:#fff;border-top:1px solid #eaeaea;height:65px}[data-uppy-theme=dark] .uppy-StatusBar:not([aria-hidden=true]).is-waiting{background-color:#1f1f1f;border-top:1px solid #333}.uppy-StatusBar-progress{background-color:#1269cf;height:2px;position:absolute;transition:background-color,width .3s ease-out;z-index:1001}.uppy-StatusBar-progress.is-indeterminate{animation:uppy-StatusBar-ProgressStripes 1s linear infinite;background-image:linear-gradient(45deg,#0000004d 25%,#0000 0 50%,#0000004d 0 75%,#0000 0,#0000);background-size:64px 64px}@keyframes uppy-StatusBar-ProgressStripes{0%{background-position:0 0}to{background-position:64px 0}}.uppy-StatusBar.is-postprocessing .uppy-StatusBar-progress,.uppy-StatusBar.is-preprocessing .uppy-StatusBar-progress{background-color:#f6a623}.uppy-StatusBar.is-waiting .uppy-StatusBar-progress{display:none}[dir=ltr] .uppy-StatusBar-content{padding-left:10px}[dir=rtl] .uppy-StatusBar-content{padding-right:10px}.uppy-StatusBar-content{align-items:center;color:#333;display:flex;height:100%;position:relative;text-overflow:ellipsis;white-space:nowrap;z-index:1002}[dir=ltr] .uppy-size--md .uppy-StatusBar-content{padding-left:15px}[dir=rtl] .uppy-size--md .uppy-StatusBar-content{padding-right:15px}[data-uppy-theme=dark] .uppy-StatusBar-content{color:#eaeaea}[dir=ltr] .uppy-StatusBar-status{padding-right:.3em}[dir=rtl] .uppy-StatusBar-status{padding-left:.3em}.uppy-StatusBar-status{display:flex;flex-direction:column;font-weight:400;justify-content:center;line-height:1.4}.uppy-StatusBar-statusPrimary{display:flex;font-weight:500;line-height:1}.uppy-StatusBar-statusPrimary button.uppy-StatusBar-details{margin-left:5px}[data-uppy-theme=dark] .uppy-StatusBar-statusPrimary{color:#eaeaea}.uppy-StatusBar-statusSecondary{color:#757575;display:inline-block;font-size:11px;line-height:1.2;margin-top:1px;white-space:nowrap}[data-uppy-theme=dark] .uppy-StatusBar-statusSecondary{color:#bbb}[dir=ltr] .uppy-StatusBar-statusSecondaryHint{margin-right:5px}[dir=rtl] .uppy-StatusBar-statusSecondaryHint{margin-left:5px}.uppy-StatusBar-statusSecondaryHint{display:inline-block;line-height:1;vertical-align:middle}[dir=ltr] .uppy-size--md .uppy-StatusBar-statusSecondaryHint{margin-right:8px}[dir=rtl] .uppy-size--md .uppy-StatusBar-statusSecondaryHint{margin-left:8px}[dir=ltr] .uppy-StatusBar-statusIndicator{margin-right:7px}[dir=rtl] .uppy-StatusBar-statusIndicator{margin-left:7px}.uppy-StatusBar-statusIndicator{color:#525252;position:relative;top:1px}.uppy-StatusBar-statusIndicator svg{vertical-align:text-bottom}[dir=ltr] .uppy-StatusBar-actions{right:10px}[dir=rtl] .uppy-StatusBar-actions{left:10px}.uppy-StatusBar-actions{align-items:center;bottom:0;display:flex;position:absolute;top:0;z-index:1004}.uppy-StatusBar.is-waiting .uppy-StatusBar-actions{background-color:#fafafa;height:100%;padding:0 15px;position:static;width:100%}[data-uppy-theme=dark] .uppy-StatusBar.is-waiting .uppy-StatusBar-actions{background-color:#1f1f1f}.uppy-StatusBar:not([aria-hidden=true]).is-waiting.has-ghosts{flex-direction:column;height:90px}.uppy-size--md .uppy-StatusBar:not([aria-hidden=true]).is-waiting.has-ghosts{flex-direction:row;height:65px}.uppy-StatusBar:not([aria-hidden=true]).is-waiting.has-ghosts .uppy-StatusBar-actions{flex-direction:column;justify-content:center}.uppy-size--md .uppy-StatusBar:not([aria-hidden=true]).is-waiting.has-ghosts .uppy-StatusBar-actions{flex-direction:row;justify-content:normal}.uppy-StatusBar-actionCircleBtn{cursor:pointer;line-height:1;margin:3px;opacity:.9}.uppy-StatusBar-actionCircleBtn:focus{outline:none}.uppy-StatusBar-actionCircleBtn::-moz-focus-inner{border:0}.uppy-StatusBar-actionCircleBtn:focus{box-shadow:0 0 0 3px #1269cf80}[data-uppy-theme=dark] .uppy-StatusBar-actionCircleBtn:focus{outline:none}[data-uppy-theme=dark] .uppy-StatusBar-actionCircleBtn::-moz-focus-inner{border:0}[data-uppy-theme=dark] .uppy-StatusBar-actionCircleBtn:focus{box-shadow:0 0 0 2px #aae1ffd9}.uppy-StatusBar-actionCircleBtn:hover{opacity:1}.uppy-StatusBar-actionCircleBtn:focus{border-radius:50%}.uppy-StatusBar-actionCircleBtn svg{vertical-align:bottom}.uppy-StatusBar-actionBtn{color:#1269cf;display:inline-block;font-size:10px;line-height:inherit;vertical-align:middle}.uppy-size--md .uppy-StatusBar-actionBtn{font-size:11px}.uppy-StatusBar-actionBtn--disabled{opacity:.4}[data-uppy-theme=dark] .uppy-StatusBar-actionBtn--disabled{opacity:.7}[dir=ltr] .uppy-StatusBar-actionBtn--retry{margin-right:6px}[dir=rtl] .uppy-StatusBar-actionBtn--retry{margin-left:6px}.uppy-StatusBar-actionBtn--retry{background-color:#ff4b23;border-radius:8px;color:#fff;height:16px;line-height:1;padding:1px 6px 3px 18px;position:relative}.uppy-StatusBar-actionBtn--retry:focus{outline:none}.uppy-StatusBar-actionBtn--retry::-moz-focus-inner{border:0}.uppy-StatusBar-actionBtn--retry:focus{box-shadow:0 0 0 3px #1269cf80}[data-uppy-theme=dark] .uppy-StatusBar-actionBtn--retry:focus{outline:none}[data-uppy-theme=dark] .uppy-StatusBar-actionBtn--retry::-moz-focus-inner{border:0}[data-uppy-theme=dark] .uppy-StatusBar-actionBtn--retry:focus{box-shadow:0 0 0 2px #aae1ffd9}.uppy-StatusBar-actionBtn--retry:hover{background-color:#f92d00}[dir=ltr] .uppy-StatusBar-actionBtn--retry svg{left:6px}[dir=rtl] .uppy-StatusBar-actionBtn--retry svg{right:6px}.uppy-StatusBar-actionBtn--retry svg{position:absolute;top:3px}.uppy-StatusBar.is-waiting .uppy-StatusBar-actionBtn--upload{background-color:#1bb240;color:#fff;font-size:14px;line-height:1;padding:15px 10px;width:100%}.uppy-StatusBar.is-waiting .uppy-StatusBar-actionBtn--upload:hover{background-color:#189c38}[data-uppy-theme=dark] .uppy-StatusBar.is-waiting .uppy-StatusBar-actionBtn--upload{background-color:#1c8b37}[data-uppy-theme=dark] .uppy-StatusBar.is-waiting .uppy-StatusBar-actionBtn--upload:hover{background-color:#18762f}.uppy-size--md .uppy-StatusBar.is-waiting .uppy-StatusBar-actionBtn--upload{padding:13px 22px;width:auto}.uppy-StatusBar.is-waiting .uppy-StatusBar-actionBtn--upload.uppy-StatusBar-actionBtn--disabled:hover{background-color:#1bb240;cursor:not-allowed}[data-uppy-theme=dark] .uppy-StatusBar.is-waiting .uppy-StatusBar-actionBtn--upload.uppy-StatusBar-actionBtn--disabled:hover{background-color:#1c8b37}.uppy-StatusBar:not(.is-waiting) .uppy-StatusBar-actionBtn--upload{background-color:initial;color:#1269cf}[dir=ltr] .uppy-StatusBar-actionBtn--uploadNewlyAdded{padding-right:3px}[dir=ltr] .uppy-StatusBar-actionBtn--uploadNewlyAdded,[dir=rtl] .uppy-StatusBar-actionBtn--uploadNewlyAdded{padding-left:3px}[dir=rtl] .uppy-StatusBar-actionBtn--uploadNewlyAdded{padding-right:3px}.uppy-StatusBar-actionBtn--uploadNewlyAdded{border-radius:3px;padding-bottom:1px}.uppy-StatusBar-actionBtn--uploadNewlyAdded:focus{outline:none}.uppy-StatusBar-actionBtn--uploadNewlyAdded::-moz-focus-inner{border:0}.uppy-StatusBar-actionBtn--uploadNewlyAdded:focus{box-shadow:0 0 0 3px #1269cf80}[data-uppy-theme=dark] .uppy-StatusBar-actionBtn--uploadNewlyAdded:focus{outline:none}[data-uppy-theme=dark] .uppy-StatusBar-actionBtn--uploadNewlyAdded::-moz-focus-inner{border:0}[data-uppy-theme=dark] .uppy-StatusBar-actionBtn--uploadNewlyAdded:focus{box-shadow:0 0 0 2px #aae1ffd9}.uppy-StatusBar.is-postprocessing .uppy-StatusBar-actionBtn--uploadNewlyAdded,.uppy-StatusBar.is-preprocessing .uppy-StatusBar-actionBtn--uploadNewlyAdded{display:none}.uppy-StatusBar-actionBtn--done{border-radius:3px;line-height:1;padding:7px 8px}.uppy-StatusBar-actionBtn--done:focus{outline:none}.uppy-StatusBar-actionBtn--done::-moz-focus-inner{border:0}.uppy-StatusBar-actionBtn--done:hover{color:#0e51a0}.uppy-StatusBar-actionBtn--done:focus{background-color:#dfe6f1}[data-uppy-theme=dark] .uppy-StatusBar-actionBtn--done:focus{background-color:#333}[data-uppy-theme=dark] .uppy-StatusBar-actionBtn--done{color:#02baf2}.uppy-size--md .uppy-StatusBar-actionBtn--done{font-size:14px}.uppy-StatusBar-serviceMsg{color:#000;font-size:11px;line-height:1.1;padding-left:10px}.uppy-size--md .uppy-StatusBar-serviceMsg{font-size:14px;padding-left:15px}[data-uppy-theme=dark] .uppy-StatusBar-serviceMsg{color:#eaeaea}.uppy-StatusBar-serviceMsg-ghostsIcon{left:6px;opacity:.5;position:relative;top:2px;vertical-align:text-bottom;width:10px}.uppy-size--md .uppy-StatusBar-serviceMsg-ghostsIcon{left:10px;top:1px;width:15px}[dir=ltr] .uppy-StatusBar-details{left:2px}[dir=rtl] .uppy-StatusBar-details{right:2px}.uppy-StatusBar-details{-webkit-appearance:none;appearance:none;background-color:#939393;border-radius:50%;color:#fff;cursor:help;display:inline-block;font-size:10px;font-weight:600;height:13px;line-height:12px;position:relative;text-align:center;top:0;vertical-align:middle;width:13px}.uppy-StatusBar-details:after{line-height:1.3;word-wrap:break-word}[dir=ltr] .uppy-StatusBar-spinner{margin-right:10px}[dir=rtl] .uppy-StatusBar-spinner{margin-left:10px}.uppy-StatusBar-spinner{animation-duration:1s;animation-iteration-count:infinite;animation-name:uppy-StatusBar-spinnerAnimation;animation-timing-function:linear;fill:#1269cf}.uppy-StatusBar.is-postprocessing .uppy-StatusBar-spinner,.uppy-StatusBar.is-preprocessing .uppy-StatusBar-spinner{fill:#f6a623}@keyframes uppy-StatusBar-spinnerAnimation{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.uppy-ProviderBrowser-viewType--grid ul.uppy-ProviderBrowser-list,.uppy-ProviderBrowser-viewType--unsplash ul.uppy-ProviderBrowser-list{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:wrap;justify-content:space-between;padding:6px}.uppy-ProviderBrowser-viewType--grid ul.uppy-ProviderBrowser-list:after,.uppy-ProviderBrowser-viewType--unsplash ul.uppy-ProviderBrowser-list:after{content:"";flex:auto}.uppy-ProviderBrowser-viewType--grid li.uppy-ProviderBrowserItem,.uppy-ProviderBrowser-viewType--unsplash li.uppy-ProviderBrowserItem{margin:0;position:relative;width:50%}.uppy-size--md .uppy-ProviderBrowser-viewType--grid li.uppy-ProviderBrowserItem,.uppy-size--md .uppy-ProviderBrowser-viewType--unsplash li.uppy-ProviderBrowserItem{width:33.3333%}.uppy-size--lg .uppy-ProviderBrowser-viewType--grid li.uppy-ProviderBrowserItem,.uppy-size--lg .uppy-ProviderBrowser-viewType--unsplash li.uppy-ProviderBrowserItem{width:25%}.uppy-ProviderBrowser-viewType--grid li.uppy-ProviderBrowserItem:before,.uppy-ProviderBrowser-viewType--unsplash li.uppy-ProviderBrowserItem:before{content:"";display:block;padding-top:100%}.uppy-ProviderBrowser-viewType--grid li.uppy-ProviderBrowserItem--selected img,.uppy-ProviderBrowser-viewType--grid li.uppy-ProviderBrowserItem--selected svg,.uppy-ProviderBrowser-viewType--unsplash li.uppy-ProviderBrowserItem--selected img,.uppy-ProviderBrowser-viewType--unsplash li.uppy-ProviderBrowserItem--selected svg{opacity:.85}.uppy-ProviderBrowser-viewType--grid li.uppy-ProviderBrowserItem--disabled,.uppy-ProviderBrowser-viewType--unsplash li.uppy-ProviderBrowserItem--disabled{opacity:.5}.uppy-ProviderBrowser-viewType--grid li.uppy-ProviderBrowserItem--noPreview .uppy-ProviderBrowserItem-inner,.uppy-ProviderBrowser-viewType--unsplash li.uppy-ProviderBrowserItem--noPreview .uppy-ProviderBrowserItem-inner{background-color:#93939333}[data-uppy-theme=dark] .uppy-ProviderBrowser-viewType--grid li.uppy-ProviderBrowserItem--noPreview .uppy-ProviderBrowserItem-inner,[data-uppy-theme=dark] .uppy-ProviderBrowser-viewType--unsplash li.uppy-ProviderBrowserItem--noPreview .uppy-ProviderBrowserItem-inner{background-color:#eaeaea33}.uppy-ProviderBrowser-viewType--grid li.uppy-ProviderBrowserItem--noPreview svg,.uppy-ProviderBrowser-viewType--unsplash li.uppy-ProviderBrowserItem--noPreview svg{height:30%;width:30%;fill:#000000b3}[data-uppy-theme=dark] .uppy-ProviderBrowser-viewType--grid li.uppy-ProviderBrowserItem--noPreview svg,[data-uppy-theme=dark] .uppy-ProviderBrowser-viewType--unsplash li.uppy-ProviderBrowserItem--noPreview svg{fill:#fffc}.uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-inner,.uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-inner{border-radius:4px;height:calc(100% - 14px);inset:7px;overflow:hidden;position:absolute;text-align:center;width:calc(100% - 14px)}@media (hover:none){.uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-inner .uppy-ProviderBrowserItem-author,.uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-inner .uppy-ProviderBrowserItem-author{display:block}}[data-uppy-theme=dark] .uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-inner,[data-uppy-theme=dark] .uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-inner{box-shadow:0 0 0 3px #aae1ffb3}.uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-inner img,.uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-inner img{border-radius:4px;height:100%;object-fit:cover;width:100%}.uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-author,.uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-author{background:#0000004d;bottom:0;color:#fff;display:none;font-size:12px;font-weight:500;left:0;margin:0;padding:5px;position:absolute;text-decoration:none;width:100%}.uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-author:hover,.uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-author:hover{background:#0006;text-decoration:underline}.uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-checkbox,.uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-checkbox{background-color:#1269cf;border-radius:50%;height:26px;opacity:0;position:absolute;right:16px;top:16px;width:26px;z-index:1002}[dir=ltr] .uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-checkbox:after,[dir=ltr] .uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-checkbox:after{left:7px}[dir=rtl] .uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-checkbox:after,[dir=rtl] .uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-checkbox:after{right:7px}.uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-checkbox:after,.uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-checkbox:after{height:7px;top:8px;width:12px}.uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem--is-checked .uppy-ProviderBrowserItem-checkbox,.uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem--is-checked .uppy-ProviderBrowserItem-checkbox{opacity:1}.uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-checkbox--grid:focus+label .uppy-ProviderBrowserItem-author,.uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-checkbox--grid:hover+label .uppy-ProviderBrowserItem-author,.uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-checkbox--grid:focus+label .uppy-ProviderBrowserItem-author,.uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-checkbox--grid:hover+label .uppy-ProviderBrowserItem-author{display:block}.uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-checkbox--grid:focus+label,.uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-checkbox--grid:focus+label{box-shadow:0 0 0 3px #1269cf80}.uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-checkbox--grid:focus+label:focus,.uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-checkbox--grid:focus+label:focus{outline:none}.uppy-ProviderBrowser-viewType--grid .uppy-ProviderBrowserItem-checkbox--grid:focus+label::-moz-focus-inner,.uppy-ProviderBrowser-viewType--unsplash .uppy-ProviderBrowserItem-checkbox--grid:focus+label::-moz-focus-inner{border:0}.uppy-ProviderBrowser-viewType--list{background-color:#fff}[data-uppy-theme=dark] .uppy-ProviderBrowser-viewType--list{background-color:#1f1f1f}.uppy-ProviderBrowser-viewType--list li.uppy-ProviderBrowserItem{align-items:center;display:flex;margin:0;padding:7px 15px}[data-uppy-theme=dark] .uppy-ProviderBrowser-viewType--list li.uppy-ProviderBrowserItem{color:#eaeaea}.uppy-ProviderBrowser-viewType--list li.uppy-ProviderBrowserItem--disabled{opacity:.6}[dir=ltr] .uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-checkbox{margin-right:15px}[dir=rtl] .uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-checkbox{margin-left:15px}.uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-checkbox{background-color:#fff;border:1px solid #cfcfcf;border-radius:3px;height:17px;width:17px}.uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-checkbox:focus{border:1px solid #1269cf;box-shadow:0 0 0 3px #1269cf40;outline:none}[dir=ltr] .uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-checkbox:after{left:3px}[dir=rtl] .uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-checkbox:after{right:3px}.uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-checkbox:after{height:5px;opacity:0;top:4px;width:9px}[data-uppy-theme=dark] .uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-checkbox:focus{border-color:#02baf2b3;box-shadow:0 0 0 3px #02baf233}.uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem--is-checked .uppy-ProviderBrowserItem-checkbox,.uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem--is-partial .uppy-ProviderBrowserItem-checkbox{background-color:#1269cf;border-color:#1269cf}.uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem--is-checked .uppy-ProviderBrowserItem-checkbox:after,.uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem--is-partial .uppy-ProviderBrowserItem-checkbox:after{opacity:1}.uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-inner{align-items:center;color:inherit;display:flex;font-family:-apple-system,system-ui,BlinkMacSystemFont,Segoe UI,Segoe UI Symbol,Segoe UI Emoji,Apple Color Emoji,Roboto,Helvetica,Arial,sans-serif;overflow:hidden;padding:2px;text-overflow:ellipsis;white-space:nowrap}.uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-inner:focus{outline:none;text-decoration:underline}[dir=ltr] .uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-inner img,[dir=ltr] .uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-inner svg{margin-right:8px}[dir=rtl] .uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-inner img,[dir=rtl] .uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-inner svg{margin-left:8px}.uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-inner span{line-height:1.2;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem--disabled .uppy-ProviderBrowserItem-inner{cursor:default}[dir=ltr] .uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-iconWrap{margin-right:7px}[dir=rtl] .uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-iconWrap{margin-left:7px}.uppy-ProviderBrowser-viewType--list .uppy-ProviderBrowserItem-iconWrap{width:20px}.uppy-ProviderBrowserItem-checkbox{cursor:pointer;flex-shrink:0;position:relative}.uppy-ProviderBrowserItem-checkbox:disabled,.uppy-ProviderBrowserItem-checkbox:disabled:after{cursor:default}[data-uppy-theme=dark] .uppy-ProviderBrowserItem-checkbox{background-color:#1f1f1f;border-color:#939393}[data-uppy-theme=dark] .uppy-ProviderBrowserItem--is-checked .uppy-ProviderBrowserItem-checkbox{background-color:#333}.uppy-ProviderBrowserItem--is-checked .uppy-ProviderBrowserItem-checkbox:after{border-bottom:2px solid #eaeaea;border-left:2px solid #eaeaea;content:"";cursor:pointer;position:absolute;transform:rotate(-45deg)}.uppy-ProviderBrowserItem--is-partial .uppy-ProviderBrowserItem-checkbox:after{background-color:#eaeaea!important;content:""!important;height:2px!important;left:20%!important;position:absolute!important;right:20%!important;top:50%!important;transform:translateY(-50%)!important}.uppy-SearchProvider{align-items:center;display:flex;flex:1;flex-direction:column;height:100%;justify-content:center;width:100%}[data-uppy-theme=dark] .uppy-SearchProvider{background-color:#1f1f1f}.uppy-SearchProvider-input{margin-bottom:15px;max-width:650px;width:90%}.uppy-size--md .uppy-SearchProvider-input{margin-bottom:20px}.uppy-SearchProvider-input::-webkit-search-cancel-button{display:none}.uppy-SearchProvider-searchButton{padding:13px 25px}.uppy-size--md .uppy-SearchProvider-searchButton{padding:13px 30px}.uppy-DashboardContent-panelBody{align-items:center;display:flex;flex:1;justify-content:center}[data-uppy-theme=dark] .uppy-DashboardContent-panelBody{background-color:#1f1f1f}.uppy-Provider-auth,.uppy-Provider-empty,.uppy-Provider-error,.uppy-Provider-loading{align-items:center;color:#939393;display:flex;flex:1;flex-flow:column wrap;justify-content:center}.uppy-Provider-empty{color:#939393}.uppy-Provider-authIcon svg{height:75px;width:100px}.uppy-Provider-authTitle{color:#757575;font-size:17px;font-weight:400;line-height:1.4;margin-bottom:30px;max-width:500px;padding:0 15px;text-align:center}.uppy-size--md .uppy-Provider-authTitle{font-size:20px}[data-uppy-theme=dark] .uppy-Provider-authTitle{color:#cfcfcf}.uppy-Provider-btn-google{align-items:center;background:#4285f4;display:flex;padding:8px 12px!important}.uppy-Provider-btn-google:hover{background-color:#1266f1}.uppy-Provider-btn-google:focus{box-shadow:0 0 0 3px #4285f466;outline:none}.uppy-Provider-btn-google svg{margin-right:8px}[dir=ltr] .uppy-Provider-breadcrumbs{text-align:left}[dir=rtl] .uppy-Provider-breadcrumbs{text-align:right}.uppy-Provider-breadcrumbs{color:#525252;flex:1;font-size:12px;margin-bottom:10px}.uppy-size--md .uppy-Provider-breadcrumbs{margin-bottom:0}[data-uppy-theme=dark] .uppy-Provider-breadcrumbs{color:#eaeaea}[dir=ltr] .uppy-Provider-breadcrumbsIcon{margin-right:4px}[dir=rtl] .uppy-Provider-breadcrumbsIcon{margin-left:4px}.uppy-Provider-breadcrumbsIcon{color:#525252;display:inline-block;line-height:1;vertical-align:middle}.uppy-Provider-breadcrumbsIcon svg{height:13px;width:13px;fill:#525252}.uppy-Provider-breadcrumbs button{border-radius:3px;display:inline-block;line-height:inherit;padding:4px}.uppy-Provider-breadcrumbs button:focus{outline:none}.uppy-Provider-breadcrumbs button::-moz-focus-inner{border:0}.uppy-Provider-breadcrumbs button:hover{color:#0e51a0}.uppy-Provider-breadcrumbs button:focus{background-color:#dfe6f1}[data-uppy-theme=dark] .uppy-Provider-breadcrumbs button:focus{background-color:#333}.uppy-Provider-breadcrumbs button:not(:last-of-type){text-decoration:underline}.uppy-Provider-breadcrumbs button:last-of-type{color:#333;cursor:normal;font-weight:500;pointer-events:none}.uppy-Provider-breadcrumbs button:hover{cursor:pointer}[data-uppy-theme=dark] .uppy-Provider-breadcrumbs button{color:#eaeaea}.uppy-ProviderBrowser{display:flex;flex:1;flex-direction:column;font-size:14px;font-weight:400;height:100%}.uppy-ProviderBrowser-user{color:#333;font-weight:500;margin:0 8px 0 0}[data-uppy-theme=dark] .uppy-ProviderBrowser-user{color:#eaeaea}[dir=ltr] .uppy-ProviderBrowser-user:after{left:4px}[dir=rtl] .uppy-ProviderBrowser-user:after{right:4px}.uppy-ProviderBrowser-user:after{color:#939393;content:"·";font-weight:400;position:relative}.uppy-ProviderBrowser-header{border-bottom:1px solid #eaeaea;position:relative;z-index:1001}[data-uppy-theme=dark] .uppy-ProviderBrowser-header{border-bottom:1px solid #333}.uppy-ProviderBrowser-headerBar{background-color:#fafafa;color:#757575;font-size:12px;line-height:1.4;padding:7px 15px;z-index:1001}.uppy-size--md .uppy-ProviderBrowser-headerBar{align-items:center;display:flex}[data-uppy-theme=dark] .uppy-ProviderBrowser-headerBar{background-color:#1f1f1f}.uppy-ProviderBrowser-headerBar--simple{display:block;justify-content:center;text-align:center}.uppy-ProviderBrowser-headerBar--simple .uppy-Provider-breadcrumbsWrap{display:inline-block;flex:none;vertical-align:middle}.uppy-ProviderBrowser-searchFilter{align-items:center;display:flex;height:30px;margin-bottom:15px;margin-top:15px;padding-left:8px;padding-right:8px;position:relative;width:100%}[dir=ltr] .uppy-ProviderBrowser-searchFilterInput{padding-left:30px}[dir=ltr] .uppy-ProviderBrowser-searchFilterInput,[dir=rtl] .uppy-ProviderBrowser-searchFilterInput{padding-right:30px}[dir=rtl] .uppy-ProviderBrowser-searchFilterInput{padding-left:30px}.uppy-ProviderBrowser-searchFilterInput{background-color:#eaeaea;border:0;border-radius:4px;color:#333;font-family:-apple-system,system-ui,BlinkMacSystemFont,Segoe UI,Segoe UI Symbol,Segoe UI Emoji,Apple Color Emoji,Roboto,Helvetica,Arial,sans-serif;font-size:13px;height:30px;line-height:1.4;outline:0;width:100%;z-index:1001}.uppy-ProviderBrowser-searchFilterInput::-webkit-search-cancel-button{display:none}[data-uppy-theme=dark] .uppy-ProviderBrowser-searchFilterInput{background-color:#1f1f1f;color:#eaeaea}.uppy-ProviderBrowser-searchFilterInput:focus{background-color:#cfcfcf;border:0}[data-uppy-theme=dark] .uppy-ProviderBrowser-searchFilterInput:focus{background-color:#333}[dir=ltr] .uppy-ProviderBrowser-searchFilterIcon{left:16px}[dir=rtl] .uppy-ProviderBrowser-searchFilterIcon{right:16px}.uppy-ProviderBrowser-searchFilterIcon{color:#757575;height:12px;position:absolute;width:12px;z-index:1002}.uppy-ProviderBrowser-searchFilterInput::placeholder{color:#939393;opacity:1}[dir=ltr] .uppy-ProviderBrowser-searchFilterReset{right:16px}[dir=rtl] .uppy-ProviderBrowser-searchFilterReset{left:16px}.uppy-ProviderBrowser-searchFilterReset{border-radius:3px;color:#939393;cursor:pointer;height:22px;padding:6px;position:absolute;width:22px;z-index:1002}.uppy-ProviderBrowser-searchFilterReset:focus{outline:none}.uppy-ProviderBrowser-searchFilterReset::-moz-focus-inner{border:0}.uppy-ProviderBrowser-searchFilterReset:focus{box-shadow:0 0 0 3px #1269cf80}.uppy-ProviderBrowser-searchFilterReset:hover{color:#757575}.uppy-ProviderBrowser-searchFilterReset svg{vertical-align:text-top}.uppy-ProviderBrowser-userLogout{border-radius:3px;color:#1269cf;cursor:pointer;line-height:inherit;padding:4px}.uppy-ProviderBrowser-userLogout:focus{outline:none}.uppy-ProviderBrowser-userLogout::-moz-focus-inner{border:0}.uppy-ProviderBrowser-userLogout:hover{color:#0e51a0}.uppy-ProviderBrowser-userLogout:focus{background-color:#dfe6f1}[data-uppy-theme=dark] .uppy-ProviderBrowser-userLogout:focus{background-color:#333}.uppy-ProviderBrowser-userLogout:hover{text-decoration:underline}[data-uppy-theme=dark] .uppy-ProviderBrowser-userLogout{color:#eaeaea}.uppy-ProviderBrowser-body{flex:1;position:relative}.uppy-ProviderBrowser-list{background-color:#fff;border-spacing:0;display:block;flex:1;height:100%;inset:0;list-style:none;margin:0;overflow-x:hidden;overflow-y:auto;padding:0;position:absolute;width:100%;-webkit-overflow-scrolling:touch}[data-uppy-theme=dark] .uppy-ProviderBrowser-list{background-color:#1f1f1f}.uppy-ProviderBrowser-list:focus{outline:none}.uppy-ProviderBrowserItem-inner{cursor:pointer;font-size:13px;font-weight:500}.uppy-ProviderBrowser-footer{align-items:center;background-color:#fff;border-top:1px solid #eaeaea;display:flex;justify-content:space-between;padding:15px}[dir=ltr] .uppy-ProviderBrowser-footer button{margin-right:8px}[dir=rtl] .uppy-ProviderBrowser-footer button{margin-left:8px}[data-uppy-theme=dark] .uppy-ProviderBrowser-footer{background-color:#1f1f1f;border-top:1px solid #333}.uppy-ProviderBrowser-footer-buttons{flex-shrink:0}.uppy-ProviderBrowser-footer-error{color:#e32437;line-height:18px}@media (max-width:426px){.uppy-ProviderBrowser-footer{align-items:stretch;flex-direction:column-reverse}.uppy-ProviderBrowser-footer-error{padding-bottom:10px}}.picker-dialog-bg{z-index:20000!important}.picker-dialog{z-index:20001!important}.uppy-Dashboard-Item-previewInnerWrap{align-items:center;border-radius:3px;box-shadow:0 0 2px #0006;display:flex;flex-direction:column;height:100%;justify-content:center;overflow:hidden;position:relative;width:100%}.uppy-size--md .uppy-Dashboard-Item-previewInnerWrap{box-shadow:0 1px 2px #00000026}.uppy-Dashboard--singleFile .uppy-Dashboard-Item-previewInnerWrap{box-shadow:none}.uppy-Dashboard-Item-previewInnerWrap:after{background-color:#000000a6;content:"";display:none;inset:0;position:absolute;z-index:1001}.uppy-Dashboard-Item-previewLink{inset:0;position:absolute;z-index:1002}.uppy-Dashboard-Item-previewLink:focus{box-shadow:inset 0 0 0 3px #579df0}[data-uppy-theme=dark] .uppy-Dashboard-Item-previewLink:focus{box-shadow:inset 0 0 0 3px #016c8d}.uppy-Dashboard-Item-preview img.uppy-Dashboard-Item-previewImg{border-radius:3px;height:100%;object-fit:cover;transform:translateZ(0);width:100%}.uppy-Dashboard--singleFile .uppy-Dashboard-Item-preview img.uppy-Dashboard-Item-previewImg{height:auto;max-height:100%;max-width:100%;object-fit:contain;padding:10px;width:auto}.uppy-Dashboard-Item-progress{color:#fff;left:50%;position:absolute;text-align:center;top:50%;transform:translate(-50%,-50%);transition:all .35 ease;width:120px;z-index:1002}.uppy-Dashboard-Item-progressIndicator{color:#fff;display:inline-block;height:38px;opacity:.9;width:38px}.uppy-size--md .uppy-Dashboard-Item-progressIndicator{height:55px;width:55px}button.uppy-Dashboard-Item-progressIndicator{cursor:pointer}button.uppy-Dashboard-Item-progressIndicator:focus{outline:none}button.uppy-Dashboard-Item-progressIndicator::-moz-focus-inner{border:0}button.uppy-Dashboard-Item-progressIndicator:focus .uppy-Dashboard-Item-progressIcon--bg,button.uppy-Dashboard-Item-progressIndicator:focus .uppy-Dashboard-Item-progressIcon--retry{fill:#579df0}.uppy-Dashboard-Item-progressIcon--circle{height:100%;width:100%}.uppy-Dashboard-Item-progressIcon--bg{stroke:#fff6}.uppy-Dashboard-Item-progressIcon--progress{transition:stroke-dashoffset .5s ease-out;stroke:#fff}.uppy-Dashboard-Item-progressIcon--play{transition:all .2s;fill:#fff;stroke:#fff}.uppy-Dashboard-Item-progressIcon--cancel{transition:all .2s;fill:#fff}.uppy-Dashboard-Item-progressIcon--pause{transition:all .2s;fill:#fff;stroke:#fff}.uppy-Dashboard-Item-progressIcon--check{transition:all .2s;fill:#fff}.uppy-Dashboard-Item-progressIcon--retry{fill:#fff}[dir=ltr] .uppy-Dashboard-Item.is-complete .uppy-Dashboard-Item-progress{right:-8px}[dir=rtl] .uppy-Dashboard-Item.is-complete .uppy-Dashboard-Item-progress{left:-8px}[dir=ltr] .uppy-Dashboard-Item.is-complete .uppy-Dashboard-Item-progress{left:auto}[dir=rtl] .uppy-Dashboard-Item.is-complete .uppy-Dashboard-Item-progress{right:auto}.uppy-Dashboard-Item.is-complete .uppy-Dashboard-Item-progress{top:-9px;transform:none;width:auto}.uppy-Dashboard-Item.is-error .uppy-Dashboard-Item-progressIndicator{height:18px;width:18px}.uppy-size--md .uppy-Dashboard-Item.is-error .uppy-Dashboard-Item-progressIndicator{height:28px;width:28px}.uppy-Dashboard-Item.is-complete .uppy-Dashboard-Item-progressIndicator{height:18px;opacity:1;width:18px}.uppy-size--md .uppy-Dashboard-Item.is-complete .uppy-Dashboard-Item-progressIndicator{height:22px;width:22px}.uppy-Dashboard-Item.is-processing .uppy-Dashboard-Item-progress{opacity:0}[dir=ltr] .uppy-Dashboard-Item-fileInfo{padding-right:5px}[dir=rtl] .uppy-Dashboard-Item-fileInfo{padding-left:5px}[dir=ltr] .uppy-Dashboard--singleFile .uppy-Dashboard-Item-fileInfo{padding-right:10px}[dir=rtl] .uppy-Dashboard--singleFile .uppy-Dashboard-Item-fileInfo{padding-left:10px}[dir=ltr] .uppy-size--md.uppy-Dashboard--singleFile .uppy-Dashboard-Item-fileInfo{padding-right:15px}[dir=rtl] .uppy-size--md.uppy-Dashboard--singleFile .uppy-Dashboard-Item-fileInfo{padding-left:15px}.uppy-Dashboard-Item-name{font-size:12px;font-weight:500;line-height:1.3;margin-bottom:5px;word-wrap:anywhere;word-break:break-all}[data-uppy-theme=dark] .uppy-Dashboard-Item-name{color:#eaeaea}.uppy-size--md.uppy-Dashboard--singleFile .uppy-Dashboard-Item-name{font-size:14px;line-height:1.4}.uppy-Dashboard-Item-fileName{align-items:baseline;display:flex}.uppy-Dashboard-Item-fileName button{margin-left:5px}.uppy-Dashboard-Item-author{color:#757575;display:inline-block;font-size:11px;font-weight:400;line-height:1;margin-bottom:5px;vertical-align:bottom}.uppy-Dashboard-Item-author a{color:#757575}.uppy-Dashboard-Item-status{color:#757575;font-size:11px;font-weight:400;line-height:1}[data-uppy-theme=dark] .uppy-Dashboard-Item-status{color:#bbb}.uppy-Dashboard-Item-statusSize{display:inline-block;margin-bottom:5px;text-transform:uppercase;vertical-align:bottom}.uppy-Dashboard-Item-reSelect{color:#1269cf;font-family:inherit;font-size:inherit;font-weight:600}.uppy-Dashboard-Item-errorMessage{background-color:#fdeff1;color:#a51523;font-size:11px;font-weight:500;line-height:1.3;padding:5px 6px}.uppy-Dashboard-Item-errorMessageBtn{color:#a51523;cursor:pointer;font-size:11px;font-weight:500;text-decoration:underline}.uppy-Dashboard-Item-preview .uppy-Dashboard-Item-errorMessage{display:none}.uppy-size--md .uppy-Dashboard-Item-preview .uppy-Dashboard-Item-errorMessage{border-bottom-left-radius:3px;border-bottom-right-radius:3px;border-top:1px solid #f7c2c8;bottom:0;display:block;left:0;line-height:1.4;padding:6px 8px;position:absolute;right:0}.uppy-Dashboard-Item-fileInfo .uppy-Dashboard-Item-errorMessage{border:1px solid #f7c2c8;border-radius:3px;display:inline-block;position:static}.uppy-size--md .uppy-Dashboard-Item-fileInfo .uppy-Dashboard-Item-errorMessage{display:none}.uppy-Dashboard-Item-action{color:#939393;cursor:pointer}.uppy-Dashboard-Item-action:focus{outline:none}.uppy-Dashboard-Item-action::-moz-focus-inner{border:0}.uppy-Dashboard-Item-action:focus{box-shadow:0 0 0 3px #1269cf80}.uppy-Dashboard-Item-action:hover{color:#1f1f1f;opacity:1}[data-uppy-theme=dark] .uppy-Dashboard-Item-action{color:#cfcfcf}[data-uppy-theme=dark] .uppy-Dashboard-Item-action:focus{outline:none}[data-uppy-theme=dark] .uppy-Dashboard-Item-action::-moz-focus-inner{border:0}[data-uppy-theme=dark] .uppy-Dashboard-Item-action:focus{box-shadow:0 0 0 2px #aae1ffd9}[data-uppy-theme=dark] .uppy-Dashboard-Item-action:hover{color:#eaeaea}.uppy-Dashboard-Item-action--remove{color:#1f1f1f;opacity:.95}.uppy-Dashboard-Item-action--remove:hover{color:#000;opacity:1}[dir=ltr] .uppy-size--md .uppy-Dashboard-Item-action--remove{right:-8px}[dir=rtl] .uppy-size--md .uppy-Dashboard-Item-action--remove{left:-8px}.uppy-size--md .uppy-Dashboard-Item-action--remove{height:18px;padding:0;position:absolute;top:-8px;width:18px;z-index:1002}.uppy-size--md .uppy-Dashboard-Item-action--remove:focus{border-radius:50%}[dir=ltr] .uppy-Dashboard--singleFile.uppy-size--height-md .uppy-Dashboard-Item-action--remove{right:8px}[dir=rtl] .uppy-Dashboard--singleFile.uppy-size--height-md .uppy-Dashboard-Item-action--remove{left:8px}.uppy-Dashboard--singleFile.uppy-size--height-md .uppy-Dashboard-Item-action--remove{position:absolute;top:8px}[data-uppy-theme=dark] .uppy-Dashboard-Item-action--remove{color:#525252}[data-uppy-theme=dark] .uppy-Dashboard-Item-action--remove:hover{color:#333}.uppy-Dashboard:not(.uppy-size--md):not(.uppy-Dashboard--singleFile.uppy-size--height-md) .uppy-Dashboard-Item-actionWrapper{align-items:center;display:flex}.uppy-Dashboard:not(.uppy-size--md):not(.uppy-Dashboard--singleFile.uppy-size--height-md) .uppy-Dashboard-Item-action{height:22px;margin-left:3px;padding:3px;width:22px}.uppy-Dashboard:not(.uppy-size--md):not(.uppy-Dashboard--singleFile.uppy-size--height-md) .uppy-Dashboard-Item-action:focus{border-radius:3px}.uppy-size--md .uppy-Dashboard-Item-action--copyLink,.uppy-size--md .uppy-Dashboard-Item-action--edit{height:16px;padding:0;width:16px}.uppy-size--md .uppy-Dashboard-Item-action--copyLink:focus,.uppy-size--md .uppy-Dashboard-Item-action--edit:focus{border-radius:3px}.uppy-Dashboard-Item{align-items:center;border-bottom:1px solid #eaeaea;display:flex;padding:10px}[dir=ltr] .uppy-Dashboard:not(.uppy-Dashboard--singleFile) .uppy-Dashboard-Item{padding-right:0}[dir=rtl] .uppy-Dashboard:not(.uppy-Dashboard--singleFile) .uppy-Dashboard-Item{padding-left:0}[data-uppy-theme=dark] .uppy-Dashboard-Item{border-bottom:1px solid #333}[dir=ltr] .uppy-size--md .uppy-Dashboard-Item{float:left}[dir=rtl] .uppy-size--md .uppy-Dashboard-Item{float:right}.uppy-size--md .uppy-Dashboard-Item{border-bottom:0;display:block;height:215px;margin:5px 15px;padding:0;position:relative;width:calc(33.333% - 30px)}.uppy-size--lg .uppy-Dashboard-Item{height:190px;margin:5px 15px;padding:0;width:calc(25% - 30px)}.uppy-size--xl .uppy-Dashboard-Item{height:210px;padding:0;width:calc(20% - 30px)}.uppy-Dashboard--singleFile .uppy-Dashboard-Item{border-bottom:0;display:flex;flex-direction:column;height:100%;max-width:400px;padding:15px;position:relative;width:100%}.uppy-Dashboard-Item.is-ghost .uppy-Dashboard-Item-previewInnerWrap{opacity:.2}.uppy-Dashboard-Item.is-ghost .uppy-Dashboard-Item-name{opacity:.7}.uppy-Dashboard-Item.is-ghost .uppy-Dashboard-Item-preview:before{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='35' height='39' viewBox='0 0 35 39'%3E%3Cpath fill='%2523000' d='M1.708 38.66c1.709 0 3.417-3.417 6.834-3.417s5.125 3.417 8.61 3.417c3.348 0 5.056-3.417 8.473-3.417 4.305 0 5.125 3.417 6.833 3.417.889 0 1.709-.889 1.709-1.709v-19.68C34.167-5.757 0-5.757 0 17.271v19.68c0 .82.888 1.709 1.708 1.709m8.542-17.084a3.383 3.383 0 0 1-3.417-3.416 3.383 3.383 0 0 1 3.417-3.417 3.383 3.383 0 0 1 3.417 3.417 3.383 3.383 0 0 1-3.417 3.416m13.667 0A3.383 3.383 0 0 1 20.5 18.16a3.383 3.383 0 0 1 3.417-3.417 3.383 3.383 0 0 1 3.416 3.417 3.383 3.383 0 0 1-3.416 3.416'/%3E%3C/svg%3E");background-position:50% 10px;background-repeat:no-repeat;background-size:25px;content:"";inset:0;opacity:.5;position:absolute;z-index:1005}.uppy-size--md .uppy-Dashboard-Item.is-ghost .uppy-Dashboard-Item-preview:before{background-position:50% 50%;background-size:40px}.uppy-Dashboard--singleFile .uppy-Dashboard-Item.is-ghost .uppy-Dashboard-Item-preview:before{background-position:50% 50%;background-size:30%}.uppy-Dashboard-Item-preview{flex-grow:0;flex-shrink:0;height:50px;position:relative;width:50px}.uppy-size--md .uppy-Dashboard-Item-preview{height:140px;width:100%}.uppy-size--lg .uppy-Dashboard-Item-preview{height:120px}.uppy-size--xl .uppy-Dashboard-Item-preview{height:140px}.uppy-Dashboard--singleFile .uppy-Dashboard-Item-preview{flex-grow:1;max-height:75%;width:100%}.uppy-Dashboard--singleFile.uppy-size--md .uppy-Dashboard-Item-preview{max-height:100%}[dir=ltr] .uppy-Dashboard-Item-fileInfoAndButtons{padding-right:8px}[dir=rtl] .uppy-Dashboard-Item-fileInfoAndButtons{padding-left:8px}[dir=ltr] .uppy-Dashboard-Item-fileInfoAndButtons{padding-left:12px}[dir=rtl] .uppy-Dashboard-Item-fileInfoAndButtons{padding-right:12px}.uppy-Dashboard-Item-fileInfoAndButtons{align-items:center;display:flex;flex-grow:1;justify-content:space-between}.uppy-Dashboard--singleFile .uppy-Dashboard-Item-fileInfoAndButtons,.uppy-size--md .uppy-Dashboard-Item-fileInfoAndButtons{align-items:flex-start;padding:9px 0 0}.uppy-Dashboard--singleFile .uppy-Dashboard-Item-fileInfoAndButtons{flex-grow:0;width:100%}.uppy-Dashboard-Item-fileInfo{flex-grow:1;flex-shrink:1}.uppy-Dashboard-Item-actionWrapper{flex-grow:0;flex-shrink:0}.uppy-Dashboard-Item.is-error .uppy-Dashboard-Item-previewInnerWrap:after,.uppy-Dashboard-Item.is-inprogress .uppy-Dashboard-Item-previewInnerWrap:after{display:block}[dir=ltr] .uppy-Dashboard-Item-errorDetails{left:2px}[dir=rtl] .uppy-Dashboard-Item-errorDetails{right:2px}.uppy-Dashboard-Item-errorDetails{-webkit-appearance:none;appearance:none;background-color:#939393;border:none;border-radius:50%;color:#fff;cursor:help;flex-shrink:0;font-size:10px;font-weight:600;height:13px;line-height:12px;position:relative;text-align:center;top:0;width:13px}.uppy-Dashboard-Item-errorDetails:after{line-height:1.3;word-wrap:break-word}.uppy-Dashboard-FileCard{background-color:#fff;border-radius:5px;box-shadow:0 0 10px 4px #0000001a;display:flex;flex-direction:column;height:100%;inset:0;position:absolute;width:100%;z-index:1005}.uppy-Dashboard-FileCard .uppy-DashboardContent-bar{border-top-left-radius:5px;border-top-right-radius:5px}.uppy-Dashboard-FileCard .uppy-Dashboard-FileCard-actions{border-bottom-left-radius:5px;border-bottom-right-radius:5px}.uppy-Dashboard-FileCard-inner{display:flex;flex-direction:column;flex-grow:1;flex-shrink:1;height:100%;min-height:0}.uppy-Dashboard-FileCard-preview{align-items:center;border-bottom:1px solid #eaeaea;display:flex;flex-grow:0;flex-shrink:1;height:60%;justify-content:center;min-height:0;position:relative}[data-uppy-theme=dark] .uppy-Dashboard-FileCard-preview{background-color:#333;border-bottom:0}.uppy-Dashboard-FileCard-preview img.uppy-Dashboard-Item-previewImg{border-radius:3px;box-shadow:0 3px 20px #00000026;flex:0 0 auto;max-height:90%;max-width:90%;object-fit:cover}[dir=ltr] .uppy-Dashboard-FileCard-edit{right:10px}[dir=rtl] .uppy-Dashboard-FileCard-edit{left:10px}.uppy-Dashboard-FileCard-edit{background-color:#00000080;border-radius:50px;color:#fff;font-size:13px;padding:7px 15px;position:absolute;top:10px}.uppy-Dashboard-FileCard-edit:focus{outline:none}.uppy-Dashboard-FileCard-edit::-moz-focus-inner{border:0}.uppy-Dashboard-FileCard-edit:focus{box-shadow:0 0 0 3px #1269cf80}.uppy-Dashboard-FileCard-edit:hover{background-color:#000c}.uppy-Dashboard-FileCard-info{flex-grow:0;flex-shrink:0;height:40%;overflow-y:auto;padding:30px 20px 20px;-webkit-overflow-scrolling:touch}[data-uppy-theme=dark] .uppy-Dashboard-FileCard-info{background-color:#1f1f1f}.uppy-Dashboard-FileCard-fieldset{border:0;font-size:0;margin:auto auto 12px;max-width:640px;padding:0}.uppy-Dashboard-FileCard-label{color:#525252;display:inline-block;font-size:12px;vertical-align:middle;width:22%}.uppy-size--md .uppy-Dashboard-FileCard-label{font-size:14px}[data-uppy-theme=dark] .uppy-Dashboard-FileCard-label{color:#eaeaea}.uppy-Dashboard-FileCard-input{display:inline-block;vertical-align:middle;width:78%}.uppy-Dashboard-FileCard-actions{align-items:center;background-color:#fafafa;border-top:1px solid #eaeaea;display:flex;flex-grow:0;flex-shrink:0;height:55px;padding:0 15px}.uppy-size--md .uppy-Dashboard-FileCard-actions{height:65px}[data-uppy-theme=dark] .uppy-Dashboard-FileCard-actions{background-color:#1f1f1f;border-top:1px solid #333}[dir=ltr] .uppy-Dashboard-FileCard-actionsBtn{margin-right:10px}[dir=rtl] .uppy-Dashboard-FileCard-actionsBtn{margin-left:10px}.uppy-transition-slideDownUp-enter{opacity:.01;transform:translate3d(0,-105%,0);transition:transform .25s ease-in-out,opacity .25s ease-in-out}.uppy-transition-slideDownUp-enter.uppy-transition-slideDownUp-enter-active{opacity:1;transform:translateZ(0)}.uppy-transition-slideDownUp-leave{opacity:1;transform:translateZ(0);transition:transform .25s ease-in-out,opacity .25s ease-in-out}.uppy-transition-slideDownUp-leave.uppy-transition-slideDownUp-leave-active{opacity:.01;transform:translate3d(0,-105%,0)}@keyframes uppy-Dashboard-fadeIn{0%{opacity:0}to{opacity:1}}@keyframes uppy-Dashboard-fadeOut{0%{opacity:1}to{opacity:0}}@keyframes uppy-Dashboard-slideDownAndFadeIn{0%{opacity:0;transform:translate3d(-50%,-70%,0)}to{opacity:1;transform:translate3d(-50%,-50%,0)}}@keyframes uppy-Dashboard-slideDownAndFadeIn--small{0%{opacity:0;transform:translate3d(0,-20%,0)}to{opacity:1;transform:translateZ(0)}}@keyframes uppy-Dashboard-slideUpFadeOut{0%{opacity:1;transform:translate3d(-50%,-50%,0)}to{opacity:0;transform:translate3d(-50%,-70%,0)}}@keyframes uppy-Dashboard-slideUpFadeOut--small{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20%,0)}}.uppy-Dashboard--modal{z-index:1001}.uppy-Dashboard--modal[aria-hidden=true]{display:none}.uppy-Dashboard--modal.uppy-Dashboard--animateOpenClose>.uppy-Dashboard-inner{animation:uppy-Dashboard-slideDownAndFadeIn--small .3s cubic-bezier(0,0,.2,1)}@media only screen and (min-width:820px){.uppy-Dashboard--modal.uppy-Dashboard--animateOpenClose>.uppy-Dashboard-inner{animation:uppy-Dashboard-slideDownAndFadeIn .3s cubic-bezier(0,0,.2,1)}}.uppy-Dashboard--modal.uppy-Dashboard--animateOpenClose>.uppy-Dashboard-overlay{animation:uppy-Dashboard-fadeIn .3s cubic-bezier(0,0,.2,1)}.uppy-Dashboard--modal.uppy-Dashboard--animateOpenClose.uppy-Dashboard--isClosing>.uppy-Dashboard-inner{animation:uppy-Dashboard-slideUpFadeOut--small .3s cubic-bezier(0,0,.2,1)}@media only screen and (min-width:820px){.uppy-Dashboard--modal.uppy-Dashboard--animateOpenClose.uppy-Dashboard--isClosing>.uppy-Dashboard-inner{animation:uppy-Dashboard-slideUpFadeOut .3s cubic-bezier(0,0,.2,1)}}.uppy-Dashboard--modal.uppy-Dashboard--animateOpenClose.uppy-Dashboard--isClosing>.uppy-Dashboard-overlay{animation:uppy-Dashboard-fadeOut .3s cubic-bezier(0,0,.2,1)}.uppy-Dashboard-isFixed{height:100vh;overflow:hidden}.uppy-Dashboard--modal .uppy-Dashboard-overlay{background-color:#00000080;inset:0;position:fixed;z-index:1001}.uppy-Dashboard-inner{background-color:#f4f4f4;border:1px solid #eaeaea;border-radius:5px;max-height:100%;max-width:100%;outline:none;position:relative}.uppy-size--md .uppy-Dashboard-inner{min-height:auto}@media only screen and (min-width:820px){.uppy-Dashboard-inner{height:500px;width:650px}}.uppy-Dashboard--modal .uppy-Dashboard-inner{z-index:1002}[data-uppy-theme=dark] .uppy-Dashboard-inner{background-color:#1f1f1f}.uppy-Dashboard--isDisabled .uppy-Dashboard-inner{cursor:not-allowed}.uppy-Dashboard-innerWrap{border-radius:5px;display:flex;flex-direction:column;height:100%;opacity:0;overflow:hidden;position:relative}.uppy-Dashboard--isInnerWrapVisible .uppy-Dashboard-innerWrap{opacity:1}.uppy-Dashboard--isDisabled .uppy-Dashboard-innerWrap{cursor:not-allowed;filter:grayscale(100%);opacity:.6;-webkit-user-select:none;user-select:none}.uppy-Dashboard--isDisabled .uppy-ProviderIconBg{fill:#9f9f9f}.uppy-Dashboard--isDisabled [aria-disabled],.uppy-Dashboard--isDisabled [disabled]{cursor:not-allowed;pointer-events:none}.uppy-Dashboard--modal .uppy-Dashboard-inner{border:none;inset:35px 15px 15px;position:fixed}@media only screen and (min-width:820px){.uppy-Dashboard--modal .uppy-Dashboard-inner{box-shadow:0 5px 15px 4px #00000026;left:50%;right:auto;top:50%;transform:translate(-50%,-50%)}}[dir=ltr] .uppy-Dashboard-close{right:-2px}[dir=rtl] .uppy-Dashboard-close{left:-2px}.uppy-Dashboard-close{color:#ffffffe6;cursor:pointer;display:block;font-size:27px;position:absolute;top:-33px;z-index:1005}.uppy-Dashboard-close:focus{outline:none}.uppy-Dashboard-close::-moz-focus-inner{border:0}.uppy-Dashboard-close:focus{color:#6eabf2}@media only screen and (min-width:820px){[dir=ltr] .uppy-Dashboard-close{right:-35px}[dir=rtl] .uppy-Dashboard-close{left:-35px}.uppy-Dashboard-close{font-size:35px;top:-10px}}.uppy-Dashboard-serviceMsg{background-color:#fffbf7;border-bottom:1px solid #edd4b9;border-top:1px solid #edd4b9;font-size:12px;font-weight:500;line-height:1.3;padding:12px 0;position:relative;top:-1px;z-index:1004}.uppy-size--md .uppy-Dashboard-serviceMsg{font-size:14px;line-height:1.4}[data-uppy-theme=dark] .uppy-Dashboard-serviceMsg{background-color:#1f1f1f;border-bottom:1px solid #333;border-top:1px solid #333;color:#eaeaea}.uppy-Dashboard-serviceMsg-title{display:block;line-height:1;margin-bottom:4px;padding-left:42px}.uppy-Dashboard-serviceMsg-text{padding:0 15px}.uppy-Dashboard-serviceMsg-actionBtn{color:#1269cf;font-size:inherit;font-weight:inherit;vertical-align:initial}[data-uppy-theme=dark] .uppy-Dashboard-serviceMsg-actionBtn{color:#02baf2e6}.uppy-Dashboard-serviceMsg-icon{left:15px;position:absolute;top:10px}.uppy-Dashboard-AddFiles{align-items:center;display:flex;flex-direction:column;height:100%;justify-content:center;position:relative;text-align:center}[data-uppy-drag-drop-supported=true] .uppy-Dashboard-AddFiles{border:1px dashed #dfdfdf;border-radius:3px;height:calc(100% - 14px);margin:7px}.uppy-Dashboard-AddFilesPanel .uppy-Dashboard-AddFiles{border:none;height:calc(100% - 54px)}.uppy-Dashboard--modal .uppy-Dashboard-AddFiles{border-color:#cfcfcf}[data-uppy-theme=dark] .uppy-Dashboard-AddFiles{border-color:#757575}.uppy-Dashboard-AddFiles-info{display:none;margin-top:auto;padding-bottom:15px;padding-top:15px}.uppy-size--height-md .uppy-Dashboard-AddFiles-info{display:block}.uppy-size--md .uppy-Dashboard-AddFiles-info{bottom:25px;left:0;padding-bottom:0;padding-top:30px;position:absolute;right:0}[data-uppy-num-acquirers="0"] .uppy-Dashboard-AddFiles-info{margin-top:0}.uppy-Dashboard-browse{color:#1269cf;cursor:pointer}.uppy-Dashboard-browse:focus{outline:none}.uppy-Dashboard-browse::-moz-focus-inner{border:0}.uppy-Dashboard-browse:focus,.uppy-Dashboard-browse:hover{border-bottom:1px solid #1269cf}[data-uppy-theme=dark] .uppy-Dashboard-browse{color:#02baf2e6}[data-uppy-theme=dark] .uppy-Dashboard-browse:focus,[data-uppy-theme=dark] .uppy-Dashboard-browse:hover{border-bottom:1px solid #02baf2}.uppy-Dashboard-browseBtn{display:block;font-size:14px;font-weight:500;margin-bottom:5px;margin-top:8px;width:100%}.uppy-size--md .uppy-Dashboard-browseBtn{font-size:15px;margin:15px auto;padding:13px 44px;width:auto}.uppy-Dashboard-AddFiles-list{display:flex;flex:1;flex-direction:column;margin-top:2px;overflow-y:auto;padding:2px 0;width:100%;-webkit-overflow-scrolling:touch}.uppy-size--md .uppy-Dashboard-AddFiles-list{flex:none;flex-direction:row;flex-wrap:wrap;justify-content:center;margin-top:15px;max-width:600px;overflow-y:visible;padding-top:0}.uppy-DashboardTab{border-bottom:1px solid #eaeaea;text-align:center;width:100%}[data-uppy-theme=dark] .uppy-DashboardTab{border-bottom:1px solid #333}.uppy-size--md .uppy-DashboardTab{border-bottom:none;display:inline-block;margin-bottom:10px;width:auto}.uppy-DashboardTab-btn{align-items:center;-webkit-appearance:none;appearance:none;background-color:initial;color:#525252;cursor:pointer;flex-direction:row;height:100%;justify-content:left;padding:12px 15px;width:100%}.uppy-DashboardTab-btn:focus{outline:none}[dir=ltr] .uppy-size--md .uppy-DashboardTab-btn{margin-right:1px}[dir=rtl] .uppy-size--md .uppy-DashboardTab-btn{margin-left:1px}.uppy-size--md .uppy-DashboardTab-btn{border-radius:5px;flex-direction:column;padding:10px 3px;width:86px}[data-uppy-theme=dark] .uppy-DashboardTab-btn{color:#eaeaea}.uppy-DashboardTab-btn::-moz-focus-inner{border:0}.uppy-DashboardTab-btn:hover{background-color:#e9ecef}[data-uppy-theme=dark] .uppy-DashboardTab-btn:hover{background-color:#333}.uppy-DashboardTab-btn:active,.uppy-DashboardTab-btn:focus{background-color:#dfe6f1}[data-uppy-theme=dark] .uppy-DashboardTab-btn:active,[data-uppy-theme=dark] .uppy-DashboardTab-btn:focus{background-color:#525252}.uppy-DashboardTab-btn svg{display:inline-block;max-height:100%;max-width:100%;overflow:hidden;transition:transform .15s ease-in-out;vertical-align:text-top}[dir=ltr] .uppy-DashboardTab-inner{margin-right:10px}[dir=rtl] .uppy-DashboardTab-inner{margin-left:10px}.uppy-DashboardTab-inner{align-items:center;background-color:#fff;border-radius:8px;box-shadow:0 1px 1px #0000001a,0 1px 2px #0000001a,0 2px 3px #00000005;display:flex;height:32px;justify-content:center;width:32px}[dir=ltr] .uppy-size--md .uppy-DashboardTab-inner{margin-right:0}[dir=rtl] .uppy-size--md .uppy-DashboardTab-inner{margin-left:0}[data-uppy-theme=dark] .uppy-DashboardTab-inner{background-color:#323232;box-shadow:0 1px 1px #0003,0 1px 2px #0003,0 2px 3px #00000014}.uppy-DashboardTab-name{font-size:14px;font-weight:400}.uppy-size--md .uppy-DashboardTab-name{font-size:12px;line-height:15px;margin-bottom:0;margin-top:8px}.uppy-DashboardTab-iconMyDevice{color:#1269cf}[data-uppy-theme=dark] .uppy-DashboardTab-iconMyDevice{color:#02baf2}.uppy-DashboardTab-iconBox{color:#0061d5}[data-uppy-theme=dark] .uppy-DashboardTab-iconBox{color:#eaeaea}.uppy-DashboardTab-iconDropbox{color:#0061fe}[data-uppy-theme=dark] .uppy-DashboardTab-iconDropbox{color:#eaeaea}.uppy-DashboardTab-iconUnsplash{color:#111}[data-uppy-theme=dark] .uppy-DashboardTab-iconUnsplash{color:#eaeaea}.uppy-DashboardTab-iconWebdav{color:#111}[data-uppy-theme=dark] .uppy-DashboardTab-iconWebdav{color:#eaeaea}.uppy-DashboardTab-iconScreenRec{color:#2c3e50}[data-uppy-theme=dark] .uppy-DashboardTab-iconScreenRec{color:#eaeaea}.uppy-DashboardTab-iconAudio{color:#8030a3}[data-uppy-theme=dark] .uppy-DashboardTab-iconAudio{color:#bf6ee3}.uppy-Dashboard-input{height:.1px;opacity:0;overflow:hidden;position:absolute;width:.1px;z-index:-1}.uppy-DashboardContent-bar{align-items:center;background-color:#fafafa;border-bottom:1px solid #eaeaea;display:flex;flex-shrink:0;height:40px;justify-content:space-between;padding:0 10px;position:relative;width:100%;z-index:1004}.uppy-size--md .uppy-DashboardContent-bar{height:50px;padding:0 15px}[data-uppy-theme=dark] .uppy-DashboardContent-bar{background-color:#1f1f1f;border-bottom:1px solid #333}.uppy-DashboardContent-title{font-size:12px;font-weight:500;left:0;line-height:40px;margin:auto;max-width:170px;overflow-x:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0;white-space:nowrap;width:100%}.uppy-size--md .uppy-DashboardContent-title{font-size:14px;line-height:50px;max-width:300px}[data-uppy-theme=dark] .uppy-DashboardContent-title{color:#eaeaea}[dir=ltr] .uppy-DashboardContent-back,[dir=ltr] .uppy-DashboardContent-save{margin-left:-6px}[dir=rtl] .uppy-DashboardContent-back,[dir=rtl] .uppy-DashboardContent-save{margin-right:-6px}.uppy-DashboardContent-back,.uppy-DashboardContent-save{-webkit-appearance:none;background:none;border:0;border-radius:3px;color:inherit;color:#1269cf;cursor:pointer;font-family:inherit;font-size:inherit;font-size:12px;font-weight:400;line-height:1;margin:0;padding:7px 6px}.uppy-DashboardContent-back:focus,.uppy-DashboardContent-save:focus{outline:none}.uppy-DashboardContent-back::-moz-focus-inner,.uppy-DashboardContent-save::-moz-focus-inner{border:0}.uppy-DashboardContent-back:hover,.uppy-DashboardContent-save:hover{color:#0e51a0}.uppy-DashboardContent-back:focus,.uppy-DashboardContent-save:focus{background-color:#dfe6f1}[data-uppy-theme=dark] .uppy-DashboardContent-back:focus,[data-uppy-theme=dark] .uppy-DashboardContent-save:focus{background-color:#333}.uppy-size--md .uppy-DashboardContent-back,.uppy-size--md .uppy-DashboardContent-save{font-size:14px}[data-uppy-theme=dark] .uppy-DashboardContent-back,[data-uppy-theme=dark] .uppy-DashboardContent-save{color:#02baf2}[dir=ltr] .uppy-DashboardContent-addMore{margin-right:-5px}[dir=rtl] .uppy-DashboardContent-addMore{margin-left:-5px}.uppy-DashboardContent-addMore{-webkit-appearance:none;background:none;border:0;border-radius:3px;color:inherit;color:#1269cf;cursor:pointer;font-family:inherit;font-size:inherit;font-weight:500;height:29px;line-height:1;margin:0;padding:7px 8px;width:29px}.uppy-DashboardContent-addMore:focus{outline:none}.uppy-DashboardContent-addMore::-moz-focus-inner{border:0}.uppy-DashboardContent-addMore:hover{color:#0e51a0}.uppy-DashboardContent-addMore:focus{background-color:#dfe6f1}[data-uppy-theme=dark] .uppy-DashboardContent-addMore:focus{background-color:#333}[dir=ltr] .uppy-size--md .uppy-DashboardContent-addMore{margin-right:-8px}[dir=rtl] .uppy-size--md .uppy-DashboardContent-addMore{margin-left:-8px}.uppy-size--md .uppy-DashboardContent-addMore{font-size:14px;height:auto;width:auto}[data-uppy-theme=dark] .uppy-DashboardContent-addMore{color:#02baf2}[dir=ltr] .uppy-DashboardContent-addMore svg{margin-right:4px}[dir=rtl] .uppy-DashboardContent-addMore svg{margin-left:4px}.uppy-DashboardContent-addMore svg{vertical-align:initial}.uppy-size--md .uppy-DashboardContent-addMore svg{height:11px;width:11px}.uppy-DashboardContent-addMoreCaption{display:none}.uppy-size--md .uppy-DashboardContent-addMoreCaption{display:inline}.uppy-DashboardContent-panel{background-color:#f5f5f5;flex:1}.uppy-Dashboard-AddFilesPanel,.uppy-DashboardContent-panel{border-radius:5px;display:flex;flex-direction:column;inset:0;overflow:hidden;position:absolute;z-index:1005}.uppy-Dashboard-AddFilesPanel{background:#fafafa;background:linear-gradient(0deg,#fafafa 35%,#fafafad9);box-shadow:0 0 10px 5px #00000026}[data-uppy-theme=dark] .uppy-Dashboard-AddFilesPanel{background-color:#333;background-image:linear-gradient(0deg,#1f1f1f 35%,#1f1f1fd9)}.uppy-Dashboard--isAddFilesPanelVisible .uppy-Dashboard-files{filter:blur(2px)}.uppy-Dashboard-progress{bottom:0;height:12%;left:0;position:absolute;width:100%}.uppy-Dashboard-progressBarContainer.is-active{height:100%;left:0;position:absolute;top:0;width:100%;z-index:1004}.uppy-Dashboard-filesContainer{flex:1;margin:0;overflow-y:hidden;position:relative}.uppy-Dashboard-filesContainer:after{clear:both;content:"";display:table}.uppy-Dashboard-files{flex:1;margin:0;overflow-y:auto;padding:0 0 10px;-webkit-overflow-scrolling:touch}.uppy-size--md .uppy-Dashboard-files{padding-top:10px}.uppy-Dashboard--singleFile .uppy-Dashboard-filesInner{align-items:center;display:flex;height:100%;justify-content:center}.uppy-Dashboard-dropFilesHereHint{align-items:center;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48'%3E%3Cpath fill='%231269CF' d='M24 1v1C11.85 2 2 11.85 2 24s9.85 22 22 22 22-9.85 22-22S36.15 2 24 2zm0 0V0c13.254 0 24 10.746 24 24S37.254 48 24 48 0 37.254 0 24 10.746 0 24 0zm7.707 19.293a.999.999 0 1 1-1.414 1.414L25 16.414V34a1 1 0 1 1-2 0V16.414l-5.293 5.293a.999.999 0 1 1-1.414-1.414l7-7a1 1 0 0 1 1.414 0z'/%3E%3C/svg%3E");background-position:50% 50%;background-repeat:no-repeat;border:1px dashed #1269cf;border-radius:3px;color:#757575;display:flex;font-size:16px;justify-content:center;inset:7px;padding-top:90px;position:absolute;text-align:center;visibility:hidden;z-index:2000}[data-uppy-theme=dark] .uppy-Dashboard-dropFilesHereHint{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48'%3E%3Cpath fill='%2302BAF2' d='M24 1v1C11.85 2 2 11.85 2 24s9.85 22 22 22 22-9.85 22-22S36.15 2 24 2zm0 0V0c13.254 0 24 10.746 24 24S37.254 48 24 48 0 37.254 0 24 10.746 0 24 0zm7.707 19.293a.999.999 0 1 1-1.414 1.414L25 16.414V34a1 1 0 1 1-2 0V16.414l-5.293 5.293a.999.999 0 1 1-1.414-1.414l7-7a1 1 0 0 1 1.414 0z'/%3E%3C/svg%3E");border-color:#02baf2;color:#bbb}.uppy-Dashboard.uppy-Dashboard--isDraggingOver .uppy-Dashboard-dropFilesHereHint{pointer-events:none;visibility:visible}.uppy-Dashboard.uppy-Dashboard--isDraggingOver .uppy-Dashboard-files,.uppy-Dashboard.uppy-Dashboard--isDraggingOver .uppy-Dashboard-progressindicators,.uppy-Dashboard.uppy-Dashboard--isDraggingOver .uppy-Dashboard-serviceMsg,.uppy-Dashboard.uppy-Dashboard--isDraggingOver .uppy-DashboardContent-bar{opacity:.15}.uppy-Dashboard.uppy-Dashboard--isDraggingOver .uppy-Dashboard-AddFiles{opacity:.03}.uppy-Dashboard-AddFiles-title{color:#000;font-size:17px;font-weight:500;line-height:1.35;margin-bottom:5px;margin-top:15px;padding:0 15px;text-align:inline-start;width:100%}.uppy-size--md .uppy-Dashboard-AddFiles-title{font-size:21px;font-weight:400;margin-top:5px;max-width:480px;padding:0 35px;text-align:center}[data-uppy-num-acquirers="0"] .uppy-Dashboard-AddFiles-title{text-align:center}[data-uppy-theme=dark] .uppy-Dashboard-AddFiles-title{color:#eaeaea}.uppy-Dashboard-AddFiles-title button{font-weight:500}.uppy-size--md .uppy-Dashboard-AddFiles-title button{font-weight:400}.uppy-Dashboard-note{color:#757575;font-size:14px;line-height:1.25;margin:auto;max-width:350px;padding:0 15px;text-align:center}.uppy-size--md .uppy-Dashboard-note{line-height:1.35;max-width:600px}[data-uppy-theme=dark] .uppy-Dashboard-note{color:#cfcfcf}a.uppy-Dashboard-poweredBy{color:#939393;display:inline-block;font-size:11px;margin-top:8px;text-align:center;text-decoration:none}.uppy-Dashboard-poweredByIcon{margin-left:1px;margin-right:1px;opacity:.9;position:relative;top:1px;vertical-align:text-top;fill:none;stroke:#939393}.uppy-Dashboard-Item-previewIcon{height:25px;left:50%;position:absolute;top:50%;transform:translate(-50%,-50%);width:25px;z-index:100}.uppy-size--md .uppy-Dashboard-Item-previewIcon{height:38px;width:38px}.uppy-Dashboard-Item-previewIcon svg{height:100%;width:100%}.uppy-Dashboard--singleFile .uppy-Dashboard-Item-previewIcon{height:100%;max-height:60%;max-width:60%;width:100%}.uppy-Dashboard-Item-previewIconWrap{height:76px;max-height:75%;position:relative}.uppy-Dashboard--singleFile .uppy-Dashboard-Item-previewIconWrap{height:100%;width:100%}.uppy-Dashboard-Item-previewIconBg{filter:drop-shadow(rgba(0,0,0,.1) 0 1px 1px);height:100%;width:100%}.uppy-Dashboard-upload{height:50px;position:relative;width:50px}.uppy-size--md .uppy-Dashboard-upload{height:60px;width:60px}.uppy-Dashboard-upload .uppy-c-icon{position:relative;top:1px;width:50%}[dir=ltr] .uppy-Dashboard-uploadCount{right:-12px}[dir=rtl] .uppy-Dashboard-uploadCount{left:-12px}.uppy-Dashboard-uploadCount{background-color:#1bb240;border-radius:50%;color:#fff;font-size:8px;height:16px;line-height:16px;position:absolute;top:-12px;width:16px}.uppy-size--md .uppy-Dashboard-uploadCount{font-size:9px;height:18px;line-height:18px;width:18px}`, uppyImageEditor = `.uppy-ImageCropper-range{-webkit-appearance:none;background:#0000;margin:8px 0;width:100%}.uppy-ImageCropper-range::-moz-focus-outer{border:0}.uppy-ImageCropper-range:focus{outline:0}.uppy-ImageCropper-range:focus::-webkit-slider-runnable-track{background:#fff3}.uppy-ImageCropper-range:focus::-ms-fill-lower,.uppy-ImageCropper-range:focus::-ms-fill-upper{background:#fff3}.uppy-ImageCropper-range::-webkit-slider-runnable-track{background:#fff3;border:0 solid #0000;border-radius:5px;box-shadow:0 0 #0000,0 0 #0d0d0d00;cursor:default;height:4px;-webkit-transition:all .2s ease;transition:all .2s ease;width:100%}.uppy-ImageCropper-range::-webkit-slider-thumb{-webkit-appearance:none;background:#fff;border:0 solid #0000;border-radius:9px;box-shadow:0 0 4px #0003,0 0 #0d0d0d33;box-sizing:border-box;cursor:default;height:16px;margin-top:-6px;width:16px}.uppy-ImageCropper-range::-moz-range-track{background:#fff3;border:0 solid #0000;border-radius:5px;box-shadow:0 0 #0000,0 0 #0d0d0d00;cursor:default;height:2px;-moz-transition:all .2s ease;transition:all .2s ease;width:100%}.uppy-ImageCropper-range::-moz-range-thumb{background:#fff;border:0 solid #0000;border-radius:9px;box-shadow:0 0 4px #0003,0 0 #0d0d0d33;box-sizing:border-box;cursor:default;height:16px;width:16px}.uppy-ImageCropper-range::-ms-track{background:#0000;border-color:#0000;border-width:8px 0;color:#0000;cursor:default;height:4px;-ms-transition:all .2s ease;transition:all .2s ease;width:100%}.uppy-ImageCropper-range::-ms-fill-lower{background:#f2f2f233;border:0 solid #0000;border-radius:10px;box-shadow:0 0 #0000,0 0 #0d0d0d00}.uppy-ImageCropper-range::-ms-fill-upper{background:#fff3;border:0 solid #0000;border-radius:10px;box-shadow:0 0 #0000,0 0 #0d0d0d00}.uppy-ImageCropper-range::-ms-thumb{background:#fff;border:0 solid #0000;border-radius:9px;box-shadow:0 0 4px #0003,0 0 #0d0d0d33;box-sizing:border-box;cursor:default;height:16px;margin-top:1px;width:16px}.uppy-ImageCropper-range:disabled::-moz-range-thumb,.uppy-ImageCropper-range:disabled::-ms-fill-lower,.uppy-ImageCropper-range:disabled::-ms-fill-upper,.uppy-ImageCropper-range:disabled::-ms-thumb,.uppy-ImageCropper-range:disabled::-webkit-slider-runnable-track,.uppy-ImageCropper-range:disabled::-webkit-slider-thumb{cursor:not-allowed}/*!
* Cropper.js v1.5.6
* https://fengyuanchen.github.io/cropperjs
*
* Copyright 2015-present Chen Fengyuan
* Released under the MIT license
*
* Date: 2019-10-04T04:33:44.164Z
*/.cropper-container{direction:ltr;font-size:0;line-height:0;position:relative;touch-action:none;-webkit-user-select:none;user-select:none}.cropper-container img{display:block;height:100%;image-orientation:0deg;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;width:100%}.cropper-canvas,.cropper-crop-box,.cropper-drag-box,.cropper-modal,.cropper-wrap-box{inset:0;position:absolute}.cropper-canvas,.cropper-wrap-box{overflow:hidden}.cropper-drag-box{background-color:#fff;opacity:0}.cropper-modal{background-color:#000;opacity:.5}.cropper-view-box{display:block;height:100%;outline:1px solid #39f;outline-color:#3399ffbf;overflow:hidden;width:100%}.cropper-dashed{border:0 dashed #eee;display:block;opacity:.5;position:absolute}.cropper-dashed.dashed-h{border-bottom-width:1px;border-top-width:1px;height:33.3333333333%;left:0;top:33.3333333333%;width:100%}.cropper-dashed.dashed-v{border-left-width:1px;border-right-width:1px;height:100%;left:33.3333333333%;top:0;width:33.3333333333%}.cropper-center{display:block;height:0;left:50%;opacity:.75;position:absolute;top:50%;width:0}.cropper-center:after,.cropper-center:before{background-color:#eee;content:" ";display:block;position:absolute}.cropper-center:before{height:1px;left:-3px;top:0;width:7px}.cropper-center:after{height:7px;left:0;top:-3px;width:1px}.cropper-face,.cropper-line,.cropper-point{display:block;height:100%;opacity:.1;position:absolute;width:100%}.cropper-face{background-color:#fff;left:0;top:0}.cropper-line{background-color:#39f}.cropper-line.line-e{cursor:ew-resize;right:-3px;top:0;width:5px}.cropper-line.line-n{cursor:ns-resize;height:5px;left:0;top:-3px}.cropper-line.line-w{cursor:ew-resize;left:-3px;top:0;width:5px}.cropper-line.line-s{bottom:-3px;cursor:ns-resize;height:5px;left:0}.cropper-point{background-color:#39f;height:5px;opacity:.75;width:5px}.cropper-point.point-e{cursor:ew-resize;margin-top:-3px;right:-3px;top:50%}.cropper-point.point-n{cursor:ns-resize;left:50%;margin-left:-3px;top:-3px}.cropper-point.point-w{cursor:ew-resize;left:-3px;margin-top:-3px;top:50%}.cropper-point.point-s{bottom:-3px;cursor:s-resize;left:50%;margin-left:-3px}.cropper-point.point-ne{cursor:nesw-resize;right:-3px;top:-3px}.cropper-point.point-nw{cursor:nwse-resize;left:-3px;top:-3px}.cropper-point.point-sw{bottom:-3px;cursor:nesw-resize;left:-3px}.cropper-point.point-se{bottom:-3px;cursor:nwse-resize;height:20px;opacity:1;right:-3px;width:20px}@media (min-width:768px){.cropper-point.point-se{height:15px;width:15px}}@media (min-width:992px){.cropper-point.point-se{height:10px;width:10px}}@media (min-width:1200px){.cropper-point.point-se{height:5px;opacity:.75;width:5px}}.cropper-point.point-se:before{background-color:#39f;bottom:-50%;content:" ";display:block;height:200%;opacity:0;position:absolute;right:-50%;width:200%}.cropper-invisible{opacity:0}.cropper-bg{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAAA3NCSVQICAjb4U/gAAAABlBMVEXMzMz////TjRV2AAAACXBIWXMAAArrAAAK6wGCiw1aAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABFJREFUCJlj+M/AgBVhF/0PAH6/D/HkDxOGAAAAAElFTkSuQmCC)}.cropper-hide{display:block;height:0;position:absolute;width:0}.cropper-hidden{display:none!important}.cropper-move{cursor:move}.cropper-crop{cursor:crosshair}.cropper-disabled .cropper-drag-box,.cropper-disabled .cropper-face,.cropper-disabled .cropper-line,.cropper-disabled .cropper-point{cursor:not-allowed}.uppy-ImageCropper{display:flex;flex-direction:column;height:100%;width:100%}.uppy-ImageCropper-container{flex-grow:1}.uppy-ImageCropper-image{display:block;max-height:400px;max-width:100%}.uppy-ImageCropper-controls{align-items:center;background-color:#0009;border-radius:5px;bottom:15px;color:#fff;display:flex;justify-content:center;left:50%;padding-top:38px;position:absolute;transform:translate(-50%)}.uppy-size--md .uppy-ImageCropper-controls{padding-top:0}.uppy-ImageCropper-controls button{border-radius:5px;height:35px;width:35px}.uppy-ImageCropper-controls button svg{padding:3px}.uppy-size--md .uppy-ImageCropper-controls button{height:40px;width:40px}.uppy-size--md .uppy-ImageCropper-controls button svg{padding:1px}.uppy-ImageCropper-controls button:hover{background-color:#ffffff80}.uppy-ImageCropper-controls button:focus{background-color:#ffffff80;outline:none}.uppy-Dashboard:not(.uppy-size--md) .uppy-ImageCropper-rangeWrapper{height:38px;left:10px;position:absolute!important;right:10px;top:0}.uppy-size--md .uppy-ImageCropper-range{margin-left:5px;margin-right:5px;width:180px}.uppy-ImageCropper .cropper-point{height:8px;width:8px}.uppy-ImageCropper .cropper-view-box{background:repeating-conic-gradient(#bdbdbd33 0 25%,#fff 0 50%) 50%/16px 16px;outline:2px solid #39f}[data-uppy-theme=dark] .uppy-ImageCropper .cropper-view-box{background:repeating-conic-gradient(#2b2a2a 0 25%,#000 0 50%) 50%/16px 16px}.uppy-ImageCropper .cropper-modal{background-color:#fff;opacity:.9}[data-uppy-theme=dark] .uppy-ImageCropper .cropper-modal{background-color:#000;opacity:.7}.uppy-ImageCropper .cropper-face{opacity:0}.uppy-ImageCropper-range::-moz-range-track{height:4px}.uppy-ImageCropper-range:focus::-webkit-slider-runnable-track,.uppy-ImageCropper-range:hover::-webkit-slider-runnable-track{background:#ffffff80}.uppy-ImageCropper-range:focus::-ms-fill-lower,.uppy-ImageCropper-range:focus::-ms-fill-upper,.uppy-ImageCropper-range:hover::-ms-fill-lower,.uppy-ImageCropper-range:hover::-ms-fill-upper{background:#ffffff80}.uppy-ImageCropper-range:focus::-moz-range-track,.uppy-ImageCropper-range:hover::-moz-range-track{background:#ffffff80}`, state$6 = {
  classNamePrefix: null,
  logPrefix: "LT Image Uploader: ",
  observer: null,
  observedElements: /* @__PURE__ */ new Map(),
  renderedCss: !1,
  options: {
    quality: 0.7,
    maxWidth: 1500,
    maxHeight: 1500
  },
  upload: {
    request: null,
    security: null,
    uriUploadForm: checkUploadFormUri("https://authorapi.learnosity.com/latest-lts/assets/uploadform")
  },
  uppy: null
};
function run$6(le, Y, re = {}) {
  state$6.renderedCss || injectCSS$4(), state$6.upload.security = le, state$6.upload.request = Y, overrideOptions$1(re), validateRunParams() && appInstance().on("widgetedit:widget:ready", setupModalObserver);
}
function setupModalObserver() {
  logger.debug(`${state$6.logPrefix}setupModalObserver()`), state$6.classNamePrefix = checkAppVersion(state$6.classNamePrefix), clearObserver();
  const le = (Y) => {
    for (const re of Y)
      if (re.type === "childList") {
        const oe = document.querySelector(
          '[data-authorapi-selector="asset-uploader-iframe-outlet"]:not(.lrn-author-slide-pane [data-authorapi-selector="asset-uploader-iframe-outlet"]):not(.lrn-qe-slide-pane [data-authorapi-selector="asset-uploader-iframe-outlet"])'
        ), ue = document.querySelector('[data-authorapi-selector="asset-display-name"]');
        if (oe && !ue) {
          logger.debug(`${state$6.logPrefix}Disconnecting observer`), clearObserver(), setupUploderUI();
          break;
        }
      }
  };
  state$6.observedElements.size ? logger.debug(`${state$6.logPrefix}Observed elements full`) : (state$6.observer = new MutationObserver(le), activateObserver());
}
function activateObserver() {
  logger.debug(`${state$6.logPrefix}Looking to activate observer`);
  const le = document.querySelector(".lrn-author-item");
  state$6.observedElements.has(le) || (logger.debug(`${state$6.logPrefix}Activated observer`), state$6.observer.observe(le, { childList: !0, subtree: !0 }), state$6.observedElements.set(le, state$6.observer));
}
function clearObserver() {
  state$6.observer?.disconnect(), state$6.observedElements.clear();
}
function setupUploderUI() {
  const le = document.querySelector('[data-authorapi-selector="asset-uploader-alignment"]'), Y = document.querySelector(`.lrn-${state$6.classNamePrefix}image-uploader-preview`);
  setTimeout(() => {
    const oe = document.querySelector('[data-authorapi-selector="asset-uploader-iframe-outlet"]'), ue = oe.querySelector("iframe"), fe = document.querySelector(`.lrn-${state$6.classNamePrefix}adv-options`), he = document.createElement("div");
    he.setAttribute("id", "uppy-dashboard"), ue.setAttribute("hidden", ""), oe.insertAdjacentElement("afterbegin", he), listenForSelfHostedImages(), prepareModalButtons(), fe.removeAttribute("hidden"), setupUploadLibrary();
  }, !le && !Y ? 0 : 500);
}
function setupUploadLibrary() {
  state$6.uppy = new Uppy({
    debug: !1,
    autoProceed: !1,
    restrictions: { maxNumberOfFiles: 1, minNumberOfFiles: 1, allowedFileTypes: ["image/gif", "image/jpeg", "image/png", "image/svg+xml"] }
  }).use(Dashboard, {
    inline: !0,
    width: 790,
    height: 350,
    autoOpen: null,
    disableStatusBar: !0,
    target: "#uppy-dashboard",
    showProgressDetails: !1,
    proudlyDisplayPoweredByUppy: !1
  }).use(Compressor, {
    quality: state$6.options.quality,
    convertSize: 5e5,
    convertTypes: ["image/png"],
    maxHeight: state$6.options.maxHeight,
    maxWidth: state$6.options.maxWidth
  }).use(ImageEditor, { target: Dashboard }), state$6.uppy.on("file-added", (le) => {
    logger.debug(`${state$6.logPrefix}file-added: ${le.source}`), document.querySelector(`.lrn-${state$6.classNamePrefix}adv-options`).setAttribute("hidden", ""), le.source === "Dashboard" && compressImage(le);
  }), state$6.uppy.on("file-removed", () => {
    logger.debug(`${state$6.logPrefix}file-removed`), toggleElement("lt__image-uploader-upload-btn", "remove");
  }), state$6.uppy.on("file-editor:start", () => {
    logger.debug(`${state$6.logPrefix}file-editor:start`), toggleElement("lt__image-uploader-upload-btn", "disable");
  }), state$6.uppy.on("file-editor:complete", (le) => {
    logger.debug(`${state$6.logPrefix}file-editor:complete`), compressImage(le), toggleElement("lt__image-uploader-upload-btn", "enable");
  }), state$6.uppy.on("file-editor:cancel", () => {
    logger.debug(`${state$6.logPrefix}file-editor:cancel`), toggleElement("lt__image-uploader-upload-btn", "enable");
  }), state$6.uppy.on("error", (le) => {
    logger.error(le.stack);
  });
}
function compressImage(le) {
  const Y = le.name, re = le.meta, oe = le.type;
  oe !== "image/svg+xml" ? (logger.debug(`${state$6.logPrefix}Compressing image`), state$6.uppy.getPlugin("Compressor").compress(le.data).then((ue) => {
    setTimeout(() => {
      state$6.uppy.removeFile(le.id), state$6.uppy.addFile({
        name: Y,
        type: oe,
        meta: re,
        data: ue,
        source: "Local"
      });
      const fe = state$6.uppy.store.state.files;
      let he;
      for (const _e in fe)
        he = _e;
      addUploadButton(he);
    }, 50);
  })) : addUploadButton(le.id);
}
function addUploadButton(le) {
  const Y = document.querySelector(`.lrn-${state$6.classNamePrefix}modal-footer`);
  removeUploadButton();
  const re = document.createElement("button"), oe = state$6.classNamePrefix ? "-old" : "";
  re.setAttribute(
    "class",
    `lrn-${state$6.classNamePrefix}btn${oe} lrn-${state$6.classNamePrefix}btn${oe}-legacy lt__image-uploader-upload-btn`
  ), re.textContent = "Upload", Y.insertAdjacentElement("afterbegin", re), re.addEventListener("click", () => uploadImage(le));
}
function removeUploadButton() {
  const le = document.querySelector(".lt__image-uploader-upload-btn");
  le && (logger.debug(`${state$6.logPrefix}Removing existing upload button`), le.remove());
}
function uploadImage(le) {
  document.querySelector(".lt__image-uploader-upload-btn").removeEventListener("click", () => uploadImage(le)), document.querySelector(".uppy-Dashboard-Item-action--edit")?.setAttribute("disabled", "");
  const oe = state$6.uppy.getFile(le), ue = document.querySelector(".lt__image-uploader-upload-btn");
  ue.setAttribute("style", "width:105px;"), ue.innerHTML = '<span class="lt__upload-spinner"><svg width="14" height="14" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><style>.spinner_6kVp{transform-origin:center;animation:spinner_irSm .75s infinite linear}@keyframes spinner_irSm{100%{transform:rotate(360deg)};fill:#ffffff;}</style><path d="M10.72,19.9a8,8,0,0,1-6.5-9.79A7.77,7.77,0,0,1,10.4,4.16a8,8,0,0,1,9.49,6.52A1.54,1.54,0,0,0,21.38,12h.13a1.37,1.37,0,0,0,1.38-1.54,11,11,0,1,0-12.7,12.39A1.54,1.54,0,0,0,12,21.34h0A1.47,1.47,0,0,0,10.72,19.9Z" class="spinner_6kVp" style="fill: white"/></svg></span>', ue.setAttribute("disabled", "");
  const fe = new FormData(), he = {
    usrequest: { assetName: oe.name, mimeType: oe.type, fileType: "image" },
    action: "get",
    security: state$6.upload.security,
    request: state$6.upload.request
  };
  fe.append("usrequest", JSON.stringify(he.usrequest)), fe.append("action", he.action), fe.append("security", JSON.stringify(he.security)), fe.append("request", JSON.stringify(he.request));
  async function _e() {
    return (await fetch(state$6.upload.uriUploadForm, {
      method: "POST",
      body: fe
    })).json();
  }
  _e().then((ve) => {
    const xe = new FormData();
    xe.append("key", ve.data.formInputs.key), xe.append("Content-Type", ve.data.formInputs["Content-Type"]), xe.append("X-Amz-Security-Token", ve.data.formInputs["X-Amz-Security-Token"]), xe.append("X-Amz-Credential", ve.data.formInputs["X-Amz-Credential"]), xe.append("X-Amz-Algorithm", ve.data.formInputs["X-Amz-Algorithm"]), xe.append("X-Amz-Date", ve.data.formInputs["X-Amz-Date"]), xe.append("Policy", ve.data.formInputs.Policy), xe.append("X-Amz-Signature", ve.data.formInputs["X-Amz-Signature"]), xe.append("file", oe.data);
    async function Ee() {
      return await fetch(ve.data.formAttributes.action, {
        method: "POST",
        body: xe
      });
    }
    Ee().then(() => {
      const Se = ve.data.assetUrl, Te = document.querySelector('[data-authorapi-selector="asset-uploader-source"]');
      Te.value = Se.trim(), Te.dispatchEvent(new Event("input", { bubbles: !0 })), logger.debug(`${state$6.logPrefix}Added image path to URI`), setTimeout(() => {
        removeUploadButton();
        const Ce = document.querySelector(
          `.lrn-author-item .lrn-${state$6.classNamePrefix}delete-btn-wrapper [data-authorapi-action="asset-uploader-delete"]`
        ), Ie = document.querySelector(
          `.lrn-author-item .lrn-${state$6.classNamePrefix}image-uploader [data-authorapi-selector="asset-uploader-alignment"]`
        );
        if (Ce && !Ie) {
          const Ne = document.querySelector('[data-authorapi-selector="asset-uploader-okay"]');
          Ne && (Ne.click(), logger.debug(`${state$6.logPrefix}Clicked OK button for background images`));
        }
        prepareModalButtons();
      }, 1500);
    }).catch((Se) => console.error("Error in uploading image:", Se));
  }).catch((ve) => console.error("Error in fetching tokens:", ve));
}
function listenForSelfHostedImages() {
  logger.debug(`${state$6.logPrefix}listenForSelfHostedImages()`), setTimeout(() => {
    const le = document.querySelector('[data-authorapi-selector="asset-uploader-source"]');
    le && le.addEventListener("input", handleSelfHostedImage);
  }, 500);
}
function handleSelfHostedImage() {
  logger.debug(`${state$6.logPrefix}handleSelfHostedImage()`), setTimeout(() => {
    prepareModalButtons();
  }, 1500);
}
function prepareModalButtons() {
  logger.debug(`${state$6.logPrefix}prepareModalButtons()`);
  const le = [
    `lrn-${state$6.classNamePrefix}modal-button-close`,
    `lrn-${state$6.classNamePrefix}btn-default`,
    `lrn-${state$6.classNamePrefix}btn-primary-legacy`,
    `lrn-${state$6.classNamePrefix}btn-sec`
  ], Y = document.querySelector(`.lrn-${state$6.classNamePrefix}modal`);
  ue();
  function re(fe, he, _e) {
    const ve = new MutationObserver((Ee, Se) => {
      for (const Te of Ee)
        if (Te.type === "childList") {
          const Ce = document.querySelector(he);
          Ce && (_e(Ce), Se.disconnect());
        }
    });
    ve.observe(fe, { childList: !0, subtree: !0 });
    const xe = document.querySelector(he);
    xe && (_e(xe), ve.disconnect());
  }
  setTimeout(() => {
    re(Y, `.lrn-${state$6.classNamePrefix}modal-footer .lrn-${state$6.classNamePrefix}delete-btn-wrapper`, () => {
      logger.debug(`${state$6.logPrefix}waitForElement() observed`);
      for (const fe of le) {
        const he = Y.querySelector(`.lrn-${state$6.classNamePrefix}modal-dialog button.${fe}`);
        he && (he.addEventListener("click", oe), logger.debug(`Adding clickHanders for: ${fe}`), logger.debug(he));
      }
    });
  }, 100);
  function oe() {
    logger.debug(`${state$6.logPrefix}clickHandler()`), ue(), setTimeout(() => {
      activateObserver();
    }, 1e3);
  }
  function ue() {
    for (const he of le) {
      const _e = Y.querySelector(`.lrn-${state$6.classNamePrefix}modal-dialog button.${he}`);
      _e && (logger.debug(`${state$6.logPrefix}Removed clickHandler`), _e.removeEventListener("click", oe));
    }
    const fe = document.querySelector('[data-authorapi-selector="asset-uploader-source"]');
    fe && fe.removeEventListener("input", handleSelfHostedImage);
  }
}
function checkUploadFormUri(le) {
  const Y = new URLSearchParams(window.location.search), re = window.location.hostname, oe = Y.get("env");
  return re.includes("learnosity.com") && oe === "staging" ? le.replace("authorapi.", "authorapi.staging.") : le;
}
function overrideOptions$1(le) {
  ["quality", "maxWidth", "maxHeight"].forEach((Y) => {
    typeof le?.[Y] == "number" && (state$6.options[Y] = le[Y]);
  });
}
function validateRunParams() {
  return !state$6.upload.security || !state$6.upload.request || typeof state$6.upload.security != "object" || typeof state$6.upload.request != "object" ? (logger.error(`${state$6.logPrefix}imageUploader extension failed to run - Missing/invalid security or request parameters`), !1) : !0;
}
function toggleElement(le, Y) {
  const re = document.querySelector(`.${le}`);
  re && (Y === "disable" ? re.setAttribute("disabled", "") : Y === "enable" ? re.removeAttribute("disabled") : Y === "remove" && re.remove());
}
function injectCSS$4() {
  const le = document.createElement("style"), Y = [uppyCore, uppyDashboard, uppyImageEditor].join(`
`), re = `
/* Learnosity custom image uploader (DAM) */
/* Used to style content tabs added by via rich-text editor */
.lrn .lrn-author-ui-no-preview .uppy-c-btn,
.lrn .lrn-author-ui-no-preview button.uppy-c-btn {
    color: #fff;
}
.lrn .lrn-author-ui-no-preview button.uppy-Dashboard-browse {
    color: #1269cf;
}
.lrn .uppy-Dashboard-inner {
    margin-bottom: 15px;
}
.lrn .lrn-author-ui-no-preview .uppy-Dashboard-Item-actionWrapper button {
    color: inherit;
}
.lrn .uppy-StatusBar.is-waiting .uppy-StatusBar-actionBtn--upload,
.lrn .uppy-StatusBar.is-waiting .uppy-StatusBar-actionBtn--upload:hover {
    background-color: #1877b1;
}
.lrn .lrn-author-ui-no-preview button.lt__image-uploader-upload-btn {
    color: #fff;
    background: #1877b1;
}
.lrn .lrn-author-ui-no-preview button.lt__image-uploader-upload-btn[disabled],
.lrn .lrn-author-ui-no-preview button.lt__image-uploader-upload-btn[disabled]:hover,
.lrn .lrn-author-ui-no-preview button.lt__image-uploader-upload-btn[disabled]:focus {
    color: #d9d9d9;
    border-color: #96b7cb;
    background: #96b7cb;
}

.lrn .uppy-Dashboard-input[type=file] {
    display: none;
}
`;
  le.setAttribute("data-style", "LT Image Uploader"), le.textContent = `${Y}

${re}`, document.head.append(le), state$6.renderedCss = !0;
}
const imageUploader = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  run: run$6
}, Symbol.toStringTag, { value: "Module" })), state$5 = {
  renderedCss: !1
};
function run$5() {
  state$5.renderedCss || injectCSS$3();
}
function addLanguageAttribute(le, Y) {
  const re = getLanguageCodes(), oe = LRNCKEDITOR.currentInstance.getSelectedHtml().getHtml(), ue = LRNCKEDITOR.currentInstance.getData(), fe = getModalTemplate();
  document.querySelector(".learnosity-question-editor").insertAdjacentHTML("beforeend", fe);
  const he = document.getElementById("lrn__ltd_language"), _e = document.getElementById("lrn__ltd_notranslate");
  for (let Ee = 0; Ee < re.length; Ee++) {
    let Se;
    Ee === 0 && (Se = document.createElement("option"), Se.value = "", Se.text = "--", he.add(Se)), Se = document.createElement("option"), Se.value = re[Ee].code, Se.text = re[Ee].language, Se.setAttribute("data-dir", re[Ee].direction), he.add(Se);
  }
  const ve = [];
  ve.push(document.querySelector("#ltLanguageModal .lrn-qe-btn-default")), ve.push(document.querySelector("#ltLanguageModal .lrn-qe-modal-btn-close"));
  for (let Ee = 0; Ee < ve.length; Ee++)
    ve[Ee].addEventListener("click", () => {
      Y(oe), document.getElementById("ltLanguageModal").remove();
    });
  document.querySelector("#ltLanguageModal .lrn-qe-btn-primary").addEventListener("click", () => {
    const Ee = getLinebreakType(oe), Se = {};
    document.getElementById("ltLanguageModal").remove(), he.selectedIndex > 0 && (Se.direction = he.options[he.selectedIndex].getAttribute("data-dir"), Se.code = he.options[he.selectedIndex].value), _e.checked && (Se.noTranslate = !0);
    const Te = getReturnTemplate(Se, Ee, oe, ue);
    return Y(Te);
  });
}
function getModalTemplate() {
  return `
    <div class="lrn-qe lrn-qe-modal lt__languageModal" style="display: block;" id="ltLanguageModal">
        <div class="lrn-qe-ui">
            <div class="lrn-qe-modal-dialog">
                <div class="lrn-qe-modal-dialog-inner">
                    <div class="lrn-qe-modal-header">
                        <div class="lrn-qe-form-label lrn-qe-h4 lrn-qe-section-header">
                            <h4 class="lrn-qe-heading">Language support</h4>
                        </div>
                        <button type="button" class="lrn-qe-btn lrn-qe-modal-btn-close" aria-label="Close" tabindex="0">
                            <span class="lrn-qe-sr-only">Close</span>
                            <span aria-role="presentation" class="lrn-qe-i-cross"></span>
                        </button>
                    </div>
                    <div data-lrn-qe-selector="modal-outlet">
                        <div class="lrn-qe-modal-content" data-lrn-qe-modal-section="content">
                            <div class="lrn-qe-form-group-wrapper">
                                <div class="lrn-qe-form-group">
                                    <p><label class="lrn-qe-label lrn-qe-form-label" for="lrn__ltd_language">Choose language</label></p>
                                    <p>Specify the language for different parts of your content to enable accurate reading by screen
                                    readers and other accessibility tools.</p>
                                    <div class="lrn-qe-custom-select">
                                        <select name="lrn__ltd_language" id="lrn__ltd_language" class="lrn__combobox lrn-qe-select lrn-qe-form-control"></select>
                                    </div>
                                </div>
                                <div class="lrn-qe-form-group lrn-qe-padding-sm lt__border lrn-qe-margin-top-md">
                                    <p><input id="lrn__ltd_notranslate" type="checkbox" class="lrn-qe-input">
                                    <label class="lrn-qe-label lrn-qe-form-label lrn-qe-padding-left-xs" for="lrn__ltd_notranslate">Disable translation</label></p>
                                    <p>Adding this flag will turn off translation, preventing Google Translate and
                                    Author Aide from translating selected text.</p>
                                </div>
                            </div>
                            <p class="lrn-qe-padding-top-sm"><label class="lrn-qe-label lrn-qe-form-label">Removing these settings</label></p>
                            <ul>
                                <li>For words or sentences, highlight the text and use the clear formatting button in the toolbar.</li>
                                <li>For entire paragraph(s), right click anywhere in the text and choose "Remove Style" from the menu.</li>
                            </ul>
                        </div>
                        <div class="lrn-qe-modal-footer">
                            <ul class="lrn-qe-ul">
                                <li class="lrn-qe-li lrn-qe-modal-footer-item lrn-qe-float-left">
                                    <button type="button" class="lrn-qe-btn lrn-qe-btn-default"><span>Cancel</span></button>
                                </li>&nbsp;
                                <li class="lrn-qe-li lrn-qe-modal-footer-item">
                                    <button type="button" class="lrn-qe-btn lrn-qe-btn-primary" data-lrn-qe-modal-action="confirm"><span>Apply</span></button>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    `;
}
function getReturnTemplate(le, Y, re, oe) {
  let ue = "", fe = "";
  if (le?.code && (ue += ` lang="${le.code}" dir="${le.direction}"`), le?.noTranslate && (ue += ' translate="no"'), Y === "block")
    switch (numParagraphsInString(re)) {
      // Selecting a single line strips the surrounding <p></p>.
      // We add an empty <p> so that we can add the correct
      // attributes to the <p> element.
      case 0:
        fe = `<p${ue}>${re}</p><p>&nbsp;</p>`;
        break;
      case 1:
        fe = re.replace("<p", `<p${ue}`);
        break;
      default:
        fe = `<div${ue}>${re}</div>`;
        break;
    }
  else
    oe.replace(/&nbsp;/g, "").includes(`<p>${re.replace(/&nbsp;/g, "")}</p>`) ? fe = `<div${ue}><p>${re}</p></div>` : re.length && (fe = `<span${ue}>${re}</span>`);
  return fe;
}
function getLanguageCodes() {
  return [
    {
      language: "Afrikaans",
      code: "af",
      direction: "ltr"
    },
    {
      language: "Albanian",
      code: "sq",
      direction: "ltr"
    },
    {
      language: "Amharic",
      code: "am",
      direction: "ltr"
    },
    {
      language: "Arabic",
      code: "ar",
      direction: "rtl"
    },
    {
      language: "Armenian",
      code: "hy",
      direction: "ltr"
    },
    {
      language: "Azerbaijani",
      code: "az",
      direction: "ltr"
    },
    {
      language: "Basque",
      code: "eu",
      direction: "ltr"
    },
    {
      language: "Belarusian",
      code: "be",
      direction: "ltr"
    },
    {
      language: "Bengali",
      code: "bn",
      direction: "ltr"
    },
    {
      language: "Bosnian",
      code: "bs",
      direction: "ltr"
    },
    {
      language: "Bulgarian",
      code: "bg",
      direction: "ltr"
    },
    {
      language: "Catalan",
      code: "ca",
      direction: "ltr"
    },
    {
      language: "Cebuano",
      code: "ceb",
      direction: "ltr"
    },
    {
      language: "Chichewa",
      code: "ny",
      direction: "ltr"
    },
    {
      language: "Chinese (Simplified)",
      code: "zh-Hans",
      direction: "ltr"
    },
    {
      language: "Chinese (Traditional)",
      code: "zh-Hant",
      direction: "ltr"
    },
    {
      language: "Corsican",
      code: "co",
      direction: "ltr"
    },
    {
      language: "Haitian Creole",
      code: "ht",
      direction: "ltr"
    },
    {
      language: "Croatian",
      code: "hr",
      direction: "ltr"
    },
    {
      language: "Czech",
      code: "cs",
      direction: "ltr"
    },
    {
      language: "Danish",
      code: "da",
      direction: "ltr"
    },
    {
      language: "Dutch",
      code: "nl",
      direction: "ltr"
    },
    {
      language: "English",
      code: "en",
      direction: "ltr"
    },
    {
      language: "Esperanto",
      code: "eo",
      direction: "ltr"
    },
    {
      language: "Estonian",
      code: "et",
      direction: "ltr"
    },
    {
      language: "Finnish",
      code: "fi",
      direction: "ltr"
    },
    {
      language: "French",
      code: "fr",
      direction: "ltr"
    },
    {
      language: "Frisian",
      code: "fy",
      direction: "ltr"
    },
    {
      language: "Galician",
      code: "gl",
      direction: "ltr"
    },
    {
      language: "Georgian",
      code: "ka",
      direction: "ltr"
    },
    {
      language: "German",
      code: "de",
      direction: "ltr"
    },
    {
      language: "Greek",
      code: "el",
      direction: "ltr"
    },
    {
      language: "Gujarati",
      code: "gu",
      direction: "ltr"
    },
    {
      language: "Hausa",
      code: "ha",
      direction: "ltr"
    },
    {
      language: "Hawaiian",
      code: "haw",
      direction: "ltr"
    },
    {
      language: "Hebrew",
      code: "he",
      direction: "rtl"
    },
    {
      language: "Hindi",
      code: "hi",
      direction: "ltr"
    },
    {
      language: "Hmong",
      code: "hmn",
      direction: "ltr"
    },
    {
      language: "Hungarian",
      code: "hu",
      direction: "ltr"
    },
    {
      language: "Icelandic",
      code: "is",
      direction: "ltr"
    },
    {
      language: "Igbo",
      code: "ig",
      direction: "ltr"
    },
    {
      language: "Indonesian",
      code: "id",
      direction: "ltr"
    },
    {
      language: "Irish",
      code: "ga",
      direction: "ltr"
    },
    {
      language: "Italian",
      code: "it",
      direction: "ltr"
    },
    {
      language: "Japanese",
      code: "ja",
      direction: "ltr"
    },
    {
      language: "Javanese",
      code: "jv",
      direction: "ltr"
    },
    {
      language: "Kannada",
      code: "kn",
      direction: "ltr"
    },
    {
      language: "Kazakh",
      code: "kk",
      direction: "ltr"
    },
    {
      language: "Khmer",
      code: "km",
      direction: "ltr"
    },
    {
      language: "Kinyarwanda",
      code: "rw",
      direction: "ltr"
    },
    {
      language: "Korean",
      code: "ko",
      direction: "ltr"
    },
    {
      language: "Kurdish (Kurmanji)",
      code: "ku",
      direction: "ltr"
    },
    {
      language: "Kyrgyz",
      code: "ky",
      direction: "ltr"
    },
    {
      language: "Lao",
      code: "lo",
      direction: "ltr"
    },
    {
      language: "Latin",
      code: "la",
      direction: "ltr"
    },
    {
      language: "Latvian",
      code: "lv",
      direction: "ltr"
    },
    {
      language: "Lithuanian",
      code: "lt",
      direction: "ltr"
    },
    {
      language: "Luxembourgish",
      code: "lb",
      direction: "ltr"
    },
    {
      language: "Macedonian",
      code: "mk",
      direction: "ltr"
    },
    {
      language: "Malagasy",
      code: "mg",
      direction: "ltr"
    },
    {
      language: "Malay",
      code: "ms",
      direction: "ltr"
    },
    {
      language: "Malayalam",
      code: "ml",
      direction: "ltr"
    },
    {
      language: "Maltese",
      code: "mt",
      direction: "ltr"
    },
    {
      language: "Maori",
      code: "mi",
      direction: "ltr"
    },
    {
      language: "Marathi",
      code: "mr",
      direction: "ltr"
    },
    {
      language: "Mongolian",
      code: "mn",
      direction: "ltr"
    },
    {
      language: "Myanmar (Burmese)",
      code: "my",
      direction: "ltr"
    },
    {
      language: "Nepali",
      code: "ne",
      direction: "ltr"
    },
    {
      language: "Norwegian",
      code: "no",
      direction: "ltr"
    },
    {
      language: "Odia",
      code: "or",
      direction: "ltr"
    },
    {
      language: "Pashto",
      code: "ps",
      direction: "rtl"
    },
    {
      language: "Persian",
      code: "fa",
      direction: "rtl"
    },
    {
      language: "Polish",
      code: "pl",
      direction: "ltr"
    },
    {
      language: "Portuguese",
      code: "pt",
      direction: "ltr"
    },
    {
      language: "Punjabi",
      code: "pa",
      direction: "ltr"
    },
    {
      language: "Romanian",
      code: "ro",
      direction: "ltr"
    },
    {
      language: "Russian",
      code: "ru",
      direction: "ltr"
    },
    {
      language: "Samoan",
      code: "sm",
      direction: "ltr"
    },
    {
      language: "Scots Gaelic",
      code: "gd",
      direction: "ltr"
    },
    {
      language: "Serbian Cyrilic",
      code: "sr-Cyrl",
      direction: "ltr"
    },
    {
      language: "Sesotho",
      code: "st",
      direction: "ltr"
    },
    {
      language: "Shona",
      code: "sn",
      direction: "ltr"
    },
    {
      language: "Sindhi",
      code: "sd",
      direction: "rtl"
    },
    {
      language: "Sinhala",
      code: "si",
      direction: "ltr"
    },
    {
      language: "Slovak",
      code: "sk",
      direction: "ltr"
    },
    {
      language: "Slovenian",
      code: "sl",
      direction: "ltr"
    },
    {
      language: "Somali",
      code: "so",
      direction: "ltr"
    },
    {
      language: "Spanish",
      code: "es",
      direction: "ltr"
    },
    {
      language: "Sundanese",
      code: "su",
      direction: "ltr"
    },
    {
      language: "Swahili",
      code: "sw",
      direction: "ltr"
    },
    {
      language: "Swedish",
      code: "sv",
      direction: "ltr"
    },
    {
      language: "Filipino (Tagalog)",
      code: "tl",
      direction: "ltr"
    },
    {
      language: "Tajik",
      code: "tg",
      direction: "ltr"
    },
    {
      language: "Tamil",
      code: "ta",
      direction: "ltr"
    },
    {
      language: "Tatar",
      code: "tt",
      direction: "ltr"
    },
    {
      language: "Telugu",
      code: "te",
      direction: "ltr"
    },
    {
      language: "Thai",
      code: "th",
      direction: "ltr"
    },
    {
      language: "Turkish",
      code: "tr",
      direction: "ltr"
    },
    {
      language: "Turkmen",
      code: "tk",
      direction: "ltr"
    },
    {
      language: "Ukrainian",
      code: "uk",
      direction: "ltr"
    },
    {
      language: "Urdu",
      code: "ur",
      direction: "rtl"
    },
    {
      language: "Uyghur",
      code: "ug",
      direction: "rtl"
    },
    {
      language: "Uzbek",
      code: "uz",
      direction: "ltr"
    },
    {
      language: "Vietnamese",
      code: "vi",
      direction: "ltr"
    },
    {
      language: "Welsh",
      code: "cy",
      direction: "ltr"
    },
    {
      language: "Xhosa",
      code: "xh",
      direction: "ltr"
    },
    {
      language: "Yiddish",
      code: "yi",
      direction: "rtl"
    },
    {
      language: "Yoruba",
      code: "yo",
      direction: "ltr"
    },
    {
      language: "Zulu",
      code: "zu",
      direction: "ltr"
    }
  ];
}
function numParagraphsInString(le) {
  const Y = /<p>.*?<\/p>/gs, re = le.match(Y);
  return re ? re.length : 0;
}
function getLinebreakType(le) {
  return numParagraphsInString(le) <= 1 ? "inline" : "block";
}
function injectCSS$3() {
  const le = document.createElement("style"), Y = `
/* Learnosity language and no translation styles */
/* Used to see elements inside the rich-text editor that have language or translate styles applied */
.lrn.lrn-author .lt__languageModal {
    h4 {
        font-size: 1.43em;
    }

    label {
        font-weight: bold;
    }

    input[type="checkbox"] {
        height: 16px;
        width: 16px;
        vertical-align: text-bottom;
        margin: 0;
    }

    .lt__border {
        border: 1px solid #eaeaea;
    }
}

.lrn-qe-form-group-wrapper {
    .lrn-qe-form-control-ckeditor *[translate],
    .lrn-qe-form-control-ckeditor *[lang] {
        border: 2px dashed #696969;
        padding: 5px;
        position: relative;
    }

    .lrn-qe .lrn-qe-ui div[translate],
    .lrn-qe .lrn-qe-ui div[lang] {
        margin-bottom: 1em;

        p:last-child {
            margin-bottom: 0;
        }
    }

    .lrn-qe-form-control-ckeditor *[translate]::after,
    .lrn-qe-form-control-ckeditor *[lang]::after {
        content: "No translate";
        position: absolute;
        left: 100px;
        top: 0;
        transform: translateX(-50%);
        background-color: #333;
        color: #fff;
        padding: 5px;
        border-radius: 4px;
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s;
        z-index: 10000000;
    }

    .lrn-qe-form-control-ckeditor *[lang]::after {
        content: "Language";
    }

    .lrn-qe-form-control-ckeditor *[translate][lang]::after {
        content: "No translate and Language";
    }

    /* Show tooltip on hover */
    .lrn-qe-form-control-ckeditor *[translate]:hover::after,
    .lrn-qe-form-control-ckeditor *[lang]:hover::after {
        opacity: 1;
        visibility: visible;
    }

    /* Force the icon to be the right size */
    .lrn-qe-ckeditor-toolbar .cke_button__addlanguageattribute .cke_button__addlanguageattribute_icon {
        background-position: -3px !important;
        background-size: 22px !important;
    }

    /* Size the "content" textarea and make is resizable */
    .lrn-qe .lrn-qe-modal-content .lrn-qe-form-group-wrapper textarea#lrn__ltd_content {
        resize: vertical;
        min-height: 4em;
    }
}
`;
  le.setAttribute("data-style", "LT Language Text Direction"), le.textContent = Y, document.head.append(le), state$5.renderedCss = !0;
}
const languageTextDirection = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addLanguageAttribute,
  run: run$5
}, Symbol.toStringTag, { value: "Module" })), state$4 = {
  columns: {
    numTabsLeft: 2,
    numTabsRight: 2
  },
  dirty: !1,
  logPrefix: "LT Native Tabs: ",
  options: {
    maxTabs: 5
  },
  renderedCss: !1
};
function run$4(le = {}) {
  state$4.renderedCss || injectCSS$2(), overrideOptions(le), appInstance().on("render:item", () => {
    state$4.columns.numTabsLeft = 2, state$4.columns.numTabsRight = 2, state$4.dirty = !1;
  }), appInstance().on("navigate", Y);
  function Y() {
    setTimeout(() => {
      if (["items/:reference/settings/:tab", "items/:reference/settings", void 0].includes(appInstance().getLocation().route)) {
        const re = appInstance().getLocation().location.split("/").pop();
        ["layout", "settings"].includes(re) && setup();
      }
    }, 100);
  }
}
function setup() {
  const le = document.querySelector('[data-authorapi-selector="lrn-author-tabs-col1"]'), Y = document.querySelector('[data-authorapi-selector="lrn-author-tabs-col2"]'), re = document.getElementById("lt__nativeTabs-col1"), oe = document.getElementById("lt__nativeTabs-col2"), ue = document.querySelector('[data-authorapi-selector="lrn-author-apply-settings"]'), fe = appInstance().getItem(), he = countTabs(fe.item.definition);
  state$4.columns.numTabsLeft = max([he[0], state$4.columns.numTabsLeft]), state$4.columns.numTabsRight = max([he[1], state$4.columns.numTabsRight]), ue ? (!re && le && le.querySelector(".lrn-author-layout-content").insertAdjacentHTML("beforeend", _e("col1", state$4.columns.numTabsLeft)), !oe && Y && Y.querySelector(".lrn-author-layout-content").insertAdjacentHTML("beforeend", _e("col2", state$4.columns.numTabsRight)), setNumColumnsState(), ue.addEventListener("click", () => {
    saveTabsToItem(he);
  })) : logger.warn(`${state$4.logPrefix}Settings apply button not found`);
  function _e(ve, xe) {
    return `
            <label class="lrn-author-checkbox-label" for="lt__nativeTabs-${ve}">
                <span class="label-full">Number of tabs</span>
                <span class="label-short">Num tabs</span>
            </label>
            <div class="lrn-form-group">
                <input id="lt__nativeTabs-${ve}" class="lrn-author-form-control lt__nativeTabsInput" type="number" min="2" max="${state$4.options.maxTabs}" value="${xe}" class="lrn-form-control lt__width-sm">
            </div>
        `;
  }
}
function checkApplyButtonEnabled() {
  if (state$4.dirty) {
    const le = document.querySelector('[data-authorapi-selector="lrn-author-apply-settings"]');
    if (le && le.disabled) {
      const Y = document.querySelector('[data-authorapi-selector="itemLayoutTabLabel - Left"]'), re = document.querySelector('[data-authorapi-selector="itemLayoutTabLabel - Right"]');
      if (Y.checked) {
        Y.click(), Y.click();
        return;
      }
      re.checked && (re.click(), re.click());
    }
  }
}
function checkTabsEnabled() {
  const le = document.querySelector('[data-authorapi-selector="itemLayoutTabLabel - Left"]'), Y = document.querySelector('[data-authorapi-selector="itemLayoutTabLabel - Right"]');
  return le.checked || (state$4.columns.numTabsLeft = 2), Y.checked || (state$4.columns.numTabsRight = 2), {
    leftEnabled: le.checked,
    rightEnabled: Y.checked
  };
}
function countTabs(le) {
  const Y = [0, 0];
  function re(ue) {
    let fe = 0;
    function he(_e) {
      if (Array.isArray(_e))
        _e.forEach(he);
      else if (typeof _e == "object" && _e !== null) {
        _e.type === "tab" && fe++;
        for (const ve in _e)
          _e.hasOwnProperty(ve) && he(_e[ve]);
      }
    }
    return he(ue), fe;
  }
  const oe = le.regions?.filter((ue) => ue.type === "column") || [];
  for (let ue = 0; ue < 2; ue++)
    oe[ue] && (Y[ue] = re(oe[ue]));
  return Y;
}
function saveTabsToItem(le) {
  const Y = checkTabsEnabled();
  setTimeout(() => {
    const oe = appInstance().getItem(), ue = oe.item.definition;
    re(0, state$4.columns.numTabsLeft, Y.leftEnabled, le[0], ue), re(1, state$4.columns.numTabsRight, Y.rightEnabled, le[1], ue), oe.item.definition = ue, appInstance().setItemJson(oe);
  }, 100);
  function re(oe, ue, fe, he, _e) {
    if (ue >= 2 && fe) {
      const ve = _e.regions[oe].regions[0].regions;
      if (ue < ve.length) {
        const xe = ve.length - ue;
        for (let Ee = ve.length; Ee > ve.length - xe; Ee--)
          ve[Ee - 1].hasOwnProperty("widgets") && (ve[0].hasOwnProperty("widgets") ? ve[0].widgets.push(ve[Ee - 1].widgets) : ve[0].widgets = ve[Ee - 1].widgets);
        ve.splice(-xe);
      } else {
        const xe = (he || 2) + 1;
        for (let Ee = xe; Ee <= ue; Ee++)
          ve.push({
            label: `Tab ${Ee}`,
            type: "tab"
          });
      }
    }
  }
}
function setNumColumnsState() {
  const le = document.getElementById("lt__nativeTabs-col1"), Y = document.getElementById("lt__nativeTabs-col2");
  le.addEventListener("change", () => {
    state$4.columns.numTabsLeft = validateNumTabs(+le.value), state$4.dirty = !0, checkApplyButtonEnabled();
  }), Y.addEventListener("change", () => {
    state$4.columns.numTabsRight = validateNumTabs(+Y.value), state$4.dirty = !0, checkApplyButtonEnabled();
  });
}
function validateNumTabs(le) {
  return le < 2 ? 2 : le > state$4.options.maxTabs ? state$4.options.maxTabs : le;
}
function overrideOptions(le) {
  ["maxTabs"].forEach((Y) => {
    typeof le?.[Y] == "number" && le?.[Y] >= 2 && le?.[Y] <= 10 && (state$4.options[Y] = le[Y]);
  });
}
function injectCSS$2() {
  const le = document.createElement("style"), Y = `
/* Learnosity native tab styles */
.lrn .lrn-author-ui,
.lrn.lrn-author {
    .lrn-author-api-react-container .lrn-author-item-settings .lrn-author-layout-settings .lrn-author-layout-tab .lrn-author-layout-content,
    .lrn-author-api-react-container .lrn-author-activity-labels .lrn-author-layout-settings .lrn-author-layout-tab .lrn-author-layout-content {
        padding: 9px;
    }

    .lrn-form-control.lt__width-sm,
    .lrn-author-form-control.lt__nativeTabsInput {
        width: 80px;
    }

    .lrn-author-checkbox-label {
        padding-bottom: .5714285714em;
    }

    [data-authorapi-selector="lrn-author-tabs-col1"],
    [data-authorapi-selector="lrn-author-tabs-col2"] {
        .lrn-author-layout-content {
            container-type: inline-size;

            .label-short {
                display: none;
            }

            @container (max-width: 120px) {
                .label-full {
                    display: none;
                }

                .label-short {
                    display: inline;
                }
            }
        }
    }
}
`;
  le.setAttribute("data-style", "LT Native Tabs"), le.textContent = Y, document.head.append(le), state$4.renderedCss = !0;
}
const nativeTabs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  run: run$4
}, Symbol.toStringTag, { value: "Module" })), state$3 = {
  renderedCss: !1
};
function run$3() {
  state$3.renderedCss || injectCSS$1(), appInstance().on("widgetedit:widget:ready", () => {
    document.querySelectorAll(".cke_button__lrnresource").forEach((Y) => {
      logger.debug("Found resource button in editor"), Y.addEventListener("click", () => {
        addRenderOption();
      });
    });
  });
}
function addRenderOption() {
  const le = document.querySelector(".lrn-adv-options-group"), Y = generateRandomString(), re = `<div class="lrn-row">
        <div class="lrn-col-xs-12">
            <label for="lt__renderPDF-Id_${Y}" class="lrn-author-asset-upload lrn-form-label-name">
                <span class="lrn-author-asset-upload lrn-form-label-name">Render PDF inline?</span>
            </label>
            <div class="lrn-form-control-wrapper">
                <input id="lt__renderPDF-Id_${Y}" name="renderPDF" value="true" type="checkbox" class="lrn-form-control lt__renderPDFOption">
            </div>
        </div>
    </div>`;
  le && le.insertAdjacentHTML("beforeend", re);
}
function generateRandomString() {
  return Math.floor(Math.random() * Date.now()).toString(36);
}
function injectCSS$1() {
  const le = document.createElement("style"), Y = `
/* Learnosity language text direction styles */
/* Used to style render PDF options added to the resource upload panel */
.lrn .lrn-author-ui .lrn-form-control.lt__renderPDFOption {
    width: auto;
}
`;
  le.textContent = Y, document.head.append(le), state$3.renderedCss = !0;
}
const renderPDF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  run: run$3
}, Symbol.toStringTag, { value: "Module" })), state$2 = {
  classNamePrefix: null,
  elements: {}
};
function run$2() {
  cacheElements(), appInstance().on("render:item", checkQuestions), appInstance().on("render:widgets", checkQuestions), appInstance().on("itemedit:changed", checkQuestions);
}
function checkQuestions() {
  state$2.classNamePrefix = checkAppVersion(state$2.classNamePrefix), appInstance().getItem().questions.length ? hideAddButton() : showAddButton();
}
function hideAddButton() {
  const le = state$2.elements.apiWrapper.querySelectorAll('[data-authorapi-selector="add-button"]'), Y = state$2.elements.apiWrapper.querySelectorAll(".lrn-author-ui-add-extras"), re = [...le, ...Y];
  re && re.forEach((oe) => {
    oe.classList.add(`lrn-${state$2.classNamePrefix}hide`);
  });
}
function showAddButton() {
  const le = state$2.elements.apiWrapper.querySelectorAll('[data-authorapi-selector="add-button"]'), Y = state$2.elements.apiWrapper.querySelectorAll(".lrn-author-ui-add-extras"), re = [...le, ...Y];
  re && re.forEach((oe) => {
    oe.classList.remove(`lrn-${state$2.classNamePrefix}hide`);
  });
}
function cacheElements() {
  state$2.elements.apiWrapper = document.querySelector(".lrn-author");
}
const singleQuestion = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  run: run$2
}, Symbol.toStringTag, { value: "Module" }));
var Scope = /* @__PURE__ */ ((le) => (le[le.TYPE = 3] = "TYPE", le[le.LEVEL = 12] = "LEVEL", le[le.ATTRIBUTE = 13] = "ATTRIBUTE", le[le.BLOT = 14] = "BLOT", le[le.INLINE = 7] = "INLINE", le[le.BLOCK = 11] = "BLOCK", le[le.BLOCK_BLOT = 10] = "BLOCK_BLOT", le[le.INLINE_BLOT = 6] = "INLINE_BLOT", le[le.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE", le[le.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE", le[le.ANY = 15] = "ANY", le))(Scope || {});
class Attributor {
  constructor(Y, re, oe = {}) {
    this.attrName = Y, this.keyName = re;
    const ue = Scope.TYPE & Scope.ATTRIBUTE;
    this.scope = oe.scope != null ? (
      // Ignore type bits, force attribute bit
      oe.scope & Scope.LEVEL | ue
    ) : Scope.ATTRIBUTE, oe.whitelist != null && (this.whitelist = oe.whitelist);
  }
  static keys(Y) {
    return Array.from(Y.attributes).map((re) => re.name);
  }
  add(Y, re) {
    return this.canAdd(Y, re) ? (Y.setAttribute(this.keyName, re), !0) : !1;
  }
  canAdd(Y, re) {
    return this.whitelist == null ? !0 : typeof re == "string" ? this.whitelist.indexOf(re.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(re) > -1;
  }
  remove(Y) {
    Y.removeAttribute(this.keyName);
  }
  value(Y) {
    const re = Y.getAttribute(this.keyName);
    return this.canAdd(Y, re) && re ? re : "";
  }
}
class ParchmentError extends Error {
  constructor(Y) {
    Y = "[Parchment] " + Y, super(Y), this.message = Y, this.name = this.constructor.name;
  }
}
const _Registry = class Vi {
  constructor() {
    this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};
  }
  static find(Y, re = !1) {
    if (Y == null)
      return null;
    if (this.blots.has(Y))
      return this.blots.get(Y) || null;
    if (re) {
      let oe = null;
      try {
        oe = Y.parentNode;
      } catch {
        return null;
      }
      return this.find(oe, re);
    }
    return null;
  }
  create(Y, re, oe) {
    const ue = this.query(re);
    if (ue == null)
      throw new ParchmentError(`Unable to create ${re} blot`);
    const fe = ue, he = (
      // @ts-expect-error Fix me later
      re instanceof Node || re.nodeType === Node.TEXT_NODE ? re : fe.create(oe)
    ), _e = new fe(Y, he, oe);
    return Vi.blots.set(_e.domNode, _e), _e;
  }
  find(Y, re = !1) {
    return Vi.find(Y, re);
  }
  query(Y, re = Scope.ANY) {
    let oe;
    return typeof Y == "string" ? oe = this.types[Y] || this.attributes[Y] : Y instanceof Text || Y.nodeType === Node.TEXT_NODE ? oe = this.types.text : typeof Y == "number" ? Y & Scope.LEVEL & Scope.BLOCK ? oe = this.types.block : Y & Scope.LEVEL & Scope.INLINE && (oe = this.types.inline) : Y instanceof Element && ((Y.getAttribute("class") || "").split(/\s+/).some((ue) => (oe = this.classes[ue], !!oe)), oe = oe || this.tags[Y.tagName]), oe == null ? null : "scope" in oe && re & Scope.LEVEL & oe.scope && re & Scope.TYPE & oe.scope ? oe : null;
  }
  register(...Y) {
    return Y.map((re) => {
      const oe = "blotName" in re, ue = "attrName" in re;
      if (!oe && !ue)
        throw new ParchmentError("Invalid definition");
      if (oe && re.blotName === "abstract")
        throw new ParchmentError("Cannot register abstract class");
      const fe = oe ? re.blotName : ue ? re.attrName : void 0;
      return this.types[fe] = re, ue ? typeof re.keyName == "string" && (this.attributes[re.keyName] = re) : oe && (re.className && (this.classes[re.className] = re), re.tagName && (Array.isArray(re.tagName) ? re.tagName = re.tagName.map((he) => he.toUpperCase()) : re.tagName = re.tagName.toUpperCase(), (Array.isArray(re.tagName) ? re.tagName : [re.tagName]).forEach((he) => {
        (this.tags[he] == null || re.className == null) && (this.tags[he] = re);
      }))), re;
    });
  }
};
_Registry.blots = /* @__PURE__ */ new WeakMap();
let Registry = _Registry;
function match(le, Y) {
  return (le.getAttribute("class") || "").split(/\s+/).filter((re) => re.indexOf(`${Y}-`) === 0);
}
class ClassAttributor extends Attributor {
  static keys(Y) {
    return (Y.getAttribute("class") || "").split(/\s+/).map((re) => re.split("-").slice(0, -1).join("-"));
  }
  add(Y, re) {
    return this.canAdd(Y, re) ? (this.remove(Y), Y.classList.add(`${this.keyName}-${re}`), !0) : !1;
  }
  remove(Y) {
    match(Y, this.keyName).forEach((re) => {
      Y.classList.remove(re);
    }), Y.classList.length === 0 && Y.removeAttribute("class");
  }
  value(Y) {
    const re = (match(Y, this.keyName)[0] || "").slice(this.keyName.length + 1);
    return this.canAdd(Y, re) ? re : "";
  }
}
const ClassAttributor$1 = ClassAttributor;
function camelize(le) {
  const Y = le.split("-"), re = Y.slice(1).map((oe) => oe[0].toUpperCase() + oe.slice(1)).join("");
  return Y[0] + re;
}
class StyleAttributor extends Attributor {
  static keys(Y) {
    return (Y.getAttribute("style") || "").split(";").map((re) => re.split(":")[0].trim());
  }
  add(Y, re) {
    return this.canAdd(Y, re) ? (Y.style[camelize(this.keyName)] = re, !0) : !1;
  }
  remove(Y) {
    Y.style[camelize(this.keyName)] = "", Y.getAttribute("style") || Y.removeAttribute("style");
  }
  value(Y) {
    const re = Y.style[camelize(this.keyName)];
    return this.canAdd(Y, re) ? re : "";
  }
}
const StyleAttributor$1 = StyleAttributor;
class AttributorStore {
  constructor(Y) {
    this.attributes = {}, this.domNode = Y, this.build();
  }
  attribute(Y, re) {
    re ? Y.add(this.domNode, re) && (Y.value(this.domNode) != null ? this.attributes[Y.attrName] = Y : delete this.attributes[Y.attrName]) : (Y.remove(this.domNode), delete this.attributes[Y.attrName]);
  }
  build() {
    this.attributes = {};
    const Y = Registry.find(this.domNode);
    if (Y == null)
      return;
    const re = Attributor.keys(this.domNode), oe = ClassAttributor$1.keys(this.domNode), ue = StyleAttributor$1.keys(this.domNode);
    re.concat(oe).concat(ue).forEach((fe) => {
      const he = Y.scroll.query(fe, Scope.ATTRIBUTE);
      he instanceof Attributor && (this.attributes[he.attrName] = he);
    });
  }
  copy(Y) {
    Object.keys(this.attributes).forEach((re) => {
      const oe = this.attributes[re].value(this.domNode);
      Y.format(re, oe);
    });
  }
  move(Y) {
    this.copy(Y), Object.keys(this.attributes).forEach((re) => {
      this.attributes[re].remove(this.domNode);
    }), this.attributes = {};
  }
  values() {
    return Object.keys(this.attributes).reduce(
      (Y, re) => (Y[re] = this.attributes[re].value(this.domNode), Y),
      {}
    );
  }
}
const AttributorStore$1 = AttributorStore, _ShadowBlot = class {
  constructor(Y, re) {
    this.scroll = Y, this.domNode = re, Registry.blots.set(re, this), this.prev = null, this.next = null;
  }
  static create(Y) {
    if (this.tagName == null)
      throw new ParchmentError("Blot definition missing tagName");
    let re, oe;
    return Array.isArray(this.tagName) ? (typeof Y == "string" ? (oe = Y.toUpperCase(), parseInt(oe, 10).toString() === oe && (oe = parseInt(oe, 10))) : typeof Y == "number" && (oe = Y), typeof oe == "number" ? re = document.createElement(this.tagName[oe - 1]) : oe && this.tagName.indexOf(oe) > -1 ? re = document.createElement(oe) : re = document.createElement(this.tagName[0])) : re = document.createElement(this.tagName), this.className && re.classList.add(this.className), re;
  }
  // Hack for accessing inherited static methods
  get statics() {
    return this.constructor;
  }
  attach() {
  }
  clone() {
    const Y = this.domNode.cloneNode(!1);
    return this.scroll.create(Y);
  }
  detach() {
    this.parent != null && this.parent.removeChild(this), Registry.blots.delete(this.domNode);
  }
  deleteAt(Y, re) {
    this.isolate(Y, re).remove();
  }
  formatAt(Y, re, oe, ue) {
    const fe = this.isolate(Y, re);
    if (this.scroll.query(oe, Scope.BLOT) != null && ue)
      fe.wrap(oe, ue);
    else if (this.scroll.query(oe, Scope.ATTRIBUTE) != null) {
      const he = this.scroll.create(this.statics.scope);
      fe.wrap(he), he.format(oe, ue);
    }
  }
  insertAt(Y, re, oe) {
    const ue = oe == null ? this.scroll.create("text", re) : this.scroll.create(re, oe), fe = this.split(Y);
    this.parent.insertBefore(ue, fe || void 0);
  }
  isolate(Y, re) {
    const oe = this.split(Y);
    if (oe == null)
      throw new Error("Attempt to isolate at end");
    return oe.split(re), oe;
  }
  length() {
    return 1;
  }
  offset(Y = this.parent) {
    return this.parent == null || this === Y ? 0 : this.parent.children.offset(this) + this.parent.offset(Y);
  }
  optimize(Y) {
    this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);
  }
  remove() {
    this.domNode.parentNode != null && this.domNode.parentNode.removeChild(this.domNode), this.detach();
  }
  replaceWith(Y, re) {
    const oe = typeof Y == "string" ? this.scroll.create(Y, re) : Y;
    return this.parent != null && (this.parent.insertBefore(oe, this.next || void 0), this.remove()), oe;
  }
  split(Y, re) {
    return Y === 0 ? this : this.next;
  }
  update(Y, re) {
  }
  wrap(Y, re) {
    const oe = typeof Y == "string" ? this.scroll.create(Y, re) : Y;
    if (this.parent != null && this.parent.insertBefore(oe, this.next || void 0), typeof oe.appendChild != "function")
      throw new ParchmentError(`Cannot wrap ${Y}`);
    return oe.appendChild(this), oe;
  }
};
_ShadowBlot.blotName = "abstract";
let ShadowBlot = _ShadowBlot;
const _LeafBlot = class extends ShadowBlot {
  /**
   * Returns the value represented by domNode if it is this Blot's type
   * No checking that domNode can represent this Blot type is required so
   * applications needing it should check externally before calling.
   */
  static value(Y) {
    return !0;
  }
  /**
   * Given location represented by node and offset from DOM Selection Range,
   * return index to that location.
   */
  index(Y, re) {
    return this.domNode === Y || this.domNode.compareDocumentPosition(Y) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(re, 1) : -1;
  }
  /**
   * Given index to location within blot, return node and offset representing
   * that location, consumable by DOM Selection Range
   */
  position(Y, re) {
    let oe = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);
    return Y > 0 && (oe += 1), [this.parent.domNode, oe];
  }
  /**
   * Return value represented by this blot
   * Should not change without interaction from API or
   * user change detectable by update()
   */
  value() {
    return {
      [this.statics.blotName]: this.statics.value(this.domNode) || !0
    };
  }
};
_LeafBlot.scope = Scope.INLINE_BLOT;
let LeafBlot = _LeafBlot;
const LeafBlot$1 = LeafBlot;
class LinkedList {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  append(...Y) {
    if (this.insertBefore(Y[0], null), Y.length > 1) {
      const re = Y.slice(1);
      this.append(...re);
    }
  }
  at(Y) {
    const re = this.iterator();
    let oe = re();
    for (; oe && Y > 0; )
      Y -= 1, oe = re();
    return oe;
  }
  contains(Y) {
    const re = this.iterator();
    let oe = re();
    for (; oe; ) {
      if (oe === Y)
        return !0;
      oe = re();
    }
    return !1;
  }
  indexOf(Y) {
    const re = this.iterator();
    let oe = re(), ue = 0;
    for (; oe; ) {
      if (oe === Y)
        return ue;
      ue += 1, oe = re();
    }
    return -1;
  }
  insertBefore(Y, re) {
    Y != null && (this.remove(Y), Y.next = re, re != null ? (Y.prev = re.prev, re.prev != null && (re.prev.next = Y), re.prev = Y, re === this.head && (this.head = Y)) : this.tail != null ? (this.tail.next = Y, Y.prev = this.tail, this.tail = Y) : (Y.prev = null, this.head = this.tail = Y), this.length += 1);
  }
  offset(Y) {
    let re = 0, oe = this.head;
    for (; oe != null; ) {
      if (oe === Y)
        return re;
      re += oe.length(), oe = oe.next;
    }
    return -1;
  }
  remove(Y) {
    this.contains(Y) && (Y.prev != null && (Y.prev.next = Y.next), Y.next != null && (Y.next.prev = Y.prev), Y === this.head && (this.head = Y.next), Y === this.tail && (this.tail = Y.prev), this.length -= 1);
  }
  iterator(Y = this.head) {
    return () => {
      const re = Y;
      return Y != null && (Y = Y.next), re;
    };
  }
  find(Y, re = !1) {
    const oe = this.iterator();
    let ue = oe();
    for (; ue; ) {
      const fe = ue.length();
      if (Y < fe || re && Y === fe && (ue.next == null || ue.next.length() !== 0))
        return [ue, Y];
      Y -= fe, ue = oe();
    }
    return [null, 0];
  }
  forEach(Y) {
    const re = this.iterator();
    let oe = re();
    for (; oe; )
      Y(oe), oe = re();
  }
  forEachAt(Y, re, oe) {
    if (re <= 0)
      return;
    const [ue, fe] = this.find(Y);
    let he = Y - fe;
    const _e = this.iterator(ue);
    let ve = _e();
    for (; ve && he < Y + re; ) {
      const xe = ve.length();
      Y > he ? oe(
        ve,
        Y - he,
        Math.min(re, he + xe - Y)
      ) : oe(ve, 0, Math.min(xe, Y + re - he)), he += xe, ve = _e();
    }
  }
  map(Y) {
    return this.reduce((re, oe) => (re.push(Y(oe)), re), []);
  }
  reduce(Y, re) {
    const oe = this.iterator();
    let ue = oe();
    for (; ue; )
      re = Y(re, ue), ue = oe();
    return re;
  }
}
function makeAttachedBlot(le, Y) {
  const re = Y.find(le);
  if (re)
    return re;
  try {
    return Y.create(le);
  } catch {
    const oe = Y.create(Scope.INLINE);
    return Array.from(le.childNodes).forEach((ue) => {
      oe.domNode.appendChild(ue);
    }), le.parentNode && le.parentNode.replaceChild(oe.domNode, le), oe.attach(), oe;
  }
}
const _ParentBlot = class _a extends ShadowBlot {
  constructor(Y, re) {
    super(Y, re), this.uiNode = null, this.build();
  }
  appendChild(Y) {
    this.insertBefore(Y);
  }
  attach() {
    super.attach(), this.children.forEach((Y) => {
      Y.attach();
    });
  }
  attachUI(Y) {
    this.uiNode != null && this.uiNode.remove(), this.uiNode = Y, _a.uiClass && this.uiNode.classList.add(_a.uiClass), this.uiNode.setAttribute("contenteditable", "false"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);
  }
  /**
   * Called during construction, should fill its own children LinkedList.
   */
  build() {
    this.children = new LinkedList(), Array.from(this.domNode.childNodes).filter((Y) => Y !== this.uiNode).reverse().forEach((Y) => {
      try {
        const re = makeAttachedBlot(Y, this.scroll);
        this.insertBefore(re, this.children.head || void 0);
      } catch (re) {
        if (re instanceof ParchmentError)
          return;
        throw re;
      }
    });
  }
  deleteAt(Y, re) {
    if (Y === 0 && re === this.length())
      return this.remove();
    this.children.forEachAt(Y, re, (oe, ue, fe) => {
      oe.deleteAt(ue, fe);
    });
  }
  descendant(Y, re = 0) {
    const [oe, ue] = this.children.find(re);
    return Y.blotName == null && Y(oe) || Y.blotName != null && oe instanceof Y ? [oe, ue] : oe instanceof _a ? oe.descendant(Y, ue) : [null, -1];
  }
  descendants(Y, re = 0, oe = Number.MAX_VALUE) {
    let ue = [], fe = oe;
    return this.children.forEachAt(
      re,
      oe,
      (he, _e, ve) => {
        (Y.blotName == null && Y(he) || Y.blotName != null && he instanceof Y) && ue.push(he), he instanceof _a && (ue = ue.concat(
          he.descendants(Y, _e, fe)
        )), fe -= ve;
      }
    ), ue;
  }
  detach() {
    this.children.forEach((Y) => {
      Y.detach();
    }), super.detach();
  }
  enforceAllowedChildren() {
    let Y = !1;
    this.children.forEach((re) => {
      Y || this.statics.allowedChildren.some(
        (oe) => re instanceof oe
      ) || (re.statics.scope === Scope.BLOCK_BLOT ? (re.next != null && this.splitAfter(re), re.prev != null && this.splitAfter(re.prev), re.parent.unwrap(), Y = !0) : re instanceof _a ? re.unwrap() : re.remove());
    });
  }
  formatAt(Y, re, oe, ue) {
    this.children.forEachAt(Y, re, (fe, he, _e) => {
      fe.formatAt(he, _e, oe, ue);
    });
  }
  insertAt(Y, re, oe) {
    const [ue, fe] = this.children.find(Y);
    if (ue)
      ue.insertAt(fe, re, oe);
    else {
      const he = oe == null ? this.scroll.create("text", re) : this.scroll.create(re, oe);
      this.appendChild(he);
    }
  }
  insertBefore(Y, re) {
    Y.parent != null && Y.parent.children.remove(Y);
    let oe = null;
    this.children.insertBefore(Y, re || null), Y.parent = this, re != null && (oe = re.domNode), (this.domNode.parentNode !== Y.domNode || this.domNode.nextSibling !== oe) && this.domNode.insertBefore(Y.domNode, oe), Y.attach();
  }
  length() {
    return this.children.reduce((Y, re) => Y + re.length(), 0);
  }
  moveChildren(Y, re) {
    this.children.forEach((oe) => {
      Y.insertBefore(oe, re);
    });
  }
  optimize(Y) {
    if (super.optimize(Y), this.enforceAllowedChildren(), this.uiNode != null && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), this.children.length === 0)
      if (this.statics.defaultChild != null) {
        const re = this.scroll.create(this.statics.defaultChild.blotName);
        this.appendChild(re);
      } else
        this.remove();
  }
  path(Y, re = !1) {
    const [oe, ue] = this.children.find(Y, re), fe = [[this, Y]];
    return oe instanceof _a ? fe.concat(oe.path(ue, re)) : (oe != null && fe.push([oe, ue]), fe);
  }
  removeChild(Y) {
    this.children.remove(Y);
  }
  replaceWith(Y, re) {
    const oe = typeof Y == "string" ? this.scroll.create(Y, re) : Y;
    return oe instanceof _a && this.moveChildren(oe), super.replaceWith(oe);
  }
  split(Y, re = !1) {
    if (!re) {
      if (Y === 0)
        return this;
      if (Y === this.length())
        return this.next;
    }
    const oe = this.clone();
    return this.parent && this.parent.insertBefore(oe, this.next || void 0), this.children.forEachAt(Y, this.length(), (ue, fe, he) => {
      const _e = ue.split(fe, re);
      _e != null && oe.appendChild(_e);
    }), oe;
  }
  splitAfter(Y) {
    const re = this.clone();
    for (; Y.next != null; )
      re.appendChild(Y.next);
    return this.parent && this.parent.insertBefore(re, this.next || void 0), re;
  }
  unwrap() {
    this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();
  }
  update(Y, re) {
    const oe = [], ue = [];
    Y.forEach((fe) => {
      fe.target === this.domNode && fe.type === "childList" && (oe.push(...fe.addedNodes), ue.push(...fe.removedNodes));
    }), ue.forEach((fe) => {
      if (fe.parentNode != null && // @ts-expect-error Fix me later
      fe.tagName !== "IFRAME" && document.body.compareDocumentPosition(fe) & Node.DOCUMENT_POSITION_CONTAINED_BY)
        return;
      const he = this.scroll.find(fe);
      he != null && (he.domNode.parentNode == null || he.domNode.parentNode === this.domNode) && he.detach();
    }), oe.filter((fe) => fe.parentNode === this.domNode && fe !== this.uiNode).sort((fe, he) => fe === he ? 0 : fe.compareDocumentPosition(he) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1).forEach((fe) => {
      let he = null;
      fe.nextSibling != null && (he = this.scroll.find(fe.nextSibling));
      const _e = makeAttachedBlot(fe, this.scroll);
      (_e.next !== he || _e.next == null) && (_e.parent != null && _e.parent.removeChild(this), this.insertBefore(_e, he || void 0));
    }), this.enforceAllowedChildren();
  }
};
_ParentBlot.uiClass = "";
let ParentBlot = _ParentBlot;
const ParentBlot$1 = ParentBlot;
function isEqual(le, Y) {
  if (Object.keys(le).length !== Object.keys(Y).length)
    return !1;
  for (const re in le)
    if (le[re] !== Y[re])
      return !1;
  return !0;
}
const _InlineBlot = class Xa extends ParentBlot$1 {
  static create(Y) {
    return super.create(Y);
  }
  static formats(Y, re) {
    const oe = re.query(Xa.blotName);
    if (!(oe != null && Y.tagName === oe.tagName)) {
      if (typeof this.tagName == "string")
        return !0;
      if (Array.isArray(this.tagName))
        return Y.tagName.toLowerCase();
    }
  }
  constructor(Y, re) {
    super(Y, re), this.attributes = new AttributorStore$1(this.domNode);
  }
  format(Y, re) {
    if (Y === this.statics.blotName && !re)
      this.children.forEach((oe) => {
        oe instanceof Xa || (oe = oe.wrap(Xa.blotName, !0)), this.attributes.copy(oe);
      }), this.unwrap();
    else {
      const oe = this.scroll.query(Y, Scope.INLINE);
      if (oe == null)
        return;
      oe instanceof Attributor ? this.attributes.attribute(oe, re) : re && (Y !== this.statics.blotName || this.formats()[Y] !== re) && this.replaceWith(Y, re);
    }
  }
  formats() {
    const Y = this.attributes.values(), re = this.statics.formats(this.domNode, this.scroll);
    return re != null && (Y[this.statics.blotName] = re), Y;
  }
  formatAt(Y, re, oe, ue) {
    this.formats()[oe] != null || this.scroll.query(oe, Scope.ATTRIBUTE) ? this.isolate(Y, re).format(oe, ue) : super.formatAt(Y, re, oe, ue);
  }
  optimize(Y) {
    super.optimize(Y);
    const re = this.formats();
    if (Object.keys(re).length === 0)
      return this.unwrap();
    const oe = this.next;
    oe instanceof Xa && oe.prev === this && isEqual(re, oe.formats()) && (oe.moveChildren(this), oe.remove());
  }
  replaceWith(Y, re) {
    const oe = super.replaceWith(Y, re);
    return this.attributes.copy(oe), oe;
  }
  update(Y, re) {
    super.update(Y, re), Y.some(
      (oe) => oe.target === this.domNode && oe.type === "attributes"
    ) && this.attributes.build();
  }
  wrap(Y, re) {
    const oe = super.wrap(Y, re);
    return oe instanceof Xa && this.attributes.move(oe), oe;
  }
};
_InlineBlot.allowedChildren = [_InlineBlot, LeafBlot$1], _InlineBlot.blotName = "inline", _InlineBlot.scope = Scope.INLINE_BLOT, _InlineBlot.tagName = "SPAN";
let InlineBlot = _InlineBlot;
const InlineBlot$1 = InlineBlot, _BlockBlot = class Gi extends ParentBlot$1 {
  static create(Y) {
    return super.create(Y);
  }
  static formats(Y, re) {
    const oe = re.query(Gi.blotName);
    if (!(oe != null && Y.tagName === oe.tagName)) {
      if (typeof this.tagName == "string")
        return !0;
      if (Array.isArray(this.tagName))
        return Y.tagName.toLowerCase();
    }
  }
  constructor(Y, re) {
    super(Y, re), this.attributes = new AttributorStore$1(this.domNode);
  }
  format(Y, re) {
    const oe = this.scroll.query(Y, Scope.BLOCK);
    oe != null && (oe instanceof Attributor ? this.attributes.attribute(oe, re) : Y === this.statics.blotName && !re ? this.replaceWith(Gi.blotName) : re && (Y !== this.statics.blotName || this.formats()[Y] !== re) && this.replaceWith(Y, re));
  }
  formats() {
    const Y = this.attributes.values(), re = this.statics.formats(this.domNode, this.scroll);
    return re != null && (Y[this.statics.blotName] = re), Y;
  }
  formatAt(Y, re, oe, ue) {
    this.scroll.query(oe, Scope.BLOCK) != null ? this.format(oe, ue) : super.formatAt(Y, re, oe, ue);
  }
  insertAt(Y, re, oe) {
    if (oe == null || this.scroll.query(re, Scope.INLINE) != null)
      super.insertAt(Y, re, oe);
    else {
      const ue = this.split(Y);
      if (ue != null) {
        const fe = this.scroll.create(re, oe);
        ue.parent.insertBefore(fe, ue);
      } else
        throw new Error("Attempt to insertAt after block boundaries");
    }
  }
  replaceWith(Y, re) {
    const oe = super.replaceWith(Y, re);
    return this.attributes.copy(oe), oe;
  }
  update(Y, re) {
    super.update(Y, re), Y.some(
      (oe) => oe.target === this.domNode && oe.type === "attributes"
    ) && this.attributes.build();
  }
};
_BlockBlot.blotName = "block", _BlockBlot.scope = Scope.BLOCK_BLOT, _BlockBlot.tagName = "P", _BlockBlot.allowedChildren = [
  InlineBlot$1,
  _BlockBlot,
  LeafBlot$1
];
let BlockBlot = _BlockBlot;
const BlockBlot$1 = BlockBlot, _ContainerBlot = class extends ParentBlot$1 {
  checkMerge() {
    return this.next !== null && this.next.statics.blotName === this.statics.blotName;
  }
  deleteAt(Y, re) {
    super.deleteAt(Y, re), this.enforceAllowedChildren();
  }
  formatAt(Y, re, oe, ue) {
    super.formatAt(Y, re, oe, ue), this.enforceAllowedChildren();
  }
  insertAt(Y, re, oe) {
    super.insertAt(Y, re, oe), this.enforceAllowedChildren();
  }
  optimize(Y) {
    super.optimize(Y), this.children.length > 0 && this.next != null && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());
  }
};
_ContainerBlot.blotName = "container", _ContainerBlot.scope = Scope.BLOCK_BLOT;
let ContainerBlot = _ContainerBlot;
const ContainerBlot$1 = ContainerBlot;
class EmbedBlot extends LeafBlot$1 {
  static formats(Y, re) {
  }
  format(Y, re) {
    super.formatAt(0, this.length(), Y, re);
  }
  formatAt(Y, re, oe, ue) {
    Y === 0 && re === this.length() ? this.format(oe, ue) : super.formatAt(Y, re, oe, ue);
  }
  formats() {
    return this.statics.formats(this.domNode, this.scroll);
  }
}
const EmbedBlot$1 = EmbedBlot, OBSERVER_CONFIG = {
  attributes: !0,
  characterData: !0,
  characterDataOldValue: !0,
  childList: !0,
  subtree: !0
}, MAX_OPTIMIZE_ITERATIONS = 100, _ScrollBlot = class extends ParentBlot$1 {
  constructor(Y, re) {
    super(null, re), this.registry = Y, this.scroll = this, this.build(), this.observer = new MutationObserver((oe) => {
      this.update(oe);
    }), this.observer.observe(this.domNode, OBSERVER_CONFIG), this.attach();
  }
  create(Y, re) {
    return this.registry.create(this, Y, re);
  }
  find(Y, re = !1) {
    const oe = this.registry.find(Y, re);
    return oe ? oe.scroll === this ? oe : re ? this.find(oe.scroll.domNode.parentNode, !0) : null : null;
  }
  query(Y, re = Scope.ANY) {
    return this.registry.query(Y, re);
  }
  register(...Y) {
    return this.registry.register(...Y);
  }
  build() {
    this.scroll != null && super.build();
  }
  detach() {
    super.detach(), this.observer.disconnect();
  }
  deleteAt(Y, re) {
    this.update(), Y === 0 && re === this.length() ? this.children.forEach((oe) => {
      oe.remove();
    }) : super.deleteAt(Y, re);
  }
  formatAt(Y, re, oe, ue) {
    this.update(), super.formatAt(Y, re, oe, ue);
  }
  insertAt(Y, re, oe) {
    this.update(), super.insertAt(Y, re, oe);
  }
  optimize(Y = [], re = {}) {
    super.optimize(re);
    const oe = re.mutationsMap || /* @__PURE__ */ new WeakMap();
    let ue = Array.from(this.observer.takeRecords());
    for (; ue.length > 0; )
      Y.push(ue.pop());
    const fe = (ve, xe = !0) => {
      ve == null || ve === this || ve.domNode.parentNode != null && (oe.has(ve.domNode) || oe.set(ve.domNode, []), xe && fe(ve.parent));
    }, he = (ve) => {
      oe.has(ve.domNode) && (ve instanceof ParentBlot$1 && ve.children.forEach(he), oe.delete(ve.domNode), ve.optimize(re));
    };
    let _e = Y;
    for (let ve = 0; _e.length > 0; ve += 1) {
      if (ve >= MAX_OPTIMIZE_ITERATIONS)
        throw new Error("[Parchment] Maximum optimize iterations reached");
      for (_e.forEach((xe) => {
        const Ee = this.find(xe.target, !0);
        Ee != null && (Ee.domNode === xe.target && (xe.type === "childList" ? (fe(this.find(xe.previousSibling, !1)), Array.from(xe.addedNodes).forEach((Se) => {
          const Te = this.find(Se, !1);
          fe(Te, !1), Te instanceof ParentBlot$1 && Te.children.forEach((Ce) => {
            fe(Ce, !1);
          });
        })) : xe.type === "attributes" && fe(Ee.prev)), fe(Ee));
      }), this.children.forEach(he), _e = Array.from(this.observer.takeRecords()), ue = _e.slice(); ue.length > 0; )
        Y.push(ue.pop());
    }
  }
  update(Y, re = {}) {
    Y = Y || this.observer.takeRecords();
    const oe = /* @__PURE__ */ new WeakMap();
    Y.map((ue) => {
      const fe = this.find(ue.target, !0);
      return fe == null ? null : oe.has(fe.domNode) ? (oe.get(fe.domNode).push(ue), null) : (oe.set(fe.domNode, [ue]), fe);
    }).forEach((ue) => {
      ue != null && ue !== this && oe.has(ue.domNode) && ue.update(oe.get(ue.domNode) || [], re);
    }), re.mutationsMap = oe, oe.has(this.domNode) && super.update(oe.get(this.domNode), re), this.optimize(Y, re);
  }
};
_ScrollBlot.blotName = "scroll", _ScrollBlot.defaultChild = BlockBlot$1, _ScrollBlot.allowedChildren = [BlockBlot$1, ContainerBlot$1], _ScrollBlot.scope = Scope.BLOCK_BLOT, _ScrollBlot.tagName = "DIV";
let ScrollBlot = _ScrollBlot;
const ScrollBlot$1 = ScrollBlot, _TextBlot = class vn extends LeafBlot$1 {
  static create(Y) {
    return document.createTextNode(Y);
  }
  static value(Y) {
    return Y.data;
  }
  constructor(Y, re) {
    super(Y, re), this.text = this.statics.value(this.domNode);
  }
  deleteAt(Y, re) {
    this.domNode.data = this.text = this.text.slice(0, Y) + this.text.slice(Y + re);
  }
  index(Y, re) {
    return this.domNode === Y ? re : -1;
  }
  insertAt(Y, re, oe) {
    oe == null ? (this.text = this.text.slice(0, Y) + re + this.text.slice(Y), this.domNode.data = this.text) : super.insertAt(Y, re, oe);
  }
  length() {
    return this.text.length;
  }
  optimize(Y) {
    super.optimize(Y), this.text = this.statics.value(this.domNode), this.text.length === 0 ? this.remove() : this.next instanceof vn && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());
  }
  position(Y, re = !1) {
    return [this.domNode, Y];
  }
  split(Y, re = !1) {
    if (!re) {
      if (Y === 0)
        return this;
      if (Y === this.length())
        return this.next;
    }
    const oe = this.scroll.create(this.domNode.splitText(Y));
    return this.parent.insertBefore(oe, this.next || void 0), this.text = this.statics.value(this.domNode), oe;
  }
  update(Y, re) {
    Y.some((oe) => oe.type === "characterData" && oe.target === this.domNode) && (this.text = this.statics.value(this.domNode));
  }
  value() {
    return this.text;
  }
};
_TextBlot.blotName = "text", _TextBlot.scope = Scope.INLINE_BLOT;
let TextBlot = _TextBlot;
const TextBlot$1 = TextBlot, Parchment = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Attributor,
  AttributorStore: AttributorStore$1,
  BlockBlot: BlockBlot$1,
  ClassAttributor: ClassAttributor$1,
  ContainerBlot: ContainerBlot$1,
  EmbedBlot: EmbedBlot$1,
  InlineBlot: InlineBlot$1,
  LeafBlot: LeafBlot$1,
  ParentBlot: ParentBlot$1,
  Registry,
  Scope,
  ScrollBlot: ScrollBlot$1,
  StyleAttributor: StyleAttributor$1,
  TextBlot: TextBlot$1
}, Symbol.toStringTag, { value: "Module" }));
var Delta$1 = { exports: {} }, diff_1, hasRequiredDiff;
function requireDiff() {
  if (hasRequiredDiff) return diff_1;
  hasRequiredDiff = 1;
  var le = -1, Y = 1, re = 0;
  function oe(ze, tt, Xe, mt, at) {
    if (ze === tt)
      return ze ? [[re, ze]] : [];
    if (Xe != null) {
      var qe = De(ze, tt, Xe);
      if (qe)
        return qe;
    }
    var st = _e(ze, tt), xt = ze.substring(0, st);
    ze = ze.substring(st), tt = tt.substring(st), st = xe(ze, tt);
    var gt = ze.substring(ze.length - st);
    ze = ze.substring(0, ze.length - st), tt = tt.substring(0, tt.length - st);
    var Ze = ue(ze, tt);
    return xt && Ze.unshift([re, xt]), gt && Ze.push([re, gt]), Pe(Ze, at), mt && Se(Ze), Ze;
  }
  function ue(ze, tt) {
    var Xe;
    if (!ze)
      return [[Y, tt]];
    if (!tt)
      return [[le, ze]];
    var mt = ze.length > tt.length ? ze : tt, at = ze.length > tt.length ? tt : ze, qe = mt.indexOf(at);
    if (qe !== -1)
      return Xe = [
        [Y, mt.substring(0, qe)],
        [re, at],
        [Y, mt.substring(qe + at.length)]
      ], ze.length > tt.length && (Xe[0][0] = Xe[2][0] = le), Xe;
    if (at.length === 1)
      return [
        [le, ze],
        [Y, tt]
      ];
    var st = Ee(ze, tt);
    if (st) {
      var xt = st[0], gt = st[1], Ze = st[2], _t = st[3], wt = st[4], yt = oe(xt, Ze), St = oe(gt, _t);
      return yt.concat([[re, wt]], St);
    }
    return fe(ze, tt);
  }
  function fe(ze, tt) {
    for (var Xe = ze.length, mt = tt.length, at = Math.ceil((Xe + mt) / 2), qe = at, st = 2 * at, xt = new Array(st), gt = new Array(st), Ze = 0; Ze < st; Ze++)
      xt[Ze] = -1, gt[Ze] = -1;
    xt[qe + 1] = 0, gt[qe + 1] = 0;
    for (var _t = Xe - mt, wt = _t % 2 !== 0, yt = 0, St = 0, It = 0, Bt = 0, Ye = 0; Ye < at; Ye++) {
      for (var Be = -Ye + yt; Be <= Ye - St; Be += 2) {
        var et = qe + Be, je;
        Be === -Ye || Be !== Ye && xt[et - 1] < xt[et + 1] ? je = xt[et + 1] : je = xt[et - 1] + 1;
        for (var it = je - Be; je < Xe && it < mt && ze.charAt(je) === tt.charAt(it); )
          je++, it++;
        if (xt[et] = je, je > Xe)
          St += 2;
        else if (it > mt)
          yt += 2;
        else if (wt) {
          var bt = qe + _t - Be;
          if (bt >= 0 && bt < st && gt[bt] !== -1) {
            var rt = Xe - gt[bt];
            if (je >= rt)
              return he(ze, tt, je, it);
          }
        }
      }
      for (var Ct = -Ye + It; Ct <= Ye - Bt; Ct += 2) {
        var bt = qe + Ct, rt;
        Ct === -Ye || Ct !== Ye && gt[bt - 1] < gt[bt + 1] ? rt = gt[bt + 1] : rt = gt[bt - 1] + 1;
        for (var Rt = rt - Ct; rt < Xe && Rt < mt && ze.charAt(Xe - rt - 1) === tt.charAt(mt - Rt - 1); )
          rt++, Rt++;
        if (gt[bt] = rt, rt > Xe)
          Bt += 2;
        else if (Rt > mt)
          It += 2;
        else if (!wt) {
          var et = qe + _t - Ct;
          if (et >= 0 && et < st && xt[et] !== -1) {
            var je = xt[et], it = qe + je - et;
            if (rt = Xe - rt, je >= rt)
              return he(ze, tt, je, it);
          }
        }
      }
    }
    return [
      [le, ze],
      [Y, tt]
    ];
  }
  function he(ze, tt, Xe, mt) {
    var at = ze.substring(0, Xe), qe = tt.substring(0, mt), st = ze.substring(Xe), xt = tt.substring(mt), gt = oe(at, qe), Ze = oe(st, xt);
    return gt.concat(Ze);
  }
  function _e(ze, tt) {
    if (!ze || !tt || ze.charAt(0) !== tt.charAt(0))
      return 0;
    for (var Xe = 0, mt = Math.min(ze.length, tt.length), at = mt, qe = 0; Xe < at; )
      ze.substring(qe, at) == tt.substring(qe, at) ? (Xe = at, qe = Xe) : mt = at, at = Math.floor((mt - Xe) / 2 + Xe);
    return Fe(ze.charCodeAt(at - 1)) && at--, at;
  }
  function ve(ze, tt) {
    var Xe = ze.length, mt = tt.length;
    if (Xe == 0 || mt == 0)
      return 0;
    Xe > mt ? ze = ze.substring(Xe - mt) : Xe < mt && (tt = tt.substring(0, Xe));
    var at = Math.min(Xe, mt);
    if (ze == tt)
      return at;
    for (var qe = 0, st = 1; ; ) {
      var xt = ze.substring(at - st), gt = tt.indexOf(xt);
      if (gt == -1)
        return qe;
      st += gt, (gt == 0 || ze.substring(at - st) == tt.substring(0, st)) && (qe = st, st++);
    }
  }
  function xe(ze, tt) {
    if (!ze || !tt || ze.slice(-1) !== tt.slice(-1))
      return 0;
    for (var Xe = 0, mt = Math.min(ze.length, tt.length), at = mt, qe = 0; Xe < at; )
      ze.substring(ze.length - at, ze.length - qe) == tt.substring(tt.length - at, tt.length - qe) ? (Xe = at, qe = Xe) : mt = at, at = Math.floor((mt - Xe) / 2 + Xe);
    return Le(ze.charCodeAt(ze.length - at)) && at--, at;
  }
  function Ee(ze, tt) {
    var Xe = ze.length > tt.length ? ze : tt, mt = ze.length > tt.length ? tt : ze;
    if (Xe.length < 4 || mt.length * 2 < Xe.length)
      return null;
    function at(St, It, Bt) {
      for (var Ye = St.substring(Bt, Bt + Math.floor(St.length / 4)), Be = -1, et = "", je, it, bt, rt; (Be = It.indexOf(Ye, Be + 1)) !== -1; ) {
        var Ct = _e(
          St.substring(Bt),
          It.substring(Be)
        ), Rt = xe(
          St.substring(0, Bt),
          It.substring(0, Be)
        );
        et.length < Rt + Ct && (et = It.substring(Be - Rt, Be) + It.substring(Be, Be + Ct), je = St.substring(0, Bt - Rt), it = St.substring(Bt + Ct), bt = It.substring(0, Be - Rt), rt = It.substring(Be + Ct));
      }
      return et.length * 2 >= St.length ? [
        je,
        it,
        bt,
        rt,
        et
      ] : null;
    }
    var qe = at(
      Xe,
      mt,
      Math.ceil(Xe.length / 4)
    ), st = at(
      Xe,
      mt,
      Math.ceil(Xe.length / 2)
    ), xt;
    if (!qe && !st)
      return null;
    st ? qe ? xt = qe[4].length > st[4].length ? qe : st : xt = st : xt = qe;
    var gt, Ze, _t, wt;
    ze.length > tt.length ? (gt = xt[0], Ze = xt[1], _t = xt[2], wt = xt[3]) : (_t = xt[0], wt = xt[1], gt = xt[2], Ze = xt[3]);
    var yt = xt[4];
    return [gt, Ze, _t, wt, yt];
  }
  function Se(ze) {
    for (var tt = !1, Xe = [], mt = 0, at = null, qe = 0, st = 0, xt = 0, gt = 0, Ze = 0; qe < ze.length; )
      ze[qe][0] == re ? (Xe[mt++] = qe, st = gt, xt = Ze, gt = 0, Ze = 0, at = ze[qe][1]) : (ze[qe][0] == Y ? gt += ze[qe][1].length : Ze += ze[qe][1].length, at && at.length <= Math.max(st, xt) && at.length <= Math.max(gt, Ze) && (ze.splice(Xe[mt - 1], 0, [
        le,
        at
      ]), ze[Xe[mt - 1] + 1][0] = Y, mt--, mt--, qe = mt > 0 ? Xe[mt - 1] : -1, st = 0, xt = 0, gt = 0, Ze = 0, at = null, tt = !0)), qe++;
    for (tt && Pe(ze), Ae(ze), qe = 1; qe < ze.length; ) {
      if (ze[qe - 1][0] == le && ze[qe][0] == Y) {
        var _t = ze[qe - 1][1], wt = ze[qe][1], yt = ve(_t, wt), St = ve(wt, _t);
        yt >= St ? (yt >= _t.length / 2 || yt >= wt.length / 2) && (ze.splice(qe, 0, [
          re,
          wt.substring(0, yt)
        ]), ze[qe - 1][1] = _t.substring(
          0,
          _t.length - yt
        ), ze[qe + 1][1] = wt.substring(yt), qe++) : (St >= _t.length / 2 || St >= wt.length / 2) && (ze.splice(qe, 0, [
          re,
          _t.substring(0, St)
        ]), ze[qe - 1][0] = Y, ze[qe - 1][1] = wt.substring(
          0,
          wt.length - St
        ), ze[qe + 1][0] = le, ze[qe + 1][1] = _t.substring(St), qe++), qe++;
      }
      qe++;
    }
  }
  var Te = /[^a-zA-Z0-9]/, Ce = /\s/, Ie = /[\r\n]/, Ne = /\n\r?\n$/, Re = /^\r?\n\r?\n/;
  function Ae(ze) {
    function tt(St, It) {
      if (!St || !It)
        return 6;
      var Bt = St.charAt(St.length - 1), Ye = It.charAt(0), Be = Bt.match(Te), et = Ye.match(Te), je = Be && Bt.match(Ce), it = et && Ye.match(Ce), bt = je && Bt.match(Ie), rt = it && Ye.match(Ie), Ct = bt && St.match(Ne), Rt = rt && It.match(Re);
      return Ct || Rt ? 5 : bt || rt ? 4 : Be && !je && it ? 3 : je || it ? 2 : Be || et ? 1 : 0;
    }
    for (var Xe = 1; Xe < ze.length - 1; ) {
      if (ze[Xe - 1][0] == re && ze[Xe + 1][0] == re) {
        var mt = ze[Xe - 1][1], at = ze[Xe][1], qe = ze[Xe + 1][1], st = xe(mt, at);
        if (st) {
          var xt = at.substring(at.length - st);
          mt = mt.substring(0, mt.length - st), at = xt + at.substring(0, at.length - st), qe = xt + qe;
        }
        for (var gt = mt, Ze = at, _t = qe, wt = tt(mt, at) + tt(at, qe); at.charAt(0) === qe.charAt(0); ) {
          mt += at.charAt(0), at = at.substring(1) + qe.charAt(0), qe = qe.substring(1);
          var yt = tt(mt, at) + tt(at, qe);
          yt >= wt && (wt = yt, gt = mt, Ze = at, _t = qe);
        }
        ze[Xe - 1][1] != gt && (gt ? ze[Xe - 1][1] = gt : (ze.splice(Xe - 1, 1), Xe--), ze[Xe][1] = Ze, _t ? ze[Xe + 1][1] = _t : (ze.splice(Xe + 1, 1), Xe--));
      }
      Xe++;
    }
  }
  function Pe(ze, tt) {
    ze.push([re, ""]);
    for (var Xe = 0, mt = 0, at = 0, qe = "", st = "", xt; Xe < ze.length; ) {
      if (Xe < ze.length - 1 && !ze[Xe][1]) {
        ze.splice(Xe, 1);
        continue;
      }
      switch (ze[Xe][0]) {
        case Y:
          at++, st += ze[Xe][1], Xe++;
          break;
        case le:
          mt++, qe += ze[Xe][1], Xe++;
          break;
        case re:
          var gt = Xe - at - mt - 1;
          if (tt) {
            if (gt >= 0 && Ge(ze[gt][1])) {
              var Ze = ze[gt][1].slice(-1);
              if (ze[gt][1] = ze[gt][1].slice(
                0,
                -1
              ), qe = Ze + qe, st = Ze + st, !ze[gt][1]) {
                ze.splice(gt, 1), Xe--;
                var _t = gt - 1;
                ze[_t] && ze[_t][0] === Y && (at++, st = ze[_t][1] + st, _t--), ze[_t] && ze[_t][0] === le && (mt++, qe = ze[_t][1] + qe, _t--), gt = _t;
              }
            }
            if (He(ze[Xe][1])) {
              var Ze = ze[Xe][1].charAt(0);
              ze[Xe][1] = ze[Xe][1].slice(1), qe += Ze, st += Ze;
            }
          }
          if (Xe < ze.length - 1 && !ze[Xe][1]) {
            ze.splice(Xe, 1);
            break;
          }
          if (qe.length > 0 || st.length > 0) {
            qe.length > 0 && st.length > 0 && (xt = _e(st, qe), xt !== 0 && (gt >= 0 ? ze[gt][1] += st.substring(
              0,
              xt
            ) : (ze.splice(0, 0, [
              re,
              st.substring(0, xt)
            ]), Xe++), st = st.substring(xt), qe = qe.substring(xt)), xt = xe(st, qe), xt !== 0 && (ze[Xe][1] = st.substring(st.length - xt) + ze[Xe][1], st = st.substring(
              0,
              st.length - xt
            ), qe = qe.substring(
              0,
              qe.length - xt
            )));
            var wt = at + mt;
            qe.length === 0 && st.length === 0 ? (ze.splice(Xe - wt, wt), Xe = Xe - wt) : qe.length === 0 ? (ze.splice(Xe - wt, wt, [Y, st]), Xe = Xe - wt + 1) : st.length === 0 ? (ze.splice(Xe - wt, wt, [le, qe]), Xe = Xe - wt + 1) : (ze.splice(
              Xe - wt,
              wt,
              [le, qe],
              [Y, st]
            ), Xe = Xe - wt + 2);
          }
          Xe !== 0 && ze[Xe - 1][0] === re ? (ze[Xe - 1][1] += ze[Xe][1], ze.splice(Xe, 1)) : Xe++, at = 0, mt = 0, qe = "", st = "";
          break;
      }
    }
    ze[ze.length - 1][1] === "" && ze.pop();
    var yt = !1;
    for (Xe = 1; Xe < ze.length - 1; )
      ze[Xe - 1][0] === re && ze[Xe + 1][0] === re && (ze[Xe][1].substring(
        ze[Xe][1].length - ze[Xe - 1][1].length
      ) === ze[Xe - 1][1] ? (ze[Xe][1] = ze[Xe - 1][1] + ze[Xe][1].substring(
        0,
        ze[Xe][1].length - ze[Xe - 1][1].length
      ), ze[Xe + 1][1] = ze[Xe - 1][1] + ze[Xe + 1][1], ze.splice(Xe - 1, 1), yt = !0) : ze[Xe][1].substring(0, ze[Xe + 1][1].length) == ze[Xe + 1][1] && (ze[Xe - 1][1] += ze[Xe + 1][1], ze[Xe][1] = ze[Xe][1].substring(ze[Xe + 1][1].length) + ze[Xe + 1][1], ze.splice(Xe + 1, 1), yt = !0)), Xe++;
    yt && Pe(ze, tt);
  }
  function Fe(ze) {
    return ze >= 55296 && ze <= 56319;
  }
  function Le(ze) {
    return ze >= 56320 && ze <= 57343;
  }
  function He(ze) {
    return Le(ze.charCodeAt(0));
  }
  function Ge(ze) {
    return Fe(ze.charCodeAt(ze.length - 1));
  }
  function Ve(ze) {
    for (var tt = [], Xe = 0; Xe < ze.length; Xe++)
      ze[Xe][1].length > 0 && tt.push(ze[Xe]);
    return tt;
  }
  function $e(ze, tt, Xe, mt) {
    return Ge(ze) || He(mt) ? null : Ve([
      [re, ze],
      [le, tt],
      [Y, Xe],
      [re, mt]
    ]);
  }
  function De(ze, tt, Xe) {
    var mt = typeof Xe == "number" ? { index: Xe, length: 0 } : Xe.oldRange, at = typeof Xe == "number" ? null : Xe.newRange, qe = ze.length, st = tt.length;
    if (mt.length === 0 && (at === null || at.length === 0)) {
      var xt = mt.index, gt = ze.slice(0, xt), Ze = ze.slice(xt), _t = at ? at.index : null;
      e: {
        var wt = xt + st - qe;
        if (_t !== null && _t !== wt || wt < 0 || wt > st)
          break e;
        var yt = tt.slice(0, wt), St = tt.slice(wt);
        if (St !== Ze)
          break e;
        var It = Math.min(xt, wt), Bt = gt.slice(0, It), Ye = yt.slice(0, It);
        if (Bt !== Ye)
          break e;
        var Be = gt.slice(It), et = yt.slice(It);
        return $e(Bt, Be, et, Ze);
      }
      e: {
        if (_t !== null && _t !== xt)
          break e;
        var je = xt, yt = tt.slice(0, je), St = tt.slice(je);
        if (yt !== gt)
          break e;
        var it = Math.min(qe - je, st - je), bt = Ze.slice(Ze.length - it), rt = St.slice(St.length - it);
        if (bt !== rt)
          break e;
        var Be = Ze.slice(0, Ze.length - it), et = St.slice(0, St.length - it);
        return $e(gt, Be, et, bt);
      }
    }
    if (mt.length > 0 && at && at.length === 0)
      e: {
        var Bt = ze.slice(0, mt.index), bt = ze.slice(mt.index + mt.length), It = Bt.length, it = bt.length;
        if (st < It + it)
          break e;
        var Ye = tt.slice(0, It), rt = tt.slice(st - it);
        if (Bt !== Ye || bt !== rt)
          break e;
        var Be = ze.slice(It, qe - it), et = tt.slice(It, st - it);
        return $e(Bt, Be, et, bt);
      }
    return null;
  }
  function Ke(ze, tt, Xe, mt) {
    return oe(ze, tt, Xe, mt, !0);
  }
  return Ke.INSERT = Y, Ke.DELETE = le, Ke.EQUAL = re, diff_1 = Ke, diff_1;
}
var lodash_clonedeep = { exports: {} };
lodash_clonedeep.exports;
var hasRequiredLodash_clonedeep;
function requireLodash_clonedeep() {
  return hasRequiredLodash_clonedeep || (hasRequiredLodash_clonedeep = 1, function(le, Y) {
    var re = 200, oe = "__lodash_hash_undefined__", ue = 9007199254740991, fe = "[object Arguments]", he = "[object Array]", _e = "[object Boolean]", ve = "[object Date]", xe = "[object Error]", Ee = "[object Function]", Se = "[object GeneratorFunction]", Te = "[object Map]", Ce = "[object Number]", Ie = "[object Object]", Ne = "[object Promise]", Re = "[object RegExp]", Ae = "[object Set]", Pe = "[object String]", Fe = "[object Symbol]", Le = "[object WeakMap]", He = "[object ArrayBuffer]", Ge = "[object DataView]", Ve = "[object Float32Array]", $e = "[object Float64Array]", De = "[object Int8Array]", Ke = "[object Int16Array]", ze = "[object Int32Array]", tt = "[object Uint8Array]", Xe = "[object Uint8ClampedArray]", mt = "[object Uint16Array]", at = "[object Uint32Array]", qe = /[\\^$.*+?()[\]{}|]/g, st = /\w*$/, xt = /^\[object .+?Constructor\]$/, gt = /^(?:0|[1-9]\d*)$/, Ze = {};
    Ze[fe] = Ze[he] = Ze[He] = Ze[Ge] = Ze[_e] = Ze[ve] = Ze[Ve] = Ze[$e] = Ze[De] = Ze[Ke] = Ze[ze] = Ze[Te] = Ze[Ce] = Ze[Ie] = Ze[Re] = Ze[Ae] = Ze[Pe] = Ze[Fe] = Ze[tt] = Ze[Xe] = Ze[mt] = Ze[at] = !0, Ze[xe] = Ze[Ee] = Ze[Le] = !1;
    var _t = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, wt = typeof self == "object" && self && self.Object === Object && self, yt = _t || wt || Function("return this")(), St = Y && !Y.nodeType && Y, It = St && !0 && le && !le.nodeType && le, Bt = It && It.exports === St;
    function Ye(Me, nt) {
      return Me.set(nt[0], nt[1]), Me;
    }
    function Be(Me, nt) {
      return Me.add(nt), Me;
    }
    function et(Me, nt) {
      for (var vt = -1, Pt = Me ? Me.length : 0; ++vt < Pt && nt(Me[vt], vt, Me) !== !1; )
        ;
      return Me;
    }
    function je(Me, nt) {
      for (var vt = -1, Pt = nt.length, rr = Me.length; ++vt < Pt; )
        Me[rr + vt] = nt[vt];
      return Me;
    }
    function it(Me, nt, vt, Pt) {
      for (var rr = -1, Qt = Me ? Me.length : 0; ++rr < Qt; )
        vt = nt(vt, Me[rr], rr, Me);
      return vt;
    }
    function bt(Me, nt) {
      for (var vt = -1, Pt = Array(Me); ++vt < Me; )
        Pt[vt] = nt(vt);
      return Pt;
    }
    function rt(Me, nt) {
      return Me?.[nt];
    }
    function Ct(Me) {
      var nt = !1;
      if (Me != null && typeof Me.toString != "function")
        try {
          nt = !!(Me + "");
        } catch {
        }
      return nt;
    }
    function Rt(Me) {
      var nt = -1, vt = Array(Me.size);
      return Me.forEach(function(Pt, rr) {
        vt[++nt] = [rr, Pt];
      }), vt;
    }
    function Ot(Me, nt) {
      return function(vt) {
        return Me(nt(vt));
      };
    }
    function Mt(Me) {
      var nt = -1, vt = Array(Me.size);
      return Me.forEach(function(Pt) {
        vt[++nt] = Pt;
      }), vt;
    }
    var Dt = Array.prototype, Vt = Function.prototype, Jt = Object.prototype, er = yt["__core-js_shared__"], Zt = function() {
      var Me = /[^.]+$/.exec(er && er.keys && er.keys.IE_PROTO || "");
      return Me ? "Symbol(src)_1." + Me : "";
    }(), Gt = Vt.toString, Yt = Jt.hasOwnProperty, $t = Jt.toString, ir = RegExp(
      "^" + Gt.call(Yt).replace(qe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), Je = Bt ? yt.Buffer : void 0, Ue = yt.Symbol, We = yt.Uint8Array, lt = Ot(Object.getPrototypeOf, Object), ft = Object.create, Et = Jt.propertyIsEnumerable, Lt = Dt.splice, Kt = Object.getOwnPropertySymbols, ar = Je ? Je.isBuffer : void 0, sr = Ot(Object.keys, Object), or = qr(yt, "DataView"), nr = qr(yt, "Map"), Nr = qr(yt, "Promise"), Zr = qr(yt, "Set"), va = qr(yt, "WeakMap"), ea = qr(Object, "create"), Gr = Lr(or), ta = Lr(nr), xa = Lr(Nr), ya = Lr(Zr), ba = Lr(va), jr = Ue ? Ue.prototype : void 0, Ba = jr ? jr.valueOf : void 0;
    function Wr(Me) {
      var nt = -1, vt = Me ? Me.length : 0;
      for (this.clear(); ++nt < vt; ) {
        var Pt = Me[nt];
        this.set(Pt[0], Pt[1]);
      }
    }
    function Ka() {
      this.__data__ = ea ? ea(null) : {};
    }
    function wa(Me) {
      return this.has(Me) && delete this.__data__[Me];
    }
    function Ya(Me) {
      var nt = this.__data__;
      if (ea) {
        var vt = nt[Me];
        return vt === oe ? void 0 : vt;
      }
      return Yt.call(nt, Me) ? nt[Me] : void 0;
    }
    function Da(Me) {
      var nt = this.__data__;
      return ea ? nt[Me] !== void 0 : Yt.call(nt, Me);
    }
    function Ea(Me, nt) {
      var vt = this.__data__;
      return vt[Me] = ea && nt === void 0 ? oe : nt, this;
    }
    Wr.prototype.clear = Ka, Wr.prototype.delete = wa, Wr.prototype.get = Ya, Wr.prototype.has = Da, Wr.prototype.set = Ea;
    function Qe(Me) {
      var nt = -1, vt = Me ? Me.length : 0;
      for (this.clear(); ++nt < vt; ) {
        var Pt = Me[nt];
        this.set(Pt[0], Pt[1]);
      }
    }
    function dt() {
      this.__data__ = [];
    }
    function ot(Me) {
      var nt = this.__data__, vt = $r(nt, Me);
      if (vt < 0)
        return !1;
      var Pt = nt.length - 1;
      return vt == Pt ? nt.pop() : Lt.call(nt, vt, 1), !0;
    }
    function ct(Me) {
      var nt = this.__data__, vt = $r(nt, Me);
      return vt < 0 ? void 0 : nt[vt][1];
    }
    function ut(Me) {
      return $r(this.__data__, Me) > -1;
    }
    function ht(Me, nt) {
      var vt = this.__data__, Pt = $r(vt, Me);
      return Pt < 0 ? vt.push([Me, nt]) : vt[Pt][1] = nt, this;
    }
    Qe.prototype.clear = dt, Qe.prototype.delete = ot, Qe.prototype.get = ct, Qe.prototype.has = ut, Qe.prototype.set = ht;
    function Tt(Me) {
      var nt = -1, vt = Me ? Me.length : 0;
      for (this.clear(); ++nt < vt; ) {
        var Pt = Me[nt];
        this.set(Pt[0], Pt[1]);
      }
    }
    function Nt() {
      this.__data__ = {
        hash: new Wr(),
        map: new (nr || Qe)(),
        string: new Wr()
      };
    }
    function At(Me) {
      return Ca(this, Me).delete(Me);
    }
    function Ft(Me) {
      return Ca(this, Me).get(Me);
    }
    function kt(Me) {
      return Ca(this, Me).has(Me);
    }
    function Ht(Me, nt) {
      return Ca(this, Me).set(Me, nt), this;
    }
    Tt.prototype.clear = Nt, Tt.prototype.delete = At, Tt.prototype.get = Ft, Tt.prototype.has = kt, Tt.prototype.set = Ht;
    function Wt(Me) {
      this.__data__ = new Qe(Me);
    }
    function jt() {
      this.__data__ = new Qe();
    }
    function zt(Me) {
      return this.__data__.delete(Me);
    }
    function qt(Me) {
      return this.__data__.get(Me);
    }
    function tr(Me) {
      return this.__data__.has(Me);
    }
    function hr(Me, nt) {
      var vt = this.__data__;
      if (vt instanceof Qe) {
        var Pt = vt.__data__;
        if (!nr || Pt.length < re - 1)
          return Pt.push([Me, nt]), this;
        vt = this.__data__ = new Tt(Pt);
      }
      return vt.set(Me, nt), this;
    }
    Wt.prototype.clear = jt, Wt.prototype.delete = zt, Wt.prototype.get = qt, Wt.prototype.has = tr, Wt.prototype.set = hr;
    function ur(Me, nt) {
      var vt = Za(Me) || $a(Me) ? bt(Me.length, String) : [], Pt = vt.length, rr = !!Pt;
      for (var Qt in Me)
        Yt.call(Me, Qt) && !(rr && (Qt == "length" || Ri(Qt, Pt))) && vt.push(Qt);
      return vt;
    }
    function xr(Me, nt, vt) {
      var Pt = Me[nt];
      (!(Yt.call(Me, nt) && fi(Pt, vt)) || vt === void 0 && !(nt in Me)) && (Me[nt] = vt);
    }
    function $r(Me, nt) {
      for (var vt = Me.length; vt--; )
        if (fi(Me[vt][0], nt))
          return vt;
      return -1;
    }
    function Ir(Me, nt) {
      return Me && Ja(nt, ti(nt), Me);
    }
    function Hr(Me, nt, vt, Pt, rr, Qt, cr) {
      var lr;
      if (Pt && (lr = Qt ? Pt(Me, rr, Qt, cr) : Pt(Me)), lr !== void 0)
        return lr;
      if (!Kr(Me))
        return Me;
      var yr = Za(Me);
      if (yr) {
        if (lr = Li(Me), !nt)
          return Ii(Me, lr);
      } else {
        var dr = aa(Me), Fr = dr == Ee || dr == Se;
        if (hi(Me))
          return Ua(Me, nt);
        if (dr == Ie || dr == fe || Fr && !Qt) {
          if (Ct(Me))
            return Qt ? Me : {};
          if (lr = Xr(Fr ? {} : Me), !nt)
            return Fi(Me, Ir(lr, Me));
        } else {
          if (!Ze[dr])
            return Qt ? Me : {};
          lr = Oi(Me, dr, Hr, nt);
        }
      }
      cr || (cr = new Wt());
      var Pr = cr.get(Me);
      if (Pr)
        return Pr;
      if (cr.set(Me, lr), !yr)
        var wr = vt ? ki(Me) : ti(Me);
      return et(wr || Me, function(kr, Tr) {
        wr && (Tr = kr, kr = Me[Tr]), xr(lr, Tr, Hr(kr, nt, vt, Pt, Tr, Me, cr));
      }), lr;
    }
    function zr(Me) {
      return Kr(Me) ? ft(Me) : {};
    }
    function Sa(Me, nt, vt) {
      var Pt = nt(Me);
      return Za(Me) ? Pt : je(Pt, vt(Me));
    }
    function Dr(Me) {
      return $t.call(Me);
    }
    function Ei(Me) {
      if (!Kr(Me) || Pi(Me))
        return !1;
      var nt = ei(Me) || Ct(Me) ? ir : xt;
      return nt.test(Lr(Me));
    }
    function Si(Me) {
      if (!ui(Me))
        return sr(Me);
      var nt = [];
      for (var vt in Object(Me))
        Yt.call(Me, vt) && vt != "constructor" && nt.push(vt);
      return nt;
    }
    function Ua(Me, nt) {
      if (nt)
        return Me.slice();
      var vt = new Me.constructor(Me.length);
      return Me.copy(vt), vt;
    }
    function Qa(Me) {
      var nt = new Me.constructor(Me.byteLength);
      return new We(nt).set(new We(Me)), nt;
    }
    function Ta(Me, nt) {
      var vt = nt ? Qa(Me.buffer) : Me.buffer;
      return new Me.constructor(vt, Me.byteOffset, Me.byteLength);
    }
    function li(Me, nt, vt) {
      var Pt = nt ? vt(Rt(Me), !0) : Rt(Me);
      return it(Pt, Ye, new Me.constructor());
    }
    function ci(Me) {
      var nt = new Me.constructor(Me.source, st.exec(Me));
      return nt.lastIndex = Me.lastIndex, nt;
    }
    function Ti(Me, nt, vt) {
      var Pt = nt ? vt(Mt(Me), !0) : Mt(Me);
      return it(Pt, Be, new Me.constructor());
    }
    function Ci(Me) {
      return Ba ? Object(Ba.call(Me)) : {};
    }
    function Ai(Me, nt) {
      var vt = nt ? Qa(Me.buffer) : Me.buffer;
      return new Me.constructor(vt, Me.byteOffset, Me.length);
    }
    function Ii(Me, nt) {
      var vt = -1, Pt = Me.length;
      for (nt || (nt = Array(Pt)); ++vt < Pt; )
        nt[vt] = Me[vt];
      return nt;
    }
    function Ja(Me, nt, vt, Pt) {
      vt || (vt = {});
      for (var rr = -1, Qt = nt.length; ++rr < Qt; ) {
        var cr = nt[rr], lr = void 0;
        xr(vt, cr, lr === void 0 ? Me[cr] : lr);
      }
      return vt;
    }
    function Fi(Me, nt) {
      return Ja(Me, ra(Me), nt);
    }
    function ki(Me) {
      return Sa(Me, ti, ra);
    }
    function Ca(Me, nt) {
      var vt = Me.__data__;
      return Ni(nt) ? vt[typeof nt == "string" ? "string" : "hash"] : vt.map;
    }
    function qr(Me, nt) {
      var vt = rt(Me, nt);
      return Ei(vt) ? vt : void 0;
    }
    var ra = Kt ? Ot(Kt, Object) : Di, aa = Dr;
    (or && aa(new or(new ArrayBuffer(1))) != Ge || nr && aa(new nr()) != Te || Nr && aa(Nr.resolve()) != Ne || Zr && aa(new Zr()) != Ae || va && aa(new va()) != Le) && (aa = function(Me) {
      var nt = $t.call(Me), vt = nt == Ie ? Me.constructor : void 0, Pt = vt ? Lr(vt) : void 0;
      if (Pt)
        switch (Pt) {
          case Gr:
            return Ge;
          case ta:
            return Te;
          case xa:
            return Ne;
          case ya:
            return Ae;
          case ba:
            return Le;
        }
      return nt;
    });
    function Li(Me) {
      var nt = Me.length, vt = Me.constructor(nt);
      return nt && typeof Me[0] == "string" && Yt.call(Me, "index") && (vt.index = Me.index, vt.input = Me.input), vt;
    }
    function Xr(Me) {
      return typeof Me.constructor == "function" && !ui(Me) ? zr(lt(Me)) : {};
    }
    function Oi(Me, nt, vt, Pt) {
      var rr = Me.constructor;
      switch (nt) {
        case He:
          return Qa(Me);
        case _e:
        case ve:
          return new rr(+Me);
        case Ge:
          return Ta(Me, Pt);
        case Ve:
        case $e:
        case De:
        case Ke:
        case ze:
        case tt:
        case Xe:
        case mt:
        case at:
          return Ai(Me, Pt);
        case Te:
          return li(Me, Pt, vt);
        case Ce:
        case Pe:
          return new rr(Me);
        case Re:
          return ci(Me);
        case Ae:
          return Ti(Me, Pt, vt);
        case Fe:
          return Ci(Me);
      }
    }
    function Ri(Me, nt) {
      return nt = nt ?? ue, !!nt && (typeof Me == "number" || gt.test(Me)) && Me > -1 && Me % 1 == 0 && Me < nt;
    }
    function Ni(Me) {
      var nt = typeof Me;
      return nt == "string" || nt == "number" || nt == "symbol" || nt == "boolean" ? Me !== "__proto__" : Me === null;
    }
    function Pi(Me) {
      return !!Zt && Zt in Me;
    }
    function ui(Me) {
      var nt = Me && Me.constructor, vt = typeof nt == "function" && nt.prototype || Jt;
      return Me === vt;
    }
    function Lr(Me) {
      if (Me != null) {
        try {
          return Gt.call(Me);
        } catch {
        }
        try {
          return Me + "";
        } catch {
        }
      }
      return "";
    }
    function di(Me) {
      return Hr(Me, !0, !0);
    }
    function fi(Me, nt) {
      return Me === nt || Me !== Me && nt !== nt;
    }
    function $a(Me) {
      return Bi(Me) && Yt.call(Me, "callee") && (!Et.call(Me, "callee") || $t.call(Me) == fe);
    }
    var Za = Array.isArray;
    function Ma(Me) {
      return Me != null && pi(Me.length) && !ei(Me);
    }
    function Bi(Me) {
      return mi(Me) && Ma(Me);
    }
    var hi = ar || Ui;
    function ei(Me) {
      var nt = Kr(Me) ? $t.call(Me) : "";
      return nt == Ee || nt == Se;
    }
    function pi(Me) {
      return typeof Me == "number" && Me > -1 && Me % 1 == 0 && Me <= ue;
    }
    function Kr(Me) {
      var nt = typeof Me;
      return !!Me && (nt == "object" || nt == "function");
    }
    function mi(Me) {
      return !!Me && typeof Me == "object";
    }
    function ti(Me) {
      return Ma(Me) ? ur(Me) : Si(Me);
    }
    function Di() {
      return [];
    }
    function Ui() {
      return !1;
    }
    le.exports = di;
  }(lodash_clonedeep, lodash_clonedeep.exports)), lodash_clonedeep.exports;
}
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
var hasRequiredLodash_isequal;
function requireLodash_isequal() {
  return hasRequiredLodash_isequal || (hasRequiredLodash_isequal = 1, function(le, Y) {
    var re = 200, oe = "__lodash_hash_undefined__", ue = 1, fe = 2, he = 9007199254740991, _e = "[object Arguments]", ve = "[object Array]", xe = "[object AsyncFunction]", Ee = "[object Boolean]", Se = "[object Date]", Te = "[object Error]", Ce = "[object Function]", Ie = "[object GeneratorFunction]", Ne = "[object Map]", Re = "[object Number]", Ae = "[object Null]", Pe = "[object Object]", Fe = "[object Promise]", Le = "[object Proxy]", He = "[object RegExp]", Ge = "[object Set]", Ve = "[object String]", $e = "[object Symbol]", De = "[object Undefined]", Ke = "[object WeakMap]", ze = "[object ArrayBuffer]", tt = "[object DataView]", Xe = "[object Float32Array]", mt = "[object Float64Array]", at = "[object Int8Array]", qe = "[object Int16Array]", st = "[object Int32Array]", xt = "[object Uint8Array]", gt = "[object Uint8ClampedArray]", Ze = "[object Uint16Array]", _t = "[object Uint32Array]", wt = /[\\^$.*+?()[\]{}|]/g, yt = /^\[object .+?Constructor\]$/, St = /^(?:0|[1-9]\d*)$/, It = {};
    It[Xe] = It[mt] = It[at] = It[qe] = It[st] = It[xt] = It[gt] = It[Ze] = It[_t] = !0, It[_e] = It[ve] = It[ze] = It[Ee] = It[tt] = It[Se] = It[Te] = It[Ce] = It[Ne] = It[Re] = It[Pe] = It[He] = It[Ge] = It[Ve] = It[Ke] = !1;
    var Bt = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, Ye = typeof self == "object" && self && self.Object === Object && self, Be = Bt || Ye || Function("return this")(), et = Y && !Y.nodeType && Y, je = et && !0 && le && !le.nodeType && le, it = je && je.exports === et, bt = it && Bt.process, rt = function() {
      try {
        return bt && bt.binding && bt.binding("util");
      } catch {
      }
    }(), Ct = rt && rt.isTypedArray;
    function Rt(Me, nt) {
      for (var vt = -1, Pt = Me == null ? 0 : Me.length, rr = 0, Qt = []; ++vt < Pt; ) {
        var cr = Me[vt];
        nt(cr, vt, Me) && (Qt[rr++] = cr);
      }
      return Qt;
    }
    function Ot(Me, nt) {
      for (var vt = -1, Pt = nt.length, rr = Me.length; ++vt < Pt; )
        Me[rr + vt] = nt[vt];
      return Me;
    }
    function Mt(Me, nt) {
      for (var vt = -1, Pt = Me == null ? 0 : Me.length; ++vt < Pt; )
        if (nt(Me[vt], vt, Me))
          return !0;
      return !1;
    }
    function Dt(Me, nt) {
      for (var vt = -1, Pt = Array(Me); ++vt < Me; )
        Pt[vt] = nt(vt);
      return Pt;
    }
    function Vt(Me) {
      return function(nt) {
        return Me(nt);
      };
    }
    function Jt(Me, nt) {
      return Me.has(nt);
    }
    function er(Me, nt) {
      return Me?.[nt];
    }
    function Zt(Me) {
      var nt = -1, vt = Array(Me.size);
      return Me.forEach(function(Pt, rr) {
        vt[++nt] = [rr, Pt];
      }), vt;
    }
    function Gt(Me, nt) {
      return function(vt) {
        return Me(nt(vt));
      };
    }
    function Yt(Me) {
      var nt = -1, vt = Array(Me.size);
      return Me.forEach(function(Pt) {
        vt[++nt] = Pt;
      }), vt;
    }
    var $t = Array.prototype, ir = Function.prototype, Je = Object.prototype, Ue = Be["__core-js_shared__"], We = ir.toString, lt = Je.hasOwnProperty, ft = function() {
      var Me = /[^.]+$/.exec(Ue && Ue.keys && Ue.keys.IE_PROTO || "");
      return Me ? "Symbol(src)_1." + Me : "";
    }(), Et = Je.toString, Lt = RegExp(
      "^" + We.call(lt).replace(wt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), Kt = it ? Be.Buffer : void 0, ar = Be.Symbol, sr = Be.Uint8Array, or = Je.propertyIsEnumerable, nr = $t.splice, Nr = ar ? ar.toStringTag : void 0, Zr = Object.getOwnPropertySymbols, va = Kt ? Kt.isBuffer : void 0, ea = Gt(Object.keys, Object), Gr = ra(Be, "DataView"), ta = ra(Be, "Map"), xa = ra(Be, "Promise"), ya = ra(Be, "Set"), ba = ra(Be, "WeakMap"), jr = ra(Object, "create"), Ba = Lr(Gr), Wr = Lr(ta), Ka = Lr(xa), wa = Lr(ya), Ya = Lr(ba), Da = ar ? ar.prototype : void 0, Ea = Da ? Da.valueOf : void 0;
    function Qe(Me) {
      var nt = -1, vt = Me == null ? 0 : Me.length;
      for (this.clear(); ++nt < vt; ) {
        var Pt = Me[nt];
        this.set(Pt[0], Pt[1]);
      }
    }
    function dt() {
      this.__data__ = jr ? jr(null) : {}, this.size = 0;
    }
    function ot(Me) {
      var nt = this.has(Me) && delete this.__data__[Me];
      return this.size -= nt ? 1 : 0, nt;
    }
    function ct(Me) {
      var nt = this.__data__;
      if (jr) {
        var vt = nt[Me];
        return vt === oe ? void 0 : vt;
      }
      return lt.call(nt, Me) ? nt[Me] : void 0;
    }
    function ut(Me) {
      var nt = this.__data__;
      return jr ? nt[Me] !== void 0 : lt.call(nt, Me);
    }
    function ht(Me, nt) {
      var vt = this.__data__;
      return this.size += this.has(Me) ? 0 : 1, vt[Me] = jr && nt === void 0 ? oe : nt, this;
    }
    Qe.prototype.clear = dt, Qe.prototype.delete = ot, Qe.prototype.get = ct, Qe.prototype.has = ut, Qe.prototype.set = ht;
    function Tt(Me) {
      var nt = -1, vt = Me == null ? 0 : Me.length;
      for (this.clear(); ++nt < vt; ) {
        var Pt = Me[nt];
        this.set(Pt[0], Pt[1]);
      }
    }
    function Nt() {
      this.__data__ = [], this.size = 0;
    }
    function At(Me) {
      var nt = this.__data__, vt = Ua(nt, Me);
      if (vt < 0)
        return !1;
      var Pt = nt.length - 1;
      return vt == Pt ? nt.pop() : nr.call(nt, vt, 1), --this.size, !0;
    }
    function Ft(Me) {
      var nt = this.__data__, vt = Ua(nt, Me);
      return vt < 0 ? void 0 : nt[vt][1];
    }
    function kt(Me) {
      return Ua(this.__data__, Me) > -1;
    }
    function Ht(Me, nt) {
      var vt = this.__data__, Pt = Ua(vt, Me);
      return Pt < 0 ? (++this.size, vt.push([Me, nt])) : vt[Pt][1] = nt, this;
    }
    Tt.prototype.clear = Nt, Tt.prototype.delete = At, Tt.prototype.get = Ft, Tt.prototype.has = kt, Tt.prototype.set = Ht;
    function Wt(Me) {
      var nt = -1, vt = Me == null ? 0 : Me.length;
      for (this.clear(); ++nt < vt; ) {
        var Pt = Me[nt];
        this.set(Pt[0], Pt[1]);
      }
    }
    function jt() {
      this.size = 0, this.__data__ = {
        hash: new Qe(),
        map: new (ta || Tt)(),
        string: new Qe()
      };
    }
    function zt(Me) {
      var nt = qr(this, Me).delete(Me);
      return this.size -= nt ? 1 : 0, nt;
    }
    function qt(Me) {
      return qr(this, Me).get(Me);
    }
    function tr(Me) {
      return qr(this, Me).has(Me);
    }
    function hr(Me, nt) {
      var vt = qr(this, Me), Pt = vt.size;
      return vt.set(Me, nt), this.size += vt.size == Pt ? 0 : 1, this;
    }
    Wt.prototype.clear = jt, Wt.prototype.delete = zt, Wt.prototype.get = qt, Wt.prototype.has = tr, Wt.prototype.set = hr;
    function ur(Me) {
      var nt = -1, vt = Me == null ? 0 : Me.length;
      for (this.__data__ = new Wt(); ++nt < vt; )
        this.add(Me[nt]);
    }
    function xr(Me) {
      return this.__data__.set(Me, oe), this;
    }
    function $r(Me) {
      return this.__data__.has(Me);
    }
    ur.prototype.add = ur.prototype.push = xr, ur.prototype.has = $r;
    function Ir(Me) {
      var nt = this.__data__ = new Tt(Me);
      this.size = nt.size;
    }
    function Hr() {
      this.__data__ = new Tt(), this.size = 0;
    }
    function zr(Me) {
      var nt = this.__data__, vt = nt.delete(Me);
      return this.size = nt.size, vt;
    }
    function Sa(Me) {
      return this.__data__.get(Me);
    }
    function Dr(Me) {
      return this.__data__.has(Me);
    }
    function Ei(Me, nt) {
      var vt = this.__data__;
      if (vt instanceof Tt) {
        var Pt = vt.__data__;
        if (!ta || Pt.length < re - 1)
          return Pt.push([Me, nt]), this.size = ++vt.size, this;
        vt = this.__data__ = new Wt(Pt);
      }
      return vt.set(Me, nt), this.size = vt.size, this;
    }
    Ir.prototype.clear = Hr, Ir.prototype.delete = zr, Ir.prototype.get = Sa, Ir.prototype.has = Dr, Ir.prototype.set = Ei;
    function Si(Me, nt) {
      var vt = $a(Me), Pt = !vt && fi(Me), rr = !vt && !Pt && Ma(Me), Qt = !vt && !Pt && !rr && mi(Me), cr = vt || Pt || rr || Qt, lr = cr ? Dt(Me.length, String) : [], yr = lr.length;
      for (var dr in Me)
        lt.call(Me, dr) && !(cr && // Safari 9 has enumerable `arguments.length` in strict mode.
        (dr == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        rr && (dr == "offset" || dr == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        Qt && (dr == "buffer" || dr == "byteLength" || dr == "byteOffset") || // Skip index properties.
        Oi(dr, yr))) && lr.push(dr);
      return lr;
    }
    function Ua(Me, nt) {
      for (var vt = Me.length; vt--; )
        if (di(Me[vt][0], nt))
          return vt;
      return -1;
    }
    function Qa(Me, nt, vt) {
      var Pt = nt(Me);
      return $a(Me) ? Pt : Ot(Pt, vt(Me));
    }
    function Ta(Me) {
      return Me == null ? Me === void 0 ? De : Ae : Nr && Nr in Object(Me) ? aa(Me) : ui(Me);
    }
    function li(Me) {
      return Kr(Me) && Ta(Me) == _e;
    }
    function ci(Me, nt, vt, Pt, rr) {
      return Me === nt ? !0 : Me == null || nt == null || !Kr(Me) && !Kr(nt) ? Me !== Me && nt !== nt : Ti(Me, nt, vt, Pt, ci, rr);
    }
    function Ti(Me, nt, vt, Pt, rr, Qt) {
      var cr = $a(Me), lr = $a(nt), yr = cr ? ve : Xr(Me), dr = lr ? ve : Xr(nt);
      yr = yr == _e ? Pe : yr, dr = dr == _e ? Pe : dr;
      var Fr = yr == Pe, Pr = dr == Pe, wr = yr == dr;
      if (wr && Ma(Me)) {
        if (!Ma(nt))
          return !1;
        cr = !0, Fr = !1;
      }
      if (wr && !Fr)
        return Qt || (Qt = new Ir()), cr || mi(Me) ? Ja(Me, nt, vt, Pt, rr, Qt) : Fi(Me, nt, yr, vt, Pt, rr, Qt);
      if (!(vt & ue)) {
        var kr = Fr && lt.call(Me, "__wrapped__"), Tr = Pr && lt.call(nt, "__wrapped__");
        if (kr || Tr) {
          var da = kr ? Me.value() : Me, ia = Tr ? nt.value() : nt;
          return Qt || (Qt = new Ir()), rr(da, ia, vt, Pt, Qt);
        }
      }
      return wr ? (Qt || (Qt = new Ir()), ki(Me, nt, vt, Pt, rr, Qt)) : !1;
    }
    function Ci(Me) {
      if (!pi(Me) || Ni(Me))
        return !1;
      var nt = hi(Me) ? Lt : yt;
      return nt.test(Lr(Me));
    }
    function Ai(Me) {
      return Kr(Me) && ei(Me.length) && !!It[Ta(Me)];
    }
    function Ii(Me) {
      if (!Pi(Me))
        return ea(Me);
      var nt = [];
      for (var vt in Object(Me))
        lt.call(Me, vt) && vt != "constructor" && nt.push(vt);
      return nt;
    }
    function Ja(Me, nt, vt, Pt, rr, Qt) {
      var cr = vt & ue, lr = Me.length, yr = nt.length;
      if (lr != yr && !(cr && yr > lr))
        return !1;
      var dr = Qt.get(Me);
      if (dr && Qt.get(nt))
        return dr == nt;
      var Fr = -1, Pr = !0, wr = vt & fe ? new ur() : void 0;
      for (Qt.set(Me, nt), Qt.set(nt, Me); ++Fr < lr; ) {
        var kr = Me[Fr], Tr = nt[Fr];
        if (Pt)
          var da = cr ? Pt(Tr, kr, Fr, nt, Me, Qt) : Pt(kr, Tr, Fr, Me, nt, Qt);
        if (da !== void 0) {
          if (da)
            continue;
          Pr = !1;
          break;
        }
        if (wr) {
          if (!Mt(nt, function(ia, Aa) {
            if (!Jt(wr, Aa) && (kr === ia || rr(kr, ia, vt, Pt, Qt)))
              return wr.push(Aa);
          })) {
            Pr = !1;
            break;
          }
        } else if (!(kr === Tr || rr(kr, Tr, vt, Pt, Qt))) {
          Pr = !1;
          break;
        }
      }
      return Qt.delete(Me), Qt.delete(nt), Pr;
    }
    function Fi(Me, nt, vt, Pt, rr, Qt, cr) {
      switch (vt) {
        case tt:
          if (Me.byteLength != nt.byteLength || Me.byteOffset != nt.byteOffset)
            return !1;
          Me = Me.buffer, nt = nt.buffer;
        case ze:
          return !(Me.byteLength != nt.byteLength || !Qt(new sr(Me), new sr(nt)));
        case Ee:
        case Se:
        case Re:
          return di(+Me, +nt);
        case Te:
          return Me.name == nt.name && Me.message == nt.message;
        case He:
        case Ve:
          return Me == nt + "";
        case Ne:
          var lr = Zt;
        case Ge:
          var yr = Pt & ue;
          if (lr || (lr = Yt), Me.size != nt.size && !yr)
            return !1;
          var dr = cr.get(Me);
          if (dr)
            return dr == nt;
          Pt |= fe, cr.set(Me, nt);
          var Fr = Ja(lr(Me), lr(nt), Pt, rr, Qt, cr);
          return cr.delete(Me), Fr;
        case $e:
          if (Ea)
            return Ea.call(Me) == Ea.call(nt);
      }
      return !1;
    }
    function ki(Me, nt, vt, Pt, rr, Qt) {
      var cr = vt & ue, lr = Ca(Me), yr = lr.length, dr = Ca(nt), Fr = dr.length;
      if (yr != Fr && !cr)
        return !1;
      for (var Pr = yr; Pr--; ) {
        var wr = lr[Pr];
        if (!(cr ? wr in nt : lt.call(nt, wr)))
          return !1;
      }
      var kr = Qt.get(Me);
      if (kr && Qt.get(nt))
        return kr == nt;
      var Tr = !0;
      Qt.set(Me, nt), Qt.set(nt, Me);
      for (var da = cr; ++Pr < yr; ) {
        wr = lr[Pr];
        var ia = Me[wr], Aa = nt[wr];
        if (Pt)
          var ji = cr ? Pt(Aa, ia, wr, nt, Me, Qt) : Pt(ia, Aa, wr, Me, nt, Qt);
        if (!(ji === void 0 ? ia === Aa || rr(ia, Aa, vt, Pt, Qt) : ji)) {
          Tr = !1;
          break;
        }
        da || (da = wr == "constructor");
      }
      if (Tr && !da) {
        var gi = Me.constructor, _i = nt.constructor;
        gi != _i && "constructor" in Me && "constructor" in nt && !(typeof gi == "function" && gi instanceof gi && typeof _i == "function" && _i instanceof _i) && (Tr = !1);
      }
      return Qt.delete(Me), Qt.delete(nt), Tr;
    }
    function Ca(Me) {
      return Qa(Me, ti, Li);
    }
    function qr(Me, nt) {
      var vt = Me.__data__;
      return Ri(nt) ? vt[typeof nt == "string" ? "string" : "hash"] : vt.map;
    }
    function ra(Me, nt) {
      var vt = er(Me, nt);
      return Ci(vt) ? vt : void 0;
    }
    function aa(Me) {
      var nt = lt.call(Me, Nr), vt = Me[Nr];
      try {
        Me[Nr] = void 0;
        var Pt = !0;
      } catch {
      }
      var rr = Et.call(Me);
      return Pt && (nt ? Me[Nr] = vt : delete Me[Nr]), rr;
    }
    var Li = Zr ? function(Me) {
      return Me == null ? [] : (Me = Object(Me), Rt(Zr(Me), function(nt) {
        return or.call(Me, nt);
      }));
    } : Di, Xr = Ta;
    (Gr && Xr(new Gr(new ArrayBuffer(1))) != tt || ta && Xr(new ta()) != Ne || xa && Xr(xa.resolve()) != Fe || ya && Xr(new ya()) != Ge || ba && Xr(new ba()) != Ke) && (Xr = function(Me) {
      var nt = Ta(Me), vt = nt == Pe ? Me.constructor : void 0, Pt = vt ? Lr(vt) : "";
      if (Pt)
        switch (Pt) {
          case Ba:
            return tt;
          case Wr:
            return Ne;
          case Ka:
            return Fe;
          case wa:
            return Ge;
          case Ya:
            return Ke;
        }
      return nt;
    });
    function Oi(Me, nt) {
      return nt = nt ?? he, !!nt && (typeof Me == "number" || St.test(Me)) && Me > -1 && Me % 1 == 0 && Me < nt;
    }
    function Ri(Me) {
      var nt = typeof Me;
      return nt == "string" || nt == "number" || nt == "symbol" || nt == "boolean" ? Me !== "__proto__" : Me === null;
    }
    function Ni(Me) {
      return !!ft && ft in Me;
    }
    function Pi(Me) {
      var nt = Me && Me.constructor, vt = typeof nt == "function" && nt.prototype || Je;
      return Me === vt;
    }
    function ui(Me) {
      return Et.call(Me);
    }
    function Lr(Me) {
      if (Me != null) {
        try {
          return We.call(Me);
        } catch {
        }
        try {
          return Me + "";
        } catch {
        }
      }
      return "";
    }
    function di(Me, nt) {
      return Me === nt || Me !== Me && nt !== nt;
    }
    var fi = li(/* @__PURE__ */ function() {
      return arguments;
    }()) ? li : function(Me) {
      return Kr(Me) && lt.call(Me, "callee") && !or.call(Me, "callee");
    }, $a = Array.isArray;
    function Za(Me) {
      return Me != null && ei(Me.length) && !hi(Me);
    }
    var Ma = va || Ui;
    function Bi(Me, nt) {
      return ci(Me, nt);
    }
    function hi(Me) {
      if (!pi(Me))
        return !1;
      var nt = Ta(Me);
      return nt == Ce || nt == Ie || nt == xe || nt == Le;
    }
    function ei(Me) {
      return typeof Me == "number" && Me > -1 && Me % 1 == 0 && Me <= he;
    }
    function pi(Me) {
      var nt = typeof Me;
      return Me != null && (nt == "object" || nt == "function");
    }
    function Kr(Me) {
      return Me != null && typeof Me == "object";
    }
    var mi = Ct ? Vt(Ct) : Ai;
    function ti(Me) {
      return Za(Me) ? Si(Me) : Ii(Me);
    }
    function Di() {
      return [];
    }
    function Ui() {
      return !1;
    }
    le.exports = Bi;
  }(lodash_isequal, lodash_isequal.exports)), lodash_isequal.exports;
}
var AttributeMap = {}, hasRequiredAttributeMap;
function requireAttributeMap() {
  if (hasRequiredAttributeMap) return AttributeMap;
  hasRequiredAttributeMap = 1, Object.defineProperty(AttributeMap, "__esModule", { value: !0 });
  const le = requireLodash_clonedeep(), Y = requireLodash_isequal();
  var re;
  return function(oe) {
    function ue(ve = {}, xe = {}, Ee = !1) {
      typeof ve != "object" && (ve = {}), typeof xe != "object" && (xe = {});
      let Se = le(xe);
      Ee || (Se = Object.keys(Se).reduce((Te, Ce) => (Se[Ce] != null && (Te[Ce] = Se[Ce]), Te), {}));
      for (const Te in ve)
        ve[Te] !== void 0 && xe[Te] === void 0 && (Se[Te] = ve[Te]);
      return Object.keys(Se).length > 0 ? Se : void 0;
    }
    oe.compose = ue;
    function fe(ve = {}, xe = {}) {
      typeof ve != "object" && (ve = {}), typeof xe != "object" && (xe = {});
      const Ee = Object.keys(ve).concat(Object.keys(xe)).reduce((Se, Te) => (Y(ve[Te], xe[Te]) || (Se[Te] = xe[Te] === void 0 ? null : xe[Te]), Se), {});
      return Object.keys(Ee).length > 0 ? Ee : void 0;
    }
    oe.diff = fe;
    function he(ve = {}, xe = {}) {
      ve = ve || {};
      const Ee = Object.keys(xe).reduce((Se, Te) => (xe[Te] !== ve[Te] && ve[Te] !== void 0 && (Se[Te] = xe[Te]), Se), {});
      return Object.keys(ve).reduce((Se, Te) => (ve[Te] !== xe[Te] && xe[Te] === void 0 && (Se[Te] = null), Se), Ee);
    }
    oe.invert = he;
    function _e(ve, xe, Ee = !1) {
      if (typeof ve != "object")
        return xe;
      if (typeof xe != "object")
        return;
      if (!Ee)
        return xe;
      const Se = Object.keys(xe).reduce((Te, Ce) => (ve[Ce] === void 0 && (Te[Ce] = xe[Ce]), Te), {});
      return Object.keys(Se).length > 0 ? Se : void 0;
    }
    oe.transform = _e;
  }(re || (re = {})), AttributeMap.default = re, AttributeMap;
}
var Op = {}, hasRequiredOp;
function requireOp() {
  if (hasRequiredOp) return Op;
  hasRequiredOp = 1, Object.defineProperty(Op, "__esModule", { value: !0 });
  var le;
  return function(Y) {
    function re(oe) {
      return typeof oe.delete == "number" ? oe.delete : typeof oe.retain == "number" ? oe.retain : typeof oe.retain == "object" && oe.retain !== null ? 1 : typeof oe.insert == "string" ? oe.insert.length : 1;
    }
    Y.length = re;
  }(le || (le = {})), Op.default = le, Op;
}
var OpIterator = {}, hasRequiredOpIterator;
function requireOpIterator() {
  if (hasRequiredOpIterator) return OpIterator;
  hasRequiredOpIterator = 1, Object.defineProperty(OpIterator, "__esModule", { value: !0 });
  const le = requireOp();
  class Y {
    constructor(oe) {
      this.ops = oe, this.index = 0, this.offset = 0;
    }
    hasNext() {
      return this.peekLength() < 1 / 0;
    }
    next(oe) {
      oe || (oe = 1 / 0);
      const ue = this.ops[this.index];
      if (ue) {
        const fe = this.offset, he = le.default.length(ue);
        if (oe >= he - fe ? (oe = he - fe, this.index += 1, this.offset = 0) : this.offset += oe, typeof ue.delete == "number")
          return { delete: oe };
        {
          const _e = {};
          return ue.attributes && (_e.attributes = ue.attributes), typeof ue.retain == "number" ? _e.retain = oe : typeof ue.retain == "object" && ue.retain !== null ? _e.retain = ue.retain : typeof ue.insert == "string" ? _e.insert = ue.insert.substr(fe, oe) : _e.insert = ue.insert, _e;
        }
      } else
        return { retain: 1 / 0 };
    }
    peek() {
      return this.ops[this.index];
    }
    peekLength() {
      return this.ops[this.index] ? le.default.length(this.ops[this.index]) - this.offset : 1 / 0;
    }
    peekType() {
      const oe = this.ops[this.index];
      return oe ? typeof oe.delete == "number" ? "delete" : typeof oe.retain == "number" || typeof oe.retain == "object" && oe.retain !== null ? "retain" : "insert" : "retain";
    }
    rest() {
      if (this.hasNext()) {
        if (this.offset === 0)
          return this.ops.slice(this.index);
        {
          const oe = this.offset, ue = this.index, fe = this.next(), he = this.ops.slice(this.index);
          return this.offset = oe, this.index = ue, [fe].concat(he);
        }
      } else return [];
    }
  }
  return OpIterator.default = Y, OpIterator;
}
var hasRequiredDelta;
function requireDelta() {
  return hasRequiredDelta || (hasRequiredDelta = 1, function(le, Y) {
    Object.defineProperty(Y, "__esModule", { value: !0 }), Y.AttributeMap = Y.OpIterator = Y.Op = void 0;
    const re = requireDiff(), oe = requireLodash_clonedeep(), ue = requireLodash_isequal(), fe = requireAttributeMap();
    Y.AttributeMap = fe.default;
    const he = requireOp();
    Y.Op = he.default;
    const _e = requireOpIterator();
    Y.OpIterator = _e.default;
    const ve = "\0", xe = (Se, Te) => {
      if (typeof Se != "object" || Se === null)
        throw new Error(`cannot retain a ${typeof Se}`);
      if (typeof Te != "object" || Te === null)
        throw new Error(`cannot retain a ${typeof Te}`);
      const Ce = Object.keys(Se)[0];
      if (!Ce || Ce !== Object.keys(Te)[0])
        throw new Error(`embed types not matched: ${Ce} != ${Object.keys(Te)[0]}`);
      return [Ce, Se[Ce], Te[Ce]];
    };
    class Ee {
      constructor(Te) {
        Array.isArray(Te) ? this.ops = Te : Te != null && Array.isArray(Te.ops) ? this.ops = Te.ops : this.ops = [];
      }
      static registerEmbed(Te, Ce) {
        this.handlers[Te] = Ce;
      }
      static unregisterEmbed(Te) {
        delete this.handlers[Te];
      }
      static getHandler(Te) {
        const Ce = this.handlers[Te];
        if (!Ce)
          throw new Error(`no handlers for embed type "${Te}"`);
        return Ce;
      }
      insert(Te, Ce) {
        const Ie = {};
        return typeof Te == "string" && Te.length === 0 ? this : (Ie.insert = Te, Ce != null && typeof Ce == "object" && Object.keys(Ce).length > 0 && (Ie.attributes = Ce), this.push(Ie));
      }
      delete(Te) {
        return Te <= 0 ? this : this.push({ delete: Te });
      }
      retain(Te, Ce) {
        if (typeof Te == "number" && Te <= 0)
          return this;
        const Ie = { retain: Te };
        return Ce != null && typeof Ce == "object" && Object.keys(Ce).length > 0 && (Ie.attributes = Ce), this.push(Ie);
      }
      push(Te) {
        let Ce = this.ops.length, Ie = this.ops[Ce - 1];
        if (Te = oe(Te), typeof Ie == "object") {
          if (typeof Te.delete == "number" && typeof Ie.delete == "number")
            return this.ops[Ce - 1] = { delete: Ie.delete + Te.delete }, this;
          if (typeof Ie.delete == "number" && Te.insert != null && (Ce -= 1, Ie = this.ops[Ce - 1], typeof Ie != "object"))
            return this.ops.unshift(Te), this;
          if (ue(Te.attributes, Ie.attributes)) {
            if (typeof Te.insert == "string" && typeof Ie.insert == "string")
              return this.ops[Ce - 1] = { insert: Ie.insert + Te.insert }, typeof Te.attributes == "object" && (this.ops[Ce - 1].attributes = Te.attributes), this;
            if (typeof Te.retain == "number" && typeof Ie.retain == "number")
              return this.ops[Ce - 1] = { retain: Ie.retain + Te.retain }, typeof Te.attributes == "object" && (this.ops[Ce - 1].attributes = Te.attributes), this;
          }
        }
        return Ce === this.ops.length ? this.ops.push(Te) : this.ops.splice(Ce, 0, Te), this;
      }
      chop() {
        const Te = this.ops[this.ops.length - 1];
        return Te && typeof Te.retain == "number" && !Te.attributes && this.ops.pop(), this;
      }
      filter(Te) {
        return this.ops.filter(Te);
      }
      forEach(Te) {
        this.ops.forEach(Te);
      }
      map(Te) {
        return this.ops.map(Te);
      }
      partition(Te) {
        const Ce = [], Ie = [];
        return this.forEach((Ne) => {
          (Te(Ne) ? Ce : Ie).push(Ne);
        }), [Ce, Ie];
      }
      reduce(Te, Ce) {
        return this.ops.reduce(Te, Ce);
      }
      changeLength() {
        return this.reduce((Te, Ce) => Ce.insert ? Te + he.default.length(Ce) : Ce.delete ? Te - Ce.delete : Te, 0);
      }
      length() {
        return this.reduce((Te, Ce) => Te + he.default.length(Ce), 0);
      }
      slice(Te = 0, Ce = 1 / 0) {
        const Ie = [], Ne = new _e.default(this.ops);
        let Re = 0;
        for (; Re < Ce && Ne.hasNext(); ) {
          let Ae;
          Re < Te ? Ae = Ne.next(Te - Re) : (Ae = Ne.next(Ce - Re), Ie.push(Ae)), Re += he.default.length(Ae);
        }
        return new Ee(Ie);
      }
      compose(Te) {
        const Ce = new _e.default(this.ops), Ie = new _e.default(Te.ops), Ne = [], Re = Ie.peek();
        if (Re != null && typeof Re.retain == "number" && Re.attributes == null) {
          let Pe = Re.retain;
          for (; Ce.peekType() === "insert" && Ce.peekLength() <= Pe; )
            Pe -= Ce.peekLength(), Ne.push(Ce.next());
          Re.retain - Pe > 0 && Ie.next(Re.retain - Pe);
        }
        const Ae = new Ee(Ne);
        for (; Ce.hasNext() || Ie.hasNext(); )
          if (Ie.peekType() === "insert")
            Ae.push(Ie.next());
          else if (Ce.peekType() === "delete")
            Ae.push(Ce.next());
          else {
            const Pe = Math.min(Ce.peekLength(), Ie.peekLength()), Fe = Ce.next(Pe), Le = Ie.next(Pe);
            if (Le.retain) {
              const He = {};
              if (typeof Fe.retain == "number")
                He.retain = typeof Le.retain == "number" ? Pe : Le.retain;
              else if (typeof Le.retain == "number")
                Fe.retain == null ? He.insert = Fe.insert : He.retain = Fe.retain;
              else {
                const Ve = Fe.retain == null ? "insert" : "retain", [$e, De, Ke] = xe(Fe[Ve], Le.retain), ze = Ee.getHandler($e);
                He[Ve] = {
                  [$e]: ze.compose(De, Ke, Ve === "retain")
                };
              }
              const Ge = fe.default.compose(Fe.attributes, Le.attributes, typeof Fe.retain == "number");
              if (Ge && (He.attributes = Ge), Ae.push(He), !Ie.hasNext() && ue(Ae.ops[Ae.ops.length - 1], He)) {
                const Ve = new Ee(Ce.rest());
                return Ae.concat(Ve).chop();
              }
            } else typeof Le.delete == "number" && (typeof Fe.retain == "number" || typeof Fe.retain == "object" && Fe.retain !== null) && Ae.push(Le);
          }
        return Ae.chop();
      }
      concat(Te) {
        const Ce = new Ee(this.ops.slice());
        return Te.ops.length > 0 && (Ce.push(Te.ops[0]), Ce.ops = Ce.ops.concat(Te.ops.slice(1))), Ce;
      }
      diff(Te, Ce) {
        if (this.ops === Te.ops)
          return new Ee();
        const Ie = [this, Te].map((Fe) => Fe.map((Le) => {
          if (Le.insert != null)
            return typeof Le.insert == "string" ? Le.insert : ve;
          const He = Fe === Te ? "on" : "with";
          throw new Error("diff() called " + He + " non-document");
        }).join("")), Ne = new Ee(), Re = re(Ie[0], Ie[1], Ce, !0), Ae = new _e.default(this.ops), Pe = new _e.default(Te.ops);
        return Re.forEach((Fe) => {
          let Le = Fe[1].length;
          for (; Le > 0; ) {
            let He = 0;
            switch (Fe[0]) {
              case re.INSERT:
                He = Math.min(Pe.peekLength(), Le), Ne.push(Pe.next(He));
                break;
              case re.DELETE:
                He = Math.min(Le, Ae.peekLength()), Ae.next(He), Ne.delete(He);
                break;
              case re.EQUAL:
                He = Math.min(Ae.peekLength(), Pe.peekLength(), Le);
                const Ge = Ae.next(He), Ve = Pe.next(He);
                ue(Ge.insert, Ve.insert) ? Ne.retain(He, fe.default.diff(Ge.attributes, Ve.attributes)) : Ne.push(Ve).delete(He);
                break;
            }
            Le -= He;
          }
        }), Ne.chop();
      }
      eachLine(Te, Ce = `
`) {
        const Ie = new _e.default(this.ops);
        let Ne = new Ee(), Re = 0;
        for (; Ie.hasNext(); ) {
          if (Ie.peekType() !== "insert")
            return;
          const Ae = Ie.peek(), Pe = he.default.length(Ae) - Ie.peekLength(), Fe = typeof Ae.insert == "string" ? Ae.insert.indexOf(Ce, Pe) - Pe : -1;
          if (Fe < 0)
            Ne.push(Ie.next());
          else if (Fe > 0)
            Ne.push(Ie.next(Fe));
          else {
            if (Te(Ne, Ie.next(1).attributes || {}, Re) === !1)
              return;
            Re += 1, Ne = new Ee();
          }
        }
        Ne.length() > 0 && Te(Ne, {}, Re);
      }
      invert(Te) {
        const Ce = new Ee();
        return this.reduce((Ie, Ne) => {
          if (Ne.insert)
            Ce.delete(he.default.length(Ne));
          else {
            if (typeof Ne.retain == "number" && Ne.attributes == null)
              return Ce.retain(Ne.retain), Ie + Ne.retain;
            if (Ne.delete || typeof Ne.retain == "number") {
              const Re = Ne.delete || Ne.retain;
              return Te.slice(Ie, Ie + Re).forEach((Pe) => {
                Ne.delete ? Ce.push(Pe) : Ne.retain && Ne.attributes && Ce.retain(he.default.length(Pe), fe.default.invert(Ne.attributes, Pe.attributes));
              }), Ie + Re;
            } else if (typeof Ne.retain == "object" && Ne.retain !== null) {
              const Re = Te.slice(Ie, Ie + 1), Ae = new _e.default(Re.ops).next(), [Pe, Fe, Le] = xe(Ne.retain, Ae.insert), He = Ee.getHandler(Pe);
              return Ce.retain({ [Pe]: He.invert(Fe, Le) }, fe.default.invert(Ne.attributes, Ae.attributes)), Ie + 1;
            }
          }
          return Ie;
        }, 0), Ce.chop();
      }
      transform(Te, Ce = !1) {
        if (Ce = !!Ce, typeof Te == "number")
          return this.transformPosition(Te, Ce);
        const Ie = Te, Ne = new _e.default(this.ops), Re = new _e.default(Ie.ops), Ae = new Ee();
        for (; Ne.hasNext() || Re.hasNext(); )
          if (Ne.peekType() === "insert" && (Ce || Re.peekType() !== "insert"))
            Ae.retain(he.default.length(Ne.next()));
          else if (Re.peekType() === "insert")
            Ae.push(Re.next());
          else {
            const Pe = Math.min(Ne.peekLength(), Re.peekLength()), Fe = Ne.next(Pe), Le = Re.next(Pe);
            if (Fe.delete)
              continue;
            if (Le.delete)
              Ae.push(Le);
            else {
              const He = Fe.retain, Ge = Le.retain;
              let Ve = typeof Ge == "object" && Ge !== null ? Ge : Pe;
              if (typeof He == "object" && He !== null && typeof Ge == "object" && Ge !== null) {
                const $e = Object.keys(He)[0];
                if ($e === Object.keys(Ge)[0]) {
                  const De = Ee.getHandler($e);
                  De && (Ve = {
                    [$e]: De.transform(He[$e], Ge[$e], Ce)
                  });
                }
              }
              Ae.retain(Ve, fe.default.transform(Fe.attributes, Le.attributes, Ce));
            }
          }
        return Ae.chop();
      }
      transformPosition(Te, Ce = !1) {
        Ce = !!Ce;
        const Ie = new _e.default(this.ops);
        let Ne = 0;
        for (; Ie.hasNext() && Ne <= Te; ) {
          const Re = Ie.peekLength(), Ae = Ie.peekType();
          if (Ie.next(), Ae === "delete") {
            Te -= Math.min(Re, Te - Ne);
            continue;
          } else Ae === "insert" && (Ne < Te || !Ce) && (Te += Re);
          Ne += Re;
        }
        return Te;
      }
    }
    Ee.Op = he.default, Ee.OpIterator = _e.default, Ee.AttributeMap = fe.default, Ee.handlers = {}, Y.default = Ee, le.exports = Ee, le.exports.default = Ee;
  }(Delta$1, Delta$1.exports)), Delta$1.exports;
}
var DeltaExports = requireDelta();
const Delta = /* @__PURE__ */ getDefaultExportFromCjs(DeltaExports);
class Break extends EmbedBlot$1 {
  static value() {
  }
  optimize() {
    (this.prev || this.next) && this.remove();
  }
  length() {
    return 0;
  }
  value() {
    return "";
  }
}
Break.blotName = "break";
Break.tagName = "BR";
let Text$1 = class extends TextBlot$1 {
};
const entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function escapeText(le) {
  return le.replace(/[&<>"']/g, (Y) => entityMap[Y]);
}
class Inline extends InlineBlot$1 {
  static allowedChildren = [Inline, Break, EmbedBlot$1, Text$1];
  // Lower index means deeper in the DOM tree, since not found (-1) is for embeds
  static order = [
    "cursor",
    "inline",
    // Must be lower
    "link",
    // Chrome wants <a> to be lower
    "underline",
    "strike",
    "italic",
    "bold",
    "script",
    "code"
    // Must be higher
  ];
  static compare(Y, re) {
    const oe = Inline.order.indexOf(Y), ue = Inline.order.indexOf(re);
    return oe >= 0 || ue >= 0 ? oe - ue : Y === re ? 0 : Y < re ? -1 : 1;
  }
  formatAt(Y, re, oe, ue) {
    if (Inline.compare(this.statics.blotName, oe) < 0 && this.scroll.query(oe, Scope.BLOT)) {
      const fe = this.isolate(Y, re);
      ue && fe.wrap(oe, ue);
    } else
      super.formatAt(Y, re, oe, ue);
  }
  optimize(Y) {
    if (super.optimize(Y), this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
      const re = this.parent.isolate(this.offset(), this.length());
      this.moveChildren(re), re.wrap(this);
    }
  }
}
const NEWLINE_LENGTH = 1;
class Block extends BlockBlot$1 {
  cache = {};
  delta() {
    return this.cache.delta == null && (this.cache.delta = blockDelta(this)), this.cache.delta;
  }
  deleteAt(Y, re) {
    super.deleteAt(Y, re), this.cache = {};
  }
  formatAt(Y, re, oe, ue) {
    re <= 0 || (this.scroll.query(oe, Scope.BLOCK) ? Y + re === this.length() && this.format(oe, ue) : super.formatAt(Y, Math.min(re, this.length() - Y - 1), oe, ue), this.cache = {});
  }
  insertAt(Y, re, oe) {
    if (oe != null) {
      super.insertAt(Y, re, oe), this.cache = {};
      return;
    }
    if (re.length === 0) return;
    const ue = re.split(`
`), fe = ue.shift();
    fe.length > 0 && (Y < this.length() - 1 || this.children.tail == null ? super.insertAt(Math.min(Y, this.length() - 1), fe) : this.children.tail.insertAt(this.children.tail.length(), fe), this.cache = {});
    let he = this;
    ue.reduce((_e, ve) => (he = he.split(_e, !0), he.insertAt(0, ve), ve.length), Y + fe.length);
  }
  insertBefore(Y, re) {
    const {
      head: oe
    } = this.children;
    super.insertBefore(Y, re), oe instanceof Break && oe.remove(), this.cache = {};
  }
  length() {
    return this.cache.length == null && (this.cache.length = super.length() + NEWLINE_LENGTH), this.cache.length;
  }
  moveChildren(Y, re) {
    super.moveChildren(Y, re), this.cache = {};
  }
  optimize(Y) {
    super.optimize(Y), this.cache = {};
  }
  path(Y) {
    return super.path(Y, !0);
  }
  removeChild(Y) {
    super.removeChild(Y), this.cache = {};
  }
  split(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (re && (Y === 0 || Y >= this.length() - NEWLINE_LENGTH)) {
      const ue = this.clone();
      return Y === 0 ? (this.parent.insertBefore(ue, this), this) : (this.parent.insertBefore(ue, this.next), ue);
    }
    const oe = super.split(Y, re);
    return this.cache = {}, oe;
  }
}
Block.blotName = "block";
Block.tagName = "P";
Block.defaultChild = Break;
Block.allowedChildren = [Break, Inline, EmbedBlot$1, Text$1];
class BlockEmbed extends EmbedBlot$1 {
  attach() {
    super.attach(), this.attributes = new AttributorStore$1(this.domNode);
  }
  delta() {
    return new Delta().insert(this.value(), {
      ...this.formats(),
      ...this.attributes.values()
    });
  }
  format(Y, re) {
    const oe = this.scroll.query(Y, Scope.BLOCK_ATTRIBUTE);
    oe != null && this.attributes.attribute(oe, re);
  }
  formatAt(Y, re, oe, ue) {
    this.format(oe, ue);
  }
  insertAt(Y, re, oe) {
    if (oe != null) {
      super.insertAt(Y, re, oe);
      return;
    }
    const ue = re.split(`
`), fe = ue.pop(), he = ue.map((ve) => {
      const xe = this.scroll.create(Block.blotName);
      return xe.insertAt(0, ve), xe;
    }), _e = this.split(Y);
    he.forEach((ve) => {
      this.parent.insertBefore(ve, _e);
    }), fe && this.parent.insertBefore(this.scroll.create("text", fe), _e);
  }
}
BlockEmbed.scope = Scope.BLOCK_BLOT;
function blockDelta(le) {
  let Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return le.descendants(LeafBlot$1).reduce((re, oe) => oe.length() === 0 ? re : re.insert(oe.value(), bubbleFormats(oe, {}, Y)), new Delta()).insert(`
`, bubbleFormats(le));
}
function bubbleFormats(le) {
  let Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, re = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  return le == null || ("formats" in le && typeof le.formats == "function" && (Y = {
    ...Y,
    ...le.formats()
  }, re && delete Y["code-token"]), le.parent == null || le.parent.statics.blotName === "scroll" || le.parent.statics.scope !== le.statics.scope) ? Y : bubbleFormats(le.parent, Y, re);
}
class Cursor extends EmbedBlot$1 {
  static blotName = "cursor";
  static className = "ql-cursor";
  static tagName = "span";
  static CONTENTS = "\uFEFF";
  // Zero width no break space
  static value() {
  }
  constructor(Y, re, oe) {
    super(Y, re), this.selection = oe, this.textNode = document.createTextNode(Cursor.CONTENTS), this.domNode.appendChild(this.textNode), this.savedLength = 0;
  }
  detach() {
    this.parent != null && this.parent.removeChild(this);
  }
  format(Y, re) {
    if (this.savedLength !== 0) {
      super.format(Y, re);
      return;
    }
    let oe = this, ue = 0;
    for (; oe != null && oe.statics.scope !== Scope.BLOCK_BLOT; )
      ue += oe.offset(oe.parent), oe = oe.parent;
    oe != null && (this.savedLength = Cursor.CONTENTS.length, oe.optimize(), oe.formatAt(ue, Cursor.CONTENTS.length, Y, re), this.savedLength = 0);
  }
  index(Y, re) {
    return Y === this.textNode ? 0 : super.index(Y, re);
  }
  length() {
    return this.savedLength;
  }
  position() {
    return [this.textNode, this.textNode.data.length];
  }
  remove() {
    super.remove(), this.parent = null;
  }
  restore() {
    if (this.selection.composing || this.parent == null) return null;
    const Y = this.selection.getNativeRange();
    for (; this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode; )
      this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
    const re = this.prev instanceof Text$1 ? this.prev : null, oe = re ? re.length() : 0, ue = this.next instanceof Text$1 ? this.next : null, fe = ue ? ue.text : "", {
      textNode: he
    } = this, _e = he.data.split(Cursor.CONTENTS).join("");
    he.data = Cursor.CONTENTS;
    let ve;
    if (re)
      ve = re, (_e || ue) && (re.insertAt(re.length(), _e + fe), ue && ue.remove());
    else if (ue)
      ve = ue, ue.insertAt(0, _e);
    else {
      const xe = document.createTextNode(_e);
      ve = this.scroll.create(xe), this.parent.insertBefore(ve, this);
    }
    if (this.remove(), Y) {
      const xe = (Te, Ce) => re && Te === re.domNode ? Ce : Te === he ? oe + Ce - 1 : ue && Te === ue.domNode ? oe + _e.length + Ce : null, Ee = xe(Y.start.node, Y.start.offset), Se = xe(Y.end.node, Y.end.offset);
      if (Ee !== null && Se !== null)
        return {
          startNode: ve.domNode,
          startOffset: Ee,
          endNode: ve.domNode,
          endOffset: Se
        };
    }
    return null;
  }
  update(Y, re) {
    if (Y.some((oe) => oe.type === "characterData" && oe.target === this.textNode)) {
      const oe = this.restore();
      oe && (re.range = oe);
    }
  }
  // Avoid .ql-cursor being a descendant of `<a/>`.
  // The reason is Safari pushes down `<a/>` on text insertion.
  // That will cause DOM nodes not sync with the model.
  //
  // For example ({I} is the caret), given the markup:
  //    <a><span class="ql-cursor">\uFEFF{I}</span></a>
  // When typing a char "x", `<a/>` will be pushed down inside the `<span>` first:
  //    <span class="ql-cursor"><a>\uFEFF{I}</a></span>
  // And then "x" will be inserted after `<a/>`:
  //    <span class="ql-cursor"><a>\uFEFF</a>d{I}</span>
  optimize(Y) {
    super.optimize(Y);
    let {
      parent: re
    } = this;
    for (; re; ) {
      if (re.domNode.tagName === "A") {
        this.savedLength = Cursor.CONTENTS.length, re.isolate(this.offset(re), this.length()).unwrap(), this.savedLength = 0;
        break;
      }
      re = re.parent;
    }
  }
  value() {
    return "";
  }
}
const instances = /* @__PURE__ */ new WeakMap(), levels = ["error", "warn", "log", "info"];
let level = "warn";
function debug$6(le) {
  if (level && levels.indexOf(le) <= levels.indexOf(level)) {
    for (var Y = arguments.length, re = new Array(Y > 1 ? Y - 1 : 0), oe = 1; oe < Y; oe++)
      re[oe - 1] = arguments[oe];
    console[le](...re);
  }
}
function namespace(le) {
  return levels.reduce((Y, re) => (Y[re] = debug$6.bind(console, re, le), Y), {});
}
namespace.level = (le) => {
  level = le;
};
debug$6.level = namespace.level;
const debug$5 = namespace("quill:events"), EVENTS = ["selectionchange", "mousedown", "mouseup", "click"];
EVENTS.forEach((le) => {
  document.addEventListener(le, function() {
    for (var Y = arguments.length, re = new Array(Y), oe = 0; oe < Y; oe++)
      re[oe] = arguments[oe];
    Array.from(document.querySelectorAll(".ql-container")).forEach((ue) => {
      const fe = instances.get(ue);
      fe && fe.emitter && fe.emitter.handleDOM(...re);
    });
  });
});
class Emitter extends EventEmitter {
  static events = {
    EDITOR_CHANGE: "editor-change",
    SCROLL_BEFORE_UPDATE: "scroll-before-update",
    SCROLL_BLOT_MOUNT: "scroll-blot-mount",
    SCROLL_BLOT_UNMOUNT: "scroll-blot-unmount",
    SCROLL_OPTIMIZE: "scroll-optimize",
    SCROLL_UPDATE: "scroll-update",
    SCROLL_EMBED_UPDATE: "scroll-embed-update",
    SELECTION_CHANGE: "selection-change",
    TEXT_CHANGE: "text-change",
    COMPOSITION_BEFORE_START: "composition-before-start",
    COMPOSITION_START: "composition-start",
    COMPOSITION_BEFORE_END: "composition-before-end",
    COMPOSITION_END: "composition-end"
  };
  static sources = {
    API: "api",
    SILENT: "silent",
    USER: "user"
  };
  constructor() {
    super(), this.domListeners = {}, this.on("error", debug$5.error);
  }
  emit() {
    for (var Y = arguments.length, re = new Array(Y), oe = 0; oe < Y; oe++)
      re[oe] = arguments[oe];
    return debug$5.log.call(debug$5, ...re), super.emit(...re);
  }
  handleDOM(Y) {
    for (var re = arguments.length, oe = new Array(re > 1 ? re - 1 : 0), ue = 1; ue < re; ue++)
      oe[ue - 1] = arguments[ue];
    (this.domListeners[Y.type] || []).forEach((fe) => {
      let {
        node: he,
        handler: _e
      } = fe;
      (Y.target === he || he.contains(Y.target)) && _e(Y, ...oe);
    });
  }
  listenDOM(Y, re, oe) {
    this.domListeners[Y] || (this.domListeners[Y] = []), this.domListeners[Y].push({
      node: re,
      handler: oe
    });
  }
}
const debug$4 = namespace("quill:selection");
class Range {
  constructor(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    this.index = Y, this.length = re;
  }
}
class Selection {
  constructor(Y, re) {
    this.emitter = re, this.scroll = Y, this.composing = !1, this.mouseDown = !1, this.root = this.scroll.domNode, this.cursor = this.scroll.create("cursor", this), this.savedRange = new Range(0, 0), this.lastRange = this.savedRange, this.lastNative = null, this.handleComposition(), this.handleDragging(), this.emitter.listenDOM("selectionchange", document, () => {
      !this.mouseDown && !this.composing && setTimeout(this.update.bind(this, Emitter.sources.USER), 1);
    }), this.emitter.on(Emitter.events.SCROLL_BEFORE_UPDATE, () => {
      if (!this.hasFocus()) return;
      const oe = this.getNativeRange();
      oe != null && oe.start.node !== this.cursor.textNode && this.emitter.once(Emitter.events.SCROLL_UPDATE, (ue, fe) => {
        try {
          this.root.contains(oe.start.node) && this.root.contains(oe.end.node) && this.setNativeRange(oe.start.node, oe.start.offset, oe.end.node, oe.end.offset);
          const he = fe.some((_e) => _e.type === "characterData" || _e.type === "childList" || _e.type === "attributes" && _e.target === this.root);
          this.update(he ? Emitter.sources.SILENT : ue);
        } catch {
        }
      });
    }), this.emitter.on(Emitter.events.SCROLL_OPTIMIZE, (oe, ue) => {
      if (ue.range) {
        const {
          startNode: fe,
          startOffset: he,
          endNode: _e,
          endOffset: ve
        } = ue.range;
        this.setNativeRange(fe, he, _e, ve), this.update(Emitter.sources.SILENT);
      }
    }), this.update(Emitter.sources.SILENT);
  }
  handleComposition() {
    this.emitter.on(Emitter.events.COMPOSITION_BEFORE_START, () => {
      this.composing = !0;
    }), this.emitter.on(Emitter.events.COMPOSITION_END, () => {
      if (this.composing = !1, this.cursor.parent) {
        const Y = this.cursor.restore();
        if (!Y) return;
        setTimeout(() => {
          this.setNativeRange(Y.startNode, Y.startOffset, Y.endNode, Y.endOffset);
        }, 1);
      }
    });
  }
  handleDragging() {
    this.emitter.listenDOM("mousedown", document.body, () => {
      this.mouseDown = !0;
    }), this.emitter.listenDOM("mouseup", document.body, () => {
      this.mouseDown = !1, this.update(Emitter.sources.USER);
    });
  }
  focus() {
    this.hasFocus() || (this.root.focus({
      preventScroll: !0
    }), this.setRange(this.savedRange));
  }
  format(Y, re) {
    this.scroll.update();
    const oe = this.getNativeRange();
    if (!(oe == null || !oe.native.collapsed || this.scroll.query(Y, Scope.BLOCK))) {
      if (oe.start.node !== this.cursor.textNode) {
        const ue = this.scroll.find(oe.start.node, !1);
        if (ue == null) return;
        if (ue instanceof LeafBlot$1) {
          const fe = ue.split(oe.start.offset);
          ue.parent.insertBefore(this.cursor, fe);
        } else
          ue.insertBefore(this.cursor, oe.start.node);
        this.cursor.attach();
      }
      this.cursor.format(Y, re), this.scroll.optimize(), this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length), this.update();
    }
  }
  getBounds(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const oe = this.scroll.length();
    Y = Math.min(Y, oe - 1), re = Math.min(Y + re, oe - 1) - Y;
    let ue, [fe, he] = this.scroll.leaf(Y);
    if (fe == null) return null;
    if (re > 0 && he === fe.length()) {
      const [Ee] = this.scroll.leaf(Y + 1);
      if (Ee) {
        const [Se] = this.scroll.line(Y), [Te] = this.scroll.line(Y + 1);
        Se === Te && (fe = Ee, he = 0);
      }
    }
    [ue, he] = fe.position(he, !0);
    const _e = document.createRange();
    if (re > 0)
      return _e.setStart(ue, he), [fe, he] = this.scroll.leaf(Y + re), fe == null ? null : ([ue, he] = fe.position(he, !0), _e.setEnd(ue, he), _e.getBoundingClientRect());
    let ve = "left", xe;
    if (ue instanceof Text) {
      if (!ue.data.length)
        return null;
      he < ue.data.length ? (_e.setStart(ue, he), _e.setEnd(ue, he + 1)) : (_e.setStart(ue, he - 1), _e.setEnd(ue, he), ve = "right"), xe = _e.getBoundingClientRect();
    } else {
      if (!(fe.domNode instanceof Element)) return null;
      xe = fe.domNode.getBoundingClientRect(), he > 0 && (ve = "right");
    }
    return {
      bottom: xe.top + xe.height,
      height: xe.height,
      left: xe[ve],
      right: xe[ve],
      top: xe.top,
      width: 0
    };
  }
  getNativeRange() {
    const Y = document.getSelection();
    if (Y == null || Y.rangeCount <= 0) return null;
    const re = Y.getRangeAt(0);
    if (re == null) return null;
    const oe = this.normalizeNative(re);
    return debug$4.info("getNativeRange", oe), oe;
  }
  getRange() {
    const Y = this.scroll.domNode;
    if ("isConnected" in Y && !Y.isConnected)
      return [null, null];
    const re = this.getNativeRange();
    return re == null ? [null, null] : [this.normalizedToRange(re), re];
  }
  hasFocus() {
    return document.activeElement === this.root || document.activeElement != null && contains(this.root, document.activeElement);
  }
  normalizedToRange(Y) {
    const re = [[Y.start.node, Y.start.offset]];
    Y.native.collapsed || re.push([Y.end.node, Y.end.offset]);
    const oe = re.map((he) => {
      const [_e, ve] = he, xe = this.scroll.find(_e, !0), Ee = xe.offset(this.scroll);
      return ve === 0 ? Ee : xe instanceof LeafBlot$1 ? Ee + xe.index(_e, ve) : Ee + xe.length();
    }), ue = Math.min(Math.max(...oe), this.scroll.length() - 1), fe = Math.min(ue, ...oe);
    return new Range(fe, ue - fe);
  }
  normalizeNative(Y) {
    if (!contains(this.root, Y.startContainer) || !Y.collapsed && !contains(this.root, Y.endContainer))
      return null;
    const re = {
      start: {
        node: Y.startContainer,
        offset: Y.startOffset
      },
      end: {
        node: Y.endContainer,
        offset: Y.endOffset
      },
      native: Y
    };
    return [re.start, re.end].forEach((oe) => {
      let {
        node: ue,
        offset: fe
      } = oe;
      for (; !(ue instanceof Text) && ue.childNodes.length > 0; )
        if (ue.childNodes.length > fe)
          ue = ue.childNodes[fe], fe = 0;
        else if (ue.childNodes.length === fe)
          ue = ue.lastChild, ue instanceof Text ? fe = ue.data.length : ue.childNodes.length > 0 ? fe = ue.childNodes.length : fe = ue.childNodes.length + 1;
        else
          break;
      oe.node = ue, oe.offset = fe;
    }), re;
  }
  rangeToNative(Y) {
    const re = this.scroll.length(), oe = (ue, fe) => {
      ue = Math.min(re - 1, ue);
      const [he, _e] = this.scroll.leaf(ue);
      return he ? he.position(_e, fe) : [null, -1];
    };
    return [...oe(Y.index, !1), ...oe(Y.index + Y.length, !0)];
  }
  setNativeRange(Y, re) {
    let oe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Y, ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : re, fe = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    if (debug$4.info("setNativeRange", Y, re, oe, ue), Y != null && (this.root.parentNode == null || Y.parentNode == null || // @ts-expect-error Fix me later
    oe.parentNode == null))
      return;
    const he = document.getSelection();
    if (he != null)
      if (Y != null) {
        this.hasFocus() || this.root.focus({
          preventScroll: !0
        });
        const {
          native: _e
        } = this.getNativeRange() || {};
        if (_e == null || fe || Y !== _e.startContainer || re !== _e.startOffset || oe !== _e.endContainer || ue !== _e.endOffset) {
          Y instanceof Element && Y.tagName === "BR" && (re = Array.from(Y.parentNode.childNodes).indexOf(Y), Y = Y.parentNode), oe instanceof Element && oe.tagName === "BR" && (ue = Array.from(oe.parentNode.childNodes).indexOf(oe), oe = oe.parentNode);
          const ve = document.createRange();
          ve.setStart(Y, re), ve.setEnd(oe, ue), he.removeAllRanges(), he.addRange(ve);
        }
      } else
        he.removeAllRanges(), this.root.blur();
  }
  setRange(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, oe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Emitter.sources.API;
    if (typeof re == "string" && (oe = re, re = !1), debug$4.info("setRange", Y), Y != null) {
      const ue = this.rangeToNative(Y);
      this.setNativeRange(...ue, re);
    } else
      this.setNativeRange(null);
    this.update(oe);
  }
  update() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Emitter.sources.USER;
    const re = this.lastRange, [oe, ue] = this.getRange();
    if (this.lastRange = oe, this.lastNative = ue, this.lastRange != null && (this.savedRange = this.lastRange), !isEqual$2(re, this.lastRange)) {
      if (!this.composing && ue != null && ue.native.collapsed && ue.start.node !== this.cursor.textNode) {
        const he = this.cursor.restore();
        he && this.setNativeRange(he.startNode, he.startOffset, he.endNode, he.endOffset);
      }
      const fe = [Emitter.events.SELECTION_CHANGE, cloneDeep(this.lastRange), cloneDeep(re), Y];
      this.emitter.emit(Emitter.events.EDITOR_CHANGE, ...fe), Y !== Emitter.sources.SILENT && this.emitter.emit(...fe);
    }
  }
}
function contains(le, Y) {
  try {
    Y.parentNode;
  } catch {
    return !1;
  }
  return le.contains(Y);
}
const ASCII = /^[ -~]*$/;
class Editor {
  constructor(Y) {
    this.scroll = Y, this.delta = this.getDelta();
  }
  applyDelta(Y) {
    this.scroll.update();
    let re = this.scroll.length();
    this.scroll.batchStart();
    const oe = normalizeDelta(Y), ue = new Delta();
    return splitOpLines(oe.ops.slice()).reduce((he, _e) => {
      const ve = DeltaExports.Op.length(_e);
      let xe = _e.attributes || {}, Ee = !1, Se = !1;
      if (_e.insert != null) {
        if (ue.retain(ve), typeof _e.insert == "string") {
          const Ie = _e.insert;
          Se = !Ie.endsWith(`
`) && (re <= he || !!this.scroll.descendant(BlockEmbed, he)[0]), this.scroll.insertAt(he, Ie);
          const [Ne, Re] = this.scroll.line(he);
          let Ae = merge({}, bubbleFormats(Ne));
          if (Ne instanceof Block) {
            const [Pe] = Ne.descendant(LeafBlot$1, Re);
            Pe && (Ae = merge(Ae, bubbleFormats(Pe)));
          }
          xe = DeltaExports.AttributeMap.diff(Ae, xe) || {};
        } else if (typeof _e.insert == "object") {
          const Ie = Object.keys(_e.insert)[0];
          if (Ie == null) return he;
          const Ne = this.scroll.query(Ie, Scope.INLINE) != null;
          if (Ne)
            (re <= he || this.scroll.descendant(BlockEmbed, he)[0]) && (Se = !0);
          else if (he > 0) {
            const [Re, Ae] = this.scroll.descendant(LeafBlot$1, he - 1);
            Re instanceof Text$1 ? Re.value()[Ae] !== `
` && (Ee = !0) : Re instanceof EmbedBlot$1 && Re.statics.scope === Scope.INLINE_BLOT && (Ee = !0);
          }
          if (this.scroll.insertAt(he, Ie, _e.insert[Ie]), Ne) {
            const [Re] = this.scroll.descendant(LeafBlot$1, he);
            if (Re) {
              const Ae = merge({}, bubbleFormats(Re));
              xe = DeltaExports.AttributeMap.diff(Ae, xe) || {};
            }
          }
        }
        re += ve;
      } else if (ue.push(_e), _e.retain !== null && typeof _e.retain == "object") {
        const Ie = Object.keys(_e.retain)[0];
        if (Ie == null) return he;
        this.scroll.updateEmbedAt(he, Ie, _e.retain[Ie]);
      }
      Object.keys(xe).forEach((Ie) => {
        this.scroll.formatAt(he, ve, Ie, xe[Ie]);
      });
      const Te = Ee ? 1 : 0, Ce = Se ? 1 : 0;
      return re += Te + Ce, ue.retain(Te), ue.delete(Ce), he + ve + Te + Ce;
    }, 0), ue.reduce((he, _e) => typeof _e.delete == "number" ? (this.scroll.deleteAt(he, _e.delete), he) : he + DeltaExports.Op.length(_e), 0), this.scroll.batchEnd(), this.scroll.optimize(), this.update(oe);
  }
  deleteText(Y, re) {
    return this.scroll.deleteAt(Y, re), this.update(new Delta().retain(Y).delete(re));
  }
  formatLine(Y, re) {
    let oe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.scroll.update(), Object.keys(oe).forEach((fe) => {
      this.scroll.lines(Y, Math.max(re, 1)).forEach((he) => {
        he.format(fe, oe[fe]);
      });
    }), this.scroll.optimize();
    const ue = new Delta().retain(Y).retain(re, cloneDeep(oe));
    return this.update(ue);
  }
  formatText(Y, re) {
    let oe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.keys(oe).forEach((fe) => {
      this.scroll.formatAt(Y, re, fe, oe[fe]);
    });
    const ue = new Delta().retain(Y).retain(re, cloneDeep(oe));
    return this.update(ue);
  }
  getContents(Y, re) {
    return this.delta.slice(Y, Y + re);
  }
  getDelta() {
    return this.scroll.lines().reduce((Y, re) => Y.concat(re.delta()), new Delta());
  }
  getFormat(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, oe = [], ue = [];
    re === 0 ? this.scroll.path(Y).forEach((_e) => {
      const [ve] = _e;
      ve instanceof Block ? oe.push(ve) : ve instanceof LeafBlot$1 && ue.push(ve);
    }) : (oe = this.scroll.lines(Y, re), ue = this.scroll.descendants(LeafBlot$1, Y, re));
    const [fe, he] = [oe, ue].map((_e) => {
      const ve = _e.shift();
      if (ve == null) return {};
      let xe = bubbleFormats(ve);
      for (; Object.keys(xe).length > 0; ) {
        const Ee = _e.shift();
        if (Ee == null) return xe;
        xe = combineFormats(bubbleFormats(Ee), xe);
      }
      return xe;
    });
    return {
      ...fe,
      ...he
    };
  }
  getHTML(Y, re) {
    const [oe, ue] = this.scroll.line(Y);
    if (oe) {
      const fe = oe.length();
      return oe.length() >= ue + re && !(ue === 0 && re === fe) ? convertHTML(oe, ue, re, !0) : convertHTML(this.scroll, Y, re, !0);
    }
    return "";
  }
  getText(Y, re) {
    return this.getContents(Y, re).filter((oe) => typeof oe.insert == "string").map((oe) => oe.insert).join("");
  }
  insertContents(Y, re) {
    const oe = normalizeDelta(re), ue = new Delta().retain(Y).concat(oe);
    return this.scroll.insertContents(Y, oe), this.update(ue);
  }
  insertEmbed(Y, re, oe) {
    return this.scroll.insertAt(Y, re, oe), this.update(new Delta().retain(Y).insert({
      [re]: oe
    }));
  }
  insertText(Y, re) {
    let oe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return re = re.replace(/\r\n/g, `
`).replace(/\r/g, `
`), this.scroll.insertAt(Y, re), Object.keys(oe).forEach((ue) => {
      this.scroll.formatAt(Y, re.length, ue, oe[ue]);
    }), this.update(new Delta().retain(Y).insert(re, cloneDeep(oe)));
  }
  isBlank() {
    if (this.scroll.children.length === 0) return !0;
    if (this.scroll.children.length > 1) return !1;
    const Y = this.scroll.children.head;
    if (Y?.statics.blotName !== Block.blotName) return !1;
    const re = Y;
    return re.children.length > 1 ? !1 : re.children.head instanceof Break;
  }
  removeFormat(Y, re) {
    const oe = this.getText(Y, re), [ue, fe] = this.scroll.line(Y + re);
    let he = 0, _e = new Delta();
    ue != null && (he = ue.length() - fe, _e = ue.delta().slice(fe, fe + he - 1).insert(`
`));
    const xe = this.getContents(Y, re + he).diff(new Delta().insert(oe).concat(_e)), Ee = new Delta().retain(Y).concat(xe);
    return this.applyDelta(Ee);
  }
  update(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], oe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    const ue = this.delta;
    if (re.length === 1 && re[0].type === "characterData" && // @ts-expect-error Fix me later
    re[0].target.data.match(ASCII) && this.scroll.find(re[0].target)) {
      const fe = this.scroll.find(re[0].target), he = bubbleFormats(fe), _e = fe.offset(this.scroll), ve = re[0].oldValue.replace(Cursor.CONTENTS, ""), xe = new Delta().insert(ve), Ee = new Delta().insert(fe.value()), Se = oe && {
        oldRange: shiftRange$1(oe.oldRange, -_e),
        newRange: shiftRange$1(oe.newRange, -_e)
      };
      Y = new Delta().retain(_e).concat(xe.diff(Ee, Se)).reduce((Ce, Ie) => Ie.insert ? Ce.insert(Ie.insert, he) : Ce.push(Ie), new Delta()), this.delta = ue.compose(Y);
    } else
      this.delta = this.getDelta(), (!Y || !isEqual$2(ue.compose(Y), this.delta)) && (Y = ue.diff(this.delta, oe));
    return Y;
  }
}
function convertListHTML(le, Y, re) {
  if (le.length === 0) {
    const [Ce] = getListType(re.pop());
    return Y <= 0 ? `</li></${Ce}>` : `</li></${Ce}>${convertListHTML([], Y - 1, re)}`;
  }
  const [{
    child: oe,
    offset: ue,
    length: fe,
    indent: he,
    type: _e
  }, ...ve] = le, [xe, Ee] = getListType(_e);
  if (he > Y)
    return re.push(_e), he === Y + 1 ? `<${xe}><li${Ee}>${convertHTML(oe, ue, fe)}${convertListHTML(ve, he, re)}` : `<${xe}><li>${convertListHTML(le, Y + 1, re)}`;
  const Se = re[re.length - 1];
  if (he === Y && _e === Se)
    return `</li><li${Ee}>${convertHTML(oe, ue, fe)}${convertListHTML(ve, he, re)}`;
  const [Te] = getListType(re.pop());
  return `</li></${Te}>${convertListHTML(le, Y - 1, re)}`;
}
function convertHTML(le, Y, re) {
  let oe = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if ("html" in le && typeof le.html == "function")
    return le.html(Y, re);
  if (le instanceof Text$1)
    return escapeText(le.value().slice(Y, Y + re)).replaceAll(" ", "&nbsp;");
  if (le instanceof ParentBlot$1) {
    if (le.statics.blotName === "list-container") {
      const xe = [];
      return le.children.forEachAt(Y, re, (Ee, Se, Te) => {
        const Ce = "formats" in Ee && typeof Ee.formats == "function" ? Ee.formats() : {};
        xe.push({
          child: Ee,
          offset: Se,
          length: Te,
          indent: Ce.indent || 0,
          type: Ce.list
        });
      }), convertListHTML(xe, -1, []);
    }
    const ue = [];
    if (le.children.forEachAt(Y, re, (xe, Ee, Se) => {
      ue.push(convertHTML(xe, Ee, Se));
    }), oe || le.statics.blotName === "list")
      return ue.join("");
    const {
      outerHTML: fe,
      innerHTML: he
    } = le.domNode, [_e, ve] = fe.split(`>${he}<`);
    return _e === "<table" ? `<table style="border: 1px solid #000;">${ue.join("")}<${ve}` : `${_e}>${ue.join("")}<${ve}`;
  }
  return le.domNode instanceof Element ? le.domNode.outerHTML : "";
}
function combineFormats(le, Y) {
  return Object.keys(Y).reduce((re, oe) => {
    if (le[oe] == null) return re;
    const ue = Y[oe];
    return ue === le[oe] ? re[oe] = ue : Array.isArray(ue) ? ue.indexOf(le[oe]) < 0 ? re[oe] = ue.concat([le[oe]]) : re[oe] = ue : re[oe] = [ue, le[oe]], re;
  }, {});
}
function getListType(le) {
  const Y = le === "ordered" ? "ol" : "ul";
  switch (le) {
    case "checked":
      return [Y, ' data-list="checked"'];
    case "unchecked":
      return [Y, ' data-list="unchecked"'];
    default:
      return [Y, ""];
  }
}
function normalizeDelta(le) {
  return le.reduce((Y, re) => {
    if (typeof re.insert == "string") {
      const oe = re.insert.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
      return Y.insert(oe, re.attributes);
    }
    return Y.push(re);
  }, new Delta());
}
function shiftRange$1(le, Y) {
  let {
    index: re,
    length: oe
  } = le;
  return new Range(re + Y, oe);
}
function splitOpLines(le) {
  const Y = [];
  return le.forEach((re) => {
    typeof re.insert == "string" ? re.insert.split(`
`).forEach((ue, fe) => {
      fe && Y.push({
        insert: `
`,
        attributes: re.attributes
      }), ue && Y.push({
        insert: ue,
        attributes: re.attributes
      });
    }) : Y.push(re);
  }), Y;
}
let Module$1 = class {
  static DEFAULTS = {};
  constructor(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.quill = Y, this.options = re;
  }
};
const GUARD_TEXT = "\uFEFF";
class Embed extends EmbedBlot$1 {
  constructor(Y, re) {
    super(Y, re), this.contentNode = document.createElement("span"), this.contentNode.setAttribute("contenteditable", "false"), Array.from(this.domNode.childNodes).forEach((oe) => {
      this.contentNode.appendChild(oe);
    }), this.leftGuard = document.createTextNode(GUARD_TEXT), this.rightGuard = document.createTextNode(GUARD_TEXT), this.domNode.appendChild(this.leftGuard), this.domNode.appendChild(this.contentNode), this.domNode.appendChild(this.rightGuard);
  }
  index(Y, re) {
    return Y === this.leftGuard ? 0 : Y === this.rightGuard ? 1 : super.index(Y, re);
  }
  restore(Y) {
    let re = null, oe;
    const ue = Y.data.split(GUARD_TEXT).join("");
    if (Y === this.leftGuard)
      if (this.prev instanceof Text$1) {
        const fe = this.prev.length();
        this.prev.insertAt(fe, ue), re = {
          startNode: this.prev.domNode,
          startOffset: fe + ue.length
        };
      } else
        oe = document.createTextNode(ue), this.parent.insertBefore(this.scroll.create(oe), this), re = {
          startNode: oe,
          startOffset: ue.length
        };
    else Y === this.rightGuard && (this.next instanceof Text$1 ? (this.next.insertAt(0, ue), re = {
      startNode: this.next.domNode,
      startOffset: ue.length
    }) : (oe = document.createTextNode(ue), this.parent.insertBefore(this.scroll.create(oe), this.next), re = {
      startNode: oe,
      startOffset: ue.length
    }));
    return Y.data = GUARD_TEXT, re;
  }
  update(Y, re) {
    Y.forEach((oe) => {
      if (oe.type === "characterData" && (oe.target === this.leftGuard || oe.target === this.rightGuard)) {
        const ue = this.restore(oe.target);
        ue && (re.range = ue);
      }
    });
  }
}
class Composition {
  isComposing = !1;
  constructor(Y, re) {
    this.scroll = Y, this.emitter = re, this.setupListeners();
  }
  setupListeners() {
    this.scroll.domNode.addEventListener("compositionstart", (Y) => {
      this.isComposing || this.handleCompositionStart(Y);
    }), this.scroll.domNode.addEventListener("compositionend", (Y) => {
      this.isComposing && queueMicrotask(() => {
        this.handleCompositionEnd(Y);
      });
    });
  }
  handleCompositionStart(Y) {
    const re = Y.target instanceof Node ? this.scroll.find(Y.target, !0) : null;
    re && !(re instanceof Embed) && (this.emitter.emit(Emitter.events.COMPOSITION_BEFORE_START, Y), this.scroll.batchStart(), this.emitter.emit(Emitter.events.COMPOSITION_START, Y), this.isComposing = !0);
  }
  handleCompositionEnd(Y) {
    this.emitter.emit(Emitter.events.COMPOSITION_BEFORE_END, Y), this.scroll.batchEnd(), this.emitter.emit(Emitter.events.COMPOSITION_END, Y), this.isComposing = !1;
  }
}
class Theme {
  static DEFAULTS = {
    modules: {}
  };
  static themes = {
    default: Theme
  };
  modules = {};
  constructor(Y, re) {
    this.quill = Y, this.options = re;
  }
  init() {
    Object.keys(this.options.modules).forEach((Y) => {
      this.modules[Y] == null && this.addModule(Y);
    });
  }
  addModule(Y) {
    const re = this.quill.constructor.import(`modules/${Y}`);
    return this.modules[Y] = new re(this.quill, this.options.modules[Y] || {}), this.modules[Y];
  }
}
const getParentElement = (le) => le.parentElement || le.getRootNode().host || null, getElementRect = (le) => {
  const Y = le.getBoundingClientRect(), re = "offsetWidth" in le && Math.abs(Y.width) / le.offsetWidth || 1, oe = "offsetHeight" in le && Math.abs(Y.height) / le.offsetHeight || 1;
  return {
    top: Y.top,
    right: Y.left + le.clientWidth * re,
    bottom: Y.top + le.clientHeight * oe,
    left: Y.left
  };
}, paddingValueToInt = (le) => {
  const Y = parseInt(le, 10);
  return Number.isNaN(Y) ? 0 : Y;
}, getScrollDistance = (le, Y, re, oe, ue, fe) => le < re && Y > oe ? 0 : le < re ? -(re - le + ue) : Y > oe ? Y - le > oe - re ? le + ue - re : Y - oe + fe : 0, scrollRectIntoView = (le, Y) => {
  const re = le.ownerDocument;
  let oe = Y, ue = le;
  for (; ue; ) {
    const fe = ue === re.body, he = fe ? {
      top: 0,
      right: window.visualViewport?.width ?? re.documentElement.clientWidth,
      bottom: window.visualViewport?.height ?? re.documentElement.clientHeight,
      left: 0
    } : getElementRect(ue), _e = getComputedStyle(ue), ve = getScrollDistance(oe.left, oe.right, he.left, he.right, paddingValueToInt(_e.scrollPaddingLeft), paddingValueToInt(_e.scrollPaddingRight)), xe = getScrollDistance(oe.top, oe.bottom, he.top, he.bottom, paddingValueToInt(_e.scrollPaddingTop), paddingValueToInt(_e.scrollPaddingBottom));
    if (ve || xe)
      if (fe)
        re.defaultView?.scrollBy(ve, xe);
      else {
        const {
          scrollLeft: Ee,
          scrollTop: Se
        } = ue;
        xe && (ue.scrollTop += xe), ve && (ue.scrollLeft += ve);
        const Te = ue.scrollLeft - Ee, Ce = ue.scrollTop - Se;
        oe = {
          left: oe.left - Te,
          top: oe.top - Ce,
          right: oe.right - Te,
          bottom: oe.bottom - Ce
        };
      }
    ue = fe || _e.position === "fixed" ? null : getParentElement(ue);
  }
}, MAX_REGISTER_ITERATIONS = 100, CORE_FORMATS = ["block", "break", "cursor", "inline", "scroll", "text"], createRegistryWithFormats = (le, Y, re) => {
  const oe = new Registry();
  return CORE_FORMATS.forEach((ue) => {
    const fe = Y.query(ue);
    fe && oe.register(fe);
  }), le.forEach((ue) => {
    let fe = Y.query(ue);
    fe || re.error(`Cannot register "${ue}" specified in "formats" config. Are you sure it was registered?`);
    let he = 0;
    for (; fe; )
      if (oe.register(fe), fe = "blotName" in fe ? fe.requiredContainer ?? null : null, he += 1, he > MAX_REGISTER_ITERATIONS) {
        re.error(`Cycle detected in registering blot requiredContainer: "${ue}"`);
        break;
      }
  }), oe;
}, debug$3 = namespace("quill"), globalRegistry = new Registry();
ParentBlot$1.uiClass = "ql-ui";
class Quill {
  static DEFAULTS = {
    bounds: null,
    modules: {
      clipboard: !0,
      keyboard: !0,
      history: !0,
      uploader: !0
    },
    placeholder: "",
    readOnly: !1,
    registry: globalRegistry,
    theme: "default"
  };
  static events = Emitter.events;
  static sources = Emitter.sources;
  static version = "2.0.3";
  static imports = {
    delta: Delta,
    parchment: Parchment,
    "core/module": Module$1,
    "core/theme": Theme
  };
  static debug(Y) {
    Y === !0 && (Y = "log"), namespace.level(Y);
  }
  static find(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return instances.get(Y) || globalRegistry.find(Y, re);
  }
  static import(Y) {
    return this.imports[Y] == null && debug$3.error(`Cannot import ${Y}. Are you sure it was registered?`), this.imports[Y];
  }
  static register() {
    if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) != "string") {
      const Y = arguments.length <= 0 ? void 0 : arguments[0], re = !!(!(arguments.length <= 1) && arguments[1]), oe = "attrName" in Y ? Y.attrName : Y.blotName;
      typeof oe == "string" ? this.register(`formats/${oe}`, Y, re) : Object.keys(Y).forEach((ue) => {
        this.register(ue, Y[ue], re);
      });
    } else {
      const Y = arguments.length <= 0 ? void 0 : arguments[0], re = arguments.length <= 1 ? void 0 : arguments[1], oe = !!(!(arguments.length <= 2) && arguments[2]);
      this.imports[Y] != null && !oe && debug$3.warn(`Overwriting ${Y} with`, re), this.imports[Y] = re, (Y.startsWith("blots/") || Y.startsWith("formats/")) && re && typeof re != "boolean" && re.blotName !== "abstract" && globalRegistry.register(re), typeof re.register == "function" && re.register(globalRegistry);
    }
  }
  constructor(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.options = expandConfig(Y, re), this.container = this.options.container, this.container == null) {
      debug$3.error("Invalid Quill container", Y);
      return;
    }
    this.options.debug && Quill.debug(this.options.debug);
    const oe = this.container.innerHTML.trim();
    this.container.classList.add("ql-container"), this.container.innerHTML = "", instances.set(this.container, this), this.root = this.addContainer("ql-editor"), this.root.classList.add("ql-blank"), this.emitter = new Emitter();
    const ue = ScrollBlot$1.blotName, fe = this.options.registry.query(ue);
    if (!fe || !("blotName" in fe))
      throw new Error(`Cannot initialize Quill without "${ue}" blot`);
    if (this.scroll = new fe(this.options.registry, this.root, {
      emitter: this.emitter
    }), this.editor = new Editor(this.scroll), this.selection = new Selection(this.scroll, this.emitter), this.composition = new Composition(this.scroll, this.emitter), this.theme = new this.options.theme(this, this.options), this.keyboard = this.theme.addModule("keyboard"), this.clipboard = this.theme.addModule("clipboard"), this.history = this.theme.addModule("history"), this.uploader = this.theme.addModule("uploader"), this.theme.addModule("input"), this.theme.addModule("uiNode"), this.theme.init(), this.emitter.on(Emitter.events.EDITOR_CHANGE, (he) => {
      he === Emitter.events.TEXT_CHANGE && this.root.classList.toggle("ql-blank", this.editor.isBlank());
    }), this.emitter.on(Emitter.events.SCROLL_UPDATE, (he, _e) => {
      const ve = this.selection.lastRange, [xe] = this.selection.getRange(), Ee = ve && xe ? {
        oldRange: ve,
        newRange: xe
      } : void 0;
      modify.call(this, () => this.editor.update(null, _e, Ee), he);
    }), this.emitter.on(Emitter.events.SCROLL_EMBED_UPDATE, (he, _e) => {
      const ve = this.selection.lastRange, [xe] = this.selection.getRange(), Ee = ve && xe ? {
        oldRange: ve,
        newRange: xe
      } : void 0;
      modify.call(this, () => {
        const Se = new Delta().retain(he.offset(this)).retain({
          [he.statics.blotName]: _e
        });
        return this.editor.update(Se, [], Ee);
      }, Quill.sources.USER);
    }), oe) {
      const he = this.clipboard.convert({
        html: `${oe}<p><br></p>`,
        text: `
`
      });
      this.setContents(he);
    }
    this.history.clear(), this.options.placeholder && this.root.setAttribute("data-placeholder", this.options.placeholder), this.options.readOnly && this.disable(), this.allowReadOnlyEdits = !1;
  }
  addContainer(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (typeof Y == "string") {
      const oe = Y;
      Y = document.createElement("div"), Y.classList.add(oe);
    }
    return this.container.insertBefore(Y, re), Y;
  }
  blur() {
    this.selection.setRange(null);
  }
  deleteText(Y, re, oe) {
    return [Y, re, , oe] = overload(Y, re, oe), modify.call(this, () => this.editor.deleteText(Y, re), oe, Y, -1 * re);
  }
  disable() {
    this.enable(!1);
  }
  editReadOnly(Y) {
    this.allowReadOnlyEdits = !0;
    const re = Y();
    return this.allowReadOnlyEdits = !1, re;
  }
  enable() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.scroll.enable(Y), this.container.classList.toggle("ql-disabled", !Y);
  }
  focus() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.selection.focus(), Y.preventScroll || this.scrollSelectionIntoView();
  }
  format(Y, re) {
    let oe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Emitter.sources.API;
    return modify.call(this, () => {
      const ue = this.getSelection(!0);
      let fe = new Delta();
      if (ue == null) return fe;
      if (this.scroll.query(Y, Scope.BLOCK))
        fe = this.editor.formatLine(ue.index, ue.length, {
          [Y]: re
        });
      else {
        if (ue.length === 0)
          return this.selection.format(Y, re), fe;
        fe = this.editor.formatText(ue.index, ue.length, {
          [Y]: re
        });
      }
      return this.setSelection(ue, Emitter.sources.SILENT), fe;
    }, oe);
  }
  formatLine(Y, re, oe, ue, fe) {
    let he;
    return [Y, re, he, fe] = overload(
      Y,
      re,
      // @ts-expect-error
      oe,
      ue,
      fe
    ), modify.call(this, () => this.editor.formatLine(Y, re, he), fe, Y, 0);
  }
  formatText(Y, re, oe, ue, fe) {
    let he;
    return [Y, re, he, fe] = overload(
      // @ts-expect-error
      Y,
      re,
      oe,
      ue,
      fe
    ), modify.call(this, () => this.editor.formatText(Y, re, he), fe, Y, 0);
  }
  getBounds(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, oe = null;
    if (typeof Y == "number" ? oe = this.selection.getBounds(Y, re) : oe = this.selection.getBounds(Y.index, Y.length), !oe) return null;
    const ue = this.container.getBoundingClientRect();
    return {
      bottom: oe.bottom - ue.top,
      height: oe.height,
      left: oe.left - ue.left,
      right: oe.right - ue.left,
      top: oe.top - ue.top,
      width: oe.width
    };
  }
  getContents() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - Y;
    return [Y, re] = overload(Y, re), this.editor.getContents(Y, re);
  }
  getFormat() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getSelection(!0), re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return typeof Y == "number" ? this.editor.getFormat(Y, re) : this.editor.getFormat(Y.index, Y.length);
  }
  getIndex(Y) {
    return Y.offset(this.scroll);
  }
  getLength() {
    return this.scroll.length();
  }
  getLeaf(Y) {
    return this.scroll.leaf(Y);
  }
  getLine(Y) {
    return this.scroll.line(Y);
  }
  getLines() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
    return typeof Y != "number" ? this.scroll.lines(Y.index, Y.length) : this.scroll.lines(Y, re);
  }
  getModule(Y) {
    return this.theme.modules[Y];
  }
  getSelection() {
    return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) && this.focus(), this.update(), this.selection.getRange()[0];
  }
  getSemanticHTML() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, re = arguments.length > 1 ? arguments[1] : void 0;
    return typeof Y == "number" && (re = re ?? this.getLength() - Y), [Y, re] = overload(Y, re), this.editor.getHTML(Y, re);
  }
  getText() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, re = arguments.length > 1 ? arguments[1] : void 0;
    return typeof Y == "number" && (re = re ?? this.getLength() - Y), [Y, re] = overload(Y, re), this.editor.getText(Y, re);
  }
  hasFocus() {
    return this.selection.hasFocus();
  }
  insertEmbed(Y, re, oe) {
    let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Quill.sources.API;
    return modify.call(this, () => this.editor.insertEmbed(Y, re, oe), ue, Y);
  }
  insertText(Y, re, oe, ue, fe) {
    let he;
    return [Y, , he, fe] = overload(Y, 0, oe, ue, fe), modify.call(this, () => this.editor.insertText(Y, re, he), fe, Y, re.length);
  }
  isEnabled() {
    return this.scroll.isEnabled();
  }
  off() {
    return this.emitter.off(...arguments);
  }
  on() {
    return this.emitter.on(...arguments);
  }
  once() {
    return this.emitter.once(...arguments);
  }
  removeFormat(Y, re, oe) {
    return [Y, re, , oe] = overload(Y, re, oe), modify.call(this, () => this.editor.removeFormat(Y, re), oe, Y);
  }
  scrollRectIntoView(Y) {
    scrollRectIntoView(this.root, Y);
  }
  /**
   * @deprecated Use Quill#scrollSelectionIntoView() instead.
   */
  scrollIntoView() {
    console.warn("Quill#scrollIntoView() has been deprecated and will be removed in the near future. Please use Quill#scrollSelectionIntoView() instead."), this.scrollSelectionIntoView();
  }
  /**
   * Scroll the current selection into the visible area.
   * If the selection is already visible, no scrolling will occur.
   */
  scrollSelectionIntoView() {
    const Y = this.selection.lastRange, re = Y && this.selection.getBounds(Y.index, Y.length);
    re && this.scrollRectIntoView(re);
  }
  setContents(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Emitter.sources.API;
    return modify.call(this, () => {
      Y = new Delta(Y);
      const oe = this.getLength(), ue = this.editor.deleteText(0, oe), fe = this.editor.insertContents(0, Y), he = this.editor.deleteText(this.getLength() - 1, 1);
      return ue.compose(fe).compose(he);
    }, re);
  }
  setSelection(Y, re, oe) {
    Y == null ? this.selection.setRange(null, re || Quill.sources.API) : ([Y, re, , oe] = overload(Y, re, oe), this.selection.setRange(new Range(Math.max(0, Y), re), oe), oe !== Emitter.sources.SILENT && this.scrollSelectionIntoView());
  }
  setText(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Emitter.sources.API;
    const oe = new Delta().insert(Y);
    return this.setContents(oe, re);
  }
  update() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Emitter.sources.USER;
    const re = this.scroll.update(Y);
    return this.selection.update(Y), re;
  }
  updateContents(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Emitter.sources.API;
    return modify.call(this, () => (Y = new Delta(Y), this.editor.applyDelta(Y)), re, !0);
  }
}
function resolveSelector(le) {
  return typeof le == "string" ? document.querySelector(le) : le;
}
function expandModuleConfig(le) {
  return Object.entries(le ?? {}).reduce((Y, re) => {
    let [oe, ue] = re;
    return {
      ...Y,
      [oe]: ue === !0 ? {} : ue
    };
  }, {});
}
function omitUndefinedValuesFromOptions(le) {
  return Object.fromEntries(Object.entries(le).filter((Y) => Y[1] !== void 0));
}
function expandConfig(le, Y) {
  const re = resolveSelector(le);
  if (!re)
    throw new Error("Invalid Quill container");
  const ue = !Y.theme || Y.theme === Quill.DEFAULTS.theme ? Theme : Quill.import(`themes/${Y.theme}`);
  if (!ue)
    throw new Error(`Invalid theme ${Y.theme}. Did you register it?`);
  const {
    modules: fe,
    ...he
  } = Quill.DEFAULTS, {
    modules: _e,
    ...ve
  } = ue.DEFAULTS;
  let xe = expandModuleConfig(Y.modules);
  xe != null && xe.toolbar && xe.toolbar.constructor !== Object && (xe = {
    ...xe,
    toolbar: {
      container: xe.toolbar
    }
  });
  const Ee = merge({}, expandModuleConfig(fe), expandModuleConfig(_e), xe), Se = {
    ...he,
    ...omitUndefinedValuesFromOptions(ve),
    ...omitUndefinedValuesFromOptions(Y)
  };
  let Te = Y.registry;
  return Te ? Y.formats && debug$3.warn('Ignoring "formats" option because "registry" is specified') : Te = Y.formats ? createRegistryWithFormats(Y.formats, Se.registry, debug$3) : Se.registry, {
    ...Se,
    registry: Te,
    container: re,
    theme: ue,
    modules: Object.entries(Ee).reduce((Ce, Ie) => {
      let [Ne, Re] = Ie;
      if (!Re) return Ce;
      const Ae = Quill.import(`modules/${Ne}`);
      return Ae == null ? (debug$3.error(`Cannot load ${Ne} module. Are you sure you registered it?`), Ce) : {
        ...Ce,
        // @ts-expect-error
        [Ne]: merge({}, Ae.DEFAULTS || {}, Re)
      };
    }, {}),
    bounds: resolveSelector(Se.bounds)
  };
}
function modify(le, Y, re, oe) {
  if (!this.isEnabled() && Y === Emitter.sources.USER && !this.allowReadOnlyEdits)
    return new Delta();
  let ue = re == null ? null : this.getSelection();
  const fe = this.editor.delta, he = le();
  if (ue != null && (re === !0 && (re = ue.index), oe == null ? ue = shiftRange(ue, he, Y) : oe !== 0 && (ue = shiftRange(ue, re, oe, Y)), this.setSelection(ue, Emitter.sources.SILENT)), he.length() > 0) {
    const _e = [Emitter.events.TEXT_CHANGE, he, fe, Y];
    this.emitter.emit(Emitter.events.EDITOR_CHANGE, ..._e), Y !== Emitter.sources.SILENT && this.emitter.emit(..._e);
  }
  return he;
}
function overload(le, Y, re, oe, ue) {
  let fe = {};
  return typeof le.index == "number" && typeof le.length == "number" ? typeof Y != "number" ? (ue = oe, oe = re, re = Y, Y = le.length, le = le.index) : (Y = le.length, le = le.index) : typeof Y != "number" && (ue = oe, oe = re, re = Y, Y = 0), typeof re == "object" ? (fe = re, ue = oe) : typeof re == "string" && (oe != null ? fe[re] = oe : ue = re), ue = ue || Emitter.sources.API, [le, Y, fe, ue];
}
function shiftRange(le, Y, re, oe) {
  const ue = typeof re == "number" ? re : 0;
  if (le == null) return null;
  let fe, he;
  return Y && typeof Y.transformPosition == "function" ? [fe, he] = [le.index, le.index + le.length].map((_e) => (
    // @ts-expect-error -- TODO: add a better type guard around `index`
    Y.transformPosition(_e, oe !== Emitter.sources.USER)
  )) : [fe, he] = [le.index, le.index + le.length].map((_e) => _e < Y || _e === Y && oe === Emitter.sources.USER ? _e : ue >= 0 ? _e + ue : Math.max(Y, _e + ue)), new Range(fe, he - fe);
}
class Container extends ContainerBlot$1 {
}
function isLine$1(le) {
  return le instanceof Block || le instanceof BlockEmbed;
}
function isUpdatable(le) {
  return typeof le.updateContent == "function";
}
class Scroll extends ScrollBlot$1 {
  static blotName = "scroll";
  static className = "ql-editor";
  static tagName = "DIV";
  static defaultChild = Block;
  static allowedChildren = [Block, BlockEmbed, Container];
  constructor(Y, re, oe) {
    let {
      emitter: ue
    } = oe;
    super(Y, re), this.emitter = ue, this.batch = !1, this.optimize(), this.enable(), this.domNode.addEventListener("dragstart", (fe) => this.handleDragStart(fe));
  }
  batchStart() {
    Array.isArray(this.batch) || (this.batch = []);
  }
  batchEnd() {
    if (!this.batch) return;
    const Y = this.batch;
    this.batch = !1, this.update(Y);
  }
  emitMount(Y) {
    this.emitter.emit(Emitter.events.SCROLL_BLOT_MOUNT, Y);
  }
  emitUnmount(Y) {
    this.emitter.emit(Emitter.events.SCROLL_BLOT_UNMOUNT, Y);
  }
  emitEmbedUpdate(Y, re) {
    this.emitter.emit(Emitter.events.SCROLL_EMBED_UPDATE, Y, re);
  }
  deleteAt(Y, re) {
    const [oe, ue] = this.line(Y), [fe] = this.line(Y + re);
    if (super.deleteAt(Y, re), fe != null && oe !== fe && ue > 0) {
      if (oe instanceof BlockEmbed || fe instanceof BlockEmbed) {
        this.optimize();
        return;
      }
      const he = fe.children.head instanceof Break ? null : fe.children.head;
      oe.moveChildren(fe, he), oe.remove();
    }
    this.optimize();
  }
  enable() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.domNode.setAttribute("contenteditable", Y ? "true" : "false");
  }
  formatAt(Y, re, oe, ue) {
    super.formatAt(Y, re, oe, ue), this.optimize();
  }
  insertAt(Y, re, oe) {
    if (Y >= this.length())
      if (oe == null || this.scroll.query(re, Scope.BLOCK) == null) {
        const ue = this.scroll.create(this.statics.defaultChild.blotName);
        this.appendChild(ue), oe == null && re.endsWith(`
`) ? ue.insertAt(0, re.slice(0, -1), oe) : ue.insertAt(0, re, oe);
      } else {
        const ue = this.scroll.create(re, oe);
        this.appendChild(ue);
      }
    else
      super.insertAt(Y, re, oe);
    this.optimize();
  }
  insertBefore(Y, re) {
    if (Y.statics.scope === Scope.INLINE_BLOT) {
      const oe = this.scroll.create(this.statics.defaultChild.blotName);
      oe.appendChild(Y), super.insertBefore(oe, re);
    } else
      super.insertBefore(Y, re);
  }
  insertContents(Y, re) {
    const oe = this.deltaToRenderBlocks(re.concat(new Delta().insert(`
`))), ue = oe.pop();
    if (ue == null) return;
    this.batchStart();
    const fe = oe.shift();
    if (fe) {
      const ve = fe.type === "block" && (fe.delta.length() === 0 || !this.descendant(BlockEmbed, Y)[0] && Y < this.length()), xe = fe.type === "block" ? fe.delta : new Delta().insert({
        [fe.key]: fe.value
      });
      insertInlineContents(this, Y, xe);
      const Ee = fe.type === "block" ? 1 : 0, Se = Y + xe.length() + Ee;
      ve && this.insertAt(Se - 1, `
`);
      const Te = bubbleFormats(this.line(Y)[0]), Ce = DeltaExports.AttributeMap.diff(Te, fe.attributes) || {};
      Object.keys(Ce).forEach((Ie) => {
        this.formatAt(Se - 1, 1, Ie, Ce[Ie]);
      }), Y = Se;
    }
    let [he, _e] = this.children.find(Y);
    if (oe.length && (he && (he = he.split(_e), _e = 0), oe.forEach((ve) => {
      if (ve.type === "block") {
        const xe = this.createBlock(ve.attributes, he || void 0);
        insertInlineContents(xe, 0, ve.delta);
      } else {
        const xe = this.create(ve.key, ve.value);
        this.insertBefore(xe, he || void 0), Object.keys(ve.attributes).forEach((Ee) => {
          xe.format(Ee, ve.attributes[Ee]);
        });
      }
    })), ue.type === "block" && ue.delta.length()) {
      const ve = he ? he.offset(he.scroll) + _e : this.length();
      insertInlineContents(this, ve, ue.delta);
    }
    this.batchEnd(), this.optimize();
  }
  isEnabled() {
    return this.domNode.getAttribute("contenteditable") === "true";
  }
  leaf(Y) {
    const re = this.path(Y).pop();
    if (!re)
      return [null, -1];
    const [oe, ue] = re;
    return oe instanceof LeafBlot$1 ? [oe, ue] : [null, -1];
  }
  line(Y) {
    return Y === this.length() ? this.line(Y - 1) : this.descendant(isLine$1, Y);
  }
  lines() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
    const oe = (ue, fe, he) => {
      let _e = [], ve = he;
      return ue.children.forEachAt(fe, he, (xe, Ee, Se) => {
        isLine$1(xe) ? _e.push(xe) : xe instanceof ContainerBlot$1 && (_e = _e.concat(oe(xe, Ee, ve))), ve -= Se;
      }), _e;
    };
    return oe(this, Y, re);
  }
  optimize() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.batch || (super.optimize(Y, re), Y.length > 0 && this.emitter.emit(Emitter.events.SCROLL_OPTIMIZE, Y, re));
  }
  path(Y) {
    return super.path(Y).slice(1);
  }
  remove() {
  }
  update(Y) {
    if (this.batch) {
      Array.isArray(Y) && (this.batch = this.batch.concat(Y));
      return;
    }
    let re = Emitter.sources.USER;
    typeof Y == "string" && (re = Y), Array.isArray(Y) || (Y = this.observer.takeRecords()), Y = Y.filter((oe) => {
      let {
        target: ue
      } = oe;
      const fe = this.find(ue, !0);
      return fe && !isUpdatable(fe);
    }), Y.length > 0 && this.emitter.emit(Emitter.events.SCROLL_BEFORE_UPDATE, re, Y), super.update(Y.concat([])), Y.length > 0 && this.emitter.emit(Emitter.events.SCROLL_UPDATE, re, Y);
  }
  updateEmbedAt(Y, re, oe) {
    const [ue] = this.descendant((fe) => fe instanceof BlockEmbed, Y);
    ue && ue.statics.blotName === re && isUpdatable(ue) && ue.updateContent(oe);
  }
  handleDragStart(Y) {
    Y.preventDefault();
  }
  deltaToRenderBlocks(Y) {
    const re = [];
    let oe = new Delta();
    return Y.forEach((ue) => {
      const fe = ue?.insert;
      if (fe)
        if (typeof fe == "string") {
          const he = fe.split(`
`);
          he.slice(0, -1).forEach((ve) => {
            oe.insert(ve, ue.attributes), re.push({
              type: "block",
              delta: oe,
              attributes: ue.attributes ?? {}
            }), oe = new Delta();
          });
          const _e = he[he.length - 1];
          _e && oe.insert(_e, ue.attributes);
        } else {
          const he = Object.keys(fe)[0];
          if (!he) return;
          this.query(he, Scope.INLINE) ? oe.push(ue) : (oe.length() && re.push({
            type: "block",
            delta: oe,
            attributes: {}
          }), oe = new Delta(), re.push({
            type: "blockEmbed",
            key: he,
            value: fe[he],
            attributes: ue.attributes ?? {}
          }));
        }
    }), oe.length() && re.push({
      type: "block",
      delta: oe,
      attributes: {}
    }), re;
  }
  createBlock(Y, re) {
    let oe;
    const ue = {};
    Object.entries(Y).forEach((_e) => {
      let [ve, xe] = _e;
      this.query(ve, Scope.BLOCK & Scope.BLOT) != null ? oe = ve : ue[ve] = xe;
    });
    const fe = this.create(oe || this.statics.defaultChild.blotName, oe ? Y[oe] : void 0);
    this.insertBefore(fe, re || void 0);
    const he = fe.length();
    return Object.entries(ue).forEach((_e) => {
      let [ve, xe] = _e;
      fe.formatAt(0, he, ve, xe);
    }), fe;
  }
}
function insertInlineContents(le, Y, re) {
  re.reduce((oe, ue) => {
    const fe = DeltaExports.Op.length(ue);
    let he = ue.attributes || {};
    if (ue.insert != null) {
      if (typeof ue.insert == "string") {
        const _e = ue.insert;
        le.insertAt(oe, _e);
        const [ve] = le.descendant(LeafBlot$1, oe), xe = bubbleFormats(ve);
        he = DeltaExports.AttributeMap.diff(xe, he) || {};
      } else if (typeof ue.insert == "object") {
        const _e = Object.keys(ue.insert)[0];
        if (_e == null) return oe;
        if (le.insertAt(oe, _e, ue.insert[_e]), le.scroll.query(_e, Scope.INLINE) != null) {
          const [xe] = le.descendant(LeafBlot$1, oe), Ee = bubbleFormats(xe);
          he = DeltaExports.AttributeMap.diff(Ee, he) || {};
        }
      }
    }
    return Object.keys(he).forEach((_e) => {
      le.formatAt(oe, fe, _e, he[_e]);
    }), oe + fe;
  }, Y);
}
const config$2 = {
  scope: Scope.BLOCK,
  whitelist: ["right", "center", "justify"]
}, AlignAttribute = new Attributor("align", "align", config$2), AlignClass = new ClassAttributor$1("align", "ql-align", config$2), AlignStyle = new StyleAttributor$1("align", "text-align", config$2);
class ColorAttributor extends StyleAttributor$1 {
  value(Y) {
    let re = super.value(Y);
    return re.startsWith("rgb(") ? (re = re.replace(/^[^\d]+/, "").replace(/[^\d]+$/, ""), `#${re.split(",").map((ue) => `00${parseInt(ue, 10).toString(16)}`.slice(-2)).join("")}`) : re;
  }
}
const ColorClass = new ClassAttributor$1("color", "ql-color", {
  scope: Scope.INLINE
}), ColorStyle = new ColorAttributor("color", "color", {
  scope: Scope.INLINE
}), BackgroundClass = new ClassAttributor$1("background", "ql-bg", {
  scope: Scope.INLINE
}), BackgroundStyle = new ColorAttributor("background", "background-color", {
  scope: Scope.INLINE
});
class CodeBlockContainer extends Container {
  static create(Y) {
    const re = super.create(Y);
    return re.setAttribute("spellcheck", "false"), re;
  }
  code(Y, re) {
    return this.children.map((oe) => oe.length() <= 1 ? "" : oe.domNode.innerText).join(`
`).slice(Y, Y + re);
  }
  html(Y, re) {
    return `<pre>
${escapeText(this.code(Y, re))}
</pre>`;
  }
}
class CodeBlock extends Block {
  static TAB = "  ";
  static register() {
    Quill.register(CodeBlockContainer);
  }
}
class Code extends Inline {
}
Code.blotName = "code";
Code.tagName = "CODE";
CodeBlock.blotName = "code-block";
CodeBlock.className = "ql-code-block";
CodeBlock.tagName = "DIV";
CodeBlockContainer.blotName = "code-block-container";
CodeBlockContainer.className = "ql-code-block-container";
CodeBlockContainer.tagName = "DIV";
CodeBlockContainer.allowedChildren = [CodeBlock];
CodeBlock.allowedChildren = [Text$1, Break, Cursor];
CodeBlock.requiredContainer = CodeBlockContainer;
const config$1 = {
  scope: Scope.BLOCK,
  whitelist: ["rtl"]
}, DirectionAttribute = new Attributor("direction", "dir", config$1), DirectionClass = new ClassAttributor$1("direction", "ql-direction", config$1), DirectionStyle = new StyleAttributor$1("direction", "direction", config$1), config = {
  scope: Scope.INLINE,
  whitelist: ["serif", "monospace"]
}, FontClass = new ClassAttributor$1("font", "ql-font", config);
class FontStyleAttributor extends StyleAttributor$1 {
  value(Y) {
    return super.value(Y).replace(/["']/g, "");
  }
}
const FontStyle = new FontStyleAttributor("font", "font-family", config), SizeClass = new ClassAttributor$1("size", "ql-size", {
  scope: Scope.INLINE,
  whitelist: ["small", "large", "huge"]
}), SizeStyle = new StyleAttributor$1("size", "font-size", {
  scope: Scope.INLINE,
  whitelist: ["10px", "18px", "32px"]
}), debug$2 = namespace("quill:keyboard"), SHORTKEY = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
class Keyboard extends Module$1 {
  static match(Y, re) {
    return ["altKey", "ctrlKey", "metaKey", "shiftKey"].some((oe) => !!re[oe] !== Y[oe] && re[oe] !== null) ? !1 : re.key === Y.key || re.key === Y.which;
  }
  constructor(Y, re) {
    super(Y, re), this.bindings = {}, Object.keys(this.options.bindings).forEach((oe) => {
      this.options.bindings[oe] && this.addBinding(this.options.bindings[oe]);
    }), this.addBinding({
      key: "Enter",
      shiftKey: null
    }, this.handleEnter), this.addBinding({
      key: "Enter",
      metaKey: null,
      ctrlKey: null,
      altKey: null
    }, () => {
    }), /Firefox/i.test(navigator.userAgent) ? (this.addBinding({
      key: "Backspace"
    }, {
      collapsed: !0
    }, this.handleBackspace), this.addBinding({
      key: "Delete"
    }, {
      collapsed: !0
    }, this.handleDelete)) : (this.addBinding({
      key: "Backspace"
    }, {
      collapsed: !0,
      prefix: /^.?$/
    }, this.handleBackspace), this.addBinding({
      key: "Delete"
    }, {
      collapsed: !0,
      suffix: /^.?$/
    }, this.handleDelete)), this.addBinding({
      key: "Backspace"
    }, {
      collapsed: !1
    }, this.handleDeleteRange), this.addBinding({
      key: "Delete"
    }, {
      collapsed: !1
    }, this.handleDeleteRange), this.addBinding({
      key: "Backspace",
      altKey: null,
      ctrlKey: null,
      metaKey: null,
      shiftKey: null
    }, {
      collapsed: !0,
      offset: 0
    }, this.handleBackspace), this.listen();
  }
  addBinding(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, oe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const ue = normalize$2(Y);
    if (ue == null) {
      debug$2.warn("Attempted to add invalid keyboard binding", ue);
      return;
    }
    typeof re == "function" && (re = {
      handler: re
    }), typeof oe == "function" && (oe = {
      handler: oe
    }), (Array.isArray(ue.key) ? ue.key : [ue.key]).forEach((he) => {
      const _e = {
        ...ue,
        key: he,
        ...re,
        ...oe
      };
      this.bindings[_e.key] = this.bindings[_e.key] || [], this.bindings[_e.key].push(_e);
    });
  }
  listen() {
    this.quill.root.addEventListener("keydown", (Y) => {
      if (Y.defaultPrevented || Y.isComposing || Y.keyCode === 229 && (Y.key === "Enter" || Y.key === "Backspace")) return;
      const ue = (this.bindings[Y.key] || []).concat(this.bindings[Y.which] || []).filter((Ae) => Keyboard.match(Y, Ae));
      if (ue.length === 0) return;
      const fe = Quill.find(Y.target, !0);
      if (fe && fe.scroll !== this.quill.scroll) return;
      const he = this.quill.getSelection();
      if (he == null || !this.quill.hasFocus()) return;
      const [_e, ve] = this.quill.getLine(he.index), [xe, Ee] = this.quill.getLeaf(he.index), [Se, Te] = he.length === 0 ? [xe, Ee] : this.quill.getLeaf(he.index + he.length), Ce = xe instanceof TextBlot$1 ? xe.value().slice(0, Ee) : "", Ie = Se instanceof TextBlot$1 ? Se.value().slice(Te) : "", Ne = {
        collapsed: he.length === 0,
        // @ts-expect-error Fix me later
        empty: he.length === 0 && _e.length() <= 1,
        format: this.quill.getFormat(he),
        line: _e,
        offset: ve,
        prefix: Ce,
        suffix: Ie,
        event: Y
      };
      ue.some((Ae) => {
        if (Ae.collapsed != null && Ae.collapsed !== Ne.collapsed || Ae.empty != null && Ae.empty !== Ne.empty || Ae.offset != null && Ae.offset !== Ne.offset)
          return !1;
        if (Array.isArray(Ae.format)) {
          if (Ae.format.every((Pe) => Ne.format[Pe] == null))
            return !1;
        } else if (typeof Ae.format == "object" && !Object.keys(Ae.format).every((Pe) => Ae.format[Pe] === !0 ? Ne.format[Pe] != null : Ae.format[Pe] === !1 ? Ne.format[Pe] == null : isEqual$2(Ae.format[Pe], Ne.format[Pe])))
          return !1;
        return Ae.prefix != null && !Ae.prefix.test(Ne.prefix) || Ae.suffix != null && !Ae.suffix.test(Ne.suffix) ? !1 : Ae.handler.call(this, he, Ne, Ae) !== !0;
      }) && Y.preventDefault();
    });
  }
  handleBackspace(Y, re) {
    const oe = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(re.prefix) ? 2 : 1;
    if (Y.index === 0 || this.quill.getLength() <= 1) return;
    let ue = {};
    const [fe] = this.quill.getLine(Y.index);
    let he = new Delta().retain(Y.index - oe).delete(oe);
    if (re.offset === 0) {
      const [_e] = this.quill.getLine(Y.index - 1);
      if (_e && !(_e.statics.blotName === "block" && _e.length() <= 1)) {
        const xe = fe.formats(), Ee = this.quill.getFormat(Y.index - 1, 1);
        if (ue = DeltaExports.AttributeMap.diff(xe, Ee) || {}, Object.keys(ue).length > 0) {
          const Se = new Delta().retain(Y.index + fe.length() - 2).retain(1, ue);
          he = he.compose(Se);
        }
      }
    }
    this.quill.updateContents(he, Quill.sources.USER), this.quill.focus();
  }
  handleDelete(Y, re) {
    const oe = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(re.suffix) ? 2 : 1;
    if (Y.index >= this.quill.getLength() - oe) return;
    let ue = {};
    const [fe] = this.quill.getLine(Y.index);
    let he = new Delta().retain(Y.index).delete(oe);
    if (re.offset >= fe.length() - 1) {
      const [_e] = this.quill.getLine(Y.index + 1);
      if (_e) {
        const ve = fe.formats(), xe = this.quill.getFormat(Y.index, 1);
        ue = DeltaExports.AttributeMap.diff(ve, xe) || {}, Object.keys(ue).length > 0 && (he = he.retain(_e.length() - 1).retain(1, ue));
      }
    }
    this.quill.updateContents(he, Quill.sources.USER), this.quill.focus();
  }
  handleDeleteRange(Y) {
    deleteRange({
      range: Y,
      quill: this.quill
    }), this.quill.focus();
  }
  handleEnter(Y, re) {
    const oe = Object.keys(re.format).reduce((fe, he) => (this.quill.scroll.query(he, Scope.BLOCK) && !Array.isArray(re.format[he]) && (fe[he] = re.format[he]), fe), {}), ue = new Delta().retain(Y.index).delete(Y.length).insert(`
`, oe);
    this.quill.updateContents(ue, Quill.sources.USER), this.quill.setSelection(Y.index + 1, Quill.sources.SILENT), this.quill.focus();
  }
}
const defaultOptions = {
  bindings: {
    bold: makeFormatHandler("bold"),
    italic: makeFormatHandler("italic"),
    underline: makeFormatHandler("underline"),
    indent: {
      // highlight tab or tab at beginning of list, indent or blockquote
      key: "Tab",
      format: ["blockquote", "indent", "list"],
      handler(le, Y) {
        return Y.collapsed && Y.offset !== 0 ? !0 : (this.quill.format("indent", "+1", Quill.sources.USER), !1);
      }
    },
    outdent: {
      key: "Tab",
      shiftKey: !0,
      format: ["blockquote", "indent", "list"],
      // highlight tab or tab at beginning of list, indent or blockquote
      handler(le, Y) {
        return Y.collapsed && Y.offset !== 0 ? !0 : (this.quill.format("indent", "-1", Quill.sources.USER), !1);
      }
    },
    "outdent backspace": {
      key: "Backspace",
      collapsed: !0,
      shiftKey: null,
      metaKey: null,
      ctrlKey: null,
      altKey: null,
      format: ["indent", "list"],
      offset: 0,
      handler(le, Y) {
        Y.format.indent != null ? this.quill.format("indent", "-1", Quill.sources.USER) : Y.format.list != null && this.quill.format("list", !1, Quill.sources.USER);
      }
    },
    "indent code-block": makeCodeBlockHandler(!0),
    "outdent code-block": makeCodeBlockHandler(!1),
    "remove tab": {
      key: "Tab",
      shiftKey: !0,
      collapsed: !0,
      prefix: /\t$/,
      handler(le) {
        this.quill.deleteText(le.index - 1, 1, Quill.sources.USER);
      }
    },
    tab: {
      key: "Tab",
      handler(le, Y) {
        if (Y.format.table) return !0;
        this.quill.history.cutoff();
        const re = new Delta().retain(le.index).delete(le.length).insert("	");
        return this.quill.updateContents(re, Quill.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(le.index + 1, Quill.sources.SILENT), !1;
      }
    },
    "blockquote empty enter": {
      key: "Enter",
      collapsed: !0,
      format: ["blockquote"],
      empty: !0,
      handler() {
        this.quill.format("blockquote", !1, Quill.sources.USER);
      }
    },
    "list empty enter": {
      key: "Enter",
      collapsed: !0,
      format: ["list"],
      empty: !0,
      handler(le, Y) {
        const re = {
          list: !1
        };
        Y.format.indent && (re.indent = !1), this.quill.formatLine(le.index, le.length, re, Quill.sources.USER);
      }
    },
    "checklist enter": {
      key: "Enter",
      collapsed: !0,
      format: {
        list: "checked"
      },
      handler(le) {
        const [Y, re] = this.quill.getLine(le.index), oe = {
          // @ts-expect-error Fix me later
          ...Y.formats(),
          list: "checked"
        }, ue = new Delta().retain(le.index).insert(`
`, oe).retain(Y.length() - re - 1).retain(1, {
          list: "unchecked"
        });
        this.quill.updateContents(ue, Quill.sources.USER), this.quill.setSelection(le.index + 1, Quill.sources.SILENT), this.quill.scrollSelectionIntoView();
      }
    },
    "header enter": {
      key: "Enter",
      collapsed: !0,
      format: ["header"],
      suffix: /^$/,
      handler(le, Y) {
        const [re, oe] = this.quill.getLine(le.index), ue = new Delta().retain(le.index).insert(`
`, Y.format).retain(re.length() - oe - 1).retain(1, {
          header: null
        });
        this.quill.updateContents(ue, Quill.sources.USER), this.quill.setSelection(le.index + 1, Quill.sources.SILENT), this.quill.scrollSelectionIntoView();
      }
    },
    "table backspace": {
      key: "Backspace",
      format: ["table"],
      collapsed: !0,
      offset: 0,
      handler() {
      }
    },
    "table delete": {
      key: "Delete",
      format: ["table"],
      collapsed: !0,
      suffix: /^$/,
      handler() {
      }
    },
    "table enter": {
      key: "Enter",
      shiftKey: null,
      format: ["table"],
      handler(le) {
        const Y = this.quill.getModule("table");
        if (Y) {
          const [re, oe, ue, fe] = Y.getTable(le), he = tableSide(re, oe, ue, fe);
          if (he == null) return;
          let _e = re.offset();
          if (he < 0) {
            const ve = new Delta().retain(_e).insert(`
`);
            this.quill.updateContents(ve, Quill.sources.USER), this.quill.setSelection(le.index + 1, le.length, Quill.sources.SILENT);
          } else if (he > 0) {
            _e += re.length();
            const ve = new Delta().retain(_e).insert(`
`);
            this.quill.updateContents(ve, Quill.sources.USER), this.quill.setSelection(_e, Quill.sources.USER);
          }
        }
      }
    },
    "table tab": {
      key: "Tab",
      shiftKey: null,
      format: ["table"],
      handler(le, Y) {
        const {
          event: re,
          line: oe
        } = Y, ue = oe.offset(this.quill.scroll);
        re.shiftKey ? this.quill.setSelection(ue - 1, Quill.sources.USER) : this.quill.setSelection(ue + oe.length(), Quill.sources.USER);
      }
    },
    "list autofill": {
      key: " ",
      shiftKey: null,
      collapsed: !0,
      format: {
        "code-block": !1,
        blockquote: !1,
        table: !1
      },
      prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
      handler(le, Y) {
        if (this.quill.scroll.query("list") == null) return !0;
        const {
          length: re
        } = Y.prefix, [oe, ue] = this.quill.getLine(le.index);
        if (ue > re) return !0;
        let fe;
        switch (Y.prefix.trim()) {
          case "[]":
          case "[ ]":
            fe = "unchecked";
            break;
          case "[x]":
            fe = "checked";
            break;
          case "-":
          case "*":
            fe = "bullet";
            break;
          default:
            fe = "ordered";
        }
        this.quill.insertText(le.index, " ", Quill.sources.USER), this.quill.history.cutoff();
        const he = new Delta().retain(le.index - ue).delete(re + 1).retain(oe.length() - 2 - ue).retain(1, {
          list: fe
        });
        return this.quill.updateContents(he, Quill.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(le.index - re, Quill.sources.SILENT), !1;
      }
    },
    "code exit": {
      key: "Enter",
      collapsed: !0,
      format: ["code-block"],
      prefix: /^$/,
      suffix: /^\s*$/,
      handler(le) {
        const [Y, re] = this.quill.getLine(le.index);
        let oe = 2, ue = Y;
        for (; ue != null && ue.length() <= 1 && ue.formats()["code-block"]; )
          if (ue = ue.prev, oe -= 1, oe <= 0) {
            const fe = new Delta().retain(le.index + Y.length() - re - 2).retain(1, {
              "code-block": null
            }).delete(1);
            return this.quill.updateContents(fe, Quill.sources.USER), this.quill.setSelection(le.index - 1, Quill.sources.SILENT), !1;
          }
        return !0;
      }
    },
    "embed left": makeEmbedArrowHandler("ArrowLeft", !1),
    "embed left shift": makeEmbedArrowHandler("ArrowLeft", !0),
    "embed right": makeEmbedArrowHandler("ArrowRight", !1),
    "embed right shift": makeEmbedArrowHandler("ArrowRight", !0),
    "table down": makeTableArrowHandler(!1),
    "table up": makeTableArrowHandler(!0)
  }
};
Keyboard.DEFAULTS = defaultOptions;
function makeCodeBlockHandler(le) {
  return {
    key: "Tab",
    shiftKey: !le,
    format: {
      "code-block": !0
    },
    handler(Y, re) {
      let {
        event: oe
      } = re;
      const ue = this.quill.scroll.query("code-block"), {
        TAB: fe
      } = ue;
      if (Y.length === 0 && !oe.shiftKey) {
        this.quill.insertText(Y.index, fe, Quill.sources.USER), this.quill.setSelection(Y.index + fe.length, Quill.sources.SILENT);
        return;
      }
      const he = Y.length === 0 ? this.quill.getLines(Y.index, 1) : this.quill.getLines(Y);
      let {
        index: _e,
        length: ve
      } = Y;
      he.forEach((xe, Ee) => {
        le ? (xe.insertAt(0, fe), Ee === 0 ? _e += fe.length : ve += fe.length) : xe.domNode.textContent.startsWith(fe) && (xe.deleteAt(0, fe.length), Ee === 0 ? _e -= fe.length : ve -= fe.length);
      }), this.quill.update(Quill.sources.USER), this.quill.setSelection(_e, ve, Quill.sources.SILENT);
    }
  };
}
function makeEmbedArrowHandler(le, Y) {
  return {
    key: le,
    shiftKey: Y,
    altKey: null,
    [le === "ArrowLeft" ? "prefix" : "suffix"]: /^$/,
    handler(oe) {
      let {
        index: ue
      } = oe;
      le === "ArrowRight" && (ue += oe.length + 1);
      const [fe] = this.quill.getLeaf(ue);
      return fe instanceof EmbedBlot$1 ? (le === "ArrowLeft" ? Y ? this.quill.setSelection(oe.index - 1, oe.length + 1, Quill.sources.USER) : this.quill.setSelection(oe.index - 1, Quill.sources.USER) : Y ? this.quill.setSelection(oe.index, oe.length + 1, Quill.sources.USER) : this.quill.setSelection(oe.index + oe.length + 1, Quill.sources.USER), !1) : !0;
    }
  };
}
function makeFormatHandler(le) {
  return {
    key: le[0],
    shortKey: !0,
    handler(Y, re) {
      this.quill.format(le, !re.format[le], Quill.sources.USER);
    }
  };
}
function makeTableArrowHandler(le) {
  return {
    key: le ? "ArrowUp" : "ArrowDown",
    collapsed: !0,
    format: ["table"],
    handler(Y, re) {
      const oe = le ? "prev" : "next", ue = re.line, fe = ue.parent[oe];
      if (fe != null) {
        if (fe.statics.blotName === "table-row") {
          let he = fe.children.head, _e = ue;
          for (; _e.prev != null; )
            _e = _e.prev, he = he.next;
          const ve = he.offset(this.quill.scroll) + Math.min(re.offset, he.length() - 1);
          this.quill.setSelection(ve, 0, Quill.sources.USER);
        }
      } else {
        const he = ue.table()[oe];
        he != null && (le ? this.quill.setSelection(he.offset(this.quill.scroll) + he.length() - 1, 0, Quill.sources.USER) : this.quill.setSelection(he.offset(this.quill.scroll), 0, Quill.sources.USER));
      }
      return !1;
    }
  };
}
function normalize$2(le) {
  if (typeof le == "string" || typeof le == "number")
    le = {
      key: le
    };
  else if (typeof le == "object")
    le = cloneDeep(le);
  else
    return null;
  return le.shortKey && (le[SHORTKEY] = le.shortKey, delete le.shortKey), le;
}
function deleteRange(le) {
  let {
    quill: Y,
    range: re
  } = le;
  const oe = Y.getLines(re);
  let ue = {};
  if (oe.length > 1) {
    const fe = oe[0].formats(), he = oe[oe.length - 1].formats();
    ue = DeltaExports.AttributeMap.diff(he, fe) || {};
  }
  Y.deleteText(re, Quill.sources.USER), Object.keys(ue).length > 0 && Y.formatLine(re.index, 1, ue, Quill.sources.USER), Y.setSelection(re.index, Quill.sources.SILENT);
}
function tableSide(le, Y, re, oe) {
  return Y.prev == null && Y.next == null ? re.prev == null && re.next == null ? oe === 0 ? -1 : 1 : re.prev == null ? -1 : 1 : Y.prev == null ? -1 : Y.next == null ? 1 : null;
}
const normalWeightRegexp = /font-weight:\s*normal/, blockTagNames = ["P", "OL", "UL"], isBlockElement = (le) => le && blockTagNames.includes(le.tagName), normalizeEmptyLines = (le) => {
  Array.from(le.querySelectorAll("br")).filter((Y) => isBlockElement(Y.previousElementSibling) && isBlockElement(Y.nextElementSibling)).forEach((Y) => {
    Y.parentNode?.removeChild(Y);
  });
}, normalizeFontWeight = (le) => {
  Array.from(le.querySelectorAll('b[style*="font-weight"]')).filter((Y) => Y.getAttribute("style")?.match(normalWeightRegexp)).forEach((Y) => {
    const re = le.createDocumentFragment();
    re.append(...Y.childNodes), Y.parentNode?.replaceChild(re, Y);
  });
};
function normalize$1(le) {
  le.querySelector('[id^="docs-internal-guid-"]') && (normalizeFontWeight(le), normalizeEmptyLines(le));
}
const ignoreRegexp = /\bmso-list:[^;]*ignore/i, idRegexp = /\bmso-list:[^;]*\bl(\d+)/i, indentRegexp = /\bmso-list:[^;]*\blevel(\d+)/i, parseListItem = (le, Y) => {
  const re = le.getAttribute("style"), oe = re?.match(idRegexp);
  if (!oe)
    return null;
  const ue = Number(oe[1]), fe = re?.match(indentRegexp), he = fe ? Number(fe[1]) : 1, _e = new RegExp(`@list l${ue}:level${he}\\s*\\{[^\\}]*mso-level-number-format:\\s*([\\w-]+)`, "i"), ve = Y.match(_e), xe = ve && ve[1] === "bullet" ? "bullet" : "ordered";
  return {
    id: ue,
    indent: he,
    type: xe,
    element: le
  };
}, normalizeListItem = (le) => {
  const Y = Array.from(le.querySelectorAll("[style*=mso-list]")), re = [], oe = [];
  Y.forEach((he) => {
    (he.getAttribute("style") || "").match(ignoreRegexp) ? re.push(he) : oe.push(he);
  }), re.forEach((he) => he.parentNode?.removeChild(he));
  const ue = le.documentElement.innerHTML, fe = oe.map((he) => parseListItem(he, ue)).filter((he) => he);
  for (; fe.length; ) {
    const he = [];
    let _e = fe.shift();
    for (; _e; )
      he.push(_e), _e = fe.length && fe[0]?.element === _e.element.nextElementSibling && // Different id means the next item doesn't belong to this group.
      fe[0].id === _e.id ? fe.shift() : null;
    const ve = document.createElement("ul");
    he.forEach((Se) => {
      const Te = document.createElement("li");
      Te.setAttribute("data-list", Se.type), Se.indent > 1 && Te.setAttribute("class", `ql-indent-${Se.indent - 1}`), Te.innerHTML = Se.element.innerHTML, ve.appendChild(Te);
    });
    const xe = he[0]?.element, {
      parentNode: Ee
    } = xe ?? {};
    xe && Ee?.replaceChild(ve, xe), he.slice(1).forEach((Se) => {
      let {
        element: Te
      } = Se;
      Ee?.removeChild(Te);
    });
  }
};
function normalize(le) {
  le.documentElement.getAttribute("xmlns:w") === "urn:schemas-microsoft-com:office:word" && normalizeListItem(le);
}
const NORMALIZERS = [normalize, normalize$1], normalizeExternalHTML = (le) => {
  le.documentElement && NORMALIZERS.forEach((Y) => {
    Y(le);
  });
}, debug$1 = namespace("quill:clipboard"), CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ["br", matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ["li", matchIndent], ["ol, ul", matchList], ["pre", matchCodeBlock], ["tr", matchTable], ["b", createMatchAlias("bold")], ["i", createMatchAlias("italic")], ["strike", createMatchAlias("strike")], ["style", matchIgnore]], ATTRIBUTE_ATTRIBUTORS = [AlignAttribute, DirectionAttribute].reduce((le, Y) => (le[Y.keyName] = Y, le), {}), STYLE_ATTRIBUTORS = [AlignStyle, BackgroundStyle, ColorStyle, DirectionStyle, FontStyle, SizeStyle].reduce((le, Y) => (le[Y.keyName] = Y, le), {});
class Clipboard extends Module$1 {
  static DEFAULTS = {
    matchers: []
  };
  constructor(Y, re) {
    super(Y, re), this.quill.root.addEventListener("copy", (oe) => this.onCaptureCopy(oe, !1)), this.quill.root.addEventListener("cut", (oe) => this.onCaptureCopy(oe, !0)), this.quill.root.addEventListener("paste", this.onCapturePaste.bind(this)), this.matchers = [], CLIPBOARD_CONFIG.concat(this.options.matchers ?? []).forEach((oe) => {
      let [ue, fe] = oe;
      this.addMatcher(ue, fe);
    });
  }
  addMatcher(Y, re) {
    this.matchers.push([Y, re]);
  }
  convert(Y) {
    let {
      html: re,
      text: oe
    } = Y, ue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (ue[CodeBlock.blotName])
      return new Delta().insert(oe || "", {
        [CodeBlock.blotName]: ue[CodeBlock.blotName]
      });
    if (!re)
      return new Delta().insert(oe || "", ue);
    const fe = this.convertHTML(re);
    return deltaEndsWith(fe, `
`) && (fe.ops[fe.ops.length - 1].attributes == null || ue.table) ? fe.compose(new Delta().retain(fe.length() - 1).delete(1)) : fe;
  }
  normalizeHTML(Y) {
    normalizeExternalHTML(Y);
  }
  convertHTML(Y) {
    const re = new DOMParser().parseFromString(Y, "text/html");
    this.normalizeHTML(re);
    const oe = re.body, ue = /* @__PURE__ */ new WeakMap(), [fe, he] = this.prepareMatching(oe, ue);
    return traverse(this.quill.scroll, oe, fe, he, ue);
  }
  dangerouslyPasteHTML(Y, re) {
    let oe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Quill.sources.API;
    if (typeof Y == "string") {
      const ue = this.convert({
        html: Y,
        text: ""
      });
      this.quill.setContents(ue, re), this.quill.setSelection(0, Quill.sources.SILENT);
    } else {
      const ue = this.convert({
        html: re,
        text: ""
      });
      this.quill.updateContents(new Delta().retain(Y).concat(ue), oe), this.quill.setSelection(Y + ue.length(), Quill.sources.SILENT);
    }
  }
  onCaptureCopy(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (Y.defaultPrevented) return;
    Y.preventDefault();
    const [oe] = this.quill.selection.getRange();
    if (oe == null) return;
    const {
      html: ue,
      text: fe
    } = this.onCopy(oe, re);
    Y.clipboardData?.setData("text/plain", fe), Y.clipboardData?.setData("text/html", ue), re && deleteRange({
      range: oe,
      quill: this.quill
    });
  }
  /*
   * https://www.iana.org/assignments/media-types/text/uri-list
   */
  normalizeURIList(Y) {
    return Y.split(/\r?\n/).filter((re) => re[0] !== "#").join(`
`);
  }
  onCapturePaste(Y) {
    if (Y.defaultPrevented || !this.quill.isEnabled()) return;
    Y.preventDefault();
    const re = this.quill.getSelection(!0);
    if (re == null) return;
    const oe = Y.clipboardData?.getData("text/html");
    let ue = Y.clipboardData?.getData("text/plain");
    if (!oe && !ue) {
      const he = Y.clipboardData?.getData("text/uri-list");
      he && (ue = this.normalizeURIList(he));
    }
    const fe = Array.from(Y.clipboardData?.files || []);
    if (!oe && fe.length > 0) {
      this.quill.uploader.upload(re, fe);
      return;
    }
    if (oe && fe.length > 0) {
      const he = new DOMParser().parseFromString(oe, "text/html");
      if (he.body.childElementCount === 1 && he.body.firstElementChild?.tagName === "IMG") {
        this.quill.uploader.upload(re, fe);
        return;
      }
    }
    this.onPaste(re, {
      html: oe,
      text: ue
    });
  }
  onCopy(Y) {
    const re = this.quill.getText(Y);
    return {
      html: this.quill.getSemanticHTML(Y),
      text: re
    };
  }
  onPaste(Y, re) {
    let {
      text: oe,
      html: ue
    } = re;
    const fe = this.quill.getFormat(Y.index), he = this.convert({
      text: oe,
      html: ue
    }, fe);
    debug$1.log("onPaste", he, {
      text: oe,
      html: ue
    });
    const _e = new Delta().retain(Y.index).delete(Y.length).concat(he);
    this.quill.updateContents(_e, Quill.sources.USER), this.quill.setSelection(_e.length() - Y.length, Quill.sources.SILENT), this.quill.scrollSelectionIntoView();
  }
  prepareMatching(Y, re) {
    const oe = [], ue = [];
    return this.matchers.forEach((fe) => {
      const [he, _e] = fe;
      switch (he) {
        case Node.TEXT_NODE:
          ue.push(_e);
          break;
        case Node.ELEMENT_NODE:
          oe.push(_e);
          break;
        default:
          Array.from(Y.querySelectorAll(he)).forEach((ve) => {
            re.has(ve) ? re.get(ve)?.push(_e) : re.set(ve, [_e]);
          });
          break;
      }
    }), [oe, ue];
  }
}
function applyFormat(le, Y, re, oe) {
  return oe.query(Y) ? le.reduce((ue, fe) => {
    if (!fe.insert) return ue;
    if (fe.attributes && fe.attributes[Y])
      return ue.push(fe);
    const he = re ? {
      [Y]: re
    } : {};
    return ue.insert(fe.insert, {
      ...he,
      ...fe.attributes
    });
  }, new Delta()) : le;
}
function deltaEndsWith(le, Y) {
  let re = "";
  for (let oe = le.ops.length - 1; oe >= 0 && re.length < Y.length; --oe) {
    const ue = le.ops[oe];
    if (typeof ue.insert != "string") break;
    re = ue.insert + re;
  }
  return re.slice(-1 * Y.length) === Y;
}
function isLine(le, Y) {
  if (!(le instanceof Element)) return !1;
  const re = Y.query(le);
  return re && re.prototype instanceof EmbedBlot$1 ? !1 : ["address", "article", "blockquote", "canvas", "dd", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "iframe", "li", "main", "nav", "ol", "output", "p", "pre", "section", "table", "td", "tr", "ul", "video"].includes(le.tagName.toLowerCase());
}
function isBetweenInlineElements(le, Y) {
  return le.previousElementSibling && le.nextElementSibling && !isLine(le.previousElementSibling, Y) && !isLine(le.nextElementSibling, Y);
}
const preNodes = /* @__PURE__ */ new WeakMap();
function isPre(le) {
  return le == null ? !1 : (preNodes.has(le) || (le.tagName === "PRE" ? preNodes.set(le, !0) : preNodes.set(le, isPre(le.parentNode))), preNodes.get(le));
}
function traverse(le, Y, re, oe, ue) {
  return Y.nodeType === Y.TEXT_NODE ? oe.reduce((fe, he) => he(Y, fe, le), new Delta()) : Y.nodeType === Y.ELEMENT_NODE ? Array.from(Y.childNodes || []).reduce((fe, he) => {
    let _e = traverse(le, he, re, oe, ue);
    return he.nodeType === Y.ELEMENT_NODE && (_e = re.reduce((ve, xe) => xe(he, ve, le), _e), _e = (ue.get(he) || []).reduce((ve, xe) => xe(he, ve, le), _e)), fe.concat(_e);
  }, new Delta()) : new Delta();
}
function createMatchAlias(le) {
  return (Y, re, oe) => applyFormat(re, le, !0, oe);
}
function matchAttributor(le, Y, re) {
  const oe = Attributor.keys(le), ue = ClassAttributor$1.keys(le), fe = StyleAttributor$1.keys(le), he = {};
  return oe.concat(ue).concat(fe).forEach((_e) => {
    let ve = re.query(_e, Scope.ATTRIBUTE);
    ve != null && (he[ve.attrName] = ve.value(le), he[ve.attrName]) || (ve = ATTRIBUTE_ATTRIBUTORS[_e], ve != null && (ve.attrName === _e || ve.keyName === _e) && (he[ve.attrName] = ve.value(le) || void 0), ve = STYLE_ATTRIBUTORS[_e], ve != null && (ve.attrName === _e || ve.keyName === _e) && (ve = STYLE_ATTRIBUTORS[_e], he[ve.attrName] = ve.value(le) || void 0));
  }), Object.entries(he).reduce((_e, ve) => {
    let [xe, Ee] = ve;
    return applyFormat(_e, xe, Ee, re);
  }, Y);
}
function matchBlot(le, Y, re) {
  const oe = re.query(le);
  if (oe == null) return Y;
  if (oe.prototype instanceof EmbedBlot$1) {
    const ue = {}, fe = oe.value(le);
    if (fe != null)
      return ue[oe.blotName] = fe, new Delta().insert(ue, oe.formats(le, re));
  } else if (oe.prototype instanceof BlockBlot$1 && !deltaEndsWith(Y, `
`) && Y.insert(`
`), "blotName" in oe && "formats" in oe && typeof oe.formats == "function")
    return applyFormat(Y, oe.blotName, oe.formats(le, re), re);
  return Y;
}
function matchBreak(le, Y) {
  return deltaEndsWith(Y, `
`) || Y.insert(`
`), Y;
}
function matchCodeBlock(le, Y, re) {
  const oe = re.query("code-block"), ue = oe && "formats" in oe && typeof oe.formats == "function" ? oe.formats(le, re) : !0;
  return applyFormat(Y, "code-block", ue, re);
}
function matchIgnore() {
  return new Delta();
}
function matchIndent(le, Y, re) {
  const oe = re.query(le);
  if (oe == null || // @ts-expect-error
  oe.blotName !== "list" || !deltaEndsWith(Y, `
`))
    return Y;
  let ue = -1, fe = le.parentNode;
  for (; fe != null; )
    ["OL", "UL"].includes(fe.tagName) && (ue += 1), fe = fe.parentNode;
  return ue <= 0 ? Y : Y.reduce((he, _e) => _e.insert ? _e.attributes && typeof _e.attributes.indent == "number" ? he.push(_e) : he.insert(_e.insert, {
    indent: ue,
    ..._e.attributes || {}
  }) : he, new Delta());
}
function matchList(le, Y, re) {
  const oe = le;
  let ue = oe.tagName === "OL" ? "ordered" : "bullet";
  const fe = oe.getAttribute("data-checked");
  return fe && (ue = fe === "true" ? "checked" : "unchecked"), applyFormat(Y, "list", ue, re);
}
function matchNewline(le, Y, re) {
  if (!deltaEndsWith(Y, `
`)) {
    if (isLine(le, re) && (le.childNodes.length > 0 || le instanceof HTMLParagraphElement))
      return Y.insert(`
`);
    if (Y.length() > 0 && le.nextSibling) {
      let oe = le.nextSibling;
      for (; oe != null; ) {
        if (isLine(oe, re))
          return Y.insert(`
`);
        const ue = re.query(oe);
        if (ue && ue.prototype instanceof BlockEmbed)
          return Y.insert(`
`);
        oe = oe.firstChild;
      }
    }
  }
  return Y;
}
function matchStyles(le, Y, re) {
  const oe = {}, ue = le.style || {};
  return ue.fontStyle === "italic" && (oe.italic = !0), ue.textDecoration === "underline" && (oe.underline = !0), ue.textDecoration === "line-through" && (oe.strike = !0), (ue.fontWeight?.startsWith("bold") || // @ts-expect-error Fix me later
  parseInt(ue.fontWeight, 10) >= 700) && (oe.bold = !0), Y = Object.entries(oe).reduce((fe, he) => {
    let [_e, ve] = he;
    return applyFormat(fe, _e, ve, re);
  }, Y), parseFloat(ue.textIndent || 0) > 0 ? new Delta().insert("	").concat(Y) : Y;
}
function matchTable(le, Y, re) {
  const oe = le.parentElement?.tagName === "TABLE" ? le.parentElement : le.parentElement?.parentElement;
  if (oe != null) {
    const fe = Array.from(oe.querySelectorAll("tr")).indexOf(le) + 1;
    return applyFormat(Y, "table", fe, re);
  }
  return Y;
}
function matchText(le, Y, re) {
  let oe = le.data;
  if (le.parentElement?.tagName === "O:P")
    return Y.insert(oe.trim());
  if (!isPre(le)) {
    if (oe.trim().length === 0 && oe.includes(`
`) && !isBetweenInlineElements(le, re))
      return Y;
    oe = oe.replace(/[^\S\u00a0]/g, " "), oe = oe.replace(/ {2,}/g, " "), (le.previousSibling == null && le.parentElement != null && isLine(le.parentElement, re) || le.previousSibling instanceof Element && isLine(le.previousSibling, re)) && (oe = oe.replace(/^ /, "")), (le.nextSibling == null && le.parentElement != null && isLine(le.parentElement, re) || le.nextSibling instanceof Element && isLine(le.nextSibling, re)) && (oe = oe.replace(/ $/, "")), oe = oe.replaceAll(" ", " ");
  }
  return Y.insert(oe);
}
class History extends Module$1 {
  static DEFAULTS = {
    delay: 1e3,
    maxStack: 100,
    userOnly: !1
  };
  lastRecorded = 0;
  ignoreChange = !1;
  stack = {
    undo: [],
    redo: []
  };
  currentRange = null;
  constructor(Y, re) {
    super(Y, re), this.quill.on(Quill.events.EDITOR_CHANGE, (oe, ue, fe, he) => {
      oe === Quill.events.SELECTION_CHANGE ? ue && he !== Quill.sources.SILENT && (this.currentRange = ue) : oe === Quill.events.TEXT_CHANGE && (this.ignoreChange || (!this.options.userOnly || he === Quill.sources.USER ? this.record(ue, fe) : this.transform(ue)), this.currentRange = transformRange(this.currentRange, ue));
    }), this.quill.keyboard.addBinding({
      key: "z",
      shortKey: !0
    }, this.undo.bind(this)), this.quill.keyboard.addBinding({
      key: ["z", "Z"],
      shortKey: !0,
      shiftKey: !0
    }, this.redo.bind(this)), /Win/i.test(navigator.platform) && this.quill.keyboard.addBinding({
      key: "y",
      shortKey: !0
    }, this.redo.bind(this)), this.quill.root.addEventListener("beforeinput", (oe) => {
      oe.inputType === "historyUndo" ? (this.undo(), oe.preventDefault()) : oe.inputType === "historyRedo" && (this.redo(), oe.preventDefault());
    });
  }
  change(Y, re) {
    if (this.stack[Y].length === 0) return;
    const oe = this.stack[Y].pop();
    if (!oe) return;
    const ue = this.quill.getContents(), fe = oe.delta.invert(ue);
    this.stack[re].push({
      delta: fe,
      range: transformRange(oe.range, fe)
    }), this.lastRecorded = 0, this.ignoreChange = !0, this.quill.updateContents(oe.delta, Quill.sources.USER), this.ignoreChange = !1, this.restoreSelection(oe);
  }
  clear() {
    this.stack = {
      undo: [],
      redo: []
    };
  }
  cutoff() {
    this.lastRecorded = 0;
  }
  record(Y, re) {
    if (Y.ops.length === 0) return;
    this.stack.redo = [];
    let oe = Y.invert(re), ue = this.currentRange;
    const fe = Date.now();
    if (
      // @ts-expect-error Fix me later
      this.lastRecorded + this.options.delay > fe && this.stack.undo.length > 0
    ) {
      const he = this.stack.undo.pop();
      he && (oe = oe.compose(he.delta), ue = he.range);
    } else
      this.lastRecorded = fe;
    oe.length() !== 0 && (this.stack.undo.push({
      delta: oe,
      range: ue
    }), this.stack.undo.length > this.options.maxStack && this.stack.undo.shift());
  }
  redo() {
    this.change("redo", "undo");
  }
  transform(Y) {
    transformStack(this.stack.undo, Y), transformStack(this.stack.redo, Y);
  }
  undo() {
    this.change("undo", "redo");
  }
  restoreSelection(Y) {
    if (Y.range)
      this.quill.setSelection(Y.range, Quill.sources.USER);
    else {
      const re = getLastChangeIndex(this.quill.scroll, Y.delta);
      this.quill.setSelection(re, Quill.sources.USER);
    }
  }
}
function transformStack(le, Y) {
  let re = Y;
  for (let oe = le.length - 1; oe >= 0; oe -= 1) {
    const ue = le[oe];
    le[oe] = {
      delta: re.transform(ue.delta, !0),
      range: ue.range && transformRange(ue.range, re)
    }, re = ue.delta.transform(re), le[oe].delta.length() === 0 && le.splice(oe, 1);
  }
}
function endsWithNewlineChange(le, Y) {
  const re = Y.ops[Y.ops.length - 1];
  return re == null ? !1 : re.insert != null ? typeof re.insert == "string" && re.insert.endsWith(`
`) : re.attributes != null ? Object.keys(re.attributes).some((oe) => le.query(oe, Scope.BLOCK) != null) : !1;
}
function getLastChangeIndex(le, Y) {
  const re = Y.reduce((ue, fe) => ue + (fe.delete || 0), 0);
  let oe = Y.length() - re;
  return endsWithNewlineChange(le, Y) && (oe -= 1), oe;
}
function transformRange(le, Y) {
  if (!le) return le;
  const re = Y.transformPosition(le.index), oe = Y.transformPosition(le.index + le.length);
  return {
    index: re,
    length: oe - re
  };
}
class Uploader extends Module$1 {
  constructor(Y, re) {
    super(Y, re), Y.root.addEventListener("drop", (oe) => {
      oe.preventDefault();
      let ue = null;
      if (document.caretRangeFromPoint)
        ue = document.caretRangeFromPoint(oe.clientX, oe.clientY);
      else if (document.caretPositionFromPoint) {
        const he = document.caretPositionFromPoint(oe.clientX, oe.clientY);
        ue = document.createRange(), ue.setStart(he.offsetNode, he.offset), ue.setEnd(he.offsetNode, he.offset);
      }
      const fe = ue && Y.selection.normalizeNative(ue);
      if (fe) {
        const he = Y.selection.normalizedToRange(fe);
        oe.dataTransfer?.files && this.upload(he, oe.dataTransfer.files);
      }
    });
  }
  upload(Y, re) {
    const oe = [];
    Array.from(re).forEach((ue) => {
      ue && this.options.mimetypes?.includes(ue.type) && oe.push(ue);
    }), oe.length > 0 && this.options.handler.call(this, Y, oe);
  }
}
Uploader.DEFAULTS = {
  mimetypes: ["image/png", "image/jpeg"],
  handler(le, Y) {
    if (!this.quill.scroll.query("image"))
      return;
    const re = Y.map((oe) => new Promise((ue) => {
      const fe = new FileReader();
      fe.onload = () => {
        ue(fe.result);
      }, fe.readAsDataURL(oe);
    }));
    Promise.all(re).then((oe) => {
      const ue = oe.reduce((fe, he) => fe.insert({
        image: he
      }), new Delta().retain(le.index).delete(le.length));
      this.quill.updateContents(ue, Emitter.sources.USER), this.quill.setSelection(le.index + oe.length, Emitter.sources.SILENT);
    });
  }
};
const INSERT_TYPES = ["insertText", "insertReplacementText"];
class Input extends Module$1 {
  constructor(Y, re) {
    super(Y, re), Y.root.addEventListener("beforeinput", (oe) => {
      this.handleBeforeInput(oe);
    }), /Android/i.test(navigator.userAgent) || Y.on(Quill.events.COMPOSITION_BEFORE_START, () => {
      this.handleCompositionStart();
    });
  }
  deleteRange(Y) {
    deleteRange({
      range: Y,
      quill: this.quill
    });
  }
  replaceText(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    if (Y.length === 0) return !1;
    if (re) {
      const oe = this.quill.getFormat(Y.index, 1);
      this.deleteRange(Y), this.quill.updateContents(new Delta().retain(Y.index).insert(re, oe), Quill.sources.USER);
    } else
      this.deleteRange(Y);
    return this.quill.setSelection(Y.index + re.length, 0, Quill.sources.SILENT), !0;
  }
  handleBeforeInput(Y) {
    if (this.quill.composition.isComposing || Y.defaultPrevented || !INSERT_TYPES.includes(Y.inputType))
      return;
    const re = Y.getTargetRanges ? Y.getTargetRanges()[0] : null;
    if (!re || re.collapsed === !0)
      return;
    const oe = getPlainTextFromInputEvent(Y);
    if (oe == null)
      return;
    const ue = this.quill.selection.normalizeNative(re), fe = ue ? this.quill.selection.normalizedToRange(ue) : null;
    fe && this.replaceText(fe, oe) && Y.preventDefault();
  }
  handleCompositionStart() {
    const Y = this.quill.getSelection();
    Y && this.replaceText(Y);
  }
}
function getPlainTextFromInputEvent(le) {
  return typeof le.data == "string" ? le.data : le.dataTransfer?.types.includes("text/plain") ? le.dataTransfer.getData("text/plain") : null;
}
const isMac = /Mac/i.test(navigator.platform), TTL_FOR_VALID_SELECTION_CHANGE = 100, canMoveCaretBeforeUINode = (le) => !!(le.key === "ArrowLeft" || le.key === "ArrowRight" || // RTL scripts or moving from the end of the previous line
le.key === "ArrowUp" || le.key === "ArrowDown" || le.key === "Home" || isMac && le.key === "a" && le.ctrlKey === !0);
class UINode extends Module$1 {
  isListening = !1;
  selectionChangeDeadline = 0;
  constructor(Y, re) {
    super(Y, re), this.handleArrowKeys(), this.handleNavigationShortcuts();
  }
  handleArrowKeys() {
    this.quill.keyboard.addBinding({
      key: ["ArrowLeft", "ArrowRight"],
      offset: 0,
      shiftKey: null,
      handler(Y, re) {
        let {
          line: oe,
          event: ue
        } = re;
        if (!(oe instanceof ParentBlot$1) || !oe.uiNode)
          return !0;
        const fe = getComputedStyle(oe.domNode).direction === "rtl";
        return fe && ue.key !== "ArrowRight" || !fe && ue.key !== "ArrowLeft" ? !0 : (this.quill.setSelection(Y.index - 1, Y.length + (ue.shiftKey ? 1 : 0), Quill.sources.USER), !1);
      }
    });
  }
  handleNavigationShortcuts() {
    this.quill.root.addEventListener("keydown", (Y) => {
      !Y.defaultPrevented && canMoveCaretBeforeUINode(Y) && this.ensureListeningToSelectionChange();
    });
  }
  /**
   * We only listen to the `selectionchange` event when
   * there is an intention of moving the caret to the beginning using shortcuts.
   * This is primarily implemented to prevent infinite loops, as we are changing
   * the selection within the handler of a `selectionchange` event.
   */
  ensureListeningToSelectionChange() {
    if (this.selectionChangeDeadline = Date.now() + TTL_FOR_VALID_SELECTION_CHANGE, this.isListening) return;
    this.isListening = !0;
    const Y = () => {
      this.isListening = !1, Date.now() <= this.selectionChangeDeadline && this.handleSelectionChange();
    };
    document.addEventListener("selectionchange", Y, {
      once: !0
    });
  }
  handleSelectionChange() {
    const Y = document.getSelection();
    if (!Y) return;
    const re = Y.getRangeAt(0);
    if (re.collapsed !== !0 || re.startOffset !== 0) return;
    const oe = this.quill.scroll.find(re.startContainer);
    if (!(oe instanceof ParentBlot$1) || !oe.uiNode) return;
    const ue = document.createRange();
    ue.setStartAfter(oe.uiNode), ue.setEndAfter(oe.uiNode), Y.removeAllRanges(), Y.addRange(ue);
  }
}
Quill.register({
  "blots/block": Block,
  "blots/block/embed": BlockEmbed,
  "blots/break": Break,
  "blots/container": Container,
  "blots/cursor": Cursor,
  "blots/embed": Embed,
  "blots/inline": Inline,
  "blots/scroll": Scroll,
  "blots/text": Text$1,
  "modules/clipboard": Clipboard,
  "modules/history": History,
  "modules/keyboard": Keyboard,
  "modules/uploader": Uploader,
  "modules/input": Input,
  "modules/uiNode": UINode
});
class IndentAttributor extends ClassAttributor$1 {
  add(Y, re) {
    let oe = 0;
    if (re === "+1" || re === "-1") {
      const ue = this.value(Y) || 0;
      oe = re === "+1" ? ue + 1 : ue - 1;
    } else typeof re == "number" && (oe = re);
    return oe === 0 ? (this.remove(Y), !0) : super.add(Y, oe.toString());
  }
  canAdd(Y, re) {
    return super.canAdd(Y, re) || super.canAdd(Y, parseInt(re, 10));
  }
  value(Y) {
    return parseInt(super.value(Y), 10) || void 0;
  }
}
const IndentClass = new IndentAttributor("indent", "ql-indent", {
  scope: Scope.BLOCK,
  // @ts-expect-error
  whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
});
class Blockquote extends Block {
  static blotName = "blockquote";
  static tagName = "blockquote";
}
class Header extends Block {
  static blotName = "header";
  static tagName = ["H1", "H2", "H3", "H4", "H5", "H6"];
  static formats(Y) {
    return this.tagName.indexOf(Y.tagName) + 1;
  }
}
class ListContainer extends Container {
}
ListContainer.blotName = "list-container";
ListContainer.tagName = "OL";
class ListItem extends Block {
  static create(Y) {
    const re = super.create();
    return re.setAttribute("data-list", Y), re;
  }
  static formats(Y) {
    return Y.getAttribute("data-list") || void 0;
  }
  static register() {
    Quill.register(ListContainer);
  }
  constructor(Y, re) {
    super(Y, re);
    const oe = re.ownerDocument.createElement("span"), ue = (fe) => {
      if (!Y.isEnabled()) return;
      const he = this.statics.formats(re, Y);
      he === "checked" ? (this.format("list", "unchecked"), fe.preventDefault()) : he === "unchecked" && (this.format("list", "checked"), fe.preventDefault());
    };
    oe.addEventListener("mousedown", ue), oe.addEventListener("touchstart", ue), this.attachUI(oe);
  }
  format(Y, re) {
    Y === this.statics.blotName && re ? this.domNode.setAttribute("data-list", re) : super.format(Y, re);
  }
}
ListItem.blotName = "list";
ListItem.tagName = "LI";
ListContainer.allowedChildren = [ListItem];
ListItem.requiredContainer = ListContainer;
class Bold extends Inline {
  static blotName = "bold";
  static tagName = ["STRONG", "B"];
  static create() {
    return super.create();
  }
  static formats() {
    return !0;
  }
  optimize(Y) {
    super.optimize(Y), this.domNode.tagName !== this.statics.tagName[0] && this.replaceWith(this.statics.blotName);
  }
}
class Italic extends Bold {
  static blotName = "italic";
  static tagName = ["EM", "I"];
}
class Link extends Inline {
  static blotName = "link";
  static tagName = "A";
  static SANITIZED_URL = "about:blank";
  static PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel", "sms"];
  static create(Y) {
    const re = super.create(Y);
    return re.setAttribute("href", this.sanitize(Y)), re.setAttribute("rel", "noopener noreferrer"), re.setAttribute("target", "_blank"), re;
  }
  static formats(Y) {
    return Y.getAttribute("href");
  }
  static sanitize(Y) {
    return sanitize(Y, this.PROTOCOL_WHITELIST) ? Y : this.SANITIZED_URL;
  }
  format(Y, re) {
    Y !== this.statics.blotName || !re ? super.format(Y, re) : this.domNode.setAttribute("href", this.constructor.sanitize(re));
  }
}
function sanitize(le, Y) {
  const re = document.createElement("a");
  re.href = le;
  const oe = re.href.slice(0, re.href.indexOf(":"));
  return Y.indexOf(oe) > -1;
}
class Script extends Inline {
  static blotName = "script";
  static tagName = ["SUB", "SUP"];
  static create(Y) {
    return Y === "super" ? document.createElement("sup") : Y === "sub" ? document.createElement("sub") : super.create(Y);
  }
  static formats(Y) {
    if (Y.tagName === "SUB") return "sub";
    if (Y.tagName === "SUP") return "super";
  }
}
class Strike extends Bold {
  static blotName = "strike";
  static tagName = ["S", "STRIKE"];
}
class Underline extends Inline {
  static blotName = "underline";
  static tagName = "U";
}
class Formula extends Embed {
  static blotName = "formula";
  static className = "ql-formula";
  static tagName = "SPAN";
  static create(Y) {
    if (window.katex == null)
      throw new Error("Formula module requires KaTeX.");
    const re = super.create(Y);
    return typeof Y == "string" && (window.katex.render(Y, re, {
      throwOnError: !1,
      errorColor: "#f00"
    }), re.setAttribute("data-value", Y)), re;
  }
  static value(Y) {
    return Y.getAttribute("data-value");
  }
  html() {
    const {
      formula: Y
    } = this.value();
    return `<span>${Y}</span>`;
  }
}
const ATTRIBUTES$1 = ["alt", "height", "width"];
let Image$1 = class extends EmbedBlot$1 {
  static blotName = "image";
  static tagName = "IMG";
  static create(Y) {
    const re = super.create(Y);
    return typeof Y == "string" && re.setAttribute("src", this.sanitize(Y)), re;
  }
  static formats(Y) {
    return ATTRIBUTES$1.reduce((re, oe) => (Y.hasAttribute(oe) && (re[oe] = Y.getAttribute(oe)), re), {});
  }
  static match(Y) {
    return /\.(jpe?g|gif|png)$/.test(Y) || /^data:image\/.+;base64/.test(Y);
  }
  static sanitize(Y) {
    return sanitize(Y, ["http", "https", "data"]) ? Y : "//:0";
  }
  static value(Y) {
    return Y.getAttribute("src");
  }
  format(Y, re) {
    ATTRIBUTES$1.indexOf(Y) > -1 ? re ? this.domNode.setAttribute(Y, re) : this.domNode.removeAttribute(Y) : super.format(Y, re);
  }
};
const ATTRIBUTES = ["height", "width"];
class Video extends BlockEmbed {
  static blotName = "video";
  static className = "ql-video";
  static tagName = "IFRAME";
  static create(Y) {
    const re = super.create(Y);
    return re.setAttribute("frameborder", "0"), re.setAttribute("allowfullscreen", "true"), re.setAttribute("src", this.sanitize(Y)), re;
  }
  static formats(Y) {
    return ATTRIBUTES.reduce((re, oe) => (Y.hasAttribute(oe) && (re[oe] = Y.getAttribute(oe)), re), {});
  }
  static sanitize(Y) {
    return Link.sanitize(Y);
  }
  static value(Y) {
    return Y.getAttribute("src");
  }
  format(Y, re) {
    ATTRIBUTES.indexOf(Y) > -1 ? re ? this.domNode.setAttribute(Y, re) : this.domNode.removeAttribute(Y) : super.format(Y, re);
  }
  html() {
    const {
      video: Y
    } = this.value();
    return `<a href="${Y}">${Y}</a>`;
  }
}
const TokenAttributor = new ClassAttributor$1("code-token", "hljs", {
  scope: Scope.INLINE
});
class CodeToken extends Inline {
  static formats(Y, re) {
    for (; Y != null && Y !== re.domNode; ) {
      if (Y.classList && Y.classList.contains(CodeBlock.className))
        return super.formats(Y, re);
      Y = Y.parentNode;
    }
  }
  constructor(Y, re, oe) {
    super(Y, re, oe), TokenAttributor.add(this.domNode, oe);
  }
  format(Y, re) {
    Y !== CodeToken.blotName ? super.format(Y, re) : re ? TokenAttributor.add(this.domNode, re) : (TokenAttributor.remove(this.domNode), this.domNode.classList.remove(this.statics.className));
  }
  optimize() {
    super.optimize(...arguments), TokenAttributor.value(this.domNode) || this.unwrap();
  }
}
CodeToken.blotName = "code-token";
CodeToken.className = "ql-token";
class SyntaxCodeBlock extends CodeBlock {
  static create(Y) {
    const re = super.create(Y);
    return typeof Y == "string" && re.setAttribute("data-language", Y), re;
  }
  static formats(Y) {
    return Y.getAttribute("data-language") || "plain";
  }
  static register() {
  }
  // Syntax module will register
  format(Y, re) {
    Y === this.statics.blotName && re ? this.domNode.setAttribute("data-language", re) : super.format(Y, re);
  }
  replaceWith(Y, re) {
    return this.formatAt(0, this.length(), CodeToken.blotName, !1), super.replaceWith(Y, re);
  }
}
class SyntaxCodeBlockContainer extends CodeBlockContainer {
  attach() {
    super.attach(), this.forceNext = !1, this.scroll.emitMount(this);
  }
  format(Y, re) {
    Y === SyntaxCodeBlock.blotName && (this.forceNext = !0, this.children.forEach((oe) => {
      oe.format(Y, re);
    }));
  }
  formatAt(Y, re, oe, ue) {
    oe === SyntaxCodeBlock.blotName && (this.forceNext = !0), super.formatAt(Y, re, oe, ue);
  }
  highlight(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (this.children.head == null) return;
    const ue = `${Array.from(this.domNode.childNodes).filter((he) => he !== this.uiNode).map((he) => he.textContent).join(`
`)}
`, fe = SyntaxCodeBlock.formats(this.children.head.domNode);
    if (re || this.forceNext || this.cachedText !== ue) {
      if (ue.trim().length > 0 || this.cachedText == null) {
        const he = this.children.reduce((ve, xe) => ve.concat(blockDelta(xe, !1)), new Delta()), _e = Y(ue, fe);
        he.diff(_e).reduce((ve, xe) => {
          let {
            retain: Ee,
            attributes: Se
          } = xe;
          return Ee ? (Se && Object.keys(Se).forEach((Te) => {
            [SyntaxCodeBlock.blotName, CodeToken.blotName].includes(Te) && this.formatAt(ve, Ee, Te, Se[Te]);
          }), ve + Ee) : ve;
        }, 0);
      }
      this.cachedText = ue, this.forceNext = !1;
    }
  }
  html(Y, re) {
    const [oe] = this.children.find(Y);
    return `<pre data-language="${oe ? SyntaxCodeBlock.formats(oe.domNode) : "plain"}">
${escapeText(this.code(Y, re))}
</pre>`;
  }
  optimize(Y) {
    if (super.optimize(Y), this.parent != null && this.children.head != null && this.uiNode != null) {
      const re = SyntaxCodeBlock.formats(this.children.head.domNode);
      re !== this.uiNode.value && (this.uiNode.value = re);
    }
  }
}
SyntaxCodeBlockContainer.allowedChildren = [SyntaxCodeBlock];
SyntaxCodeBlock.requiredContainer = SyntaxCodeBlockContainer;
SyntaxCodeBlock.allowedChildren = [CodeToken, Cursor, Text$1, Break];
const highlight = (le, Y, re) => {
  if (typeof le.versionString == "string") {
    const oe = le.versionString.split(".")[0];
    if (parseInt(oe, 10) >= 11)
      return le.highlight(re, {
        language: Y
      }).value;
  }
  return le.highlight(Y, re).value;
};
class Syntax extends Module$1 {
  static register() {
    Quill.register(CodeToken, !0), Quill.register(SyntaxCodeBlock, !0), Quill.register(SyntaxCodeBlockContainer, !0);
  }
  constructor(Y, re) {
    if (super(Y, re), this.options.hljs == null)
      throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
    this.languages = this.options.languages.reduce((oe, ue) => {
      let {
        key: fe
      } = ue;
      return oe[fe] = !0, oe;
    }, {}), this.highlightBlot = this.highlightBlot.bind(this), this.initListener(), this.initTimer();
  }
  initListener() {
    this.quill.on(Quill.events.SCROLL_BLOT_MOUNT, (Y) => {
      if (!(Y instanceof SyntaxCodeBlockContainer)) return;
      const re = this.quill.root.ownerDocument.createElement("select");
      this.options.languages.forEach((oe) => {
        let {
          key: ue,
          label: fe
        } = oe;
        const he = re.ownerDocument.createElement("option");
        he.textContent = fe, he.setAttribute("value", ue), re.appendChild(he);
      }), re.addEventListener("change", () => {
        Y.format(SyntaxCodeBlock.blotName, re.value), this.quill.root.focus(), this.highlight(Y, !0);
      }), Y.uiNode == null && (Y.attachUI(re), Y.children.head && (re.value = SyntaxCodeBlock.formats(Y.children.head.domNode)));
    });
  }
  initTimer() {
    let Y = null;
    this.quill.on(Quill.events.SCROLL_OPTIMIZE, () => {
      Y && clearTimeout(Y), Y = setTimeout(() => {
        this.highlight(), Y = null;
      }, this.options.interval);
    });
  }
  highlight() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (this.quill.selection.composing) return;
    this.quill.update(Quill.sources.USER);
    const oe = this.quill.getSelection();
    (Y == null ? this.quill.scroll.descendants(SyntaxCodeBlockContainer) : [Y]).forEach((fe) => {
      fe.highlight(this.highlightBlot, re);
    }), this.quill.update(Quill.sources.SILENT), oe != null && this.quill.setSelection(oe, Quill.sources.SILENT);
  }
  highlightBlot(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "plain";
    if (re = this.languages[re] ? re : "plain", re === "plain")
      return escapeText(Y).split(`
`).reduce((ue, fe, he) => (he !== 0 && ue.insert(`
`, {
        [CodeBlock.blotName]: re
      }), ue.insert(fe)), new Delta());
    const oe = this.quill.root.ownerDocument.createElement("div");
    return oe.classList.add(CodeBlock.className), oe.innerHTML = highlight(this.options.hljs, re, Y), traverse(this.quill.scroll, oe, [(ue, fe) => {
      const he = TokenAttributor.value(ue);
      return he ? fe.compose(new Delta().retain(fe.length(), {
        [CodeToken.blotName]: he
      })) : fe;
    }], [(ue, fe) => ue.data.split(`
`).reduce((he, _e, ve) => (ve !== 0 && he.insert(`
`, {
      [CodeBlock.blotName]: re
    }), he.insert(_e)), fe)], /* @__PURE__ */ new WeakMap());
  }
}
Syntax.DEFAULTS = {
  hljs: window.hljs,
  interval: 1e3,
  languages: [{
    key: "plain",
    label: "Plain"
  }, {
    key: "bash",
    label: "Bash"
  }, {
    key: "cpp",
    label: "C++"
  }, {
    key: "cs",
    label: "C#"
  }, {
    key: "css",
    label: "CSS"
  }, {
    key: "diff",
    label: "Diff"
  }, {
    key: "xml",
    label: "HTML/XML"
  }, {
    key: "java",
    label: "Java"
  }, {
    key: "javascript",
    label: "JavaScript"
  }, {
    key: "markdown",
    label: "Markdown"
  }, {
    key: "php",
    label: "PHP"
  }, {
    key: "python",
    label: "Python"
  }, {
    key: "ruby",
    label: "Ruby"
  }, {
    key: "sql",
    label: "SQL"
  }]
};
class TableCell extends Block {
  static blotName = "table";
  static tagName = "TD";
  static create(Y) {
    const re = super.create();
    return Y ? re.setAttribute("data-row", Y) : re.setAttribute("data-row", tableId()), re;
  }
  static formats(Y) {
    if (Y.hasAttribute("data-row"))
      return Y.getAttribute("data-row");
  }
  cellOffset() {
    return this.parent ? this.parent.children.indexOf(this) : -1;
  }
  format(Y, re) {
    Y === TableCell.blotName && re ? this.domNode.setAttribute("data-row", re) : super.format(Y, re);
  }
  row() {
    return this.parent;
  }
  rowOffset() {
    return this.row() ? this.row().rowOffset() : -1;
  }
  table() {
    return this.row() && this.row().table();
  }
}
class TableRow extends Container {
  static blotName = "table-row";
  static tagName = "TR";
  checkMerge() {
    if (super.checkMerge() && this.next.children.head != null) {
      const Y = this.children.head.formats(), re = this.children.tail.formats(), oe = this.next.children.head.formats(), ue = this.next.children.tail.formats();
      return Y.table === re.table && Y.table === oe.table && Y.table === ue.table;
    }
    return !1;
  }
  optimize(Y) {
    super.optimize(Y), this.children.forEach((re) => {
      if (re.next == null) return;
      const oe = re.formats(), ue = re.next.formats();
      if (oe.table !== ue.table) {
        const fe = this.splitAfter(re);
        fe && fe.optimize(), this.prev && this.prev.optimize();
      }
    });
  }
  rowOffset() {
    return this.parent ? this.parent.children.indexOf(this) : -1;
  }
  table() {
    return this.parent && this.parent.parent;
  }
}
class TableBody extends Container {
  static blotName = "table-body";
  static tagName = "TBODY";
}
class TableContainer extends Container {
  static blotName = "table-container";
  static tagName = "TABLE";
  balanceCells() {
    const Y = this.descendants(TableRow), re = Y.reduce((oe, ue) => Math.max(ue.children.length, oe), 0);
    Y.forEach((oe) => {
      new Array(re - oe.children.length).fill(0).forEach(() => {
        let ue;
        oe.children.head != null && (ue = TableCell.formats(oe.children.head.domNode));
        const fe = this.scroll.create(TableCell.blotName, ue);
        oe.appendChild(fe), fe.optimize();
      });
    });
  }
  cells(Y) {
    return this.rows().map((re) => re.children.at(Y));
  }
  deleteColumn(Y) {
    const [re] = this.descendant(TableBody);
    re == null || re.children.head == null || re.children.forEach((oe) => {
      const ue = oe.children.at(Y);
      ue?.remove();
    });
  }
  insertColumn(Y) {
    const [re] = this.descendant(TableBody);
    re == null || re.children.head == null || re.children.forEach((oe) => {
      const ue = oe.children.at(Y), fe = TableCell.formats(oe.children.head.domNode), he = this.scroll.create(TableCell.blotName, fe);
      oe.insertBefore(he, ue);
    });
  }
  insertRow(Y) {
    const [re] = this.descendant(TableBody);
    if (re == null || re.children.head == null) return;
    const oe = tableId(), ue = this.scroll.create(TableRow.blotName);
    re.children.head.children.forEach(() => {
      const he = this.scroll.create(TableCell.blotName, oe);
      ue.appendChild(he);
    });
    const fe = re.children.at(Y);
    re.insertBefore(ue, fe);
  }
  rows() {
    const Y = this.children.head;
    return Y == null ? [] : Y.children.map((re) => re);
  }
}
TableContainer.allowedChildren = [TableBody];
TableBody.requiredContainer = TableContainer;
TableBody.allowedChildren = [TableRow];
TableRow.requiredContainer = TableBody;
TableRow.allowedChildren = [TableCell];
TableCell.requiredContainer = TableRow;
function tableId() {
  return `row-${Math.random().toString(36).slice(2, 6)}`;
}
class Table extends Module$1 {
  static register() {
    Quill.register(TableCell), Quill.register(TableRow), Quill.register(TableBody), Quill.register(TableContainer);
  }
  constructor() {
    super(...arguments), this.listenBalanceCells();
  }
  balanceTables() {
    this.quill.scroll.descendants(TableContainer).forEach((Y) => {
      Y.balanceCells();
    });
  }
  deleteColumn() {
    const [Y, , re] = this.getTable();
    re != null && (Y.deleteColumn(re.cellOffset()), this.quill.update(Quill.sources.USER));
  }
  deleteRow() {
    const [, Y] = this.getTable();
    Y != null && (Y.remove(), this.quill.update(Quill.sources.USER));
  }
  deleteTable() {
    const [Y] = this.getTable();
    if (Y == null) return;
    const re = Y.offset();
    Y.remove(), this.quill.update(Quill.sources.USER), this.quill.setSelection(re, Quill.sources.SILENT);
  }
  getTable() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.quill.getSelection();
    if (Y == null) return [null, null, null, -1];
    const [re, oe] = this.quill.getLine(Y.index);
    if (re == null || re.statics.blotName !== TableCell.blotName)
      return [null, null, null, -1];
    const ue = re.parent;
    return [ue.parent.parent, ue, re, oe];
  }
  insertColumn(Y) {
    const re = this.quill.getSelection();
    if (!re) return;
    const [oe, ue, fe] = this.getTable(re);
    if (fe == null) return;
    const he = fe.cellOffset();
    oe.insertColumn(he + Y), this.quill.update(Quill.sources.USER);
    let _e = ue.rowOffset();
    Y === 0 && (_e += 1), this.quill.setSelection(re.index + _e, re.length, Quill.sources.SILENT);
  }
  insertColumnLeft() {
    this.insertColumn(0);
  }
  insertColumnRight() {
    this.insertColumn(1);
  }
  insertRow(Y) {
    const re = this.quill.getSelection();
    if (!re) return;
    const [oe, ue, fe] = this.getTable(re);
    if (fe == null) return;
    const he = ue.rowOffset();
    oe.insertRow(he + Y), this.quill.update(Quill.sources.USER), Y > 0 ? this.quill.setSelection(re, Quill.sources.SILENT) : this.quill.setSelection(re.index + ue.children.length, re.length, Quill.sources.SILENT);
  }
  insertRowAbove() {
    this.insertRow(0);
  }
  insertRowBelow() {
    this.insertRow(1);
  }
  insertTable(Y, re) {
    const oe = this.quill.getSelection();
    if (oe == null) return;
    const ue = new Array(Y).fill(0).reduce((fe) => {
      const he = new Array(re).fill(`
`).join("");
      return fe.insert(he, {
        table: tableId()
      });
    }, new Delta().retain(oe.index));
    this.quill.updateContents(ue, Quill.sources.USER), this.quill.setSelection(oe.index, Quill.sources.SILENT), this.balanceTables();
  }
  listenBalanceCells() {
    this.quill.on(Quill.events.SCROLL_OPTIMIZE, (Y) => {
      Y.some((re) => ["TD", "TR", "TBODY", "TABLE"].includes(re.target.tagName) ? (this.quill.once(Quill.events.TEXT_CHANGE, (oe, ue, fe) => {
        fe === Quill.sources.USER && this.balanceTables();
      }), !0) : !1);
    });
  }
}
const debug = namespace("quill:toolbar");
class Toolbar extends Module$1 {
  constructor(Y, re) {
    if (super(Y, re), Array.isArray(this.options.container)) {
      const oe = document.createElement("div");
      oe.setAttribute("role", "toolbar"), addControls(oe, this.options.container), Y.container?.parentNode?.insertBefore(oe, Y.container), this.container = oe;
    } else typeof this.options.container == "string" ? this.container = document.querySelector(this.options.container) : this.container = this.options.container;
    if (!(this.container instanceof HTMLElement)) {
      debug.error("Container required for toolbar", this.options);
      return;
    }
    this.container.classList.add("ql-toolbar"), this.controls = [], this.handlers = {}, this.options.handlers && Object.keys(this.options.handlers).forEach((oe) => {
      const ue = this.options.handlers?.[oe];
      ue && this.addHandler(oe, ue);
    }), Array.from(this.container.querySelectorAll("button, select")).forEach((oe) => {
      this.attach(oe);
    }), this.quill.on(Quill.events.EDITOR_CHANGE, () => {
      const [oe] = this.quill.selection.getRange();
      this.update(oe);
    });
  }
  addHandler(Y, re) {
    this.handlers[Y] = re;
  }
  attach(Y) {
    let re = Array.from(Y.classList).find((ue) => ue.indexOf("ql-") === 0);
    if (!re) return;
    if (re = re.slice(3), Y.tagName === "BUTTON" && Y.setAttribute("type", "button"), this.handlers[re] == null && this.quill.scroll.query(re) == null) {
      debug.warn("ignoring attaching to nonexistent format", re, Y);
      return;
    }
    const oe = Y.tagName === "SELECT" ? "change" : "click";
    Y.addEventListener(oe, (ue) => {
      let fe;
      if (Y.tagName === "SELECT") {
        if (Y.selectedIndex < 0) return;
        const _e = Y.options[Y.selectedIndex];
        _e.hasAttribute("selected") ? fe = !1 : fe = _e.value || !1;
      } else
        Y.classList.contains("ql-active") ? fe = !1 : fe = Y.value || !Y.hasAttribute("value"), ue.preventDefault();
      this.quill.focus();
      const [he] = this.quill.selection.getRange();
      if (this.handlers[re] != null)
        this.handlers[re].call(this, fe);
      else if (
        // @ts-expect-error
        this.quill.scroll.query(re).prototype instanceof EmbedBlot$1
      ) {
        if (fe = prompt(`Enter ${re}`), !fe) return;
        this.quill.updateContents(new Delta().retain(he.index).delete(he.length).insert({
          [re]: fe
        }), Quill.sources.USER);
      } else
        this.quill.format(re, fe, Quill.sources.USER);
      this.update(he);
    }), this.controls.push([re, Y]);
  }
  update(Y) {
    const re = Y == null ? {} : this.quill.getFormat(Y);
    this.controls.forEach((oe) => {
      const [ue, fe] = oe;
      if (fe.tagName === "SELECT") {
        let he = null;
        if (Y == null)
          he = null;
        else if (re[ue] == null)
          he = fe.querySelector("option[selected]");
        else if (!Array.isArray(re[ue])) {
          let _e = re[ue];
          typeof _e == "string" && (_e = _e.replace(/"/g, '\\"')), he = fe.querySelector(`option[value="${_e}"]`);
        }
        he == null ? (fe.value = "", fe.selectedIndex = -1) : he.selected = !0;
      } else if (Y == null)
        fe.classList.remove("ql-active"), fe.setAttribute("aria-pressed", "false");
      else if (fe.hasAttribute("value")) {
        const he = re[ue], _e = he === fe.getAttribute("value") || he != null && he.toString() === fe.getAttribute("value") || he == null && !fe.getAttribute("value");
        fe.classList.toggle("ql-active", _e), fe.setAttribute("aria-pressed", _e.toString());
      } else {
        const he = re[ue] != null;
        fe.classList.toggle("ql-active", he), fe.setAttribute("aria-pressed", he.toString());
      }
    });
  }
}
Toolbar.DEFAULTS = {};
function addButton(le, Y, re) {
  const oe = document.createElement("button");
  oe.setAttribute("type", "button"), oe.classList.add(`ql-${Y}`), oe.setAttribute("aria-pressed", "false"), re != null ? (oe.value = re, oe.setAttribute("aria-label", `${Y}: ${re}`)) : oe.setAttribute("aria-label", Y), le.appendChild(oe);
}
function addControls(le, Y) {
  Array.isArray(Y[0]) || (Y = [Y]), Y.forEach((re) => {
    const oe = document.createElement("span");
    oe.classList.add("ql-formats"), re.forEach((ue) => {
      if (typeof ue == "string")
        addButton(oe, ue);
      else {
        const fe = Object.keys(ue)[0], he = ue[fe];
        Array.isArray(he) ? addSelect(oe, fe, he) : addButton(oe, fe, he);
      }
    }), le.appendChild(oe);
  });
}
function addSelect(le, Y, re) {
  const oe = document.createElement("select");
  oe.classList.add(`ql-${Y}`), re.forEach((ue) => {
    const fe = document.createElement("option");
    ue !== !1 ? fe.setAttribute("value", String(ue)) : fe.setAttribute("selected", "selected"), oe.appendChild(fe);
  }), le.appendChild(oe);
}
Toolbar.DEFAULTS = {
  container: null,
  handlers: {
    clean() {
      const le = this.quill.getSelection();
      if (le != null)
        if (le.length === 0) {
          const Y = this.quill.getFormat();
          Object.keys(Y).forEach((re) => {
            this.quill.scroll.query(re, Scope.INLINE) != null && this.quill.format(re, !1, Quill.sources.USER);
          });
        } else
          this.quill.removeFormat(le.index, le.length, Quill.sources.USER);
    },
    direction(le) {
      const {
        align: Y
      } = this.quill.getFormat();
      le === "rtl" && Y == null ? this.quill.format("align", "right", Quill.sources.USER) : !le && Y === "right" && this.quill.format("align", !1, Quill.sources.USER), this.quill.format("direction", le, Quill.sources.USER);
    },
    indent(le) {
      const Y = this.quill.getSelection(), re = this.quill.getFormat(Y), oe = parseInt(re.indent || 0, 10);
      if (le === "+1" || le === "-1") {
        let ue = le === "+1" ? 1 : -1;
        re.direction === "rtl" && (ue *= -1), this.quill.format("indent", oe + ue, Quill.sources.USER);
      }
    },
    link(le) {
      le === !0 && (le = prompt("Enter link URL:")), this.quill.format("link", le, Quill.sources.USER);
    },
    list(le) {
      const Y = this.quill.getSelection(), re = this.quill.getFormat(Y);
      le === "check" ? re.list === "checked" || re.list === "unchecked" ? this.quill.format("list", !1, Quill.sources.USER) : this.quill.format("list", "unchecked", Quill.sources.USER) : this.quill.format("list", le, Quill.sources.USER);
    }
  }
};
const alignLeftIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="13" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="9" y1="4" y2="4"/></svg>', alignCenterIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="14" x2="4" y1="14" y2="14"/><line class="ql-stroke" x1="12" x2="6" y1="4" y2="4"/></svg>', alignRightIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="5" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="9" y1="4" y2="4"/></svg>', alignJustifyIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="3" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="3" y1="4" y2="4"/></svg>', backgroundIcon = '<svg viewbox="0 0 18 18"><g class="ql-fill ql-color-label"><polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"/><rect height="1" width="1" x="4" y="4"/><polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"/><rect height="1" width="1" x="2" y="6"/><rect height="1" width="1" x="3" y="5"/><rect height="1" width="1" x="4" y="7"/><polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"/><rect height="1" width="1" x="2" y="12"/><rect height="1" width="1" x="2" y="9"/><rect height="1" width="1" x="2" y="15"/><polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"/><rect height="1" width="1" x="3" y="8"/><path d="M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z"/><path d="M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z"/><path d="M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z"/><rect height="1" width="1" x="12" y="2"/><rect height="1" width="1" x="11" y="3"/><path d="M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z"/><rect height="1" width="1" x="2" y="3"/><rect height="1" width="1" x="6" y="2"/><rect height="1" width="1" x="3" y="2"/><rect height="1" width="1" x="5" y="3"/><rect height="1" width="1" x="9" y="2"/><rect height="1" width="1" x="15" y="14"/><polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"/><rect height="1" width="1" x="13" y="7"/><rect height="1" width="1" x="15" y="5"/><rect height="1" width="1" x="14" y="6"/><rect height="1" width="1" x="15" y="8"/><rect height="1" width="1" x="14" y="9"/><path d="M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z"/><rect height="1" width="1" x="14" y="3"/><polygon points="12 6.868 12 6 11.62 6 12 6.868"/><rect height="1" width="1" x="15" y="2"/><rect height="1" width="1" x="12" y="5"/><rect height="1" width="1" x="13" y="4"/><polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"/><rect height="1" width="1" x="9" y="14"/><rect height="1" width="1" x="8" y="15"/><path d="M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z"/><rect height="1" width="1" x="5" y="15"/><path d="M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z"/><rect height="1" width="1" x="11" y="15"/><path d="M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z"/><rect height="1" width="1" x="14" y="15"/><rect height="1" width="1" x="15" y="11"/></g><polyline class="ql-stroke" points="5.5 13 9 5 12.5 13"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="11" y2="11"/></svg>', blockquoteIcon = '<svg viewbox="0 0 18 18"><rect class="ql-fill ql-stroke" height="3" width="3" x="4" y="5"/><rect class="ql-fill ql-stroke" height="3" width="3" x="11" y="5"/><path class="ql-even ql-fill ql-stroke" d="M7,8c0,4.031-3,5-3,5"/><path class="ql-even ql-fill ql-stroke" d="M14,8c0,4.031-3,5-3,5"/></svg>', boldIcon = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z"/><path class="ql-stroke" d="M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z"/></svg>', cleanIcon = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="5" x2="13" y1="3" y2="3"/><line class="ql-stroke" x1="6" x2="9.35" y1="12" y2="3"/><line class="ql-stroke" x1="11" x2="15" y1="11" y2="15"/><line class="ql-stroke" x1="15" x2="11" y1="11" y2="15"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="7" x="2" y="14"/></svg>', codeIcon = '<svg viewbox="0 0 18 18"><polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"/><polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"/><line class="ql-stroke" x1="10" x2="8" y1="5" y2="13"/></svg>', colorIcon = '<svg viewbox="0 0 18 18"><line class="ql-color-label ql-stroke ql-transparent" x1="3" x2="15" y1="15" y2="15"/><polyline class="ql-stroke" points="5.5 11 9 3 12.5 11"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="9" y2="9"/></svg>', directionLeftToRightIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"/><line class="ql-stroke ql-fill" x1="15" x2="11" y1="4" y2="4"/><path class="ql-fill" d="M11,3a3,3,0,0,0,0,6h1V3H11Z"/><rect class="ql-fill" height="11" width="1" x="11" y="4"/><rect class="ql-fill" height="11" width="1" x="13" y="4"/></svg>', directionRightToLeftIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"/><line class="ql-stroke ql-fill" x1="9" x2="5" y1="4" y2="4"/><path class="ql-fill" d="M5,3A3,3,0,0,0,5,9H6V3H5Z"/><rect class="ql-fill" height="11" width="1" x="5" y="4"/><rect class="ql-fill" height="11" width="1" x="7" y="4"/></svg>', formulaIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z"/><rect class="ql-fill" height="1.6" rx="0.8" ry="0.8" width="5" x="5.15" y="6.2"/><path class="ql-fill" d="M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z"/></svg>', headerIcon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z"/></svg>', header2Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>', header3Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.65186,12.30664a2.6742,2.6742,0,0,1-2.915,2.68457,3.96592,3.96592,0,0,1-2.25537-.6709.56007.56007,0,0,1-.13232-.83594L11.64648,13c.209-.34082.48389-.36328.82471-.1543a2.32654,2.32654,0,0,0,1.12256.33008c.71484,0,1.12207-.35156,1.12207-.78125,0-.61523-.61621-.86816-1.46338-.86816H13.2085a.65159.65159,0,0,1-.68213-.41895l-.05518-.10937a.67114.67114,0,0,1,.14307-.78125l.71533-.86914a8.55289,8.55289,0,0,1,.68213-.7373V8.58887a3.93913,3.93913,0,0,1-.748.05469H11.9873a.54085.54085,0,0,1-.605-.60547V7.59863a.54085.54085,0,0,1,.605-.60547h3.75146a.53773.53773,0,0,1,.60547.59375v.17676a1.03723,1.03723,0,0,1-.27539.748L14.74854,10.0293A2.31132,2.31132,0,0,1,16.65186,12.30664ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>', header4Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm7.05371,7.96582v.38477c0,.39648-.165.60547-.46191.60547h-.47314v1.29785a.54085.54085,0,0,1-.605.60547h-.69336a.54085.54085,0,0,1-.605-.60547V12.95605H11.333a.5412.5412,0,0,1-.60547-.60547v-.15332a1.199,1.199,0,0,1,.22021-.748l2.56348-4.05957a.7819.7819,0,0,1,.72607-.39648h1.27637a.54085.54085,0,0,1,.605.60547v3.7627h.33008A.54055.54055,0,0,1,17.05371,11.96582ZM14.28125,8.7207h-.022a4.18969,4.18969,0,0,1-.38525.81348l-1.188,1.80469v.02246h1.5293V9.60059A7.04058,7.04058,0,0,1,14.28125,8.7207Z"/></svg>', header5Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.74023,12.18555a2.75131,2.75131,0,0,1-2.91553,2.80566,3.908,3.908,0,0,1-2.25537-.68164.54809.54809,0,0,1-.13184-.8252L11.73438,13c.209-.34082.48389-.36328.8252-.1543a2.23757,2.23757,0,0,0,1.1001.33008,1.01827,1.01827,0,0,0,1.1001-.96777c0-.61621-.53906-.97949-1.25439-.97949a2.15554,2.15554,0,0,0-.64893.09961,1.15209,1.15209,0,0,1-.814.01074l-.12109-.04395a.64116.64116,0,0,1-.45117-.71484l.231-3.00391a.56666.56666,0,0,1,.62744-.583H15.541a.54085.54085,0,0,1,.605.60547v.43945a.54085.54085,0,0,1-.605.60547H13.41748l-.04395.72559a1.29306,1.29306,0,0,1-.04395.30859h.022a2.39776,2.39776,0,0,1,.57227-.07715A2.53266,2.53266,0,0,1,16.74023,12.18555ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>', header6Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M14.51758,9.64453a1.85627,1.85627,0,0,0-1.24316.38477H13.252a1.73532,1.73532,0,0,1,1.72754-1.4082,2.66491,2.66491,0,0,1,.5498.06641c.35254.05469.57227.01074.70508-.40723l.16406-.5166a.53393.53393,0,0,0-.373-.75977,4.83723,4.83723,0,0,0-1.17773-.14258c-2.43164,0-3.7627,2.17773-3.7627,4.43359,0,2.47559,1.60645,3.69629,3.19043,3.69629A2.70585,2.70585,0,0,0,16.96,12.19727,2.43861,2.43861,0,0,0,14.51758,9.64453Zm-.23047,3.58691c-.67187,0-1.22168-.81445-1.22168-1.45215,0-.47363.30762-.583.72559-.583.96875,0,1.27734.59375,1.27734,1.12207A.82182.82182,0,0,1,14.28711,13.23145ZM10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Z"/></svg>', italicIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="13" y1="4" y2="4"/><line class="ql-stroke" x1="5" x2="11" y1="14" y2="14"/><line class="ql-stroke" x1="8" x2="10" y1="14" y2="4"/></svg>', imageIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="10" width="12" x="3" y="4"/><circle class="ql-fill" cx="6" cy="7" r="1"/><polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"/></svg>', indentIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"/></svg>', outdentIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="5 7 5 11 3 9 5 7"/></svg>', linkIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="11" y1="7" y2="11"/><path class="ql-even ql-stroke" d="M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z"/><path class="ql-even ql-stroke" d="M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z"/></svg>', listBulletIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="6" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="6" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="6" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="3" y1="4" y2="4"/><line class="ql-stroke" x1="3" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="3" y1="14" y2="14"/></svg>', listCheckIcon = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="9" x2="15" y1="4" y2="4"/><polyline class="ql-stroke" points="3 4 4 5 6 3"/><line class="ql-stroke" x1="9" x2="15" y1="14" y2="14"/><polyline class="ql-stroke" points="3 14 4 15 6 13"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="3 9 4 10 6 8"/></svg>', listOrderedIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="7" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="7" x2="15" y1="14" y2="14"/><line class="ql-stroke ql-thin" x1="2.5" x2="4.5" y1="5.5" y2="5.5"/><path class="ql-fill" d="M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z"/><path class="ql-stroke ql-thin" d="M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156"/><path class="ql-stroke ql-thin" d="M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109"/></svg>', subscriptIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z"/><path class="ql-fill" d="M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z"/></svg>', superscriptIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z"/><path class="ql-fill" d="M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z"/></svg>', strikeIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke ql-thin" x1="15.5" x2="2.5" y1="8.5" y2="9.5"/><path class="ql-fill" d="M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z"/><path class="ql-fill" d="M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z"/></svg>', tableIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="2" width="3" x="5" y="5"/><rect class="ql-fill" height="2" width="4" x="9" y="5"/><g class="ql-fill ql-transparent"><rect height="2" width="3" x="5" y="8"/><rect height="2" width="4" x="9" y="8"/><rect height="2" width="3" x="5" y="11"/><rect height="2" width="4" x="9" y="11"/></g></svg>', underlineIcon = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="12" x="3" y="15"/></svg>', videoIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="12" width="1" x="5" y="3"/><rect class="ql-fill" height="12" width="1" x="12" y="3"/><rect class="ql-fill" height="2" width="8" x="5" y="8"/><rect class="ql-fill" height="1" width="3" x="3" y="5"/><rect class="ql-fill" height="1" width="3" x="3" y="7"/><rect class="ql-fill" height="1" width="3" x="3" y="10"/><rect class="ql-fill" height="1" width="3" x="3" y="12"/><rect class="ql-fill" height="1" width="3" x="12" y="5"/><rect class="ql-fill" height="1" width="3" x="12" y="7"/><rect class="ql-fill" height="1" width="3" x="12" y="10"/><rect class="ql-fill" height="1" width="3" x="12" y="12"/></svg>', Icons = {
  align: {
    "": alignLeftIcon,
    center: alignCenterIcon,
    right: alignRightIcon,
    justify: alignJustifyIcon
  },
  background: backgroundIcon,
  blockquote: blockquoteIcon,
  bold: boldIcon,
  clean: cleanIcon,
  code: codeIcon,
  "code-block": codeIcon,
  color: colorIcon,
  direction: {
    "": directionLeftToRightIcon,
    rtl: directionRightToLeftIcon
  },
  formula: formulaIcon,
  header: {
    1: headerIcon,
    2: header2Icon,
    3: header3Icon,
    4: header4Icon,
    5: header5Icon,
    6: header6Icon
  },
  italic: italicIcon,
  image: imageIcon,
  indent: {
    "+1": indentIcon,
    "-1": outdentIcon
  },
  link: linkIcon,
  list: {
    bullet: listBulletIcon,
    check: listCheckIcon,
    ordered: listOrderedIcon
  },
  script: {
    sub: subscriptIcon,
    super: superscriptIcon
  },
  strike: strikeIcon,
  table: tableIcon,
  underline: underlineIcon,
  video: videoIcon
}, DropdownIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke" points="7 11 9 13 11 11 7 11"/><polygon class="ql-stroke" points="7 7 9 5 11 7 7 7"/></svg>';
let optionsCounter = 0;
function toggleAriaAttribute(le, Y) {
  le.setAttribute(Y, `${le.getAttribute(Y) !== "true"}`);
}
class Picker {
  constructor(Y) {
    this.select = Y, this.container = document.createElement("span"), this.buildPicker(), this.select.style.display = "none", this.select.parentNode.insertBefore(this.container, this.select), this.label.addEventListener("mousedown", () => {
      this.togglePicker();
    }), this.label.addEventListener("keydown", (re) => {
      switch (re.key) {
        case "Enter":
          this.togglePicker();
          break;
        case "Escape":
          this.escape(), re.preventDefault();
          break;
      }
    }), this.select.addEventListener("change", this.update.bind(this));
  }
  togglePicker() {
    this.container.classList.toggle("ql-expanded"), toggleAriaAttribute(this.label, "aria-expanded"), toggleAriaAttribute(this.options, "aria-hidden");
  }
  buildItem(Y) {
    const re = document.createElement("span");
    re.tabIndex = "0", re.setAttribute("role", "button"), re.classList.add("ql-picker-item");
    const oe = Y.getAttribute("value");
    return oe && re.setAttribute("data-value", oe), Y.textContent && re.setAttribute("data-label", Y.textContent), re.addEventListener("click", () => {
      this.selectItem(re, !0);
    }), re.addEventListener("keydown", (ue) => {
      switch (ue.key) {
        case "Enter":
          this.selectItem(re, !0), ue.preventDefault();
          break;
        case "Escape":
          this.escape(), ue.preventDefault();
          break;
      }
    }), re;
  }
  buildLabel() {
    const Y = document.createElement("span");
    return Y.classList.add("ql-picker-label"), Y.innerHTML = DropdownIcon, Y.tabIndex = "0", Y.setAttribute("role", "button"), Y.setAttribute("aria-expanded", "false"), this.container.appendChild(Y), Y;
  }
  buildOptions() {
    const Y = document.createElement("span");
    Y.classList.add("ql-picker-options"), Y.setAttribute("aria-hidden", "true"), Y.tabIndex = "-1", Y.id = `ql-picker-options-${optionsCounter}`, optionsCounter += 1, this.label.setAttribute("aria-controls", Y.id), this.options = Y, Array.from(this.select.options).forEach((re) => {
      const oe = this.buildItem(re);
      Y.appendChild(oe), re.selected === !0 && this.selectItem(oe);
    }), this.container.appendChild(Y);
  }
  buildPicker() {
    Array.from(this.select.attributes).forEach((Y) => {
      this.container.setAttribute(Y.name, Y.value);
    }), this.container.classList.add("ql-picker"), this.label = this.buildLabel(), this.buildOptions();
  }
  escape() {
    this.close(), setTimeout(() => this.label.focus(), 1);
  }
  close() {
    this.container.classList.remove("ql-expanded"), this.label.setAttribute("aria-expanded", "false"), this.options.setAttribute("aria-hidden", "true");
  }
  selectItem(Y) {
    let re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const oe = this.container.querySelector(".ql-selected");
    Y !== oe && (oe?.classList.remove("ql-selected"), Y != null && (Y.classList.add("ql-selected"), this.select.selectedIndex = Array.from(Y.parentNode.children).indexOf(Y), Y.hasAttribute("data-value") ? this.label.setAttribute("data-value", Y.getAttribute("data-value")) : this.label.removeAttribute("data-value"), Y.hasAttribute("data-label") ? this.label.setAttribute("data-label", Y.getAttribute("data-label")) : this.label.removeAttribute("data-label"), re && (this.select.dispatchEvent(new Event("change")), this.close())));
  }
  update() {
    let Y;
    if (this.select.selectedIndex > -1) {
      const oe = (
        // @ts-expect-error Fix me later
        this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex]
      );
      Y = this.select.options[this.select.selectedIndex], this.selectItem(oe);
    } else
      this.selectItem(null);
    const re = Y != null && Y !== this.select.querySelector("option[selected]");
    this.label.classList.toggle("ql-active", re);
  }
}
class ColorPicker extends Picker {
  constructor(Y, re) {
    super(Y), this.label.innerHTML = re, this.container.classList.add("ql-color-picker"), Array.from(this.container.querySelectorAll(".ql-picker-item")).slice(0, 7).forEach((oe) => {
      oe.classList.add("ql-primary");
    });
  }
  buildItem(Y) {
    const re = super.buildItem(Y);
    return re.style.backgroundColor = Y.getAttribute("value") || "", re;
  }
  selectItem(Y, re) {
    super.selectItem(Y, re);
    const oe = this.label.querySelector(".ql-color-label"), ue = Y && Y.getAttribute("data-value") || "";
    oe && (oe.tagName === "line" ? oe.style.stroke = ue : oe.style.fill = ue);
  }
}
class IconPicker extends Picker {
  constructor(Y, re) {
    super(Y), this.container.classList.add("ql-icon-picker"), Array.from(this.container.querySelectorAll(".ql-picker-item")).forEach((oe) => {
      oe.innerHTML = re[oe.getAttribute("data-value") || ""];
    }), this.defaultItem = this.container.querySelector(".ql-selected"), this.selectItem(this.defaultItem);
  }
  selectItem(Y, re) {
    super.selectItem(Y, re);
    const oe = Y || this.defaultItem;
    if (oe != null) {
      if (this.label.innerHTML === oe.innerHTML) return;
      this.label.innerHTML = oe.innerHTML;
    }
  }
}
const isScrollable = (le) => {
  const {
    overflowY: Y
  } = getComputedStyle(le, null);
  return Y !== "visible" && Y !== "clip";
};
class Tooltip {
  constructor(Y, re) {
    this.quill = Y, this.boundsContainer = re || document.body, this.root = Y.addContainer("ql-tooltip"), this.root.innerHTML = this.constructor.TEMPLATE, isScrollable(this.quill.root) && this.quill.root.addEventListener("scroll", () => {
      this.root.style.marginTop = `${-1 * this.quill.root.scrollTop}px`;
    }), this.hide();
  }
  hide() {
    this.root.classList.add("ql-hidden");
  }
  position(Y) {
    const re = Y.left + Y.width / 2 - this.root.offsetWidth / 2, oe = Y.bottom + this.quill.root.scrollTop;
    this.root.style.left = `${re}px`, this.root.style.top = `${oe}px`, this.root.classList.remove("ql-flip");
    const ue = this.boundsContainer.getBoundingClientRect(), fe = this.root.getBoundingClientRect();
    let he = 0;
    if (fe.right > ue.right && (he = ue.right - fe.right, this.root.style.left = `${re + he}px`), fe.left < ue.left && (he = ue.left - fe.left, this.root.style.left = `${re + he}px`), fe.bottom > ue.bottom) {
      const _e = fe.bottom - fe.top, ve = Y.bottom - Y.top + _e;
      this.root.style.top = `${oe - ve}px`, this.root.classList.add("ql-flip");
    }
    return he;
  }
  show() {
    this.root.classList.remove("ql-editing"), this.root.classList.remove("ql-hidden");
  }
}
const ALIGNS = [!1, "center", "right", "justify"], COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"], FONTS = [!1, "serif", "monospace"], HEADERS = ["1", "2", "3", !1], SIZES = ["small", !1, "large", "huge"];
class BaseTheme extends Theme {
  constructor(Y, re) {
    super(Y, re);
    const oe = (ue) => {
      if (!document.body.contains(Y.root)) {
        document.body.removeEventListener("click", oe);
        return;
      }
      this.tooltip != null && // @ts-expect-error
      !this.tooltip.root.contains(ue.target) && // @ts-expect-error
      document.activeElement !== this.tooltip.textbox && !this.quill.hasFocus() && this.tooltip.hide(), this.pickers != null && this.pickers.forEach((fe) => {
        fe.container.contains(ue.target) || fe.close();
      });
    };
    Y.emitter.listenDOM("click", document.body, oe);
  }
  addModule(Y) {
    const re = super.addModule(Y);
    return Y === "toolbar" && this.extendToolbar(re), re;
  }
  buildButtons(Y, re) {
    Array.from(Y).forEach((oe) => {
      (oe.getAttribute("class") || "").split(/\s+/).forEach((fe) => {
        if (fe.startsWith("ql-") && (fe = fe.slice(3), re[fe] != null))
          if (fe === "direction")
            oe.innerHTML = re[fe][""] + re[fe].rtl;
          else if (typeof re[fe] == "string")
            oe.innerHTML = re[fe];
          else {
            const he = oe.value || "";
            he != null && re[fe][he] && (oe.innerHTML = re[fe][he]);
          }
      });
    });
  }
  buildPickers(Y, re) {
    this.pickers = Array.from(Y).map((ue) => {
      if (ue.classList.contains("ql-align") && (ue.querySelector("option") == null && fillSelect(ue, ALIGNS), typeof re.align == "object"))
        return new IconPicker(ue, re.align);
      if (ue.classList.contains("ql-background") || ue.classList.contains("ql-color")) {
        const fe = ue.classList.contains("ql-background") ? "background" : "color";
        return ue.querySelector("option") == null && fillSelect(ue, COLORS, fe === "background" ? "#ffffff" : "#000000"), new ColorPicker(ue, re[fe]);
      }
      return ue.querySelector("option") == null && (ue.classList.contains("ql-font") ? fillSelect(ue, FONTS) : ue.classList.contains("ql-header") ? fillSelect(ue, HEADERS) : ue.classList.contains("ql-size") && fillSelect(ue, SIZES)), new Picker(ue);
    });
    const oe = () => {
      this.pickers.forEach((ue) => {
        ue.update();
      });
    };
    this.quill.on(Emitter.events.EDITOR_CHANGE, oe);
  }
}
BaseTheme.DEFAULTS = merge({}, Theme.DEFAULTS, {
  modules: {
    toolbar: {
      handlers: {
        formula() {
          this.quill.theme.tooltip.edit("formula");
        },
        image() {
          let le = this.container.querySelector("input.ql-image[type=file]");
          le == null && (le = document.createElement("input"), le.setAttribute("type", "file"), le.setAttribute("accept", this.quill.uploader.options.mimetypes.join(", ")), le.classList.add("ql-image"), le.addEventListener("change", () => {
            const Y = this.quill.getSelection(!0);
            this.quill.uploader.upload(Y, le.files), le.value = "";
          }), this.container.appendChild(le)), le.click();
        },
        video() {
          this.quill.theme.tooltip.edit("video");
        }
      }
    }
  }
});
class BaseTooltip extends Tooltip {
  constructor(Y, re) {
    super(Y, re), this.textbox = this.root.querySelector('input[type="text"]'), this.listen();
  }
  listen() {
    this.textbox.addEventListener("keydown", (Y) => {
      Y.key === "Enter" ? (this.save(), Y.preventDefault()) : Y.key === "Escape" && (this.cancel(), Y.preventDefault());
    });
  }
  cancel() {
    this.hide(), this.restoreFocus();
  }
  edit() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "link", re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (this.root.classList.remove("ql-hidden"), this.root.classList.add("ql-editing"), this.textbox == null) return;
    re != null ? this.textbox.value = re : Y !== this.root.getAttribute("data-mode") && (this.textbox.value = "");
    const oe = this.quill.getBounds(this.quill.selection.savedRange);
    oe != null && this.position(oe), this.textbox.select(), this.textbox.setAttribute("placeholder", this.textbox.getAttribute(`data-${Y}`) || ""), this.root.setAttribute("data-mode", Y);
  }
  restoreFocus() {
    this.quill.focus({
      preventScroll: !0
    });
  }
  save() {
    let {
      value: Y
    } = this.textbox;
    switch (this.root.getAttribute("data-mode")) {
      case "link": {
        const {
          scrollTop: re
        } = this.quill.root;
        this.linkRange ? (this.quill.formatText(this.linkRange, "link", Y, Emitter.sources.USER), delete this.linkRange) : (this.restoreFocus(), this.quill.format("link", Y, Emitter.sources.USER)), this.quill.root.scrollTop = re;
        break;
      }
      case "video":
        Y = extractVideoUrl(Y);
      // eslint-disable-next-line no-fallthrough
      case "formula": {
        if (!Y) break;
        const re = this.quill.getSelection(!0);
        if (re != null) {
          const oe = re.index + re.length;
          this.quill.insertEmbed(
            oe,
            // @ts-expect-error Fix me later
            this.root.getAttribute("data-mode"),
            Y,
            Emitter.sources.USER
          ), this.root.getAttribute("data-mode") === "formula" && this.quill.insertText(oe + 1, " ", Emitter.sources.USER), this.quill.setSelection(oe + 2, Emitter.sources.USER);
        }
        break;
      }
    }
    this.textbox.value = "", this.hide();
  }
}
function extractVideoUrl(le) {
  let Y = le.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || le.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
  return Y ? `${Y[1] || "https"}://www.youtube.com/embed/${Y[2]}?showinfo=0` : (Y = le.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) ? `${Y[1] || "https"}://player.vimeo.com/video/${Y[2]}/` : le;
}
function fillSelect(le, Y) {
  let re = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  Y.forEach((oe) => {
    const ue = document.createElement("option");
    oe === re ? ue.setAttribute("selected", "selected") : ue.setAttribute("value", String(oe)), le.appendChild(ue);
  });
}
const TOOLBAR_CONFIG$1 = [["bold", "italic", "link"], [{
  header: 1
}, {
  header: 2
}, "blockquote"]];
class BubbleTooltip extends BaseTooltip {
  static TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join("");
  constructor(Y, re) {
    super(Y, re), this.quill.on(Emitter.events.EDITOR_CHANGE, (oe, ue, fe, he) => {
      if (oe === Emitter.events.SELECTION_CHANGE)
        if (ue != null && ue.length > 0 && he === Emitter.sources.USER) {
          this.show(), this.root.style.left = "0px", this.root.style.width = "", this.root.style.width = `${this.root.offsetWidth}px`;
          const _e = this.quill.getLines(ue.index, ue.length);
          if (_e.length === 1) {
            const ve = this.quill.getBounds(ue);
            ve != null && this.position(ve);
          } else {
            const ve = _e[_e.length - 1], xe = this.quill.getIndex(ve), Ee = Math.min(ve.length() - 1, ue.index + ue.length - xe), Se = this.quill.getBounds(new Range(xe, Ee));
            Se != null && this.position(Se);
          }
        } else document.activeElement !== this.textbox && this.quill.hasFocus() && this.hide();
    });
  }
  listen() {
    super.listen(), this.root.querySelector(".ql-close").addEventListener("click", () => {
      this.root.classList.remove("ql-editing");
    }), this.quill.on(Emitter.events.SCROLL_OPTIMIZE, () => {
      setTimeout(() => {
        if (this.root.classList.contains("ql-hidden")) return;
        const Y = this.quill.getSelection();
        if (Y != null) {
          const re = this.quill.getBounds(Y);
          re != null && this.position(re);
        }
      }, 1);
    });
  }
  cancel() {
    this.show();
  }
  position(Y) {
    const re = super.position(Y), oe = this.root.querySelector(".ql-tooltip-arrow");
    return oe.style.marginLeft = "", re !== 0 && (oe.style.marginLeft = `${-1 * re - oe.offsetWidth / 2}px`), re;
  }
}
class BubbleTheme extends BaseTheme {
  constructor(Y, re) {
    re.modules.toolbar != null && re.modules.toolbar.container == null && (re.modules.toolbar.container = TOOLBAR_CONFIG$1), super(Y, re), this.quill.container.classList.add("ql-bubble");
  }
  extendToolbar(Y) {
    this.tooltip = new BubbleTooltip(this.quill, this.options.bounds), Y.container != null && (this.tooltip.root.appendChild(Y.container), this.buildButtons(Y.container.querySelectorAll("button"), Icons), this.buildPickers(Y.container.querySelectorAll("select"), Icons));
  }
}
BubbleTheme.DEFAULTS = merge({}, BaseTheme.DEFAULTS, {
  modules: {
    toolbar: {
      handlers: {
        link(le) {
          le ? this.quill.theme.tooltip.edit() : this.quill.format("link", !1, Quill.sources.USER);
        }
      }
    }
  }
});
const TOOLBAR_CONFIG = [[{
  header: ["1", "2", "3", !1]
}], ["bold", "italic", "underline", "link"], [{
  list: "ordered"
}, {
  list: "bullet"
}], ["clean"]];
class SnowTooltip extends BaseTooltip {
  static TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join("");
  preview = this.root.querySelector("a.ql-preview");
  listen() {
    super.listen(), this.root.querySelector("a.ql-action").addEventListener("click", (Y) => {
      this.root.classList.contains("ql-editing") ? this.save() : this.edit("link", this.preview.textContent), Y.preventDefault();
    }), this.root.querySelector("a.ql-remove").addEventListener("click", (Y) => {
      if (this.linkRange != null) {
        const re = this.linkRange;
        this.restoreFocus(), this.quill.formatText(re, "link", !1, Emitter.sources.USER), delete this.linkRange;
      }
      Y.preventDefault(), this.hide();
    }), this.quill.on(Emitter.events.SELECTION_CHANGE, (Y, re, oe) => {
      if (Y != null) {
        if (Y.length === 0 && oe === Emitter.sources.USER) {
          const [ue, fe] = this.quill.scroll.descendant(Link, Y.index);
          if (ue != null) {
            this.linkRange = new Range(Y.index - fe, ue.length());
            const he = Link.formats(ue.domNode);
            this.preview.textContent = he, this.preview.setAttribute("href", he), this.show();
            const _e = this.quill.getBounds(this.linkRange);
            _e != null && this.position(_e);
            return;
          }
        } else
          delete this.linkRange;
        this.hide();
      }
    });
  }
  show() {
    super.show(), this.root.removeAttribute("data-mode");
  }
}
class SnowTheme extends BaseTheme {
  constructor(Y, re) {
    re.modules.toolbar != null && re.modules.toolbar.container == null && (re.modules.toolbar.container = TOOLBAR_CONFIG), super(Y, re), this.quill.container.classList.add("ql-snow");
  }
  extendToolbar(Y) {
    Y.container != null && (Y.container.classList.add("ql-snow"), this.buildButtons(Y.container.querySelectorAll("button"), Icons), this.buildPickers(Y.container.querySelectorAll("select"), Icons), this.tooltip = new SnowTooltip(this.quill, this.options.bounds), Y.container.querySelector(".ql-link") && this.quill.keyboard.addBinding({
      key: "k",
      shortKey: !0
    }, (re, oe) => {
      Y.handlers.link.call(Y, !oe.format.link);
    }));
  }
}
SnowTheme.DEFAULTS = merge({}, BaseTheme.DEFAULTS, {
  modules: {
    toolbar: {
      handlers: {
        link(le) {
          if (le) {
            const Y = this.quill.getSelection();
            if (Y == null || Y.length === 0) return;
            let re = this.quill.getText(Y);
            /^\S+@\S+\.\S+$/.test(re) && re.indexOf("mailto:") !== 0 && (re = `mailto:${re}`);
            const {
              tooltip: oe
            } = this.quill.theme;
            oe.edit("link", re);
          } else
            this.quill.format("link", !1, Quill.sources.USER);
        }
      }
    }
  }
});
Quill.register({
  "attributors/attribute/direction": DirectionAttribute,
  "attributors/class/align": AlignClass,
  "attributors/class/background": BackgroundClass,
  "attributors/class/color": ColorClass,
  "attributors/class/direction": DirectionClass,
  "attributors/class/font": FontClass,
  "attributors/class/size": SizeClass,
  "attributors/style/align": AlignStyle,
  "attributors/style/background": BackgroundStyle,
  "attributors/style/color": ColorStyle,
  "attributors/style/direction": DirectionStyle,
  "attributors/style/font": FontStyle,
  "attributors/style/size": SizeStyle
}, !0);
Quill.register({
  "formats/align": AlignClass,
  "formats/direction": DirectionClass,
  "formats/indent": IndentClass,
  "formats/background": BackgroundStyle,
  "formats/color": ColorStyle,
  "formats/font": FontClass,
  "formats/size": SizeClass,
  "formats/blockquote": Blockquote,
  "formats/code-block": CodeBlock,
  "formats/header": Header,
  "formats/list": ListItem,
  "formats/bold": Bold,
  "formats/code": Code,
  "formats/italic": Italic,
  "formats/link": Link,
  "formats/script": Script,
  "formats/strike": Strike,
  "formats/underline": Underline,
  "formats/formula": Formula,
  "formats/image": Image$1,
  "formats/video": Video,
  "modules/syntax": Syntax,
  "modules/table": Table,
  "modules/toolbar": Toolbar,
  "themes/bubble": BubbleTheme,
  "themes/snow": SnowTheme,
  "ui/icons": Icons,
  "ui/picker": Picker,
  "ui/icon-picker": IconPicker,
  "ui/color-picker": ColorPicker,
  "ui/tooltip": Tooltip
}, !0);
var sax = {}, emitterComponent, hasRequiredEmitterComponent;
function requireEmitterComponent() {
  if (hasRequiredEmitterComponent) return emitterComponent;
  hasRequiredEmitterComponent = 1, emitterComponent = le;
  function le(re) {
    if (re) return Y(re);
  }
  function Y(re) {
    for (var oe in le.prototype)
      re[oe] = le.prototype[oe];
    return re;
  }
  return le.prototype.on = le.prototype.addEventListener = function(re, oe) {
    return this._callbacks = this._callbacks || {}, (this._callbacks[re] = this._callbacks[re] || []).push(oe), this;
  }, le.prototype.once = function(re, oe) {
    var ue = this;
    this._callbacks = this._callbacks || {};
    function fe() {
      ue.off(re, fe), oe.apply(this, arguments);
    }
    return fe.fn = oe, this.on(re, fe), this;
  }, le.prototype.off = le.prototype.removeListener = le.prototype.removeAllListeners = le.prototype.removeEventListener = function(re, oe) {
    if (this._callbacks = this._callbacks || {}, arguments.length == 0)
      return this._callbacks = {}, this;
    var ue = this._callbacks[re];
    if (!ue) return this;
    if (arguments.length == 1)
      return delete this._callbacks[re], this;
    for (var fe, he = 0; he < ue.length; he++)
      if (fe = ue[he], fe === oe || fe.fn === oe) {
        ue.splice(he, 1);
        break;
      }
    return this;
  }, le.prototype.emit = function(re) {
    this._callbacks = this._callbacks || {};
    var oe = [].slice.call(arguments, 1), ue = this._callbacks[re];
    if (ue) {
      ue = ue.slice(0);
      for (var fe = 0, he = ue.length; fe < he; ++fe)
        ue[fe].apply(this, oe);
    }
    return this;
  }, le.prototype.listeners = function(re) {
    return this._callbacks = this._callbacks || {}, this._callbacks[re] || [];
  }, le.prototype.hasListeners = function(re) {
    return !!this.listeners(re).length;
  }, emitterComponent;
}
var stream, hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream;
  hasRequiredStream = 1;
  var le = requireEmitterComponent();
  function Y() {
    le.call(this);
  }
  return Y.prototype = new le(), stream = Y, Y.Stream = Y, Y.prototype.pipe = function(re, oe) {
    var ue = this;
    function fe(Te) {
      re.writable && re.write(Te) === !1 && ue.pause && ue.pause();
    }
    ue.on("data", fe);
    function he() {
      ue.readable && ue.resume && ue.resume();
    }
    re.on("drain", he), !re._isStdio && (!oe || oe.end !== !1) && (ue.on("end", ve), ue.on("close", xe));
    var _e = !1;
    function ve() {
      _e || (_e = !0, re.end());
    }
    function xe() {
      _e || (_e = !0, typeof re.destroy == "function" && re.destroy());
    }
    function Ee(Te) {
      if (Se(), !this.hasListeners("error"))
        throw Te;
    }
    ue.on("error", Ee), re.on("error", Ee);
    function Se() {
      ue.off("data", fe), re.off("drain", he), ue.off("end", ve), ue.off("close", xe), ue.off("error", Ee), re.off("error", Ee), ue.off("end", Se), ue.off("close", Se), re.off("end", Se), re.off("close", Se);
    }
    return ue.on("end", Se), ue.on("close", Se), re.on("end", Se), re.on("close", Se), re.emit("pipe", ue), re;
  }, stream;
}
var string_decoder = {}, safeBuffer = { exports: {} }, buffer = {}, base64Js = {}, hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1, base64Js.byteLength = _e, base64Js.toByteArray = xe, base64Js.fromByteArray = Te;
  for (var le = [], Y = [], re = typeof Uint8Array < "u" ? Uint8Array : Array, oe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ue = 0, fe = oe.length; ue < fe; ++ue)
    le[ue] = oe[ue], Y[oe.charCodeAt(ue)] = ue;
  Y[45] = 62, Y[95] = 63;
  function he(Ce) {
    var Ie = Ce.length;
    if (Ie % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var Ne = Ce.indexOf("=");
    Ne === -1 && (Ne = Ie);
    var Re = Ne === Ie ? 0 : 4 - Ne % 4;
    return [Ne, Re];
  }
  function _e(Ce) {
    var Ie = he(Ce), Ne = Ie[0], Re = Ie[1];
    return (Ne + Re) * 3 / 4 - Re;
  }
  function ve(Ce, Ie, Ne) {
    return (Ie + Ne) * 3 / 4 - Ne;
  }
  function xe(Ce) {
    var Ie, Ne = he(Ce), Re = Ne[0], Ae = Ne[1], Pe = new re(ve(Ce, Re, Ae)), Fe = 0, Le = Ae > 0 ? Re - 4 : Re, He;
    for (He = 0; He < Le; He += 4)
      Ie = Y[Ce.charCodeAt(He)] << 18 | Y[Ce.charCodeAt(He + 1)] << 12 | Y[Ce.charCodeAt(He + 2)] << 6 | Y[Ce.charCodeAt(He + 3)], Pe[Fe++] = Ie >> 16 & 255, Pe[Fe++] = Ie >> 8 & 255, Pe[Fe++] = Ie & 255;
    return Ae === 2 && (Ie = Y[Ce.charCodeAt(He)] << 2 | Y[Ce.charCodeAt(He + 1)] >> 4, Pe[Fe++] = Ie & 255), Ae === 1 && (Ie = Y[Ce.charCodeAt(He)] << 10 | Y[Ce.charCodeAt(He + 1)] << 4 | Y[Ce.charCodeAt(He + 2)] >> 2, Pe[Fe++] = Ie >> 8 & 255, Pe[Fe++] = Ie & 255), Pe;
  }
  function Ee(Ce) {
    return le[Ce >> 18 & 63] + le[Ce >> 12 & 63] + le[Ce >> 6 & 63] + le[Ce & 63];
  }
  function Se(Ce, Ie, Ne) {
    for (var Re, Ae = [], Pe = Ie; Pe < Ne; Pe += 3)
      Re = (Ce[Pe] << 16 & 16711680) + (Ce[Pe + 1] << 8 & 65280) + (Ce[Pe + 2] & 255), Ae.push(Ee(Re));
    return Ae.join("");
  }
  function Te(Ce) {
    for (var Ie, Ne = Ce.length, Re = Ne % 3, Ae = [], Pe = 16383, Fe = 0, Le = Ne - Re; Fe < Le; Fe += Pe)
      Ae.push(Se(Ce, Fe, Fe + Pe > Le ? Le : Fe + Pe));
    return Re === 1 ? (Ie = Ce[Ne - 1], Ae.push(
      le[Ie >> 2] + le[Ie << 4 & 63] + "=="
    )) : Re === 2 && (Ie = (Ce[Ne - 2] << 8) + Ce[Ne - 1], Ae.push(
      le[Ie >> 10] + le[Ie >> 4 & 63] + le[Ie << 2 & 63] + "="
    )), Ae.join("");
  }
  return base64Js;
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredIeee754;
function requireIeee754() {
  return hasRequiredIeee754 || (hasRequiredIeee754 = 1, ieee754.read = function(le, Y, re, oe, ue) {
    var fe, he, _e = ue * 8 - oe - 1, ve = (1 << _e) - 1, xe = ve >> 1, Ee = -7, Se = re ? ue - 1 : 0, Te = re ? -1 : 1, Ce = le[Y + Se];
    for (Se += Te, fe = Ce & (1 << -Ee) - 1, Ce >>= -Ee, Ee += _e; Ee > 0; fe = fe * 256 + le[Y + Se], Se += Te, Ee -= 8)
      ;
    for (he = fe & (1 << -Ee) - 1, fe >>= -Ee, Ee += oe; Ee > 0; he = he * 256 + le[Y + Se], Se += Te, Ee -= 8)
      ;
    if (fe === 0)
      fe = 1 - xe;
    else {
      if (fe === ve)
        return he ? NaN : (Ce ? -1 : 1) * (1 / 0);
      he = he + Math.pow(2, oe), fe = fe - xe;
    }
    return (Ce ? -1 : 1) * he * Math.pow(2, fe - oe);
  }, ieee754.write = function(le, Y, re, oe, ue, fe) {
    var he, _e, ve, xe = fe * 8 - ue - 1, Ee = (1 << xe) - 1, Se = Ee >> 1, Te = ue === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Ce = oe ? 0 : fe - 1, Ie = oe ? 1 : -1, Ne = Y < 0 || Y === 0 && 1 / Y < 0 ? 1 : 0;
    for (Y = Math.abs(Y), isNaN(Y) || Y === 1 / 0 ? (_e = isNaN(Y) ? 1 : 0, he = Ee) : (he = Math.floor(Math.log(Y) / Math.LN2), Y * (ve = Math.pow(2, -he)) < 1 && (he--, ve *= 2), he + Se >= 1 ? Y += Te / ve : Y += Te * Math.pow(2, 1 - Se), Y * ve >= 2 && (he++, ve /= 2), he + Se >= Ee ? (_e = 0, he = Ee) : he + Se >= 1 ? (_e = (Y * ve - 1) * Math.pow(2, ue), he = he + Se) : (_e = Y * Math.pow(2, Se - 1) * Math.pow(2, ue), he = 0)); ue >= 8; le[re + Ce] = _e & 255, Ce += Ie, _e /= 256, ue -= 8)
      ;
    for (he = he << ue | _e, xe += ue; xe > 0; le[re + Ce] = he & 255, Ce += Ie, he /= 256, xe -= 8)
      ;
    le[re + Ce - Ie] |= Ne * 128;
  }), ieee754;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var hasRequiredBuffer;
function requireBuffer() {
  return hasRequiredBuffer || (hasRequiredBuffer = 1, function(le) {
    const Y = requireBase64Js(), re = requireIeee754(), oe = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    le.Buffer = _e, le.SlowBuffer = Pe, le.INSPECT_MAX_BYTES = 50;
    const ue = 2147483647;
    le.kMaxLength = ue, _e.TYPED_ARRAY_SUPPORT = fe(), !_e.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function fe() {
      try {
        const Je = new Uint8Array(1), Ue = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(Ue, Uint8Array.prototype), Object.setPrototypeOf(Je, Ue), Je.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(_e.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (_e.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(_e.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (_e.isBuffer(this))
          return this.byteOffset;
      }
    });
    function he(Je) {
      if (Je > ue)
        throw new RangeError('The value "' + Je + '" is invalid for option "size"');
      const Ue = new Uint8Array(Je);
      return Object.setPrototypeOf(Ue, _e.prototype), Ue;
    }
    function _e(Je, Ue, We) {
      if (typeof Je == "number") {
        if (typeof Ue == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return Se(Je);
      }
      return ve(Je, Ue, We);
    }
    _e.poolSize = 8192;
    function ve(Je, Ue, We) {
      if (typeof Je == "string")
        return Te(Je, Ue);
      if (ArrayBuffer.isView(Je))
        return Ie(Je);
      if (Je == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Je
        );
      if (Zt(Je, ArrayBuffer) || Je && Zt(Je.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Zt(Je, SharedArrayBuffer) || Je && Zt(Je.buffer, SharedArrayBuffer)))
        return Ne(Je, Ue, We);
      if (typeof Je == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const lt = Je.valueOf && Je.valueOf();
      if (lt != null && lt !== Je)
        return _e.from(lt, Ue, We);
      const ft = Re(Je);
      if (ft) return ft;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Je[Symbol.toPrimitive] == "function")
        return _e.from(Je[Symbol.toPrimitive]("string"), Ue, We);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Je
      );
    }
    _e.from = function(Je, Ue, We) {
      return ve(Je, Ue, We);
    }, Object.setPrototypeOf(_e.prototype, Uint8Array.prototype), Object.setPrototypeOf(_e, Uint8Array);
    function xe(Je) {
      if (typeof Je != "number")
        throw new TypeError('"size" argument must be of type number');
      if (Je < 0)
        throw new RangeError('The value "' + Je + '" is invalid for option "size"');
    }
    function Ee(Je, Ue, We) {
      return xe(Je), Je <= 0 ? he(Je) : Ue !== void 0 ? typeof We == "string" ? he(Je).fill(Ue, We) : he(Je).fill(Ue) : he(Je);
    }
    _e.alloc = function(Je, Ue, We) {
      return Ee(Je, Ue, We);
    };
    function Se(Je) {
      return xe(Je), he(Je < 0 ? 0 : Ae(Je) | 0);
    }
    _e.allocUnsafe = function(Je) {
      return Se(Je);
    }, _e.allocUnsafeSlow = function(Je) {
      return Se(Je);
    };
    function Te(Je, Ue) {
      if ((typeof Ue != "string" || Ue === "") && (Ue = "utf8"), !_e.isEncoding(Ue))
        throw new TypeError("Unknown encoding: " + Ue);
      const We = Fe(Je, Ue) | 0;
      let lt = he(We);
      const ft = lt.write(Je, Ue);
      return ft !== We && (lt = lt.slice(0, ft)), lt;
    }
    function Ce(Je) {
      const Ue = Je.length < 0 ? 0 : Ae(Je.length) | 0, We = he(Ue);
      for (let lt = 0; lt < Ue; lt += 1)
        We[lt] = Je[lt] & 255;
      return We;
    }
    function Ie(Je) {
      if (Zt(Je, Uint8Array)) {
        const Ue = new Uint8Array(Je);
        return Ne(Ue.buffer, Ue.byteOffset, Ue.byteLength);
      }
      return Ce(Je);
    }
    function Ne(Je, Ue, We) {
      if (Ue < 0 || Je.byteLength < Ue)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (Je.byteLength < Ue + (We || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let lt;
      return Ue === void 0 && We === void 0 ? lt = new Uint8Array(Je) : We === void 0 ? lt = new Uint8Array(Je, Ue) : lt = new Uint8Array(Je, Ue, We), Object.setPrototypeOf(lt, _e.prototype), lt;
    }
    function Re(Je) {
      if (_e.isBuffer(Je)) {
        const Ue = Ae(Je.length) | 0, We = he(Ue);
        return We.length === 0 || Je.copy(We, 0, 0, Ue), We;
      }
      if (Je.length !== void 0)
        return typeof Je.length != "number" || Gt(Je.length) ? he(0) : Ce(Je);
      if (Je.type === "Buffer" && Array.isArray(Je.data))
        return Ce(Je.data);
    }
    function Ae(Je) {
      if (Je >= ue)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + ue.toString(16) + " bytes");
      return Je | 0;
    }
    function Pe(Je) {
      return +Je != Je && (Je = 0), _e.alloc(+Je);
    }
    _e.isBuffer = function(Ue) {
      return Ue != null && Ue._isBuffer === !0 && Ue !== _e.prototype;
    }, _e.compare = function(Ue, We) {
      if (Zt(Ue, Uint8Array) && (Ue = _e.from(Ue, Ue.offset, Ue.byteLength)), Zt(We, Uint8Array) && (We = _e.from(We, We.offset, We.byteLength)), !_e.isBuffer(Ue) || !_e.isBuffer(We))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (Ue === We) return 0;
      let lt = Ue.length, ft = We.length;
      for (let Et = 0, Lt = Math.min(lt, ft); Et < Lt; ++Et)
        if (Ue[Et] !== We[Et]) {
          lt = Ue[Et], ft = We[Et];
          break;
        }
      return lt < ft ? -1 : ft < lt ? 1 : 0;
    }, _e.isEncoding = function(Ue) {
      switch (String(Ue).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, _e.concat = function(Ue, We) {
      if (!Array.isArray(Ue))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (Ue.length === 0)
        return _e.alloc(0);
      let lt;
      if (We === void 0)
        for (We = 0, lt = 0; lt < Ue.length; ++lt)
          We += Ue[lt].length;
      const ft = _e.allocUnsafe(We);
      let Et = 0;
      for (lt = 0; lt < Ue.length; ++lt) {
        let Lt = Ue[lt];
        if (Zt(Lt, Uint8Array))
          Et + Lt.length > ft.length ? (_e.isBuffer(Lt) || (Lt = _e.from(Lt)), Lt.copy(ft, Et)) : Uint8Array.prototype.set.call(
            ft,
            Lt,
            Et
          );
        else if (_e.isBuffer(Lt))
          Lt.copy(ft, Et);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        Et += Lt.length;
      }
      return ft;
    };
    function Fe(Je, Ue) {
      if (_e.isBuffer(Je))
        return Je.length;
      if (ArrayBuffer.isView(Je) || Zt(Je, ArrayBuffer))
        return Je.byteLength;
      if (typeof Je != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Je
        );
      const We = Je.length, lt = arguments.length > 2 && arguments[2] === !0;
      if (!lt && We === 0) return 0;
      let ft = !1;
      for (; ; )
        switch (Ue) {
          case "ascii":
          case "latin1":
          case "binary":
            return We;
          case "utf8":
          case "utf-8":
            return Mt(Je).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return We * 2;
          case "hex":
            return We >>> 1;
          case "base64":
            return Jt(Je).length;
          default:
            if (ft)
              return lt ? -1 : Mt(Je).length;
            Ue = ("" + Ue).toLowerCase(), ft = !0;
        }
    }
    _e.byteLength = Fe;
    function Le(Je, Ue, We) {
      let lt = !1;
      if ((Ue === void 0 || Ue < 0) && (Ue = 0), Ue > this.length || ((We === void 0 || We > this.length) && (We = this.length), We <= 0) || (We >>>= 0, Ue >>>= 0, We <= Ue))
        return "";
      for (Je || (Je = "utf8"); ; )
        switch (Je) {
          case "hex":
            return gt(this, Ue, We);
          case "utf8":
          case "utf-8":
            return mt(this, Ue, We);
          case "ascii":
            return st(this, Ue, We);
          case "latin1":
          case "binary":
            return xt(this, Ue, We);
          case "base64":
            return Xe(this, Ue, We);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ze(this, Ue, We);
          default:
            if (lt) throw new TypeError("Unknown encoding: " + Je);
            Je = (Je + "").toLowerCase(), lt = !0;
        }
    }
    _e.prototype._isBuffer = !0;
    function He(Je, Ue, We) {
      const lt = Je[Ue];
      Je[Ue] = Je[We], Je[We] = lt;
    }
    _e.prototype.swap16 = function() {
      const Ue = this.length;
      if (Ue % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let We = 0; We < Ue; We += 2)
        He(this, We, We + 1);
      return this;
    }, _e.prototype.swap32 = function() {
      const Ue = this.length;
      if (Ue % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let We = 0; We < Ue; We += 4)
        He(this, We, We + 3), He(this, We + 1, We + 2);
      return this;
    }, _e.prototype.swap64 = function() {
      const Ue = this.length;
      if (Ue % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let We = 0; We < Ue; We += 8)
        He(this, We, We + 7), He(this, We + 1, We + 6), He(this, We + 2, We + 5), He(this, We + 3, We + 4);
      return this;
    }, _e.prototype.toString = function() {
      const Ue = this.length;
      return Ue === 0 ? "" : arguments.length === 0 ? mt(this, 0, Ue) : Le.apply(this, arguments);
    }, _e.prototype.toLocaleString = _e.prototype.toString, _e.prototype.equals = function(Ue) {
      if (!_e.isBuffer(Ue)) throw new TypeError("Argument must be a Buffer");
      return this === Ue ? !0 : _e.compare(this, Ue) === 0;
    }, _e.prototype.inspect = function() {
      let Ue = "";
      const We = le.INSPECT_MAX_BYTES;
      return Ue = this.toString("hex", 0, We).replace(/(.{2})/g, "$1 ").trim(), this.length > We && (Ue += " ... "), "<Buffer " + Ue + ">";
    }, oe && (_e.prototype[oe] = _e.prototype.inspect), _e.prototype.compare = function(Ue, We, lt, ft, Et) {
      if (Zt(Ue, Uint8Array) && (Ue = _e.from(Ue, Ue.offset, Ue.byteLength)), !_e.isBuffer(Ue))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Ue
        );
      if (We === void 0 && (We = 0), lt === void 0 && (lt = Ue ? Ue.length : 0), ft === void 0 && (ft = 0), Et === void 0 && (Et = this.length), We < 0 || lt > Ue.length || ft < 0 || Et > this.length)
        throw new RangeError("out of range index");
      if (ft >= Et && We >= lt)
        return 0;
      if (ft >= Et)
        return -1;
      if (We >= lt)
        return 1;
      if (We >>>= 0, lt >>>= 0, ft >>>= 0, Et >>>= 0, this === Ue) return 0;
      let Lt = Et - ft, Kt = lt - We;
      const ar = Math.min(Lt, Kt), sr = this.slice(ft, Et), or = Ue.slice(We, lt);
      for (let nr = 0; nr < ar; ++nr)
        if (sr[nr] !== or[nr]) {
          Lt = sr[nr], Kt = or[nr];
          break;
        }
      return Lt < Kt ? -1 : Kt < Lt ? 1 : 0;
    };
    function Ge(Je, Ue, We, lt, ft) {
      if (Je.length === 0) return -1;
      if (typeof We == "string" ? (lt = We, We = 0) : We > 2147483647 ? We = 2147483647 : We < -2147483648 && (We = -2147483648), We = +We, Gt(We) && (We = ft ? 0 : Je.length - 1), We < 0 && (We = Je.length + We), We >= Je.length) {
        if (ft) return -1;
        We = Je.length - 1;
      } else if (We < 0)
        if (ft) We = 0;
        else return -1;
      if (typeof Ue == "string" && (Ue = _e.from(Ue, lt)), _e.isBuffer(Ue))
        return Ue.length === 0 ? -1 : Ve(Je, Ue, We, lt, ft);
      if (typeof Ue == "number")
        return Ue = Ue & 255, typeof Uint8Array.prototype.indexOf == "function" ? ft ? Uint8Array.prototype.indexOf.call(Je, Ue, We) : Uint8Array.prototype.lastIndexOf.call(Je, Ue, We) : Ve(Je, [Ue], We, lt, ft);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Ve(Je, Ue, We, lt, ft) {
      let Et = 1, Lt = Je.length, Kt = Ue.length;
      if (lt !== void 0 && (lt = String(lt).toLowerCase(), lt === "ucs2" || lt === "ucs-2" || lt === "utf16le" || lt === "utf-16le")) {
        if (Je.length < 2 || Ue.length < 2)
          return -1;
        Et = 2, Lt /= 2, Kt /= 2, We /= 2;
      }
      function ar(or, nr) {
        return Et === 1 ? or[nr] : or.readUInt16BE(nr * Et);
      }
      let sr;
      if (ft) {
        let or = -1;
        for (sr = We; sr < Lt; sr++)
          if (ar(Je, sr) === ar(Ue, or === -1 ? 0 : sr - or)) {
            if (or === -1 && (or = sr), sr - or + 1 === Kt) return or * Et;
          } else
            or !== -1 && (sr -= sr - or), or = -1;
      } else
        for (We + Kt > Lt && (We = Lt - Kt), sr = We; sr >= 0; sr--) {
          let or = !0;
          for (let nr = 0; nr < Kt; nr++)
            if (ar(Je, sr + nr) !== ar(Ue, nr)) {
              or = !1;
              break;
            }
          if (or) return sr;
        }
      return -1;
    }
    _e.prototype.includes = function(Ue, We, lt) {
      return this.indexOf(Ue, We, lt) !== -1;
    }, _e.prototype.indexOf = function(Ue, We, lt) {
      return Ge(this, Ue, We, lt, !0);
    }, _e.prototype.lastIndexOf = function(Ue, We, lt) {
      return Ge(this, Ue, We, lt, !1);
    };
    function $e(Je, Ue, We, lt) {
      We = Number(We) || 0;
      const ft = Je.length - We;
      lt ? (lt = Number(lt), lt > ft && (lt = ft)) : lt = ft;
      const Et = Ue.length;
      lt > Et / 2 && (lt = Et / 2);
      let Lt;
      for (Lt = 0; Lt < lt; ++Lt) {
        const Kt = parseInt(Ue.substr(Lt * 2, 2), 16);
        if (Gt(Kt)) return Lt;
        Je[We + Lt] = Kt;
      }
      return Lt;
    }
    function De(Je, Ue, We, lt) {
      return er(Mt(Ue, Je.length - We), Je, We, lt);
    }
    function Ke(Je, Ue, We, lt) {
      return er(Dt(Ue), Je, We, lt);
    }
    function ze(Je, Ue, We, lt) {
      return er(Jt(Ue), Je, We, lt);
    }
    function tt(Je, Ue, We, lt) {
      return er(Vt(Ue, Je.length - We), Je, We, lt);
    }
    _e.prototype.write = function(Ue, We, lt, ft) {
      if (We === void 0)
        ft = "utf8", lt = this.length, We = 0;
      else if (lt === void 0 && typeof We == "string")
        ft = We, lt = this.length, We = 0;
      else if (isFinite(We))
        We = We >>> 0, isFinite(lt) ? (lt = lt >>> 0, ft === void 0 && (ft = "utf8")) : (ft = lt, lt = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const Et = this.length - We;
      if ((lt === void 0 || lt > Et) && (lt = Et), Ue.length > 0 && (lt < 0 || We < 0) || We > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      ft || (ft = "utf8");
      let Lt = !1;
      for (; ; )
        switch (ft) {
          case "hex":
            return $e(this, Ue, We, lt);
          case "utf8":
          case "utf-8":
            return De(this, Ue, We, lt);
          case "ascii":
          case "latin1":
          case "binary":
            return Ke(this, Ue, We, lt);
          case "base64":
            return ze(this, Ue, We, lt);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return tt(this, Ue, We, lt);
          default:
            if (Lt) throw new TypeError("Unknown encoding: " + ft);
            ft = ("" + ft).toLowerCase(), Lt = !0;
        }
    }, _e.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function Xe(Je, Ue, We) {
      return Ue === 0 && We === Je.length ? Y.fromByteArray(Je) : Y.fromByteArray(Je.slice(Ue, We));
    }
    function mt(Je, Ue, We) {
      We = Math.min(Je.length, We);
      const lt = [];
      let ft = Ue;
      for (; ft < We; ) {
        const Et = Je[ft];
        let Lt = null, Kt = Et > 239 ? 4 : Et > 223 ? 3 : Et > 191 ? 2 : 1;
        if (ft + Kt <= We) {
          let ar, sr, or, nr;
          switch (Kt) {
            case 1:
              Et < 128 && (Lt = Et);
              break;
            case 2:
              ar = Je[ft + 1], (ar & 192) === 128 && (nr = (Et & 31) << 6 | ar & 63, nr > 127 && (Lt = nr));
              break;
            case 3:
              ar = Je[ft + 1], sr = Je[ft + 2], (ar & 192) === 128 && (sr & 192) === 128 && (nr = (Et & 15) << 12 | (ar & 63) << 6 | sr & 63, nr > 2047 && (nr < 55296 || nr > 57343) && (Lt = nr));
              break;
            case 4:
              ar = Je[ft + 1], sr = Je[ft + 2], or = Je[ft + 3], (ar & 192) === 128 && (sr & 192) === 128 && (or & 192) === 128 && (nr = (Et & 15) << 18 | (ar & 63) << 12 | (sr & 63) << 6 | or & 63, nr > 65535 && nr < 1114112 && (Lt = nr));
          }
        }
        Lt === null ? (Lt = 65533, Kt = 1) : Lt > 65535 && (Lt -= 65536, lt.push(Lt >>> 10 & 1023 | 55296), Lt = 56320 | Lt & 1023), lt.push(Lt), ft += Kt;
      }
      return qe(lt);
    }
    const at = 4096;
    function qe(Je) {
      const Ue = Je.length;
      if (Ue <= at)
        return String.fromCharCode.apply(String, Je);
      let We = "", lt = 0;
      for (; lt < Ue; )
        We += String.fromCharCode.apply(
          String,
          Je.slice(lt, lt += at)
        );
      return We;
    }
    function st(Je, Ue, We) {
      let lt = "";
      We = Math.min(Je.length, We);
      for (let ft = Ue; ft < We; ++ft)
        lt += String.fromCharCode(Je[ft] & 127);
      return lt;
    }
    function xt(Je, Ue, We) {
      let lt = "";
      We = Math.min(Je.length, We);
      for (let ft = Ue; ft < We; ++ft)
        lt += String.fromCharCode(Je[ft]);
      return lt;
    }
    function gt(Je, Ue, We) {
      const lt = Je.length;
      (!Ue || Ue < 0) && (Ue = 0), (!We || We < 0 || We > lt) && (We = lt);
      let ft = "";
      for (let Et = Ue; Et < We; ++Et)
        ft += Yt[Je[Et]];
      return ft;
    }
    function Ze(Je, Ue, We) {
      const lt = Je.slice(Ue, We);
      let ft = "";
      for (let Et = 0; Et < lt.length - 1; Et += 2)
        ft += String.fromCharCode(lt[Et] + lt[Et + 1] * 256);
      return ft;
    }
    _e.prototype.slice = function(Ue, We) {
      const lt = this.length;
      Ue = ~~Ue, We = We === void 0 ? lt : ~~We, Ue < 0 ? (Ue += lt, Ue < 0 && (Ue = 0)) : Ue > lt && (Ue = lt), We < 0 ? (We += lt, We < 0 && (We = 0)) : We > lt && (We = lt), We < Ue && (We = Ue);
      const ft = this.subarray(Ue, We);
      return Object.setPrototypeOf(ft, _e.prototype), ft;
    };
    function _t(Je, Ue, We) {
      if (Je % 1 !== 0 || Je < 0) throw new RangeError("offset is not uint");
      if (Je + Ue > We) throw new RangeError("Trying to access beyond buffer length");
    }
    _e.prototype.readUintLE = _e.prototype.readUIntLE = function(Ue, We, lt) {
      Ue = Ue >>> 0, We = We >>> 0, lt || _t(Ue, We, this.length);
      let ft = this[Ue], Et = 1, Lt = 0;
      for (; ++Lt < We && (Et *= 256); )
        ft += this[Ue + Lt] * Et;
      return ft;
    }, _e.prototype.readUintBE = _e.prototype.readUIntBE = function(Ue, We, lt) {
      Ue = Ue >>> 0, We = We >>> 0, lt || _t(Ue, We, this.length);
      let ft = this[Ue + --We], Et = 1;
      for (; We > 0 && (Et *= 256); )
        ft += this[Ue + --We] * Et;
      return ft;
    }, _e.prototype.readUint8 = _e.prototype.readUInt8 = function(Ue, We) {
      return Ue = Ue >>> 0, We || _t(Ue, 1, this.length), this[Ue];
    }, _e.prototype.readUint16LE = _e.prototype.readUInt16LE = function(Ue, We) {
      return Ue = Ue >>> 0, We || _t(Ue, 2, this.length), this[Ue] | this[Ue + 1] << 8;
    }, _e.prototype.readUint16BE = _e.prototype.readUInt16BE = function(Ue, We) {
      return Ue = Ue >>> 0, We || _t(Ue, 2, this.length), this[Ue] << 8 | this[Ue + 1];
    }, _e.prototype.readUint32LE = _e.prototype.readUInt32LE = function(Ue, We) {
      return Ue = Ue >>> 0, We || _t(Ue, 4, this.length), (this[Ue] | this[Ue + 1] << 8 | this[Ue + 2] << 16) + this[Ue + 3] * 16777216;
    }, _e.prototype.readUint32BE = _e.prototype.readUInt32BE = function(Ue, We) {
      return Ue = Ue >>> 0, We || _t(Ue, 4, this.length), this[Ue] * 16777216 + (this[Ue + 1] << 16 | this[Ue + 2] << 8 | this[Ue + 3]);
    }, _e.prototype.readBigUInt64LE = $t(function(Ue) {
      Ue = Ue >>> 0, rt(Ue, "offset");
      const We = this[Ue], lt = this[Ue + 7];
      (We === void 0 || lt === void 0) && Ct(Ue, this.length - 8);
      const ft = We + this[++Ue] * 2 ** 8 + this[++Ue] * 2 ** 16 + this[++Ue] * 2 ** 24, Et = this[++Ue] + this[++Ue] * 2 ** 8 + this[++Ue] * 2 ** 16 + lt * 2 ** 24;
      return BigInt(ft) + (BigInt(Et) << BigInt(32));
    }), _e.prototype.readBigUInt64BE = $t(function(Ue) {
      Ue = Ue >>> 0, rt(Ue, "offset");
      const We = this[Ue], lt = this[Ue + 7];
      (We === void 0 || lt === void 0) && Ct(Ue, this.length - 8);
      const ft = We * 2 ** 24 + this[++Ue] * 2 ** 16 + this[++Ue] * 2 ** 8 + this[++Ue], Et = this[++Ue] * 2 ** 24 + this[++Ue] * 2 ** 16 + this[++Ue] * 2 ** 8 + lt;
      return (BigInt(ft) << BigInt(32)) + BigInt(Et);
    }), _e.prototype.readIntLE = function(Ue, We, lt) {
      Ue = Ue >>> 0, We = We >>> 0, lt || _t(Ue, We, this.length);
      let ft = this[Ue], Et = 1, Lt = 0;
      for (; ++Lt < We && (Et *= 256); )
        ft += this[Ue + Lt] * Et;
      return Et *= 128, ft >= Et && (ft -= Math.pow(2, 8 * We)), ft;
    }, _e.prototype.readIntBE = function(Ue, We, lt) {
      Ue = Ue >>> 0, We = We >>> 0, lt || _t(Ue, We, this.length);
      let ft = We, Et = 1, Lt = this[Ue + --ft];
      for (; ft > 0 && (Et *= 256); )
        Lt += this[Ue + --ft] * Et;
      return Et *= 128, Lt >= Et && (Lt -= Math.pow(2, 8 * We)), Lt;
    }, _e.prototype.readInt8 = function(Ue, We) {
      return Ue = Ue >>> 0, We || _t(Ue, 1, this.length), this[Ue] & 128 ? (255 - this[Ue] + 1) * -1 : this[Ue];
    }, _e.prototype.readInt16LE = function(Ue, We) {
      Ue = Ue >>> 0, We || _t(Ue, 2, this.length);
      const lt = this[Ue] | this[Ue + 1] << 8;
      return lt & 32768 ? lt | 4294901760 : lt;
    }, _e.prototype.readInt16BE = function(Ue, We) {
      Ue = Ue >>> 0, We || _t(Ue, 2, this.length);
      const lt = this[Ue + 1] | this[Ue] << 8;
      return lt & 32768 ? lt | 4294901760 : lt;
    }, _e.prototype.readInt32LE = function(Ue, We) {
      return Ue = Ue >>> 0, We || _t(Ue, 4, this.length), this[Ue] | this[Ue + 1] << 8 | this[Ue + 2] << 16 | this[Ue + 3] << 24;
    }, _e.prototype.readInt32BE = function(Ue, We) {
      return Ue = Ue >>> 0, We || _t(Ue, 4, this.length), this[Ue] << 24 | this[Ue + 1] << 16 | this[Ue + 2] << 8 | this[Ue + 3];
    }, _e.prototype.readBigInt64LE = $t(function(Ue) {
      Ue = Ue >>> 0, rt(Ue, "offset");
      const We = this[Ue], lt = this[Ue + 7];
      (We === void 0 || lt === void 0) && Ct(Ue, this.length - 8);
      const ft = this[Ue + 4] + this[Ue + 5] * 2 ** 8 + this[Ue + 6] * 2 ** 16 + (lt << 24);
      return (BigInt(ft) << BigInt(32)) + BigInt(We + this[++Ue] * 2 ** 8 + this[++Ue] * 2 ** 16 + this[++Ue] * 2 ** 24);
    }), _e.prototype.readBigInt64BE = $t(function(Ue) {
      Ue = Ue >>> 0, rt(Ue, "offset");
      const We = this[Ue], lt = this[Ue + 7];
      (We === void 0 || lt === void 0) && Ct(Ue, this.length - 8);
      const ft = (We << 24) + // Overflow
      this[++Ue] * 2 ** 16 + this[++Ue] * 2 ** 8 + this[++Ue];
      return (BigInt(ft) << BigInt(32)) + BigInt(this[++Ue] * 2 ** 24 + this[++Ue] * 2 ** 16 + this[++Ue] * 2 ** 8 + lt);
    }), _e.prototype.readFloatLE = function(Ue, We) {
      return Ue = Ue >>> 0, We || _t(Ue, 4, this.length), re.read(this, Ue, !0, 23, 4);
    }, _e.prototype.readFloatBE = function(Ue, We) {
      return Ue = Ue >>> 0, We || _t(Ue, 4, this.length), re.read(this, Ue, !1, 23, 4);
    }, _e.prototype.readDoubleLE = function(Ue, We) {
      return Ue = Ue >>> 0, We || _t(Ue, 8, this.length), re.read(this, Ue, !0, 52, 8);
    }, _e.prototype.readDoubleBE = function(Ue, We) {
      return Ue = Ue >>> 0, We || _t(Ue, 8, this.length), re.read(this, Ue, !1, 52, 8);
    };
    function wt(Je, Ue, We, lt, ft, Et) {
      if (!_e.isBuffer(Je)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (Ue > ft || Ue < Et) throw new RangeError('"value" argument is out of bounds');
      if (We + lt > Je.length) throw new RangeError("Index out of range");
    }
    _e.prototype.writeUintLE = _e.prototype.writeUIntLE = function(Ue, We, lt, ft) {
      if (Ue = +Ue, We = We >>> 0, lt = lt >>> 0, !ft) {
        const Kt = Math.pow(2, 8 * lt) - 1;
        wt(this, Ue, We, lt, Kt, 0);
      }
      let Et = 1, Lt = 0;
      for (this[We] = Ue & 255; ++Lt < lt && (Et *= 256); )
        this[We + Lt] = Ue / Et & 255;
      return We + lt;
    }, _e.prototype.writeUintBE = _e.prototype.writeUIntBE = function(Ue, We, lt, ft) {
      if (Ue = +Ue, We = We >>> 0, lt = lt >>> 0, !ft) {
        const Kt = Math.pow(2, 8 * lt) - 1;
        wt(this, Ue, We, lt, Kt, 0);
      }
      let Et = lt - 1, Lt = 1;
      for (this[We + Et] = Ue & 255; --Et >= 0 && (Lt *= 256); )
        this[We + Et] = Ue / Lt & 255;
      return We + lt;
    }, _e.prototype.writeUint8 = _e.prototype.writeUInt8 = function(Ue, We, lt) {
      return Ue = +Ue, We = We >>> 0, lt || wt(this, Ue, We, 1, 255, 0), this[We] = Ue & 255, We + 1;
    }, _e.prototype.writeUint16LE = _e.prototype.writeUInt16LE = function(Ue, We, lt) {
      return Ue = +Ue, We = We >>> 0, lt || wt(this, Ue, We, 2, 65535, 0), this[We] = Ue & 255, this[We + 1] = Ue >>> 8, We + 2;
    }, _e.prototype.writeUint16BE = _e.prototype.writeUInt16BE = function(Ue, We, lt) {
      return Ue = +Ue, We = We >>> 0, lt || wt(this, Ue, We, 2, 65535, 0), this[We] = Ue >>> 8, this[We + 1] = Ue & 255, We + 2;
    }, _e.prototype.writeUint32LE = _e.prototype.writeUInt32LE = function(Ue, We, lt) {
      return Ue = +Ue, We = We >>> 0, lt || wt(this, Ue, We, 4, 4294967295, 0), this[We + 3] = Ue >>> 24, this[We + 2] = Ue >>> 16, this[We + 1] = Ue >>> 8, this[We] = Ue & 255, We + 4;
    }, _e.prototype.writeUint32BE = _e.prototype.writeUInt32BE = function(Ue, We, lt) {
      return Ue = +Ue, We = We >>> 0, lt || wt(this, Ue, We, 4, 4294967295, 0), this[We] = Ue >>> 24, this[We + 1] = Ue >>> 16, this[We + 2] = Ue >>> 8, this[We + 3] = Ue & 255, We + 4;
    };
    function yt(Je, Ue, We, lt, ft) {
      bt(Ue, lt, ft, Je, We, 7);
      let Et = Number(Ue & BigInt(4294967295));
      Je[We++] = Et, Et = Et >> 8, Je[We++] = Et, Et = Et >> 8, Je[We++] = Et, Et = Et >> 8, Je[We++] = Et;
      let Lt = Number(Ue >> BigInt(32) & BigInt(4294967295));
      return Je[We++] = Lt, Lt = Lt >> 8, Je[We++] = Lt, Lt = Lt >> 8, Je[We++] = Lt, Lt = Lt >> 8, Je[We++] = Lt, We;
    }
    function St(Je, Ue, We, lt, ft) {
      bt(Ue, lt, ft, Je, We, 7);
      let Et = Number(Ue & BigInt(4294967295));
      Je[We + 7] = Et, Et = Et >> 8, Je[We + 6] = Et, Et = Et >> 8, Je[We + 5] = Et, Et = Et >> 8, Je[We + 4] = Et;
      let Lt = Number(Ue >> BigInt(32) & BigInt(4294967295));
      return Je[We + 3] = Lt, Lt = Lt >> 8, Je[We + 2] = Lt, Lt = Lt >> 8, Je[We + 1] = Lt, Lt = Lt >> 8, Je[We] = Lt, We + 8;
    }
    _e.prototype.writeBigUInt64LE = $t(function(Ue, We = 0) {
      return yt(this, Ue, We, BigInt(0), BigInt("0xffffffffffffffff"));
    }), _e.prototype.writeBigUInt64BE = $t(function(Ue, We = 0) {
      return St(this, Ue, We, BigInt(0), BigInt("0xffffffffffffffff"));
    }), _e.prototype.writeIntLE = function(Ue, We, lt, ft) {
      if (Ue = +Ue, We = We >>> 0, !ft) {
        const ar = Math.pow(2, 8 * lt - 1);
        wt(this, Ue, We, lt, ar - 1, -ar);
      }
      let Et = 0, Lt = 1, Kt = 0;
      for (this[We] = Ue & 255; ++Et < lt && (Lt *= 256); )
        Ue < 0 && Kt === 0 && this[We + Et - 1] !== 0 && (Kt = 1), this[We + Et] = (Ue / Lt >> 0) - Kt & 255;
      return We + lt;
    }, _e.prototype.writeIntBE = function(Ue, We, lt, ft) {
      if (Ue = +Ue, We = We >>> 0, !ft) {
        const ar = Math.pow(2, 8 * lt - 1);
        wt(this, Ue, We, lt, ar - 1, -ar);
      }
      let Et = lt - 1, Lt = 1, Kt = 0;
      for (this[We + Et] = Ue & 255; --Et >= 0 && (Lt *= 256); )
        Ue < 0 && Kt === 0 && this[We + Et + 1] !== 0 && (Kt = 1), this[We + Et] = (Ue / Lt >> 0) - Kt & 255;
      return We + lt;
    }, _e.prototype.writeInt8 = function(Ue, We, lt) {
      return Ue = +Ue, We = We >>> 0, lt || wt(this, Ue, We, 1, 127, -128), Ue < 0 && (Ue = 255 + Ue + 1), this[We] = Ue & 255, We + 1;
    }, _e.prototype.writeInt16LE = function(Ue, We, lt) {
      return Ue = +Ue, We = We >>> 0, lt || wt(this, Ue, We, 2, 32767, -32768), this[We] = Ue & 255, this[We + 1] = Ue >>> 8, We + 2;
    }, _e.prototype.writeInt16BE = function(Ue, We, lt) {
      return Ue = +Ue, We = We >>> 0, lt || wt(this, Ue, We, 2, 32767, -32768), this[We] = Ue >>> 8, this[We + 1] = Ue & 255, We + 2;
    }, _e.prototype.writeInt32LE = function(Ue, We, lt) {
      return Ue = +Ue, We = We >>> 0, lt || wt(this, Ue, We, 4, 2147483647, -2147483648), this[We] = Ue & 255, this[We + 1] = Ue >>> 8, this[We + 2] = Ue >>> 16, this[We + 3] = Ue >>> 24, We + 4;
    }, _e.prototype.writeInt32BE = function(Ue, We, lt) {
      return Ue = +Ue, We = We >>> 0, lt || wt(this, Ue, We, 4, 2147483647, -2147483648), Ue < 0 && (Ue = 4294967295 + Ue + 1), this[We] = Ue >>> 24, this[We + 1] = Ue >>> 16, this[We + 2] = Ue >>> 8, this[We + 3] = Ue & 255, We + 4;
    }, _e.prototype.writeBigInt64LE = $t(function(Ue, We = 0) {
      return yt(this, Ue, We, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), _e.prototype.writeBigInt64BE = $t(function(Ue, We = 0) {
      return St(this, Ue, We, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function It(Je, Ue, We, lt, ft, Et) {
      if (We + lt > Je.length) throw new RangeError("Index out of range");
      if (We < 0) throw new RangeError("Index out of range");
    }
    function Bt(Je, Ue, We, lt, ft) {
      return Ue = +Ue, We = We >>> 0, ft || It(Je, Ue, We, 4), re.write(Je, Ue, We, lt, 23, 4), We + 4;
    }
    _e.prototype.writeFloatLE = function(Ue, We, lt) {
      return Bt(this, Ue, We, !0, lt);
    }, _e.prototype.writeFloatBE = function(Ue, We, lt) {
      return Bt(this, Ue, We, !1, lt);
    };
    function Ye(Je, Ue, We, lt, ft) {
      return Ue = +Ue, We = We >>> 0, ft || It(Je, Ue, We, 8), re.write(Je, Ue, We, lt, 52, 8), We + 8;
    }
    _e.prototype.writeDoubleLE = function(Ue, We, lt) {
      return Ye(this, Ue, We, !0, lt);
    }, _e.prototype.writeDoubleBE = function(Ue, We, lt) {
      return Ye(this, Ue, We, !1, lt);
    }, _e.prototype.copy = function(Ue, We, lt, ft) {
      if (!_e.isBuffer(Ue)) throw new TypeError("argument should be a Buffer");
      if (lt || (lt = 0), !ft && ft !== 0 && (ft = this.length), We >= Ue.length && (We = Ue.length), We || (We = 0), ft > 0 && ft < lt && (ft = lt), ft === lt || Ue.length === 0 || this.length === 0) return 0;
      if (We < 0)
        throw new RangeError("targetStart out of bounds");
      if (lt < 0 || lt >= this.length) throw new RangeError("Index out of range");
      if (ft < 0) throw new RangeError("sourceEnd out of bounds");
      ft > this.length && (ft = this.length), Ue.length - We < ft - lt && (ft = Ue.length - We + lt);
      const Et = ft - lt;
      return this === Ue && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(We, lt, ft) : Uint8Array.prototype.set.call(
        Ue,
        this.subarray(lt, ft),
        We
      ), Et;
    }, _e.prototype.fill = function(Ue, We, lt, ft) {
      if (typeof Ue == "string") {
        if (typeof We == "string" ? (ft = We, We = 0, lt = this.length) : typeof lt == "string" && (ft = lt, lt = this.length), ft !== void 0 && typeof ft != "string")
          throw new TypeError("encoding must be a string");
        if (typeof ft == "string" && !_e.isEncoding(ft))
          throw new TypeError("Unknown encoding: " + ft);
        if (Ue.length === 1) {
          const Lt = Ue.charCodeAt(0);
          (ft === "utf8" && Lt < 128 || ft === "latin1") && (Ue = Lt);
        }
      } else typeof Ue == "number" ? Ue = Ue & 255 : typeof Ue == "boolean" && (Ue = Number(Ue));
      if (We < 0 || this.length < We || this.length < lt)
        throw new RangeError("Out of range index");
      if (lt <= We)
        return this;
      We = We >>> 0, lt = lt === void 0 ? this.length : lt >>> 0, Ue || (Ue = 0);
      let Et;
      if (typeof Ue == "number")
        for (Et = We; Et < lt; ++Et)
          this[Et] = Ue;
      else {
        const Lt = _e.isBuffer(Ue) ? Ue : _e.from(Ue, ft), Kt = Lt.length;
        if (Kt === 0)
          throw new TypeError('The value "' + Ue + '" is invalid for argument "value"');
        for (Et = 0; Et < lt - We; ++Et)
          this[Et + We] = Lt[Et % Kt];
      }
      return this;
    };
    const Be = {};
    function et(Je, Ue, We) {
      Be[Je] = class extends We {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: Ue.apply(this, arguments),
            writable: !0,
            configurable: !0
          }), this.name = `${this.name} [${Je}]`, this.stack, delete this.name;
        }
        get code() {
          return Je;
        }
        set code(ft) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: ft,
            writable: !0
          });
        }
        toString() {
          return `${this.name} [${Je}]: ${this.message}`;
        }
      };
    }
    et(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(Je) {
        return Je ? `${Je} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), et(
      "ERR_INVALID_ARG_TYPE",
      function(Je, Ue) {
        return `The "${Je}" argument must be of type number. Received type ${typeof Ue}`;
      },
      TypeError
    ), et(
      "ERR_OUT_OF_RANGE",
      function(Je, Ue, We) {
        let lt = `The value of "${Je}" is out of range.`, ft = We;
        return Number.isInteger(We) && Math.abs(We) > 2 ** 32 ? ft = je(String(We)) : typeof We == "bigint" && (ft = String(We), (We > BigInt(2) ** BigInt(32) || We < -(BigInt(2) ** BigInt(32))) && (ft = je(ft)), ft += "n"), lt += ` It must be ${Ue}. Received ${ft}`, lt;
      },
      RangeError
    );
    function je(Je) {
      let Ue = "", We = Je.length;
      const lt = Je[0] === "-" ? 1 : 0;
      for (; We >= lt + 4; We -= 3)
        Ue = `_${Je.slice(We - 3, We)}${Ue}`;
      return `${Je.slice(0, We)}${Ue}`;
    }
    function it(Je, Ue, We) {
      rt(Ue, "offset"), (Je[Ue] === void 0 || Je[Ue + We] === void 0) && Ct(Ue, Je.length - (We + 1));
    }
    function bt(Je, Ue, We, lt, ft, Et) {
      if (Je > We || Je < Ue) {
        const Lt = typeof Ue == "bigint" ? "n" : "";
        let Kt;
        throw Ue === 0 || Ue === BigInt(0) ? Kt = `>= 0${Lt} and < 2${Lt} ** ${(Et + 1) * 8}${Lt}` : Kt = `>= -(2${Lt} ** ${(Et + 1) * 8 - 1}${Lt}) and < 2 ** ${(Et + 1) * 8 - 1}${Lt}`, new Be.ERR_OUT_OF_RANGE("value", Kt, Je);
      }
      it(lt, ft, Et);
    }
    function rt(Je, Ue) {
      if (typeof Je != "number")
        throw new Be.ERR_INVALID_ARG_TYPE(Ue, "number", Je);
    }
    function Ct(Je, Ue, We) {
      throw Math.floor(Je) !== Je ? (rt(Je, We), new Be.ERR_OUT_OF_RANGE("offset", "an integer", Je)) : Ue < 0 ? new Be.ERR_BUFFER_OUT_OF_BOUNDS() : new Be.ERR_OUT_OF_RANGE(
        "offset",
        `>= 0 and <= ${Ue}`,
        Je
      );
    }
    const Rt = /[^+/0-9A-Za-z-_]/g;
    function Ot(Je) {
      if (Je = Je.split("=")[0], Je = Je.trim().replace(Rt, ""), Je.length < 2) return "";
      for (; Je.length % 4 !== 0; )
        Je = Je + "=";
      return Je;
    }
    function Mt(Je, Ue) {
      Ue = Ue || 1 / 0;
      let We;
      const lt = Je.length;
      let ft = null;
      const Et = [];
      for (let Lt = 0; Lt < lt; ++Lt) {
        if (We = Je.charCodeAt(Lt), We > 55295 && We < 57344) {
          if (!ft) {
            if (We > 56319) {
              (Ue -= 3) > -1 && Et.push(239, 191, 189);
              continue;
            } else if (Lt + 1 === lt) {
              (Ue -= 3) > -1 && Et.push(239, 191, 189);
              continue;
            }
            ft = We;
            continue;
          }
          if (We < 56320) {
            (Ue -= 3) > -1 && Et.push(239, 191, 189), ft = We;
            continue;
          }
          We = (ft - 55296 << 10 | We - 56320) + 65536;
        } else ft && (Ue -= 3) > -1 && Et.push(239, 191, 189);
        if (ft = null, We < 128) {
          if ((Ue -= 1) < 0) break;
          Et.push(We);
        } else if (We < 2048) {
          if ((Ue -= 2) < 0) break;
          Et.push(
            We >> 6 | 192,
            We & 63 | 128
          );
        } else if (We < 65536) {
          if ((Ue -= 3) < 0) break;
          Et.push(
            We >> 12 | 224,
            We >> 6 & 63 | 128,
            We & 63 | 128
          );
        } else if (We < 1114112) {
          if ((Ue -= 4) < 0) break;
          Et.push(
            We >> 18 | 240,
            We >> 12 & 63 | 128,
            We >> 6 & 63 | 128,
            We & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return Et;
    }
    function Dt(Je) {
      const Ue = [];
      for (let We = 0; We < Je.length; ++We)
        Ue.push(Je.charCodeAt(We) & 255);
      return Ue;
    }
    function Vt(Je, Ue) {
      let We, lt, ft;
      const Et = [];
      for (let Lt = 0; Lt < Je.length && !((Ue -= 2) < 0); ++Lt)
        We = Je.charCodeAt(Lt), lt = We >> 8, ft = We % 256, Et.push(ft), Et.push(lt);
      return Et;
    }
    function Jt(Je) {
      return Y.toByteArray(Ot(Je));
    }
    function er(Je, Ue, We, lt) {
      let ft;
      for (ft = 0; ft < lt && !(ft + We >= Ue.length || ft >= Je.length); ++ft)
        Ue[ft + We] = Je[ft];
      return ft;
    }
    function Zt(Je, Ue) {
      return Je instanceof Ue || Je != null && Je.constructor != null && Je.constructor.name != null && Je.constructor.name === Ue.name;
    }
    function Gt(Je) {
      return Je !== Je;
    }
    const Yt = function() {
      const Je = "0123456789abcdef", Ue = new Array(256);
      for (let We = 0; We < 16; ++We) {
        const lt = We * 16;
        for (let ft = 0; ft < 16; ++ft)
          Ue[lt + ft] = Je[We] + Je[ft];
      }
      return Ue;
    }();
    function $t(Je) {
      return typeof BigInt > "u" ? ir : Je;
    }
    function ir() {
      throw new Error("BigInt not supported");
    }
  }(buffer)), buffer;
}
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(le, Y) {
    var re = requireBuffer(), oe = re.Buffer;
    function ue(he, _e) {
      for (var ve in he)
        _e[ve] = he[ve];
    }
    oe.from && oe.alloc && oe.allocUnsafe && oe.allocUnsafeSlow ? le.exports = re : (ue(re, Y), Y.Buffer = fe);
    function fe(he, _e, ve) {
      return oe(he, _e, ve);
    }
    fe.prototype = Object.create(oe.prototype), ue(oe, fe), fe.from = function(he, _e, ve) {
      if (typeof he == "number")
        throw new TypeError("Argument must not be a number");
      return oe(he, _e, ve);
    }, fe.alloc = function(he, _e, ve) {
      if (typeof he != "number")
        throw new TypeError("Argument must be a number");
      var xe = oe(he);
      return _e !== void 0 ? typeof ve == "string" ? xe.fill(_e, ve) : xe.fill(_e) : xe.fill(0), xe;
    }, fe.allocUnsafe = function(he) {
      if (typeof he != "number")
        throw new TypeError("Argument must be a number");
      return oe(he);
    }, fe.allocUnsafeSlow = function(he) {
      if (typeof he != "number")
        throw new TypeError("Argument must be a number");
      return re.SlowBuffer(he);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var le = requireSafeBuffer().Buffer, Y = le.isEncoding || function(Ae) {
    switch (Ae = "" + Ae, Ae && Ae.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function re(Ae) {
    if (!Ae) return "utf8";
    for (var Pe; ; )
      switch (Ae) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return Ae;
        default:
          if (Pe) return;
          Ae = ("" + Ae).toLowerCase(), Pe = !0;
      }
  }
  function oe(Ae) {
    var Pe = re(Ae);
    if (typeof Pe != "string" && (le.isEncoding === Y || !Y(Ae))) throw new Error("Unknown encoding: " + Ae);
    return Pe || Ae;
  }
  string_decoder.StringDecoder = ue;
  function ue(Ae) {
    this.encoding = oe(Ae);
    var Pe;
    switch (this.encoding) {
      case "utf16le":
        this.text = Se, this.end = Te, Pe = 4;
        break;
      case "utf8":
        this.fillLast = ve, Pe = 4;
        break;
      case "base64":
        this.text = Ce, this.end = Ie, Pe = 3;
        break;
      default:
        this.write = Ne, this.end = Re;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = le.allocUnsafe(Pe);
  }
  ue.prototype.write = function(Ae) {
    if (Ae.length === 0) return "";
    var Pe, Fe;
    if (this.lastNeed) {
      if (Pe = this.fillLast(Ae), Pe === void 0) return "";
      Fe = this.lastNeed, this.lastNeed = 0;
    } else
      Fe = 0;
    return Fe < Ae.length ? Pe ? Pe + this.text(Ae, Fe) : this.text(Ae, Fe) : Pe || "";
  }, ue.prototype.end = Ee, ue.prototype.text = xe, ue.prototype.fillLast = function(Ae) {
    if (this.lastNeed <= Ae.length)
      return Ae.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    Ae.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, Ae.length), this.lastNeed -= Ae.length;
  };
  function fe(Ae) {
    return Ae <= 127 ? 0 : Ae >> 5 === 6 ? 2 : Ae >> 4 === 14 ? 3 : Ae >> 3 === 30 ? 4 : Ae >> 6 === 2 ? -1 : -2;
  }
  function he(Ae, Pe, Fe) {
    var Le = Pe.length - 1;
    if (Le < Fe) return 0;
    var He = fe(Pe[Le]);
    return He >= 0 ? (He > 0 && (Ae.lastNeed = He - 1), He) : --Le < Fe || He === -2 ? 0 : (He = fe(Pe[Le]), He >= 0 ? (He > 0 && (Ae.lastNeed = He - 2), He) : --Le < Fe || He === -2 ? 0 : (He = fe(Pe[Le]), He >= 0 ? (He > 0 && (He === 2 ? He = 0 : Ae.lastNeed = He - 3), He) : 0));
  }
  function _e(Ae, Pe, Fe) {
    if ((Pe[0] & 192) !== 128)
      return Ae.lastNeed = 0, "�";
    if (Ae.lastNeed > 1 && Pe.length > 1) {
      if ((Pe[1] & 192) !== 128)
        return Ae.lastNeed = 1, "�";
      if (Ae.lastNeed > 2 && Pe.length > 2 && (Pe[2] & 192) !== 128)
        return Ae.lastNeed = 2, "�";
    }
  }
  function ve(Ae) {
    var Pe = this.lastTotal - this.lastNeed, Fe = _e(this, Ae);
    if (Fe !== void 0) return Fe;
    if (this.lastNeed <= Ae.length)
      return Ae.copy(this.lastChar, Pe, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    Ae.copy(this.lastChar, Pe, 0, Ae.length), this.lastNeed -= Ae.length;
  }
  function xe(Ae, Pe) {
    var Fe = he(this, Ae, Pe);
    if (!this.lastNeed) return Ae.toString("utf8", Pe);
    this.lastTotal = Fe;
    var Le = Ae.length - (Fe - this.lastNeed);
    return Ae.copy(this.lastChar, 0, Le), Ae.toString("utf8", Pe, Le);
  }
  function Ee(Ae) {
    var Pe = Ae && Ae.length ? this.write(Ae) : "";
    return this.lastNeed ? Pe + "�" : Pe;
  }
  function Se(Ae, Pe) {
    if ((Ae.length - Pe) % 2 === 0) {
      var Fe = Ae.toString("utf16le", Pe);
      if (Fe) {
        var Le = Fe.charCodeAt(Fe.length - 1);
        if (Le >= 55296 && Le <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = Ae[Ae.length - 2], this.lastChar[1] = Ae[Ae.length - 1], Fe.slice(0, -1);
      }
      return Fe;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = Ae[Ae.length - 1], Ae.toString("utf16le", Pe, Ae.length - 1);
  }
  function Te(Ae) {
    var Pe = Ae && Ae.length ? this.write(Ae) : "";
    if (this.lastNeed) {
      var Fe = this.lastTotal - this.lastNeed;
      return Pe + this.lastChar.toString("utf16le", 0, Fe);
    }
    return Pe;
  }
  function Ce(Ae, Pe) {
    var Fe = (Ae.length - Pe) % 3;
    return Fe === 0 ? Ae.toString("base64", Pe) : (this.lastNeed = 3 - Fe, this.lastTotal = 3, Fe === 1 ? this.lastChar[0] = Ae[Ae.length - 1] : (this.lastChar[0] = Ae[Ae.length - 2], this.lastChar[1] = Ae[Ae.length - 1]), Ae.toString("base64", Pe, Ae.length - Fe));
  }
  function Ie(Ae) {
    var Pe = Ae && Ae.length ? this.write(Ae) : "";
    return this.lastNeed ? Pe + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : Pe;
  }
  function Ne(Ae) {
    return Ae.toString(this.encoding);
  }
  function Re(Ae) {
    return Ae && Ae.length ? this.write(Ae) : "";
  }
  return string_decoder;
}
var hasRequiredSax;
function requireSax() {
  return hasRequiredSax || (hasRequiredSax = 1, function(le) {
    (function(Y) {
      Y.parser = function(Ye, Be) {
        return new oe(Ye, Be);
      }, Y.SAXParser = oe, Y.SAXStream = Ee, Y.createStream = xe, Y.MAX_BUFFER_LENGTH = 64 * 1024;
      var re = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      Y.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function oe(Ye, Be) {
        if (!(this instanceof oe))
          return new oe(Ye, Be);
        var et = this;
        fe(et), et.q = et.c = "", et.bufferCheckPosition = Y.MAX_BUFFER_LENGTH, et.opt = Be || {}, et.opt.lowercase = et.opt.lowercase || et.opt.lowercasetags, et.looseCase = et.opt.lowercase ? "toLowerCase" : "toUpperCase", et.tags = [], et.closed = et.closedRoot = et.sawRoot = !1, et.tag = et.error = null, et.strict = !!Ye, et.noscript = !!(Ye || et.opt.noscript), et.state = De.BEGIN, et.strictEntities = et.opt.strictEntities, et.ENTITIES = et.strictEntities ? Object.create(Y.XML_ENTITIES) : Object.create(Y.ENTITIES), et.attribList = [], et.opt.xmlns && (et.ns = Object.create(Ne)), et.opt.unquotedAttributeValues === void 0 && (et.opt.unquotedAttributeValues = !Ye), et.trackPosition = et.opt.position !== !1, et.trackPosition && (et.position = et.line = et.column = 0), ze(et, "onready");
      }
      Object.create || (Object.create = function(Ye) {
        function Be() {
        }
        Be.prototype = Ye;
        var et = new Be();
        return et;
      }), Object.keys || (Object.keys = function(Ye) {
        var Be = [];
        for (var et in Ye) Ye.hasOwnProperty(et) && Be.push(et);
        return Be;
      });
      function ue(Ye) {
        for (var Be = Math.max(Y.MAX_BUFFER_LENGTH, 10), et = 0, je = 0, it = re.length; je < it; je++) {
          var bt = Ye[re[je]].length;
          if (bt > Be)
            switch (re[je]) {
              case "textNode":
                Xe(Ye);
                break;
              case "cdata":
                tt(Ye, "oncdata", Ye.cdata), Ye.cdata = "";
                break;
              case "script":
                tt(Ye, "onscript", Ye.script), Ye.script = "";
                break;
              default:
                at(Ye, "Max buffer length exceeded: " + re[je]);
            }
          et = Math.max(et, bt);
        }
        var rt = Y.MAX_BUFFER_LENGTH - et;
        Ye.bufferCheckPosition = rt + Ye.position;
      }
      function fe(Ye) {
        for (var Be = 0, et = re.length; Be < et; Be++)
          Ye[re[Be]] = "";
      }
      function he(Ye) {
        Xe(Ye), Ye.cdata !== "" && (tt(Ye, "oncdata", Ye.cdata), Ye.cdata = ""), Ye.script !== "" && (tt(Ye, "onscript", Ye.script), Ye.script = "");
      }
      oe.prototype = {
        end: function() {
          qe(this);
        },
        write: Bt,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          he(this);
        }
      };
      var _e;
      try {
        _e = requireStream().Stream;
      } catch {
        _e = function() {
        };
      }
      _e || (_e = function() {
      });
      var ve = Y.EVENTS.filter(function(Ye) {
        return Ye !== "error" && Ye !== "end";
      });
      function xe(Ye, Be) {
        return new Ee(Ye, Be);
      }
      function Ee(Ye, Be) {
        if (!(this instanceof Ee))
          return new Ee(Ye, Be);
        _e.apply(this), this._parser = new oe(Ye, Be), this.writable = !0, this.readable = !0;
        var et = this;
        this._parser.onend = function() {
          et.emit("end");
        }, this._parser.onerror = function(je) {
          et.emit("error", je), et._parser.error = null;
        }, this._decoder = null, ve.forEach(function(je) {
          Object.defineProperty(et, "on" + je, {
            get: function() {
              return et._parser["on" + je];
            },
            set: function(it) {
              if (!it)
                return et.removeAllListeners(je), et._parser["on" + je] = it, it;
              et.on(je, it);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      Ee.prototype = Object.create(_e.prototype, {
        constructor: {
          value: Ee
        }
      }), Ee.prototype.write = function(Ye) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(Ye)) {
          if (!this._decoder) {
            var Be = requireString_decoder().StringDecoder;
            this._decoder = new Be("utf8");
          }
          Ye = this._decoder.write(Ye);
        }
        return this._parser.write(Ye.toString()), this.emit("data", Ye), !0;
      }, Ee.prototype.end = function(Ye) {
        return Ye && Ye.length && this.write(Ye), this._parser.end(), !0;
      }, Ee.prototype.on = function(Ye, Be) {
        var et = this;
        return !et._parser["on" + Ye] && ve.indexOf(Ye) !== -1 && (et._parser["on" + Ye] = function() {
          var je = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          je.splice(0, 0, Ye), et.emit.apply(et, je);
        }), _e.prototype.on.call(et, Ye, Be);
      };
      var Se = "[CDATA[", Te = "DOCTYPE", Ce = "http://www.w3.org/XML/1998/namespace", Ie = "http://www.w3.org/2000/xmlns/", Ne = { xml: Ce, xmlns: Ie }, Re = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, Ae = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, Pe = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, Fe = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function Le(Ye) {
        return Ye === " " || Ye === `
` || Ye === "\r" || Ye === "	";
      }
      function He(Ye) {
        return Ye === '"' || Ye === "'";
      }
      function Ge(Ye) {
        return Ye === ">" || Le(Ye);
      }
      function Ve(Ye, Be) {
        return Ye.test(Be);
      }
      function $e(Ye, Be) {
        return !Ve(Ye, Be);
      }
      var De = 0;
      Y.STATE = {
        BEGIN: De++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: De++,
        // leading whitespace
        TEXT: De++,
        // general stuff
        TEXT_ENTITY: De++,
        // &amp and such.
        OPEN_WAKA: De++,
        // <
        SGML_DECL: De++,
        // <!BLARG
        SGML_DECL_QUOTED: De++,
        // <!BLARG foo "bar
        DOCTYPE: De++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: De++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: De++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: De++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: De++,
        // <!-
        COMMENT: De++,
        // <!--
        COMMENT_ENDING: De++,
        // <!-- blah -
        COMMENT_ENDED: De++,
        // <!-- blah --
        CDATA: De++,
        // <![CDATA[ something
        CDATA_ENDING: De++,
        // ]
        CDATA_ENDING_2: De++,
        // ]]
        PROC_INST: De++,
        // <?hi
        PROC_INST_BODY: De++,
        // <?hi there
        PROC_INST_ENDING: De++,
        // <?hi "there" ?
        OPEN_TAG: De++,
        // <strong
        OPEN_TAG_SLASH: De++,
        // <strong /
        ATTRIB: De++,
        // <a
        ATTRIB_NAME: De++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: De++,
        // <a foo _
        ATTRIB_VALUE: De++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: De++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: De++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: De++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: De++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: De++,
        // <foo bar=&quot
        CLOSE_TAG: De++,
        // </a
        CLOSE_TAG_SAW_WHITE: De++,
        // </a   >
        SCRIPT: De++,
        // <script> ...
        SCRIPT_ENDING: De++
        // <script> ... <
      }, Y.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, Y.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(Y.ENTITIES).forEach(function(Ye) {
        var Be = Y.ENTITIES[Ye], et = typeof Be == "number" ? String.fromCharCode(Be) : Be;
        Y.ENTITIES[Ye] = et;
      });
      for (var Ke in Y.STATE)
        Y.STATE[Y.STATE[Ke]] = Ke;
      De = Y.STATE;
      function ze(Ye, Be, et) {
        Ye[Be] && Ye[Be](et);
      }
      function tt(Ye, Be, et) {
        Ye.textNode && Xe(Ye), ze(Ye, Be, et);
      }
      function Xe(Ye) {
        Ye.textNode = mt(Ye.opt, Ye.textNode), Ye.textNode && ze(Ye, "ontext", Ye.textNode), Ye.textNode = "";
      }
      function mt(Ye, Be) {
        return Ye.trim && (Be = Be.trim()), Ye.normalize && (Be = Be.replace(/\s+/g, " ")), Be;
      }
      function at(Ye, Be) {
        return Xe(Ye), Ye.trackPosition && (Be += `
Line: ` + Ye.line + `
Column: ` + Ye.column + `
Char: ` + Ye.c), Be = new Error(Be), Ye.error = Be, ze(Ye, "onerror", Be), Ye;
      }
      function qe(Ye) {
        return Ye.sawRoot && !Ye.closedRoot && st(Ye, "Unclosed root tag"), Ye.state !== De.BEGIN && Ye.state !== De.BEGIN_WHITESPACE && Ye.state !== De.TEXT && at(Ye, "Unexpected end"), Xe(Ye), Ye.c = "", Ye.closed = !0, ze(Ye, "onend"), oe.call(Ye, Ye.strict, Ye.opt), Ye;
      }
      function st(Ye, Be) {
        if (typeof Ye != "object" || !(Ye instanceof oe))
          throw new Error("bad call to strictFail");
        Ye.strict && at(Ye, Be);
      }
      function xt(Ye) {
        Ye.strict || (Ye.tagName = Ye.tagName[Ye.looseCase]());
        var Be = Ye.tags[Ye.tags.length - 1] || Ye, et = Ye.tag = { name: Ye.tagName, attributes: {} };
        Ye.opt.xmlns && (et.ns = Be.ns), Ye.attribList.length = 0, tt(Ye, "onopentagstart", et);
      }
      function gt(Ye, Be) {
        var et = Ye.indexOf(":"), je = et < 0 ? ["", Ye] : Ye.split(":"), it = je[0], bt = je[1];
        return Be && Ye === "xmlns" && (it = "xmlns", bt = ""), { prefix: it, local: bt };
      }
      function Ze(Ye) {
        if (Ye.strict || (Ye.attribName = Ye.attribName[Ye.looseCase]()), Ye.attribList.indexOf(Ye.attribName) !== -1 || Ye.tag.attributes.hasOwnProperty(Ye.attribName)) {
          Ye.attribName = Ye.attribValue = "";
          return;
        }
        if (Ye.opt.xmlns) {
          var Be = gt(Ye.attribName, !0), et = Be.prefix, je = Be.local;
          if (et === "xmlns")
            if (je === "xml" && Ye.attribValue !== Ce)
              st(
                Ye,
                "xml: prefix must be bound to " + Ce + `
Actual: ` + Ye.attribValue
              );
            else if (je === "xmlns" && Ye.attribValue !== Ie)
              st(
                Ye,
                "xmlns: prefix must be bound to " + Ie + `
Actual: ` + Ye.attribValue
              );
            else {
              var it = Ye.tag, bt = Ye.tags[Ye.tags.length - 1] || Ye;
              it.ns === bt.ns && (it.ns = Object.create(bt.ns)), it.ns[je] = Ye.attribValue;
            }
          Ye.attribList.push([Ye.attribName, Ye.attribValue]);
        } else
          Ye.tag.attributes[Ye.attribName] = Ye.attribValue, tt(Ye, "onattribute", {
            name: Ye.attribName,
            value: Ye.attribValue
          });
        Ye.attribName = Ye.attribValue = "";
      }
      function _t(Ye, Be) {
        if (Ye.opt.xmlns) {
          var et = Ye.tag, je = gt(Ye.tagName);
          et.prefix = je.prefix, et.local = je.local, et.uri = et.ns[je.prefix] || "", et.prefix && !et.uri && (st(Ye, "Unbound namespace prefix: " + JSON.stringify(Ye.tagName)), et.uri = je.prefix);
          var it = Ye.tags[Ye.tags.length - 1] || Ye;
          et.ns && it.ns !== et.ns && Object.keys(et.ns).forEach(function(Zt) {
            tt(Ye, "onopennamespace", {
              prefix: Zt,
              uri: et.ns[Zt]
            });
          });
          for (var bt = 0, rt = Ye.attribList.length; bt < rt; bt++) {
            var Ct = Ye.attribList[bt], Rt = Ct[0], Ot = Ct[1], Mt = gt(Rt, !0), Dt = Mt.prefix, Vt = Mt.local, Jt = Dt === "" ? "" : et.ns[Dt] || "", er = {
              name: Rt,
              value: Ot,
              prefix: Dt,
              local: Vt,
              uri: Jt
            };
            Dt && Dt !== "xmlns" && !Jt && (st(Ye, "Unbound namespace prefix: " + JSON.stringify(Dt)), er.uri = Dt), Ye.tag.attributes[Rt] = er, tt(Ye, "onattribute", er);
          }
          Ye.attribList.length = 0;
        }
        Ye.tag.isSelfClosing = !!Be, Ye.sawRoot = !0, Ye.tags.push(Ye.tag), tt(Ye, "onopentag", Ye.tag), Be || (!Ye.noscript && Ye.tagName.toLowerCase() === "script" ? Ye.state = De.SCRIPT : Ye.state = De.TEXT, Ye.tag = null, Ye.tagName = ""), Ye.attribName = Ye.attribValue = "", Ye.attribList.length = 0;
      }
      function wt(Ye) {
        if (!Ye.tagName) {
          st(Ye, "Weird empty close tag."), Ye.textNode += "</>", Ye.state = De.TEXT;
          return;
        }
        if (Ye.script) {
          if (Ye.tagName !== "script") {
            Ye.script += "</" + Ye.tagName + ">", Ye.tagName = "", Ye.state = De.SCRIPT;
            return;
          }
          tt(Ye, "onscript", Ye.script), Ye.script = "";
        }
        var Be = Ye.tags.length, et = Ye.tagName;
        Ye.strict || (et = et[Ye.looseCase]());
        for (var je = et; Be--; ) {
          var it = Ye.tags[Be];
          if (it.name !== je)
            st(Ye, "Unexpected close tag");
          else
            break;
        }
        if (Be < 0) {
          st(Ye, "Unmatched closing tag: " + Ye.tagName), Ye.textNode += "</" + Ye.tagName + ">", Ye.state = De.TEXT;
          return;
        }
        Ye.tagName = et;
        for (var bt = Ye.tags.length; bt-- > Be; ) {
          var rt = Ye.tag = Ye.tags.pop();
          Ye.tagName = Ye.tag.name, tt(Ye, "onclosetag", Ye.tagName);
          var Ct = {};
          for (var Rt in rt.ns)
            Ct[Rt] = rt.ns[Rt];
          var Ot = Ye.tags[Ye.tags.length - 1] || Ye;
          Ye.opt.xmlns && rt.ns !== Ot.ns && Object.keys(rt.ns).forEach(function(Mt) {
            var Dt = rt.ns[Mt];
            tt(Ye, "onclosenamespace", { prefix: Mt, uri: Dt });
          });
        }
        Be === 0 && (Ye.closedRoot = !0), Ye.tagName = Ye.attribValue = Ye.attribName = "", Ye.attribList.length = 0, Ye.state = De.TEXT;
      }
      function yt(Ye) {
        var Be = Ye.entity, et = Be.toLowerCase(), je, it = "";
        return Ye.ENTITIES[Be] ? Ye.ENTITIES[Be] : Ye.ENTITIES[et] ? Ye.ENTITIES[et] : (Be = et, Be.charAt(0) === "#" && (Be.charAt(1) === "x" ? (Be = Be.slice(2), je = parseInt(Be, 16), it = je.toString(16)) : (Be = Be.slice(1), je = parseInt(Be, 10), it = je.toString(10))), Be = Be.replace(/^0+/, ""), isNaN(je) || it.toLowerCase() !== Be ? (st(Ye, "Invalid character entity"), "&" + Ye.entity + ";") : String.fromCodePoint(je));
      }
      function St(Ye, Be) {
        Be === "<" ? (Ye.state = De.OPEN_WAKA, Ye.startTagPosition = Ye.position) : Le(Be) || (st(Ye, "Non-whitespace before first tag."), Ye.textNode = Be, Ye.state = De.TEXT);
      }
      function It(Ye, Be) {
        var et = "";
        return Be < Ye.length && (et = Ye.charAt(Be)), et;
      }
      function Bt(Ye) {
        var Be = this;
        if (this.error)
          throw this.error;
        if (Be.closed)
          return at(
            Be,
            "Cannot write after close. Assign an onready handler."
          );
        if (Ye === null)
          return qe(Be);
        typeof Ye == "object" && (Ye = Ye.toString());
        for (var et = 0, je = ""; je = It(Ye, et++), Be.c = je, !!je; )
          switch (Be.trackPosition && (Be.position++, je === `
` ? (Be.line++, Be.column = 0) : Be.column++), Be.state) {
            case De.BEGIN:
              if (Be.state = De.BEGIN_WHITESPACE, je === "\uFEFF")
                continue;
              St(Be, je);
              continue;
            case De.BEGIN_WHITESPACE:
              St(Be, je);
              continue;
            case De.TEXT:
              if (Be.sawRoot && !Be.closedRoot) {
                for (var it = et - 1; je && je !== "<" && je !== "&"; )
                  je = It(Ye, et++), je && Be.trackPosition && (Be.position++, je === `
` ? (Be.line++, Be.column = 0) : Be.column++);
                Be.textNode += Ye.substring(it, et - 1);
              }
              je === "<" && !(Be.sawRoot && Be.closedRoot && !Be.strict) ? (Be.state = De.OPEN_WAKA, Be.startTagPosition = Be.position) : (!Le(je) && (!Be.sawRoot || Be.closedRoot) && st(Be, "Text data outside of root node."), je === "&" ? Be.state = De.TEXT_ENTITY : Be.textNode += je);
              continue;
            case De.SCRIPT:
              je === "<" ? Be.state = De.SCRIPT_ENDING : Be.script += je;
              continue;
            case De.SCRIPT_ENDING:
              je === "/" ? Be.state = De.CLOSE_TAG : (Be.script += "<" + je, Be.state = De.SCRIPT);
              continue;
            case De.OPEN_WAKA:
              if (je === "!")
                Be.state = De.SGML_DECL, Be.sgmlDecl = "";
              else if (!Le(je)) if (Ve(Re, je))
                Be.state = De.OPEN_TAG, Be.tagName = je;
              else if (je === "/")
                Be.state = De.CLOSE_TAG, Be.tagName = "";
              else if (je === "?")
                Be.state = De.PROC_INST, Be.procInstName = Be.procInstBody = "";
              else {
                if (st(Be, "Unencoded <"), Be.startTagPosition + 1 < Be.position) {
                  var bt = Be.position - Be.startTagPosition;
                  je = new Array(bt).join(" ") + je;
                }
                Be.textNode += "<" + je, Be.state = De.TEXT;
              }
              continue;
            case De.SGML_DECL:
              if (Be.sgmlDecl + je === "--") {
                Be.state = De.COMMENT, Be.comment = "", Be.sgmlDecl = "";
                continue;
              }
              Be.doctype && Be.doctype !== !0 && Be.sgmlDecl ? (Be.state = De.DOCTYPE_DTD, Be.doctype += "<!" + Be.sgmlDecl + je, Be.sgmlDecl = "") : (Be.sgmlDecl + je).toUpperCase() === Se ? (tt(Be, "onopencdata"), Be.state = De.CDATA, Be.sgmlDecl = "", Be.cdata = "") : (Be.sgmlDecl + je).toUpperCase() === Te ? (Be.state = De.DOCTYPE, (Be.doctype || Be.sawRoot) && st(
                Be,
                "Inappropriately located doctype declaration"
              ), Be.doctype = "", Be.sgmlDecl = "") : je === ">" ? (tt(Be, "onsgmldeclaration", Be.sgmlDecl), Be.sgmlDecl = "", Be.state = De.TEXT) : (He(je) && (Be.state = De.SGML_DECL_QUOTED), Be.sgmlDecl += je);
              continue;
            case De.SGML_DECL_QUOTED:
              je === Be.q && (Be.state = De.SGML_DECL, Be.q = ""), Be.sgmlDecl += je;
              continue;
            case De.DOCTYPE:
              je === ">" ? (Be.state = De.TEXT, tt(Be, "ondoctype", Be.doctype), Be.doctype = !0) : (Be.doctype += je, je === "[" ? Be.state = De.DOCTYPE_DTD : He(je) && (Be.state = De.DOCTYPE_QUOTED, Be.q = je));
              continue;
            case De.DOCTYPE_QUOTED:
              Be.doctype += je, je === Be.q && (Be.q = "", Be.state = De.DOCTYPE);
              continue;
            case De.DOCTYPE_DTD:
              je === "]" ? (Be.doctype += je, Be.state = De.DOCTYPE) : je === "<" ? (Be.state = De.OPEN_WAKA, Be.startTagPosition = Be.position) : He(je) ? (Be.doctype += je, Be.state = De.DOCTYPE_DTD_QUOTED, Be.q = je) : Be.doctype += je;
              continue;
            case De.DOCTYPE_DTD_QUOTED:
              Be.doctype += je, je === Be.q && (Be.state = De.DOCTYPE_DTD, Be.q = "");
              continue;
            case De.COMMENT:
              je === "-" ? Be.state = De.COMMENT_ENDING : Be.comment += je;
              continue;
            case De.COMMENT_ENDING:
              je === "-" ? (Be.state = De.COMMENT_ENDED, Be.comment = mt(Be.opt, Be.comment), Be.comment && tt(Be, "oncomment", Be.comment), Be.comment = "") : (Be.comment += "-" + je, Be.state = De.COMMENT);
              continue;
            case De.COMMENT_ENDED:
              je !== ">" ? (st(Be, "Malformed comment"), Be.comment += "--" + je, Be.state = De.COMMENT) : Be.doctype && Be.doctype !== !0 ? Be.state = De.DOCTYPE_DTD : Be.state = De.TEXT;
              continue;
            case De.CDATA:
              je === "]" ? Be.state = De.CDATA_ENDING : Be.cdata += je;
              continue;
            case De.CDATA_ENDING:
              je === "]" ? Be.state = De.CDATA_ENDING_2 : (Be.cdata += "]" + je, Be.state = De.CDATA);
              continue;
            case De.CDATA_ENDING_2:
              je === ">" ? (Be.cdata && tt(Be, "oncdata", Be.cdata), tt(Be, "onclosecdata"), Be.cdata = "", Be.state = De.TEXT) : je === "]" ? Be.cdata += "]" : (Be.cdata += "]]" + je, Be.state = De.CDATA);
              continue;
            case De.PROC_INST:
              je === "?" ? Be.state = De.PROC_INST_ENDING : Le(je) ? Be.state = De.PROC_INST_BODY : Be.procInstName += je;
              continue;
            case De.PROC_INST_BODY:
              if (!Be.procInstBody && Le(je))
                continue;
              je === "?" ? Be.state = De.PROC_INST_ENDING : Be.procInstBody += je;
              continue;
            case De.PROC_INST_ENDING:
              je === ">" ? (tt(Be, "onprocessinginstruction", {
                name: Be.procInstName,
                body: Be.procInstBody
              }), Be.procInstName = Be.procInstBody = "", Be.state = De.TEXT) : (Be.procInstBody += "?" + je, Be.state = De.PROC_INST_BODY);
              continue;
            case De.OPEN_TAG:
              Ve(Ae, je) ? Be.tagName += je : (xt(Be), je === ">" ? _t(Be) : je === "/" ? Be.state = De.OPEN_TAG_SLASH : (Le(je) || st(Be, "Invalid character in tag name"), Be.state = De.ATTRIB));
              continue;
            case De.OPEN_TAG_SLASH:
              je === ">" ? (_t(Be, !0), wt(Be)) : (st(Be, "Forward-slash in opening tag not followed by >"), Be.state = De.ATTRIB);
              continue;
            case De.ATTRIB:
              if (Le(je))
                continue;
              je === ">" ? _t(Be) : je === "/" ? Be.state = De.OPEN_TAG_SLASH : Ve(Re, je) ? (Be.attribName = je, Be.attribValue = "", Be.state = De.ATTRIB_NAME) : st(Be, "Invalid attribute name");
              continue;
            case De.ATTRIB_NAME:
              je === "=" ? Be.state = De.ATTRIB_VALUE : je === ">" ? (st(Be, "Attribute without value"), Be.attribValue = Be.attribName, Ze(Be), _t(Be)) : Le(je) ? Be.state = De.ATTRIB_NAME_SAW_WHITE : Ve(Ae, je) ? Be.attribName += je : st(Be, "Invalid attribute name");
              continue;
            case De.ATTRIB_NAME_SAW_WHITE:
              if (je === "=")
                Be.state = De.ATTRIB_VALUE;
              else {
                if (Le(je))
                  continue;
                st(Be, "Attribute without value"), Be.tag.attributes[Be.attribName] = "", Be.attribValue = "", tt(Be, "onattribute", {
                  name: Be.attribName,
                  value: ""
                }), Be.attribName = "", je === ">" ? _t(Be) : Ve(Re, je) ? (Be.attribName = je, Be.state = De.ATTRIB_NAME) : (st(Be, "Invalid attribute name"), Be.state = De.ATTRIB);
              }
              continue;
            case De.ATTRIB_VALUE:
              if (Le(je))
                continue;
              He(je) ? (Be.q = je, Be.state = De.ATTRIB_VALUE_QUOTED) : (Be.opt.unquotedAttributeValues || at(Be, "Unquoted attribute value"), Be.state = De.ATTRIB_VALUE_UNQUOTED, Be.attribValue = je);
              continue;
            case De.ATTRIB_VALUE_QUOTED:
              if (je !== Be.q) {
                je === "&" ? Be.state = De.ATTRIB_VALUE_ENTITY_Q : Be.attribValue += je;
                continue;
              }
              Ze(Be), Be.q = "", Be.state = De.ATTRIB_VALUE_CLOSED;
              continue;
            case De.ATTRIB_VALUE_CLOSED:
              Le(je) ? Be.state = De.ATTRIB : je === ">" ? _t(Be) : je === "/" ? Be.state = De.OPEN_TAG_SLASH : Ve(Re, je) ? (st(Be, "No whitespace between attributes"), Be.attribName = je, Be.attribValue = "", Be.state = De.ATTRIB_NAME) : st(Be, "Invalid attribute name");
              continue;
            case De.ATTRIB_VALUE_UNQUOTED:
              if (!Ge(je)) {
                je === "&" ? Be.state = De.ATTRIB_VALUE_ENTITY_U : Be.attribValue += je;
                continue;
              }
              Ze(Be), je === ">" ? _t(Be) : Be.state = De.ATTRIB;
              continue;
            case De.CLOSE_TAG:
              if (Be.tagName)
                je === ">" ? wt(Be) : Ve(Ae, je) ? Be.tagName += je : Be.script ? (Be.script += "</" + Be.tagName, Be.tagName = "", Be.state = De.SCRIPT) : (Le(je) || st(Be, "Invalid tagname in closing tag"), Be.state = De.CLOSE_TAG_SAW_WHITE);
              else {
                if (Le(je))
                  continue;
                $e(Re, je) ? Be.script ? (Be.script += "</" + je, Be.state = De.SCRIPT) : st(Be, "Invalid tagname in closing tag.") : Be.tagName = je;
              }
              continue;
            case De.CLOSE_TAG_SAW_WHITE:
              if (Le(je))
                continue;
              je === ">" ? wt(Be) : st(Be, "Invalid characters in closing tag");
              continue;
            case De.TEXT_ENTITY:
            case De.ATTRIB_VALUE_ENTITY_Q:
            case De.ATTRIB_VALUE_ENTITY_U:
              var rt, Ct;
              switch (Be.state) {
                case De.TEXT_ENTITY:
                  rt = De.TEXT, Ct = "textNode";
                  break;
                case De.ATTRIB_VALUE_ENTITY_Q:
                  rt = De.ATTRIB_VALUE_QUOTED, Ct = "attribValue";
                  break;
                case De.ATTRIB_VALUE_ENTITY_U:
                  rt = De.ATTRIB_VALUE_UNQUOTED, Ct = "attribValue";
                  break;
              }
              if (je === ";") {
                var Rt = yt(Be);
                Be.opt.unparsedEntities && !Object.values(Y.XML_ENTITIES).includes(Rt) ? (Be.entity = "", Be.state = rt, Be.write(Rt)) : (Be[Ct] += Rt, Be.entity = "", Be.state = rt);
              } else Ve(Be.entity.length ? Fe : Pe, je) ? Be.entity += je : (st(Be, "Invalid character in entity name"), Be[Ct] += "&" + Be.entity + je, Be.entity = "", Be.state = rt);
              continue;
            default:
              throw new Error(Be, "Unknown state: " + Be.state);
          }
        return Be.position >= Be.bufferCheckPosition && ue(Be), Be;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      String.fromCodePoint || function() {
        var Ye = String.fromCharCode, Be = Math.floor, et = function() {
          var je = 16384, it = [], bt, rt, Ct = -1, Rt = arguments.length;
          if (!Rt)
            return "";
          for (var Ot = ""; ++Ct < Rt; ) {
            var Mt = Number(arguments[Ct]);
            if (!isFinite(Mt) || // `NaN`, `+Infinity`, or `-Infinity`
            Mt < 0 || // not a valid Unicode code point
            Mt > 1114111 || // not a valid Unicode code point
            Be(Mt) !== Mt)
              throw RangeError("Invalid code point: " + Mt);
            Mt <= 65535 ? it.push(Mt) : (Mt -= 65536, bt = (Mt >> 10) + 55296, rt = Mt % 1024 + 56320, it.push(bt, rt)), (Ct + 1 === Rt || it.length > je) && (Ot += Ye.apply(null, it), it.length = 0);
          }
          return Ot;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: et,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = et;
      }();
    })(le);
  }(sax)), sax;
}
var arrayHelper$1, hasRequiredArrayHelper$1;
function requireArrayHelper$1() {
  return hasRequiredArrayHelper$1 || (hasRequiredArrayHelper$1 = 1, arrayHelper$1 = {
    isArray: function(le) {
      return Array.isArray ? Array.isArray(le) : Object.prototype.toString.call(le) === "[object Array]";
    }
  }), arrayHelper$1;
}
var optionsHelper$1, hasRequiredOptionsHelper$1;
function requireOptionsHelper$1() {
  if (hasRequiredOptionsHelper$1) return optionsHelper$1;
  hasRequiredOptionsHelper$1 = 1;
  var le = requireArrayHelper$1().isArray;
  return optionsHelper$1 = {
    copyOptions: function(Y) {
      var re, oe = {};
      for (re in Y)
        Y.hasOwnProperty(re) && (oe[re] = Y[re]);
      return oe;
    },
    ensureFlagExists: function(Y, re) {
      (!(Y in re) || typeof re[Y] != "boolean") && (re[Y] = !1);
    },
    ensureSpacesExists: function(Y) {
      (!("spaces" in Y) || typeof Y.spaces != "number" && typeof Y.spaces != "string") && (Y.spaces = 0);
    },
    ensureAlwaysArrayExists: function(Y) {
      (!("alwaysArray" in Y) || typeof Y.alwaysArray != "boolean" && !le(Y.alwaysArray)) && (Y.alwaysArray = !1);
    },
    ensureKeyExists: function(Y, re) {
      (!(Y + "Key" in re) || typeof re[Y + "Key"] != "string") && (re[Y + "Key"] = re.compact ? "_" + Y : Y);
    },
    checkFnExists: function(Y, re) {
      return Y + "Fn" in re;
    }
  }, optionsHelper$1;
}
var xml2js$1, hasRequiredXml2js$1;
function requireXml2js$1() {
  if (hasRequiredXml2js$1) return xml2js$1;
  hasRequiredXml2js$1 = 1;
  var le = requireSax(), Y = requireOptionsHelper$1(), re = requireArrayHelper$1().isArray, oe, ue;
  function fe(Ae) {
    return oe = Y.copyOptions(Ae), Y.ensureFlagExists("ignoreDeclaration", oe), Y.ensureFlagExists("ignoreInstruction", oe), Y.ensureFlagExists("ignoreAttributes", oe), Y.ensureFlagExists("ignoreText", oe), Y.ensureFlagExists("ignoreComment", oe), Y.ensureFlagExists("ignoreCdata", oe), Y.ensureFlagExists("ignoreDoctype", oe), Y.ensureFlagExists("compact", oe), Y.ensureFlagExists("alwaysChildren", oe), Y.ensureFlagExists("addParent", oe), Y.ensureFlagExists("trim", oe), Y.ensureFlagExists("nativeType", oe), Y.ensureFlagExists("nativeTypeAttributes", oe), Y.ensureFlagExists("sanitize", oe), Y.ensureFlagExists("instructionHasAttributes", oe), Y.ensureFlagExists("captureSpacesBetweenElements", oe), Y.ensureAlwaysArrayExists(oe), Y.ensureKeyExists("declaration", oe), Y.ensureKeyExists("instruction", oe), Y.ensureKeyExists("attributes", oe), Y.ensureKeyExists("text", oe), Y.ensureKeyExists("comment", oe), Y.ensureKeyExists("cdata", oe), Y.ensureKeyExists("doctype", oe), Y.ensureKeyExists("type", oe), Y.ensureKeyExists("name", oe), Y.ensureKeyExists("elements", oe), Y.ensureKeyExists("parent", oe), Y.checkFnExists("doctype", oe), Y.checkFnExists("instruction", oe), Y.checkFnExists("cdata", oe), Y.checkFnExists("comment", oe), Y.checkFnExists("text", oe), Y.checkFnExists("instructionName", oe), Y.checkFnExists("elementName", oe), Y.checkFnExists("attributeName", oe), Y.checkFnExists("attributeValue", oe), Y.checkFnExists("attributes", oe), oe;
  }
  function he(Ae) {
    var Pe = Number(Ae);
    if (!isNaN(Pe))
      return Pe;
    var Fe = Ae.toLowerCase();
    return Fe === "true" ? !0 : Fe === "false" ? !1 : Ae;
  }
  function _e(Ae, Pe) {
    var Fe;
    if (oe.compact) {
      if (!ue[oe[Ae + "Key"]] && (re(oe.alwaysArray) ? oe.alwaysArray.indexOf(oe[Ae + "Key"]) !== -1 : oe.alwaysArray) && (ue[oe[Ae + "Key"]] = []), ue[oe[Ae + "Key"]] && !re(ue[oe[Ae + "Key"]]) && (ue[oe[Ae + "Key"]] = [ue[oe[Ae + "Key"]]]), Ae + "Fn" in oe && typeof Pe == "string" && (Pe = oe[Ae + "Fn"](Pe, ue)), Ae === "instruction" && ("instructionFn" in oe || "instructionNameFn" in oe)) {
        for (Fe in Pe)
          if (Pe.hasOwnProperty(Fe))
            if ("instructionFn" in oe)
              Pe[Fe] = oe.instructionFn(Pe[Fe], Fe, ue);
            else {
              var Le = Pe[Fe];
              delete Pe[Fe], Pe[oe.instructionNameFn(Fe, Le, ue)] = Le;
            }
      }
      re(ue[oe[Ae + "Key"]]) ? ue[oe[Ae + "Key"]].push(Pe) : ue[oe[Ae + "Key"]] = Pe;
    } else {
      ue[oe.elementsKey] || (ue[oe.elementsKey] = []);
      var He = {};
      if (He[oe.typeKey] = Ae, Ae === "instruction") {
        for (Fe in Pe)
          if (Pe.hasOwnProperty(Fe))
            break;
        He[oe.nameKey] = "instructionNameFn" in oe ? oe.instructionNameFn(Fe, Pe, ue) : Fe, oe.instructionHasAttributes ? (He[oe.attributesKey] = Pe[Fe][oe.attributesKey], "instructionFn" in oe && (He[oe.attributesKey] = oe.instructionFn(He[oe.attributesKey], Fe, ue))) : ("instructionFn" in oe && (Pe[Fe] = oe.instructionFn(Pe[Fe], Fe, ue)), He[oe.instructionKey] = Pe[Fe]);
      } else
        Ae + "Fn" in oe && (Pe = oe[Ae + "Fn"](Pe, ue)), He[oe[Ae + "Key"]] = Pe;
      oe.addParent && (He[oe.parentKey] = ue), ue[oe.elementsKey].push(He);
    }
  }
  function ve(Ae) {
    if ("attributesFn" in oe && Ae && (Ae = oe.attributesFn(Ae, ue)), (oe.trim || "attributeValueFn" in oe || "attributeNameFn" in oe || oe.nativeTypeAttributes) && Ae) {
      var Pe;
      for (Pe in Ae)
        if (Ae.hasOwnProperty(Pe) && (oe.trim && (Ae[Pe] = Ae[Pe].trim()), oe.nativeTypeAttributes && (Ae[Pe] = he(Ae[Pe])), "attributeValueFn" in oe && (Ae[Pe] = oe.attributeValueFn(Ae[Pe], Pe, ue)), "attributeNameFn" in oe)) {
          var Fe = Ae[Pe];
          delete Ae[Pe], Ae[oe.attributeNameFn(Pe, Ae[Pe], ue)] = Fe;
        }
    }
    return Ae;
  }
  function xe(Ae) {
    var Pe = {};
    if (Ae.body && (Ae.name.toLowerCase() === "xml" || oe.instructionHasAttributes)) {
      for (var Fe = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g, Le; (Le = Fe.exec(Ae.body)) !== null; )
        Pe[Le[1]] = Le[2] || Le[3] || Le[4];
      Pe = ve(Pe);
    }
    if (Ae.name.toLowerCase() === "xml") {
      if (oe.ignoreDeclaration)
        return;
      ue[oe.declarationKey] = {}, Object.keys(Pe).length && (ue[oe.declarationKey][oe.attributesKey] = Pe), oe.addParent && (ue[oe.declarationKey][oe.parentKey] = ue);
    } else {
      if (oe.ignoreInstruction)
        return;
      oe.trim && (Ae.body = Ae.body.trim());
      var He = {};
      oe.instructionHasAttributes && Object.keys(Pe).length ? (He[Ae.name] = {}, He[Ae.name][oe.attributesKey] = Pe) : He[Ae.name] = Ae.body, _e("instruction", He);
    }
  }
  function Ee(Ae, Pe) {
    var Fe;
    if (typeof Ae == "object" && (Pe = Ae.attributes, Ae = Ae.name), Pe = ve(Pe), "elementNameFn" in oe && (Ae = oe.elementNameFn(Ae, ue)), oe.compact) {
      if (Fe = {}, !oe.ignoreAttributes && Pe && Object.keys(Pe).length) {
        Fe[oe.attributesKey] = {};
        var Le;
        for (Le in Pe)
          Pe.hasOwnProperty(Le) && (Fe[oe.attributesKey][Le] = Pe[Le]);
      }
      !(Ae in ue) && (re(oe.alwaysArray) ? oe.alwaysArray.indexOf(Ae) !== -1 : oe.alwaysArray) && (ue[Ae] = []), ue[Ae] && !re(ue[Ae]) && (ue[Ae] = [ue[Ae]]), re(ue[Ae]) ? ue[Ae].push(Fe) : ue[Ae] = Fe;
    } else
      ue[oe.elementsKey] || (ue[oe.elementsKey] = []), Fe = {}, Fe[oe.typeKey] = "element", Fe[oe.nameKey] = Ae, !oe.ignoreAttributes && Pe && Object.keys(Pe).length && (Fe[oe.attributesKey] = Pe), oe.alwaysChildren && (Fe[oe.elementsKey] = []), ue[oe.elementsKey].push(Fe);
    Fe[oe.parentKey] = ue, ue = Fe;
  }
  function Se(Ae) {
    oe.ignoreText || !Ae.trim() && !oe.captureSpacesBetweenElements || (oe.trim && (Ae = Ae.trim()), oe.nativeType && (Ae = he(Ae)), oe.sanitize && (Ae = Ae.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")), _e("text", Ae));
  }
  function Te(Ae) {
    oe.ignoreComment || (oe.trim && (Ae = Ae.trim()), _e("comment", Ae));
  }
  function Ce(Ae) {
    var Pe = ue[oe.parentKey];
    oe.addParent || delete ue[oe.parentKey], ue = Pe;
  }
  function Ie(Ae) {
    oe.ignoreCdata || (oe.trim && (Ae = Ae.trim()), _e("cdata", Ae));
  }
  function Ne(Ae) {
    oe.ignoreDoctype || (Ae = Ae.replace(/^ /, ""), oe.trim && (Ae = Ae.trim()), _e("doctype", Ae));
  }
  function Re(Ae) {
    Ae.note = Ae;
  }
  return xml2js$1 = function(Ae, Pe) {
    var Fe = le.parser(!0, {}), Le = {};
    if (ue = Le, oe = fe(Pe), Fe.opt = { strictEntities: !0 }, Fe.onopentag = Ee, Fe.ontext = Se, Fe.oncomment = Te, Fe.onclosetag = Ce, Fe.onerror = Re, Fe.oncdata = Ie, Fe.ondoctype = Ne, Fe.onprocessinginstruction = xe, Fe.write(Ae).close(), Le[oe.elementsKey]) {
      var He = Le[oe.elementsKey];
      delete Le[oe.elementsKey], Le[oe.elementsKey] = He, delete Le.text;
    }
    return Le;
  }, xml2js$1;
}
var xml2json$1, hasRequiredXml2json$1;
function requireXml2json$1() {
  if (hasRequiredXml2json$1) return xml2json$1;
  hasRequiredXml2json$1 = 1;
  var le = requireOptionsHelper$1(), Y = requireXml2js$1();
  function re(oe) {
    var ue = le.copyOptions(oe);
    return le.ensureSpacesExists(ue), ue;
  }
  return xml2json$1 = function(oe, ue) {
    var fe, he, _e, ve;
    return fe = re(ue), he = Y(oe, fe), ve = "compact" in fe && fe.compact ? "_parent" : "parent", "addParent" in fe && fe.addParent ? _e = JSON.stringify(he, function(xe, Ee) {
      return xe === ve ? "_" : Ee;
    }, fe.spaces) : _e = JSON.stringify(he, null, fe.spaces), _e.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }, xml2json$1;
}
var js2xml$1, hasRequiredJs2xml$1;
function requireJs2xml$1() {
  if (hasRequiredJs2xml$1) return js2xml$1;
  hasRequiredJs2xml$1 = 1;
  var le = requireOptionsHelper$1(), Y = requireArrayHelper$1().isArray, re, oe;
  function ue(Fe) {
    var Le = le.copyOptions(Fe);
    return le.ensureFlagExists("ignoreDeclaration", Le), le.ensureFlagExists("ignoreInstruction", Le), le.ensureFlagExists("ignoreAttributes", Le), le.ensureFlagExists("ignoreText", Le), le.ensureFlagExists("ignoreComment", Le), le.ensureFlagExists("ignoreCdata", Le), le.ensureFlagExists("ignoreDoctype", Le), le.ensureFlagExists("compact", Le), le.ensureFlagExists("indentText", Le), le.ensureFlagExists("indentCdata", Le), le.ensureFlagExists("indentAttributes", Le), le.ensureFlagExists("indentInstruction", Le), le.ensureFlagExists("fullTagEmptyElement", Le), le.ensureFlagExists("noQuotesForNativeAttributes", Le), le.ensureSpacesExists(Le), typeof Le.spaces == "number" && (Le.spaces = Array(Le.spaces + 1).join(" ")), le.ensureKeyExists("declaration", Le), le.ensureKeyExists("instruction", Le), le.ensureKeyExists("attributes", Le), le.ensureKeyExists("text", Le), le.ensureKeyExists("comment", Le), le.ensureKeyExists("cdata", Le), le.ensureKeyExists("doctype", Le), le.ensureKeyExists("type", Le), le.ensureKeyExists("name", Le), le.ensureKeyExists("elements", Le), le.checkFnExists("doctype", Le), le.checkFnExists("instruction", Le), le.checkFnExists("cdata", Le), le.checkFnExists("comment", Le), le.checkFnExists("text", Le), le.checkFnExists("instructionName", Le), le.checkFnExists("elementName", Le), le.checkFnExists("attributeName", Le), le.checkFnExists("attributeValue", Le), le.checkFnExists("attributes", Le), le.checkFnExists("fullTagEmptyElement", Le), Le;
  }
  function fe(Fe, Le, He) {
    return (!He && Fe.spaces ? `
` : "") + Array(Le + 1).join(Fe.spaces);
  }
  function he(Fe, Le, He) {
    if (Le.ignoreAttributes)
      return "";
    "attributesFn" in Le && (Fe = Le.attributesFn(Fe, oe, re));
    var Ge, Ve, $e, De, Ke = [];
    for (Ge in Fe)
      Fe.hasOwnProperty(Ge) && Fe[Ge] !== null && Fe[Ge] !== void 0 && (De = Le.noQuotesForNativeAttributes && typeof Fe[Ge] != "string" ? "" : '"', Ve = "" + Fe[Ge], Ve = Ve.replace(/"/g, "&quot;"), $e = "attributeNameFn" in Le ? Le.attributeNameFn(Ge, Ve, oe, re) : Ge, Ke.push(Le.spaces && Le.indentAttributes ? fe(Le, He + 1, !1) : " "), Ke.push($e + "=" + De + ("attributeValueFn" in Le ? Le.attributeValueFn(Ve, Ge, oe, re) : Ve) + De));
    return Fe && Object.keys(Fe).length && Le.spaces && Le.indentAttributes && Ke.push(fe(Le, He, !1)), Ke.join("");
  }
  function _e(Fe, Le, He) {
    return re = Fe, oe = "xml", Le.ignoreDeclaration ? "" : "<?xml" + he(Fe[Le.attributesKey], Le, He) + "?>";
  }
  function ve(Fe, Le, He) {
    if (Le.ignoreInstruction)
      return "";
    var Ge;
    for (Ge in Fe)
      if (Fe.hasOwnProperty(Ge))
        break;
    var Ve = "instructionNameFn" in Le ? Le.instructionNameFn(Ge, Fe[Ge], oe, re) : Ge;
    if (typeof Fe[Ge] == "object")
      return re = Fe, oe = Ve, "<?" + Ve + he(Fe[Ge][Le.attributesKey], Le, He) + "?>";
    var $e = Fe[Ge] ? Fe[Ge] : "";
    return "instructionFn" in Le && ($e = Le.instructionFn($e, Ge, oe, re)), "<?" + Ve + ($e ? " " + $e : "") + "?>";
  }
  function xe(Fe, Le) {
    return Le.ignoreComment ? "" : "<!--" + ("commentFn" in Le ? Le.commentFn(Fe, oe, re) : Fe) + "-->";
  }
  function Ee(Fe, Le) {
    return Le.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in Le ? Le.cdataFn(Fe, oe, re) : Fe.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
  }
  function Se(Fe, Le) {
    return Le.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in Le ? Le.doctypeFn(Fe, oe, re) : Fe) + ">";
  }
  function Te(Fe, Le) {
    return Le.ignoreText ? "" : (Fe = "" + Fe, Fe = Fe.replace(/&amp;/g, "&"), Fe = Fe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), "textFn" in Le ? Le.textFn(Fe, oe, re) : Fe);
  }
  function Ce(Fe, Le) {
    var He;
    if (Fe.elements && Fe.elements.length)
      for (He = 0; He < Fe.elements.length; ++He)
        switch (Fe.elements[He][Le.typeKey]) {
          case "text":
            if (Le.indentText)
              return !0;
            break;
          // skip to next key
          case "cdata":
            if (Le.indentCdata)
              return !0;
            break;
          // skip to next key
          case "instruction":
            if (Le.indentInstruction)
              return !0;
            break;
          // skip to next key
          case "doctype":
          case "comment":
          case "element":
            return !0;
          default:
            return !0;
        }
    return !1;
  }
  function Ie(Fe, Le, He) {
    re = Fe, oe = Fe.name;
    var Ge = [], Ve = "elementNameFn" in Le ? Le.elementNameFn(Fe.name, Fe) : Fe.name;
    Ge.push("<" + Ve), Fe[Le.attributesKey] && Ge.push(he(Fe[Le.attributesKey], Le, He));
    var $e = Fe[Le.elementsKey] && Fe[Le.elementsKey].length || Fe[Le.attributesKey] && Fe[Le.attributesKey]["xml:space"] === "preserve";
    return $e || ("fullTagEmptyElementFn" in Le ? $e = Le.fullTagEmptyElementFn(Fe.name, Fe) : $e = Le.fullTagEmptyElement), $e ? (Ge.push(">"), Fe[Le.elementsKey] && Fe[Le.elementsKey].length && (Ge.push(Ne(Fe[Le.elementsKey], Le, He + 1)), re = Fe, oe = Fe.name), Ge.push(Le.spaces && Ce(Fe, Le) ? `
` + Array(He + 1).join(Le.spaces) : ""), Ge.push("</" + Ve + ">")) : Ge.push("/>"), Ge.join("");
  }
  function Ne(Fe, Le, He, Ge) {
    return Fe.reduce(function(Ve, $e) {
      var De = fe(Le, He, Ge && !Ve);
      switch ($e.type) {
        case "element":
          return Ve + De + Ie($e, Le, He);
        case "comment":
          return Ve + De + xe($e[Le.commentKey], Le);
        case "doctype":
          return Ve + De + Se($e[Le.doctypeKey], Le);
        case "cdata":
          return Ve + (Le.indentCdata ? De : "") + Ee($e[Le.cdataKey], Le);
        case "text":
          return Ve + (Le.indentText ? De : "") + Te($e[Le.textKey], Le);
        case "instruction":
          var Ke = {};
          return Ke[$e[Le.nameKey]] = $e[Le.attributesKey] ? $e : $e[Le.instructionKey], Ve + (Le.indentInstruction ? De : "") + ve(Ke, Le, He);
      }
    }, "");
  }
  function Re(Fe, Le, He) {
    var Ge;
    for (Ge in Fe)
      if (Fe.hasOwnProperty(Ge))
        switch (Ge) {
          case Le.parentKey:
          case Le.attributesKey:
            break;
          // skip to next key
          case Le.textKey:
            if (Le.indentText || He)
              return !0;
            break;
          // skip to next key
          case Le.cdataKey:
            if (Le.indentCdata || He)
              return !0;
            break;
          // skip to next key
          case Le.instructionKey:
            if (Le.indentInstruction || He)
              return !0;
            break;
          // skip to next key
          case Le.doctypeKey:
          case Le.commentKey:
            return !0;
          default:
            return !0;
        }
    return !1;
  }
  function Ae(Fe, Le, He, Ge, Ve) {
    re = Fe, oe = Le;
    var $e = "elementNameFn" in He ? He.elementNameFn(Le, Fe) : Le;
    if (typeof Fe > "u" || Fe === null || Fe === "")
      return "fullTagEmptyElementFn" in He && He.fullTagEmptyElementFn(Le, Fe) || He.fullTagEmptyElement ? "<" + $e + "></" + $e + ">" : "<" + $e + "/>";
    var De = [];
    if (Le) {
      if (De.push("<" + $e), typeof Fe != "object")
        return De.push(">" + Te(Fe, He) + "</" + $e + ">"), De.join("");
      Fe[He.attributesKey] && De.push(he(Fe[He.attributesKey], He, Ge));
      var Ke = Re(Fe, He, !0) || Fe[He.attributesKey] && Fe[He.attributesKey]["xml:space"] === "preserve";
      if (Ke || ("fullTagEmptyElementFn" in He ? Ke = He.fullTagEmptyElementFn(Le, Fe) : Ke = He.fullTagEmptyElement), Ke)
        De.push(">");
      else
        return De.push("/>"), De.join("");
    }
    return De.push(Pe(Fe, He, Ge + 1, !1)), re = Fe, oe = Le, Le && De.push((Ve ? fe(He, Ge, !1) : "") + "</" + $e + ">"), De.join("");
  }
  function Pe(Fe, Le, He, Ge) {
    var Ve, $e, De, Ke = [];
    for ($e in Fe)
      if (Fe.hasOwnProperty($e))
        for (De = Y(Fe[$e]) ? Fe[$e] : [Fe[$e]], Ve = 0; Ve < De.length; ++Ve) {
          switch ($e) {
            case Le.declarationKey:
              Ke.push(_e(De[Ve], Le, He));
              break;
            case Le.instructionKey:
              Ke.push((Le.indentInstruction ? fe(Le, He, Ge) : "") + ve(De[Ve], Le, He));
              break;
            case Le.attributesKey:
            case Le.parentKey:
              break;
            // skip
            case Le.textKey:
              Ke.push((Le.indentText ? fe(Le, He, Ge) : "") + Te(De[Ve], Le));
              break;
            case Le.cdataKey:
              Ke.push((Le.indentCdata ? fe(Le, He, Ge) : "") + Ee(De[Ve], Le));
              break;
            case Le.doctypeKey:
              Ke.push(fe(Le, He, Ge) + Se(De[Ve], Le));
              break;
            case Le.commentKey:
              Ke.push(fe(Le, He, Ge) + xe(De[Ve], Le));
              break;
            default:
              Ke.push(fe(Le, He, Ge) + Ae(De[Ve], $e, Le, He, Re(De[Ve], Le)));
          }
          Ge = Ge && !Ke.length;
        }
    return Ke.join("");
  }
  return js2xml$1 = function(Fe, Le) {
    Le = ue(Le);
    var He = [];
    return re = Fe, oe = "_root_", Le.compact ? He.push(Pe(Fe, Le, 0, !0)) : (Fe[Le.declarationKey] && He.push(_e(Fe[Le.declarationKey], Le, 0)), Fe[Le.elementsKey] && Fe[Le.elementsKey].length && He.push(Ne(Fe[Le.elementsKey], Le, 0, !He.length))), He.join("");
  }, js2xml$1;
}
var json2xml$1, hasRequiredJson2xml$1;
function requireJson2xml$1() {
  if (hasRequiredJson2xml$1) return json2xml$1;
  hasRequiredJson2xml$1 = 1;
  var le = requireJs2xml$1();
  return json2xml$1 = function(Y, re) {
    Y instanceof Buffer && (Y = Y.toString());
    var oe = null;
    if (typeof Y == "string")
      try {
        oe = JSON.parse(Y);
      } catch {
        throw new Error("The JSON structure is invalid");
      }
    else
      oe = Y;
    return le(oe, re);
  }, json2xml$1;
}
var lib$1, hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1;
  var le = requireXml2js$1(), Y = requireXml2json$1(), re = requireJs2xml$1(), oe = requireJson2xml$1();
  return lib$1 = {
    xml2js: le,
    xml2json: Y,
    js2xml: re,
    json2xml: oe
  }, lib$1;
}
var arrayHelper, hasRequiredArrayHelper;
function requireArrayHelper() {
  return hasRequiredArrayHelper || (hasRequiredArrayHelper = 1, arrayHelper = {
    isArray: function(le) {
      return Array.isArray ? Array.isArray(le) : Object.prototype.toString.call(le) === "[object Array]";
    }
  }), arrayHelper;
}
var optionsHelper, hasRequiredOptionsHelper;
function requireOptionsHelper() {
  if (hasRequiredOptionsHelper) return optionsHelper;
  hasRequiredOptionsHelper = 1;
  var le = requireArrayHelper().isArray;
  return optionsHelper = {
    copyOptions: function(Y) {
      var re, oe = {};
      for (re in Y)
        Y.hasOwnProperty(re) && (oe[re] = Y[re]);
      return oe;
    },
    ensureFlagExists: function(Y, re) {
      (!(Y in re) || typeof re[Y] != "boolean") && (re[Y] = !1);
    },
    ensureSpacesExists: function(Y) {
      (!("spaces" in Y) || typeof Y.spaces != "number" && typeof Y.spaces != "string") && (Y.spaces = 0);
    },
    ensureAlwaysArrayExists: function(Y) {
      (!("alwaysArray" in Y) || typeof Y.alwaysArray != "boolean" && !le(Y.alwaysArray)) && (Y.alwaysArray = !1);
    },
    ensureKeyExists: function(Y, re) {
      (!(Y + "Key" in re) || typeof re[Y + "Key"] != "string") && (re[Y + "Key"] = re.compact ? "_" + Y : Y);
    },
    checkFnExists: function(Y, re) {
      return Y + "Fn" in re;
    }
  }, optionsHelper;
}
var xml2js, hasRequiredXml2js;
function requireXml2js() {
  if (hasRequiredXml2js) return xml2js;
  hasRequiredXml2js = 1;
  var le = requireSax(), Y = requireOptionsHelper(), re = requireArrayHelper().isArray, oe, ue;
  function fe(Ae) {
    return oe = Y.copyOptions(Ae), Y.ensureFlagExists("ignoreDeclaration", oe), Y.ensureFlagExists("ignoreInstruction", oe), Y.ensureFlagExists("ignoreAttributes", oe), Y.ensureFlagExists("ignoreText", oe), Y.ensureFlagExists("ignoreComment", oe), Y.ensureFlagExists("ignoreCdata", oe), Y.ensureFlagExists("ignoreDoctype", oe), Y.ensureFlagExists("compact", oe), Y.ensureFlagExists("alwaysChildren", oe), Y.ensureFlagExists("addParent", oe), Y.ensureFlagExists("trim", oe), Y.ensureFlagExists("nativeType", oe), Y.ensureFlagExists("nativeTypeAttributes", oe), Y.ensureFlagExists("sanitize", oe), Y.ensureFlagExists("instructionHasAttributes", oe), Y.ensureFlagExists("captureSpacesBetweenElements", oe), Y.ensureAlwaysArrayExists(oe), Y.ensureKeyExists("declaration", oe), Y.ensureKeyExists("instruction", oe), Y.ensureKeyExists("attributes", oe), Y.ensureKeyExists("text", oe), Y.ensureKeyExists("comment", oe), Y.ensureKeyExists("cdata", oe), Y.ensureKeyExists("doctype", oe), Y.ensureKeyExists("type", oe), Y.ensureKeyExists("name", oe), Y.ensureKeyExists("elements", oe), Y.ensureKeyExists("parent", oe), Y.checkFnExists("doctype", oe), Y.checkFnExists("instruction", oe), Y.checkFnExists("cdata", oe), Y.checkFnExists("comment", oe), Y.checkFnExists("text", oe), Y.checkFnExists("instructionName", oe), Y.checkFnExists("elementName", oe), Y.checkFnExists("attributeName", oe), Y.checkFnExists("attributeValue", oe), Y.checkFnExists("attributes", oe), oe;
  }
  function he(Ae) {
    var Pe = Number(Ae);
    if (!isNaN(Pe))
      return Pe;
    var Fe = Ae.toLowerCase();
    return Fe === "true" ? !0 : Fe === "false" ? !1 : Ae;
  }
  function _e(Ae, Pe) {
    var Fe;
    if (oe.compact) {
      if (!ue[oe[Ae + "Key"]] && (re(oe.alwaysArray) ? oe.alwaysArray.indexOf(oe[Ae + "Key"]) !== -1 : oe.alwaysArray) && (ue[oe[Ae + "Key"]] = []), ue[oe[Ae + "Key"]] && !re(ue[oe[Ae + "Key"]]) && (ue[oe[Ae + "Key"]] = [ue[oe[Ae + "Key"]]]), Ae + "Fn" in oe && typeof Pe == "string" && (Pe = oe[Ae + "Fn"](Pe, ue)), Ae === "instruction" && ("instructionFn" in oe || "instructionNameFn" in oe)) {
        for (Fe in Pe)
          if (Pe.hasOwnProperty(Fe))
            if ("instructionFn" in oe)
              Pe[Fe] = oe.instructionFn(Pe[Fe], Fe, ue);
            else {
              var Le = Pe[Fe];
              delete Pe[Fe], Pe[oe.instructionNameFn(Fe, Le, ue)] = Le;
            }
      }
      re(ue[oe[Ae + "Key"]]) ? ue[oe[Ae + "Key"]].push(Pe) : ue[oe[Ae + "Key"]] = Pe;
    } else {
      ue[oe.elementsKey] || (ue[oe.elementsKey] = []);
      var He = {};
      if (He[oe.typeKey] = Ae, Ae === "instruction") {
        for (Fe in Pe)
          if (Pe.hasOwnProperty(Fe))
            break;
        He[oe.nameKey] = "instructionNameFn" in oe ? oe.instructionNameFn(Fe, Pe, ue) : Fe, oe.instructionHasAttributes ? (He[oe.attributesKey] = Pe[Fe][oe.attributesKey], "instructionFn" in oe && (He[oe.attributesKey] = oe.instructionFn(He[oe.attributesKey], Fe, ue))) : ("instructionFn" in oe && (Pe[Fe] = oe.instructionFn(Pe[Fe], Fe, ue)), He[oe.instructionKey] = Pe[Fe]);
      } else
        Ae + "Fn" in oe && (Pe = oe[Ae + "Fn"](Pe, ue)), He[oe[Ae + "Key"]] = Pe;
      oe.addParent && (He[oe.parentKey] = ue), ue[oe.elementsKey].push(He);
    }
  }
  function ve(Ae) {
    if ("attributesFn" in oe && Ae && (Ae = oe.attributesFn(Ae, ue)), (oe.trim || "attributeValueFn" in oe || "attributeNameFn" in oe || oe.nativeTypeAttributes) && Ae) {
      var Pe;
      for (Pe in Ae)
        if (Ae.hasOwnProperty(Pe) && (oe.trim && (Ae[Pe] = Ae[Pe].trim()), oe.nativeTypeAttributes && (Ae[Pe] = he(Ae[Pe])), "attributeValueFn" in oe && (Ae[Pe] = oe.attributeValueFn(Ae[Pe], Pe, ue)), "attributeNameFn" in oe)) {
          var Fe = Ae[Pe];
          delete Ae[Pe], Ae[oe.attributeNameFn(Pe, Ae[Pe], ue)] = Fe;
        }
    }
    return Ae;
  }
  function xe(Ae) {
    var Pe = {};
    if (Ae.body && (Ae.name.toLowerCase() === "xml" || oe.instructionHasAttributes)) {
      for (var Fe = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g, Le; (Le = Fe.exec(Ae.body)) !== null; )
        Pe[Le[1]] = Le[2] || Le[3] || Le[4];
      Pe = ve(Pe);
    }
    if (Ae.name.toLowerCase() === "xml") {
      if (oe.ignoreDeclaration)
        return;
      ue[oe.declarationKey] = {}, Object.keys(Pe).length && (ue[oe.declarationKey][oe.attributesKey] = Pe), oe.addParent && (ue[oe.declarationKey][oe.parentKey] = ue);
    } else {
      if (oe.ignoreInstruction)
        return;
      oe.trim && (Ae.body = Ae.body.trim());
      var He = {};
      oe.instructionHasAttributes && Object.keys(Pe).length ? (He[Ae.name] = {}, He[Ae.name][oe.attributesKey] = Pe) : He[Ae.name] = Ae.body, _e("instruction", He);
    }
  }
  function Ee(Ae, Pe) {
    var Fe;
    if (typeof Ae == "object" && (Pe = Ae.attributes, Ae = Ae.name), Pe = ve(Pe), "elementNameFn" in oe && (Ae = oe.elementNameFn(Ae, ue)), oe.compact) {
      if (Fe = {}, !oe.ignoreAttributes && Pe && Object.keys(Pe).length) {
        Fe[oe.attributesKey] = {};
        var Le;
        for (Le in Pe)
          Pe.hasOwnProperty(Le) && (Fe[oe.attributesKey][Le] = Pe[Le]);
      }
      !(Ae in ue) && (re(oe.alwaysArray) ? oe.alwaysArray.indexOf(Ae) !== -1 : oe.alwaysArray) && (ue[Ae] = []), ue[Ae] && !re(ue[Ae]) && (ue[Ae] = [ue[Ae]]), re(ue[Ae]) ? ue[Ae].push(Fe) : ue[Ae] = Fe;
    } else
      ue[oe.elementsKey] || (ue[oe.elementsKey] = []), Fe = {}, Fe[oe.typeKey] = "element", Fe[oe.nameKey] = Ae, !oe.ignoreAttributes && Pe && Object.keys(Pe).length && (Fe[oe.attributesKey] = Pe), oe.alwaysChildren && (Fe[oe.elementsKey] = []), ue[oe.elementsKey].push(Fe);
    Fe[oe.parentKey] = ue, ue = Fe;
  }
  function Se(Ae) {
    oe.ignoreText || !Ae.trim() && !oe.captureSpacesBetweenElements || (oe.trim && (Ae = Ae.trim()), oe.nativeType && (Ae = he(Ae)), oe.sanitize && (Ae = Ae.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")), _e("text", Ae));
  }
  function Te(Ae) {
    oe.ignoreComment || (oe.trim && (Ae = Ae.trim()), _e("comment", Ae));
  }
  function Ce(Ae) {
    var Pe = ue[oe.parentKey];
    oe.addParent || delete ue[oe.parentKey], ue = Pe;
  }
  function Ie(Ae) {
    oe.ignoreCdata || (oe.trim && (Ae = Ae.trim()), _e("cdata", Ae));
  }
  function Ne(Ae) {
    oe.ignoreDoctype || (Ae = Ae.replace(/^ /, ""), oe.trim && (Ae = Ae.trim()), _e("doctype", Ae));
  }
  function Re(Ae) {
    Ae.note = Ae;
  }
  return xml2js = function(Ae, Pe) {
    var Fe = le.parser(!0, {}), Le = {};
    if (ue = Le, oe = fe(Pe), Fe.opt = { strictEntities: !0 }, Fe.onopentag = Ee, Fe.ontext = Se, Fe.oncomment = Te, Fe.onclosetag = Ce, Fe.onerror = Re, Fe.oncdata = Ie, Fe.ondoctype = Ne, Fe.onprocessinginstruction = xe, Fe.write(Ae).close(), Le[oe.elementsKey]) {
      var He = Le[oe.elementsKey];
      delete Le[oe.elementsKey], Le[oe.elementsKey] = He, delete Le.text;
    }
    return Le;
  }, xml2js;
}
var xml2json, hasRequiredXml2json;
function requireXml2json() {
  if (hasRequiredXml2json) return xml2json;
  hasRequiredXml2json = 1;
  var le = requireOptionsHelper(), Y = requireXml2js();
  function re(oe) {
    var ue = le.copyOptions(oe);
    return le.ensureSpacesExists(ue), ue;
  }
  return xml2json = function(oe, ue) {
    var fe, he, _e, ve;
    return fe = re(ue), he = Y(oe, fe), ve = "compact" in fe && fe.compact ? "_parent" : "parent", "addParent" in fe && fe.addParent ? _e = JSON.stringify(he, function(xe, Ee) {
      return xe === ve ? "_" : Ee;
    }, fe.spaces) : _e = JSON.stringify(he, null, fe.spaces), _e.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }, xml2json;
}
var js2xml, hasRequiredJs2xml;
function requireJs2xml() {
  if (hasRequiredJs2xml) return js2xml;
  hasRequiredJs2xml = 1;
  var le = requireOptionsHelper(), Y = requireArrayHelper().isArray, re, oe;
  function ue(Fe) {
    var Le = le.copyOptions(Fe);
    return le.ensureFlagExists("ignoreDeclaration", Le), le.ensureFlagExists("ignoreInstruction", Le), le.ensureFlagExists("ignoreAttributes", Le), le.ensureFlagExists("ignoreText", Le), le.ensureFlagExists("ignoreComment", Le), le.ensureFlagExists("ignoreCdata", Le), le.ensureFlagExists("ignoreDoctype", Le), le.ensureFlagExists("compact", Le), le.ensureFlagExists("indentText", Le), le.ensureFlagExists("indentCdata", Le), le.ensureFlagExists("indentAttributes", Le), le.ensureFlagExists("indentInstruction", Le), le.ensureFlagExists("fullTagEmptyElement", Le), le.ensureFlagExists("noQuotesForNativeAttributes", Le), le.ensureSpacesExists(Le), typeof Le.spaces == "number" && (Le.spaces = Array(Le.spaces + 1).join(" ")), le.ensureKeyExists("declaration", Le), le.ensureKeyExists("instruction", Le), le.ensureKeyExists("attributes", Le), le.ensureKeyExists("text", Le), le.ensureKeyExists("comment", Le), le.ensureKeyExists("cdata", Le), le.ensureKeyExists("doctype", Le), le.ensureKeyExists("type", Le), le.ensureKeyExists("name", Le), le.ensureKeyExists("elements", Le), le.checkFnExists("doctype", Le), le.checkFnExists("instruction", Le), le.checkFnExists("cdata", Le), le.checkFnExists("comment", Le), le.checkFnExists("text", Le), le.checkFnExists("instructionName", Le), le.checkFnExists("elementName", Le), le.checkFnExists("attributeName", Le), le.checkFnExists("attributeValue", Le), le.checkFnExists("attributes", Le), le.checkFnExists("fullTagEmptyElement", Le), Le;
  }
  function fe(Fe, Le, He) {
    return (!He && Fe.spaces ? `
` : "") + Array(Le + 1).join(Fe.spaces);
  }
  function he(Fe, Le, He) {
    if (Le.ignoreAttributes)
      return "";
    "attributesFn" in Le && (Fe = Le.attributesFn(Fe, oe, re));
    var Ge, Ve, $e, De, Ke = [];
    for (Ge in Fe)
      Fe.hasOwnProperty(Ge) && Fe[Ge] !== null && Fe[Ge] !== void 0 && (De = Le.noQuotesForNativeAttributes && typeof Fe[Ge] != "string" ? "" : '"', Ve = "" + Fe[Ge], Ve = Ve.replace(/"/g, "&quot;"), $e = "attributeNameFn" in Le ? Le.attributeNameFn(Ge, Ve, oe, re) : Ge, Ke.push(Le.spaces && Le.indentAttributes ? fe(Le, He + 1, !1) : " "), Ke.push($e + "=" + De + ("attributeValueFn" in Le ? Le.attributeValueFn(Ve, Ge, oe, re) : Ve) + De));
    return Fe && Object.keys(Fe).length && Le.spaces && Le.indentAttributes && Ke.push(fe(Le, He, !1)), Ke.join("");
  }
  function _e(Fe, Le, He) {
    return re = Fe, oe = "xml", Le.ignoreDeclaration ? "" : "<?xml" + he(Fe[Le.attributesKey], Le, He) + "?>";
  }
  function ve(Fe, Le, He) {
    if (Le.ignoreInstruction)
      return "";
    var Ge;
    for (Ge in Fe)
      if (Fe.hasOwnProperty(Ge))
        break;
    var Ve = "instructionNameFn" in Le ? Le.instructionNameFn(Ge, Fe[Ge], oe, re) : Ge;
    if (typeof Fe[Ge] == "object")
      return re = Fe, oe = Ve, "<?" + Ve + he(Fe[Ge][Le.attributesKey], Le, He) + "?>";
    var $e = Fe[Ge] ? Fe[Ge] : "";
    return "instructionFn" in Le && ($e = Le.instructionFn($e, Ge, oe, re)), "<?" + Ve + ($e ? " " + $e : "") + "?>";
  }
  function xe(Fe, Le) {
    return Le.ignoreComment ? "" : "<!--" + ("commentFn" in Le ? Le.commentFn(Fe, oe, re) : Fe) + "-->";
  }
  function Ee(Fe, Le) {
    return Le.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in Le ? Le.cdataFn(Fe, oe, re) : Fe.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
  }
  function Se(Fe, Le) {
    return Le.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in Le ? Le.doctypeFn(Fe, oe, re) : Fe) + ">";
  }
  function Te(Fe, Le) {
    return Le.ignoreText ? "" : (Fe = "" + Fe, Fe = Fe.replace(/&amp;/g, "&"), Fe = Fe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), "textFn" in Le ? Le.textFn(Fe, oe, re) : Fe);
  }
  function Ce(Fe, Le) {
    var He;
    if (Fe.elements && Fe.elements.length)
      for (He = 0; He < Fe.elements.length; ++He)
        switch (Fe.elements[He][Le.typeKey]) {
          case "text":
            if (Le.indentText)
              return !0;
            break;
          // skip to next key
          case "cdata":
            if (Le.indentCdata)
              return !0;
            break;
          // skip to next key
          case "instruction":
            if (Le.indentInstruction)
              return !0;
            break;
          // skip to next key
          case "doctype":
          case "comment":
          case "element":
            return !0;
          default:
            return !0;
        }
    return !1;
  }
  function Ie(Fe, Le, He) {
    re = Fe, oe = Fe.name;
    var Ge = [], Ve = "elementNameFn" in Le ? Le.elementNameFn(Fe.name, Fe) : Fe.name;
    Ge.push("<" + Ve), Fe[Le.attributesKey] && Ge.push(he(Fe[Le.attributesKey], Le, He));
    var $e = Fe[Le.elementsKey] && Fe[Le.elementsKey].length || Fe[Le.attributesKey] && Fe[Le.attributesKey]["xml:space"] === "preserve";
    return $e || ("fullTagEmptyElementFn" in Le ? $e = Le.fullTagEmptyElementFn(Fe.name, Fe) : $e = Le.fullTagEmptyElement), $e ? (Ge.push(">"), Fe[Le.elementsKey] && Fe[Le.elementsKey].length && (Ge.push(Ne(Fe[Le.elementsKey], Le, He + 1)), re = Fe, oe = Fe.name), Ge.push(Le.spaces && Ce(Fe, Le) ? `
` + Array(He + 1).join(Le.spaces) : ""), Ge.push("</" + Ve + ">")) : Ge.push("/>"), Ge.join("");
  }
  function Ne(Fe, Le, He, Ge) {
    return Fe.reduce(function(Ve, $e) {
      var De = fe(Le, He, Ge && !Ve);
      switch ($e.type) {
        case "element":
          return Ve + De + Ie($e, Le, He);
        case "comment":
          return Ve + De + xe($e[Le.commentKey], Le);
        case "doctype":
          return Ve + De + Se($e[Le.doctypeKey], Le);
        case "cdata":
          return Ve + (Le.indentCdata ? De : "") + Ee($e[Le.cdataKey], Le);
        case "text":
          return Ve + (Le.indentText ? De : "") + Te($e[Le.textKey], Le);
        case "instruction":
          var Ke = {};
          return Ke[$e[Le.nameKey]] = $e[Le.attributesKey] ? $e : $e[Le.instructionKey], Ve + (Le.indentInstruction ? De : "") + ve(Ke, Le, He);
      }
    }, "");
  }
  function Re(Fe, Le, He) {
    var Ge;
    for (Ge in Fe)
      if (Fe.hasOwnProperty(Ge))
        switch (Ge) {
          case Le.parentKey:
          case Le.attributesKey:
            break;
          // skip to next key
          case Le.textKey:
            if (Le.indentText || He)
              return !0;
            break;
          // skip to next key
          case Le.cdataKey:
            if (Le.indentCdata || He)
              return !0;
            break;
          // skip to next key
          case Le.instructionKey:
            if (Le.indentInstruction || He)
              return !0;
            break;
          // skip to next key
          case Le.doctypeKey:
          case Le.commentKey:
            return !0;
          default:
            return !0;
        }
    return !1;
  }
  function Ae(Fe, Le, He, Ge, Ve) {
    re = Fe, oe = Le;
    var $e = "elementNameFn" in He ? He.elementNameFn(Le, Fe) : Le;
    if (typeof Fe > "u" || Fe === null || Fe === "")
      return "fullTagEmptyElementFn" in He && He.fullTagEmptyElementFn(Le, Fe) || He.fullTagEmptyElement ? "<" + $e + "></" + $e + ">" : "<" + $e + "/>";
    var De = [];
    if (Le) {
      if (De.push("<" + $e), typeof Fe != "object")
        return De.push(">" + Te(Fe, He) + "</" + $e + ">"), De.join("");
      Fe[He.attributesKey] && De.push(he(Fe[He.attributesKey], He, Ge));
      var Ke = Re(Fe, He, !0) || Fe[He.attributesKey] && Fe[He.attributesKey]["xml:space"] === "preserve";
      if (Ke || ("fullTagEmptyElementFn" in He ? Ke = He.fullTagEmptyElementFn(Le, Fe) : Ke = He.fullTagEmptyElement), Ke)
        De.push(">");
      else
        return De.push("/>"), De.join("");
    }
    return De.push(Pe(Fe, He, Ge + 1, !1)), re = Fe, oe = Le, Le && De.push((Ve ? fe(He, Ge, !1) : "") + "</" + $e + ">"), De.join("");
  }
  function Pe(Fe, Le, He, Ge) {
    var Ve, $e, De, Ke = [];
    for ($e in Fe)
      if (Fe.hasOwnProperty($e))
        for (De = Y(Fe[$e]) ? Fe[$e] : [Fe[$e]], Ve = 0; Ve < De.length; ++Ve) {
          switch ($e) {
            case Le.declarationKey:
              Ke.push(_e(De[Ve], Le, He));
              break;
            case Le.instructionKey:
              Ke.push((Le.indentInstruction ? fe(Le, He, Ge) : "") + ve(De[Ve], Le, He));
              break;
            case Le.attributesKey:
            case Le.parentKey:
              break;
            // skip
            case Le.textKey:
              Ke.push((Le.indentText ? fe(Le, He, Ge) : "") + Te(De[Ve], Le));
              break;
            case Le.cdataKey:
              Ke.push((Le.indentCdata ? fe(Le, He, Ge) : "") + Ee(De[Ve], Le));
              break;
            case Le.doctypeKey:
              Ke.push(fe(Le, He, Ge) + Se(De[Ve], Le));
              break;
            case Le.commentKey:
              Ke.push(fe(Le, He, Ge) + xe(De[Ve], Le));
              break;
            default:
              Ke.push(fe(Le, He, Ge) + Ae(De[Ve], $e, Le, He, Re(De[Ve], Le)));
          }
          Ge = Ge && !Ke.length;
        }
    return Ke.join("");
  }
  return js2xml = function(Fe, Le) {
    Le = ue(Le);
    var He = [];
    return re = Fe, oe = "_root_", Le.compact ? He.push(Pe(Fe, Le, 0, !0)) : (Fe[Le.declarationKey] && He.push(_e(Fe[Le.declarationKey], Le, 0)), Fe[Le.elementsKey] && Fe[Le.elementsKey].length && He.push(Ne(Fe[Le.elementsKey], Le, 0, !He.length))), He.join("");
  }, js2xml;
}
var json2xml, hasRequiredJson2xml;
function requireJson2xml() {
  if (hasRequiredJson2xml) return json2xml;
  hasRequiredJson2xml = 1;
  var le = requireJs2xml(), Y = requireBuffer().Buffer;
  return json2xml = function(re, oe) {
    re instanceof Y && (re = re.toString());
    var ue = null;
    if (typeof re == "string")
      try {
        ue = JSON.parse(re);
      } catch {
        throw new Error("The JSON structure is invalid");
      }
    else
      ue = re;
    return le(ue, oe);
  }, json2xml;
}
var lib, hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var le = requireXml2js(), Y = requireXml2json(), re = requireJs2xml(), oe = requireJson2xml();
  return lib = {
    xml2js: le,
    xml2json: Y,
    js2xml: re,
    json2xml: oe
  }, lib;
}
var checktag, hasRequiredChecktag;
function requireChecktag() {
  if (hasRequiredChecktag) return checktag;
  hasRequiredChecktag = 1;
  function le(Xe, mt, at) {
    const qe = { type: "tag", tag: Xe.name };
    return qe.type = "tag", qe.tag = Xe.name, qe.attribute = mt, qe.value = at || !Xe.attributes ? void 0 : Xe.attributes[mt], Xe.position !== void 0 && (qe.position = Xe.position), qe;
  }
  function Y(Xe, mt, at) {
    let qe;
    if (!at && Xe === "infinity")
      qe = Number.MAX_SAFE_INTEGER;
    else if (Xe.match("[0-9]+ms"))
      qe = parseInt(Xe);
    else if (Xe.match(/^[0-9]+(\.[0-9]+)?s$/g))
      qe = 1e3 * parseInt(Xe);
    else if (mt === "google" && Xe.match(/^[0-9]+(\.[0-9]+)?$/g))
      qe = 1e3 * parseInt(Xe);
    else
      return;
    return at && (qe = qe <= at ? qe : void 0), qe;
  }
  function re(Xe, mt, at, qe) {
    let st = parseFloat(Xe), xt = !0;
    return isNaN(st) ? (xt = !1, st = qe) : st < mt ? (xt = !1, st = mt) : st > at && (xt = !1, st = at), { inRange: xt, value: st };
  }
  const oe = (Xe, mt, at, qe, st, xt) => {
    const gt = Object.keys(qe.attributes || {});
    return gt.forEach((Ze) => {
      Ze === "type" ? ["first"].indexOf(qe.attributes.type) === -1 && (at.push(le(qe, Ze)), qe.attributes.type = "first") : Ze === "personId" ? qe.attributes.personId.indexOf("amzn1.ask.person.") === -1 && at.push(le(qe, Ze)) : (at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0);
    }), gt.indexOf("type") === -1 && (at.push(le(qe, "missing type")), qe.attributes = { type: "first" }), gt.indexOf("personId") === -1 && (at.push(le(qe, "missing personId")), qe.attributes = { personId: "amzn1.ask.person.ABCD" }), !1;
  }, ue = (Xe, mt, at, qe, st, xt) => (Object.keys(qe.attributes || {}).forEach((Ze) => {
    Ze === "duration" ? ["default", "x-short", "short", "medium", "long", "x-long"].indexOf(qe.attributes.duration) === -1 && (at.push(le(qe, Ze)), qe.attributes.duration = "medium") : Ze === "volume" ? ["default", "x-soft", "soft", "medium", "loud", "x-loud"].indexOf(qe.attributes.volume) === -1 && (at.push(le(qe, Ze)), qe.attributes.volume = "medium") : Ze === "frequency" ? ["default", "x-low", "low", "medium", "high", "x-high"].indexOf(qe.attributes.frequency) === -1 && (at.push(le(qe, Ze)), qe.attributes.frequncy = "medium") : (at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0);
  }), !1), fe = (Xe, mt, at, qe, st, xt) => (Object.keys(qe.attributes || {}).forEach((Ze) => {
    Ze === "duration" ? ["default", "x-short", "short", "medium", "long", "x-long"].indexOf(qe.attributes.duration) === -1 && (at.push(le(qe, Ze)), qe.attributes.duration = "medium") : Ze === "volume" ? ["default", "x-soft", "soft", "medium", "loud", "x-loud"].indexOf(qe.attributes.volume) === -1 && (at.push(le(qe, Ze)), qe.attributes.volume = "medium") : (at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0);
  }), !1), he = (Xe, mt, at, qe, st, xt) => {
    if (xt && ["en-US", "en-GB", "jp-JP", "de-DE", "en-CA", "en-AU"].indexOf(xt) === -1)
      return at.push(le(qe, "none")), qe.elements ? Xe.elements.splice(mt, 1, ...qe.elements) : Xe.elements.splice(mt, 1), !0;
    const gt = Object.keys(qe.attributes || {});
    gt.forEach((Ze) => {
      if (Ze === "name") {
        const _t = {
          conversational: ["en-US", "jp-JP"],
          "long-form": ["en-US"],
          music: ["de-DE", "en-US", "en-CA", "en-GB"],
          news: ["en-US", "en-AU"],
          fun: ["jp-JP"]
        };
        (!_t[qe.attributes.name] || xt && _t[qe.attributes.name].indexOf(xt) === -1) && (at.push(le(qe, Ze)), qe.attributes.name = "news");
      } else
        at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0;
    }), gt.length === 0 && (at.push(le(qe, "none")), qe.attributes = { name: "news" });
  }, _e = (Xe, mt, at, qe, st, xt) => {
    const gt = Object.keys(qe.attributes || {});
    return gt.forEach((Ze) => {
      if (Ze === "name")
        ["drc", "whispered"].indexOf(qe.attributes.name) === -1 && (at.push(le(qe, Ze)), qe.attributes.name = "whispered");
      else if (Ze === "phonation")
        ["soft"].indexOf(qe.attributes.phonation) === -1 && (at.push(le(qe, Ze)), qe.attributes.phonation = "soft");
      else if (Ze === "vocal-tract-length") {
        const _t = qe.attributes["vocal-tract-length"].match(/([\+|\-]?)(\d+)%/);
        if (!_t)
          at.push(le(qe, Ze)), qe.attributes["vocal-tract-length"] = "+100%";
        else if (_t[1].length) {
          const wt = re(`${_t[1]}${_t[2]}`, -50, 100, void 0);
          wt.inRange || (at.push(le(qe, Ze)), qe.attributes["vocal-tract-length"] = `${wt.value > 0 ? "+" : ""}${wt.value}%`);
        }
      } else
        at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0;
    }), gt.length === 0 && (at.push(le(qe, "none")), qe.attributes = { name: "whispered" }), !1;
  }, ve = (Xe, mt, at, qe, st, xt) => {
    if (["en-US", "en-GB", "jp-JP"].indexOf(xt) === -1)
      return at.push(le(qe, "none")), qe.elements ? Xe.elements.splice(mt, 1, ...qe.elements) : Xe.elements.splice(mt, 1), !0;
    const gt = Object.keys(qe.attributes || {});
    return gt.forEach((Ze) => {
      Ze === "name" ? ["excited", "disappointed"].indexOf(qe.attributes.name) === -1 && (at.push(le(qe, Ze)), qe.attributes.name = "excited") : Ze === "intensity" ? ["low", "medium", "high"].indexOf(qe.attributes.intensity) === -1 && (at.push(le(qe, Ze)), qe.attributes.intensity = "medium") : (at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0);
    }), gt.length !== 2 && (at.push(le(qe, "none")), qe.attributes.name = qe.attributes.name || "excited", qe.attributes.intensity = qe.attributes.intensity || "medium"), !1;
  }, xe = (Xe, mt, at, qe, st, xt) => {
    const gt = Object.keys(qe.attributes || {});
    let Ze;
    return gt.forEach((_t) => {
      if (st === "google" && _t === "clipBegin")
        Y(qe.attributes.clipBegin, st) === void 0 && (at.push(le(qe, _t)), qe.attributes.clipBegin = void 0);
      else if (st === "google" && _t === "clipEnd")
        Y(qe.attributes.clipEnd, st) === void 0 && (at.push(le(qe, _t)), qe.attributes.clipEnd = void 0);
      else if (st === "google" && _t === "speed") {
        const wt = re(qe.attributes.speed, 50, 200, 100);
        (!qe.attributes.speed.match(/^(\+)?[0-9]+(\.[0-9]+)?%$/g) || !wt.inRange) && (at.push(le(qe, _t)), qe.attributes.speed = wt.value + "%");
      } else if (st === "google" && _t === "repeatCount")
        qe.attributes.repeatCount.match(/^(\+)?[0-9]+(\.[0-9]+)?$/g) || (at.push(le(qe, _t)), qe.attributes.repeatCount = "1");
      else if (st === "google" && _t === "repeatDur")
        Y(qe.attributes.repeatDur, st) === void 0 && (at.push(le(qe, _t)), qe.attributes.repeatDur = void 0);
      else if (st === "google" && _t === "soundLevel") {
        const wt = re(qe.attributes.soundLevel, -40, 40, 0);
        (!qe.attributes.soundLevel.match(/^[+-][0-9]+(\.[0-9]+)?dB$/g) || !wt.inRange) && (at.push(le(qe, _t)), qe.attributes.soundLevel = wt.value < 0 ? wt.value + "dB" : "+" + wt.value + "dB");
      } else _t !== "src" && (at.push(le(qe, _t, !0)), qe.attributes[_t] = void 0);
    }), gt.length === 0 && (at.push(le(qe, "none")), Xe.elements.splice(mt, 1), Ze = !0), Ze;
  }, Ee = (Xe, mt, at, qe, st, xt) => (Object.keys(qe.attributes || {}).forEach((Ze) => {
    Ze === "strength" ? ["none", "x-weak", "weak", "medium", "strong", "x-strong"].indexOf(qe.attributes.strength) === -1 && (at.push(le(qe, Ze)), qe.attributes.strength = "medium") : Ze === "time" ? Y(qe.attributes.time, st, 1e4) === void 0 && (at.push(le(qe, Ze)), qe.attributes.time = "10s") : (at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0);
  }), !qe.attributes.strength && !qe.attributes.time && (qe.attributes.strength = "medium"), !1), Se = (Xe, mt, at, qe, st, xt) => {
    let gt;
    if (!Xe || Xe.name !== "audio") {
      const Ze = { type: "tag", tag: qe.name };
      qe.position !== void 0 && (Ze.position = qe.position), at.push(Ze), Xe.elements.splice(mt, 1), gt = !0;
    }
    return gt;
  }, Te = (Xe, mt, at, qe, st, xt) => {
    const gt = Object.keys(qe.attributes || {});
    return gt.forEach((Ze) => {
      Ze === "level" ? ["strong", "moderate", "reduced"].indexOf(qe.attributes.level) === -1 && (st !== "google" || qe.attributes.level !== "none") && (at.push(le(qe, Ze)), qe.attributes.level = "moderate") : (at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0);
    }), gt.length === 0 && (at.push(le(qe, "none")), qe.attributes = { level: "moderate" }), !1;
  }, Ce = (Xe, mt, at, qe, st, xt) => {
    const gt = Object.keys(qe.attributes || {}), Ze = [
      "de-DE",
      "en-AU",
      "en-CA",
      "en-GB",
      "en-IN",
      "en-US",
      "es-ES",
      "es-MX",
      "es-US",
      "fr-CA",
      "fr-FR",
      "hi-IN",
      "it-IT",
      "ja-JP",
      "pt-BR"
    ];
    return gt.forEach((_t) => {
      _t === "xml:lang" ? Ze.includes(qe.attributes["xml:lang"]) || (at.push(le(qe, _t)), qe.attributes["xml:lang"] = "en-US") : (at.push(le(qe, _t, !0)), qe.attributes[_t] = void 0);
    }), gt.length === 0 && (at.push(le(qe, "none")), qe.attributes = { "xml:lang": "en-US" }), !1;
  }, Ie = (Xe, mt, at, qe, st, xt) => {
    const gt = Object.keys(qe.attributes || {});
    return gt.forEach((Ze) => {
      Ze !== "name" && (at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0);
    }), gt.length === 0 && (at.push(le(qe, "none")), qe.attributes = { name: "mark" }), !1;
  }, Ne = (Xe, mt, at, qe, st, xt) => (Object.keys(qe.attributes || {}).forEach((Ze) => {
    Ze === "xml:id" ? qe.attributes["xml:id"].match(/^([-_#]|[a-z]|[A-Z]|ß|ö|ä|ü|Ö|Ä|Ü|æ|é|[0-9])+$/g) || (at.push(le(qe, Ze)), qe.attributes["xml:id"] = "id_" + mt) : Ze === "begin" ? !qe.attributes.begin.match(/^[+-]?[0-9]+(\.[0-9]+)?(h|min|s|ms)$/g) && !qe.attributes.begin.match(/^([-_#]|[a-z]|[A-Z]|ß|ö|ä|ü|Ö|Ä|Ü|æ|é|[0-9])+\.(begin|end)[+-][0-9]+(\.[0-9]+)?(h|min|s|ms)$/g) && (at.push(le(qe, Ze)), qe.attributes.begin = "0") : Ze === "end" ? !qe.attributes.end.match(/^[+-]?[0-9]+(\.[0-9]+)?(h|min|s|ms)$/g) && !qe.attributes.end.match(/^([-_#]|[a-z]|[A-Z]|ß|ö|ä|ü|Ö|Ä|Ü|æ|é|[0-9])+\.(begin|end)[+-][0-9]+(\.[0-9]+)?(h|min|s|ms)$/g) && (at.push(le(qe, Ze)), qe.attributes.end = void 0) : Ze === "repeatCount" ? qe.attributes.repeatCount.match(/^(\+)?[0-9]+(\.[0-9]+)?$/g) || (at.push(le(qe, Ze)), qe.attributes.repeatCount = "1") : Ze === "repeatDur" ? Y(qe.attributes.repeatDur, st) === void 0 && (at.push(le(qe, Ze)), qe.attributes.repeatDur = void 0) : Ze === "soundLevel" ? qe.attributes.soundLevel.match(/^[+-]?[0-9]+(\.[0-9]+)?dB$/g) || (at.push(le(qe, Ze)), qe.attributes.soundLevel = "+0dB") : Ze === "fadeInDur" ? Y(qe.attributes.fadeInDur, st) === void 0 && (at.push(le(qe, Ze)), qe.attributes.fadeInDur = "0s") : Ze === "fadeOutDur" ? Y(qe.attributes.fadeOutDur, st) === void 0 && (at.push(le(qe, Ze)), qe.attributes.fadeOutDur = "0s") : at.push(le(qe, Ze, !0));
  }), !1), Re = (Xe, mt, at, qe, st, xt) => (Object.keys(qe.attributes || {}).forEach((Ze) => {
    at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0;
  }), !1), Ae = Re, Pe = (Xe, mt, at, qe, st, xt) => {
    if (qe.elements) {
      let gt;
      for (gt = 0; gt < qe.elements.length; gt++) {
        const Ze = qe.elements[gt];
        if (["par", "seq", "media"].indexOf(Ze.name) === -1) {
          const _t = { type: "tag", tag: qe.name };
          _t.value = Ze.name, qe.position !== void 0 && (_t.position = qe.position), at.push(_t), qe.elements.splice(gt, 1), gt--;
        }
      }
    }
    return !1;
  }, Fe = Pe, Le = (Xe, mt, at, qe, st, xt) => (Object.keys(qe.attributes || {}).forEach((Ze) => {
    Ze === "alphabet" ? ["ipa", "x-sampa"].indexOf(qe.attributes.alphabet) === -1 && (at.push(le(qe, Ze)), qe.attributes.alphabet = "ipa") : Ze !== "ph" && (at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0);
  }), !1), He = (Xe, mt, at, qe, st, xt) => (Object.keys(qe.attributes || {}).forEach((Ze) => {
    if (Ze === "rate") {
      if (["x-slow", "slow", "medium", "fast", "x-fast"].indexOf(qe.attributes.rate) === -1) {
        const _t = re(qe.attributes.rate, 20, Number.MAX_SAFE_INTEGER, 100);
        (!qe.attributes.rate.match(/^[0-9]+(\.[0-9]+)?%$/g) || !_t.inRange) && (at.push(le(qe, Ze)), qe.attributes.rate = _t.value + "%");
      }
    } else if (Ze === "pitch") {
      if (["x-low", "low", "medium", "high", "x-high"].indexOf(qe.attributes.pitch) === -1) {
        const _t = re(qe.attributes.pitch, -33.3, 50, 0);
        (!qe.attributes.pitch.match(/^[+-][0-9]+(\.[0-9]+)?%$/g) || !_t.inRange) && (st !== "google" || !qe.attributes.pitch.match(/^[+-]+[0-9]+(\.[0-9]+)?st$/g)) && (at.push(le(qe, Ze)), qe.attributes.pitch = _t.value < 0 ? _t.value + "%" : "+" + _t.value + "%");
      }
    } else Ze === "volume" ? ["silent", "x-soft", "soft", "medium", "loud", "x-loud"].indexOf(qe.attributes.volume) === -1 && (qe.attributes.volume.match(/^[+-][0-9]+(\.[0-9]+)?dB$/g) || (at.push(le(qe, Ze)), qe.attributes.volume = "+0dB")) : Ze === "amazon:max-duration" && st === "amazon" ? Y(qe.attributes["amazon:max-duration"], st, void 0) === void 0 && (at.push(le(qe, Ze)), qe.attributes["amazon:max-duration"] = "2s") : (at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0);
  }), !1), Ge = (Xe, mt, at, qe, st, xt) => (Object.keys(qe.attributes || {}).forEach((Ze) => {
    if (Ze === "interpret-as") {
      if ([
        "characters",
        "spell-out",
        "cardinal",
        "ordinal",
        "fraction",
        "unit",
        "date",
        "time",
        "telephone",
        "expletive",
        "beep",
        "number",
        "verbatim",
        "currency"
      ].indexOf(qe.attributes["interpret-as"]) === -1) {
        let _t = !1;
        (st === "amazon" && ["number", "digits", "address", "interjection"].indexOf(qe.attributes["interpret-as"] !== -1) || st === "google" && ["bleep", "verbatim"].indexOf(qe.attributes["interpret-as"] !== -1)) && (_t = !0), _t || (at.push(le(qe, Ze)), qe.attributes["interpret-as"] = "cardinal");
      }
    } else Ze === "format" ? qe.attributes["interpret-as"] === "date" ? ["mdy", "dmy", "ymd", "md", "dm", "ym", "my", "d", "m", "y"].indexOf(qe.attributes.format) === -1 && (at.push(le(qe, Ze)), qe.attributes.format = "mdy") : st === "google" ? qe.attributes.format.match(/^[hmsZ^\s.!?:;(12|24)]*$/g) || (at.push(le(qe, Ze)), qe.attributes.format = "hms12") : (at.push(le(qe, Ze)), qe.attributes.format = void 0) : st === "google" && Ze === "detail" ? ["1", "2"].indexOf(qe.attributes.detail) === -1 && (at.push(le(qe, Ze)), qe.attributes.detail = "1") : (at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0);
  }), !1), Ve = (Xe, mt, at, qe, st, xt) => (Object.keys(qe.attributes || {}).forEach((Ze) => {
    Ze !== "alias" && (at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0);
  }), !1), $e = (Xe, mt, at, qe, st, xt) => !1, De = (Xe, mt, at, qe, st, xt) => (Object.keys(qe.attributes || {}).forEach((Ze) => {
    Ze === "name" ? [
      "Ivy",
      "Joanna",
      "Joey",
      "Justin",
      "Kendra",
      "Kimberly",
      "Matthew",
      "Salli",
      "Nicole",
      "Russell",
      "Amy",
      "Brian",
      "Emma",
      "Aditi",
      "Raveena",
      "Hans",
      "Marlene",
      "Vicki",
      "Conchita",
      "Enrique",
      "Carla",
      "Giorgio",
      "Mizuki",
      "Takumi",
      "Celine",
      "Lea",
      "Mathieu"
    ].indexOf(qe.attributes.name) === -1 && (at.push(le(qe, Ze)), qe.attributes.name = "Ivy") : (at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0);
  }), !1), Ke = (Xe, mt, at, qe, st, xt) => {
    const gt = (yt) => {
      const St = yt.split("-");
      return !(St.length !== 4 || [
        "af",
        "ar",
        "bn",
        "cmn",
        "cs",
        "da",
        "de",
        "el",
        "en",
        "es",
        "fi",
        "fil",
        "fr",
        "gu",
        "hi",
        "hu",
        "id",
        "it",
        "ja",
        "kn",
        "ko",
        "ml",
        "mr",
        "nb",
        "nl",
        "pl",
        "pt",
        "ru",
        "sk",
        "sv",
        "sw",
        "ta",
        "te",
        "th",
        "tr",
        "uk",
        "vi",
        "yue",
        "zh"
      ].indexOf(St[0]) === -1 || ["Standard", "Wavenet"].indexOf(St[2]) === -1 || ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"].indexOf(St[3]) === -1 || St[1].length !== 2);
    };
    let Ze = !1, _t = !1;
    Object.keys(qe.attributes || {}).forEach((yt) => {
      yt === "name" ? (Ze = !0, gt(qe.attributes.name) || (at.push(le(qe, yt)), qe.attributes.name = "en-US-Standard-A")) : yt === "gender" ? (_t = !0, ["male", "female", "neutral"].indexOf(qe.attributes.gender) === -1 && (at.push(le(qe, yt)), qe.attributes.gender = "neutral")) : yt === "variant" ? (_t = !0, gt(qe.attributes.variant) || (at.push(le(qe, yt)), qe.attributes.variant = "en-US-Standard-A")) : yt === "language" ? (_t = !0, qe.attributes.language.match(/^[a-z]{2}-[A-Z]{2}$/) || (at.push(le(qe, yt)), qe.attributes.language = "en-US")) : yt !== "required" && yt !== "ordering" && (at.push(le(qe, yt, !0)), qe.attributes[yt] = void 0);
    }), !Ze && !_t && (at.push(le(qe, "name", !0)), qe.attributes || (qe.attributes = {}), qe.attributes.name = "en-US-Standard-A");
  };
  return checktag = {
    check_alexa_name: oe,
    check_amazon_auto_breaths: ue,
    check_amazon_breath: fe,
    check_amazon_domain: he,
    check_amazon_effect: _e,
    check_amazon_emotion: ve,
    check_audio: xe,
    check_break: Ee,
    check_desc: Se,
    check_emphasis: Te,
    check_lang: Ce,
    check_mark: Ie,
    check_media: Ne,
    check_p: Re,
    check_par: Pe,
    check_phoneme: Le,
    check_prosody: He,
    check_s: Ae,
    check_say_as: Ge,
    check_seq: Fe,
    check_speak: $e,
    check_sub: Ve,
    check_voice: (Xe, mt, at, qe, st, xt) => st === "amazon" ? De(Xe, mt, at, qe) : st === "google" ? Ke(Xe, mt, at, qe) : (at.push(le(qe, "voice", !0)), qe.attributes.voice = void 0, !1),
    check_w: (Xe, mt, at, qe, st, xt) => (Object.keys(qe.attributes || {}).forEach((Ze) => {
      Ze === "role" ? ["amazon:VB", "amazon:VBD", "amazon:NN", "amazon:DT", "amazon:IN", "amazon:JJ", "amazon:SENSE_1"].indexOf(qe.attributes.role) === -1 && (at.push(le(qe, Ze)), qe.attributes.role = "amazon:VB") : (at.push(le(qe, Ze, !0)), qe.attributes[Ze] = void 0);
    }), !1)
  }, checktag;
}
var ssmlCheckCore, hasRequiredSsmlCheckCore;
function requireSsmlCheckCore() {
  if (hasRequiredSsmlCheckCore) return ssmlCheckCore;
  hasRequiredSsmlCheckCore = 1, requireBuffer().Buffer;
  const le = requireLib(), Y = requireChecktag();
  function re(Ee, Se, Te) {
    let Ce, Ie = Te, Ne, Re;
    if (Se.type === "element") {
      const Ae = new RegExp(`<\\s?${Se.name}`), Pe = Ee.substring(Te).match(Ae);
      Ie = Pe ? Te + Pe.index : -1, Ie > -1 && (Se.position = Ie, Ie += Se.name.length + 1);
    }
    if (Se.elements)
      for (Ne = Ie, Ce = 0; Ce < Se.elements.length; Ce++)
        Re = re(Ee, Se.elements[Ce], Ne), Re > -1 && (Ne = Re);
    return Ie;
  }
  function oe(Ee, Se) {
    re(Ee, Se, 0);
  }
  function ue(Ee) {
    let Se = [];
    return Ee.name === "audio" && Ee.attributes.src && Se.push(Ee.attributes.src), Ee.elements && Ee.elements.forEach((Te) => {
      Se = Se.concat(ue(Te));
    }), Se;
  }
  function fe(Ee, Se, Te, Ce) {
    let Ie = Ce, Ne = !1;
    if (Te.name === "audio" && Te.attributes.src && (Ie < 5 ? Ie++ : (Ee.splice(Se, 1), Ne = !0)), Te.elements) {
      let Re, Ae;
      for (Re = 0; Re < Te.elements.length; Re++)
        Ae = fe(Te.elements, Re, Te.elements[Re], Ie), Ie = Ae.total, Ae.removed && Re--;
    }
    return { total: Ie, removed: Ne };
  }
  function he(Ee) {
    fe(null, 0, Ee, 0);
  }
  function _e(Ee, Se, Te, Ce, Ie, Ne, Re) {
    let Ae;
    if (Ce.name) {
      const Pe = ["audio", "break", "emphasis", "lang", "mark", "p", "phoneme", "prosody", "s", "say-as", "speak", "sub"].filter(
        (He) => !Re.includes(He)
      ), Fe = ["amazon:auto-breaths", "amazon:breath", "amazon:effect", "amazon:emotion", "amazon:domain", "voice", "w", "alexa:name"].filter(
        (He) => !Re.includes(He)
      ), Le = ["par", "seq", "media", "desc", "voice"].filter((He) => !Re.includes(He));
      if (Pe.indexOf(Ce.name) === -1 && !(Ie === "amazon" && Fe.indexOf(Ce.name) !== -1 || Ie === "google" && Le.indexOf(Ce.name) !== -1)) {
        const He = { type: "tag", tag: Ce.name };
        Ce.position !== void 0 && (He.position = Ce.position), Te.push(He), Ce.elements ? Ee.elements.splice(Se, 1, ...Ce.elements) : Ee.elements.splice(Se, 1), Ae = !0;
      } else {
        const He = "check_" + Ce.name.replace(/:|-/g, "_");
        Ae = Y[He](Ee, Se, Te, Ce, Ie, Ne);
      }
    }
    if (Ce.elements) {
      let Pe, Fe;
      for (Pe = 0; Pe < Ce.elements.length; Pe++)
        Fe = _e(Ce, Pe, Te, Ce.elements[Pe], Ie, Ne, Re), Fe && Pe--;
    }
    return Ae;
  }
  function ve(Ee, Se, Te, Ce, Ie) {
    _e(Se, 0, Ee, Se.elements[0], Te, Ce, Ie);
  }
  function xe(Ee, Se, Te) {
    let Ce = [];
    try {
      let Ie;
      const Ne = Se || {};
      if (Ne.platform = Ne.platform || "all", Ne.unsupportedTags = Ne.unsupportedTags || [], ["all", "amazon", "google"].indexOf(Ne.platform) === -1)
        return Ce.push({ type: "invalid platform" }), Promise.resolve({ errors: Ce });
      try {
        Ie = JSON.parse(le.xml2json(Ee, { compact: !1 }));
      } catch {
        try {
          let Ae = Ee;
          Ae = Ae.replace(/&/g, "&amp;"), Ie = JSON.parse(le.xml2json(Ae, { compact: !1 })), Ce.push({ type: "Invalid & character" });
        } catch (Ae) {
          Ce.push({ type: "Can't parse SSML", message: Ae.message });
        }
        if (!Ie || !Te)
          return Promise.resolve({ errors: Ce });
      }
      if (Ne.getPositions && oe(Ee, Ie), !Ie.elements || Ie.elements.length !== 1 || Ie.elements[0].name !== "speak")
        return Ce.push({ type: "tag", tag: "speak" }), Promise.resolve({ errors: Ce });
      if (ve(Ce, Ie, Ne.platform, Ne.locale, Ne.unsupportedTags), Ne.platform !== "google" && ue(Ie.elements[0]).length > 5) {
        const Ae = { type: "Too many audio files" };
        if (Ne.getPositions) {
          const Pe = [...Ee.matchAll(/<\s?audio/g)];
          Ae.position = Pe[5].index;
        }
        Ce.push(Ae), Te && he(Ie.elements[0]);
      }
      return Promise.resolve({ json: Ie, errors: Ce.length ? Ce : void 0 });
    } catch (Ie) {
      Ce.push({ type: "unknown error", message: Ie.message });
    }
    return Promise.resolve({ errors: Ce.length ? Ce : void 0 });
  }
  return ssmlCheckCore = {
    check: function(Ee, Se) {
      return xe(Ee, Se).then((Te) => Te.errors);
    },
    verifyAndFix: function(Ee, Se) {
      return xe(Ee, Se, !0).then((Te) => {
        let Ce;
        return Te.json && Te.errors && (Ce = le.json2xml(Te.json, { compact: !1 })), { fixedSSML: Ce, errors: Te.errors };
      });
    }
  }, ssmlCheckCore;
}
var ssmlCheck, hasRequiredSsmlCheck;
function requireSsmlCheck() {
  if (hasRequiredSsmlCheck) return ssmlCheck;
  hasRequiredSsmlCheck = 1, requireLib$1();
  const le = requireSsmlCheckCore();
  return ssmlCheck = {
    check: function(Y, re) {
      const oe = re || {};
      return oe.platform = oe.platform || "all", le.check(Y, re).then((ue) => ue);
    },
    verifyAndFix: function(Y, re) {
      const oe = re || {};
      return oe.platform = oe.platform || "all", le.verifyAndFix(Y, re).then((ue) => ue);
    }
  }, ssmlCheck;
}
var ssmlCheckExports = requireSsmlCheck();
const Module = Quill.import("core/module");
class SsmlToolbar extends Module {
  constructor(Y, re) {
    super(Y, re), this.controls = [], this.handlers = {}, this.options = re, this.quill = Y, this.loadIcons(), this.registerHandlers();
  }
  /**
   * Load icons to use for toolbar buttons
   */
  loadIcons() {
    const Y = document.createElement("link");
    Y.setAttribute("rel", "stylesheet"), Y.setAttribute("href", "https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined"), document.getElementsByTagName("head")[0].appendChild(Y);
  }
  /**
   * Sets up all toolbar button handlers
   * @param {object} quill
   */
  registerHandlers() {
    const Y = this.quill.getModule("toolbar");
    re(), Y.addHandler("ssml_break", ve.bind(this)), Y.addHandler("ssml_emphasis", ue.bind(this)), Y.addHandler("ssml_gender", fe.bind(this)), Y.addHandler("ssml_language", he.bind(this)), Y.addHandler("ssml_sayas", Ee.bind(this)), Y.addHandler("ssml_date", oe.bind(this)), Y.addHandler("ssml_substitute", Se.bind(this)), Y.addHandler("ssml_phoneme", xe.bind(this)), Y.addHandler("ssml_prosody", _e.bind(this)), Y.addHandler("ssml_validate", Te.bind(this));
    function re() {
      document.querySelector(".ql-ssml_phoneme").innerHTML = '<span class="material-symbols-outlined" title="Phoneme">menu_book</span>', document.querySelector(".ql-ssml_validate").innerHTML = '<span class="material-symbols-outlined" title="Validate SSML">domain_verification</span>', document.querySelector(".ql-ssml_emphasis").innerHTML = '<span class="material-symbols-outlined" title="Emphasis">Highlight</span>', document.querySelector(".ql-ssml_substitute").innerHTML = '<span class="material-symbols-outlined" title="Substitute">letter_switch</span>', Array.prototype.slice.call(document.querySelectorAll(".ql-ssml_break .ql-picker-item")).forEach((Fe) => Fe.textContent = Fe.dataset.value), document.querySelector(".ql-ssml_break .ql-picker-label").innerHTML = '<span class="material-symbols-outlined" title="Break">auto_read_pause</span>' + document.querySelector(".ql-ssml_break .ql-picker-label").innerHTML, Array.prototype.slice.call(document.querySelectorAll(".ql-ssml_gender .ql-picker-item")).forEach((Fe) => Fe.textContent = Fe.dataset.value), document.querySelector(".ql-ssml_gender .ql-picker-label").innerHTML = '<span class="material-symbols-outlined" title="Gender">Wc</span>' + document.querySelector(".ql-ssml_gender .ql-picker-label").innerHTML, Array.prototype.slice.call(document.querySelectorAll(".ql-ssml_language .ql-picker-item")).forEach((Fe) => Fe.textContent = Fe.dataset.value), document.querySelector(".ql-ssml_language .ql-picker-label").innerHTML = '<span class="material-symbols-outlined" title="Language">Language</span>' + document.querySelector(".ql-ssml_language .ql-picker-label").innerHTML, Array.prototype.slice.call(document.querySelectorAll(".ql-ssml_sayas .ql-picker-item")).forEach((Fe) => Fe.textContent = Fe.dataset.value), document.querySelector(".ql-ssml_sayas .ql-picker-label").innerHTML = '<span class="material-symbols-outlined" title="Say as">translate</span>' + document.querySelector(".ql-ssml_sayas .ql-picker-label").innerHTML, Array.prototype.slice.call(document.querySelectorAll(".ql-ssml_prosody .ql-picker-item")).forEach((Fe) => Fe.textContent = Fe.dataset.value), document.querySelector(".ql-ssml_prosody .ql-picker-label").innerHTML = '<span class="material-symbols-outlined" title="Prosody">speed</span>' + document.querySelector(".ql-ssml_prosody .ql-picker-label").innerHTML, Array.prototype.slice.call(document.querySelectorAll(".ql-ssml_date .ql-picker-item")).forEach((Fe) => Fe.textContent = Fe.dataset.value), document.querySelector(".ql-ssml_date .ql-picker-label").innerHTML = '<span class="material-symbols-outlined" title="Date">calendar_month</span>' + document.querySelector(".ql-ssml_date .ql-picker-label").innerHTML;
    }
    function oe(Ce) {
      const Ie = quill.getSelection();
      Ie ? Ie.length > 0 && (this.quill.insertText(Ie.index + Ie.length, "</say-as>"), this.quill.insertText(Ie.index, '<say-as interpret-as="date" format="' + Ce + '">'), this.quill.setSelection(Ie.index + Ie.length + Ce.length + 47)) : this.quill.insertText('<say-as interpret-as="date" format=""></say-as>');
    }
    function ue() {
      const Ce = quill.getSelection();
      Ce ? Ce.length > 0 && (this.quill.insertText(Ce.index + Ce.length, "</emphasis>"), this.quill.insertText(Ce.index, '<emphasis level="strong">'), this.quill.setSelection(Ce.index + Ce.length + 36)) : this.quill.insertText('<emphasis level="strong"></emphasis>');
    }
    function fe(Ce) {
      const Ie = quill.getSelection();
      this.quill.insertText(Ie.index + Ie.length, "</voice>"), this.quill.insertText(Ie.index, '<voice gender="' + Ce + '">'), this.quill.setSelection(Ie.index + Ie.length + Ce.length + 25);
    }
    function he(Ce) {
      const Ie = quill.getSelection();
      Ie ? Ie.length > 0 && (this.quill.insertText(Ie.index + Ie.length, "</lang>"), this.quill.insertText(Ie.index, '<lang xml:lang="' + Ce + '">'), this.quill.setSelection(Ie.index + Ie.length + Ce.length + 25)) : this.quill.insertText('<lang xml:lang=""></lang>');
    }
    function _e(Ce) {
      const Ie = quill.getSelection();
      Ie ? Ie.length > 0 && (this.quill.insertText(Ie.index + Ie.length, "</prosody>"), this.quill.insertText(Ie.index, '<prosody rate="' + Ce + '">'), this.quill.setSelection(Ie.index + Ie.length + Ce.length + 25)) : this.quill.insertText('<prosody rate=""></prosody>');
    }
    function ve(Ce) {
      if (Ce) {
        const Ie = this.quill.getSelection().index;
        this.quill.insertText(Ie, '<break time="' + Ce + '"/>'), this.quill.setSelection(Ie + Ce.length + 20);
      }
    }
    function xe() {
      const Ce = quill.getSelection();
      Ce && Ce.length > 0 && (this.quill.insertText(Ce.index + Ce.length, "</phoneme>"), this.quill.insertText(Ce.index, '<phoneme alphabet="ipa" ph="pɪˈkɑːn">'), this.quill.setSelection(Ce.index + Ce.length + 46));
    }
    function Ee(Ce) {
      const Ie = quill.getSelection();
      Ie ? Ie.length > 0 && (this.quill.insertText(Ie.index + Ie.length, "</say-as>"), this.quill.insertText(Ie.index, '<say-as interpret-as="' + Ce + '">'), this.quill.setSelection(Ie.index + Ie.length + Ce.length + 33)) : this.quill.insertText('<say-as interpret-as=""></say-as>');
    }
    function Se() {
      const Ce = quill.getSelection();
      Ce && Ce.length > 0 && (this.quill.insertText(Ce.index + Ce.length, "</sub>"), this.quill.insertText(Ce.index, '<sub alias="Enter Substitute Text Here">'), this.quill.setSelection(Ce.index + Ce.length + 46));
    }
    function Te() {
      ssmlCheckExports.check(quill.getText()).then((Ce) => {
        const Ie = '<span class="material-symbols-outlined" title="Valid">check_circle</span>', Ne = '<span class="material-symbols-outlined" title="Invalid">error</span>', Re = document.getElementById("ssmlStatus");
        Re.innerHTML = "", Re.classList.remove("hidden"), console.log(Ce), Ce ? ssmlCheckExports.verifyAndFix(quill.getText()).then((Ae) => {
          if (Ae.fixedSSML)
            console.log(Ae.fixedSSML);
          else if (Ae.errors) {
            let Pe = "";
            Re.classList.remove("ssmlStatusValid"), Re.classList.add("ssmlStatusInvalid"), Ae.errors[0]?.tag === "speak" && (Pe = ". Check body is encased within a &lt;speak&gt;&lt;/speak&gt; element."), Re.innerHTML = `${Ne} Invalid SSML${Pe}`, console.log(JSON.stringify(Ae.errors));
          }
        }) : (Re.classList.remove("ssmlStatusInvalid"), Re.classList.add("ssmlStatusValid"), Re.innerHTML = `${Ie} Valid SSML`);
      });
    }
  }
  processBlankLines(Y) {
    return Y = Y.trim(), Y.split(/\n\n/).map((ue) => (ue = ue.trim(), `<p>${ue.split(/(?<=\.)\s+/).map((_e) => `<s>${_e}</s>`).join("")}</p>`)).join("");
  }
  processLineBreaks(Y) {
    const re = new DOMParser(), oe = new XMLSerializer(), ue = re.parseFromString(Y, "text/xml"), fe = ue.querySelector("speak");
    if (fe) {
      const he = fe.textContent, _e = this.processBlankLines(he);
      for (; fe.firstChild; )
        fe.removeChild(fe.firstChild);
      const ve = re.parseFromString(`<speak>${_e}</speak>`, "text/xml").documentElement;
      Array.from(ve.childNodes).forEach((xe) => {
        fe.appendChild(ue.importNode(xe, !0));
      });
    }
    return oe.serializeToString(ue);
  }
}
SsmlToolbar.DEFAULTS = {};
requireBuffer();
const state$1 = {
  elements: {
    editor: null,
    wrapper: null
  },
  modules: {
    editor: {
      id: "ssmlEditor-editor"
    }
  },
  quill: null
};
function run$1(le, Y) {
  const re = Y || {
    debug: "warn",
    modules: {
      toolbar: {
        container: [
          [{ ssml_break: ["250ms", "500ms", "750ms", "1s"] }],
          ["ssml_emphasis"],
          [{ ssml_gender: ["Female", "Male", "Neutral"] }],
          [{ ssml_language: ["en-US", "en-GB", "de-DE", "es-ES", "fr-FR", "it-IT", "nl-NL", "ru-RU", "tr-TR"] }],
          [{ ssml_sayas: ["spell-out", "number", "ordinal", "digits", "fraction", "expletive"] }],
          [{ ssml_date: ["mdy", "dmy", "ymd", "md", "dm", "ym", "my", "d", "m", "y"] }],
          ["ssml_substitute"],
          ["ssml_phoneme"],
          [{ ssml_prosody: ["25%", "50%", "75%", "100%", "125%"] }],
          ["ssml_validate"]
        ],
        handlers: {
          ssml_break: function() {
          },
          ssml_emphasis: function() {
          },
          ssml_gender: function() {
          },
          ssml_language: function() {
          },
          ssml_sayas: function() {
          },
          ssml_date: function() {
          },
          ssml_substitute: function() {
          },
          ssml_phoneme: function() {
          },
          ssml_prosody: function() {
          },
          ssml_validate: function() {
          }
        }
      },
      ssmlToolbar: !0
    },
    placeholder: "",
    theme: "snow"
  };
  return setupDOMContainers(le), state$1.quill || Quill.register({
    "modules/ssmlToolbar": SsmlToolbar
  }), state$1.quill = new Quill(state$1.elements.editor, re), state$1.quill.setText(`<speak version="1.1" xml:lang="en-US">

</speak>`), state$1.quill.setSelection(39, 0), state$1.quill;
}
function setupDOMContainers(le) {
  const Y = document.createElement("div"), re = typeof le == "string" ? document.getElementById(le) : le;
  Y.setAttribute("id", state$1.modules.editor.id), state$1.elements.editor = Y, state$1.elements.wrapper = re, re instanceof HTMLElement ? re.appendChild(Y) : console.error("Trouble finding the editor wrapper. Pass an `id` (no hash) or a DOM element.");
}
const ssmlEditor$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  run: run$1
}, Symbol.toStringTag, { value: "Module" })), state = {
  renderedCss: !1
};
function run() {
  state.renderedCss || injectCSS();
}
function launchSsmlEditor(le, Y) {
  const re = window.getSelection().toString(), oe = window.getSelection().getRangeAt(0), ue = document.createElement("div");
  ue.appendChild(oe.cloneContents());
  const fe = ue.innerHTML;
  document.querySelector(".learnosity-question-editor").insertAdjacentHTML("beforeEnd", `
        <div class="lrn-qe lrn-qe-modal" style="display: block;" id="lt__ssmlModalWrapper">
            <div class="lrn-qe-ui">
                <div class="lrn-qe-modal-dialog">
                    <div class="lrn-qe-modal-dialog-inner">
                        <div class="lrn-qe-modal-header">
                            <div class="lrn-qe-form-label lrn-qe-h4 lrn-qe-section-header">
                                <h4 class="lrn-qe-heading"><label class="lrn-qe-label lrn-qe-form-label-name">Enter SSML</label></h4>
                            </div>
                            <button type="button" class="lrn-qe-btn lrn-qe-modal-btn-close" aria-label="Close" tabindex="0">
                                <span class="lrn-qe-sr-only">Close</span>
                                <span aria-role="presentation" class="lrn-qe-i-cross"></span>
                            </button>
                        </div>
                        <div data-lrn-qe-selector="modal-outlet">
                            <div class="lrn-qe-modal-content" data-lrn-qe-modal-section="content">
                                <div id="editor"></div>
                                <div id="ssmlStatus"></div>
                            </div>
                            <div class="lrn-qe-modal-footer">
                                <ul class="lrn-qe-ul">
                                    <li class="lrn-qe-li lrn-qe-modal-footer-item">
                                        <button type="button" class="lrn-qe-btn lrn-qe-btn-default"><span>Cancel</span></button>
                                    </li>&nbsp;
                                    <li class="lrn-qe-li lrn-qe-modal-footer-item">
                                        <button type="button" class="lrn-qe-btn lrn-qe-btn-primary lt__ssml-add" data-lrn-qe-modal-action="confirm"><span>Add SSML</span></button>
                                    </li>&nbsp;
                                    <li class="lrn-qe-li lrn-qe-modal-footer-item">
                                        <button type="button" class="lrn-qe-btn lrn-qe-btn-primary lt__ssml-generate-audio"><span>⭐ Generate audio</span></button>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        `);
  const _e = [];
  _e.push(document.querySelector("#lt__ssmlModalWrapper .lrn-qe-btn-default")), _e.push(document.querySelector("#lt__ssmlModalWrapper .lrn-qe-modal-btn-close"));
  for (let xe = 0; xe < _e.length; xe++)
    _e[xe].addEventListener("click", () => (removeElement("lt__ssmlModalWrapper"), delete window.quill, Y(fe)));
  if (document.querySelector("#lt__ssmlModalWrapper .lt__ssml-add").addEventListener("click", () => {
    removeElement("lt__ssmlModalWrapper");
    const xe = window.quill.getText();
    return delete window.quill, Y(`<span>${xe}</span>`);
  }), !window.hasOwnProperty("quill")) {
    const xe = run$1("editor");
    if (re) {
      const Ee = xe.getSelection();
      xe.insertText(Ee.index, re);
    }
    window.quill = xe, window.ssmlEditor = ssmlEditor$1;
  }
}
function removeElement(le) {
  document.getElementById(le).remove();
}
function injectCSS() {
  const le = document.createElement("style"), Y = `
/* Learnosity SSML TTS styles */
#lt__ssmlModalWrapper .lrn-qe-modal-content {
    height: 23em;
}
#lt__ssmlModalWrapper .ql-editor {
    height: 12rem;
}
#lt__ssmlModalWrapper .ql-editor p {
    margin: 0;
}
#lt__ssmlModalWrapper .ql-toolbar.ql-snow .ql-formats {
    margin-right: 14px;
}
.hidden {
    display: none;
}
#lt__ssmlModalWrapper .material-symbols-outlined {
    font-size: 1.3rem;
    position: relative;
    top: -2px;
}
#lt__ssmlModalWrapper .ql-picker {
    padding: 3px 0;
}
#lt__ssmlModalWrapper .ql-picker-label {
    width: 45px;
    height: 18px;
}
#ssmlStatus .material-symbols-outlined {
    vertical-align: middle;
}
.ssmlStatusValid {
    padding: 1em;
    background-color: #cbf5d3;
}
.ssmlStatusInvalid {
    padding: 1em;
    background-color: #ffb9b9;
}
speak s {
    text-decoration: none;
}
`;
  le.textContent = Y, document.head.append(le), state.renderedCss = !0;
}
const ssmlEditor = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  launchSsmlEditor,
  run
}, Symbol.toStringTag, { value: "Module" })), extensions = {
  extensions: {
    contentTabs: { ...contentTabs },
    createTags: { ...createTags },
    dynamicContent: { ...dynamicContent },
    essayMaxLength: { ...essayMaxLength },
    imageUploader: { ...imageUploader },
    languageTextDirection: { ...languageTextDirection },
    nativeTabs: { ...nativeTabs },
    renderPDF: { ...renderPDF },
    singleQuestion: { ...singleQuestion },
    ssmlEditor: { ...ssmlEditor }
  }
}, LT = { ...LT$1, ...extensions };
export {
  LT
};
