import { a as appInstance } from "./app-CxUsV76e.js";
import logger from "./logger.js";
import { s as setObserver } from "./dom-WlatGxUZ.js";
import { a as getDefaultExportFromCjs } from "./_commonjsHelpers-DQNKXVTB.js";
import { d as debounce } from "./debounce-CqEeJcMa.js";
class GenericElementUtils {
  static hideElements(...x) {
    x.forEach((w) => w.style.display = "none");
  }
  static getStyleWidth(x, w) {
    return Number.parseFloat(x.style[w]) || 0;
  }
  static doesElementExistInDom(x) {
    return !!x.parentElement;
  }
  static isFirstChildInParent(x) {
    var w;
    return ((w = x.parentElement) == null ? void 0 : w.firstChild) === x;
  }
}
GenericElementUtils.NOT_SELECTABLE_CLASS = "not-selectable";
class SVGIconUtils {
  // REF-10
  static createSVGElement(x) {
    return new DOMParser().parseFromString(x, "image/svg+xml").documentElement;
  }
}
SVGIconUtils.WHITE_FILTER = `brightness(0) saturate(100%) invert(100%) sepia(1%) saturate(3877%)
    hue-rotate(184deg) brightness(103%) contrast(100%)`;
SVGIconUtils.LIGHT_GREY_FILTER = `brightness(0) saturate(100%) invert(68%) sepia(0%) saturate(317%)
    hue-rotate(84deg) brightness(92%) contrast(93%)`;
SVGIconUtils.HEADER_FILTER = `brightness(0) saturate(100%) invert(34%) sepia(0%) saturate(1075%)
    hue-rotate(211deg) brightness(96%) contrast(90%)`;
SVGIconUtils.DROPDOWN_ITEM_FILTER = `brightness(0) saturate(100%) invert(7%) sepia(23%) saturate(258%)
    hue-rotate(63deg) brightness(99%) contrast(97%)`;
class StaticDropdown {
}
StaticDropdown.DROPDOWN_CLASS = "static-dropdown";
StaticDropdown.ITEM_CLASS = "static-dropdown-item";
StaticDropdown.ACTIVE_ITEM_CLASS = "active-static-dropdown-item";
const _DropdownItemHighlightUtils = class Mr {
  // Accepted behaviour - fadeFocused is triggered twice when moving to a different item
  static fadeCurrentlyHighlighted(x) {
    const w = x.dropdownItem;
    w && (w.classList.contains(StaticDropdown.ACTIVE_ITEM_CLASS) && w.classList.remove(StaticDropdown.ACTIVE_ITEM_CLASS), w.style.backgroundColor = "", delete x.dropdownItem);
  }
  static highlightNew(x, w) {
    Mr.fadeCurrentlyHighlighted(x), w.focus(), x.dropdownItem = w, w.classList.contains(StaticDropdown.ITEM_CLASS) ? w.classList.add(StaticDropdown.ACTIVE_ITEM_CLASS) : w.classList.contains(DropdownItem.DROPDOWN_INPUT_CLASS) || (w.style.backgroundColor = Mr.HOVER_BACKGROUND_COLOR);
  }
};
_DropdownItemHighlightUtils.HOVER_BACKGROUND_COLOR = "#eaeaea";
let DropdownItemHighlightUtils = _DropdownItemHighlightUtils;
class DropdownItemEvents {
  // prettier-ignore
  static addItemEvents(x, w) {
    w.addEventListener(
      "mouseenter",
      DropdownItemHighlightUtils.highlightNew.bind(this, x, w)
    ), w.addEventListener(
      "mouseleave",
      DropdownItemHighlightUtils.fadeCurrentlyHighlighted.bind(this, x)
    );
  }
}
const _DropdownItem = class xt {
  static toggleItem(x, w) {
    x.style.display = w ? xt.DISPLAY : xt.HIDDEN;
  }
  static isDisplayed(x) {
    return x.style.display === xt.DISPLAY;
  }
  static createDropdownItemBaseElement(x) {
    const w = document.createElement(x);
    return w.classList.add(xt.DROPDOWN_ITEM_IDENTIFIER), w;
  }
  static createItem(x) {
    const w = xt.createDropdownItemBaseElement("div");
    return x && (w.tabIndex = x.children.length), w.classList.add(xt.DROPDOWN_ITEM_CLASS, GenericElementUtils.NOT_SELECTABLE_CLASS), w;
  }
  // no need to sanitize paste as input element already does it
  static addInputItem(x, w) {
    const O = xt.createItem(w);
    O.classList.add(xt.DROPDOWN_INPUT_ITEM_CLASS);
    const D = xt.createDropdownItemBaseElement("input");
    D.classList.add(xt.DROPDOWN_INPUT_CLASS), O.appendChild(D), w.appendChild(O), DropdownItemEvents.addItemEvents(x._activeOverlayElements, D);
  }
  // REF-10
  static insertIcon(x, w) {
    const { svgString: O, containerStyles: D } = w, U = document.createElement("div");
    U.classList.add(xt.DROPDOWN_ITEM_ICON_CONTAINER_CLASS), Object.assign(U.style, D?.dropdown);
    const W = SVGIconUtils.createSVGElement(O);
    W.style.filter = SVGIconUtils.DROPDOWN_ITEM_FILTER, U.appendChild(W), x.insertBefore(U, x.children[0]);
  }
  static addPlaneButtonItem(x, w, O) {
    const D = xt.createItem(x), U = xt.createDropdownItemBaseElement("div");
    return U.innerText = w || xt.DROPDOWN_ITEM_EMPTY_PLACEHOLDER_TEXT, w.trim() === "" && U.classList.add(xt.DROPDOWN_ITEM_EMPTY_CLASS), D.append(U), x && (O !== void 0 && x.children[O] ? x.insertBefore(D, x.children[O]) : x.appendChild(D)), D;
  }
  // prettier-ignore
  static createButtonItemNoEvents(x, w, ...O) {
    const D = xt.addPlaneButtonItem(x, w.text);
    return w.iconSettings && xt.insertIcon(D, w.iconSettings), O.length > 0 && D.classList.add(...O), D;
  }
  static addTitle(x, w) {
    const O = xt.createDropdownItemBaseElement("div");
    O.classList.add(xt.DROPDOWN_ITEM_CLASS, xt.DROPDOWN_TITLE_ITEM_CLASS), O.innerText = w, x.appendChild(O);
  }
  static addDivider(x) {
    const w = xt.createDropdownItemBaseElement("div");
    w.classList.add(xt.DROPDOWN_ITEM_DIVIDER_CLASS), x.appendChild(w);
  }
  // prettier-ignore
  static addButtonItem(x, w, O, ...D) {
    const U = xt.createButtonItemNoEvents(w, O, ...D);
    return DropdownItemEvents.addItemEvents(x._activeOverlayElements, U), U;
  }
  // prettier-ignore
  static addNewButtonItems(x, w, O) {
    return O.map((D) => xt.addButtonItem(x, w, D));
  }
  static addButtonItemElements(x, w, O) {
    O.forEach((D) => {
      D.tabIndex = w.children.length, w.appendChild(D), DropdownItemEvents.addItemEvents(x._activeOverlayElements, D);
    });
  }
  static removeItems(x) {
    Array.from(x.children).forEach((w) => w.remove());
  }
  static doesElementContainItemClass(x) {
    return x.classList.contains(xt.DROPDOWN_ITEM_IDENTIFIER);
  }
  static doesElementContainInputClass(x) {
    return x.classList.contains(xt.DROPDOWN_INPUT_CLASS);
  }
  static getInputElement(x) {
    return x.getElementsByClassName(xt.DROPDOWN_INPUT_ITEM_CLASS)[0];
  }
  static toggleUsability(x, w) {
    const O = x.children[0];
    w ? (x.classList.remove(xt.DISABLED_ITEM_CLASS), O.style.filter = "") : (x.classList.add(xt.DISABLED_ITEM_CLASS), O.style.filter = SVGIconUtils.LIGHT_GREY_FILTER);
  }
};
_DropdownItem.DROPDOWN_ITEM_CLASS = "dropdown-item";
_DropdownItem.DISABLED_ITEM_CLASS = "dropdown-disabled-item";
_DropdownItem.ACTIVE_ITEM_CLASS = "active-dropdown-item";
_DropdownItem.DROPDOWN_INPUT_CLASS = "dropdown-input";
_DropdownItem.DROPDOWN_ITEM_ICON_CONTAINER_CLASS = "dropdown-item-icon-container";
_DropdownItem.DROPDOWN_INPUT_ITEM_CLASS = "dropdown-input-item";
_DropdownItem.DROPDOWN_TITLE_ITEM_CLASS = "dropdown-title-item";
_DropdownItem.DROPDOWN_ITEM_DIVIDER_CLASS = "dropdown-item-divider";
_DropdownItem.DROPDOWN_ITEM_EMPTY_CLASS = "dropdown-item-empty";
_DropdownItem.DROPDOWN_ITEM_EMPTY_PLACEHOLDER_TEXT = "...";
_DropdownItem.DROPDOWN_ITEM_IDENTIFIER = "dropdown-item-identifier";
_DropdownItem.HIDDEN = "none";
_DropdownItem.DISPLAY = "";
let DropdownItem = _DropdownItem;
class OuterDropdownItem {
  static unsetHoverColors(x) {
    x.forEach((w) => w.style.backgroundColor = "");
  }
  static unsetActiveItem(x) {
    const w = x.getElementsByClassName(DropdownItem.ACTIVE_ITEM_CLASS)[0];
    w?.classList.remove(DropdownItem.ACTIVE_ITEM_CLASS);
  }
  static setActive(x, w) {
    const O = x.find((D) => D.innerText === w);
    O?.classList.add(DropdownItem.ACTIVE_ITEM_CLASS);
  }
  static setActiveByIndex(x, w) {
    x[w].classList.add(DropdownItem.ACTIVE_ITEM_CLASS);
  }
}
class ElementStyle {
  static setStyle(x, w, O) {
    x.style[w] = O;
  }
  // prettier-ignore
  static moveStyles(x, w, ...O) {
    O.forEach((D) => {
      x.style[D] && ElementStyle.setStyle(w, D, x.style[D]);
    });
  }
  static unsetStyle(x, w) {
    const O = Object.keys(w).reduce((D, U) => (D[U] = "", D), {});
    Object.assign(x.style, O);
  }
  static unsetAllCSSStates(x, w) {
    w.click && ElementStyle.unsetStyle(x, w.click), w.hover && ElementStyle.unsetStyle(x, w.hover), w.default && ElementStyle.unsetStyle(x, w.default);
  }
  static generateStatefulCSS(x, w, O) {
    const D = x.default || {}, U = Object.assign(JSON.parse(JSON.stringify({ ...D, ...w })), x?.hover), W = Object.assign(JSON.parse(JSON.stringify({ ...U, ...O })), x?.click);
    return { default: D, hover: U, click: W };
  }
}
const _ToggleableElement = class Vt {
  static set(x, w) {
    x.classList.add(Vt.ACTIVE_BUTTON_CLASS), Object.assign(x.style, w);
  }
  static unset(x, w) {
    x.classList.remove(Vt.ACTIVE_BUTTON_CLASS), ElementStyle.unsetStyle(x, w);
  }
  static toggleActive(x, w) {
    const O = !!x.classList.contains(Vt.ACTIVE_BUTTON_CLASS);
    return O ? (Vt.unset(x, w), x.dispatchEvent(new MouseEvent("mouseenter"))) : Vt.set(x, w), O;
  }
  static unsetActive(x, w) {
    x.classList.contains(Vt.ACTIVE_BUTTON_CLASS) && (Vt.unset(x, w), x.dispatchEvent(new MouseEvent("mouseleave")));
  }
  static setActive(x, w) {
    x.classList.contains(Vt.ACTIVE_BUTTON_CLASS) || Vt.set(x, w);
  }
};
_ToggleableElement.ACTIVE_BUTTON_CLASS = "toggleable-button-active";
_ToggleableElement.AUTO_STYLING_CLASS = "toggleable-button-auto-styling";
let ToggleableElement = _ToggleableElement;
const _Dropdown = class Yt {
  static createBase() {
    const x = document.createElement("div");
    return x.classList.add(Yt.DROPDOWN_CLASS), x.style.width = `${Yt.DROPDOWN_WIDTH}px`, x.style.paddingTop = Yt.DROPDOWN_VERTICAL_PX, x.style.paddingBottom = Yt.DROPDOWN_VERTICAL_PX, Yt.hide(x), x;
  }
  static isDisplayed(x) {
    return x?.style.display === Yt.CSS_DISPLAY_VISIBLE;
  }
  static display(...x) {
    x.forEach((w) => {
      w.style.display = Yt.CSS_DISPLAY_VISIBLE;
    });
  }
  static hide(...x) {
    GenericElementUtils.hideElements(...x);
  }
  static isPartOfDropdownElement(x) {
    return x.classList.contains(Yt.DROPDOWN_CLASS) || DropdownItem.doesElementContainItemClass(x);
  }
};
_Dropdown.DROPDOWN_CLASS = "active-table-dropdown";
_Dropdown.CSS_DISPLAY_VISIBLE = "grid";
_Dropdown.DROPDOWN_WIDTH = 176;
_Dropdown.DROPDOWN_VERTICAL_PX = "4px";
let Dropdown = _Dropdown;
const _OuterDropdownButtonEvents = class ir {
  static mouseClickButton(x, w, O) {
    const { element: D } = w;
    D.classList.contains(ir.DO_NOT_DISPLAY_DROPDOWN_CLASS) ? D.classList.remove(ir.DO_NOT_DISPLAY_DROPDOWN_CLASS) : O(x, w);
  }
  static mouseDownButton(x) {
    const { element: w, button: O, activeButtonStyle: D } = x;
    Dropdown.isDisplayed(w) && (w.classList.add(ir.DO_NOT_DISPLAY_DROPDOWN_CLASS), ToggleableElement.unsetActive(O, D));
  }
  static getDisplayFunc(x) {
    return x.startsWith("top") ? OuterDropdownElement.display : OuterDropdownElement.displayReactToBottomVisibility;
  }
  // prettier-ignore
  static set(x, w, O, D, U) {
    const W = U || ir.getDisplayFunc(O);
    w.addEventListener("mousedown", ir.mouseDownButton.bind(this, D)), w.addEventListener(
      "click",
      ir.mouseClickButton.bind(this, x, D, W)
    );
  }
};
_OuterDropdownButtonEvents.DO_NOT_DISPLAY_DROPDOWN_CLASS = "do-not-display-class";
let OuterDropdownButtonEvents = _OuterDropdownButtonEvents;
const VH = "vh", VW = "vw";
class LITElementTypeConverters {
  static convertToBoolean(F) {
    return typeof F == "string" ? F === "true" : !!F;
  }
  static convertToFunction(value) {
    if (typeof value == "function")
      return value;
    if (typeof value == "string") {
      const evaluatedExpression = eval(value);
      if (typeof evaluatedExpression == "function")
        return evaluatedExpression;
    }
    return () => {
    };
  }
}
class ObjectUtils {
  static createTwoWayObject(x) {
    return Object.keys(x).forEach((w) => {
      x[x[w]] = w;
    }), x;
  }
  static convertStringToFunction(x, w) {
    typeof x[w] == "string" && (x[w] = LITElementTypeConverters.convertToFunction(
      x[w]
    ));
  }
  // method to check if value is not nullish
  static areValuesFullyDefined(...x) {
    return x.findIndex((w) => w == null) === -1;
  }
  static removeProperties(x, ...w) {
    w.forEach((O) => {
      delete x[O];
    });
  }
}
class RegexUtils {
  static extractIntegerStrs(x) {
    return x.match(/\d+/g);
  }
  static extractFloatStrs(x) {
    return x.match(/-?\d+(\.\d+)?$/g);
  }
}
class StringDimensionUtils {
  static processDimension(x, w) {
    return x < w ? w : x;
  }
  // prettier-ignore
  static processPercentageDimension(x, w, O, D) {
    w > 100 && (w = 100);
    const U = (O ? x.getBoundingClientRect().width : x.offsetHeight) * (w / 100);
    return { number: StringDimensionUtils.processDimension(U, D), isPercentage: !0 };
  }
  // can also parse numbers incase the client used that
  // if this returns a number 0 for a %, the likelyhood is that the parent element does not have that dimension set
  // prettier-ignore
  static generateNumberDimensionFromClientString(x, w, O, D, U = 0) {
    const W = w[O], X = typeof W == "string";
    let G = X ? Number(RegexUtils.extractIntegerStrs(W)[0]) : W;
    if (X) {
      if (W.includes("%"))
        return StringDimensionUtils.processPercentageDimension(x, G, D, U);
      W.includes(VH) ? G = window.innerHeight * (G / 100) : W.includes(VW) && (G = window.innerWidth * (G / 100));
    }
    return { number: StringDimensionUtils.processDimension(G, U), isPercentage: !1 };
  }
  static removeAllDimensions(x) {
    if (x)
      return ObjectUtils.removeProperties(x, "width", "minWidth", "maxWidth", "height", "minHeight", "maxHeight"), x;
  }
}
class PageButtonStyle {
  // prettier-ignore
  static unsetAllCSSStates(x, w, O) {
    ElementStyle.unsetAllCSSStates(x, w[O]);
  }
  static unsetAll(x, w, O) {
    x.classList.contains(w.activeButtonClass) ? PageButtonStyle.unsetAllCSSStates(x, w, "activeButton") : x.classList.contains(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS) ? ElementStyle.unsetStyle(x, w.disabledButtons) : PageButtonStyle.unsetAllCSSStates(x, w, O ? "actionButtons" : "buttons");
  }
  static setDefault(x, w, O) {
    PageButtonStyle.unsetAll(x, w, O), O ? Object.assign(x.style, w.actionButtons.default) : Object.assign(x.style, w.buttons.default);
  }
  // prettier-ignore
  static setActive(x, w, O) {
    O && (PageButtonStyle.unsetAllCSSStates(O, w, "activeButton"), Object.assign(O.style, w.buttons.default)), x.classList.contains(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS) ? ElementStyle.unsetStyle(x, w.disabledButtons) : PageButtonStyle.unsetAllCSSStates(x, w, "buttons"), Object.assign(x.style, w.activeButton.default);
  }
  static setDisabled(x, w, O) {
    PageButtonStyle.setDefault(x, w, O), Object.assign(x.style, w.disabledButtons);
  }
  static mouseDown(x, w, O) {
    x.classList.contains(w.activeButtonClass) ? Object.assign(x.style, w.activeButton.click) : O ? Object.assign(x.style, w.actionButtons.click) : Object.assign(x.style, w.buttons.click), PaginationVisibleButtonsUtils.overrideOnMouseEvent(x, w);
  }
  static mouseEnter(x, w, O) {
    x.classList.contains(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS) || (x.classList.contains(w.activeButtonClass) ? (PageButtonStyle.unsetAllCSSStates(x, w, "activeButton"), Object.assign(x.style, w.activeButton.default), Object.assign(x.style, w.activeButton.hover)) : (PageButtonStyle.setDefault(x, w, O), O ? Object.assign(x.style, w.actionButtons.hover) : Object.assign(x.style, w.buttons.hover)), PaginationVisibleButtonsUtils.overrideOnMouseEvent(x, w));
  }
  static mouseLeave(x, w, O) {
    x.classList.contains(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS) || (x.classList.contains(w.activeButtonClass) ? (PageButtonStyle.unsetAll(x, w, !1), Object.assign(x.style, w.activeButton.default)) : PageButtonStyle.setDefault(x, w, O), PaginationVisibleButtonsUtils.overrideOnMouseEvent(x, w));
  }
}
const _FilterInputElement = class or {
  static setPlaceholder(x, w, O) {
    if (w && w !== "") {
      const D = O || or.DEFAULT_PLACEHOLDER_TEMPLATE;
      x.placeholder = D.replace(or.TEMPLATE_VARIABLE, w);
    } else
      x.placeholder = or.DEFAULT_PLACEHOLDER;
  }
  static createElement(x, w, O) {
    const D = document.createElement("input");
    D.classList.add(or.INPUT_CLASS);
    const U = O?.placeholderColor || "#656565";
    return D.style.setProperty("--active-table-filter-placeholder-color", U), Object.assign(D.style, O?.input), or.setPlaceholder(D, x, w), D;
  }
  static create(x, w, O) {
    const D = FilterInternalUtils.generateDefaultHeaderName(O, x.defaultColumnHeaderName), U = or.createElement(D, x.placeholderTemplate, w.styles);
    return x.inputElement = U, U;
  }
};
_FilterInputElement.INPUT_CLASS = "filter-rows-input";
_FilterInputElement.TEMPLATE_VARIABLE = "{headerName}";
_FilterInputElement.DEFAULT_PLACEHOLDER = "Filter";
_FilterInputElement.DEFAULT_PLACEHOLDER_TEMPLATE = `Filter ${_FilterInputElement.TEMPLATE_VARIABLE}...`;
let FilterInputElement = _FilterInputElement;
class FilterInputEvents {
  static unsetEvents(x) {
    x && x.forEach((w) => w.inputElement.oninput = () => {
    });
  }
  static updateSameInputValues(x, w) {
    x.forEach((O) => {
      O.elements === w.elements && (O.inputElement.value = w.inputElement.value);
    });
  }
  static getFilterData(x) {
    return x.map((w) => ({
      filterText: w.isCaseSensitive ? w.inputElement.value : w.inputElement.value.toLocaleLowerCase(),
      colCells: w.elements.slice(1),
      isCaseSensitive: w.isCaseSensitive
    }));
  }
  static splitChunksAndExecute(x, w) {
    const O = x.filter((U) => U.filterText !== "");
    O.length === 0 && O.push(x[0]);
    const D = Math.ceil(O[0].colCells.length / FilterInternalUtils.CHUNK_SIZE);
    for (let U = 0; U < D; U += 1) {
      const W = U * FilterInternalUtils.CHUNK_SIZE, X = O.map((G) => ({ ...G, chunk: G.colCells.slice(W, W + FilterInternalUtils.CHUNK_SIZE) }));
      w(X);
    }
  }
  static setEvents(x, w, O) {
    if (!w.elements)
      return;
    const D = FilterInternalUtils.getFilterFunc(x), U = O.filter((W) => W !== w);
    w.inputElement.oninput = () => {
      FilterInputEvents.updateSameInputValues(U, w), FilterInputEvents.splitChunksAndExecute(FilterInputEvents.getFilterData(O), D);
    };
  }
}
const ARROW_DOWN_SVG_STRING = `<?xml version="1.0" encoding="UTF-8"?>
<svg viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
		<g transform="translate(-288.000000, 0.000000)">
			<g transform="translate(288.000000, 0.000000)">
				<path d="M24,0 L24,24 L0,24 L0,0 L24,0 Z M12.5934901,23.257841 L12.5819402,23.2595131 L12.5108777,23.2950439 L12.4918791,23.2987469 L12.4918791,23.2987469 L12.4767152,23.2950439 L12.4056548,23.2595131 C12.3958229,23.2563662 12.3870493,23.2590235 12.3821421,23.2649074 L12.3780323,23.275831 L12.360941,23.7031097 L12.3658947,23.7234994 L12.3769048,23.7357139 L12.4804777,23.8096931 L12.4953491,23.8136134 L12.4953491,23.8136134 L12.5071152,23.8096931 L12.6106902,23.7357139 L12.6232938,23.7196733 L12.6232938,23.7196733 L12.6266527,23.7031097 L12.609561,23.275831 C12.6075724,23.2657013 12.6010112,23.2592993 12.5934901,23.257841 L12.5934901,23.257841 Z M12.8583906,23.1452862 L12.8445485,23.1473072 L12.6598443,23.2396597 L12.6498822,23.2499052 L12.6498822,23.2499052 L12.6471943,23.2611114 L12.6650943,23.6906389 L12.6699349,23.7034178 L12.6699349,23.7034178 L12.678386,23.7104931 L12.8793402,23.8032389 C12.8914285,23.8068999 12.9022333,23.8029875 12.9078286,23.7952264 L12.9118235,23.7811639 L12.8776777,23.1665331 C12.8752882,23.1545897 12.8674102,23.1470016 12.8583906,23.1452862 L12.8583906,23.1452862 Z M12.1430473,23.1473072 C12.1332178,23.1423925 12.1221763,23.1452606 12.1156365,23.1525954 L12.1099173,23.1665331 L12.0757714,23.7811639 C12.0751323,23.7926639 12.0828099,23.8018602 12.0926481,23.8045676 L12.108256,23.8032389 L12.3092106,23.7104931 L12.3186497,23.7024347 L12.3186497,23.7024347 L12.3225043,23.6906389 L12.340401,23.2611114 L12.337245,23.2485176 L12.337245,23.2485176 L12.3277531,23.2396597 L12.1430473,23.1473072 Z" fill-rule="nonzero"></path>
				<path d="M12.7071,15.7072 C12.3166,16.0977 11.6834,16.0977 11.2929,15.7072 L5.63604,10.0503 C5.24551,9.65982 5.24551,9.02666 5.63604,8.63613 C6.02656,8.24561 6.65973,8.24561 7.05025,8.63613 L12,13.5859 L16.9497,8.63613 C17.3403,8.24561 17.9734,8.24561 18.364,8.63613 C18.7545,9.02666 18.7545,9.65982 18.364,10.0503 L12.7071,15.7072 Z" fill="#09244B"></path>
			</g>
		</g>
	</g>
</svg>`, _FilterButtonElement = class Kr {
  static create(x = {}) {
    const w = document.createElement("div");
    w.classList.add("filter-rows-dropdown-button", ToggleableElement.AUTO_STYLING_CLASS), FilterElements.applyStatefulStyles(w, Kr.HOVER_STYLE, x);
    const O = SVGIconUtils.createSVGElement(ARROW_DOWN_SVG_STRING);
    return w.appendChild(O), w;
  }
};
_FilterButtonElement.ACTIVE_STYLE = {
  filter: (
    // eslint-disable-next-line max-len
    "brightness(0) saturate(100%) invert(14%) sepia(59%) saturate(2970%) hue-rotate(219deg) brightness(98%) contrast(126%)"
  )
};
_FilterButtonElement.HOVER_STYLE = {
  filter: (
    // eslint-disable-next-line max-len
    "brightness(0) saturate(100%) invert(31%) sepia(1%) saturate(75%) hue-rotate(327deg) brightness(100%) contrast(99%)"
  )
};
let FilterButtonElement = _FilterButtonElement;
class OuterDropdownItemEvents {
  // prettier-ignore
  static itemMouseDownCommon(x, w, O) {
    const { _activeOverlayElements: { outerContainerDropdown: D } } = this, U = O.target.innerText;
    if (!D)
      return;
    x?.(this, U, O);
    const W = Array.from(D.element.children);
    w?.(this._activeOverlayElements, W), D.element.classList.contains(StaticDropdown.DROPDOWN_CLASS) || (OuterDropdownItem.unsetActiveItem(D.element), OuterDropdownItem.setActive(W, U), DropdownItemHighlightUtils.fadeCurrentlyHighlighted(this._activeOverlayElements));
  }
}
class FilterDropdownItemEvents {
  static resetInput(x, w, O, D) {
    const U = D.target, W = U.tabIndex === -1 ? U.parentElement.tabIndex : U.tabIndex, X = w._columnsDetails[W].elements;
    X !== x.elements && (x.elements = X, FilterInternalUtils.resetInput(w, x), FilterInternalUtils.unsetFilter(x.inputElement));
  }
  static setEvents(x, w, O, D) {
    const U = FilterDropdownItemEvents.resetInput.bind(this, O), W = FilterDropdownElement.hide.bind(this, D);
    w.onmousedown = OuterDropdownItemEvents.itemMouseDownCommon.bind(x, U, W);
  }
}
class FilterDropdownItem {
  static setActive(x, w, O) {
    const D = x._columnsDetails.findIndex((U) => U.elements === O.elements);
    OuterDropdownItem.setActiveByIndex(Array.from(w.children), D);
  }
  static addItems(x, w, O) {
    var D;
    const U = (D = x.data[0]) == null ? void 0 : D.map((W) => String(W));
    U?.forEach((W) => {
      const X = { text: W }, G = DropdownItem.addButtonItem(x, w.element, X);
      FilterDropdownItemEvents.setEvents(x, G, O, w.activeButtonStyle);
    });
  }
  static populate(x, w, O) {
    w.element.replaceChildren(), FilterDropdownItem.addItems(x, w, O), FilterDropdownItem.setActive(x, w.element, O);
  }
}
class FilterDropdownElement {
  static hide(x, w) {
    OuterDropdownElement.hide(w, x);
  }
  // prettier-ignore
  static display(x, w, O, D) {
    O.data[0] && (FilterDropdownItem.populate(O, D, w), x(O, D));
  }
  // prettier-ignore
  static create(x, w, O, D, U) {
    const W = FilterButtonElement.create(U);
    w.appendChild(W);
    const X = U?.active || {}, G = { ...FilterButtonElement.ACTIVE_STYLE, ...X }, Y = FilterDropdownElement.hide.bind(this, G, x._activeOverlayElements), K = OuterDropdownButtonEvents.getDisplayFunc(O), Z = FilterDropdownElement.display.bind(this, K, D), { element: q } = OuterDropdownElement.create(
      x,
      W,
      O,
      G,
      ["filter-rows-dropdown"],
      Y,
      Z
    );
    return q;
  }
}
class StatefulCSSEvents {
  static apply(x, w, O) {
    ElementStyle.unsetAllCSSStates(O, x), Object.assign(O.style, w);
  }
  static mouseUp(x, w, O) {
    w && O.classList.contains(w) || (StatefulCSSEvents.apply(x, x.default, O), Object.assign(O.style, x.hover));
  }
  static mouseDown(x, w, O) {
    w && O.classList.contains(w) || Object.assign(O.style, x.click);
  }
  static mouseLeave(x, w, O) {
    w && O.classList.contains(w) || StatefulCSSEvents.apply(x, x.default, O);
  }
  static mouseEnter(x, w, O) {
    w && O.classList.contains(w) || Object.assign(O.style, x.hover);
  }
  // can change the styling on another element by using the otherElement argument
  static getEvents(x, w, O, D) {
    const U = D || x;
    return {
      mouseenter: StatefulCSSEvents.mouseEnter.bind(this, w, O, U),
      mouseleave: StatefulCSSEvents.mouseLeave.bind(this, w, O, U),
      mousedown: StatefulCSSEvents.mouseDown.bind(this, w, O, U),
      mouseup: StatefulCSSEvents.mouseUp.bind(this, w, O, U)
    };
  }
  static setEvents(x, w, O, D) {
    const U = StatefulCSSEvents.getEvents(x, w, O, D);
    return x.addEventListener("mouseenter", U.mouseenter), x.addEventListener("mouseleave", U.mouseleave), x.addEventListener("mousedown", U.mousedown), x.addEventListener("mouseup", U.mouseup), U;
  }
}
class FilterInputCaseEvents {
  static clickButton(x, w, O) {
    const D = O || {}, U = ToggleableElement.toggleActive(x, { color: "#000000", ...D });
    w.isCaseSensitive = !U, FilterInternalUtils.resetInput(this, w), w.inputElement.dispatchEvent(new Event("input"));
  }
  static setEvents(x, w, O, D) {
    w.onclick = FilterInputCaseEvents.clickButton.bind(x, w, O, D);
  }
}
class FilterInputCaseElement {
  static createButton(x = {}) {
    const w = document.createElement("div");
    return w.classList.add("filter-rows-case-button"), w.textContent = "Aa", FilterElements.applyStatefulStyles(w, { color: "#626262" }, x), w;
  }
  static create(x, w, O, D) {
    const U = FilterInputCaseElement.createButton(D?.caseIcon);
    w.appendChild(U), setTimeout(() => {
      var W;
      return FilterInputCaseEvents.setEvents(x, U, O, (W = D?.caseIcon) == null ? void 0 : W.active);
    });
  }
}
const _FilterElements = class pr {
  static createContainerElement(x) {
    const w = document.createElement("div");
    return w.classList.add("filter-rows-container"), w.style.order = String(x || 0), w;
  }
  // the order at which the elements are added is very important - please check the css selectors
  // prettier-ignore
  static createComponent(x, w, O) {
    var D;
    const U = O.position || pr.DEFAULT_INPUT_POSITION, W = pr.createContainerElement(O.order), X = FilterInternalUtils.addConfig(x, O);
    if (O.dropdown !== !1) {
      const Y = FilterDropdownElement.create(
        x,
        W,
        U,
        X,
        (D = O.styles) == null ? void 0 : D.dropdownIcon
      );
      setTimeout(() => W.appendChild(Y));
    }
    O.caseButton !== !1 && FilterInputCaseElement.create(x, W, X, O.styles);
    const G = FilterInputElement.create(X, O, x.data);
    W.appendChild(G), OuterContainerElements.addToContainer(U, w, W);
  }
  static create(x, w) {
    typeof x.filter == "boolean" ? pr.createComponent(x, w, {}) : Array.isArray(x.filter) ? x.filter.forEach((O) => {
      pr.createComponent(x, w, O);
    }) : x.filter && pr.createComponent(x, w, x.filter), setTimeout(() => FilterInternalUtils.resetAllInputs(x));
  }
  static applyStatefulStyles(x, w, O = {}) {
    const D = ElementStyle.generateStatefulCSS(O, w, { color: "#484848" });
    Object.assign(x.style, D.default), setTimeout(() => StatefulCSSEvents.setEvents(x, D, ToggleableElement.ACTIVE_BUTTON_CLASS));
  }
};
_FilterElements.DEFAULT_INPUT_POSITION = "top-right";
let FilterElements = _FilterElements;
const CALENDAR_ICON_SVG_STRING = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="10px" viewBox="0 0 10 10" version="1.1">
  <g id="surface1">
    <path style=" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;" d="M 1.070312 9.285156 L 8.929688 9.285156 L 8.929688 3.570312 L 1.070312 3.570312 Z M 3.214844 2.5 L 3.214844 0.894531 C 3.214844 0.839844 3.199219 0.796875 3.164062 0.765625 C 3.128906 0.730469 3.085938 0.714844 3.035156 0.714844 L 2.679688 0.714844 C 2.625 0.714844 2.582031 0.730469 2.550781 0.765625 C 2.515625 0.796875 2.5 0.839844 2.5 0.894531 L 2.5 2.5 C 2.5 2.550781 2.515625 2.59375 2.550781 2.628906 C 2.582031 2.660156 2.625 2.679688 2.679688 2.679688 L 3.035156 2.679688 C 3.085938 2.679688 3.128906 2.660156 3.164062 2.628906 C 3.199219 2.59375 3.214844 2.550781 3.214844 2.5 Z M 7.5 2.5 L 7.5 0.894531 C 7.5 0.839844 7.484375 0.796875 7.449219 0.765625 C 7.417969 0.730469 7.375 0.714844 7.320312 0.714844 L 6.964844 0.714844 C 6.914062 0.714844 6.871094 0.730469 6.835938 0.765625 C 6.800781 0.796875 6.785156 0.839844 6.785156 0.894531 L 6.785156 2.5 C 6.785156 2.550781 6.800781 2.59375 6.835938 2.628906 C 6.871094 2.660156 6.914062 2.679688 6.964844 2.679688 L 7.320312 2.679688 C 7.375 2.679688 7.417969 2.660156 7.449219 2.628906 C 7.484375 2.59375 7.5 2.550781 7.5 2.5 Z M 9.644531 2.144531 L 9.644531 9.285156 C 9.644531 9.480469 9.570312 9.648438 9.429688 9.789062 C 9.289062 9.929688 9.121094 10 8.929688 10 L 1.070312 10 C 0.878906 10 0.710938 9.929688 0.570312 9.789062 C 0.429688 9.648438 0.355469 9.480469 0.355469 9.285156 L 0.355469 2.144531 C 0.355469 1.949219 0.429688 1.78125 0.570312 1.640625 C 0.710938 1.5 0.878906 1.429688 1.070312 1.429688 L 1.785156 1.429688 L 1.785156 0.894531 C 1.785156 0.648438 1.875 0.4375 2.046875 0.261719 C 2.222656 0.0859375 2.433594 0 2.679688 0 L 3.035156 0 C 3.28125 0 3.492188 0.0859375 3.667969 0.261719 C 3.839844 0.4375 3.929688 0.648438 3.929688 0.894531 L 3.929688 1.429688 L 6.070312 1.429688 L 6.070312 0.894531 C 6.070312 0.648438 6.160156 0.4375 6.332031 0.261719 C 6.507812 0.0859375 6.71875 0 6.964844 0 L 7.320312 0 C 7.566406 0 7.777344 0.0859375 7.953125 0.261719 C 8.125 0.4375 8.214844 0.648438 8.214844 0.894531 L 8.214844 1.429688 L 8.929688 1.429688 C 9.121094 1.429688 9.289062 1.5 9.429688 1.640625 C 9.570312 1.78125 9.644531 1.949219 9.644531 2.144531 Z M 9.644531 2.144531 "/>
  </g>
</svg>`, _DateCellCalendarIconElement = class Tr {
  // need a container as mousedown target kept being different parts of svg
  // hence svgIcon has no pointer events
  static createContainer() {
    const x = document.createElement("div");
    return x.classList.add(Tr.CALENDAR_ICON_CONTAINER_CLASS), x;
  }
  // REF-10
  static createSVGElement() {
    const x = SVGIconUtils.createSVGElement(CALENDAR_ICON_SVG_STRING);
    return x.style.pointerEvents = "none", x.style.height = "25px", x;
  }
  static createSVG() {
    const x = Tr.createSVGElement(), w = Tr.createContainer();
    return w.appendChild(x), w;
  }
  static get() {
    return Tr.CALENDAR_ICON_ELEMENT.cloneNode(!0);
  }
};
_DateCellCalendarIconElement.CALENDAR_ICON_CONTAINER_CLASS = "calender-icon-container";
_DateCellCalendarIconElement.CALENDAR_ICON_ELEMENT = _DateCellCalendarIconElement.createSVG();
let DateCellCalendarIconElement = _DateCellCalendarIconElement;
class ColumnDetailsUtils {
  static getColumnsByWidth(x) {
    var w;
    const O = [], D = [];
    for (let U = 0; U < x.length; U += 1) {
      const W = x[U];
      ((w = W.settings.widths) == null ? void 0 : w.staticWidth) !== void 0 ? D.push(W) : O.push(W);
    }
    return { dynamicWidth: O, staticWidth: D };
  }
  static aggregateItems(x) {
    return x.labelDetails ? Object.keys(x.itemsDetails).map((w) => ({ name: w, backgroundColor: x.itemsDetails[w].backgroundColor })) : Object.keys(x.itemsDetails).map((w) => ({ name: w }));
  }
  static getDetails(x) {
    const w = {
      width: x.elements[0].offsetWidth,
      typeName: x.activeType.name
    };
    return x.activeType.cellDropdownProps && (w.cellDropdownItems = ColumnDetailsUtils.aggregateItems(x.cellDropdown)), w;
  }
  static getAllColumnsDetails(x) {
    return x.map((w) => ColumnDetailsUtils.getDetails(w));
  }
}
class FireEvents {
  // prettier-ignore
  static onCellUpdate(x, w, O, D, U) {
    const W = { text: String(w), rowIndex: O, columnIndex: D, updateType: U };
    x.onCellUpdate(W), x.dispatchEvent(new CustomEvent("cell-update", { detail: W }));
  }
  static onDataUpdate(x) {
    const w = JSON.parse(JSON.stringify(x.data));
    x.onDataUpdate(w), x.dispatchEvent(new CustomEvent("data-update", { detail: w }));
  }
  static onColumnsUpdate(x) {
    const w = ColumnDetailsUtils.getAllColumnsDetails(x._columnsDetails);
    x.onColumnsUpdate(w), x.dispatchEvent(new CustomEvent("columns-update", { detail: w }));
  }
  static onRender(x) {
    x.onRender(), x.dispatchEvent(new CustomEvent("render"));
  }
}
class StaticTable {
  // because we don't set the table width for maxWidth property, its width is made up of columns widths -
  // they don't always add up to a precise expected value, e.g. if expected 500, they can add up to a 498
  // and 499. Hence instead of doing === tableElement.offsetWidth, we do <= tableElement.offsetWidth + 2
  // number 2 seems enough but can increase if this method is returning false in valid scenarios
  static isTableAtMaxWidth(x, w) {
    return w.maxWidth !== void 0 && w.maxWidth <= x.offsetWidth + 2;
  }
  static isStaticTableWidth(x, w) {
    return w.width !== void 0 || StaticTable.isTableAtMaxWidth(x, w);
  }
}
class StaticTableWidthUtils {
  // REF-11
  static togglePreserveNarrowColumns(x, w, O) {
    O || (w.style.display = x ? "block" : "");
  }
  // when the client has not provided the 'width' value for the table, but a 'maxWidth' is present, need to
  // temporarily set the width at the start in order to help the MaximumColumns class to determine what columns fit
  // prettier-ignore
  static toggleWidthUsingMaxWidth(x, w) {
    const { _tableElementRef: O, _tableDimensions: { maxWidth: D, preserveNarrowColumns: U } } = x;
    O && D !== void 0 && (O.style.width = w ? `${D}px` : "", StaticTableWidthUtils.togglePreserveNarrowColumns(w, O, U));
  }
  // prettier-ignore
  static setTableWidth(x) {
    const { _tableDimensions: { preserveNarrowColumns: w, width: O }, _tableElementRef: D } = x;
    D && O !== void 0 && (D.style.width = `${O}px`, StaticTableWidthUtils.togglePreserveNarrowColumns(!0, D, w));
  }
  // This only runs when the table width is set
  // prettier-ignore
  static changeTableWidthForNonDynamicColumns(x, w, O, D, U) {
    x.length === 0 || w.dynamicWidth.length > 0 ? O.offsetWidth !== D && (O.style.width = `${D}px`) : O.style.width = `${U}px`;
  }
  static resetDynamicWidthColumns(x, w) {
    x.forEach((O) => {
      O.elements[0].style.width = `${w.newColumnWidth}px`;
    });
  }
  static setNewColumnWidth(x, w, O) {
    if (w > 0) {
      const D = x - O.staticWidth;
      O.newColumnWidth = D / w;
    }
  }
  static resetColumnSizes(x, w, O) {
    const D = ColumnDetailsUtils.getColumnsByWidth(x);
    return StaticTableWidthUtils.setNewColumnWidth(w, D.dynamicWidth.length, O), StaticTableWidthUtils.resetDynamicWidthColumns(D.dynamicWidth, O), D;
  }
  static changeWidthsBasedOnColumnInsertRemove(x, w) {
    const { _tableElementRef: O, _tableDimensions: D, _columnsDetails: U } = x;
    if (!O)
      return;
    const { width: W, maxWidth: X, staticWidth: G } = D;
    if (W !== void 0) {
      const Y = StaticTableWidthUtils.resetColumnSizes(U, W, D);
      StaticTableWidthUtils.changeTableWidthForNonDynamicColumns(U, Y, O, W, G);
    } else
      w && StaticTable.isTableAtMaxWidth(O, D) && StaticTableWidthUtils.resetColumnSizes(U, X, D);
    setTimeout(() => FireEvents.onColumnsUpdate(x));
  }
}
class ConvertCellTypeUtils {
  static preprocessCell(x) {
    x.style.cursor = "";
  }
}
class CellStructureUtils {
  static setColumn(x, w, O, D) {
    const { elements: U } = x._columnsDetails[w];
    U.slice(1).forEach((W, X) => {
      const G = X + 1;
      O(x, W, w, G), x._columnsDetails[w].settings.isCellTextEditable && D(x, W, G, w);
    });
  }
}
class FocusedCellUtils {
  static createEmpty() {
    return {};
  }
  static setHeaderCell(x, w, O) {
    x.element = w, x.rowIndex = 0, x.columnIndex = O;
  }
  static setIndexCell(x, w, O) {
    x.element = w, x.rowIndex = O, delete x.columnIndex;
  }
  static set(x, w, O, D) {
    x.element = w, x.rowIndex = O, x.columnIndex = D;
  }
  static incrementColumnIndex(x, w) {
    x.columnIndex !== void 0 && w <= x.columnIndex && (x.columnIndex += 1);
  }
  static purge(x) {
    delete x.columnIndex, delete x.element, delete x.rowIndex;
  }
}
var KEYBOARD_KEY = /* @__PURE__ */ ((F) => (F.ESCAPE = "Escape", F.ENTER = "Enter", F.TAB = "Tab", F.ARROW_UP = "ArrowUp", F.ARROW_DOWN = "ArrowDown", F.ARROW_RIGHT = "ArrowRight", F.ARROW_LEFT = "ArrowLeft", F))(KEYBOARD_KEY || {});
const _Browser = class {
  // can't use DateCellInputElement class as this is called before CellElement class can be used
  static createDateInput() {
    const F = document.createElement("input");
    return F.type = "date", F;
  }
  static createColorInput() {
    const F = document.createElement("input");
    return F.type = "color", F;
  }
};
_Browser.IS_FIREFOX = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
_Browser.IS_SAFARI = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
_Browser.IS_CHROMIUM = window.chrome;
_Browser.IS_INPUT_DATE_SUPPORTED = _Browser.createDateInput().type === "date" && "showPicker" in HTMLInputElement.prototype;
_Browser.IS_COLOR_PICKER_SUPPORTED = _Browser.createColorInput().type === "color" && "showPicker" in HTMLInputElement.prototype;
let Browser = _Browser;
class ColumnSettingsStyleUtils {
  static applySettingsStyleOnCell(x, w, O) {
    var D;
    Object.assign(w.style, x.cellStyle || {}, O ? ((D = x.headerStyles) == null ? void 0 : D.default) || {} : {});
  }
  // prettier-ignore
  static setNewHeaderStyle(x, w) {
    var O;
    const { settings: D, elements: U } = w, W = D.cellStyle || ((O = D.headerStyles) == null ? void 0 : O.default);
    W && ColumnSettingsStyleUtils.applySettingsStyleOnCell(D, U[0], !0);
    const X = W ? D : void 0;
    w.headerStateColors = ColumnDetails.createHeaderStateColors(
      x._defaultColumnsSettings,
      X,
      x._defaultCellHoverColors
    ), ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(w, [U[0]]);
  }
  static unsetHeaderSettingStyle(x, w) {
    Object.keys(w).forEach((O) => {
      ElementStyle.setStyle(x, O, "");
    });
  }
  // prettier-ignore
  static resetHeaderStyleToDefault(x, w, O) {
    var D;
    (D = w.headerStyles) != null && D.default && ColumnSettingsStyleUtils.unsetHeaderSettingStyle(x[0], w.headerStyles.default), w.cellStyle && ElementStyle.unsetStyle(x[0], w.cellStyle);
    const { cellStyle: U, headerStyles: W } = O;
    CellElement.setDefaultCellStyle(x[0], U, W?.default);
  }
  // prettier-ignore
  static changeHeaderStyleFunc(x, w) {
    var O, D, U;
    const W = this._columnsDetails[x], { elements: X, settings: { isHeaderTextEditable: G } } = W;
    ColumnSettingsStyleUtils.resetHeaderStyleToDefault(X, w, this._defaultColumnsSettings), ColumnSettingsStyleUtils.setNewHeaderStyle(this, W);
    const Y = (U = (D = (O = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : O.displaySettings) == null ? void 0 : D.openMethod) == null ? void 0 : U.cellClick, K = !Y && G;
    CellElement.prepContentEditable(
      CellElement.getTextElement(X[0]),
      !!K,
      Y
    );
  }
  // prettier-ignore
  static changeStyleFunc(x, w, O) {
    ProcessedDataTextStyle.resetDataCellsStyle(
      x,
      w,
      ColumnSettingsStyleUtils.changeHeaderStyleFunc.bind(x, w, O),
      O.cellStyle
    );
  }
  static doStylesHaveVisibleDimension(x, w) {
    for (let O = 0; O < w.length; O += 1) {
      const D = x[w[O]];
      if (D) {
        const U = RegexUtils.extractIntegerStrs(String(D));
        if (U.length > 0 && Number(U[0]) > 0)
          return !0;
      }
    }
    return !1;
  }
  // REF-23
  // prettier-ignore
  static doesSettingHaveSideBorderStyle(x) {
    var w;
    const O = x.cellStyle || ((w = x.headerStyles) == null ? void 0 : w.default);
    return O ? ColumnSettingsStyleUtils.doStylesHaveVisibleDimension(
      O,
      ["border", "borderLeft", "borderLeftWidth", "borderRight", "borderRightWidth"]
    ) : !1;
  }
}
class ResetColumnStyles {
  static applyDefaultStyles(x, w) {
    const { cellStyle: O, headerStyles: D } = w;
    CellElement.setDefaultCellStyle(x[0], O, D?.default), x.slice(1).forEach((U) => {
      CellElement.setDefaultCellStyle(U, O);
    });
  }
  static unsetLastAppliedStyle(x, w) {
    Object.keys(x.lastAppliedStyle).forEach((O) => {
      ElementStyle.setStyle(w, O, "");
    });
  }
  // if this operation turns out to be expensive - try to save and reuse the default style
  // prettier-ignore
  static setDefaultStyle(x, w, O, D, U) {
    ResetColumnStyles.unsetLastAppliedStyle(w, O), U && ElementStyle.unsetStyle(O, U), CellElement.setDefaultCellStyle(O, D.cellStyle), ColumnSettingsStyleUtils.applySettingsStyleOnCell(x.settings, O, !1);
  }
}
const _ProcessedDataTextStyle = class Qt {
  // prettier-ignore
  static setCustomStyle(x, w, O, D, U, W, X) {
    if (x) {
      ResetColumnStyles.setDefaultStyle(O, U, W, X);
      const G = x(String(w), D);
      Object.assign(W.style, G), U.lastAppliedStyle = G, ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(O, [W]);
    }
  }
  // prettier-ignore
  static setFailedValidationStyle(x, w, O) {
    const { textValidation: D } = x.activeType, U = D.failedStyle || Qt.DEFAULT_FAILED_VALIDATION_STYLE;
    Object.assign(O.style, U), w.lastAppliedStyle = U;
  }
  // prettier-ignore
  static setStyle(x, w, O, D, U, W) {
    let X = !1;
    return x ? D != null && D.changeStyleFunc || (ResetColumnStyles.setDefaultStyle(w, O, U, W), O.lastAppliedStyle = {}, X = !0) : (D != null && D.changeStyleFunc && ResetColumnStyles.setDefaultStyle(w, O, U, W), Qt.setFailedValidationStyle(w, O, U), X = !0), X && ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(w, [U]), X;
  }
  // prettier-ignore
  static setCellStyle(x, w, O, D = !1) {
    const U = x._columnsDetails[O], W = U.elements[w], X = U.processedStyle[w], G = CellElement.getText(W), { textValidation: { func: Y }, customTextProcessing: K } = U.activeType;
    let Z = !1;
    if (Y) {
      const q = Y(G);
      (D || X.isValid !== q) && (Z = Qt.setStyle(
        q,
        U,
        X,
        K,
        W,
        x._defaultColumnsSettings
      ), X.isValid = q);
    }
    !Z && K != null && K.changeStyleFunc && Qt.setCustomStyle(
      K.changeStyleFunc,
      G,
      U,
      w,
      X,
      W,
      x._defaultColumnsSettings
    );
  }
  static setStyleOnColumn(x, w) {
    const O = x._columnsDetails[w];
    O.elements.slice(1).forEach((D, U) => {
      const W = U + 1;
      Qt.setCellStyle(x, W, w, !0), ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(O, [D]);
    });
  }
  static unsetStyleOnColumn(x, w, O) {
    const D = x._columnsDetails[w];
    D.elements.slice(1).forEach((U, W) => {
      const X = W + 1, G = D.processedStyle[X];
      ResetColumnStyles.setDefaultStyle(D, G, U, x._defaultColumnsSettings, O);
    });
  }
  // using this to first unset the previous processed style, allow new settings/type to be applied and then set
  // new style
  // prettier-ignore
  static resetDataCellsStyle(x, w, O, D) {
    Qt.unsetStyleOnColumn(x, w, D), O(), Qt.setStyleOnColumn(x, w);
  }
  // prettier-ignore
  // this is used for a case where the default style has been set and need to reapply the processed style
  // without having to rerun the validation/changeStyleFunc functions
  static reapplyCellsStyle(x, w) {
    const O = x._columnsDetails[w], { textValidation: { func: D }, customTextProcessing: U } = O.activeType;
    (D || U != null && U.changeStyleFunc) && O.elements.slice(1).forEach((W, X) => {
      const G = X + 1;
      Object.assign(W.style, O.processedStyle[G].lastAppliedStyle);
    });
  }
  static getDefaultProcessedTextStyle() {
    return { isValid: !0, lastAppliedStyle: {} };
  }
};
_ProcessedDataTextStyle.DEFAULT_FAILED_VALIDATION_STYLE = { color: "grey" };
let ProcessedDataTextStyle = _ProcessedDataTextStyle;
class NumberOfIdenticalCells {
  // columnsDetails instead of row from data because during startup - data is already be populated and
  // not yet added to the table, hence we are automatically marking headers as duplicate and setting them
  // to default, however the end headers that are not duplicate may not be displayed due to max columns,
  // hence using columnsDetails to mark duplicates as headers are added instead
  // prettier-ignore
  static get(x, w) {
    return w.map((O) => O.elements.length > 0 ? CellElement.getText(O.elements[0]) : "").filter((O) => O === x).length;
  }
}
const EMPTY_STRING = "";
class DataUtils {
  static createEmptyStringDataArray(x) {
    return new Array(x).fill(EMPTY_STRING);
  }
  static isTextEmpty(x, w) {
    return x !== EMPTY_STRING ? (typeof w == "string" ? w.trim() : w) === EMPTY_STRING : !1;
  }
  // note that NumberOfIdenticalCells.get uses the at.data top row, so it needs to be up-to-date
  // prettier-ignore
  static shouldBeSetToDefault(x, w, O, D, U) {
    const { allowDuplicateHeaders: W, _columnsDetails: X } = x;
    return DataUtils.isTextEmpty(O, w) || D === 0 && !W && NumberOfIdenticalCells.get(w, X) > 1 || D > 0 && !(U.func === void 0 || U.func(String(w)));
  }
  // prettier-ignore
  static processCellText(x, w, O, D) {
    let U = typeof D == "string" ? D.trim() : D;
    const W = x._columnsDetails[O];
    if (!W)
      return U;
    const { activeType: { textValidation: X, customTextProcessing: G }, settings: { defaultText: Y } } = W;
    return w > 0 && (G != null && G.changeTextFunc && (U = G.changeTextFunc(String(U), w)), !X.setTextToDefaultOnFail && U !== EMPTY_STRING) ? U : DataUtils.shouldBeSetToDefault(x, U, Y, w, X) ? Y : U;
  }
}
var CELL_UPDATE_TYPE = /* @__PURE__ */ ((F) => (F.UPDATE = "Update", F.ADD = "Add", F.REMOVED = "Removed", F))(CELL_UPDATE_TYPE || {});
class CellEvents {
  static executeUpdateOperation(x, w) {
    return w?.[x] === void 0 || w[x] === !0;
  }
  // this is directly handled by operations that do not insert new cells as those handle the instructions below
  // in a different order asynchronously for maximum efficiency
  // prettier-ignore
  static updateCell(x, w, O, D, U) {
    return CellEvents.executeUpdateOperation("processText", U) && (w = DataUtils.processCellText(x, O, D, w)), CellEvents.executeUpdateOperation("updateData", U) && (x.data[O][D] = w), U != null && U.element && CellElement.setNewText(x, U.element, w, !1, !1), CellEvents.executeUpdateOperation("updateTableEvent", U) && x.onDataUpdate(x.data), O > 0 && ProcessedDataTextStyle.setCellStyle(x, O, D), CellEvents.executeUpdateOperation("updateCellEvent", U) && FireEvents.onCellUpdate(x, w, O, D, CELL_UPDATE_TYPE.UPDATE), w;
  }
  // this is used for cases where updateCell should only be called if it has to be set to default
  // prettier-ignore
  static setCellToDefaultIfNeeded(x, w, O, D, U = !0) {
    const W = CellElement.getText(D), X = DataUtils.processCellText(x, w, O, W);
    return X !== W ? (CellEvents.updateCell(
      x,
      X,
      w,
      O,
      { element: D, processText: !1, updateTableEvent: U }
    ), !0) : !1;
  }
  // prettier-ignore
  static removeTextIfDefault(x, w, O, D) {
    const { isDefaultTextRemovable: U, defaultText: W } = x._columnsDetails[O].settings;
    U && W !== EMPTY_STRING && W === CellElement.getText(D) && CellEvents.updateCell(
      x,
      EMPTY_STRING,
      w,
      O,
      { element: D, processText: !1 }
    );
  }
}
class CheckboxEvents {
  // REF-29
  static focusCheckbox(x, w, O) {
    Browser.IS_SAFARI || FocusedCellUtils.set(this._focusedElements.cell, x, w, O);
  }
  // REF-29
  static blurCheckbox() {
    Browser.IS_SAFARI || FocusedCellUtils.purge(this._focusedElements.cell);
  }
  static changeValueCheckbox(x, w, O) {
    const D = O.target;
    CellEvents.updateCell(this, String(D.checked), x, w, { processText: !1 });
  }
  static keyDownCheckbox(x) {
    x.key === KEYBOARD_KEY.ENTER && x.target.click();
  }
  static setEvents(x, w, O, D) {
    w.onkeydown = CheckboxEvents.keyDownCheckbox, w.onchange = CheckboxEvents.changeValueCheckbox.bind(x, O, D), w.onfocus = CheckboxEvents.focusCheckbox.bind(x, w, O, D), w.onblur = CheckboxEvents.blurCheckbox.bind(x);
  }
}
class CheckboxCellEvents {
  static mouseDownCell(x) {
    const w = x.target;
    w.classList.contains(CellElement.CELL_CLASS) && w.children[0].click();
  }
  // REF-29
  static focusCell(x) {
    x.target.children[0].focus();
  }
  static setEvents(x, w, O, D) {
    if (!x._columnsDetails[D].settings.isCellTextEditable)
      return;
    w.onblur = () => {
    }, w.onfocus = CheckboxCellEvents.focusCell, w.onmouseenter = () => {
    }, w.onmouseleave = () => {
    }, w.oninput = () => {
    }, w.onmousedown = CheckboxCellEvents.mouseDownCell.bind(x);
    const U = CheckboxCellElement.getCheckboxElement(w);
    CheckboxEvents.setEvents(x, U, O, D);
  }
}
class CheckboxElement {
  static createCheckbox(x) {
    const w = document.createElement("input");
    return w.type = "checkbox", w.style.cursor = x ? "pointer" : "auto", w.style.pointerEvents = x ? "" : "none", w;
  }
  static setCellTextAsCheckbox(x, w) {
    const O = CheckboxElement.createCheckbox(w);
    x.replaceChildren(O);
  }
}
class CheckboxCellElement {
  static isCheckbox(x) {
    return x?.type === "checkbox";
  }
  static isCheckboxCell(x) {
    return CheckboxCellElement.isCheckbox(x.children[0]);
  }
  static getCheckboxElement(x) {
    if (CheckboxCellElement.isCheckboxCell(x))
      return x.children[0];
    if (CheckboxCellElement.isCheckbox(x))
      return x;
  }
  static getValue(x) {
    const w = CheckboxCellElement.getCheckboxElement(x);
    if (w)
      return String(w.checked);
  }
  static setValue(x, w) {
    const O = CheckboxCellElement.getCheckboxElement(x);
    return O ? (O.checked = w === "true", !0) : !1;
  }
  // prettier-ignore
  static setCellTextAsAnElement(x, w, O, D) {
    const { settings: { isCellTextEditable: U } } = x._columnsDetails[D], W = CellElement.getText(w);
    CheckboxElement.setCellTextAsCheckbox(w, U), w.contentEditable = "false", w.style.cursor = U ? "pointer" : "default", CellEvents.updateCell(x, W, O, D, { element: w });
  }
  // prettier-ignore
  static setCellCheckboxStructure(x, w, O, D) {
    ConvertCellTypeUtils.preprocessCell(w), CheckboxCellElement.setCellTextAsAnElement(x, w, D, O);
  }
  // prettier-ignore
  static setColumnCheckboxStructure(x, w) {
    CellStructureUtils.setColumn(
      x,
      w,
      CheckboxCellElement.setCellCheckboxStructure,
      CheckboxCellEvents.setEvents
    );
  }
}
class CaretPosition {
  static setSelectionToEndOfText(x, w) {
    const O = CellElement.getTextElement(x), D = document.createRange();
    D.setStart(O.childNodes[0], CellElement.getText(O).length || 0), D.collapse(!0), w.removeAllRanges(), w.addRange(D);
  }
  static getSelection(x) {
    var w;
    const O = x.shadowRoot;
    return O.getSelection ? O.getSelection() : ((w = window.document.activeElement) == null ? void 0 : w.shadowRoot) === O ? window.document.getSelection() : null;
  }
  static setToEndOfText(x, w) {
    if (CheckboxCellElement.isCheckboxCell(w))
      return;
    let O = CaretPosition.getSelection(x);
    Browser.IS_SAFARI && !O && (w.focus(), O = CaretPosition.getSelection(x)), O && CaretPosition.setSelectionToEndOfText(w, O);
  }
}
class ArrayUtils {
  static transpose(x) {
    if (x.length === 0)
      return x;
    const w = [], O = Math.max(x.length, x[0].length);
    e:
      for (let D = 0; D < O; D += 1) {
        const U = [];
        for (let W = 0; W < O && x[W] !== void 0; W += 1) {
          if (x[W][D] === void 0)
            break e;
          U.push(x[W][D]);
        }
        w.push(U);
      }
    return w;
  }
  static shuffle(x) {
    return x.sort(() => Math.random() - 0.5);
  }
  static swap(x, w, O) {
    const D = x[w];
    x[w] = x[O], x[O] = D;
  }
}
const _LabelColorUtils = class lr {
  static generateNewPasteleColor() {
    return `hsl(${Math.floor(Math.random() * 360)}, 95%, 90%)`;
  }
  static setNewLatestPasteleColor() {
    lr.LATEST_PASTELE_COLOR = lr.generateNewPasteleColor();
  }
  static getLatestPasteleColor() {
    return lr.LATEST_PASTELE_COLOR;
  }
  static getLatestPasteleColorAndSetNew() {
    const x = lr.getLatestPasteleColor();
    return lr.setNewLatestPasteleColor(), x;
  }
  // REF-34
  // these colors are used before the above
  static generateDefaultColors() {
    return ArrayUtils.shuffle([
      "hsl(154deg 96% 90%)",
      "hsl(50deg 96% 90%)",
      "hsl(171deg 96% 90%)",
      "hsl(76deg 96% 90%)",
      "hsl(315deg 96% 90%)",
      "hsl(251deg 96% 90%)",
      "hsl(209deg 84% 92%)",
      "hsl(0deg 100% 81%)",
      "hsl(29deg 100% 79%)",
      "hsl(31deg 73% 75%)",
      "hsl(137deg 80% 80%)",
      "hsl(60deg 100% 82%)",
      "hsl(219deg 100% 84%)",
      "hsl(93deg 62% 74%)",
      "hsl(54deg 93% 84%)",
      "hsl(146deg 100% 90%)",
      "hsl(334deg 100% 87%)",
      "hsl(19deg 95% 84%)",
      "hsl(203deg 95% 84%)",
      "hsl(76deg 100% 78%)",
      "hsl(0deg 100% 86%)",
      "hsl(42deg 82% 82%)",
      "hsl(97deg 100% 87%)"
    ]);
  }
  // this is a solution for same label text across different columns to have the same colors
  static generateGlobalItemColors() {
    return {
      newColors: lr.generateDefaultColors(),
      existingColors: {}
    };
  }
};
_LabelColorUtils.LATEST_PASTELE_COLOR = _LabelColorUtils.generateNewPasteleColor();
let LabelColorUtils = _LabelColorUtils;
class ScrollbarUtils {
  static isVerticalPresent(x) {
    return x.scrollHeight > x.clientHeight;
  }
  static isHorizontalPresent(x) {
    return x.scrollWidth > x.clientWidth;
  }
}
const _CellDropdownHorizontalScrollFix = class Wr {
  static setPropertiesIfHorizontalScrollPresent(x) {
    const { element: w, scrollbarPresence: O, customDropdownStyle: D } = x;
    ScrollbarUtils.isHorizontalPresent(w) && ScrollbarUtils.isVerticalPresent(w) ? (O.horizontal = !0, w.style.paddingBottom = Wr.NEW_BOTTOM_PADDING_IF_PRESENT) : (O.horizontal = !1, w.style.paddingBottom = D?.paddingBottom || Dropdown.DROPDOWN_VERTICAL_PX);
  }
  static scrollDownFurther(x) {
    x.scrollTop += Wr.SCROLL_FURTHER_BOTTOM_PX;
  }
};
_CellDropdownHorizontalScrollFix.NEW_BOTTOM_PADDING_IF_PRESENT = "8px";
_CellDropdownHorizontalScrollFix.SCROLL_FURTHER_BOTTOM_PX = 14;
let CellDropdownHorizontalScrollFix = _CellDropdownHorizontalScrollFix;
const _RGBAToHex = class Hr {
  static extractIndividualNumbers(x) {
    return x.match(Hr.REGEX);
  }
  static convert(x) {
    return `#${Hr.extractIndividualNumbers(x).slice(1).map(
      (w, O) => (O === 3 ? Math.round(parseFloat(w) * 255) : parseFloat(w)).toString(16).padStart(2, "0").replace("NaN", "")
    ).join("")}`;
  }
};
_RGBAToHex.REGEX = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)$/;
let RGBAToHex = _RGBAToHex;
const _OptionColorButton = class Kt {
  // buttonLevelElement is either input or button
  static extractRelativeParentElements(x) {
    var w;
    const O = x.parentElement, D = (w = O.previousSibling) == null ? void 0 : w.previousSibling, U = O.parentElement;
    return { containerElement: O, textElement: D, dropdownItemElement: U };
  }
  static changeVisibility(x, w, O) {
    const D = x.children[2];
    if (D.style.display = O ? "block" : "none", O) {
      const U = D.children[0], W = Browser.IS_SAFARI ? 9 : 5;
      U.style.left = `${O.offsetWidth - w + W}px`;
      const X = D.children[1];
      X.style.left = `${O.offsetWidth - w}px`;
    }
  }
  static createIcon() {
    const x = document.createElement("div");
    return x.innerText = Kt.COLOR_ICON_TEXT, x.classList.add(Kt.COLOR_BUTTON_ICON_CLASS), x;
  }
  static createButton() {
    const x = document.createElement("div");
    x.classList.add(OptionButton.BUTTON_CLASS, Kt.COLOR_BUTTON_CLASS);
    const w = Kt.createIcon();
    return x.appendChild(w), x;
  }
  static createInput() {
    const x = document.createElement("input");
    return x.type = "color", x.style.top = Browser.IS_SAFARI ? "0px" : "14px", x.classList.add(Kt.COLOR_INPUT_CLASS), x;
  }
  static createContainer() {
    const x = document.createElement("div");
    return x.classList.add(OptionButton.BUTTON_CONTAINER_CLASS), x;
  }
  static create(x, w) {
    const O = Kt.createContainer(), D = Kt.createInput();
    O.appendChild(D);
    const U = Kt.createButton();
    return O.appendChild(U), OptionColorButtonEvents.setEvents(O, D, x, w), O;
  }
};
_OptionColorButton.COLOR_INPUT_CLASS = "color-input";
_OptionColorButton.COLOR_BUTTON_CLASS = "option-color-button";
_OptionColorButton.COLOR_BUTTON_ICON_CLASS = "cell-dropdown-option-color-button-icon";
_OptionColorButton.COLOR_ICON_TEXT = "c";
let OptionColorButton = _OptionColorButton;
class OptionColorButtonEvents {
  static updateCellElements(x, w) {
    const { itemText: O, backgroundColor: D } = w;
    x.elements.slice(1).forEach((U) => {
      const W = U.children[0];
      W.innerText === O && (W.style.backgroundColor = D);
    });
  }
  // prettier-ignore
  static updateIfUpdatable(x, w, O) {
    const { itemText: D, backgroundColor: U } = O, W = x.cellDropdown.itemsDetails[D];
    W && (!W.isCustomBackgroundColor || w === x.activeType.name) && (W.backgroundColor = U, OptionColorButtonEvents.updateCellElements(x, O));
  }
  // prettier-ignore
  static updateElements(x, w, O) {
    x.forEach((D) => {
      D.cellDropdown.labelDetails && OptionColorButtonEvents.updateIfUpdatable(D, w, O);
    });
  }
  static updateColorStates(x, w) {
    var O, D, U;
    const { itemText: W, backgroundColor: X } = w;
    (D = (O = x.activeType.cellDropdownProps) == null ? void 0 : O.options) == null || D.forEach((Y) => {
      Y.text === W && (Y.backgroundColor = X);
    });
    const G = (U = x.cellDropdown.labelDetails) == null ? void 0 : U.globalItemColors.existingColors;
    G != null && G[W] && (G[W] = X);
  }
  // prettier-ignore
  static updateColumnLabelColors(x, w) {
    const { cellDropdown: { labelDetails: O }, activeType: D } = w;
    !O || !O.colorPickerNewValue || (OptionColorButtonEvents.updateColorStates(w, O.colorPickerNewValue), OptionColorButtonEvents.updateElements(x, D.name, O.colorPickerNewValue), delete O.colorPickerNewValue, setTimeout(() => w.fireColumnsUpdate()));
  }
  // important to note that mouse/key down events are not fired when clicked on picker
  static windowEventClosePicker(x, w) {
    if (w.cellDropdown) {
      const O = w.cell.columnIndex;
      OptionButton.hideAfterColorPickerContainerClose(x, x[O]);
    }
  }
  // bug fix comments are for code that fixes a firefox bug where color picker is still open after closing the dropdown
  static inputEvent(x, w) {
    if (!Dropdown.isDisplayed(x.element))
      return;
    const O = w.target, { containerElement: D, textElement: U, dropdownItemElement: W } = OptionColorButton.extractRelativeParentElements(O), X = U.textContent, G = O.value;
    W.style.backgroundColor = G;
    const Y = x.itemsDetails[X];
    Y.backgroundColor !== G && (Y.backgroundColor = G, x.labelDetails.colorPickerNewValue = { backgroundColor: G, itemText: X }, setTimeout(() => {
      var K;
      (K = x.labelDetails).colorPickerContainer ?? (K.colorPickerContainer = D);
    }));
  }
  // prettier-ignore
  static mouseDownContainer(x, w, O) {
    const { cellDropdown: { labelDetails: D } } = w;
    if (!D)
      return;
    if (D.colorPickerContainer) {
      delete D.colorPickerContainer, OptionColorButtonEvents.updateColumnLabelColors(x, w);
      return;
    }
    const U = O.target, { containerElement: W, dropdownItemElement: X } = OptionColorButton.extractRelativeParentElements(U), G = U.previousSibling;
    G.value = RGBAToHex.convert(getComputedStyle(X).backgroundColor), G.showPicker(), setTimeout(() => D.colorPickerContainer = W);
  }
  // prettier-ignore
  static setEvents(x, w, O, D) {
    x.onmousedown = OptionColorButtonEvents.mouseDownContainer.bind(this, O, D), w.oninput = OptionColorButtonEvents.inputEvent.bind(this, D.cellDropdown);
  }
}
class FocusNextRowCell {
  // does not work in Safari
  static focus(x, w, O, D) {
    D.preventDefault();
    const U = O[w + 1];
    U && (U.focus(), CaretPosition.setToEndOfText(x, U));
  }
  static focusOrBlurSelect(x, w) {
    const O = x[w + 1];
    if (O)
      return O.dispatchEvent(new Event("mousedown")), O.scrollIntoView({ block: "nearest" }), O;
    x[w].children[0].blur();
  }
}
const ARROW_DOWN_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="12" height="12">
  <g style="pointer-events: none" transform="matrix(0.6315789 0 0 0.6315789 0 0)">
    <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
      <path d="M0 87.5L350 507.5L700 87.5L0 87.5z" stroke="none" fill="#3e3e3e" fill-rule="nonzero" />
    </g>
  </g>
</svg>
`, _ArrowDownIconElement = class mr {
  static toggle(x, w) {
    if (!x)
      return;
    const O = x.children[1];
    O.style.display = w ? "block" : "none";
    const D = O.children[0];
    !w && D.style.filter && (D.style.filter = "");
  }
  static setActive(x) {
    const w = x.children[1].children[0];
    w.style.filter = `brightness(0) saturate(100%) invert(24%) sepia(73%) saturate(631%)
      hue-rotate(171deg) brightness(98%) contrast(98%)`;
  }
  // need a container to allow absolute positioning for the icon
  static createContainer() {
    const x = document.createElement("div");
    return x.classList.add(mr.ARROW_ICON_CONTAINER_CLASS), x.style.display = "none", x;
  }
  // REF-10
  static createSVGElement() {
    const x = SVGIconUtils.createSVGElement(ARROW_DOWN_ICON_SVG_STRING);
    return x.classList.add(mr.ARROW_ICON_CLASS), x;
  }
  static createSVG() {
    const x = mr.createSVGElement(), w = mr.createContainer();
    return w.appendChild(x), w;
  }
  static get() {
    return mr.ARROW_ICON_ELEMENT.cloneNode(!0);
  }
};
_ArrowDownIconElement.ARROW_ICON_CLASS = "arrow-down-icon";
_ArrowDownIconElement.ARROW_ICON_CONTAINER_CLASS = "arrow-down-icon-container";
_ArrowDownIconElement.ARROW_ICON_ELEMENT = _ArrowDownIconElement.createSVG();
let ArrowDownIconElement = _ArrowDownIconElement;
class TableBorderDimensionsUtils {
  static generateDefault() {
    return {
      leftWidth: 0,
      rightWidth: 0,
      topWidth: 0,
      bottomWidth: 0
    };
  }
  static getWidth(x, w) {
    return x.style[w] === "" ? 1 : Number.parseFloat(x.style[w]) || 0;
  }
  static generateUsingElement(x) {
    return {
      leftWidth: TableBorderDimensionsUtils.getWidth(x, "borderLeftWidth"),
      rightWidth: TableBorderDimensionsUtils.getWidth(x, "borderRightWidth"),
      topWidth: TableBorderDimensionsUtils.getWidth(x, "borderTopWidth"),
      bottomWidth: TableBorderDimensionsUtils.getWidth(x, "borderBottomWidth")
    };
  }
}
const _UpdateIndexColumnWidth = class vt {
  static wrapColumnTextAndGetDefaultWidth(x) {
    const { _tableBodyElementRef: w, data: O, _tableDimensions: D } = x;
    return ExtractElements.textRowsArrFromTBody(w, O).forEach((U) => {
      U.children[0].classList.remove(IndexColumn.INDEX_CELL_OVERFLOW_CLASS);
    }), D.isColumnIndexCellTextWrapped = !0, ToggleAdditionElements.update(x, !0, AddNewColumnElement.toggle), IndexColumn.DEFAULT_WIDTH;
  }
  static changeTableWidths(x, w) {
    const O = w - x._tableDimensions.indexColumnWidth;
    x._tableDimensions.indexColumnWidth = w, TableElement.changeStaticWidthTotal(x._tableDimensions, O), StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(x, !0);
  }
  static changeCellAndTableWidths(x, w, O) {
    const D = w.children[0];
    vt.changeTableWidths(x, O), D.style.width = `${O}px`;
  }
  static forceWrap(x, w) {
    const O = vt.wrapColumnTextAndGetDefaultWidth(x);
    vt.changeCellAndTableWidths(x, w, O);
  }
  static shouldTextBeWrapped(x) {
    return !x._tableDimensions.isColumnIndexCellTextWrapped && TableDimensionsUtils.hasSetTableWidthBeenBreached(x);
  }
  static changeWidth(x, w, O) {
    vt.changeCellAndTableWidths(x, w, O), vt.shouldTextBeWrapped(x) && vt.forceWrap(x, w);
  }
  // important to note that on initial render if the font library has not been downloaded
  // scrollWidth will give the wrong number. This is usually not a problem when using
  // small numbers or cache
  static getCellWidth(x) {
    return x.scrollWidth + (Number.parseInt(getComputedStyle(x).borderRightWidth) || 0);
  }
  // need to keep track of first cell because upon using pagination and uploading a new file, drag and droping a new file,
  // or using updateData method with a lot of data does not refresh the cell with original value
  // to reproduce the error, simply set the code in timeout to: firstCell.textContent = firstCellContent
  static temporarilySetFirstRowCellWithLastNumber(x, w, O) {
    const D = x.textContent;
    x.id || (x.id = w ? vt.TEMPORARY_INDEX_NUMBER : vt.TEMPORARY_INVISIBLE_INDEX_NUMBER), x.textContent = O.textContent, setTimeout(() => {
      x.id !== "" && (x.textContent = D, x.removeAttribute("id"));
    });
  }
  static getIndexColumnWidthWithAsyncFix(x, w, O) {
    if (O.scrollWidth === 0) {
      const D = x.children[0];
      return vt.temporarilySetFirstRowCellWithLastNumber(D, w, O), vt.getCellWidth(D);
    }
    return vt.getCellWidth(O);
  }
  // this works because the 'block' display style is not set on the table
  // checking if the cells width is overflown and if so - increase its width (cannot decrease the width)
  static updateColumnWidthWhenOverflow(x, w, O) {
    const D = !!x.dataStartsAtHeader, U = vt.getIndexColumnWidthWithAsyncFix(w, D, O);
    if (x._tableDimensions.indexColumnWidth !== U && U !== 0) {
      const W = U + (Browser.IS_FIREFOX ? 4 : 0);
      Browser.IS_SAFARI ? setTimeout(() => vt.changeWidth(x, w, W)) : vt.changeWidth(x, w, W);
    }
  }
  // when the table element display property is 'block', the 'overflow: hidden;' property does not actually work
  // and instead the lastCell width is changed automatically, all we do here is check if the expected width
  // (at.tableDimensions.indexColumnWidth) is different to the actual one and if so, we change it to actual
  static checkAutoColumnWidthUpdate(x, w) {
    if (w.offsetWidth !== x._tableDimensions.indexColumnWidth) {
      let O = w.offsetWidth;
      x.offsetWidth !== x.scrollWidth && (O = vt.wrapColumnTextAndGetDefaultWidth(x)), vt.changeTableWidths(x, O);
    }
  }
  static updatedBasedOnTableStyle(x, w, O, D = !1) {
    D ? vt.forceWrap(x, w) : x._tableDimensions.preserveNarrowColumns || x._tableDimensions.maxWidth !== void 0 ? vt.updateColumnWidthWhenOverflow(x, w, O) : x._tableDimensions.width !== void 0 && vt.checkAutoColumnWidthUpdate(x, O);
  }
  static getFirstVisibleRow(x) {
    const { _pagination: w, _tableBodyElementRef: O, dataStartsAtHeader: D } = x;
    return D && w ? w.visibleRows[0] : O?.children[0];
  }
  static updatedBasedOnVisiblity(x, w, O = !1) {
    const D = vt.getFirstVisibleRow(x);
    x._pagination && x.filter ? D ? vt.updatedBasedOnTableStyle(x, D, w, O) : setTimeout(() => {
      const U = vt.getFirstVisibleRow(x);
      U && vt.updatedBasedOnTableStyle(x, U, w, O);
    }) : D && vt.updatedBasedOnTableStyle(x, D, w, O);
  }
  // used when a new row is added
  // forceWrap - REF-19
  static update(x, w, O = !1) {
    var D;
    if (x._tableDimensions.isColumnIndexCellTextWrapped)
      return;
    if (!w) {
      const { _tableBodyElementRef: W, data: X } = x;
      w = ExtractElements.textRowsArrFromTBody(W, X);
    }
    const U = (D = w[w.length - 1]) == null ? void 0 : D.children[0];
    U && vt.updatedBasedOnVisiblity(x, U, O);
  }
  // used when a new column is added to see if wrapping is needed
  // CAUTION-2 - this runs before re-render but stay cautions
  static wrapTextWhenNarrowColumnsBreached(x) {
    x._frameComponents.displayIndexColumn && vt.shouldTextBeWrapped(x) && vt.update(x, void 0, !0);
  }
};
_UpdateIndexColumnWidth.TEMPORARY_INDEX_NUMBER = "temp-index-number";
_UpdateIndexColumnWidth.TEMPORARY_INVISIBLE_INDEX_NUMBER = "temp-invisible-index-number";
let UpdateIndexColumnWidth = _UpdateIndexColumnWidth;
const _IndexColumn = class jt {
  static updateIndexes(x, w) {
    const { _tableBodyElementRef: O, data: D, dataStartsAtHeader: U } = x, W = ExtractElements.textRowsArrFromTBody(O, D, w), X = Number(U);
    W.forEach((G, Y) => {
      const K = G.children[0], Z = w + Y + X;
      K.innerText = String(Z);
    }), UpdateIndexColumnWidth.update(x, W.length === 0 ? void 0 : W);
  }
  // prettier-ignore
  static createCell(x, w) {
    var O, D;
    const { _tableDimensions: U, _defaultColumnsSettings: W, _frameComponents: { styles: X, cellColors: G, inheritHeaderColors: Y } } = x, K = CellElement.createBaseCell(w);
    K.classList.add(jt.INDEX_CELL_CLASS, GenericElementUtils.NOT_SELECTABLE_CLASS);
    const { displaySettings: Z, canEditHeaderRow: q } = x.rowDropdown;
    return K.style.cursor = (O = Z.openMethod) != null && O.cellClick && (!w || q) ? "pointer" : "default", U.isColumnIndexCellTextWrapped || K.classList.add(jt.INDEX_CELL_OVERFLOW_CLASS), Object.assign(K.style, W.cellStyle, X?.default || {}), w && Object.assign(
      K.style,
      Y ? (D = W.headerStyles) == null ? void 0 : D.default : {},
      G.header.default
    ), K;
  }
  static createHeaderCell(x) {
    const w = jt.createCell(x, !0);
    return x.dataStartsAtHeader && (w.innerText = "1"), w.style.width = jt.DEFAULT_WIDTH_PX, Browser.IS_SAFARI && setTimeout(() => w.style.width = jt.DEFAULT_WIDTH_PX), w;
  }
  static createDataCell(x, w) {
    const O = jt.createCell(x, !1), D = x.dataStartsAtHeader ? w + 1 : w;
    return O.innerText = String(D), O;
  }
  static createAndPrependToRow(x, w, O) {
    const D = O === 0 ? jt.createHeaderCell(x) : jt.createDataCell(x, O);
    x._columnsDetails[0] && ColumnSettingsBorderUtils.unsetSubjectBorder([D], x._columnsDetails[0].elements, "right", 0), w.appendChild(D);
  }
};
_IndexColumn.INDEX_CELL_CLASS = "index-cell";
_IndexColumn.INDEX_CELL_OVERFLOW_CLASS = "index-cell-overflow";
_IndexColumn.DEFAULT_WIDTH = 30;
_IndexColumn.DEFAULT_WIDTH_PX = `${_IndexColumn.DEFAULT_WIDTH}px`;
let IndexColumn = _IndexColumn;
const UNSET_NUMBER_IDENTIFIER = -1, _TableDimensionsUtils = class _r {
  // REF-19
  static setIsColumnIndexCellTextWrapped(x, w) {
    w && (typeof w == "object" && w.wrapIndexCellText ? x.isColumnIndexCellTextWrapped = !0 : x.isColumnIndexCellTextWrapped === void 0 && (x.isColumnIndexCellTextWrapped = !1));
  }
  static setPreserveNarrowColumnsProp(x, w) {
    w.preserveNarrowColumns = x.preserveNarrowColumns;
  }
  // prettier-ignore
  static setDimension(x, w) {
    const { tableStyle: O, _tableDimensions: D, _tableElementRef: U, parentElement: W } = x;
    if (!U || !W)
      return;
    const X = StringDimensionUtils.generateNumberDimensionFromClientString(
      W,
      O,
      w,
      !0,
      _r.MINIMAL_TABLE_WIDTH
    );
    X.number > 0 && (x.overflow && OverflowUtils.processNumberDimension(D, X), D[w] = X.number, D.isPercentage = X.isPercentage);
  }
  // CAUTION-3
  // prettier-ignore
  static setTableDimensions(x) {
    const { tableStyle: w, _tableDimensions: O, _frameComponents: { displayIndexColumn: D } } = x;
    w.width !== void 0 ? _r.setDimension(x, "width") : w.maxWidth !== void 0 && _r.setDimension(x, "maxWidth"), _r.setPreserveNarrowColumnsProp(x, O), _r.setIsColumnIndexCellTextWrapped(O, D);
  }
  static hasSetTableWidthBeenBreached(x) {
    const { width: w, maxWidth: O } = x._tableDimensions, D = x.offsetWidth, U = w || O;
    return U ? Math.ceil(U) < D : !1;
  }
  static record(x) {
    x._tableDimensions.recordedParentWidth = x.parentElement.offsetWidth, x._tableDimensions.recordedParentHeight = x.parentElement.offsetHeight, x._tableDimensions.recordedWindowWidth = window.innerWidth, x._tableDimensions.recordedWindowHeight = window.innerHeight;
  }
  static getDefault() {
    return {
      recordedParentWidth: 0,
      recordedParentHeight: 0,
      recordedWindowWidth: 0,
      recordedWindowHeight: 0,
      border: TableBorderDimensionsUtils.generateDefault(),
      staticWidth: UNSET_NUMBER_IDENTIFIER,
      newColumnWidth: 140,
      indexColumnWidth: IndexColumn.DEFAULT_WIDTH
    };
  }
};
_TableDimensionsUtils.MINIMAL_TABLE_WIDTH = 70;
let TableDimensionsUtils = _TableDimensionsUtils;
class MaximumRows {
  static canAddMore(x) {
    var w;
    const { _columnsDetails: O, maxRows: D } = x, U = (w = O[0]) == null ? void 0 : w.elements.length;
    return !(U !== void 0 && D !== void 0 && D > 0 && D <= U);
  }
}
class FrameComponentsColors {
  // prettier-ignore
  static getInheritedHeaderColors(x) {
    var w, O, D, U, W, X;
    const { _defaultColumnsSettings: { headerStyles: G, cellStyle: Y } } = x;
    return {
      default: {
        backgroundColor: ((w = G?.default) == null ? void 0 : w.backgroundColor) || Y?.backgroundColor || "",
        color: ((O = G?.default) == null ? void 0 : O.color) || Y?.color || ""
      },
      hover: {
        backgroundColor: ((D = G?.hoverColors) == null ? void 0 : D.backgroundColor) || ((U = G?.default) == null ? void 0 : U.backgroundColor) || Y?.backgroundColor || x._defaultCellHoverColors.backgroundColor,
        color: ((W = G?.hoverColors) == null ? void 0 : W.color) || ((X = G?.default) == null ? void 0 : X.color) || Y?.color || x._defaultCellHoverColors.color
      }
    };
  }
  // prettier-ignore
  static getHoverColorValue(x, w) {
    var O, D, U;
    const { _frameComponents: { styles: W }, _defaultCellHoverColors: X } = x;
    return ((O = W?.hoverColors) == null ? void 0 : O[w]) || ((D = W?.default) == null ? void 0 : D[w]) || ((U = x._defaultColumnsSettings.cellStyle) == null ? void 0 : U[w]) || X[w];
  }
  static getDefaultColorValue(x, w) {
    var O, D, U;
    return ((D = (O = x._frameComponents.styles) == null ? void 0 : O.default) == null ? void 0 : D[w]) || ((U = x._defaultColumnsSettings.cellStyle) == null ? void 0 : U[w]) || "";
  }
  // prettier-ignore
  static setEventColors(x) {
    const w = {
      default: {
        backgroundColor: FrameComponentsColors.getDefaultColorValue(x, "backgroundColor"),
        color: FrameComponentsColors.getDefaultColorValue(x, "color")
      },
      hover: {
        backgroundColor: FrameComponentsColors.getHoverColorValue(x, "backgroundColor"),
        color: FrameComponentsColors.getHoverColorValue(x, "color")
      }
    }, { _frameComponents: { cellColors: O, inheritHeaderColors: D } } = x;
    O.data = w, O.header = D ? FrameComponentsColors.getInheritedHeaderColors(x) : w;
  }
  static getColorsBasedOnParam(x, w) {
    const { data: O, header: D } = x;
    return w === 0 ? D : O;
  }
  static getDefaultCellColors() {
    return {
      data: {
        default: { backgroundColor: "", color: "" },
        hover: { backgroundColor: "", color: "" }
      },
      header: {
        default: { backgroundColor: "", color: "" },
        hover: { backgroundColor: "", color: "" }
      }
    };
  }
}
class CellHighlightUtils {
  static fade(x, w) {
    x.style.backgroundColor = w?.backgroundColor || "", x.style.color = w?.color || "";
  }
  static highlight(x, w) {
    w != null && w.backgroundColor && (x.style.backgroundColor = w.backgroundColor), w != null && w.color && (x.style.color = w.color);
  }
  static unsetDefaultHoverProperties(x) {
    x.backgroundColor = "", x.color = "";
  }
  static getDefaultHoverProperties() {
    return { backgroundColor: "#f7f7f7", color: "" };
  }
}
class ElementOffset {
  static processLeft(x, w) {
    return Browser.IS_FIREFOX ? x += w.leftWidth : Browser.IS_SAFARI && (x -= w.leftWidth), x;
  }
  static processTop(x, w) {
    return Browser.IS_FIREFOX ? x += w.topWidth : Browser.IS_SAFARI && (x -= w.topWidth), x;
  }
  static processWidth(x, w) {
    return Browser.IS_FIREFOX && (x += w.leftWidth), x;
  }
}
class VisibilityUtils {
  static headerChanged(x) {
    setTimeout(() => {
      x._visiblityInternal.filters && FilterInternalUtils.resetAllInputs(x);
    });
  }
  static completeReset(x) {
    x._visiblityInternal.filters && FilterInternalUtils.completeReset(x);
  }
}
const _CaretDisplayFix = class qt {
  static removeContentEditable(x) {
    x.removeAttribute(qt.CONTENT_EDITABLE);
  }
  // THIS HAS TO BE CALLED IN A FOCUS EVENT!!!!!!!!!!!!!!!!!
  static setContentEditable(x) {
    x.setAttribute(qt.CONTENT_EDITABLE, "true");
  }
  static removeTabIndex(x) {
    x.removeAttribute(qt.TAB_INDEX);
  }
  static setTabIndex(x) {
    x.setAttribute(qt.TAB_INDEX, "0");
  }
  static removeBRPadding(x, w) {
    const O = CellElement.getTextElement(w).childNodes[0];
    O.tagName === qt.BR_TAG_NAME && (O.remove(), CaretPosition.setToEndOfText(x, w));
  }
  static addBRPaddingToEmptyCell(x, w) {
    const O = CellElement.getTextElement(x);
    w === EMPTY_STRING && O.childNodes.length === 0 && O.appendChild(document.createElement(qt.BR_TAG_NAME));
  }
  // caret is placed too far on top left
  // this happens when cell text is programmatically set to empty or when the user doubeclicks text and clicks backspace
  // natively firefox adds a 'br' element to replace the text when the user deletes it when clicking backspace for each
  // letter however it does not for the cases outlined previously, hence this is needed
  static toggleCellTextBRPadding(x, w, O) {
    const D = CellElement.getText(w);
    O && D !== EMPTY_STRING ? qt.removeBRPadding(x, w) : qt.addBRPaddingToEmptyCell(w, D);
  }
  static isIssueBrowser() {
    return Browser.IS_FIREFOX || Browser.IS_SAFARI;
  }
};
_CaretDisplayFix.CONTENT_EDITABLE = "contenteditable";
_CaretDisplayFix.TAB_INDEX = "tabindex";
_CaretDisplayFix.BR_TAG_NAME = "BR";
let CaretDisplayFix = _CaretDisplayFix;
const _CellTextElement = class Rr {
  static set(x, w) {
    x.innerText = "", x.contentEditable = "false", CaretDisplayFix.isIssueBrowser() && CaretDisplayFix.removeTabIndex(x), x.appendChild(w);
  }
  static createTextElement(x, w) {
    const O = document.createElement("div");
    return O.innerText = x, x === "" && CaretDisplayFix.addBRPaddingToEmptyCell(O, ""), O.classList.add(Rr.CELL_TEXT_DIV_CLASS), CellElement.prepContentEditable(O, w), O;
  }
  static setCellTextAsAnElement(x, w) {
    const O = CellElement.getText(x), D = Rr.createTextElement(O, w);
    return Rr.set(x, D), D;
  }
};
_CellTextElement.CELL_TEXT_DIV_CLASS = "cell-text-div";
let CellTextElement = _CellTextElement;
const _HeaderIconCellElement = class Jt {
  static createTextElement(x, w) {
    const O = CellTextElement.setCellTextAsAnElement(x, w);
    return O.classList.add(Jt.TEXT_CLASS), O.style.pointerEvents = w ? "" : "none", O;
  }
  static setScale(x, w) {
    const O = w?.x || 1.2, D = w?.y || 1.2, U = `scale(${O}, ${D})`;
    x.style.transform = U, x.style.webkitTransform = U;
  }
  static createSvgIcon(x, w) {
    var O, D;
    const U = SVGIconUtils.createSVGElement(x.svgString);
    return Jt.setScale(U, (O = w.headerIconStyle) == null ? void 0 : O.scale), U.style.filter = ((D = w.headerIconStyle) == null ? void 0 : D.filterColor) || SVGIconUtils.HEADER_FILTER, U;
  }
  static createSVGContainer(x) {
    const w = document.createElement("div"), { containerStyles: O } = x;
    return O != null && O.dropdown && Object.assign(w.style, O?.dropdown), O != null && O.headerCorrections && Object.assign(w.style, O?.headerCorrections), w.classList.add(Jt.ICON_CONTAINER_CLASS), w;
  }
  static createSVG(x, w) {
    const O = Jt.createSVGContainer(x), D = Jt.createSvgIcon(x, w);
    return O.appendChild(D), O;
  }
  static changeHeaderIcon(x) {
    const { elements: w, activeType: O, settings: D } = x, U = Jt.createSVG(O.dropdownItem.settings.iconSettings, D), W = w[0];
    W.replaceChild(U, W.children[0]);
  }
  static setHeaderIconStructure(x, w, O) {
    var D, U, W;
    const { activeType: X, settings: G } = x._columnsDetails[O], Y = Jt.createSVG(X.dropdownItem.settings.iconSettings, G), K = (W = (U = (D = x._defaultColumnsSettings.columnDropdown) == null ? void 0 : D.displaySettings) == null ? void 0 : U.openMethod) == null ? void 0 : W.cellClick, Z = G.isHeaderTextEditable && !K, q = Jt.createTextElement(w, Z);
    w.insertBefore(Y, q);
  }
};
_HeaderIconCellElement.TEXT_CLASS = "header-icon-side-text";
_HeaderIconCellElement.ICON_CONTAINER_CLASS = "header-icon-container";
let HeaderIconCellElement = _HeaderIconCellElement;
const _DateCellInputElement = class Xt {
  static isInputElement(x) {
    return x?.type === Xt.ELEMENT_TYPE;
  }
  static toggle(x, w) {
    if (!x)
      return;
    const O = x.children[1];
    O.style.display = w ? "block" : "none";
  }
  static extractInputElementFromCell(x) {
    return x.children[1].children[0];
  }
  static convertTextToInputValue(x, w) {
    if (w.calendar && (w.textValidation.func === void 0 || w.textValidation.func(x))) {
      const O = w.calendar.toYMDFunc(x);
      return [O[0], O[1].padStart(2, "0"), O[2].padStart(2, "0")].join("-");
    }
    return "-";
  }
  static updateInputBasedOnTextDiv(x, w) {
    const O = Xt.convertTextToInputValue(CellElement.getText(x), w);
    Xt.extractInputElementFromCell(x).value = O;
  }
  static createInputElement(x, w) {
    const O = document.createElement("input");
    return O.type = Xt.ELEMENT_TYPE, O.classList.add(Xt.DATE_INPUT_CLASS), O.value = Xt.convertTextToInputValue(x, w), O;
  }
  static createInputElementContainer() {
    const x = document.createElement("div");
    return x.classList.add(Xt.DATE_INPUT_CONTAINER_CLASS), x.style.display = "none", x;
  }
  static addDateInputElement(x, w, O) {
    const D = Xt.createInputElementContainer(), U = Xt.createInputElement(CellElement.getText(w), O);
    D.appendChild(U);
    const W = DateCellCalendarIconElement.get();
    D.appendChild(W), x.appendChild(D);
  }
};
_DateCellInputElement.ELEMENT_TYPE = "date";
_DateCellInputElement.DATE_INPUT_CLASS = "date-input";
_DateCellInputElement.DATE_INPUT_CONTAINER_CLASS = "date-input-container";
let DateCellInputElement = _DateCellInputElement;
class DateCellTextElement {
  static convertInputValueToText(x, w, O) {
    const D = RegexUtils.extractIntegerStrs(x);
    return D ? O.fromYMDFunc(D) : w;
  }
  static setCellTextAsAnElement(x, w) {
    const O = CellTextElement.setCellTextAsAnElement(x, w);
    return O.style.float = "left", O;
  }
}
const _DateCellCalendarIconEvents = class Vr {
  static mouseDownIcon(x, w, O) {
    const { _focusedElements: D, _activeOverlayElements: U } = this, W = O.target.previousSibling, X = CellElement.getCellElement(W);
    setTimeout(() => {
      FocusedCellUtils.set(D.cell, X, x, w), U.datePickerCell = X, Browser.IS_SAFARI ? W.dispatchEvent(new MouseEvent("click")) : W.showPicker();
    }, Vr.PICKER_DISPLAY_DELAY_ML);
  }
  static setEvents(x, w, O, D) {
    w.onmousedown = Vr.mouseDownIcon.bind(x, O, D);
  }
};
_DateCellCalendarIconEvents.PICKER_DISPLAY_DELAY_ML = Browser.IS_FIREFOX ? 190 : 0;
let DateCellCalendarIconEvents = _DateCellCalendarIconEvents;
var MOUSE_EVENT = /* @__PURE__ */ ((F) => (F.DOWN = "Down", F))(MOUSE_EVENT || {});
class DateCellInputEvents {
  // outstanding bug is when the user opens picker and moves with arrow keys, then clicks escape
  // the picker fires a clear event and does not actually close itself and instead goes to the
  // initially opened up date. The key up event for the escape button is also not fired.
  static escapeKeyInput(x) {
    if (x._activeOverlayElements.datePickerCell) {
      const w = x._focusedElements.cell.element;
      x._hoveredElements.dateCell !== w && DateCellInputElement.toggle(w, !1), delete x._activeOverlayElements.datePickerCell;
    }
  }
  // this is triggered when a date is selected via the date picker
  // prettier-ignore
  static inputInput(x, w, O) {
    const { elements: D, settings: { defaultText: U }, activeType: { calendar: W } } = this._columnsDetails[w];
    if (!W)
      return;
    const X = O.target.value, G = DateCellTextElement.convertInputValueToText(X, U, W), Y = D[x];
    CellEvents.updateCell(this, G, x, w, { element: Y });
  }
  // this is triggered when the user clicks on picker buttons
  static changeInput() {
    const x = this._focusedElements.cell.element;
    !this._userKeyEventsState[MOUSE_EVENT.DOWN] && // do not hide icon when currently hovered
    this._hoveredElements.dateCell !== x && DateCellInputElement.toggle(x, !1), delete this._activeOverlayElements.datePickerCell;
  }
  // the user does not use the actual input element and the events are triggered via the date picker
  static setEvents(x, w, O, D) {
    w.onchange = DateCellInputEvents.changeInput.bind(x), w.oninput = DateCellInputEvents.inputInput.bind(x, O, D);
  }
}
class FocusNextColumnCellFromTextDiv {
  static focusDifferentColumnCell(x, w, O) {
    const { elements: D, activeType: U, settings: W } = x._columnsDetails[w], X = D[O];
    if (!W.isCellTextEditable || O === 0 && !W.isHeaderTextEditable || // REF-29
    Browser.IS_SAFARI && CheckboxCellElement.isCheckboxCell(X))
      return FocusNextColumnCellFromTextDiv.focusOrBlurNext(x, w, O);
    U.cellDropdownProps ? X.dispatchEvent(new Event("mousedown")) : (CellWithTextEvents.programmaticBlur(x), CellElement.getTextElement(X).focus()), X.scrollIntoView({ block: "nearest" });
  }
  static focusOrBlurNextRowFirstCell(x, w) {
    const O = x._columnsDetails[0], D = w + 1;
    O.elements[D] ? FocusNextColumnCellFromTextDiv.focusDifferentColumnCell(x, 0, D) : x._focusedElements.cell.element.children[0].blur();
  }
  static focusOrBlurNext(x, w, O) {
    x._columnsDetails[w + 1] ? FocusNextColumnCellFromTextDiv.focusDifferentColumnCell(x, w + 1, O) : FocusNextColumnCellFromTextDiv.focusOrBlurNextRowFirstCell(x, O);
  }
}
class CellTextEvents {
  static tabOutOfCell(x, w, O, D) {
    D.preventDefault(), DataCellEvents.keyDownCell.bind(x, w, O)(D), FocusNextColumnCellFromTextDiv.focusOrBlurNext(x, O, w);
  }
}
class DateCellTextEvents {
  static keyDownOnText(x, w, O) {
    O.key === KEYBOARD_KEY.TAB && CellTextEvents.tabOutOfCell(this, x, w, O);
  }
  static inputText(x, w) {
    if (Browser.IS_INPUT_DATE_SUPPORTED) {
      const { activeType: O } = this._columnsDetails[x], D = CellElement.getCellElement(w.target);
      DateCellInputElement.updateInputBasedOnTextDiv(D, O);
    }
  }
  static blurText(x, w, O) {
    const D = O.target;
    DataCellEvents.blur(this, x, w, D);
  }
  static setEvents(x, w, O, D) {
    x._columnsDetails[D].settings.isCellTextEditable && (w.onfocus = CellWithTextEvents.focusText.bind(x, O, D, null), w.onblur = DateCellTextEvents.blurText.bind(x, O, D), w.oninput = DateCellTextEvents.inputText.bind(x, D), w.onkeydown = DateCellTextEvents.keyDownOnText.bind(x, O, D));
  }
}
class DateCellEvents {
  static mouseLeaveCell(x) {
    if (delete this._hoveredElements.dateCell, Browser.IS_INPUT_DATE_SUPPORTED) {
      const w = x.target;
      if (this._activeOverlayElements.datePickerCell === w)
        return;
      DateCellInputElement.toggle(w, !1);
    }
  }
  static mouseEnterCell(x) {
    this._hoveredElements.dateCell = x.target, Browser.IS_INPUT_DATE_SUPPORTED && DateCellInputElement.toggle(this._hoveredElements.dateCell, !0);
  }
  static setEvents(x, w, O, D) {
    if (!x._columnsDetails[D].settings.isCellTextEditable)
      return;
    w.onblur = () => {
    }, w.onfocus = () => {
    }, w.onmouseenter = DateCellEvents.mouseEnterCell.bind(x), w.onmouseleave = DateCellEvents.mouseLeaveCell.bind(x), w.onmousedown = CellWithTextEvents.mouseDown.bind(x, null);
    const U = w.children[0];
    if (DateCellTextEvents.setEvents(x, U, O, D), Browser.IS_INPUT_DATE_SUPPORTED) {
      const W = w.children[1];
      DateCellInputEvents.setEvents(x, W, O, D);
      const X = W.children[1];
      DateCellCalendarIconEvents.setEvents(x, X, O, D);
    }
  }
}
class DateCellElement {
  // prettier-ignore
  static setCellDateStructure(x, w, O) {
    ConvertCellTypeUtils.preprocessCell(w), w.style.cursor = "text";
    const { isCellTextEditable: D } = x._columnsDetails[O].settings, U = DateCellTextElement.setCellTextAsAnElement(w, D);
    Browser.IS_INPUT_DATE_SUPPORTED && DateCellInputElement.addDateInputElement(
      w,
      U,
      x._columnsDetails[O].activeType
    );
  }
  static setColumnDateStructure(x, w) {
    CellStructureUtils.setColumn(x, w, DateCellElement.setCellDateStructure, DateCellEvents.setEvents);
  }
}
const _SelectCellTextElement = class jr {
  static setCellTextAsAnElement(x, w, O) {
    const { isCellTextEditable: D } = x._columnsDetails[O].settings;
    CellTextElement.setCellTextAsAnElement(w, D).classList.add(jr.TEXT_CLASS);
  }
  // prettier-ignore
  static finaliseEditedText(x, w, O) {
    var D, U;
    const W = x._columnsDetails[O], { cellDropdown: X, activeType: G, settings: Y } = W, K = CellElement.getText(w), Z = !!((D = X.itemsDetails[K]) != null && D.backgroundColor);
    (U = G.cellDropdownProps) != null && U.canAddMoreOptions && K !== EMPTY_STRING && !Z && (!Y.isDefaultTextRemovable || K !== Y.defaultText) && CellDropdownItem.addNewItem(x, w, W, w.style.backgroundColor);
  }
};
_SelectCellTextElement.TEXT_CLASS = "select-cell-text";
let SelectCellTextElement = _SelectCellTextElement;
class SelectCellBaseEvents {
  static blurIfDropdownFocused(x) {
    x._focusedElements.cellDropdown && CellWithTextEvents.programmaticBlur(x);
  }
}
class SelectCellEvents {
  static mouseLeaveCell(x, w) {
    delete this._hoveredElements.selectCell;
    const O = w.target, { cellDropdown: D } = this._columnsDetails[x];
    (!Dropdown.isDisplayed(D.element) || D.displayedCellElement !== O) && ArrowDownIconElement.toggle(O, !1);
  }
  static mouseEnterCell(x) {
    this._hoveredElements.selectCell = x.target, ArrowDownIconElement.toggle(this._hoveredElements.selectCell, !0);
  }
  static mouseDownCell(x) {
    var w;
    const O = x.target;
    if (O.classList.contains(CellElement.CELL_CLASS))
      CellWithTextEvents.mouseDownCell(this, SelectCellBaseEvents.blurIfDropdownFocused, O, x);
    else if (O.classList.contains(ArrowDownIconElement.ARROW_ICON_CLASS)) {
      const D = (w = O.parentElement) == null ? void 0 : w.parentElement;
      CellWithTextEvents.mouseDownCell(this, SelectCellBaseEvents.blurIfDropdownFocused, D, x);
    }
  }
  static setEvents(x, w, O, D) {
    if (!x._columnsDetails[D].settings.isCellTextEditable)
      return;
    w.onblur = () => {
    }, w.onfocus = () => {
    }, w.onmouseenter = SelectCellEvents.mouseEnterCell.bind(x), w.onmouseleave = SelectCellEvents.mouseLeaveCell.bind(x, D), w.onmousedown = SelectCellEvents.mouseDownCell.bind(x);
    const U = w.children[0];
    SelectCellTextBaseEvents.setEvents(x, U, O, D);
  }
}
class SelectCellElement {
  static setCellSelectStructure(x, w, O) {
    ConvertCellTypeUtils.preprocessCell(w), SelectCellTextElement.setCellTextAsAnElement(x, w, O), w.appendChild(ArrowDownIconElement.get()), SelectCell.setPointerCursorIfCantAdd(w, x._columnsDetails[O].activeType);
  }
  static setColumnSelectStructure(x, w) {
    CellStructureUtils.setColumn(x, w, SelectCellElement.setCellSelectStructure, SelectCellEvents.setEvents);
  }
}
class LabelCellEvents {
  static setEvents(x, w, O, D) {
    if (!x._columnsDetails[D].settings.isCellTextEditable)
      return;
    w.onblur = () => {
    }, w.onfocus = () => {
    }, w.onmouseenter = () => {
    }, w.onmouseleave = () => {
    }, w.onmousedown = CellWithTextEvents.mouseDown.bind(x, SelectCellBaseEvents.blurIfDropdownFocused);
    const U = w.children[0];
    SelectCellTextBaseEvents.setEvents(x, U, O, D);
  }
}
class LabelCellElement {
  // prettier-ignore
  static setCellLabelStructure(x, w, O) {
    var D;
    ConvertCellTypeUtils.preprocessCell(w);
    const { cellDropdown: { itemsDetails: U }, settings: { isCellTextEditable: W } } = x._columnsDetails[O], X = ((D = U[CellElement.getText(w)]) == null ? void 0 : D.backgroundColor) || "";
    LabelCellTextElement.setCellTextAsAnElement(w, X, W), SelectCell.setPointerCursorIfCantAdd(w, x._columnsDetails[O].activeType);
  }
  static setColumnLabelStructure(x, w) {
    CellStructureUtils.setColumn(x, w, LabelCellElement.setCellLabelStructure, LabelCellEvents.setEvents);
  }
}
class SelectCell {
  static convertCell(x, w, O) {
    var D;
    (D = x._columnsDetails[w].activeType.cellDropdownProps) != null && D.isBasicSelect ? SelectCellElement.setCellSelectStructure(x, O, w) : LabelCellElement.setCellLabelStructure(x, O, w);
  }
  static convertColumn(x, w, O) {
    var D;
    (D = O.cellDropdownProps) != null && D.isBasicSelect ? SelectCellElement.setColumnSelectStructure(x, w) : LabelCellElement.setColumnLabelStructure(x, w);
  }
  static setEvents(x, w, O, D) {
    var U;
    const { activeType: W } = x._columnsDetails[D];
    (U = W.cellDropdownProps) != null && U.isBasicSelect ? SelectCellEvents.setEvents(x, w, O, D) : LabelCellEvents.setEvents(x, w, O, D);
  }
  // prettier-ignore
  static finaliseEditedText(x, w, O, D = !1) {
    var U;
    const { activeType: W } = x._columnsDetails[O];
    (U = W.cellDropdownProps) != null && U.isBasicSelect ? SelectCellTextElement.finaliseEditedText(x, w, O) : LabelCellTextElement.finaliseEditedText(x, w, O, D);
  }
  static setPointerCursorIfCantAdd(x, w) {
    var O;
    if (x.style.cursor = "pointer", !((O = w.cellDropdownProps) != null && O.canAddMoreOptions)) {
      const D = x.children[0];
      D.style.caretColor = "transparent", D.style.cursor = "pointer";
    }
  }
}
class DataCellElement {
  static setCellDataStructure(x, w, O) {
    w.innerText = CellElement.getTextElement(w).innerText;
    const { isCellTextEditable: D } = x._columnsDetails[O].settings;
    CellElement.prepContentEditable(w, D);
  }
  static setColumnDataStructure(x, w) {
    CellStructureUtils.setColumn(x, w, DataCellElement.setCellDataStructure, DataCellEvents.setEvents);
  }
}
class ChangeColumnType {
  static setInvalidCellToDefault(x, w, O) {
    const D = w + 1, U = x._columnsDetails[O].elements[D];
    return CellEvents.setCellToDefaultIfNeeded(x, D, O, U, !1);
  }
  static setInvalidCellsToDefault(x, w) {
    let O = !1;
    x.data.slice(1).forEach((D, U) => {
      ChangeColumnType.setInvalidCellToDefault(x, U, w) && !O && (O = !0);
    }), O && setTimeout(() => FireEvents.onDataUpdate(x));
  }
  static setNew(x, w, O) {
    const D = x._columnsDetails[O];
    return D.activeType = D.settings.types.find((U) => U.name === w), D.activeType;
  }
  static setNewStructureBasedOnType(x, w, O) {
    delete x._columnsDetails[w].cellDropdown.labelDetails, O.cellDropdownProps ? (CellDropdown.setUpDropdown(x, w), SelectCell.convertColumn(x, w, O)) : O.calendar ? DateCellElement.setColumnDateStructure(x, w) : O.checkbox ? CheckboxCellElement.setColumnCheckboxStructure(x, w) : DataCellElement.setColumnDataStructure(x, w);
  }
  // this is required as switching to another type makes it difficult to overwrite text element (as there isn't one) for
  // checkboxes when validation fails
  static resetCheckboxElements(x) {
    x.elements.slice(1).forEach((w) => {
      w.innerText = CellElement.getText(w);
    });
  }
  static resetAndChangeFunc(x, w, O) {
    const D = x._columnsDetails[O];
    D.activeType.checkbox && ChangeColumnType.resetCheckboxElements(D);
    const U = ChangeColumnType.setNew(x, w, O);
    U.textValidation.func && U.textValidation.setTextToDefaultOnFail && ChangeColumnType.setInvalidCellsToDefault(x, O), ChangeColumnType.setNewStructureBasedOnType(x, O, U), x.displayHeaderIcons && HeaderIconCellElement.changeHeaderIcon(x._columnsDetails[O]), setTimeout(() => FireEvents.onColumnsUpdate(x));
  }
  // prettier-ignore
  static change(x, w) {
    const O = this._columnsDetails[w].activeType;
    x !== O.name && ProcessedDataTextStyle.resetDataCellsStyle(
      this,
      w,
      ChangeColumnType.resetAndChangeFunc.bind(this, this, x, w)
    );
  }
}
class CheckboxValidationFunc {
  // cannot place this inside the CheckboxCellElement class as certain dependencies are not imported in time
  static getDefault() {
    return (x) => {
      const w = String(x).trim().toLocaleLowerCase();
      return w === "" || w === "0" || w === "00" || w === "false" ? "false" : "true";
    };
  }
}
const CURRENCY_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16">
	<g transform="matrix(0.84210527 0 0 0.84210527 0 0)">
		<g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
			<g>
				<path d="M441.1 297.29C 422.358 282.915 397.057 271.728 364.155 263.138L364.155 263.138L364.155 113.058C 378.792 114.1439 405.382 119.14 452.362 140.058C 458.8308 142.9291 466.339 142.1322 472.061 137.97209C 477.7837 133.81189 480.854 126.91709 480.1157 119.87809C 479.38132 112.84289 474.9477 106.73009 468.4867 103.843094C 413.2097 79.230095 381.8067 74.17909 364.15668 73.300095L364.15668 73.300095L364.15668 42.152092C 364.15668 34.335693 357.82077 27.996092 350.00067 27.996092C 342.18057 27.996092 335.84467 34.33589 335.84467 42.152092L335.84467 42.152092L335.84467 73.93709C 307.65366 76.28479 280.86768 87.23009 259.09866 105.29208C 234.52066 125.13208 220.09067 154.91309 219.75467 186.49509C 219.5242 216.7761 234.14967 245.24908 258.89966 262.7021C 277.64166 277.0771 302.94266 288.2641 335.84467 296.8541L335.84467 296.8541L335.84467 446.93408C 321.20767 445.84818 294.60666 440.84818 247.63766 419.93408L247.63766 419.93408L247.63766 419.93018C 241.16887 417.05908 233.66066 417.856 227.93866 422.01608C 222.21596 426.17627 219.14566 433.07108 219.88396 440.11008C 220.61833 447.14526 225.05196 453.2581 231.51295 456.14508C 286.72797 480.73108 318.18097 485.80908 335.84296 486.69608L335.84296 486.69608L335.84296 517.8371C 335.84296 525.6535 342.17886 531.9931 349.99896 531.9931C 357.81906 531.9931 364.15497 525.6533 364.15497 517.8371L364.15497 517.8371L364.15497 486.0521C 392.34598 483.7044 419.13196 472.7591 440.90097 454.69708C 465.47897 434.8571 479.90897 405.07608 480.24496 373.49408C 480.47543 343.21307 465.84998 314.74008 441.09998 297.28708L441.09998 297.28708L441.1 297.29zM282.99 231.22801C 268.099 221.23581 259.232 204.42702 259.392 186.49802C 259.81778 166.59201 269.1029 147.90802 284.712 135.54501C 299.302 123.52501 317.06 115.99001 335.841 113.85401L335.841 113.85401L335.841 255.71402C 316.907 250.75702 299.013 242.46402 282.989 231.22601zM415.27997 424.448L415.28387 424.448C 400.69388 436.468 382.93588 444.003 364.15488 446.139L364.15488 446.139L364.15488 304.279C 383.08887 309.236 400.98288 317.529 417.00687 328.767C 431.89786 338.7592 440.76486 355.568 440.60486 373.497C 440.17908 393.403 430.89395 412.087 415.28485 424.45z" stroke="none" fill="#000000" fill-rule="nonzero" />
			</g>
		</g>
	</g>
</svg>`, CHECKBOX_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="13" height="13">
  <g transform="matrix(0.68421054 0 0 0.68421054 0 0)">
    <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
      <g>
        <path d="M521.77 0L178.24002 0C 119.416016 0 70.01002 49.41 70.01002 108.23L70.01002 108.23L70.01002 454.11002C 70.01002 512.934 119.42001 562.34 178.24002 562.34L178.24002 562.34L524.12 562.34C 582.944 562.34 632.35 512.93005 632.35 454.11002L632.35 454.11002L632.35 108.23001C 629.99835 49.40601 582.94 7.6293945E-06 521.76 7.6293945E-06L521.76 7.6293945E-06L521.77 0zM587.653 451.77C 587.653 487.063 559.419 515.30096 524.122 515.30096L524.122 515.30096L178.242 515.29706C 142.949 515.29706 114.711006 487.06305 114.711006 451.76605L114.711006 451.76605L114.71491 108.23605C 114.71491 72.943054 142.94891 44.705055 178.24591 44.705055L178.24591 44.705055L524.1259 44.705055C 559.41895 44.705055 587.6569 72.93906 587.6569 108.23605z" stroke="none" fill="#010101" fill-rule="nonzero" />
        <path d="M479.41 164.71L293.53 350.59003L222.94 280.00003C 213.5298 270.58984 201.764 270.58984 192.35 280.00003C 182.9398 289.41022 182.9398 301.17603 192.35 310.59003L192.35 310.59003L279.409 397.64902C 281.7684 400.0006 286.4715 402.3521 293.534 402.3521C 300.5926 402.3521 305.3 400.00052 307.651 395.29352L307.651 395.29352L510.001 192.94351C 517.05963 185.88492 517.05963 171.76752 510.001 164.70952C 500.59082 155.29543 486.47 155.29543 479.411 164.70952L479.411 164.70952L479.41 164.71z" stroke="none" fill="#010101" fill-rule="nonzero" />
      </g>
    </g>
  </g>
</svg>`, SELECT_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="14">
	<g transform="matrix(0.9 0 0 0.93333334 0 0)">
		<g transform="matrix(0.03 0 0 0.03 2.5000005 -0)">
			<g transform="matrix(1 0 0 1 -86.77152 -33.81399)">
				<g transform="matrix(1 0 0 1 -13.737094 17.33647)">
					<path d="M399.537 218.885L277.33 218.885C 262.315 218.885 254.544 236.996 265.421 247.859L265.421 247.859L328.596 310.981C 335.328 317.708 346.201 317.708 352.933 310.466L352.933 310.466L411.966 247.343C 421.805 236.476 414.555 218.885 399.537 218.885z" stroke="none" fill="#000000" fill-rule="nonzero" />
					<path d="M340.559 56.069C 226.133 56.069 128.026 151.307 128.026 265.753C 128.026 380.198 224.339 475.408 338.765 475.408C 453.191 475.408 547.665 380.561 547.665 266.116C 547.665 151.67 454.985 56.069 340.559 56.069zM338.765 452.542C 235.73 452.542 152.37 369.168 152.37 266.116C 152.37 163.063 235.73 79.689 338.765 79.689C 441.8 79.689 525.16 163.063 525.16 266.116C 525.157 369.168 441.797 452.542 338.765 452.542z" stroke="none" fill="#000000" fill-rule="nonzero" />
				</g>
			</g>
		</g>
	</g>
</svg>`, NUMBER_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14">
	<g transform="matrix(0.7368421 0 0 0.7368421 0 0)">
		<g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
			<path d="M577.5 175L471.36 175L489.78598 55.160004C 490.4813 49.101402 487.96957 43.117004 483.15707 39.367004C 478.34848 35.620903 471.93008 34.644302 466.22308 36.796703C 460.51608 38.949005 456.34418 43.917805 455.2071 49.909702L455.2071 49.909702L435.9371 174.9997L296.35712 174.9997L314.7831 55.1597C 315.66983 50.4917 314.61905 45.6597 311.87292 41.7807C 309.12292 37.901802 304.91592 35.308 300.21692 34.5971C 295.51773 33.88226 290.7325 35.11272 286.95493 37.999397C 283.18152 40.886097 280.74402 45.186897 280.20493 49.909397L280.20493 49.909397L260.93494 174.99939L157.49493 174.99939C 151.24103 174.99939 145.46393 178.3353 142.33893 183.74939C 139.21393 189.16348 139.21393 195.83539 142.33893 201.24939C 145.46393 206.66339 151.24123 209.99939 157.49493 209.99939L157.49493 209.99939L255.49493 209.99939L234.02194 349.9994L122.49194 349.9994C 116.238045 349.9994 110.460945 353.3353 107.335945 358.7494C 104.210945 364.16348 104.210945 370.8354 107.335945 376.2494C 110.460945 381.6634 116.23824 384.9994 122.49194 384.9994L122.49194 384.9994L228.63194 384.9994L210.20595 504.8394C 209.31923 509.5074 210.37001 514.33936 213.11615 518.2184C 215.86615 522.0973 220.07315 524.6911 224.77216 525.402C 229.47136 526.1168 234.25656 524.88635 238.03415 521.9997C 241.80756 519.113 244.24506 514.8122 244.78415 510.0897L244.78415 510.0897L264.05414 384.9997L403.63416 384.9997L385.20816 504.8397C 384.32144 509.5077 385.37222 514.3397 388.11835 518.2187C 390.86835 522.0976 395.07535 524.6914 399.77435 525.4023C 404.47354 526.1171 409.25876 524.88666 413.03635 522C 416.80975 519.1133 419.24725 514.8125 419.78635 510.09L419.78635 510.09L439.05634 385L542.49634 385C 548.75024 385 554.52734 381.6641 557.65234 376.25C 560.77734 370.8359 560.77734 364.164 557.65234 358.75C 554.52734 353.336 548.75006 350 542.49634 350L542.49634 350L444.49634 350L466.03934 210L577.4993 210C 583.75323 210 589.53033 206.6641 592.65533 201.25C 595.78033 195.8359 595.78033 189.164 592.65533 183.75C 589.53033 178.336 583.75305 175 577.4993 175L577.4993 175L577.5 175zM430.5 210L408.957 350L269.497 350L291.04 210z" stroke="none" fill="#000000" fill-rule="nonzero" />
		</g>
	</g>
</svg>`, LABEL_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14">
	<g transform="matrix(0.7368421 0 0 0.7368421 0 0)">
		<g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
			<g>
				<path d="M279.16 122.86L470.53 122.86L470.53 95.829C 470.53 82.16901 464.9362 69.755005 455.913 60.735C 446.8896 51.7116 434.475 46.118 420.835 46.118L420.835 46.118L165.825 46.118C 152.165 46.118 139.75099 51.7118 130.73099 60.735C 121.70759 69.7584 116.11399 82.173004 116.11399 95.829L116.11399 95.829L116.11399 350.839C 116.11399 364.47998 121.707794 376.913 130.73099 385.917C 139.7544 394.9404 152.16899 400.534 165.82498 400.534L165.82498 400.534L192.85599 400.534L192.85599 209.164C 192.85599 185.41 202.5669 163.836 218.19199 148.195C 233.81708 132.55402 255.40298 122.85901 279.16098 122.85901L279.16098 122.85901L279.16 122.86zM507.14 122.86L534.171 122.86C 557.92505 122.86 579.499 132.5709 595.14 148.196C 610.765 163.821 620.476 185.407 620.476 209.16501L620.476 209.16501L620.476 464.175C 620.476 487.929 610.76514 509.503 595.14 525.144C 579.499 540.785 557.929 550.48 534.171 550.48L534.171 550.48L279.161 550.48C 255.40701 550.48 233.83301 540.7691 218.19202 525.144C 202.55103 509.51886 192.85602 487.93298 192.85602 464.175L192.85602 464.175L192.85602 437.14398L165.82501 437.14398C 142.07101 437.14398 120.49701 427.43307 104.85601 411.80798C 89.23101 396.18298 79.52001 374.597 79.52001 350.839L79.52001 350.839L79.52001 95.828995C 79.52001 72.075 89.23091 50.500996 104.85601 34.859993C 120.49701 19.234993 142.06702 9.523993 165.82501 9.523993L165.82501 9.523993L420.83502 9.523993C 444.58902 9.523993 466.16302 19.234894 481.80402 34.859993C 497.445 50.50099 507.14 72.07099 507.14 95.828995zM534.171 159.469L279.161 159.469C 265.52002 159.469 253.087 165.06279 244.08301 174.086C 235.0596 183.1094 229.466 195.524 229.466 209.18L229.466 209.18L229.466 464.19C 229.466 477.831 235.0598 490.264 244.08301 499.284C 253.10641 508.3074 265.521 513.901 279.161 513.901L279.161 513.901L534.171 513.901C 547.831 513.901 560.245 508.3072 569.265 499.284C 578.2884 490.2606 583.882 477.846 583.882 464.19L583.882 464.19L583.882 209.18001C 583.882 195.539 578.2882 183.106 569.265 174.086C 560.24164 165.06259 547.827 159.469 534.171 159.469z" stroke="none" fill="#000000" fill-rule="nonzero" />
			</g>
		</g>
	</g>
</svg>`, TEXT_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="12" height="12">
  <g transform="matrix(0.6315789 0 0 0.6315789 0 0)">
    <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
      <g>
        <path d="M84 32.48L616 32.48L616 92.96L84 92.96L84 32.48z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M84 177.52L470.4 177.52L470.4 238L84 238L84 177.52z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M84 322.56L616 322.56L616 383.04L84 383.04L84 322.56z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M84 467.6L470.4 467.6L470.4 528.08L84 528.08L84 467.6z" stroke="none" fill="#000000" fill-rule="nonzero" />
      </g>
    </g>
  </g>
</svg>`;
var DEFAULT_COLUMN_TYPES = /* @__PURE__ */ ((F) => (F.TEXT = "Text", F.NUMBER = "Number", F.CURRENCY = "Currency", F.DATE_DMY = "Date d-m-y", F.DATE_MDY = "Date m-d-y", F.CHECKBOX = "Checkbox", F.SELECT = "Select", F.LABEL = "Label", F))(DEFAULT_COLUMN_TYPES || {});
const _CalendarFunctionalityUtils = class {
  static mdYCellTextToYMD(F) {
    const x = RegexUtils.extractIntegerStrs(F);
    return [x[2], x[0], x[1]];
  }
  static yMDToMDYCellText(F) {
    return [F[1], F[2], F[0]].join("-");
  }
  static dMYCellTextToYMD(F) {
    const x = RegexUtils.extractIntegerStrs(F);
    return [x[2], x[1], x[0]];
  }
  static yMDToDMYCellText(F) {
    return [F[2], F[1], F[0]].join("-");
  }
};
_CalendarFunctionalityUtils.DEFAULT_TYPES_FUNCTIONALITY = {
  [DEFAULT_COLUMN_TYPES.DATE_DMY]: {
    toYMDFunc: (F) => _CalendarFunctionalityUtils.dMYCellTextToYMD(F),
    fromYMDFunc: (F) => _CalendarFunctionalityUtils.yMDToDMYCellText(F)
  },
  [DEFAULT_COLUMN_TYPES.DATE_MDY]: {
    toYMDFunc: (F) => _CalendarFunctionalityUtils.mdYCellTextToYMD(F),
    fromYMDFunc: (F) => _CalendarFunctionalityUtils.yMDToMDYCellText(F)
  }
};
let CalendarFunctionalityUtils = _CalendarFunctionalityUtils;
const _Validation = class {
  static setSelectValidation(F, x, w) {
    var O, D;
    if (!((O = F.cellDropdownProps) != null && O.options) || (D = F.cellDropdownProps) != null && D.canAddMoreOptions)
      return;
    const U = new Set(F.cellDropdownProps.options.map((W) => W.text));
    F.textValidation ?? (F.textValidation = {}), F.textValidation.func = (W) => !!U.has(W) || !x && W === w;
  }
};
_Validation.DEFAULT_TYPES_REGEX = {
  [DEFAULT_COLUMN_TYPES.CURRENCY]: new RegExp(
    // eslint-disable-next-line max-len
    /^(([$€£¥]\s*?-?(([1-9]\d{0,2}(,\d{3})*)|\d+)?(\.\d{1,2})?)|(-?(([1-9]\d{0,2}(,\d{3})*)|\d+)?(\.\d{1,2})?\s*?[$€£¥]))$/
  ),
  // \s*? is used to allow spaces between symbols
  [DEFAULT_COLUMN_TYPES.DATE_DMY]: new RegExp(
    /^(0?[1-9]|[12][0-9]|3[01])\s*?[/-]\s*?(0?[1-9]|1[012])\s*?[/-]\s*?\d{4}$/
  ),
  [DEFAULT_COLUMN_TYPES.DATE_MDY]: new RegExp(
    /^(0?[1-9]|1[012])\s*?[/-]\s*?(0?[1-9]|[12][0-9]|3[01])\s*?[/-]\s*?\d{4}$/
  )
};
_Validation.DEFAULT_TYPES_FUNCTIONALITY = {
  [DEFAULT_COLUMN_TYPES.NUMBER]: (F) => F !== EMPTY_STRING && !isNaN(F),
  [DEFAULT_COLUMN_TYPES.CURRENCY]: (F) => _Validation.DEFAULT_TYPES_REGEX[DEFAULT_COLUMN_TYPES.CURRENCY].test(F),
  [DEFAULT_COLUMN_TYPES.DATE_DMY]: (F) => _Validation.DEFAULT_TYPES_REGEX[DEFAULT_COLUMN_TYPES.DATE_DMY].test(F),
  [DEFAULT_COLUMN_TYPES.DATE_MDY]: (F) => _Validation.DEFAULT_TYPES_REGEX[DEFAULT_COLUMN_TYPES.DATE_MDY].test(F)
};
let Validation = _Validation;
class CellElementIndex {
  static getViaColumnIndex(x, w) {
    const O = Number(w);
    return x * 2 + O;
  }
}
const _Sort = class Bt {
  static extractNumberFromString(x) {
    const w = RegexUtils.extractFloatStrs(x);
    return w && w.length > 0 ? Number(w[0]) : 0;
  }
  // cannot safely identify if nothing has been changed, hence need to send out an update for all cells
  // prettier-ignore
  static update(x, w) {
    const { _tableBodyElementRef: O, _frameComponents: { displayIndexColumn: D }, data: U } = x, W = O.children;
    w.forEach((X, G) => {
      const Y = G + 1, K = W[Y].children;
      X.forEach((Z, q) => {
        const J = CellElementIndex.getViaColumnIndex(q, !!D), ee = K[J];
        CellEvents.updateCell(
          x,
          Z,
          Y,
          q,
          { processText: !1, element: ee, updateTableEvent: !1, updateData: !1 }
        ), ColumnTypesUtils.updateDataElements(x, G, q, ee);
      });
    }), U.splice(1, w.length, ...w), setTimeout(() => FireEvents.onDataUpdate(x));
  }
  static sortStringsColumnAscending(x, w) {
    x.sort((O, D) => String(O[w]).localeCompare(String(D[w])));
  }
  static sortStringsColumnDescending(x, w) {
    x.sort((O, D) => String(D[w]).localeCompare(String(O[w])));
  }
  static sortStrings(x, w, O) {
    O ? Bt.sortStringsColumnAscending(x, w) : Bt.sortStringsColumnDescending(x, w);
  }
  // prettier-ignore
  static parseComparedText(x, w, O, D) {
    const U = D(x);
    if (U === void 0)
      return O ? 1 : -1;
    const W = D(w);
    return W === void 0 ? O ? -1 : 1 : [U, W];
  }
  static validateType(x, w) {
    return x === void 0 || x(w) ? w : void 0;
  }
  // prettier-ignore
  static validateAndSort(x, w, O, D, U) {
    const W = Bt.parseComparedText(x, w, U, Bt.validateType.bind(this, D));
    return typeof W == "number" ? W : (U ? O.ascendingFunc : O.descendingFunc)(W[0], W[1]);
  }
  static sortViaSortFuncs(x, w, O, D) {
    const { sorting: U, textValidation: W } = x;
    U && w.sort(
      (X, G) => Bt.validateAndSort(X[O], G[O], U, W.func, D)
    );
  }
  static compareDates(x, w) {
    return new Date(...x) - new Date(...w);
  }
  static parseYMDFormat(x, w, O) {
    return Bt.validateType(x, O) ? w.toYMDFunc(O) : void 0;
  }
  // prettier-ignore
  static sortDates(x, w, O, D) {
    const { calendar: U, textValidation: W } = x;
    U && w.sort((X, G) => {
      const Y = Bt.parseComparedText(
        X[O],
        G[O],
        !0,
        Bt.parseYMDFormat.bind(this, W.func, U)
      );
      return typeof Y == "number" ? Y : D ? Bt.compareDates(Y[0], Y[1]) : Bt.compareDates(Y[1], Y[0]);
    });
  }
  static sortColumn(x, w, O) {
    const D = x.data.slice(1), { activeType: U } = x._columnsDetails[w];
    U.calendar ? Bt.sortDates(U, D, w, O) : U.sorting ? Bt.sortViaSortFuncs(U, D, w, O) : Bt.sortStrings(D, w, O), Bt.update(x, D);
  }
};
_Sort.DEFAULT_TYPES_SORT_FUNCS = {
  [DEFAULT_COLUMN_TYPES.NUMBER]: {
    ascendingFunc: (F, x) => Number(F) - Number(x),
    descendingFunc: (F, x) => Number(x) - Number(F)
  },
  [DEFAULT_COLUMN_TYPES.CURRENCY]: {
    ascendingFunc: (F, x) => _Sort.extractNumberFromString(F) - _Sort.extractNumberFromString(x),
    descendingFunc: (F, x) => _Sort.extractNumberFromString(x) - _Sort.extractNumberFromString(F)
  }
};
let Sort = _Sort;
const _DefaultColumnTypes = class qr {
  // REF-28
  static createDropdownItemsForDefaultTypes() {
    qr.DEFAULT_TYPES.forEach((x) => {
      const w = {
        text: x.name,
        iconSettings: x.iconSettings || DropdownButtonItemConf.DEFAULT_ITEM.iconSettings
      };
      x.dropdownItem = {
        element: DropdownItem.createButtonItemNoEvents(void 0, w),
        settings: w
      };
    });
  }
};
_DefaultColumnTypes.FALLBACK_TYPE = {
  name: DEFAULT_COLUMN_TYPES.TEXT,
  iconSettings: {
    svgString: TEXT_ICON_SVG_STRING,
    containerStyles: {
      dropdown: { marginLeft: "-0.25px", marginRight: "6px", marginTop: "2.5px" },
      headerCorrections: { marginTop: "2.5px" }
    }
  }
};
_DefaultColumnTypes.DEFAULT_TYPES = [
  _DefaultColumnTypes.FALLBACK_TYPE,
  {
    name: DEFAULT_COLUMN_TYPES.NUMBER,
    textValidation: { func: Validation.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.NUMBER] },
    sorting: Sort.DEFAULT_TYPES_SORT_FUNCS[DEFAULT_COLUMN_TYPES.NUMBER],
    iconSettings: {
      svgString: NUMBER_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginLeft: "-1px", marginRight: "4.5px", marginTop: "2px" },
        headerCorrections: { marginTop: "2.5px" }
      }
    }
  },
  {
    name: DEFAULT_COLUMN_TYPES.CURRENCY,
    textValidation: { func: Validation.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.CURRENCY] },
    sorting: Sort.DEFAULT_TYPES_SORT_FUNCS[DEFAULT_COLUMN_TYPES.CURRENCY],
    iconSettings: {
      svgString: CURRENCY_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginLeft: "-2px", marginRight: "4px", marginTop: "1px" },
        headerCorrections: { marginRight: "3px", marginTop: "2px" }
      }
    }
  },
  {
    name: DEFAULT_COLUMN_TYPES.SELECT,
    select: {},
    iconSettings: {
      svgString: SELECT_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginTop: "0px", marginRight: "3px", marginLeft: "-2.75px" },
        headerCorrections: { marginTop: "1px" }
      }
    }
  },
  {
    name: DEFAULT_COLUMN_TYPES.LABEL,
    label: {},
    iconSettings: {
      svgString: LABEL_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginTop: "1.5px", marginRight: "5.5px", marginLeft: "-1px" },
        headerCorrections: { marginTop: "2.5px", marginRight: "5.5px", marginLeft: "0px" }
      }
    }
  },
  {
    name: DEFAULT_COLUMN_TYPES.CHECKBOX,
    iconSettings: {
      svgString: CHECKBOX_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginRight: "6px", marginTop: "2px" },
        headerCorrections: { marginRight: "5px", marginLeft: "1px", marginTop: "3px" }
      }
    },
    checkbox: !0,
    customTextProcessing: {
      changeTextFunc: CheckboxValidationFunc.getDefault()
    }
  },
  {
    name: DEFAULT_COLUMN_TYPES.DATE_DMY,
    textValidation: { func: Validation.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.DATE_DMY] },
    calendar: CalendarFunctionalityUtils.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.DATE_DMY],
    iconSettings: {
      svgString: CALENDAR_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginLeft: "1.25px", marginRight: "8px", marginTop: "-1.5px" },
        headerCorrections: { marginTop: "0px" }
      }
    }
  },
  {
    name: DEFAULT_COLUMN_TYPES.DATE_MDY,
    textValidation: { func: Validation.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.DATE_MDY] },
    calendar: CalendarFunctionalityUtils.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.DATE_MDY],
    iconSettings: {
      svgString: CALENDAR_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginLeft: "1.25px", marginRight: "8px", marginTop: "-1.5px" },
        headerCorrections: { marginTop: "0px" }
      }
    }
  }
];
let DefaultColumnTypes = _DefaultColumnTypes;
class DropdownButtonItemConf {
}
DropdownButtonItemConf.DEFAULT_ITEM = {
  text: DefaultColumnTypes.FALLBACK_TYPE.name,
  iconSettings: DefaultColumnTypes.FALLBACK_TYPE.iconSettings
};
class ColumnTypesUtils {
  static getTypeByName(x, w) {
    return x.find((O) => O.name.toLocaleLowerCase() === w?.toLocaleLowerCase());
  }
  static getTypeBasedOnProperties(x, w) {
    if (w) {
      const O = ColumnTypesUtils.getTypeByName(x.types, w);
      if (O)
        return O;
    }
    if (x.defaultColumnTypeName) {
      const O = ColumnTypesUtils.getTypeByName(x.types, x.defaultColumnTypeName);
      if (O)
        return O;
    }
  }
  static getActiveType(x, w) {
    const O = ColumnTypesUtils.getTypeBasedOnProperties(x, w);
    if (O)
      return O;
    const D = x.types.find((W) => !W.textValidation.func);
    return D || x.types[0] || DefaultColumnTypes.FALLBACK_TYPE;
  }
  // prettier-ignore
  static getReusableDefaultIcon(x) {
    var w;
    const O = (w = x.reusableIconName) == null ? void 0 : w.toLocaleLowerCase(), D = DefaultColumnTypes.DEFAULT_TYPES.find((U) => U.name.toLocaleLowerCase() === O);
    return D != null && D.iconSettings ? D.iconSettings : DropdownButtonItemConf.DEFAULT_ITEM.iconSettings;
  }
  static processDropdownItemSettings(x) {
    const { name: w, iconSettings: O } = x;
    let D;
    O ? O.reusableIconName ? D = ColumnTypesUtils.getReusableDefaultIcon(O) : (D = O, Object.keys(O).length === 0 ? D = DropdownButtonItemConf.DEFAULT_ITEM.iconSettings : O.svgString || (D.svgString ?? (D.svgString = DropdownButtonItemConf.DEFAULT_ITEM.iconSettings.svgString), D.containerStyles ?? (D.containerStyles = DropdownButtonItemConf.DEFAULT_ITEM.iconSettings.containerStyles))) : D = DropdownButtonItemConf.DEFAULT_ITEM.iconSettings;
    const U = { text: w, iconSettings: D }, W = x;
    W.dropdownItem ?? (W.dropdownItem = { element: null, settings: U }), setTimeout(() => {
      var X;
      (X = W.dropdownItem).element ?? (X.element = DropdownItem.createButtonItemNoEvents(void 0, U));
    });
  }
  static processTextValidationProps(x) {
    var w;
    x.textValidation ?? (x.textValidation = {}), (w = x.textValidation).setTextToDefaultOnFail ?? (w.setTextToDefaultOnFail = !0);
  }
  static processCheckbox(x) {
    var w;
    x.checkbox && !((w = x.customTextProcessing) != null && w.changeTextFunc) && (x.customTextProcessing ?? (x.customTextProcessing = {}), x.customTextProcessing.changeTextFunc = CheckboxValidationFunc.getDefault());
  }
  static processSelectOptions(x) {
    if (typeof x.select == "object" && x.select.options) {
      const w = x.select;
      w.options = x.select.options.map((O) => ({ text: O }));
    } else if (typeof x.label == "object" && x.label.options) {
      const w = x.label;
      w.options = JSON.parse(JSON.stringify(x.label.options));
    }
  }
  static processSelect(x, w, O) {
    var D;
    const U = x;
    x.select === !0 || x.label === !0 ? U.cellDropdownProps = { isBasicSelect: !x.label } : (typeof x.select == "object" || typeof x.label == "object") && (U.cellDropdownProps = x.select || x.label, U.cellDropdownProps.isBasicSelect = !x.label, ColumnTypesUtils.processSelectOptions(x), Validation.setSelectValidation(U, w, O)), U.cellDropdownProps && U.cellDropdownProps.canAddMoreOptions === void 0 && (U.cellDropdownProps.canAddMoreOptions = !((D = U.cellDropdownProps) != null && D.options));
  }
  // the reason why this is needed is when the argument is JSON stringified, properties that hold functions are removed,
  // hence they can only be applied to the component as strings
  static convertStringFunctionsToRealFunctions(x) {
    x.textValidation && ObjectUtils.convertStringToFunction(x.textValidation, "func"), x.customTextProcessing && (ObjectUtils.convertStringToFunction(x.customTextProcessing, "changeTextFunc"), ObjectUtils.convertStringToFunction(x.customTextProcessing, "changeStyleFunc")), x.sorting && (ObjectUtils.convertStringToFunction(x.sorting, "ascendingFunc"), ObjectUtils.convertStringToFunction(x.sorting, "descendingFunc")), x.calendar && (ObjectUtils.convertStringToFunction(x.calendar, "toYMDFunc"), ObjectUtils.convertStringToFunction(x.calendar, "fromYMDFunc"));
  }
  // this is important because when types get processed - their resultant structure is not be the same, hence if
  // the same one is used in different settings (e.g. defaultColumnTypes set in default and custom settings),
  // the processing of the same type again would not work
  // JSON.stringify loses element and function references, hence they need to be manually reassigned
  static createTypeDeepCopy(x) {
    const w = JSON.parse(JSON.stringify(x));
    return x.dropdownItem && (w.dropdownItem = x.dropdownItem), x.textValidation && (w.textValidation = x.textValidation), x.customTextProcessing && (w.customTextProcessing = x.customTextProcessing), x.sorting && (w.sorting = x.sorting), x.calendar && (w.calendar = x.calendar), w;
  }
  static process(x, w, O) {
    return x.map((D) => {
      const U = ColumnTypesUtils.createTypeDeepCopy(D);
      return ColumnTypesUtils.convertStringFunctionsToRealFunctions(U), ColumnTypesUtils.processSelect(U, w, O), ColumnTypesUtils.processCheckbox(U), ColumnTypesUtils.processTextValidationProps(U), ColumnTypesUtils.processDropdownItemSettings(U), U;
    });
  }
  static getAvailableTypes(x) {
    let w = [...DefaultColumnTypes.DEFAULT_TYPES];
    const { availableDefaultColumnTypes: O, customColumnTypes: D } = x;
    if (O) {
      const U = O.map((W) => W.toLocaleLowerCase());
      w = w.filter((W) => U.indexOf(W.name.toLocaleLowerCase()) > -1);
    }
    return D && w.push(...D), w.length === 0 && w.push(DefaultColumnTypes.FALLBACK_TYPE), w;
  }
  static getProcessedTypes(x) {
    const { isDefaultTextRemovable: w, defaultText: O } = x, D = ColumnTypesUtils.getAvailableTypes(x);
    return ColumnTypesUtils.process(D, w, O);
  }
  // updates label color, date input etc.
  // prettier-ignore
  static updateDataElements(x, w, O, D) {
    const { _columnsDetails: U, _tableDimensions: W } = x, X = U[O];
    w !== 0 && (X.activeType.cellDropdownProps ? (CellDropdown.updateCellDropdown(
      D,
      X.cellDropdown,
      W.border,
      X.settings.defaultText,
      !0
    ), SelectCell.finaliseEditedText(x, D.children[0], O, !0)) : Browser.IS_INPUT_DATE_SUPPORTED && X.activeType.calendar && DateCellInputElement.updateInputBasedOnTextDiv(D, X.activeType));
  }
}
class MoveUtils {
  // prettier-ignore
  static setNewElementText(x, w, O, D, U) {
    const W = CellElement.getText(O);
    return CellEvents.updateCell(x, w, U, D, { element: O, processText: !1 }), ColumnTypesUtils.updateDataElements(x, U, D, O), W;
  }
}
class MoveColumn {
  // prettier-ignore
  static overwriteDataElements(x, w, O, D) {
    w.slice(1).forEach((U, W) => {
      const X = W + 1, G = D[X];
      MoveUtils.setNewElementText(x, G, U, O, X);
    });
  }
  // prettier-ignore
  static changeSettings(x, w, O, D, U) {
    HeaderText.onAttemptChange(x, O, w, { colMove: !0 }), U !== D.activeType && ChangeColumnType.change.bind(x)(U.name, w);
  }
  // prettier-ignore
  static overwrite(x, w, O, D, U, W) {
    const { elements: X, activeType: G } = w;
    MoveUtils.setNewElementText(x, D[0], X[0], O, 0), MoveColumn.changeSettings(x, O, X[0], w, U), MoveColumn.overwriteDataElements(x, X, O, D);
    const Y = X[0].style.width;
    return X[0].style.width = W, { overwrittenType: G, overwrittenWidth: Y };
  }
  static firstChangeSettingsIfSettingsChanged(x, w) {
    const { areSettingsDifferent: O } = ColumnSettingsUtils.parseSettingsChange(x);
    if (O) {
      const D = x._columnsDetails[w];
      HeaderText.onAttemptChange(x, D.elements[0], w);
    }
  }
  // prettier-ignore
  static move(x, w, O) {
    MoveColumn.firstChangeSettingsIfSettingsChanged(x, w);
    const D = x._columnsDetails[w], U = x._columnsDetails[w].elements.map((Z) => CellElement.getText(Z));
    CellHighlightUtils.fade(D.elements[0], D?.headerStateColors.default);
    const W = O ? w + 1 : w - 1, X = x._columnsDetails[W], G = X.elements.map((Z) => CellElement.getText(Z)), Y = X.elements[0].style.width, K = MoveColumn.overwrite(
      x,
      D,
      w,
      G,
      X.activeType,
      Y
    );
    FocusedCellUtils.set(x._focusedElements.cell, X.elements[0], 0, W), MoveColumn.overwrite(
      x,
      X,
      W,
      U,
      K.overwrittenType,
      K.overwrittenWidth
    ), setTimeout(() => FireEvents.onColumnsUpdate(x));
  }
}
class ColumnSizerGenericUtils {
  // the current solution for using first row position as 'relative' with divider having 100% height only works for
  // these browsers
  static canHeightBeInherited() {
    return Browser.IS_CHROMIUM || Browser.IS_FIREFOX;
  }
  static getSizerDetailsViaElementId(x, w) {
    const O = Number(RegexUtils.extractIntegerStrs(x)[0]), D = w[O];
    return { columnSizer: D.columnSizer, headerCell: D.elements[0], sizerNumber: O };
  }
  static findNextResizableColumnHeader(x, w) {
    const O = x.slice(w + 1).find((D) => {
      var U;
      return !((U = D.settings.widths) != null && U.staticWidth);
    });
    return O?.elements[0];
  }
}
const _UpdateRowElement = class yr {
  // required to allow the divider and all its elements to inherit its height (in non chrome or firefox browsers)
  static updateHeaderRowHeight(x) {
    ColumnSizerGenericUtils.canHeightBeInherited() || (x.style.height = yr.UNSET, x.style.height = getComputedStyle(x).height);
  }
  // if this does not capture all events - use in HeaderText.onAttemptChange method instead
  static updateHeadRowHeightOnKeyDown(x) {
    var w;
    if (!ColumnSizerGenericUtils.canHeightBeInherited()) {
      const O = (w = x.children) == null ? void 0 : w[0];
      O && O.style.height !== yr.UNSET && (O.style.height = yr.UNSET, setTimeout(() => {
        O.style.height = `${O.offsetHeight}px`;
      }));
    }
  }
  static getUnsetHeightFunc(x, w) {
    if (!ColumnSizerGenericUtils.canHeightBeInherited() && w === 0)
      return () => x.style.height = yr.UNSET;
  }
};
_UpdateRowElement.UNSET = "unset";
let UpdateRowElement = _UpdateRowElement;
class RowHoverEvents {
  static canStyleBeApplied(x, w, O) {
    return (O > 0 || x.header) && (!AddNewRowElement.isAddNewRowRow(w) || x.addNewRowButton);
  }
  static getRemoveColorFunc(x, w, O, D) {
    const U = x.rowHoverStyles;
    if (U != null && U.style && RowHoverEvents.canStyleBeApplied(U, w, O))
      return () => {
        ElementStyle.unsetStyle(w, U.style), Object.assign(w.style, D);
      };
  }
  static addMouseLeaveEvent(x, w, O, D) {
    const U = RowHoverEvents.getRemoveColorFunc(x, w, O, D), W = UpdateRowElement.getUnsetHeightFunc(w, O);
    w.onmouseleave = () => {
      U?.(), W?.();
    };
  }
  // prettier-ignore
  static addMouseEnterEvent(x, w, O) {
    const { rowHoverStyles: D, _focusedElements: { rowDragEl: U } } = x, W = D != null && D.style && RowHoverEvents.canStyleBeApplied(D, w, O) ? () => Object.assign(w.style, D?.style) : void 0;
    w.onmouseenter = () => {
      U || W == null || W();
    };
  }
  static addEvents(x, w, O, D) {
    RowHoverEvents.addMouseEnterEvent(x, w, O), RowHoverEvents.addMouseLeaveEvent(x, w, O, D);
  }
  static process(x, w) {
    x != null && x.style && (x.header ?? (x.header = !0), x.addNewRowButton ?? (x.addNewRowButton = !0), CellHighlightUtils.unsetDefaultHoverProperties(w));
  }
}
const _StripedRows = class Or {
  static setRowStyle(x, w, O) {
    const D = w % 2 ? O.even : O.odd;
    return Object.assign(x.style, D), D;
  }
  static process(x) {
    const { stripedRows: w, _defaultCellHoverColors: O } = x;
    w && (typeof w == "boolean" ? x._stripedRows = Or.DEFAULT_PROPERTIES : x._stripedRows = {
      even: w.even || Or.DEFAULT_PROPERTIES.even,
      odd: w.odd || Or.DEFAULT_PROPERTIES.odd
    }, CellHighlightUtils.unsetDefaultHoverProperties(O));
  }
};
_StripedRows.DEFAULT_PROPERTIES = {
  odd: { backgroundColor: "" },
  even: { backgroundColor: "#dcdcdc7a" }
};
let StripedRows = _StripedRows;
class CustomRowProperties {
  static setStyle(x, w, O, D) {
    if (x._stripedRows)
      return D && AddNewRowElement.isAddNewRowRow(w) && (O = +!x.dataStartsAtHeader), StripedRows.setRowStyle(w, O, x._stripedRows);
  }
  // prettier-ignore
  static updateRow(x, w, O, D, U) {
    const W = CustomRowProperties.setStyle(x, w, O, D);
    O === U ? RowHoverEvents.addEvents(x, w, O, W) : setTimeout(() => {
      RowHoverEvents.addEvents(x, w, O, W);
    });
  }
  // REF-32
  static isAddRowRowSame(x) {
    return !!(x.pagination && x._frameComponents.displayAddNewRow && PaginationUtils.getLastPossiblePageNumber(x) !== x._pagination.activePageNumber);
  }
  // this can be considered to be wasteful if no striped rows are used and we are resetting the same row events
  // every time this is called, however we are still traversing all rows from startIndex for code simplicity
  static update(x, w = 0) {
    if (!x._tableBodyElementRef)
      return;
    const O = Array.from(x._tableBodyElementRef.children), D = CustomRowProperties.isAddRowRowSame(x), U = O.length - 1;
    O.slice(w).forEach((W, X) => {
      const G = X + w;
      CustomRowProperties.updateRow(x, W, G, D, U);
    });
  }
}
class MoveRow {
  // prettier-ignore
  static overwrite(x, w, O) {
    const D = [];
    return x._columnsDetails.forEach((U, W) => {
      const X = MoveUtils.setNewElementText(
        x,
        w[W],
        U.elements[O],
        W,
        O
      );
      D.push(X);
    }), D;
  }
  static moveDataRows(x, w, O) {
    const D = x._columnsDetails.map(({ elements: W }) => CellElement.getText(W[O])), U = MoveRow.overwrite(x, D, w);
    MoveRow.overwrite(x, U, O);
  }
  static resetFocusedCell(x, w) {
    const { _frameComponents: O, _focusedElements: D } = x, { element: U, rowIndex: W, columnIndex: X } = w;
    O.displayIndexColumn ? FocusedCellUtils.setIndexCell(D.cell, U, W) : FocusedCellUtils.set(D.cell, U, W, X);
  }
  static moveHeaderToDataRow(x) {
    const { _columnsDetails: w, _focusedElements: O } = x, D = { ...O.cell }, U = w.map(({ elements: X }) => CellElement.getText(X[1])), W = MoveRow.overwrite(x, U, 0);
    w.forEach((X, G) => {
      FocusedCellUtils.set(O.cell, X.elements[0], 0, G), HeaderText.onAttemptChange(x, X.elements[0], G);
    }), MoveRow.overwrite(x, W, 1), MoveRow.resetFocusedCell(x, D);
  }
  static move(x, w, O) {
    const D = O ? w + 1 : w - 1;
    w === 0 || D === 0 ? MoveRow.moveHeaderToDataRow(x) : MoveRow.moveDataRows(x, w, D), CustomRowProperties.update(x, w), x.pagination && PaginationUtils.updateOnRowMove(x, D);
  }
}
const _Drag = class Jr {
  static move(x, w, O) {
    if (w === 0)
      return;
    const D = w > 0, U = D ? 1 : -1;
    for (let W = 0; W < Math.abs(w); W += 1)
      O(x, Jr.ORIGINAL_INDEX + W * U, D);
    setTimeout(() => FocusedCellUtils.purge(x._focusedElements.cell), 5);
  }
};
_Drag.CELL_HIDDEN_CLASS = "cell-hidden";
_Drag.DRAG_PX_TO_MOVE = 10;
_Drag.ORIGINAL_INDEX = 0;
let Drag = _Drag;
const _DragRow = class Be extends Drag {
  static resetElements(x) {
    var w, O;
    (w = Be.CLONE_ROW) == null || w.remove(), Array.from(x.children || []).forEach((D) => {
      D.classList.remove(Drag.CELL_HIDDEN_CLASS);
    }), (O = Be.TARGET_LINE) == null || O.remove();
  }
  static appendTargetLine(x) {
    Be.TARGET_LINE = document.createElement("div"), Be.TARGET_LINE.classList.add("row-drag-target-line"), Be.TARGET_LINE.style.opacity = "0", x.appendChild(Be.TARGET_LINE);
  }
  static prepareElements(x, w, O) {
    w.classList.add(Be.ROW_CLONE_CLASS), w.style.top = `${O.offsetTop}px`;
    const D = `${O.children[0].offsetHeight}px`, U = Array.from(O.children || []);
    Array.from(w.children).forEach((W, X) => {
      W.style.width = `${U[X].offsetWidth}px`, W.style.height = D;
    }), U.forEach((W) => {
      W.classList.add(Drag.CELL_HIDDEN_CLASS);
    }), Be.appendTargetLine(x);
  }
  static calculateThresholdDown(x) {
    Be.TARGET_DOWN_ROW && x && (Be.THRESHOLD_DOWN = Be.TARGET_DOWN_ROW.offsetTop + Be.TARGET_DOWN_ROW.offsetHeight / 2 - x.offsetHeight);
  }
  static calculateThresholdUp() {
    Be.TARGET_UP_ROW && (Be.THRESHOLD_UP = Be.TARGET_UP_ROW.offsetTop + Be.TARGET_UP_ROW.offsetHeight / 2);
  }
  static initiateDragState(x, w, O) {
    var D;
    if (Be.TARGET_UP_ROW = O.previousSibling, Be.TARGET_DOWN_ROW = (D = O.nextSibling) == null ? void 0 : D.nextSibling, !Be.TARGET_UP_ROW && AddNewRowElement.isAddNewRowRow(Be.TARGET_DOWN_ROW.children[0]))
      return;
    Be.CLONE_ROW = w, Be.ACTIVE_ROW_TOP_PX = O.offsetTop, Be.ACTIVE_INDEX = 0, Be.calculateThresholdUp(), Be.calculateThresholdDown(O);
    const U = Array.from(x.children);
    Drag.ORIGINAL_INDEX = U.findIndex((X) => X === O);
    const W = U[U.length - 2].offsetHeight;
    Be.MAX_DOWN = x.offsetHeight - O.offsetHeight - W;
  }
  static processRowCellsToDrag(x, w) {
    const O = w.parentElement;
    O.dispatchEvent(new MouseEvent("mouseleave"));
    const D = O.cloneNode(!0);
    return O?.insertAdjacentElement("afterend", D), Be.prepareElements(x, D, O), Be.initiateDragState(x, D, O), O;
  }
  static applyEventsToElement(x, w, O) {
    Be.isDisabled(x) || (w.onmousedown = () => {
      Be.IS_MOUSE_DOWN = !0;
    }, w.onmousemove = () => {
      Be.IS_MOUSE_DOWN && !x._focusedElements.rowDragEl && x._tableBodyElementRef && (Be.INITIALISING_DRAG_PX += 1, Be.INITIALISING_DRAG_PX > Drag.DRAG_PX_TO_MOVE && (x._focusedElements.rowDragEl = Be.processRowCellsToDrag(x._tableBodyElementRef, O), FocusedCellUtils.set(x._focusedElements.cell, O, 0, Drag.ORIGINAL_INDEX)));
    });
  }
  static moveTargetLine(x, w) {
    x.style.opacity = "1", x.style.top = `${w}px`;
  }
  // Upon approaching the original row the target line is hidden
  static removeLineOnMoveDown(x) {
    x.style.opacity = "0", Be.ACTIVE_INDEX = 0, Be.THRESHOLD_TO_NO_LINE_DOWN = -1, Be.calculateThresholdUp();
  }
  static attemptSwitchUp(x, w) {
    var O;
    Be.TARGET_UP_ROW && w && (((O = Be.TARGET_UP_ROW.previousSibling) == null ? void 0 : O.previousSibling) === w ? (Be.THRESHOLD_TO_NO_LINE_UP = w.offsetTop + w.offsetHeight / 2, Be.THRESHOLD_DOWN = Be.TARGET_UP_ROW.offsetTop + Be.TARGET_UP_ROW.offsetHeight / 2, Be.TARGET_DOWN_ROW = Be.TARGET_UP_ROW, Be.TARGET_UP_ROW = w.previousSibling, Be.TARGET_UP_ROW ? Be.calculateThresholdUp() : Be.THRESHOLD_UP = -1) : (Be.moveTargetLine(x, Be.TARGET_UP_ROW.offsetTop - 3), Be.THRESHOLD_DOWN = Be.THRESHOLD_UP, Be.TARGET_DOWN_ROW = Be.TARGET_UP_ROW, Be.TARGET_UP_ROW = Be.TARGET_UP_ROW.previousSibling, Be.calculateThresholdUp(), Be.ACTIVE_INDEX -= 1));
  }
  // Upon approaching the original row the target line is hidden
  static removeLineOnMoveUp(x, w) {
    x.style.opacity = "0", Be.ACTIVE_INDEX = 0, Be.THRESHOLD_TO_NO_LINE_UP = -1, Be.calculateThresholdDown(w);
  }
  static attemptSwitchDown(x, w) {
    var O;
    Be.TARGET_DOWN_ROW && (Be.TARGET_DOWN_ROW.nextSibling === w ? (Be.THRESHOLD_TO_NO_LINE_DOWN = Be.TARGET_DOWN_ROW.offsetTop + Be.TARGET_DOWN_ROW.offsetHeight / 2, Be.TARGET_UP_ROW = Be.TARGET_DOWN_ROW, Be.THRESHOLD_UP = Be.TARGET_UP_ROW.offsetTop - Be.TARGET_UP_ROW.offsetHeight / 2, Be.TARGET_DOWN_ROW = (O = w?.nextSibling) == null ? void 0 : O.nextSibling, Be.calculateThresholdDown(w)) : (Be.moveTargetLine(x, Be.TARGET_DOWN_ROW.offsetTop + Be.TARGET_DOWN_ROW.offsetHeight - 3), Be.THRESHOLD_UP = Be.THRESHOLD_DOWN, Be.TARGET_UP_ROW = Be.TARGET_DOWN_ROW, Be.TARGET_DOWN_ROW = Be.TARGET_DOWN_ROW.nextSibling, Be.calculateThresholdDown(w), Be.ACTIVE_INDEX += 1));
  }
  static windowDrag(x, w) {
    if (Be.isDisabled(x) || !Be.TARGET_LINE || !x._focusedElements.rowDragEl || !Be.CLONE_ROW)
      return;
    const O = Math.max(0, Be.ACTIVE_ROW_TOP_PX + w.movementY), D = Math.min(O, Be.MAX_DOWN);
    Be.ACTIVE_ROW_TOP_PX = D, Be.CLONE_ROW.style.top = `${Be.ACTIVE_ROW_TOP_PX}px`, Be.ACTIVE_ROW_TOP_PX > Be.THRESHOLD_DOWN ? Be.attemptSwitchDown(Be.TARGET_LINE, x._focusedElements.rowDragEl) : Be.ACTIVE_ROW_TOP_PX < Be.THRESHOLD_UP ? Be.attemptSwitchUp(Be.TARGET_LINE, x._focusedElements.rowDragEl) : Be.THRESHOLD_TO_NO_LINE_DOWN >= 0 && Be.THRESHOLD_TO_NO_LINE_DOWN < Be.ACTIVE_ROW_TOP_PX ? Be.removeLineOnMoveDown(Be.TARGET_LINE) : Be.THRESHOLD_TO_NO_LINE_UP >= 0 && Be.THRESHOLD_TO_NO_LINE_UP > Be.ACTIVE_ROW_TOP_PX && Be.removeLineOnMoveUp(Be.TARGET_LINE, x._focusedElements.rowDragEl);
  }
  static windowMouseUp(x) {
    Be.IS_MOUSE_DOWN = !1, !Be.isDisabled(x) && x._focusedElements.rowDragEl && (Be.resetElements(x._focusedElements.rowDragEl), delete x._focusedElements.rowDragEl, Be.INITIALISING_DRAG_PX = 0, Be.move(x, Be.ACTIVE_INDEX, MoveRow.move));
  }
  // row dragging is cumbersome when filter/pagination enabled as some rows are hidden
  static isDisabled(x) {
    return x.dragRows === !1 || x.filter || x.pagination;
  }
};
_DragRow.ROW_CLONE_CLASS = "row-clone";
_DragRow.INITIALISING_DRAG_PX = 0;
_DragRow.ACTIVE_ROW_TOP_PX = 0;
_DragRow.CLONE_ROW = null;
_DragRow.IS_MOUSE_DOWN = !1;
_DragRow.ACTIVE_INDEX = 0;
_DragRow.THRESHOLD_UP = 0;
_DragRow.THRESHOLD_DOWN = 0;
_DragRow.MAX_DOWN = 0;
_DragRow.THRESHOLD_TO_NO_LINE_DOWN = -1;
_DragRow.THRESHOLD_TO_NO_LINE_UP = -1;
let DragRow = _DragRow;
const _DragColumn = class nt extends Drag {
  static setHeaderElementsToDefault(x) {
    var w;
    const O = (w = x.parentElement) == null ? void 0 : w.children;
    nt.CLONE_CELLS.forEach((D) => D.remove()), Array.from(O || []).forEach((D) => {
      D.tagName === CellElement.HEADER_TAG && D.classList.remove(Drag.CELL_HIDDEN_CLASS);
    }), nt.DIVIDERS.forEach((D) => {
      D.style.pointerEvents = "";
    });
  }
  static applyCloneHeaderCell(x, w, O, D) {
    w.classList.add(Drag.CELL_HIDDEN_CLASS), x.classList.add(nt.HEADER_CELL_CLONE_CLASS), x.classList.add(nt.HEADER_CELL_CLONE_ANIMATION_CLASS), x.style.left = `${w.offsetLeft}px`, x.style.height = D, O?.insertAdjacentElement("beforebegin", x), nt.CLONE_CELLS.push(x), nt.REAL_CELLS.push(w);
  }
  static getThreshold(x, w) {
    const O = nt.REAL_CELLS[nt.ACTIVE_INDEX + w], D = Math.min(x.offsetWidth / 2, O?.offsetWidth / 2) * w;
    return x.offsetLeft + D;
  }
  static initiateDragState(x, w) {
    if (nt.ACTIVE_INDEX = nt.REAL_CELLS.findIndex((X) => w === X), nt.ACTIVE_INDEX + 2 >= nt.CLONE_CELLS.length && nt.ACTIVE_INDEX - 1 <= 0)
      return;
    x._focusedElements.colDragEl = nt.CLONE_CELLS[nt.ACTIVE_INDEX], x._focusedElements.colDragEl.classList.remove(nt.HEADER_CELL_CLONE_ANIMATION_CLASS), nt.ACTIVE_CELL_LEFT_PX = w.offsetLeft, nt.THRESHOLD_LEFT = nt.getThreshold(w, -1), nt.THRESHOLD_RIGHT = nt.getThreshold(w, 1);
    const O = nt.REAL_CELLS[0];
    nt.MIN_LEFT = O.classList.contains(IndexColumn.INDEX_CELL_CLASS) ? O.offsetWidth : 0;
    const D = nt.REAL_CELLS[nt.REAL_CELLS.length - 1], U = D.classList.contains(AddNewColumnElement.ADD_COLUMN_CELL_CLASS) ? 0 : D.offsetWidth;
    nt.MAX_LEFT = D.offsetLeft + U - w.offsetWidth;
    const W = nt.REAL_CELLS[0].classList.contains(IndexColumn.INDEX_CELL_CLASS);
    Drag.ORIGINAL_INDEX = nt.ACTIVE_INDEX - (W ? 1 : 0);
  }
  static processHeaderCellsToDrag(x, w, O) {
    var D;
    const U = `${w.offsetHeight}px`;
    Array.from(((D = w.parentElement) == null ? void 0 : D.children) || []).forEach((W) => {
      if (W.tagName === CellElement.HEADER_TAG) {
        const X = W.cloneNode(!0);
        nt.applyCloneHeaderCell(X, W, O, U);
      } else
        W.style.pointerEvents = "none", nt.DIVIDERS.push(W);
    }), nt.initiateDragState(x, w);
  }
  static applyEventsToElement(x, w, O) {
    x.dragColumns !== !1 && (w.onmousedown = () => {
      nt.IS_MOUSE_DOWN = !0;
    }, w.onmousemove = () => {
      var D;
      if (nt.IS_MOUSE_DOWN && !x._focusedElements.colDragEl && (nt.INITIALISING_DRAG_PX += 1, nt.INITIALISING_DRAG_PX > Drag.DRAG_PX_TO_MOVE)) {
        const U = (D = O.parentElement) == null ? void 0 : D.children[O.parentElement.children.length - 1];
        nt.processHeaderCellsToDrag(x, O, U), FocusedCellUtils.set(x._focusedElements.cell, O, 0, Drag.ORIGINAL_INDEX);
      }
    });
  }
  static switch(x) {
    const w = nt.CLONE_CELLS[nt.ACTIVE_INDEX], O = nt.CLONE_CELLS[nt.ACTIVE_INDEX + x];
    x > 0 ? (nt.THRESHOLD_LEFT = nt.THRESHOLD_RIGHT - 5, nt.THRESHOLD_RIGHT = w.offsetLeft + O.offsetWidth, O.style.left = `${O.offsetLeft - w.offsetWidth}px`) : (nt.THRESHOLD_RIGHT = nt.THRESHOLD_LEFT + 5, nt.THRESHOLD_LEFT = w.offsetLeft - O.offsetWidth, O.style.left = `${O.offsetLeft + w.offsetWidth}px`), ArrayUtils.swap(nt.CLONE_CELLS, nt.ACTIVE_INDEX, nt.ACTIVE_INDEX + x), nt.ACTIVE_INDEX += x;
  }
  static windowDrag(x, w, O) {
    if (x.dragColumns === !1)
      return;
    const D = Math.max(nt.MIN_LEFT, nt.ACTIVE_CELL_LEFT_PX + O.movementX), U = Math.min(D, nt.MAX_LEFT);
    nt.ACTIVE_CELL_LEFT_PX = U, w.style.left = `${nt.ACTIVE_CELL_LEFT_PX}px`, nt.ACTIVE_CELL_LEFT_PX > nt.THRESHOLD_RIGHT ? nt.switch(1) : nt.ACTIVE_CELL_LEFT_PX < nt.THRESHOLD_LEFT && nt.switch(-1);
  }
  static windowMouseUp(x) {
    if (nt.IS_MOUSE_DOWN = !1, x.dragColumns === !1 || !x._focusedElements.colDragEl)
      return;
    nt.setHeaderElementsToDefault(x._focusedElements.colDragEl), delete x._focusedElements.colDragEl, nt.INITIALISING_DRAG_PX = 0, nt.ACTIVE_CELL_LEFT_PX = 0, nt.CLONE_CELLS = [], nt.DIVIDERS = [];
    const w = nt.REAL_CELLS[0].classList.contains(IndexColumn.INDEX_CELL_CLASS);
    DragRow.move(x, nt.ACTIVE_INDEX - Drag.ORIGINAL_INDEX - (w ? 1 : 0), MoveColumn.move), nt.REAL_CELLS = [];
  }
};
_DragColumn.HEADER_CELL_CLONE_CLASS = "header-cell-clone";
_DragColumn.HEADER_CELL_CLONE_ANIMATION_CLASS = "header-cell-clone-animation";
_DragColumn.INITIALISING_DRAG_PX = 0;
_DragColumn.ACTIVE_CELL_LEFT_PX = 0;
_DragColumn.IS_MOUSE_DOWN = !1;
_DragColumn.CLONE_CELLS = [];
_DragColumn.REAL_CELLS = [];
_DragColumn.DIVIDERS = [];
_DragColumn.ACTIVE_INDEX = 0;
_DragColumn.THRESHOLD_RIGHT = 0;
_DragColumn.THRESHOLD_LEFT = 0;
_DragColumn.MAX_LEFT = 0;
_DragColumn.MIN_LEFT = 0;
let DragColumn = _DragColumn;
class DropdownCellOverlay {
}
DropdownCellOverlay.HIDDEN_PX = "0px";
DropdownCellOverlay.VISIBLE_PX = "10px";
DropdownCellOverlay.DROPDOWN_CELL_OVERLAY_CLASS = "dropdown-cell-overlay";
const _ColumnDropdownCellOverlay = class er {
  static setDefault(x, w) {
    var O;
    x.style.backgroundColor = ((O = w?.default) == null ? void 0 : O.backgroundColor) || "";
  }
  static resetDefaultColor(x, w) {
    var O;
    const D = w?.overlayStyles;
    (O = D?.hover) != null && O.backgroundColor && er.setDefault(x, D);
  }
  static setHoverColor(x, w) {
    var O, D;
    const U = (D = (O = w?.overlayStyles) == null ? void 0 : O.hover) == null ? void 0 : D.backgroundColor;
    U && (x.columnDropdownCellOverlay.style.backgroundColor = U);
  }
  static hide(x, w) {
    const { columnDropdownCellOverlay: O } = w, D = x._hoveredElements.headerCell;
    setTimeout(() => {
      D !== x._hoveredElements.headerCell && (O.style.height = DropdownCellOverlay.HIDDEN_PX);
    });
  }
  static setHorizontalDimensions(x) {
    const { columnDropdownCellOverlay: w, elements: O } = x, D = O[0].offsetWidth / 100;
    w.style.width = `${D * 50}px`, w.style.right = `${D * 25}px`;
  }
  static display(x) {
    x.columnDropdownCellOverlay.style.height = DropdownCellOverlay.VISIBLE_PX, er.setHorizontalDimensions(x);
  }
  static isDisplayed(x) {
    return x.style.height === DropdownCellOverlay.VISIBLE_PX;
  }
  static updateIfDisplayed(x) {
    er.isDisplayed(x.columnDropdownCellOverlay) && er.setHorizontalDimensions(x);
  }
  static create(x, w, O) {
    const D = document.createElement("div");
    return D.classList.add(DropdownCellOverlay.DROPDOWN_CELL_OVERLAY_CLASS), D.classList.add(er.COLUMN_DROPDOWN_CELL_OVERLAY_CLASS), D.style.height = DropdownCellOverlay.HIDDEN_PX, er.setDefault(D, O), DragColumn.applyEventsToElement(x, D, w), D;
  }
  static add(x, w) {
    var O, D;
    const U = (D = (O = x._defaultColumnsSettings.columnDropdown) == null ? void 0 : O.displaySettings) == null ? void 0 : D.overlayStyles, W = x._columnsDetails[w].elements[0], X = er.create(x, W, U);
    return W.nextSibling.appendChild(X), X;
  }
};
_ColumnDropdownCellOverlay.COLUMN_DROPDOWN_CELL_OVERLAY_CLASS = "column-dropdown-cell-overlay";
let ColumnDropdownCellOverlay = _ColumnDropdownCellOverlay;
const _MovableColumnSizerElement = class Zt {
  // this is recalculated as it depends on the column index that the sizer is on
  static setStaticProperties(x, w, O) {
    x.style.marginRight = w, x.style.width = O;
  }
  // the vertical line has no pointer events, hence it should not be expected to be passed in here
  static isMovableColumnSizer(x) {
    return x.classList.contains(Zt.MOVABLE_SIZER_CLASS);
  }
  static getVerticalLineHeight(x, w) {
    let O = x.offsetHeight;
    if (w) {
      const D = x.lastChild.offsetHeight;
      O -= D;
    }
    return O;
  }
  static display(x, w, O) {
    const D = w.movableElement;
    D.style.display = "flex";
    const U = D.children[0];
    U.style.height = `${Zt.getVerticalLineHeight(x, O)}px`;
  }
  static hide(x) {
    x.style.display = "none", x.style.left = "";
  }
  static createVerticalLine(x) {
    const w = document.createElement("div");
    return w.style.backgroundColor = x, w.classList.add(Zt.VERTICAL_LINE_CLASS), w;
  }
  static getMovableBackgroundColor(x) {
    return x.click || x.hover || Zt.DEFAULT_BACKGROUND_COLOR;
  }
  static create(x) {
    const w = Zt.getMovableBackgroundColor(x), O = document.createElement("div");
    O.style.backgroundColor = w, O.classList.add(Zt.MOVABLE_SIZER_CLASS), Zt.hide(O);
    const D = Zt.createVerticalLine(w);
    return O.appendChild(D), O;
  }
};
_MovableColumnSizerElement.DEFAULT_BACKGROUND_COLOR = "#4668ed";
_MovableColumnSizerElement.MOVABLE_SIZER_CLASS = "movable-column-sizer";
_MovableColumnSizerElement.VERTICAL_LINE_CLASS = "movable-column-sizer-vertical-line";
let MovableColumnSizerElement = _MovableColumnSizerElement;
class MoveLimits {
  // Borders of the side cells tend to breach over the limits of the table (when no side frame elements),
  // causing the offsets to give incorrect data and set the limits beyond the table. The breach magnitude is
  // influenced by the sizer start position when cells have borders - which is the very center position of
  // the total of those two borders width.
  // prettier-ignore
  static getSideLimitDelta(x) {
    const w = ExtractElements.getRightColumnSiblingCell(x);
    return ((Number.parseFloat(getComputedStyle(x).borderRightWidth) || 0) - (Number.parseFloat(getComputedStyle(w).borderLeftWidth) || 0)) / 2;
  }
  static getRightLimitDynamicWidthTable() {
    return window.innerWidth;
  }
  // prettier-ignore
  static getRightLimitForMaxWidth(x, w, O) {
    return StaticTable.isTableAtMaxWidth(x, w) ? O ? Number.parseFloat(O.style.width) : 0 : w.maxWidth - x.offsetWidth;
  }
  static getRightLimit(x, w) {
    return x._tableDimensions.width !== void 0 ? Number.parseFloat(w.style.width) : x._tableDimensions.maxWidth !== void 0 && x._tableElementRef ? MoveLimits.getRightLimitForMaxWidth(x._tableElementRef, x._tableDimensions, w) : MoveLimits.getRightLimitDynamicWidthTable();
  }
  static getLeftLimit(x, w) {
    let O = -x.offsetWidth;
    return w !== void 0 && (O += w), O;
  }
  // prettier-ignore
  static generate(x, w, O, D, U, W) {
    const X = w || O ? MoveLimits.getSideLimitDelta(W) : 0;
    return {
      left: MoveLimits.getLeftLimit(W, w ? X : void 0) + D,
      right: MoveLimits.getRightLimit(x, U)
    };
  }
}
class SelectedColumnSizer {
  // prettier-ignore
  static generateObj(x, w, O, D, U, W) {
    const X = w.movableElement.offsetLeft;
    return {
      element: w.element,
      moveLimits: MoveLimits.generate(x, O, D, X, W, U),
      // this is to reflect the initial sizer offset to center itself in the cell divider
      initialOffset: X,
      mouseMoveOffset: X,
      fireColumnsUpdate: FireEvents.onColumnsUpdate.bind(this, x)
    };
  }
  static get(x, w) {
    const O = x._columnsDetails[w].columnSizer, D = w === 0, U = x._columnsDetails.length - 2 === w, W = x._columnsDetails[w].elements[0], X = ColumnSizerGenericUtils.findNextResizableColumnHeader(x._columnsDetails, w);
    return SelectedColumnSizer.generateObj(x, O, D, U, W, X);
  }
}
const SEMI_TRANSPARENT_COLOR = "#ffffff01";
class ColumnSizer {
  static shouldWidthBeIncreased(x) {
    return x > 4;
  }
  // prettier-ignore
  static getBackgroundImage(x, w, O, D, U) {
    if (D && U) {
      if (Number.parseInt(getComputedStyle(U).borderRightWidth) > 0 && (w > 0 || O === void 0 || O > 0))
        return ColumnSizerElement.EMPTY_BACKGROUND_IMAGE;
    } else if (x > 0)
      return ColumnSizerElement.EMPTY_BACKGROUND_IMAGE;
    return ColumnSizerElement.FILLED_BACKGROUND_IMAGE;
  }
  static getMarginRight(x, w) {
    return w || !x ? "0px" : `${x.leftCellRight - x.rightCellLeft}px`;
  }
  static getTotalCellBorderWidth(x) {
    return x ? x.rightCellLeft + x.leftCellRight : 0;
  }
  static generateBorderWidthsInfo(x, w) {
    var O, D, U;
    const W = {
      rightCellLeft: 0,
      leftCellLeft: 0,
      leftCellRight: 0,
      beforeLeftCellRight: void 0
    }, X = (O = x[w - 1]) == null ? void 0 : O.elements[0];
    X && (W.beforeLeftCellRight = Number.parseInt(getComputedStyle(X).borderRightWidth) || 0);
    const G = (D = x[w]) == null ? void 0 : D.elements[0];
    if (G) {
      const K = getComputedStyle(G);
      W.leftCellLeft = Number.parseInt(K.borderLeftWidth) || 0, W.leftCellRight = Number.parseInt(K.borderRightWidth) || 0;
    }
    const Y = (U = x[w + 1]) == null ? void 0 : U.elements[0];
    return Y && (W.rightCellLeft = Number.parseInt(getComputedStyle(Y).borderLeftWidth) || 0), W;
  }
  // prettier-ignore
  static createObject(x, w, O, D, U, W, X) {
    const G = ColumnSizer.generateBorderWidthsInfo(w, O), Y = ColumnSizer.getTotalCellBorderWidth(G), K = w.length - 1 === O, Z = ColumnSizer.getMarginRight(G, K), q = ColumnSizer.getBackgroundImage(
      Y,
      G.leftCellLeft,
      G.beforeLeftCellRight,
      K,
      D
    ), J = ColumnSizer.shouldWidthBeIncreased(Y), ee = {
      element: x,
      styles: {
        default: {
          width: J ? `${Y + 2}px` : "1.5px",
          backgroundImage: q
        },
        hover: {
          width: J ? `${(Y + 2) * 1.5}px` : "9px"
        },
        static: {
          marginRight: Z
        }
      },
      isSideCellHovered: !1,
      isSizerHovered: !1,
      isMouseUpOnSizer: !1
    };
    return X && (ee.hoverColor = X.hover || ColumnSizerElement.DEFAULT_HOVER_COLOR), W && (ee.movableElement = W), U && (ee.overlayElement = U), ee;
  }
  // prettier-ignore
  static create(x, w) {
    const { _columnsDetails: O, _tableElementRef: D, columnResizerColors: U } = x, W = ColumnSizerElement.create(w, U.hover), X = MovableColumnSizerElement.create(U), G = ColumnSizerOverlayElement.create(), Y = ColumnSizer.createObject(
      W,
      O,
      w,
      D,
      G,
      X,
      U
    );
    return ColumnSizerOverlayElement.applyEvents(x, Y), Y;
  }
}
const _ColumnSizerFillerElement = class Zr {
  static create(x) {
    const w = document.createElement("div");
    return w.classList.add(Zr.SIZER_FILLER_CLASS), w.style.backgroundColor = x || ColumnSizerElement.DEFAULT_HOVER_COLOR, w.style.display = "none", w;
  }
  static setWidth(x, w) {
    const O = Number.parseInt(w);
    x.style.width = `${ColumnSizer.shouldWidthBeIncreased(O) ? O : 4}px`;
  }
  static display(x) {
    x.style.display = "block";
  }
  static hide(x) {
    x.style.display = "none";
  }
};
_ColumnSizerFillerElement.SIZER_FILLER_CLASS = "column-sizer-filler";
let ColumnSizerFillerElement = _ColumnSizerFillerElement;
const _ColumnSizerElement = class Dt {
  static isHovered(x) {
    return x.style.backgroundImage === Dt.EMPTY_BACKGROUND_IMAGE;
  }
  static setBackgroundImage(x, w) {
    x.style.backgroundImage = w;
  }
  static unsetBackgroundImage(x) {
    x.style.backgroundImage = Dt.EMPTY_BACKGROUND_IMAGE;
  }
  static setBackgroundColor(x, w) {
    x.style.backgroundColor = w;
  }
  static setTransitionTime(x) {
    x.style.transition = Dt.TRANSITION_TIME;
  }
  static unsetTransitionTime(x) {
    x.style.transition = "0.0s";
  }
  // is not used to unset background image
  static unsetElementsToDefault(x, w, O = !0) {
    O && Dt.setBackgroundColor(x, SEMI_TRANSPARENT_COLOR), ColumnSizerFillerElement.hide(x.children[0]), x.style.width = w;
  }
  // this is recalculated as it depends on the column index that the sizer is on
  static setStaticProperties(x, w) {
    x.style.marginRight = w;
  }
  static setElementId(x, w) {
    x.id = `${Dt.COLUMN_SIZER_ID_PREFIX}${w}`;
  }
  static create(x, w) {
    const O = document.createElement("div");
    Dt.setElementId(O, x), O.classList.add(Dt.COLUMN_SIZER_CLASS);
    const D = ColumnSizerFillerElement.create(w);
    return O.append(D), Dt.hide(O), O;
  }
  static display(x) {
    var w;
    UpdateRowElement.updateHeaderRowHeight((w = x.parentElement) == null ? void 0 : w.parentElement), x.style.display = "flex";
  }
  static hide(x) {
    x.style.display = "none";
  }
  static hideWithBlurAnimation(x) {
    setTimeout(() => {
      Dt.hide(x);
    }, Dt.HALF_TRANSITION_TIME_ML);
  }
  static hideWhenCellNotHovered(x, w) {
    x.isSideCellHovered || (w ? Dt.hideWithBlurAnimation(x.element) : Dt.hide(x.element));
  }
  static setHoverStyle(x, w, O, D) {
    const { element: U, hoverColor: W } = x;
    ColumnSizerFillerElement.display(U.children[0]), O && Dt.setTransitionTime(U), Dt.setBackgroundColor(U, D || W), U.style.width = w;
  }
};
_ColumnSizerElement.FILLED_BACKGROUND_IMAGE = "linear-gradient(180deg, #cdcdcd, #cdcdcd 75%, transparent 75%, transparent 100%)";
_ColumnSizerElement.EMPTY_BACKGROUND_IMAGE = "none";
_ColumnSizerElement.DEFAULT_HOVER_COLOR = "grey";
_ColumnSizerElement.COLUMN_SIZER_CLASS = "column-sizer";
_ColumnSizerElement.COLUMN_SIZER_ID_PREFIX = `${_ColumnSizerElement.COLUMN_SIZER_CLASS}-`;
_ColumnSizerElement.TRANSITION_TIME_ML = 200;
_ColumnSizerElement.TRANSITION_TIME = `${_ColumnSizerElement.TRANSITION_TIME_ML / 1e3}s`;
_ColumnSizerElement.HALF_TRANSITION_TIME_ML = _ColumnSizerElement.TRANSITION_TIME_ML / 2;
let ColumnSizerElement = _ColumnSizerElement;
const _ColumnSizerOverlayEvents = class Nr {
  static overlayMouseEnter(x) {
    if (x.isSizerHovered = !0, x.isMouseUpOnSizer || this._activeOverlayElements.selectedColumnSizer)
      return;
    const { width: w } = x.styles.hover;
    ColumnSizerElement.display(x.element), ColumnSizerElement.setTransitionTime(x.element), setTimeout(() => {
      x.isSizerHovered && ColumnSizerElement.setHoverStyle(x, w, !1);
    }, 1), setTimeout(() => {
      x.isSizerHovered && ColumnSizerElement.unsetBackgroundImage(x.element);
    }, Nr.MOUSE_PASSTHROUGH_TIME_ML);
  }
  // the constant if statement checking is used to prevent a bug where if a mouse leaves the sizer and immediately reenters
  // the timeouts would still proceed to execute the code below
  static unsetColorDuringTransition(x) {
    setTimeout(() => {
      x.isSizerHovered || (ColumnSizerElement.setBackgroundImage(x.element, x.styles.default.backgroundImage), setTimeout(() => {
        x.isSizerHovered || (ColumnSizerElement.unsetTransitionTime(x.element), ColumnSizerElement.setBackgroundColor(x.element, SEMI_TRANSPARENT_COLOR));
      }, ColumnSizerElement.HALF_TRANSITION_TIME_ML));
    }, ColumnSizerElement.HALF_TRANSITION_TIME_ML);
  }
  static overlayMouseLeave(x) {
    if (x.isSizerHovered = !1, this._activeOverlayElements.selectedColumnSizer || x.isMouseUpOnSizer)
      return;
    const { element: w, styles: O } = x;
    ColumnSizerElement.unsetElementsToDefault(w, O.default.width);
    const D = ColumnSizerElement.isHovered(w);
    setTimeout(() => {
      !this._activeOverlayElements.selectedColumnSizer && !x.isSizerHovered && (Nr.unsetColorDuringTransition(x), ColumnSizerElement.hideWhenCellNotHovered(x, D));
    }, Nr.MOUSE_PASSTHROUGH_TIME_ML);
  }
  // we need to pass down the sizer element instead of the id as the id can change when columns are inserted/removed
  // prettier-ignore
  static overlayMouseDown(x) {
    const { _columnsDetails: w, _tableBodyElementRef: O, _frameComponents: { displayAddNewRow: D } } = this, { columnSizer: U, sizerNumber: W } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(x.id, w), { element: X, styles: G } = U;
    MovableColumnSizerElement.display(O, U, D), ColumnSizerElement.unsetElementsToDefault(X, G.default.width), ColumnSizerElement.setBackgroundImage(X, G.default.backgroundImage), this._activeOverlayElements.selectedColumnSizer = SelectedColumnSizer.get(this, W);
  }
};
_ColumnSizerOverlayEvents.MOUSE_PASSTHROUGH_TIME_ML = 50;
let ColumnSizerOverlayEvents = _ColumnSizerOverlayEvents;
const _ColumnSizerOverlayElement = class Qr {
  // this is recalculated as it depends on the column index that the sizer is on
  static setStaticProperties(x, w, O) {
    x.style.marginRight = w, x.style.width = O;
  }
  static applyEvents(x, w) {
    w.overlayElement.onmouseenter = ColumnSizerOverlayEvents.overlayMouseEnter.bind(x, w), w.overlayElement.onmouseleave = ColumnSizerOverlayEvents.overlayMouseLeave.bind(x, w), w.overlayElement.onmousedown = ColumnSizerOverlayEvents.overlayMouseDown.bind(x, w.element);
  }
  static create() {
    const x = document.createElement("div");
    return x.classList.add(Qr.SIZER_OVERLAY_CLASS), x;
  }
};
_ColumnSizerOverlayElement.SIZER_OVERLAY_CLASS = "column-sizer-overlay";
let ColumnSizerOverlayElement = _ColumnSizerOverlayElement;
class InsertRemoveColumnSizer {
  static updateIdsOfAllSubsequent(x, w) {
    x.slice(w).forEach((O, D) => {
      if (!O.columnSizer)
        return;
      const U = w + D;
      ColumnSizerElement.setElementId(O.columnSizer.element, U);
    });
  }
  static applySizerStateToElements(x) {
    const { element: w, movableElement: O, overlayElement: D, styles: U } = x;
    ColumnSizerElement.unsetElementsToDefault(w, U.default.width), ColumnSizerFillerElement.setWidth(w.children[0], U.default.width), ColumnSizerElement.setStaticProperties(w, U.static.marginRight), ColumnSizerElement.setBackgroundImage(w, U.default.backgroundImage), MovableColumnSizerElement.setStaticProperties(O, U.static.marginRight, U.hover.width), ColumnSizerOverlayElement.setStaticProperties(D, U.static.marginRight, U.hover.width);
  }
  static insertAtIndex(x, w, O) {
    const D = w.elements[0].nextSibling, U = ColumnSizer.create(x, O);
    w.columnSizer = U, D.appendChild(U.element), D.appendChild(U.overlayElement), D.appendChild(U.movableElement), InsertRemoveColumnSizer.applySizerStateToElements(U);
  }
  // prettier-ignore
  static updateSizer(x, w, O, D) {
    const U = ColumnSizer.createObject(x.element, w, O, D);
    Object.assign(x, U), InsertRemoveColumnSizer.applySizerStateToElements(x);
  }
  static updatePrevious(x, w, O) {
    var D;
    const U = w - 1;
    if (U < 0)
      return;
    const { columnSizer: W } = x[U];
    ((D = x[U].settings.widths) == null ? void 0 : D.staticWidth) !== void 0 || !W || InsertRemoveColumnSizer.updateSizer(W, x, w, O);
  }
  static getNewColumnIndexIfWidthSet(x, w) {
    var O;
    return x.length - 1 === w ? (O = x[w - 1]) != null && O.columnSizer ? -1 : w - 1 : w;
  }
  static isNotResizable(x) {
    const { widths: w, isColumnResizable: O } = x.settings;
    return w?.staticWidth !== void 0 || !O;
  }
  // REF-13
  static insert(x, w) {
    const { _columnsDetails: O } = x;
    if (!InsertRemoveColumnSizer.isNotResizable(O[w])) {
      if (x._tableDimensions.width !== void 0) {
        if (w = InsertRemoveColumnSizer.getNewColumnIndexIfWidthSet(x._columnsDetails, w), w === -1 || InsertRemoveColumnSizer.isNotResizable(O[w]))
          return;
      } else
        InsertRemoveColumnSizer.updatePrevious(O, w, x._tableElementRef);
      InsertRemoveColumnSizer.insertAtIndex(x, O[w], w), InsertRemoveColumnSizer.updateIdsOfAllSubsequent(O, w + 1);
    }
  }
  // this is only used for when table width is static, otherwise it is removed directly with the column
  static removeSizer(x) {
    var w, O, D, U, W, X;
    (O = (w = x.columnSizer) == null ? void 0 : w.element) == null || O.remove(), (U = (D = x.columnSizer) == null ? void 0 : D.movableElement) == null || U.remove(), (X = (W = x.columnSizer) == null ? void 0 : W.overlayElement) == null || X.remove(), delete x.columnSizer;
  }
  // need to remove the sizer of the new last column as when width is set - last column does not have a sizer
  static removeIfLastColumn(x, w) {
    return x.length === w && x[w] && (w -= 1, InsertRemoveColumnSizer.removeSizer(x[w])), w;
  }
  static remove(x, w) {
    const { _tableDimensions: O, _columnsDetails: D, _tableElementRef: U } = x;
    O.width !== void 0 && (w = InsertRemoveColumnSizer.removeIfLastColumn(D, w)), InsertRemoveColumnSizer.updatePrevious(D, w, U), InsertRemoveColumnSizer.updateIdsOfAllSubsequent(D, w);
  }
  // This is used to cleanup sizers for columns that have or had static widths because they do not have sizers,
  // additionally when the table width is set the last column that is not static also does not have a sizer.
  static cleanUpCustomColumnSizers(x, w) {
    const { _tableDimensions: O, _columnsDetails: D } = x;
    if (O.width === void 0)
      return;
    let U = !1;
    for (let W = D.length - 1; W >= 0; W -= 1) {
      const X = D[W];
      if (InsertRemoveColumnSizer.isNotResizable(X))
        X.columnSizer && InsertRemoveColumnSizer.removeSizer(X);
      else if (U === !1) {
        if (U = !0, X.columnSizer && InsertRemoveColumnSizer.removeSizer(X), W < w)
          break;
      } else if (!X.columnSizer && D.length - 1 !== W && InsertRemoveColumnSizer.insertAtIndex(x, X, W), U === !0 && W < w)
        break;
    }
  }
}
class DropdownDisplaySettingsUtil {
  static process(x) {
    x.isAvailable ?? (x.isAvailable = !0), x.isAvailable ? (x.openMethod ?? (x.openMethod = {}), x.openMethod.overlayClick ? delete x.openMethod.cellClick : x.openMethod.cellClick ? delete x.openMethod.overlayClick : x.openMethod.overlayClick = !0) : (delete x.openMethod, delete x.overlayStyles);
  }
}
class ColumnSettingsDefaultTextUtils {
  static unsetDefaultText(x, w, O) {
    w.elements.slice(1).forEach((D, U) => {
      const W = U + 1;
      CellEvents.removeTextIfDefault(x, W, O, D);
    });
  }
  static setDefaultText(x, w, O) {
    w.elements.slice(1).forEach((D, U) => {
      const W = U + 1;
      CellEvents.setCellToDefaultIfNeeded(x, W, O, D, !1);
    }), setTimeout(() => FireEvents.onDataUpdate(x));
  }
}
class ColumnSettingsWidthUtils {
  // prettier-ignore
  static getSettingsWidthNumber(x, w, O = !0) {
    return StringDimensionUtils.generateNumberDimensionFromClientString(
      x,
      w,
      O ? "staticWidth" : "initialWidth",
      !0,
      ColumnDetails.MINIMAL_COLUMN_WIDTH
    );
  }
  static updateColumnWidth(x, w, O, D) {
    const { _tableDimensions: U, _tableElementRef: W } = x, { number: X } = ColumnSettingsWidthUtils.getSettingsWidthNumber(W, O);
    w.style.width = `${X}px`, TableElement.changeStaticWidthTotal(U, D ? X : -X);
  }
  // prettier-ignore
  static changeWidth(x, w, O, D) {
    let U = !1;
    O != null && O.staticWidth && (ColumnSettingsWidthUtils.updateColumnWidth(x, w, O, !1), U = !0), D != null && D.staticWidth && (ColumnSettingsWidthUtils.updateColumnWidth(x, w, D, !0), U = !0), U && StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(x, !0);
  }
}
class ColumnDropdownCellOverlayEvents {
  static mouseClick(x, w) {
    ColumnDropdown.display(this, x);
    const O = w.elements[0];
    setTimeout(() => FocusedCellUtils.setHeaderCell(this._focusedElements.cell, O, x));
  }
  // prettier-ignore
  static mouseLeave(x) {
    var w;
    ColumnDropdownCellOverlay.hide(this, x), delete this._hoveredElements.headerCell, ColumnDropdownCellOverlay.resetDefaultColor(
      x.columnDropdownCellOverlay,
      (w = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : w.displaySettings
    );
  }
  static mouseEnter(x) {
    var w;
    const O = x.elements[0];
    this._hoveredElements.headerCell = O, ColumnDropdownCellOverlay.setHoverColor(x, (w = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : w.displaySettings);
  }
  static setEvents(x, w) {
    const O = x._columnsDetails[w], { columnDropdownCellOverlay: D } = O;
    D && (D.onmouseenter = ColumnDropdownCellOverlayEvents.mouseEnter.bind(x, O), D.onmouseleave = ColumnDropdownCellOverlayEvents.mouseLeave.bind(x, O), D.onclick = ColumnDropdownCellOverlayEvents.mouseClick.bind(x, w, O));
  }
}
class EditableHeaderIconTextEvents {
  static keyDownOnText(x, w, O) {
    UpdateRowElement.updateHeadRowHeightOnKeyDown(this._tableBodyElementRef), O.key === KEYBOARD_KEY.TAB && CellTextEvents.tabOutOfCell(this, x, w, O);
  }
  // REF-15
  static blurText(x, w, O) {
    const D = O.target, U = CellElement.getCellElement(D);
    HeaderText.onAttemptChange(this, U, w), DataCellEvents.blur(this, x, w, D);
  }
  static setEvents(x, w, O, D) {
    x._columnsDetails[D].settings.isHeaderTextEditable && (w.onfocus = CellWithTextEvents.focusText.bind(x, O, D, null), w.onblur = EditableHeaderIconTextEvents.blurText.bind(x, O, D), w.onkeydown = EditableHeaderIconTextEvents.keyDownOnText.bind(x, O, D));
  }
}
class ColumnSizerCellEvents {
  static hideColumnSizer(x) {
    if (!x)
      return;
    x.isSideCellHovered = !1;
    const w = ColumnSizerElement.isHovered(x.element);
    setTimeout(() => {
      x.isSizerHovered || ColumnSizerElement.hideWhenCellNotHovered(x, w);
    });
  }
  static cellMouseLeave(x, w) {
    var O, D;
    ColumnSizerCellEvents.hideColumnSizer((O = x[w - 1]) == null ? void 0 : O.columnSizer), ColumnSizerCellEvents.hideColumnSizer((D = x[w]) == null ? void 0 : D.columnSizer);
  }
  static displayColumnSizer(x) {
    x && (ColumnSizerElement.display(x.element), x.isSideCellHovered = !0);
  }
  static cellMouseEnter(x, w) {
    var O, D;
    ColumnSizerCellEvents.displayColumnSizer((O = x[w - 1]) == null ? void 0 : O.columnSizer), ColumnSizerCellEvents.displayColumnSizer((D = x[w]) == null ? void 0 : D.columnSizer);
  }
}
class HeaderCellEvents {
  static mouseEnterCell(x, w) {
    var O, D, U, W;
    if (!this._activeOverlayElements.selectedColumnSizer) {
      const X = this._columnsDetails[x], G = w.target;
      CellHighlightUtils.highlight(G, (O = X.headerStateColors) == null ? void 0 : O.hover), ColumnSizerCellEvents.cellMouseEnter(this._columnsDetails, x), (W = (U = (D = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : D.displaySettings) == null ? void 0 : U.openMethod) != null && W.overlayClick && ColumnDropdownCellOverlay.display(X), this._hoveredElements.headerCell = G;
    }
  }
  static mouseLeaveCell(x, w) {
    var O, D, U, W;
    Dropdown.isDisplayed(this._activeOverlayElements.columnDropdown) || (CellHighlightUtils.fade(w.target, (O = this._columnsDetails[x].headerStateColors) == null ? void 0 : O.default), ColumnDropdownCellOverlay.hide(this, this._columnsDetails[x]), (W = (U = (D = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : D.displaySettings) == null ? void 0 : U.openMethod) != null && W.overlayClick && delete this._hoveredElements.headerCell), this._activeOverlayElements.selectedColumnSizer || ColumnSizerCellEvents.cellMouseLeave(this._columnsDetails, x);
  }
  static mouseClick(x, w) {
    var O, D, U;
    const W = w.target;
    CellEvents.removeTextIfDefault(this, 0, x, W), (U = (D = (O = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : O.displaySettings) == null ? void 0 : D.openMethod) != null && U.cellClick && ColumnDropdown.display(this, x), setTimeout(() => FocusedCellUtils.setHeaderCell(this._focusedElements.cell, W, x));
  }
  static setEvents(x, w, O) {
    w.onmouseenter = HeaderCellEvents.mouseEnterCell.bind(x, O), w.onmouseleave = HeaderCellEvents.mouseLeaveCell.bind(x, O), w.onclick = HeaderCellEvents.mouseClick.bind(x, O), DragColumn.applyEventsToElement(x, w, w);
  }
}
class EditableHeaderCellEvents {
  static mouseClickCell(x, w) {
    const O = w.target;
    FocusedCellUtils.purge(this._focusedElements.cell), setTimeout(() => FocusedCellUtils.setHeaderCell(this._focusedElements.cell, O, x));
  }
  static setEvents(x, w, O, D) {
    if (w.onmouseenter = HeaderCellEvents.mouseEnterCell.bind(x, D), w.onmouseleave = HeaderCellEvents.mouseLeaveCell.bind(x, D), x.displayHeaderIcons) {
      w.onfocus = () => {
      }, w.onblur = () => {
      }, w.onmousedown = CellWithTextEvents.mouseDown.bind(x, null), w.onclick = EditableHeaderCellEvents.mouseClickCell.bind(x, D);
      const U = CellElement.getTextElement(w);
      EditableHeaderIconTextEvents.setEvents(x, U, O, D);
    } else
      w.onclick = HeaderCellEvents.mouseClick.bind(x, D);
  }
}
class CellEventsReset {
  static unset(x) {
    x.onfocus = () => {
    }, x.onblur = () => {
    }, x.onmouseenter = () => {
    }, x.onmouseleave = () => {
    }, x.onmousedown = () => {
    }, x.oninput = () => {
    }, x.onpaste = () => {
    }, x.onkeydown = () => {
    };
  }
  static setDataCellEvents(x, w, O, D) {
    const { settings: U, activeType: W } = x._columnsDetails[D];
    if (!U.isCellTextEditable)
      return;
    DataCellEvents.setEvents(x, w, O, D);
    const { cellDropdownProps: X, calendar: G, checkbox: Y } = W;
    X ? SelectCell.setEvents(x, w, O, D) : G ? DateCellEvents.setEvents(x, w, O, D) : Y && CheckboxCellEvents.setEvents(x, w, O, D);
  }
  static setHeaderCellEvents(x, w, O, D) {
    var U, W, X;
    (X = (W = (U = x._defaultColumnsSettings.columnDropdown) == null ? void 0 : U.displaySettings) == null ? void 0 : W.openMethod) != null && X.cellClick ? HeaderCellEvents.setEvents(x, w, D) : (DataCellEvents.setEvents(x, w, O, D), EditableHeaderCellEvents.setEvents(x, w, 0, D), ColumnDropdownCellOverlayEvents.setEvents(x, D));
  }
  // REF-33
  static reset(x, w, O, D) {
    O === 0 ? CellEventsReset.setHeaderCellEvents(x, w, O, D) : CellEventsReset.setDataCellEvents(x, w, O, D), !x._frameComponents.displayIndexColumn && D === 0 && RowDropdownCellOverlayEvents.addCellEvents(x, O, w);
  }
}
class ResetColumnStructure {
  static reset(x, w, O) {
    const { elements: D, activeType: U, settings: W } = w;
    D.slice(1).forEach((X) => {
      W.isCellTextEditable || CellEventsReset.unset(X);
    }), ChangeColumnType.setNewStructureBasedOnType(x, O, U), ColumnSettingsBorderUtils.resetBorderOverwritingState(w), setTimeout(() => FireEvents.onColumnsUpdate(x));
  }
}
class ColumnSettingsUtils {
  static updateSizer(x, w) {
    const { _columnsDetails: O, _tableElementRef: D } = x;
    if (!D)
      return;
    const { columnSizer: U } = O[w];
    U || InsertRemoveColumnSizer.insert(x, w), InsertRemoveColumnSizer.cleanUpCustomColumnSizers(x, w), U && InsertRemoveColumnSizer.updateSizer(U, O, w, D);
    const W = w - 1;
    if (w > 0 && O[W].columnSizer) {
      const { columnSizer: X } = O[W];
      InsertRemoveColumnSizer.updateSizer(X, O, W, D);
    }
  }
  // prettier-ignore
  static change(x, w, O, D, U, W) {
    const X = x._columnsDetails[O];
    ColumnSettingsDefaultTextUtils.unsetDefaultText(x, X, O), X.settings = U, X.activeType = ColumnTypesUtils.getActiveType(U, X.settings.defaultColumnTypeName), ResetColumnStructure.reset(x, X, O), ColumnSettingsDefaultTextUtils.setDefaultText(x, X, O), W || ColumnSettingsWidthUtils.changeWidth(x, w, D.widths, U.widths), ColumnSettingsStyleUtils.changeStyleFunc(x, O, D), ColumnSettingsBorderUtils.updateSiblingColumns(x, O), ColumnSettingsUtils.updateSizer(x, O), x.displayHeaderIcons && HeaderIconCellElement.changeHeaderIcon(x._columnsDetails[O]), ColumnDropdownCellOverlay.updateIfDisplayed(X), AddNewColumnElement.toggle(x, !0);
  }
  // prettier-ignore
  static parseSettingsChange(x) {
    const { _customColumnsSettings: w, _columnsDetails: O, _focusedElements: { cell: { element: D, columnIndex: U } } } = x, W = O[U].settings, X = w[CellElement.getText(D)];
    return { oldSettings: W, newSettings: X, areSettingsDifferent: X ? W !== X : !1 };
  }
  // prettier-ignore
  static changeColumnSettingsIfNameDifferent(x, w, O, D = !1) {
    const { oldSettings: U, newSettings: W, areSettingsDifferent: X } = ColumnSettingsUtils.parseSettingsChange(x);
    X && ColumnSettingsUtils.change(x, w, O, U, W, D);
  }
  static setDropdownSettings(x, w) {
    !x || !w || (x.isSortAvailable ?? (x.isSortAvailable = w.isSortAvailable), x.isDeleteAvailable ?? (x.isDeleteAvailable = w.isDeleteAvailable), x.isInsertLeftAvailable ?? (x.isInsertLeftAvailable = w.isInsertLeftAvailable), x.isInsertRightAvailable ?? (x.isInsertRightAvailable = w.isInsertRightAvailable), x.isMoveAvailable ?? (x.isMoveAvailable = w.isMoveAvailable));
  }
  static processCellDimensions(x) {
    const w = x.cellStyle;
    if (!w)
      return;
    const O = x;
    if (w.width) {
      const D = x.isColumnResizable === !1 ? "staticWidth" : "initialWidth";
      O.widths = { [D]: w.width };
    } else
      O.widths && x.isColumnResizable && O.widths.staticWidth && (O.widths = { initialWidth: O.widths.staticWidth });
    StringDimensionUtils.removeAllDimensions(w);
  }
  static createInternalSettings(x, w) {
    const O = x;
    return ColumnSettingsStyleUtils.doesSettingHaveSideBorderStyle(O) && (O.stylePrecedence = !0), ColumnSettingsUtils.setDropdownSettings(x.columnDropdown, w.columnDropdown), Object.keys(w).forEach((D) => {
      O[D] ?? (O[D] = w[D]);
    }), O.types = ColumnTypesUtils.getProcessedTypes(O), ColumnSettingsUtils.processCellDimensions(x), O;
  }
  static createInternalMap(x, w) {
    return x.reduce((O, D) => (O[D.headerName] = ColumnSettingsUtils.createInternalSettings(D, w), O), {});
  }
  static setDefaultTypeProperties(x) {
    const { _defaultColumnsSettings: w } = x;
    w.availableDefaultColumnTypes = x.availableDefaultColumnTypes, w.customColumnTypes = x.customColumnTypes, w.defaultColumnTypeName = x.defaultColumnTypeName, w.types = ColumnTypesUtils.getProcessedTypes(w);
  }
  static setDefaultDropdownProperties(x) {
    var w, O, D, U, W, X;
    const { _defaultColumnsSettings: G } = x, Y = { openMethod: { cellClick: !0 } };
    G.columnDropdown = x.columnDropdown || { displaySettings: Y }, (w = G.columnDropdown).displaySettings ?? (w.displaySettings = Y), DropdownDisplaySettingsUtil.process(G.columnDropdown.displaySettings), (O = G.columnDropdown).isSortAvailable ?? (O.isSortAvailable = !0), (D = G.columnDropdown).isDeleteAvailable ?? (D.isDeleteAvailable = !0), (U = G.columnDropdown).isInsertLeftAvailable ?? (U.isInsertLeftAvailable = !0), (W = G.columnDropdown).isInsertRightAvailable ?? (W.isInsertRightAvailable = !0), (X = G.columnDropdown).isMoveAvailable ?? (X.isMoveAvailable = !0);
  }
  static setDefaultGenericProperties(x) {
    const { _defaultColumnsSettings: w } = x;
    w.defaultText = x.defaultText ?? EMPTY_STRING, w.isDefaultTextRemovable = x.isDefaultTextRemovable ?? !0, w.cellStyle = x.cellStyle, w.isCellTextEditable = x.isCellTextEditable ?? !0, w.headerStyles = x.headerStyles, w.isHeaderTextEditable = x.isHeaderTextEditable ?? w.isCellTextEditable, w.headerIconStyle = x.headerIconStyle, w.isColumnResizable = x.isColumnResizable ?? !0;
  }
  static setDefaultColumnsSettings(x) {
    const { _defaultColumnsSettings: w } = x;
    ColumnSettingsUtils.setDefaultGenericProperties(x), ColumnSettingsUtils.processCellDimensions(w), ColumnSettingsUtils.setDefaultDropdownProperties(x), ColumnSettingsUtils.setDefaultTypeProperties(x);
  }
  // REF-21
  static setUpInternalSettings(x) {
    ColumnSettingsUtils.setDefaultColumnsSettings(x), x._customColumnsSettings = ColumnSettingsUtils.createInternalMap(
      x.customColumnsSettings,
      x._defaultColumnsSettings
    );
  }
}
class HeaderText {
  static onAttemptChange(x, w, O, D) {
    const U = D?.colRemove;
    U || ColumnSettingsUtils.changeColumnSettingsIfNameDifferent(x, w, O, D?.colMove), x._visiblityInternal.filters && FilterInternalUtils.wasHeaderChanged(x._columnsDetails, x._visiblityInternal.filters, O, U) && VisibilityUtils.headerChanged(x);
  }
}
class NestedDropdownItem {
  static resetItemStyle(x) {
    Array.from(x.children).forEach((w) => {
      const O = w;
      O.style.backgroundColor = "", O.style.color = "";
    });
  }
}
NestedDropdownItem.NESTED_DROPDOWN_ITEM = "nested-dropdown-item";
class DropdownItemNavigation {
  static focusInputElement(x) {
    x.children[0].dispatchEvent(new MouseEvent("mouseenter"));
  }
  // either at the end when isNext is true or the start when isNext is false
  static focusItemWhenOnEdge(x, w, O) {
    var D;
    if (DropdownItem.doesElementContainInputClass(x)) {
      const W = x.parentElement;
      return DropdownItemNavigation.focusSiblingItem(W, w, O);
    }
    ((D = x.parentElement) == null ? void 0 : D.parentElement).classList.contains(DropdownItem.DROPDOWN_ITEM_CLASS) && (w = x.parentElement);
    const U = O ? w.children[0] : w.children[w.children.length - 1];
    return DropdownItemNavigation.focusSiblingItem(U, w, O, !0);
  }
  // isEdgeItem means is it a start/end or inside item
  // prettier-ignore
  static focusSiblingItem(x, w, O, D = !1) {
    if (x.classList.contains(NestedDropdownItem.NESTED_DROPDOWN_ITEM)) {
      const W = x.children[2];
      Dropdown.isDisplayed(W) && Dropdown.hide(W);
    }
    const U = D ? x : x[O ? "nextSibling" : "previousSibling"];
    if (U) {
      if (!DropdownItem.isDisplayed(U) || U.classList.contains(DropdownItem.DROPDOWN_TITLE_ITEM_CLASS) || U.classList.contains(DropdownItem.DROPDOWN_ITEM_DIVIDER_CLASS))
        return DropdownItemNavigation.focusSiblingItem(U, w, O);
      if (U.classList.contains(DropdownItem.DROPDOWN_INPUT_ITEM_CLASS))
        return DropdownItemNavigation.focusInputElement(U);
    } else
      return DropdownItemNavigation.focusItemWhenOnEdge(x, w, O);
    U.dispatchEvent(new MouseEvent("mouseenter"));
  }
  static focusFirstNestedDropdownItem(x) {
    if (x.classList.contains(NestedDropdownItem.NESTED_DROPDOWN_ITEM)) {
      const w = x.children[2];
      Dropdown.isDisplayed(w) && w.children[0].dispatchEvent(new MouseEvent("mouseenter"));
    }
  }
  static focusNestedDropdownParentItem(x) {
    var w;
    const O = (w = x.parentElement) == null ? void 0 : w.parentElement;
    O.classList.contains(DropdownItem.DROPDOWN_ITEM_CLASS) && (Dropdown.hide(x.parentElement), O.dispatchEvent(new MouseEvent("mouseenter")));
  }
}
class ColumnTypeDropdownItemEvents {
  static onClickMiddleware(x) {
    ColumnSettingsUtils.parseSettingsChange(this).areSettingsDifferent || x(), ColumnDropdown.processTextAndHide(this);
  }
  // prettier-ignore
  static set(x, w, O) {
    w.forEach((D) => {
      const U = D;
      U.onclick = ColumnTypeDropdownItemEvents.onClickMiddleware.bind(
        x,
        ChangeColumnType.change.bind(x, U.innerText.trim(), O)
      );
    });
  }
}
class ColumnTypeDropdownItem {
  static unsetActiveItem(x) {
    const w = x.getElementsByClassName(DropdownItem.ACTIVE_ITEM_CLASS)[0];
    w && (w.children[0].style.filter = "", w.classList.remove(DropdownItem.ACTIVE_ITEM_CLASS));
  }
  static reset(x) {
    ColumnTypeDropdownItem.unsetActiveItem(x), DropdownItem.removeItems(x);
  }
  static setActiveItem(x, w) {
    const O = x.find((D) => CellElement.getText(D) === w);
    O && (O.classList.add(DropdownItem.ACTIVE_ITEM_CLASS), O.children[0].style.filter = SVGIconUtils.WHITE_FILTER);
  }
  // the items are repopulated every time column dropdown is opened
  static setUp(x, w) {
    const { columnTypeDropdown: O } = x._activeOverlayElements, D = x._columnsDetails[w], U = D.settings.types.map((W) => W.dropdownItem.element);
    DropdownItem.addButtonItemElements(x, O, U), ColumnTypeDropdownItemEvents.set(x, U, w), ColumnTypeDropdownItem.setActiveItem(U, D.activeType.name);
  }
}
class DropdownEvents {
  static itemKeyNavigation(x, w, O) {
    if (O.key === KEYBOARD_KEY.TAB || O.key === KEYBOARD_KEY.ARROW_DOWN) {
      O.preventDefault();
      const D = x != null && x.activeElement ? O.target : w.children[0];
      DropdownItemNavigation.focusSiblingItem(D, w, !0);
    } else
      O.key === KEYBOARD_KEY.ARROW_UP ? DropdownItemNavigation.focusSiblingItem(O.target, w, !1) : O.key === KEYBOARD_KEY.ARROW_RIGHT ? DropdownItemNavigation.focusFirstNestedDropdownItem(O.target) : O.key === KEYBOARD_KEY.ARROW_LEFT && DropdownItemNavigation.focusNestedDropdownParentItem(O.target);
  }
}
class ColumnDropdownEvents {
  static focusNextColumnDropdown(x, w) {
    var O, D, U;
    w.preventDefault(), ColumnDropdown.processTextAndHide(x);
    let W = x._focusedElements.cell.columnIndex;
    W === x._columnsDetails.length - 1 && (W = -1);
    const X = x._columnsDetails[W + 1];
    (U = (D = (O = x._defaultColumnsSettings.columnDropdown) == null ? void 0 : O.displaySettings) == null ? void 0 : D.openMethod) != null && U.cellClick ? X.elements[0].click() : X.columnDropdownCellOverlay.click();
  }
  static onKeyDown(x, w) {
    if (w.key === KEYBOARD_KEY.ENTER) {
      const O = w.target;
      DropdownItem.doesElementContainInputClass(O) ? ColumnDropdown.processTextAndHide(this) : (O.dispatchEvent(new Event("mouseenter")), O.dispatchEvent(new Event("click")));
    } else
      w.key === KEYBOARD_KEY.ESCAPE ? ColumnDropdown.processTextAndHide(this) : w.key === KEYBOARD_KEY.TAB && this._columnsDetails.length > 0 ? ColumnDropdownEvents.focusNextColumnDropdown(this, w) : DropdownEvents.itemKeyNavigation(this.shadowRoot, x, w);
  }
  static set(x, w) {
    w.onkeydown = ColumnDropdownEvents.onKeyDown.bind(x, w);
  }
}
function buildIcon$4(F) {
  return `<?xml version="1.0" standalone="no"?>
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" style="transform: ${F}">
      <g transform="matrix(0.84210527 0 0 0.84210527 0 0)">
        <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
          <path d="M186.67 193.5L186.67 58.33C 186.67 51.888603 191.8927 46.666 198.334 46.666C 204.7793 46.666 210.002 51.888702 210.002 58.33L210.002 58.33L210.002 193.5L260.08398 143.418C 264.64258 138.8594 272.029 138.8594 276.58398 143.418C 281.14258 147.9727 281.14258 155.359 276.58398 159.918L276.58398 159.918L206.58398 229.918C 202.02928 234.4727 194.64299 234.4727 190.08398 229.918L190.08398 229.918L120.083984 159.918C 115.52928 155.3594 115.52928 147.97299 120.083984 143.418C 124.642586 138.8594 132.02899 138.8594 136.58398 143.418L136.58398 143.418L186.67 193.5zM396.66998 93.33L326.66998 93.33L326.66998 443.33002L396.66998 443.33002zM420.00198 93.33L420.00198 443.33002L490.00198 443.33002L490.00198 93.33002zM151.672 490C 145.2267 490 140.004 484.7773 140.004 478.332L140.004 478.332L140.004 268.332C 140.004 261.8906 145.2267 256.668 151.672 256.668L151.672 256.668L245.004 256.668C 251.4454 256.668 256.672 261.8907 256.672 268.332L256.672 268.332L256.672 478.332C 256.672 484.7773 251.4454 490 245.004 490zM163.336 466.668L233.336 466.668L233.336 279.998L163.336 279.998zM315.00598 466.668C 308.56458 466.668 303.33798 461.4414 303.33798 455L303.33798 455L303.33798 81.67001C 303.33798 75.22472 308.56458 70.002014 315.00598 70.002014L315.00598 70.002014L501.67596 70.002014C 508.11737 70.002014 513.33997 75.22472 513.33997 81.67001L513.33997 81.67001L513.33997 455C 513.33997 461.4414 508.11728 466.668 501.67596 466.668z" stroke="none" fill="#000000" fill-rule="nonzero" />
        </g>
      </g>
    </svg>`;
}
const INSERT_LEFT_ICON_SVG_STRING = buildIcon$4(""), INSERT_RIGHT_ICON_SVG_STRING = buildIcon$4("rotate(180deg) scale(1, -1)"), INSERT_UP_ICON_SVG_STRING = buildIcon$4("rotate(90deg) scale(1, -1)"), INSERT_DOWN_ICON_SVG_STRING = buildIcon$4("rotate(-90deg)");
function buildIcon$3(F) {
  return `<?xml version="1.0" standalone="no"?>
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="9" height="9" style="transform: ${F}">
      <g transform="matrix(0.47368425 0 0 0.47368425 0 0)">
        <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
          <g>
            <path d="M169 139.73L308.72998 0L349.175 40.484L109.124985 280.544L348.645 520.054L308.74698 559.999L169.01698 420.26904C 92.164986 343.42105 29.286987 280.29904 29.286987 279.99902C 29.286987 279.699 92.165985 216.57303 169.01698 139.72902L169.01698 139.72902L169 139.73zM490.55 139.73L630.27997 0L670.725 40.484L430.675 280.544L670.195 520.054L630.297 559.999L490.56702 420.26904C 413.71503 343.42105 350.83704 280.29904 350.83704 279.99902C 350.83704 279.699 413.71603 216.57303 490.56702 139.72902z" stroke="none" fill="#000000" fill-rule="nonzero" />
          </g>
        </g>
      </g>
    </svg>`;
}
const MOVE_LEFT_ICON_SVG_STRING = buildIcon$3(""), MOVE_RIGHT_ICON_SVG_STRING = buildIcon$3("rotate(180deg)"), MOVE_UP_ICON_SVG_STRING = buildIcon$3("rotate(90deg)"), MOVE_DOWN_ICON_SVG_STRING = buildIcon$3("rotate(-90deg)");
function buildIcon$2(F) {
  return `<?xml version="1.0" standalone="no"?>
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="9" height="12" style="transform: ${F}">
      <g transform="matrix(0.5 0 0 0.5 0 0)">
        <path d="M0 0L24 0L24 24L0 24L0 0z" stroke="none" fill="none" />
        <path d="M3 18L9 18L9 16L3 16L3 18zM3 6L3 8L21 8L21 6L3 6zM3 13L15 13L15 11L3 11L3 13z" stroke="none" fill="#000000" fill-rule="nonzero" />
      </g>
    </svg>`;
}
const SORT_ASC_ICON_SVG_STRING = buildIcon$2("scale(1, -1)"), SORT_DESC_ICON_SVG_STRING = buildIcon$2(""), TRASH_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="15">
  <g transform="matrix(1.0666668 0 0 1.0714285 0 0)">
    <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
      <g>
        <path d="M459.21 156.28L448.835 436.32C 448.6592 441.1247 444.4248 445.195 439.6006 445.195L439.6006 445.195L260.40057 445.195C 255.58028 445.195 251.34198 441.1091 251.16617 436.32L251.16617 436.32L240.79117 156.28C 240.50601 148.5534 234.00996 142.522 226.28317 142.807C 218.55658 143.09607 212.52518 149.58821 212.81018 157.315L212.81018 157.315L223.18118 437.355C 223.91946 457.195 240.51718 473.195 260.40018 473.195L260.40018 473.195L439.60016 473.195C 459.47516 473.195 476.08017 457.22202 476.81915 437.355L476.81915 437.355L487.19016 157.315C 487.4753 149.58841 481.44406 143.09601 473.71716 142.807C 465.99057 142.52185 459.49417 148.5531 459.20917 156.28L459.20917 156.28L459.21 156.28z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M338.8 212.8L338.8 403.2C 338.8 409.3875 343.81168 414.39902 349.999 414.39902C 356.1863 414.39902 361.198 409.38733 361.198 403.2L361.198 403.2L361.198 212.80002C 361.198 206.61252 356.1863 201.60101 349.999 201.60101C 343.81168 201.60101 338.8 206.61272 338.8 212.80002L338.8 212.80002L338.8 212.8z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M277.2 213.13L282.8016 403.53C 282.9852 409.7136 288.14142 414.581 294.32462 414.397C 300.5082 414.21732 305.3756 409.0572 305.19162 402.874L305.19162 402.874L299.59003 212.474C 299.41034 206.2904 294.2502 201.423 288.06702 201.607C 281.88342 201.78668 277.02002 206.9468 277.2 213.12999L277.2 213.12999L277.2 213.13z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M400.41 212.47L394.8084 402.87C 394.62482 409.0536 399.492 414.214 405.6754 414.393C 411.859 414.5766 417.0154 409.7094 417.19843 403.526L417.19843 403.526L422.80002 213.126C 422.9797 206.94241 418.11642 201.78201 411.933 201.60301C 405.74942 201.41942 400.58902 206.2866 400.41 212.47002L400.41 212.47002L400.41 212.47z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M210 162.4L490 162.4C 497.7305 162.4 504 156.1344 504 148.4C 504 140.6695 497.7305 134.4 490 134.4L490 134.4L210 134.4C 202.2695 134.4 196 140.6695 196 148.4C 196 156.1344 202.2695 162.4 210 162.4z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M307.46 143.85L313.2881 123.44401C 314.5381 119.076805 320.20218 114.803406 324.75308 114.803406L324.75308 114.803406L375.2451 114.803406C 379.7959 114.803406 385.46008 119.07291 386.71008 123.44401L386.71008 123.44401L392.53818 143.85L419.46017 136.15471L413.63208 115.75271C 408.94458 99.35771 392.29608 86.80371 375.2451 86.80371L375.2451 86.80371L324.75308 86.80371C 307.7021 86.80371 291.05008 99.36271 286.3661 115.75271L286.3661 115.75271L280.538 136.15471L307.46 143.85z" stroke="none" fill="#000000" fill-rule="nonzero" />
      </g>
    </g>
  </g>
</svg>`;
class ColumnDropdownButtonItemConf {
}
ColumnDropdownButtonItemConf.ITEMS = [
  {
    text: "Sort Ascending",
    iconSettings: {
      svgString: SORT_ASC_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginRight: "9px", marginTop: "2px" } }
    }
  },
  {
    text: "Sort Descending",
    iconSettings: {
      svgString: SORT_DESC_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginRight: "9px", marginTop: "1px" } }
    }
  },
  {
    text: "Insert Left",
    iconSettings: {
      svgString: INSERT_LEFT_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "-2px", marginRight: "3px", marginTop: "1px" } }
    }
  },
  {
    text: "Insert Right",
    iconSettings: {
      svgString: INSERT_RIGHT_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "-3px", marginRight: "4px", marginTop: "1px" } }
    }
  },
  {
    text: "Move Left",
    iconSettings: {
      svgString: MOVE_LEFT_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "1px", marginRight: "7px", marginTop: "3.5px" } }
    }
  },
  {
    text: "Move Right",
    iconSettings: {
      svgString: MOVE_RIGHT_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "1px", marginRight: "7px", marginTop: "1.5px" } }
    }
  },
  {
    text: "Delete",
    iconSettings: {
      svgString: TRASH_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "-4px", marginRight: "5px", marginTop: "-1px" } }
    }
  }
];
class UpdateCellsForColumns {
  // prettier-ignore
  static updateColumn(x, w, O, D, U) {
    U !== CELL_UPDATE_TYPE.REMOVED && CellEventsReset.reset(x, O, w, D), FireEvents.onCellUpdate(x, CellElement.getText(O), w, D, U);
  }
  // prettier-ignore
  static updateNextBeforeLastColumns(x, w, O, D) {
    ExtractElements.textCellsArrFromRow(w.element).slice(O, D).forEach((U, W) => {
      const X = W + O;
      UpdateCellsForColumns.updateColumn(x, w.index, U, X, CELL_UPDATE_TYPE.UPDATE);
    });
  }
  // the reason why last column details need to be passed here is because after removal of last element, its details are
  // no longer present here as this class's methods are run in setTimeouts, hence those details need to be captured
  // before these methods are executed
  // prettier-ignore
  static rebindAndFireUpdates(x, w, O, D, U) {
    UpdateCellsForColumns.updateNextBeforeLastColumns(x, w, O, U.index), UpdateCellsForColumns.updateColumn(x, w.index, U.element, U.index, D);
  }
}
class LastColumn {
  // the reason why last column details are used is because after removal of the last column element, its details are
  // no longer present and update methods are run in setTimeouts, hence those details need to be captured before
  // their methods are executed
  static getDetails(x, w) {
    const O = x.length - 1;
    return { element: x[O].elements[w], index: O };
  }
}
class RemoveColumn {
  static reduceStaticWidthTotal(x, w) {
    var O;
    if ((O = w.widths) != null && O.staticWidth) {
      const { number: D } = ColumnSettingsWidthUtils.getSettingsWidthNumber(
        x._tableElementRef,
        w.widths
      );
      TableElement.changeStaticWidthTotal(x._tableDimensions, -D);
    }
  }
  static updateTableDimensions(x, w) {
    RemoveColumn.reduceStaticWidthTotal(x, w), StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(x, !1);
  }
  static cleanUpData(x) {
    x.length > 0 && x[0].length === 0 && x.splice(0);
  }
  static removeElements(x, w, O) {
    const D = CellElementIndex.getViaColumnIndex(w, O);
    x.children[D].remove(), x.children[D].remove();
  }
  static removeCell(x, w, O, D) {
    const U = LastColumn.getDetails(x._columnsDetails, O);
    RemoveColumn.removeElements(w, D, !!x._frameComponents.displayIndexColumn), x.data[O].splice(D, 1), setTimeout(() => {
      const W = { element: w, index: O };
      UpdateCellsForColumns.rebindAndFireUpdates(x, W, D, CELL_UPDATE_TYPE.REMOVED, U);
    });
  }
  static removeCellFromAllRows(x, w) {
    ExtractElements.textRowsArrFromTBody(x._tableBodyElementRef, x.data).forEach((D, U) => {
      RemoveColumn.removeCell(x, D, U, w);
    }), RemoveColumn.cleanUpData(x.data), HeaderText.onAttemptChange(x, x._columnsDetails[w].elements[0], w, { colRemove: !0 });
    const O = x._columnsDetails.splice(w, 1)[0];
    return RemoveColumn.updateTableDimensions(x, O.settings), O;
  }
  static remove(x, w) {
    const O = RemoveColumn.removeCellFromAllRows(x, w);
    ToggleAdditionElements.update(x, !1, AddNewColumnElement.toggle), ColumnSettingsBorderUtils.updateSiblingColumns(x, w), setTimeout(() => {
      O.cellDropdown.element.remove(), InsertRemoveColumnSizer.remove(x, w), InsertRemoveColumnSizer.cleanUpCustomColumnSizers(x, w), w === 0 && x._columnsDetails.length > 0 && RowDropdownCellOverlay.resetOverlays(x), setTimeout(() => {
        FireEvents.onDataUpdate(x), FireEvents.onColumnsUpdate(x);
      });
    });
  }
  static removeEvent(x) {
    RemoveColumn.remove(this, x);
  }
}
class ElementSiblingIterator {
  static create(x) {
    let w = x;
    return {
      next: () => {
        const O = w.nextSibling;
        return O && (w = O), O;
      },
      currentElement: () => w
    };
  }
}
class ColumnDropdownItemEvents {
  static onClickMiddleware(x) {
    x(), ColumnDropdown.processTextAndHide(this);
  }
  // prettier-ignore
  static setItemEvents(x, w, O) {
    const D = O.getElementsByClassName(ColumnDropdownItem.SORT_ITEM_CLASS)[0], U = ElementSiblingIterator.create(D);
    U.currentElement().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      x,
      Sort.sortColumn.bind(this, x, w, !0)
    ), U.next().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      x,
      Sort.sortColumn.bind(this, x, w, !1)
    ), U.next().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      x,
      InsertNewColumn.insert.bind(this, x, w)
    ), U.next().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      x,
      InsertNewColumn.insert.bind(this, x, w + 1)
    ), U.next().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      x,
      MoveColumn.move.bind(this, x, w, !1)
    ), U.next().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      x,
      MoveColumn.move.bind(this, x, w, !0)
    ), U.next().onclick = ColumnDropdownItemEvents.onClickMiddleware.bind(
      x,
      RemoveColumn.remove.bind(this, x, w)
    );
  }
  // reason why using onInput for updating cells is because it works for paste
  // prettier-ignore
  static onInput(x, w, O, D) {
    setTimeout(() => {
      CellEvents.updateCell(this, D.value, 0, x, { element: w, processText: !1 }), O.style.top = ColumnDropdown.getTopPosition(this, w);
    });
  }
  // prettier-ignore
  static setInputItemEvent(x, w, O, D, U) {
    D.oninput = ColumnDropdownItemEvents.onInput.bind(
      x,
      w,
      O,
      U,
      D
    );
  }
}
var SIDE = /* @__PURE__ */ ((F) => (F[F.LEFT = 0] = "LEFT", F[F.RIGHT = 1] = "RIGHT", F[F.TOP = 2] = "TOP", F[F.BOTTOM = 3] = "BOTTOM", F))(SIDE || {});
class NestedDropdown {
  static create(x, w) {
    const O = Dropdown.createBase();
    return O.style.top = `-${Number.parseInt(O.style.paddingTop) + 22}px`, x && w && DropdownItem.addNewButtonItems(x, O, w), O;
  }
  static resetPosition(x) {
    x.style.left = "";
  }
  static hideDropdown(x) {
    const w = x.target.children[2];
    w.style.display = "none", NestedDropdown.resetPosition(w);
  }
  // prettier-ignore
  static correctPosition(x, w, O) {
    const D = ElementVisibility.getDetailsInWindow(x, O);
    if (!D.isFullyVisible && D.blockingSides.has(SIDE.RIGHT)) {
      x.style.left = `-${w.style.width}`;
      const U = ElementVisibility.getDetailsInWindow(x, O);
      !U.isFullyVisible && U.blockingSides.has(SIDE.LEFT) && (x.style.left = "");
    }
  }
  // prettier-ignore
  static correctPositionForOverflow(x, w, O) {
    const { _tableElementRef: D, _overflow: U } = x;
    !D || !U || D.offsetWidth !== U.overflowContainer.scrollWidth && (w.style.left = `-${O.style.width}`, w.getBoundingClientRect().x < 0 && (w.style.left = ""));
  }
  static displayAndSetDropdownPosition(x) {
    const w = x.target.children[2], O = x.target.parentElement;
    w.style.left = O.style.width, w.style.display = O.style.display, this._overflow && OverflowUtils.isOverflowElement(this._overflow.overflowContainer) ? NestedDropdown.correctPositionForOverflow(this, w, O) : NestedDropdown.correctPosition(w, O, this._tableDimensions.border);
  }
}
class NestedDropdownItemEvents {
  // prettier-ignore
  static addEvents(x, w) {
    w.addEventListener("mouseenter", NestedDropdown.displayAndSetDropdownPosition.bind(x)), w.addEventListener("mouseleave", NestedDropdown.hideDropdown), w.children[1].addEventListener(
      "mouseenter",
      DropdownItemHighlightUtils.highlightNew.bind(this, x._activeOverlayElements, w)
    );
  }
}
const _ColumnTypeDropdown = class Pr {
  static setupParentItemData(x, w) {
    var O;
    const { name: D, dropdownItem: U } = w, W = ((O = U.element) == null ? void 0 : O.children[0]).cloneNode(!0);
    x.replaceChild(W, x.children[0]);
    const X = x.children[1];
    X.innerText = D;
  }
  static setUp(x, w, O) {
    const { activeType: D, settings: U } = x._columnsDetails[O], W = w.getElementsByClassName(Pr.COLUMN_TYPE_ITEM_CLASS)[0];
    if (Pr.setupParentItemData(W, D), U.types.length < 2)
      return W.style.pointerEvents = "none";
    W.style.pointerEvents = "", setTimeout(() => ColumnTypeDropdownItem.setUp(x, O));
  }
  // prettier-ignore
  static create(x, w) {
    const O = DropdownItem.addButtonItem(
      x,
      w,
      DropdownButtonItemConf.DEFAULT_ITEM,
      NestedDropdownItem.NESTED_DROPDOWN_ITEM,
      Pr.COLUMN_TYPE_ITEM_CLASS
    );
    NestedDropdownItemEvents.addEvents(x, O);
    const D = NestedDropdown.create();
    O.appendChild(D), x._activeOverlayElements.columnTypeDropdown = D;
  }
};
_ColumnTypeDropdown.COLUMN_TYPE_ITEM_CLASS = "dropdown-column-type-item";
let ColumnTypeDropdown = _ColumnTypeDropdown;
const _ColumnDropdownItem = class tr {
  static resetItems(x) {
    Array.from(x.children).forEach((w) => DropdownItem.toggleItem(w, !0));
  }
  static addItems(x, w) {
    setTimeout(() => {
      DropdownItem.addTitle(w, "Property type"), ColumnTypeDropdown.create(x, w), DropdownItem.addDivider(w), ColumnDropdownButtonItemConf.ITEMS.slice(0, 2).forEach((O) => {
        DropdownItem.addButtonItem(x, w, O, tr.SORT_ITEM_CLASS);
      }), ColumnDropdownButtonItemConf.ITEMS.slice(2).forEach((O) => {
        DropdownItem.addButtonItem(x, w, O);
      });
    });
  }
  // hide divider when there are no items below
  static hideDivider(x) {
    x.slice(4).find((w) => w.style.display !== "none") || DropdownItem.toggleItem(x[3], !1);
  }
  static toggleItems(x, w) {
    const { isSortAvailable: O, isDeleteAvailable: D, isInsertLeftAvailable: U, isInsertRightAvailable: W, isMoveAvailable: X } = x;
    O || (DropdownItem.toggleItem(w[4], !1), DropdownItem.toggleItem(w[5], !1)), U || DropdownItem.toggleItem(w[6], !1), W || DropdownItem.toggleItem(w[7], !1), X || (DropdownItem.toggleItem(w[8], !1), DropdownItem.toggleItem(w[9], !1)), D || DropdownItem.toggleItem(w[10], !1), tr.hideDivider(w);
  }
  // prettier-ignore
  static setUpInputElement(x, w, O, D, U) {
    var W, X, G;
    const { isCellTextEditable: Y, isHeaderTextEditable: K } = x._columnsDetails[w].settings;
    if ((G = (X = (W = x._defaultColumnsSettings.columnDropdown) == null ? void 0 : W.displaySettings) == null ? void 0 : X.openMethod) != null && G.overlayClick || (ObjectUtils.areValuesFullyDefined(K) ? !K : !Y))
      DropdownItem.toggleItem(D, !1);
    else {
      const Z = D.children[0];
      Z.value = x.data[0][w], ColumnDropdownItemEvents.setInputItemEvent(x, w, O, Z, U);
    }
  }
  static setUp(x, w, O, D) {
    ColumnTypeDropdown.setUp(x, w, O);
    const U = Array.from(w.children);
    tr.setUpInputElement(x, O, D, U[0], w), tr.toggleItems(x._columnsDetails[O].settings.columnDropdown, U), tr.updateItemsStyle(x, O, w), ColumnDropdownItemEvents.setItemEvents(x, O, w);
  }
  static updateMoveColumnItemsStyle(x, w, O) {
    const { isMoveAvailable: D } = x._columnsDetails[w].settings.columnDropdown;
    D && (DropdownItem.toggleUsability(O[8], !0), DropdownItem.toggleUsability(O[9], !0), w === 0 && DropdownItem.toggleUsability(O[8], !1), w === x._columnsDetails.length - 1 && DropdownItem.toggleUsability(O[9], !1));
  }
  static updateInsertColumnItemsStyle(x, w) {
    MaximumColumns.canAddMore(x) ? (DropdownItem.toggleUsability(w[6], !0), DropdownItem.toggleUsability(w[7], !0)) : (DropdownItem.toggleUsability(w[6], !1), DropdownItem.toggleUsability(w[7], !1));
  }
  static updateItemsStyle(x, w, O) {
    const D = Array.from(O.children);
    tr.updateInsertColumnItemsStyle(x, D), tr.updateMoveColumnItemsStyle(x, w, D);
  }
};
_ColumnDropdownItem.SORT_ITEM_CLASS = "dropdown-sort-item";
let ColumnDropdownItem = _ColumnDropdownItem;
class ColumnDropdown {
  static resetDropdownPosition(x) {
    x.style.left = "";
  }
  // prettier-ignore
  static processTextAndHide(x) {
    var w;
    const { _activeOverlayElements: O, _columnsDetails: D, _focusedElements: { cell: { element: U, columnIndex: W } } } = x, { columnDropdown: X, columnTypeDropdown: G, fullTableOverlay: Y } = O;
    !X || !Y || !G || !U || (GenericElementUtils.doesElementExistInDom(U) && (CellEvents.setCellToDefaultIfNeeded(x, 0, W, U), HeaderText.onAttemptChange(x, U, W)), CellHighlightUtils.fade(U, (w = D[W]) == null ? void 0 : w.headerStateColors.default), Dropdown.hide(X, Y, G), ColumnTypeDropdownItem.reset(G), ColumnDropdown.resetDropdownPosition(X), ColumnDropdownItem.resetItems(X), DropdownItemHighlightUtils.fadeCurrentlyHighlighted(O));
  }
  static create(x) {
    const w = Dropdown.createBase();
    return ColumnDropdownEvents.set(x, w), DropdownItem.addInputItem(x, w), ColumnDropdownItem.addItems(x, w), w;
  }
  // prettier-ignore
  static getDefaultDropdownTopPosition(x, w, O) {
    return O ? `${Browser.IS_FIREFOX ? 1 + w.topWidth : 1}px` : `${ElementOffset.processTop(x.offsetTop + x.offsetHeight, w)}px`;
  }
  static getTopPosition(x, w) {
    var O, D, U;
    const W = (U = (D = (O = x._defaultColumnsSettings.columnDropdown) == null ? void 0 : O.displaySettings) == null ? void 0 : D.openMethod) == null ? void 0 : U.overlayClick;
    if (x._overflow) {
      const X = x._overflow.overflowContainer;
      return `${W ? X.scrollTop + 1 : X.scrollTop + w.offsetHeight}px`;
    } else if (x._stickyProps.header) {
      const X = w.parentElement.offsetTop;
      return `${(W ? 1 : w.offsetHeight) + X}px`;
    }
    return ColumnDropdown.getDefaultDropdownTopPosition(w, x._tableDimensions.border, W);
  }
  static getLeftPropertyToCenterDropdown(x, w) {
    return `${ElementOffset.processLeft(x.offsetLeft + x.offsetWidth / 2, w) - Dropdown.DROPDOWN_WIDTH / 2}px`;
  }
  static displayAndSetDropdownPosition(x, w, O) {
    O.style.left = ColumnDropdown.getLeftPropertyToCenterDropdown(w, x._tableDimensions.border), O.style.top = ColumnDropdown.getTopPosition(x, w), Dropdown.display(O);
    const D = ElementVisibility.getDetailsInWindow(O, x._tableDimensions.border);
    D.isFullyVisible || (D.blockingSides.has(SIDE.LEFT) ? O.style.left = "0px" : D.blockingSides.has(SIDE.RIGHT) && (O.style.left = `${w.offsetLeft + w.offsetWidth - Dropdown.DROPDOWN_WIDTH}px`));
  }
  // no active table based overflow - REF-37
  static displayAndSetPositionForSticky(x, w, O) {
    O.style.left = ColumnDropdown.getLeftPropertyToCenterDropdown(w, x._tableDimensions.border), O.style.top = ColumnDropdown.getTopPosition(x, w), Dropdown.display(O);
  }
  // prettier-ignore
  static displayAndSetPositionForOverflow(x, w, O) {
    const { _tableElementRef: D, _overflow: U, _tableDimensions: W } = x;
    if (!D || !(U != null && U.overflowContainer))
      return;
    const X = U.overflowContainer;
    O.style.left = ColumnDropdown.getLeftPropertyToCenterDropdown(w, W.border), O.style.top = ColumnDropdown.getTopPosition(x, w), Dropdown.display(O), D.offsetWidth !== X.scrollWidth ? O.style.left = `${D.offsetWidth - O.offsetWidth}px` : O.offsetLeft < 0 && (O.style.left = "0px");
  }
  static display(x, w) {
    const O = x._activeOverlayElements.columnDropdown, D = x._columnsDetails[w].elements[0];
    ColumnDropdownItem.setUp(x, O, w, D), x._overflow ? ColumnDropdown.displayAndSetPositionForOverflow(x, D, O) : x._stickyProps.header ? ColumnDropdown.displayAndSetPositionForSticky(x, D, O) : ColumnDropdown.displayAndSetDropdownPosition(x, D, O);
    const U = DropdownItem.getInputElement(O);
    U && DropdownItemNavigation.focusInputElement(U), FullTableOverlayElement.display(x);
  }
}
class FullTableOverlayEvents {
  // prettier-ignore
  static onMouseDown(x) {
    const { _activeOverlayElements: { columnDropdown: w, rowDropdown: O } } = this;
    Dropdown.isDisplayed(w) && !Dropdown.isPartOfDropdownElement(x.target) && ColumnDropdown.processTextAndHide(this), Dropdown.isDisplayed(O) && RowDropdown.hide(this);
  }
}
class FullTableOverlayElement {
  // at offsets is a bug fix for a situation where the user was able to click the table border, focus and unfocus a cell
  // and therefore not allow the column dropdown to close because there is nothing focused
  static display(x) {
    var w;
    const O = x._activeOverlayElements.fullTableOverlay;
    if (O.style.width = `${x.offsetWidth}px`, O.style.height = `${x.offsetHeight}px`, (w = x._overflow) != null && w.overflowContainer)
      O.style.top = `${x.offsetTop}px`, O.style.left = `${x.offsetLeft}px`;
    else {
      const D = x._tableElementRef.offsetTop - x.offsetTop;
      O.style.top = `-${Browser.IS_FIREFOX ? D : D + x._tableDimensions.border.topWidth}px`, O.style.left = `-${Browser.IS_FIREFOX ? 0 : x._tableDimensions.border.leftWidth}px`;
    }
    Dropdown.display(O);
  }
  static create(x) {
    const w = document.createElement("div");
    return w.id = "full-table-overlay", w.style.backgroundColor = SEMI_TRANSPARENT_COLOR, w.style.display = "none", w.onmousedown = FullTableOverlayEvents.onMouseDown.bind(x), w;
  }
}
class RowDropdownEvents {
  // the reason why we track window key events is because the table is not actually focused when it is displayed,
  // (unlike column dropdown which has an input), hence initially clicking tab does not focus the dropdown and
  // instead we need to focus it programmatically here. Once focused, the actual dropdown events can take over.
  // prettier-ignore
  static windowOnKeyDown(x, w) {
    const { _activeOverlayElements: { rowDropdown: O, fullTableOverlay: D }, shadowRoot: U } = x;
    x._focusedElements.rowDropdown || !O || !D || (w.key === KEYBOARD_KEY.ENTER || w.key === KEYBOARD_KEY.ESCAPE ? RowDropdown.hide(x) : U != null && U.activeElement || (w.key === KEYBOARD_KEY.TAB || w.key === KEYBOARD_KEY.ARROW_DOWN ? (w.preventDefault(), x._focusedElements.rowDropdown = O, DropdownItemNavigation.focusSiblingItem(O.children[0], O, !0, !0)) : w.key === KEYBOARD_KEY.ARROW_UP && (x._focusedElements.rowDropdown = O, DropdownItemNavigation.focusSiblingItem(
      O.children[O.children.length - 1],
      O,
      !1,
      !0
    ))));
  }
  static dropdownOnKeyDown(x, w) {
    if (w.key === KEYBOARD_KEY.ENTER) {
      const O = w.target;
      O.dispatchEvent(new Event("mouseenter")), O.dispatchEvent(new Event("click"));
    } else
      w.key === KEYBOARD_KEY.ESCAPE && RowDropdown.hide(this);
    DropdownEvents.itemKeyNavigation(this.shadowRoot, x, w);
  }
  static set(x, w) {
    w.onkeydown = RowDropdownEvents.dropdownOnKeyDown.bind(x, w);
  }
}
class RowDropdownButtonItemConf {
}
RowDropdownButtonItemConf.ITEMS = [
  {
    text: "Insert Up",
    iconSettings: {
      svgString: INSERT_UP_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginRight: "1px" } }
    }
  },
  {
    text: "Insert Down",
    iconSettings: {
      svgString: INSERT_DOWN_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginRight: "1px" } }
    }
  },
  {
    text: "Move Up",
    iconSettings: {
      svgString: MOVE_UP_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginRight: "8px", marginTop: "3.5px" } }
    }
  },
  {
    text: "Move Down",
    iconSettings: {
      svgString: MOVE_DOWN_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "2px", marginRight: "6px", marginTop: "3.5px" } }
    }
  },
  {
    text: "Delete",
    iconSettings: {
      svgString: TRASH_ICON_SVG_STRING,
      containerStyles: { dropdown: { marginLeft: "-4px", marginRight: "5px", marginTop: "-1px" } }
    }
  }
];
class IndexColumnEvents {
  static mouseEnterCell(x, w) {
    const O = w.target, { cellColors: D } = this._frameComponents, U = FrameComponentsColors.getColorsBasedOnParam(D, x);
    CellHighlightUtils.highlight(O, U.hover);
  }
  static mouseLeaveCell(x, w) {
    if (!Dropdown.isDisplayed(this._activeOverlayElements.rowDropdown)) {
      const { cellColors: O } = this._frameComponents, D = FrameComponentsColors.getColorsBasedOnParam(O, x);
      CellHighlightUtils.fade(w.target, D.default);
    }
  }
  static setEvents(x, w, O) {
    var D;
    w.onmouseenter = IndexColumnEvents.mouseEnterCell.bind(x, O), w.onmouseleave = IndexColumnEvents.mouseLeaveCell.bind(x, O);
    const { displaySettings: U, canEditHeaderRow: W } = x.rowDropdown;
    !W && O === 0 || (U.isAvailable && (D = U.openMethod) != null && D.cellClick ? w.onclick = RowDropdown.display.bind(x, O, w) : RowDropdownCellOverlayEvents.addCellEvents(x, O, w));
  }
}
class UpdateCellsForRows {
  // prettier-ignore
  static updateRowCells(x, w, O, D, U = !0) {
    var W;
    if (ExtractElements.textCellsArrFromRow(w).forEach((X, G) => {
      D !== CELL_UPDATE_TYPE.REMOVED && CellEventsReset.reset(x, X, O, G), U && FireEvents.onCellUpdate(x, CellElement.getText(X), O, G, D);
    }), D !== CELL_UPDATE_TYPE.REMOVED) {
      const X = w.children[0];
      if (x._frameComponents.displayIndexColumn && (IndexColumnEvents.setEvents(x, X, O), DragRow.applyEventsToElement(x, X, X)), (W = x.rowDropdown.displaySettings.openMethod) != null && W.overlayClick) {
        const G = RowDropdownCellOverlayEvents.setOverlayEvents(x, O, X);
        DragRow.applyEventsToElement(x, G, X);
      }
    }
  }
  static updateLastRow(x, w, O) {
    var D;
    (D = x._tableBodyElementRef) != null && D.children && UpdateCellsForRows.updateRowCells(x, O.element, O.index, w);
  }
  static updateLowerBeforeLastRows(x, w, O) {
    var D;
    const U = (D = x._tableBodyElementRef) == null ? void 0 : D.children;
    U && Array.from(U).slice(w, O).forEach((W, X) => {
      const G = X + w, Y = W;
      UpdateCellsForRows.updateRowCells(x, Y, G, CELL_UPDATE_TYPE.UPDATE);
    });
  }
  // REF-20
  // the reason why last row details need to be passed here is because after removal of last row, the last element details
  // are no longer available as this class's methods are run in setTimeouts, hence those details need to be captured
  // before these methods are executed
  // CAUTION-2 if the addition or removal of row causes the parent div to change width, this is indeed run after rerender,
  // however the onCellUpdate messages are required and event rebinding here still appears to be valid
  // prettier-ignore
  static rebindAndFireUpdates(x, w, O, D) {
    UpdateCellsForRows.updateLowerBeforeLastRows(x, w, D.index), UpdateCellsForRows.updateLastRow(x, O, D);
  }
}
class RemoveRow {
  // when the last row has been removed, there are no more columns
  static removeAllColumnsDetails(x) {
    const { _columnsDetails: w } = x;
    w.forEach((O) => RemoveColumn.reduceStaticWidthTotal(x, O.settings)), w.splice(0, w.length);
  }
  static update(x, w, O, D) {
    const U = { element: O, index: D };
    UpdateCellsForRows.rebindAndFireUpdates(x, w, CELL_UPDATE_TYPE.REMOVED, U), setTimeout(() => FireEvents.onDataUpdate(x)), !x._isRendering && (x.data.length === 0 && RemoveRow.removeAllColumnsDetails(x), x._addColumnCellsElementsRef.splice(w, 1));
  }
  static rowToBeRemovedIndexWhenPagination(x, w) {
    var O;
    const D = (O = x._tableBodyElementRef) == null ? void 0 : O.children[w];
    return x._pagination.visibleRows.findIndex((U) => U === D);
  }
  static removeRow(x, w) {
    var O;
    const D = x.pagination ? RemoveRow.rowToBeRemovedIndexWhenPagination(x, w) : 0;
    (O = x._tableBodyElementRef) == null || O.children[w].remove(), x._rowDropdownCellOverlays.splice(w, 1);
    const U = x.data.splice(w, 1);
    return U[0].forEach((W, X) => {
      x._columnsDetails[X].elements.splice(w, 1), x._columnsDetails[X].processedStyle.splice(w, 1);
    }), x.pagination && PaginationUtils.updateOnRowChange(x, D), U[0];
  }
  // REF-27
  static changeRowIndexIfRemoveHeaderWithDataBelow(x, w) {
    return w === 0 && x._columnsDetails[0].elements.length > 1 ? (MoveRow.move(x, 0, !0), 1) : w;
  }
  static remove(x, w) {
    var O;
    w = RemoveRow.changeRowIndexIfRemoveHeaderWithDataBelow(x, w);
    const D = x.data.length - 1, U = (O = x._tableBodyElementRef) == null ? void 0 : O.children[D];
    RemoveRow.removeRow(x, w), ToggleAdditionElements.update(x, !1, AddNewRowElement.toggle), x._frameComponents.displayIndexColumn && IndexColumn.updateIndexes(x, w), CustomRowProperties.update(x, w), setTimeout(() => RemoveRow.update(x, w, U, D));
  }
}
class RowDropdownItemEvents {
  static onClickMiddleware(x) {
    x(), RowDropdown.hide(this);
  }
  // prettier-ignore
  static set(x, w, O) {
    const D = w.getElementsByClassName(DropdownItem.DROPDOWN_ITEM_CLASS)[0], U = ElementSiblingIterator.create(D);
    U.currentElement().onclick = RowDropdownItemEvents.onClickMiddleware.bind(
      x,
      InsertNewRow.insert.bind(this, x, O, !0)
    ), U.next().onclick = RowDropdownItemEvents.onClickMiddleware.bind(
      x,
      InsertNewRow.insert.bind(this, x, O + 1, !0)
    ), U.next().onclick = RowDropdownItemEvents.onClickMiddleware.bind(
      x,
      MoveRow.move.bind(this, x, O, !1)
    ), U.next().onclick = RowDropdownItemEvents.onClickMiddleware.bind(
      x,
      MoveRow.move.bind(this, x, O, !0)
    ), U.next().onclick = RowDropdownItemEvents.onClickMiddleware.bind(
      x,
      RemoveRow.remove.bind(this, x, O)
    );
  }
}
class RowDropdownItem {
  static updateDeleteRowItemStyle(x, w, O) {
    DropdownItem.toggleUsability(O[4], !!(w > 0 || x.rowDropdown.canEditHeaderRow));
  }
  static updateMoveRowsItemsStyle(x, w, O) {
    const { isMoveAvailable: D, canEditHeaderRow: U } = x.rowDropdown;
    D && (DropdownItem.toggleUsability(O[2], !0), DropdownItem.toggleUsability(O[3], !0), (w === 0 || w === 1 && !U) && DropdownItem.toggleUsability(O[2], !1), (w === x._columnsDetails[0].elements.length - 1 || w === 0 && !U) && DropdownItem.toggleUsability(O[3], !1));
  }
  static updateInsertRowsItemsStyle(x, w, O) {
    MaximumRows.canAddMore(x) ? (w === 0 && !x.rowDropdown.canEditHeaderRow ? DropdownItem.toggleUsability(O[0], !1) : DropdownItem.toggleUsability(O[0], !0), DropdownItem.toggleUsability(O[1], !0)) : (DropdownItem.toggleUsability(O[0], !1), DropdownItem.toggleUsability(O[1], !1));
  }
  static updateItemStyle(x, w, O) {
    const D = Array.from(w.children);
    RowDropdownItem.updateInsertRowsItemsStyle(x, O, D), RowDropdownItem.updateMoveRowsItemsStyle(x, O, D), RowDropdownItem.updateDeleteRowItemStyle(x, O, D);
  }
  static update(x, w, O) {
    RowDropdownItem.updateItemStyle(x, w, O), RowDropdownItemEvents.set(x, w, O);
  }
  static setUpItems(x, w) {
    setTimeout(() => {
      const { rowDropdown: O } = x, { isInsertUpAvailable: D, isInsertDownAvailable: U, isMoveAvailable: W, isDeleteAvailable: X } = O, G = RowDropdownButtonItemConf.ITEMS.map((Y) => DropdownItem.addButtonItem(x, w, Y));
      D || DropdownItem.toggleItem(G[0], !1), U || DropdownItem.toggleItem(G[1], !1), W || (DropdownItem.toggleItem(G[2], !1), DropdownItem.toggleItem(G[3], !1)), X || DropdownItem.toggleItem(G[4], !1);
    });
  }
}
class RowDropdown {
  // prettier-ignore
  static hide(x) {
    const {
      _activeOverlayElements: { rowDropdown: w, fullTableOverlay: O },
      _focusedElements: { cell: { element: D, rowIndex: U } },
      _frameComponents: { cellColors: W, displayIndexColumn: X }
    } = x;
    if (!w || !O || !D)
      return;
    Dropdown.hide(w, O);
    const G = FrameComponentsColors.getColorsBasedOnParam(W, U);
    X && CellHighlightUtils.fade(D, G.default), DropdownItemHighlightUtils.fadeCurrentlyHighlighted(x._activeOverlayElements), setTimeout(() => {
      delete x._focusedElements.rowDropdown, FocusedCellUtils.purge(x._focusedElements.cell);
    });
  }
  static focusCell(x, w, O) {
    const { _frameComponents: D, _focusedElements: U } = x;
    D.displayIndexColumn ? FocusedCellUtils.setIndexCell(U.cell, O, w) : FocusedCellUtils.set(U.cell, O, w, 0);
  }
  // prettier-ignore
  static correctPositionWhenBottomOverflow(x, w, O) {
    const { top: D } = w.parentElement.getBoundingClientRect(), U = D + x.border.topWidth;
    let W = window.innerHeight - U - w.offsetHeight;
    Browser.IS_FIREFOX && (W += x.border.topWidth), w.style.top = `${W}px`;
    const X = ElementVisibility.getDetailsInWindow(w, x.border);
    !X.isFullyVisible && X.blockingSides.has(SIDE.TOP) && (w.style.top = O);
  }
  static getLeft(x, w) {
    var O;
    const D = (O = x.rowDropdown.displaySettings.openMethod) == null ? void 0 : O.cellClick;
    return `${ElementOffset.processWidth(D ? w.offsetWidth : 5, x._tableDimensions.border)}px`;
  }
  static displayAndSetPosition(x, w, O) {
    const D = `${ElementOffset.processTop(w.offsetTop, x._tableDimensions.border)}px`;
    O.style.top = D, O.style.left = RowDropdown.getLeft(x, w), Dropdown.display(O);
    const U = ElementVisibility.getDetailsInWindow(O, x._tableDimensions.border);
    U.isFullyVisible || U.blockingSides.has(SIDE.BOTTOM) && RowDropdown.correctPositionWhenBottomOverflow(x._tableDimensions, O, D);
  }
  // prettier-ignore
  static setOverflowPosition(x, w, O, D) {
    if (x._stickyProps.header && w.tagName === CellElement.HEADER_TAG)
      if (x._overflow)
        O.style.top = `${D.scrollTop}px`;
      else {
        const U = w.parentElement.offsetTop, W = Number.parseInt(getComputedStyle(w).borderTopWidth);
        O.style.top = `${U + W}px`;
      }
    else
      O.style.top = `${ElementOffset.processTop(w.offsetTop, x._tableDimensions.border)}px`;
    O.style.left = RowDropdown.getLeft(x, w);
  }
  // no active table based overflow
  static displayAndSetPositionForSticky(x, w, O) {
    const D = x.parentElement;
    RowDropdown.setOverflowPosition(x, w, O, D), Dropdown.display(O);
  }
  static displayAndSetPositionOverflow(x, w, O) {
    const { _tableElementRef: D, _overflow: U, _stickyProps: W } = x;
    if (!D || !(U != null && U.overflowContainer))
      return;
    RowDropdown.setOverflowPosition(x, w, O, U.overflowContainer), Dropdown.display(O);
    const X = W.header && w.tagName === CellElement.HEADER_TAG;
    D.offsetHeight !== U.overflowContainer.scrollHeight && !X && (O.style.top = `${D.offsetHeight - O.offsetHeight}px`);
  }
  static display(x, w) {
    var O;
    const D = this._activeOverlayElements.rowDropdown;
    RowDropdownItem.update(this, D, x), (O = this._overflow) != null && O.overflowContainer ? RowDropdown.displayAndSetPositionOverflow(this, w, D) : this._stickyProps.header ? RowDropdown.displayAndSetPositionForSticky(this, w, D) : RowDropdown.displayAndSetPosition(this, w, D), FullTableOverlayElement.display(this), setTimeout(() => RowDropdown.focusCell(this, x, w));
  }
  static create(x) {
    const w = Dropdown.createBase();
    return RowDropdownEvents.set(x, w), RowDropdownItem.setUpItems(x, w), w;
  }
}
class RowDropdownCellOverlayEvents {
  static mouseLeave(x, w) {
    RowDropdownCellOverlay.hide(this, x), delete this._hoveredElements.leftMostCell, RowDropdownCellOverlay.resetDefaultColor(this.rowDropdown.displaySettings, w);
  }
  static mouseEnter(x, w) {
    this._hoveredElements.leftMostCell = x, RowDropdownCellOverlay.setHoverColor(this.rowDropdown.displaySettings, w);
  }
  // prettier-ignore
  static setOverlayEvents(x, w, O) {
    const D = x._rowDropdownCellOverlays[w].element;
    return D.onmouseenter = RowDropdownCellOverlayEvents.mouseEnter.bind(
      x,
      O,
      D
    ), D.onmouseleave = RowDropdownCellOverlayEvents.mouseLeave.bind(
      x,
      w,
      D
    ), D.onclick = RowDropdown.display.bind(x, w, O), D;
  }
  static cellMouseLeave(x) {
    RowDropdownCellOverlay.hide(this, x), delete this._hoveredElements.leftMostCell;
  }
  static cellMouseEnter(x, w) {
    RowDropdownCellOverlay.display(this, x), this._hoveredElements.leftMostCell = w;
  }
  // This method is adding more events to existing cells instead of overwriting them, the reason for using this approach is
  // because we would instead need to add logic inside data cell events, select/label events, header events and more as
  // row dropdown overlay can appear above them if index column is not displayed
  // Interestingly using setting events like .onmousenter does not overwrite the events that have been added via
  // addEventListener, hence they need to be removed here before adding again
  static addCellEvents(x, w, O) {
    const { displaySettings: D, canEditHeaderRow: U } = x.rowDropdown;
    if (!D.isAvailable || !U && w === 0)
      return;
    const W = x._rowDropdownCellOverlays[w];
    if (W != null && W.cellElement) {
      const { cellElement: X, enter: G, leave: Y } = W;
      X.removeEventListener("mouseenter", G), X.removeEventListener("mouseleave", Y);
    }
    W.cellElement = O, W.enter = RowDropdownCellOverlayEvents.cellMouseEnter.bind(x, w, O), W.leave = RowDropdownCellOverlayEvents.cellMouseLeave.bind(x, w), O.addEventListener("mouseenter", W.enter), O.addEventListener("mouseleave", W.leave);
  }
}
const _RowDropdownCellOverlay = class cr {
  static setDefault(x, w) {
    var O;
    x.style.backgroundColor = ((O = w?.default) == null ? void 0 : O.backgroundColor) || "";
  }
  static resetDefaultColor(x, w) {
    var O;
    const D = x.overlayStyles;
    (O = D?.hover) != null && O.backgroundColor && cr.setDefault(w, D);
  }
  static setHoverColor(x, w) {
    var O, D;
    const U = (D = (O = x.overlayStyles) == null ? void 0 : O.hover) == null ? void 0 : D.backgroundColor;
    U && (w.style.backgroundColor = U);
  }
  static hide(x, w) {
    const O = x._hoveredElements.leftMostCell;
    setTimeout(() => {
      if (O !== x._hoveredElements.leftMostCell) {
        const D = x._rowDropdownCellOverlays[w].element;
        D.style.width = DropdownCellOverlay.HIDDEN_PX;
      }
    });
  }
  static display(x, w) {
    const O = x._columnsDetails[0], D = x._rowDropdownCellOverlays[w].element;
    D.style.width = DropdownCellOverlay.VISIBLE_PX;
    const U = O.elements[w], { displayIndexColumn: W } = x._frameComponents, X = W ? U.previousSibling : U, G = X.offsetHeight / 100;
    D.style.height = `${G * 60}px`, D.style.top = `${G * 20}px`;
    const Y = W ? O.elements[0].offsetWidth : 0;
    D.style.left = `-${X.offsetWidth + Y}px`;
  }
  static create(x) {
    const w = document.createElement("div");
    return w.classList.add(cr.ROW_DROPDOWN_CELL_OVERLAY_CLASS), w.classList.add(DropdownCellOverlay.DROPDOWN_CELL_OVERLAY_CLASS), w.style.width = DropdownCellOverlay.HIDDEN_PX, cr.setDefault(w, x), w;
  }
  static getCellDividerElement(x, w) {
    let O = x.nextSibling;
    return w && (O = O.nextSibling), O;
  }
  static add(x, w, O) {
    const D = cr.create(x.rowDropdown.displaySettings.overlayStyles), { displayIndexColumn: U } = x._frameComponents;
    cr.getCellDividerElement(O, !!U).appendChild(D), x._rowDropdownCellOverlays.splice(w, 0, {
      element: D,
      // these events are stubs and will be replaced by real ones in RowDropdownCellOverlayEvents.addCellEvents
      enter: () => {
      },
      leave: () => {
      }
    });
  }
  static resetOverlays(x) {
    var w;
    (w = x.rowDropdown.displaySettings.openMethod) != null && w.overlayClick && (x._rowDropdownCellOverlays.splice(0, x._rowDropdownCellOverlays.length), ExtractElements.textRowsArrFromTBody(x._tableBodyElementRef, x.data).forEach((O, D) => {
      const U = O.children[0];
      cr.add(x, D, U), RowDropdownCellOverlayEvents.setOverlayEvents(x, D, U);
    }));
  }
};
_RowDropdownCellOverlay.ROW_DROPDOWN_CELL_OVERLAY_CLASS = "row-dropdown-cell-overlay";
let RowDropdownCellOverlay = _RowDropdownCellOverlay;
class PaginationRowIndexes {
  static getVisibleRowRealIndex(x, w, O) {
    const D = Array.from(x.children), U = O === void 0 ? w.visibleRows.length - 1 : O, W = w.visibleRows[U];
    return D.findIndex((X) => X === W);
  }
  static getVisibleRowIndex(x, w, O) {
    const D = x.children[O];
    return w.visibleRows.findIndex((U) => U === D);
  }
  static getFilteredMaxVisibleRowIndex(x, w) {
    const { rowsPerPage: O, visibleRows: D } = w, U = PaginationRowIndexes.getVisibleRowRealIndex(x, w);
    return D.length === O ? U : U + (O - D.length);
  }
  static getRawMaxVisibleRowIndex(x) {
    const { _pagination: w, _tableBodyElementRef: O, data: D, _visiblityInternal: U } = x, { activePageNumber: W, rowsPerPage: X, isAllRowsOptionSelected: G } = w;
    return G ? D.length + 1 : U.filters ? PaginationRowIndexes.getFilteredMaxVisibleRowIndex(O, w) : W * X;
  }
  static getMaxVisibleRowIndex(x) {
    const { dataStartsAtHeader: w } = x;
    let O = PaginationRowIndexes.getRawMaxVisibleRowIndex(x);
    return w || (O += 1), O;
  }
}
const _RowElement = class rr {
  static create() {
    const x = document.createElement("tr");
    return x.classList.add("row"), x;
  }
  static moveClassToLastVisibleRow(x, w) {
    w && (w.id = ""), x.id = rr.LAST_VISIBLE_ROW_ID;
  }
  static toggleNonAddRow(x, w, O) {
    if (x.pagination && x._pagination) {
      const U = x._pagination.visibleRows[x._pagination.visibleRows.length - 1];
      if (U)
        return rr.moveClassToLastVisibleRow(U, O);
    }
    const { previousElementSibling: D } = w;
    D && rr.moveClassToLastVisibleRow(D, O);
  }
  // REF-25
  // Add new row element is always appended to the table, but not always visible (e.g. if the user has
  // chosen not to display it or max rows has been reached), hence we must always monitor its current
  // visibility and given that it can be safely assumed that it is the last row element, we can use
  // its isDisplayed method to help assign the last-visible row id to the correct row
  static toggleLastRowClass(x) {
    const w = x.shadowRoot, O = x._addRowCellElementRef.parentElement, D = w.getElementById(rr.LAST_VISIBLE_ROW_ID);
    AddNewRowElement.isDisplayed(O.children[0]) ? O.id !== rr.LAST_VISIBLE_ROW_ID && rr.moveClassToLastVisibleRow(O, D) : rr.toggleNonAddRow(x, O, D);
  }
};
_RowElement.LAST_VISIBLE_ROW_ID = "last-visible-row";
let RowElement = _RowElement;
class CellDividerElement {
  static create(x) {
    const w = document.createElement("div");
    return w.classList.add("cell-divider"), x === 0 && (w.style.height = ColumnSizerGenericUtils.canHeightBeInherited() ? "100%" : "inherit"), w;
  }
}
class InsertNewCell {
  // prettier-ignore
  static insertElementsToRow(x, w, O, D, U) {
    const W = CellElementIndex.getViaColumnIndex(D, U);
    x.insertBefore(w, x.children[W]);
    const X = CellDividerElement.create(O);
    x.insertBefore(X, x.children[W + 1]);
  }
  static updateColumnDetailsAndSizers(x, w, O, D) {
    const U = x._columnsDetails[O];
    if (U && w === 0) {
      const W = ColumnDropdownCellOverlay.add(x, O);
      ColumnDetails.updateWithNoSizer(U, W), InsertRemoveColumnSizer.insert(x, O), D && (InsertRemoveColumnSizer.cleanUpCustomColumnSizers(x, O), UpdateIndexColumnWidth.wrapTextWhenNarrowColumnsBreached(x));
    }
  }
  // prettier-ignore
  static insert(x, w, O, D, U, W, X) {
    const { _frameComponents: { displayIndexColumn: G }, data: Y, _columnsDetails: K } = x, Z = K[X];
    Z.elements.splice(W, 0, O), Z.processedStyle.splice(W, 0, ProcessedDataTextStyle.getDefaultProcessedTextStyle()), InsertNewCell.insertElementsToRow(w, O, W, X, !!G), Y[W].splice(X, U ? 0 : 1, D);
  }
  static convertCell(x, w, O, D) {
    const U = x._columnsDetails[O];
    w === 0 && x.displayHeaderIcons && HeaderIconCellElement.setHeaderIconStructure(x, D, O), U.activeType && (U.activeType.cellDropdownProps ? w === 0 ? CellDropdown.setUpDropdown(x, O) : (SelectCell.convertCell(x, O, D), SelectCell.finaliseEditedText(x, D.children[0], O, !0)) : w > 0 && (U.activeType.checkbox && CheckboxCellElement.setCellCheckboxStructure(x, D, O, w), U.activeType.calendar && DateCellElement.setCellDateStructure(x, D, O)));
  }
  // REF-13
  // prettier-ignore
  static insertInitialColumnDetails(x, w, O) {
    const { _columnsDetails: D, _customColumnsSettings: U, _cellDropdownContainer: W, _defaultColumnsSettings: X } = x, G = CellDropdown.createAndAppend(W), Y = ColumnDetails.createInitial(
      X,
      G,
      U[w],
      x._defaultCellHoverColors,
      FireEvents.onColumnsUpdate.bind(this, x)
    );
    D.splice(O, 0, Y);
  }
  // isNewText indicates whether rowData is already in the data state or if it needs to be added
  // prettier-ignore
  static insertToRow(x, w, O, D, U, W) {
    O === 0 && InsertNewCell.insertInitialColumnDetails(x, U, D);
    const X = DataUtils.processCellText(x, O, D, U), G = CellElement.createCellElement(x, X, D, O === 0);
    InsertNewCell.insert(x, w, G, X, W, O, D), InsertNewCell.convertCell(x, O, D, G), O === 0 ? (W && StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(x, !0), ColumnSettingsBorderUtils.updateSiblingColumns(x, D)) : ProcessedDataTextStyle.setCellStyle(x, O, D), setTimeout(() => InsertNewCell.updateColumnDetailsAndSizers(x, O, D, W));
  }
}
class InsertNewRow {
  // CAUTION-2 if the addition or removal of row causes the parent div to change width, this is indeed run after rerender,
  // however the notification messages are necessary and the rebinding does not seem to cause issues, nevertheless take
  // note of this if editing any of the logic below
  static bindAndfireCellUpdates(x, w) {
    var O;
    const D = x.data.length - 1, U = { element: (O = x._tableBodyElementRef) == null ? void 0 : O.children[D], index: D };
    UpdateCellsForRows.rebindAndFireUpdates(x, w, CELL_UPDATE_TYPE.ADD, U), setTimeout(() => FireEvents.onDataUpdate(x));
  }
  static canStartRenderCellBeAdded(x, w, O) {
    return w === 0 ? MaximumColumns.canAddMore(x) : x._columnsDetails[O];
  }
  // prettier-ignore
  static addCells(x, w, O, D, U) {
    const { _frameComponents: { displayIndexColumn: W, displayAddNewColumn: X } } = x;
    W && IndexColumn.createAndPrependToRow(x, O, D), w.forEach((G, Y) => {
      (U || InsertNewRow.canStartRenderCellBeAdded(x, D, Y)) && InsertNewCell.insertToRow(x, O, D, Y, G, U);
    }), X && AddNewColumnElement.createAndAppendToRow(x, O, D), setTimeout(() => RowDropdownCellOverlay.add(x, D, O.children[0]));
  }
  static updatePagination(x, w, O, D) {
    O ? PaginationUtils.updateOnRowChange(x, w, D) : PaginationUtils.initialRowUpdates(x, w, D);
  }
  static insertNewRow(x, w, O, D) {
    var U, W;
    const X = D || DataUtils.createEmptyStringDataArray(((U = x.data[0]) == null ? void 0 : U.length) || 1), G = RowElement.create();
    return x.pagination && InsertNewRow.updatePagination(x, w, O, G), (W = x._tableBodyElementRef) == null || W.insertBefore(G, x._tableBodyElementRef.children[w]), O && x.data.splice(w, 0, []), InsertNewRow.addCells(x, X, G, w, O), G;
  }
  // isNewText indicates whether rowData is already in the data state or if it needs to be added
  static insert(x, w, O, D) {
    if (!MaximumRows.canAddMore(x))
      return;
    const U = O && w === 0 && x._columnsDetails.length > 0;
    U && (w = 1);
    const W = InsertNewRow.insertNewRow(x, w, O, D);
    O && (ToggleAdditionElements.update(x, !0, AddNewRowElement.toggle), x._frameComponents.displayIndexColumn && IndexColumn.updateIndexes(x, w + 1), CustomRowProperties.update(x, w)), U && MoveRow.move(x, 0, !0), setTimeout(() => {
      x._isPopulatingTable ? UpdateCellsForRows.updateRowCells(x, W, w, CELL_UPDATE_TYPE.ADD) : D ? w === x.data.length - 1 && InsertNewRow.bindAndfireCellUpdates(x, 0) : InsertNewRow.bindAndfireCellUpdates(x, w);
    });
  }
  // prettier-ignore
  static insertEvent() {
    let x = this.data.length;
    if (this.pagination)
      if (this._visiblityInternal.filters && this._tableBodyElementRef)
        x = this.data.length === 1 && !this.dataStartsAtHeader ? 1 : PaginationRowIndexes.getVisibleRowRealIndex(this._tableBodyElementRef, this._pagination) + 1;
      else {
        const w = PaginationRowIndexes.getMaxVisibleRowIndex(this);
        w < x && (x = w);
      }
    InsertNewRow.insert(this, x, !0);
  }
}
class AddNewRowEvents {
  static mouseEnterCell(x, w) {
    CellHighlightUtils.highlight(w.target, x.hover);
  }
  static mouseLeaveCell(x, w) {
    CellHighlightUtils.fade(w.target, x.default);
  }
  static setCellEvents(x, w) {
    w.onclick = InsertNewRow.insertEvent.bind(x);
    const O = x._frameComponents.cellColors.data;
    w.onmouseenter = AddNewRowEvents.mouseEnterCell.bind(this, O), w.onmouseleave = AddNewRowEvents.mouseLeaveCell.bind(this, O);
  }
}
const _AddNewRowElement = class Mt {
  static isDisplayed(x) {
    return x.style.display === Mt.VISIBLE;
  }
  static setDisplay(x, w) {
    Mt.isDisplayed(x) !== w && (x.style.display = w ? Mt.VISIBLE : Mt.HIDDEN);
  }
  static setDefaultStyle(x) {
    x.innerText = "+ New", x.style.width = "";
  }
  // prettier-ignore
  static createCell(x) {
    const { _defaultColumnsSettings: { cellStyle: w }, _frameComponents: { displayAddNewRow: O, styles: D }, rootCell: U } = x, W = CellElement.createDataCell(!1, w, D?.default);
    return W.id = Mt.ID, O ? Mt.setDefaultStyle(W) : (RootCellElement.convertToRootCell(W, U?.text), W.addEventListener("click", Mt.setDisplay.bind(this, W, !1))), Mt.setDisplay(W, O), W.colSpan = Mt.DEFAULT_COL_SPAN, AddNewRowEvents.setCellEvents(x, W), W;
  }
  static create(x) {
    const w = RowElement.create(), O = Mt.createCell(x);
    return w.appendChild(O), O;
  }
  // prettier-ignore
  static toggle(x) {
    const { _tableBodyElementRef: w, _addRowCellElementRef: O, _frameComponents: { displayAddNewRow: D } } = x;
    !(O != null && O.parentElement) || !w || (D && Mt.setDisplay(O, MaximumRows.canAddMore(x)), RowElement.toggleLastRowClass(x));
  }
  static isAddNewRowRow(x) {
    var w;
    return ((w = x?.children[0]) == null ? void 0 : w.id) === Mt.ID;
  }
};
_AddNewRowElement.DEFAULT_COL_SPAN = 1e9;
_AddNewRowElement.HIDDEN = "none";
_AddNewRowElement.VISIBLE = "";
_AddNewRowElement.ID = "add-new-row-cell";
let AddNewRowElement = _AddNewRowElement;
class ElementEvents {
  static toggleListeners(x, w, O) {
    Object.keys(w).forEach((D) => {
      (w[D] || []).forEach((U) => {
        x[O ? "addEventListener" : "removeEventListener"](D, U);
      });
    });
  }
  static convertToArrayObj(x) {
    return Object.keys(x).reduce((w, O) => {
      const D = O, U = x[D];
      return D && U && (w[D] = [U]), w;
    }, {});
  }
  static getDefault() {
    return { rootCell: { styles: {} } };
  }
}
class RootCellEvents {
  static removeEvents(x, w) {
    AddNewRowElement.setDefaultStyle(x), ElementEvents.toggleListeners(x, w.styles, !1), x.dispatchEvent(new MouseEvent("mouseenter")), delete w.applied;
  }
  // setting, not apply here as this is only triggered once
  static setEventFunctions(x, w, O) {
    if (O && (x._eventFunctions.rootCell.styles = ElementEvents.convertToArrayObj(
      StatefulCSSEvents.getEvents(w, O)
    )), x._frameComponents.displayAddNewRow) {
      const D = RootCellElement.convertFromRootCell.bind(this, x), { styles: U } = x._eventFunctions.rootCell;
      U.click ?? (U.click = []), U.click.push(D);
    }
  }
  static applyStyles(x, w, O) {
    var D, U, W, X;
    const G = ElementStyle.generateStatefulCSS(w, {}, {});
    (D = G.default) != null && D.width && (O.style.width = G.default.width), (U = G.default) == null || delete U.width, (W = G.hover) == null || delete W.width, (X = G.click) == null || delete X.width, Object.assign(x.style, G.default);
  }
  // prettier-ignore
  static applyEvents(x, w) {
    const { _tableElementRef: O, rootCell: D, _eventFunctions: { rootCell: U } } = x, W = D != null && D.styles ? JSON.parse(JSON.stringify(D.styles)) : null;
    W && O && RootCellEvents.applyStyles(w, W, O), Object.keys(U.styles).length === 0 && RootCellEvents.setEventFunctions(x, w, W), ElementEvents.toggleListeners(w, U.styles, !0), U.applied = !0;
  }
}
const _RootCellElement = class br {
  // prettier-ignore
  static convertFromRootCell(x) {
    const { _addRowCellElementRef: w, rootCell: O, _eventFunctions: { rootCell: D } } = x;
    w && (w.classList.remove(br.ROOT_CELL_CLASS), O != null && O.styles && ElementStyle.unsetAllCSSStates(w, O.styles), RootCellEvents.removeEvents(w, D));
  }
  static convertToRootCell(x, w) {
    x.classList.add(br.ROOT_CELL_CLASS), x.innerText = w || "+", x.style.width = `${TableDimensionsUtils.MINIMAL_TABLE_WIDTH}px`;
  }
  // addNewRowCell is preserved as it is reused as the root cell
  static removeRows(x) {
    Array.from(x.children).slice(0, x.children.length - 1).forEach((w) => w.remove());
  }
  // prettier-ignore
  static display(x) {
    const {
      _tableBodyElementRef: w,
      _addColumnCellsElementsRef: O,
      _addRowCellElementRef: D,
      rootCell: U,
      _frameComponents: { displayAddNewColumn: W, displayAddNewRow: X }
    } = x;
    if (!D)
      return;
    const G = w;
    W && O.splice(0, O.length), br.removeRows(G), X && br.convertToRootCell(D, U?.text), x._eventFunctions.rootCell.applied || RootCellEvents.applyEvents(x, D), AddNewRowElement.setDisplay(D, !0);
  }
};
_RootCellElement.ROOT_CELL_CLASS = "root-cell";
let RootCellElement = _RootCellElement;
class ToggleAdditionElements {
  static update(x, w, O) {
    x.data.length === 0 || x._columnsDetails.length === 0 ? RootCellElement.display(x) : O(x, w);
  }
}
class InsertNewColumn {
  static updateColumns(x, w, O, D) {
    const U = { element: w, index: O }, W = LastColumn.getDetails(x._columnsDetails, O);
    UpdateCellsForColumns.rebindAndFireUpdates(x, U, D, CELL_UPDATE_TYPE.ADD, W);
  }
  static insertToAllRows(x, w, O) {
    ExtractElements.textRowsArrFromTBody(x._tableBodyElementRef, x.data).forEach((D, U) => {
      const W = O ? O[U] : EMPTY_STRING;
      InsertNewCell.insertToRow(x, D, U, w, W, !0), setTimeout(() => InsertNewColumn.updateColumns(x, D, U, w));
    });
  }
  // columnData is in a row format to populate the column by iterating through each row
  static insert(x, w, O) {
    MaximumColumns.canAddMore(x) && (FocusedCellUtils.incrementColumnIndex(x._focusedElements.cell, w), InsertNewColumn.insertToAllRows(x, w, O), ToggleAdditionElements.update(x, !0, AddNewColumnElement.toggle), setTimeout(() => {
      FireEvents.onDataUpdate(x), FireEvents.onColumnsUpdate(x);
    }));
  }
  static insertEvent() {
    InsertNewColumn.insert(this, this._columnsDetails.length);
  }
}
class InsertMatrix {
  // prettier-ignore
  static removeDataThatIsNotEditableFromNewRows(x, w, O) {
    return x.slice(O).forEach((D, U) => {
      D.settings.isCellTextEditable || w.forEach((W) => {
        W[U] = EMPTY_STRING;
      });
    }), w;
  }
  // if the data does not fill the 2D array, fill cells with empty strings
  static createRowDataArrayWithEmptyCells(x, w, O) {
    const D = DataUtils.createEmptyStringDataArray(x);
    return D.splice(O, w.length, ...w), D;
  }
  // prettier-ignore
  static createNewRows(x, w, O) {
    InsertMatrix.removeDataThatIsNotEditableFromNewRows(
      x._columnsDetails,
      w,
      O
    ).forEach((D) => {
      var U;
      const W = InsertMatrix.createRowDataArrayWithEmptyCells(
        ((U = x.data[0]) == null ? void 0 : U.length) || 0,
        D,
        O
      );
      InsertNewRow.insert(x, x.data.length, !0, W);
    });
  }
  static changeColumnSettings(x, w) {
    const { elements: O } = x._columnsDetails[w];
    FocusedCellUtils.set(x._focusedElements.cell, O[0], 0, w), HeaderText.onAttemptChange(x, O[0], w);
  }
  static processNewColumn(x) {
    const w = x._columnsDetails.length - 1;
    CellEvents.setCellToDefaultIfNeeded(x, 0, w, x._columnsDetails[w].elements[0], !1), InsertMatrix.changeColumnSettings(x, w);
  }
  // prettier-ignore
  static createNewColumns(x, w, O) {
    ArrayUtils.transpose(w).forEach((D) => {
      const U = InsertMatrix.createRowDataArrayWithEmptyCells(
        x.data.length,
        D,
        O
      );
      InsertNewColumn.insert(x, x.data[0].length, U), InsertMatrix.processNewColumn(x);
    });
  }
  // prettier-ignore
  static overwriteCell(x, w, O, D, U) {
    const { _frameComponents: { displayIndexColumn: W }, _columnsDetails: X } = x, G = CellElementIndex.getViaColumnIndex(D, !!W), Y = w.children[G], K = X[D];
    O === 0 && !K.settings.isHeaderTextEditable || O > 0 && !K.settings.isCellTextEditable || (O === 0 && CellElement.setNewText(x, Y, U, !1, !1), CellEvents.updateCell(x, U, O, D, { element: Y, updateTableEvent: !1 }), ColumnTypesUtils.updateDataElements(x, O, D, Y), O === 0 && InsertMatrix.changeColumnSettings(x, D));
  }
  // prettier-ignore
  static overwriteRowData(x, w, O, D, U) {
    w.forEach((W, X) => {
      const G = D + X;
      InsertMatrix.overwriteCell(x, U, O, G, W);
    });
  }
  // prettier-ignore
  static setCaretToEndAndHighlightIfSelect(x, w, O) {
    const { activeType: D, cellDropdown: U, settings: { defaultText: W } } = x._columnsDetails[O];
    CaretPosition.setToEndOfText(x, w), D.cellDropdownProps && CellDropdown.updateCellDropdown(w, U, x._tableDimensions.border, W, !0);
  }
  // prettier-ignore
  static overwriteExistingCells(x, w, O, D) {
    const U = [];
    w.forEach((X, G) => {
      var Y;
      const K = O + G, Z = (Y = x._tableBodyElementRef) == null ? void 0 : Y.children[K], q = x.data[0].length - D, J = X.slice(0, q);
      InsertMatrix.overwriteRowData(x, J, K, D, Z);
      const ee = X.slice(q);
      U.push(ee);
    });
    const W = x._focusedElements.cell.element;
    return setTimeout(() => InsertMatrix.setCaretToEndAndHighlightIfSelect(x, W, D)), U;
  }
  // no new rows should be created if no columns that are to be overwritten/created allow text edit
  static canNewRowsBeCreated(x, w, O) {
    return x._columnsDetails.slice(O, O + w[0].length).find((D) => D.settings.isCellTextEditable);
  }
  static insertColumnsInsideIfCantInsertRight(x, w, O) {
    const D = x._columnsDetails.slice(O).findIndex((U) => U.settings.columnDropdown.isInsertRightAvailable === !1);
    if (D !== -1)
      if (D === 0)
        w.forEach((U) => U.splice(1, U.length - 1));
      else {
        const U = w[0].length - (D + 1);
        for (let W = 0; W < U; W += 1)
          InsertNewColumn.insert(x, O + D + W);
      }
  }
  static getNewMatrixBasedOnColumns(x, w, O) {
    var D, U;
    const W = (((D = x[0]) == null ? void 0 : D.length) || 0) - (((U = w[0]) == null ? void 0 : U.length) || 0) - O;
    return W > 0 ? new Array(w.length).fill(new Array(W).fill(EMPTY_STRING)) : [];
  }
  // A matrix is a complete 2D array
  // prettier-ignore
  static insert(x, w, O, D, U) {
    const W = x.data.length - O;
    U || InsertMatrix.insertColumnsInsideIfCantInsertRight(x, w, D);
    const X = w.slice(0, W), G = U ? InsertMatrix.getNewMatrixBasedOnColumns(w, x.data, D) : InsertMatrix.overwriteExistingCells(x, X, O, D);
    if (InsertMatrix.createNewColumns(x, G, O), !U && !InsertMatrix.canNewRowsBeCreated(x, w, D))
      return;
    const Y = w.slice(W);
    InsertMatrix.createNewRows(x, Y, D), setTimeout(() => FireEvents.onDataUpdate(x));
  }
}
const _ParseCSVClipboardText = class Rt {
  static preprocessText(x) {
    let w = x;
    return x.charAt(0) === Rt.STRING_QUOTE_SYMBOL && (w = w.substring(1)), x.charAt(x.length - 1) === Rt.STRING_QUOTE_SYMBOL && (w = w.substring(0, x.length - 2)), w;
  }
  static getSeparatorSymbols(x) {
    return x.indexOf(Rt.EXPLICIT_WINDOWS_NEW_LINE_SYMBOL) > -1 ? {
      newLine: Rt.EXPLICIT_WINDOWS_NEW_LINE_SYMBOL,
      tab: Rt.EXPLICIT_TAB_SYMBOL
    } : x.indexOf(Rt.WINDOWS_NEW_LINE_SYMBOL) > -1 ? { newLine: Rt.WINDOWS_NEW_LINE_SYMBOL, tab: Rt.TAB_SYMBOL } : x.indexOf(Rt.EXPLICIT_NEW_LINE_SYMBOL) > -1 || x.indexOf(Rt.EXPLICIT_TAB_SYMBOL) > -1 ? { newLine: Rt.EXPLICIT_NEW_LINE_SYMBOL, tab: Rt.EXPLICIT_TAB_SYMBOL } : { newLine: Rt.NEW_LINE_SYMBOL, tab: Rt.TAB_SYMBOL };
  }
  static parse(x) {
    const w = Rt.preprocessText(x), { newLine: O, tab: D } = Rt.getSeparatorSymbols(w);
    return w.split(O).map((U) => U.split(D).map((W) => W.replace(/\\"/g, "")));
  }
};
_ParseCSVClipboardText.STRING_QUOTE_SYMBOL = '"';
_ParseCSVClipboardText.TAB_SYMBOL = "\\t";
_ParseCSVClipboardText.NEW_LINE_SYMBOL = "\\n";
_ParseCSVClipboardText.EXPLICIT_TAB_SYMBOL = "\\\\t";
_ParseCSVClipboardText.EXPLICIT_NEW_LINE_SYMBOL = "\\\\n";
_ParseCSVClipboardText.WINDOWS_NEW_LINE_SYMBOL = "\\r\\n";
_ParseCSVClipboardText.EXPLICIT_WINDOWS_NEW_LINE_SYMBOL = "\\\\r\\\\n";
let ParseCSVClipboardText = _ParseCSVClipboardText;
class OverwriteCellsViaCSVOnPaste {
  static trimCSVRowsIfPaginationAsync(x, w, O, D) {
    var U;
    const W = x.length + O;
    w.length < W && (x = x.slice(0, x.length - (W - w.length)));
    const X = ((U = w[0]) == null ? void 0 : U.length) || 0, G = x[0].length + D;
    if (X < G) {
      const Y = x[0].length - (G - X);
      x.forEach((K) => K.splice(Y));
    }
    return x;
  }
  static focusOriginalCellAfterProcess(x, w) {
    const { element: O, rowIndex: D, columnIndex: U } = x._focusedElements.cell;
    w(), FocusedCellUtils.set(x._focusedElements.cell, O, D, U);
  }
  // prettier-ignore
  static overwrite(x, w, O, D, U) {
    O.preventDefault();
    let W = ParseCSVClipboardText.parse(w);
    x._pagination.async && (W = OverwriteCellsViaCSVOnPaste.trimCSVRowsIfPaginationAsync(W, x.data, D, U)), OverwriteCellsViaCSVOnPaste.focusOriginalCellAfterProcess(
      x,
      InsertMatrix.insert.bind(this, x, W, D, U)
    );
  }
  static isCSVData(x) {
    return x.indexOf(ParseCSVClipboardText.NEW_LINE_SYMBOL) > -1 || x.indexOf(ParseCSVClipboardText.TAB_SYMBOL) > -1;
  }
}
var KEYBOARD_COMBINATION_EVENT = /* @__PURE__ */ ((F) => (F.PASTE = "Paste", F))(KEYBOARD_COMBINATION_EVENT || {});
const KEYBOARD_EVENT = { ...KEYBOARD_COMBINATION_EVENT, [KEYBOARD_KEY.TAB]: KEYBOARD_KEY.TAB }, _UserKeyEventsStateUtils = class ea {
  static createNew() {
    return { [KEYBOARD_KEY.TAB]: !1, [KEYBOARD_EVENT.PASTE]: !1, [MOUSE_EVENT.DOWN]: !1 };
  }
  static temporarilyIndicateEvent(x, w) {
    x[w] = !0, setTimeout(() => x[w] = !1, ea.KEY_PRESS_STATE_TIMEOUT_ML);
  }
};
_UserKeyEventsStateUtils.KEY_PRESS_STATE_TIMEOUT_ML = 5;
let UserKeyEventsStateUtils = _UserKeyEventsStateUtils;
const _PasteUtils = class ta {
  static sanitizePastedTextData(x) {
    var w, O;
    x.preventDefault();
    const D = (w = x.clipboardData) == null ? void 0 : w.getData("text/plain");
    (O = document.execCommand) == null || O.call(document, "insertHTML", !1, D);
  }
  static extractClipboardText(x) {
    var w;
    return JSON.stringify((w = x.clipboardData) == null ? void 0 : w.getData(ta.TEXT_DATA_FORMAT));
  }
};
_PasteUtils.TEXT_DATA_FORMAT = "text/plain";
let PasteUtils = _PasteUtils;
const UNDO_INPUT_TYPE = "historyUndo";
class DataCellEvents {
  static keyDownCell(x, w, O) {
    const { elements: D, activeType: U } = this._columnsDetails[w];
    O.key === KEYBOARD_KEY.TAB ? UserKeyEventsStateUtils.temporarilyIndicateEvent(this._userKeyEventsState, KEYBOARD_KEY.TAB) : O.key === KEYBOARD_KEY.ENTER && this.enterKeyMoveDown && !U.cellDropdownProps && FocusNextRowCell.focus(this, x, D, O);
  }
  // using this instead of keydown because when this is fired the new cell text is available
  // prettier-ignore
  static inputCell(x, w, O) {
    const D = O, U = D.target;
    if (DateCellInputElement.isInputElement(U))
      return;
    const W = CellElement.getText(U);
    if (!this._userKeyEventsState[KEYBOARD_EVENT.PASTE]) {
      const X = D.inputType === UNDO_INPUT_TYPE;
      CellElement.setNewText(this, U, W, !1, X, !1);
      const G = this._columnsDetails[w];
      G.activeType.cellDropdownProps && x > 0 && CellDropdown.updateCellDropdown(
        U,
        G.cellDropdown,
        this._tableDimensions.border,
        G.settings.defaultText,
        !0
      ), CellEvents.updateCell(this, W, x, w, { processText: !1 });
    }
  }
  // prettier-ignore
  static pasteCell(x, w, O) {
    UserKeyEventsStateUtils.temporarilyIndicateEvent(this._userKeyEventsState, KEYBOARD_EVENT.PASTE), PasteUtils.sanitizePastedTextData(O);
    const D = PasteUtils.extractClipboardText(O);
    if (OverwriteCellsViaCSVOnPaste.isCSVData(D))
      OverwriteCellsViaCSVOnPaste.overwrite(this, D, O, x, w);
    else {
      const U = O.target, { cellDropdown: W, settings: { defaultText: X }, activeType: G } = this._columnsDetails[w], Y = U.tagName === "BR" ? U.parentElement : U;
      setTimeout(() => {
        G.cellDropdownProps && CellDropdown.updateCellDropdown(
          Y,
          W,
          this._tableDimensions.border,
          X,
          !0
        ), CellEvents.updateCell(this, CellElement.getText(Y), x, w, { processText: !1 });
      });
    }
  }
  // prettier-ignore
  // textContainerElement can be cell element for data cell, text element for select/label and date cells
  static blur(x, w, O, D) {
    CaretDisplayFix.isIssueBrowser() && CaretDisplayFix.removeContentEditable(D), CellEvents.setCellToDefaultIfNeeded(x, w, O, D), FocusedCellUtils.purge(x._focusedElements.cell);
  }
  static blurCell(x, w, O) {
    var D, U, W;
    x === 0 && !((W = (U = (D = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : D.displaySettings) == null ? void 0 : U.openMethod) != null && W.cellClick) && HeaderText.onAttemptChange(this, O.target, w), DataCellEvents.blur(this, x, w, O.target);
  }
  // textContainerElement can be cell element for data cell, text element for select/label and date cells
  static prepareText(x, w, O, D) {
    var U, W, X;
    const G = (X = (W = (U = x._defaultColumnsSettings.columnDropdown) == null ? void 0 : U.displaySettings) == null ? void 0 : W.openMethod) == null ? void 0 : X.cellClick;
    CaretDisplayFix.isIssueBrowser() && (w > 0 || !G) && CaretDisplayFix.setContentEditable(D), CellEvents.removeTextIfDefault(x, w, O, D);
  }
  static focusCell(x, w, O) {
    const D = O.target;
    DataCellEvents.prepareText(this, x, w, D);
    const { _userKeyEventsState: U, _focusedElements: W } = this;
    U[KEYBOARD_KEY.TAB] && CaretPosition.setToEndOfText(this, D), FocusedCellUtils.set(W.cell, D, x, w);
  }
  static setEvents(x, w, O, D) {
    w.onfocus = DataCellEvents.focusCell.bind(x, O, D), w.onblur = DataCellEvents.blurCell.bind(x, O, D), w.onmouseenter = () => {
    }, w.onmouseleave = () => {
    }, w.onmousedown = () => {
    }, w.oninput = DataCellEvents.inputCell.bind(x, O, D), w.onpaste = DataCellEvents.pasteCell.bind(x, O, D), w.onkeydown = DataCellEvents.keyDownCell.bind(x, O, D);
  }
}
class SelectCellTextBaseEvents {
  // the reason why this is triggered by window is because when the user clicks on dropdown padding or delete button
  // keydown events will no longer be fired through the cell text - however we need to maintain the same behaviour
  // prettier-ignore
  static keyDownText(x, w, O, D) {
    const { cellDropdown: { activeItems: U, canAddMoreOptions: W }, elements: X } = x._columnsDetails[O];
    D.key === KEYBOARD_KEY.ESCAPE ? CellWithTextEvents.programmaticBlur(x) : D.key === KEYBOARD_KEY.TAB ? CellTextEvents.tabOutOfCell(x, w, O, D) : D.key === KEYBOARD_KEY.ENTER ? (D.preventDefault(), FocusNextRowCell.focusOrBlurSelect(X, w)) : D.key === KEYBOARD_KEY.ARROW_UP ? (D.preventDefault(), CellDropdownItem.setSiblingItemOnCell(x, U, "previousSibling")) : D.key === KEYBOARD_KEY.ARROW_DOWN ? (D.preventDefault(), CellDropdownItem.setSiblingItemOnCell(x, U, "nextSibling")) : (x.dataStartsAtHeader || w > 0) && !W && D.preventDefault();
  }
  static displayDropdown(x, w, O) {
    var D;
    const U = CellDropdown.display(x, w, O), { activeType: W, cellDropdown: X } = x._columnsDetails[w];
    (D = W.cellDropdownProps) != null && D.isBasicSelect && U && (X.displayedCellElement = O, ArrowDownIconElement.toggle(O, !0), ArrowDownIconElement.setActive(O));
  }
  static clearTypeSpecificProps(x, w) {
    const { cellDropdown: O, activeType: D } = w;
    D.cellDropdownProps && (D.cellDropdownProps.isBasicSelect ? (ArrowDownIconElement.toggle(O.displayedCellElement, !1), delete O.displayedCellElement) : OptionButton.hideAfterColorPickerContainerClose(x, w));
  }
  static blurring(x, w, O, D) {
    const U = x._columnsDetails[O];
    Dropdown.hide(U.cellDropdown.element), U.cellDropdown.itemsDetails[CellElement.getText(D)] || SelectCell.finaliseEditedText(x, D, O), SelectCellTextBaseEvents.clearTypeSpecificProps(x._columnsDetails, U), DataCellEvents.blur(x, w, O, D);
  }
  static blurText(x, w, O) {
    this._focusedElements.cellDropdown || SelectCellTextBaseEvents.blurring(this, x, w, O.target);
  }
  // prettier-ignore
  static setEvents(x, w, O, D) {
    w.onblur = SelectCellTextBaseEvents.blurText.bind(x, O, D), w.onfocus = CellWithTextEvents.focusText.bind(
      x,
      O,
      D,
      SelectCellTextBaseEvents.displayDropdown
    );
  }
}
class CellWithTextEvents {
  // prettier-ignore
  static focusText(x, w, O, D) {
    const U = D.target, W = CellElement.getCellElement(U);
    DataCellEvents.prepareText(this, x, w, U), O?.(this, w, W), FocusedCellUtils.set(this._focusedElements.cell, W, x, w), this._userKeyEventsState[KEYBOARD_KEY.TAB] && CaretPosition.setToEndOfText(this, U);
  }
  static programmaticBlur(x) {
    const { rowIndex: w, columnIndex: O, element: D } = x._focusedElements.cell, U = CellElement.getTextElement(D);
    U.blur(), x._focusedElements.cellDropdown && (SelectCellTextBaseEvents.blurring(x, w, O, U), delete x._focusedElements.cellDropdown);
  }
  // prettier-ignore
  static mouseDownCell(x, w, O, D) {
    x._focusedElements.cellDropdown && CellWithTextEvents.programmaticBlur(x);
    const U = CellElement.getTextElement(O);
    D.preventDefault(), w?.(x), CaretDisplayFix.isIssueBrowser() && U.focus(), CaretPosition.setToEndOfText(x, U);
  }
  static mouseDown(x, w) {
    if (w.target.classList.contains(CellElement.CELL_CLASS)) {
      const O = w.target;
      CellWithTextEvents.mouseDownCell(this, x, O, w);
    }
  }
}
class CellDropdownScrollbar {
  static setProperties(x) {
    const { element: w, scrollbarPresence: O } = x;
    CellDropdownHorizontalScrollFix.setPropertiesIfHorizontalScrollPresent(x), O.vertical = ScrollbarUtils.isVerticalPresent(w);
  }
}
class OptionDeleteButtonEvents {
  static delete(x, w) {
    const { cellDropdown: O } = x, D = w.target.parentElement.parentElement;
    delete O.itemsDetails[CellElement.getText(D.children[0])], D.remove(), Object.keys(O.itemsDetails).length === 0 ? CellWithTextEvents.programmaticBlur(this) : CellDropdownScrollbar.setProperties(O), setTimeout(() => FireEvents.onColumnsUpdate(this));
  }
  static addEvents(x, w, O) {
    O.onclick = OptionDeleteButtonEvents.delete.bind(x, w);
  }
}
const _OptionDeleteButton = class gr {
  static createIcon() {
    const x = document.createElement("div");
    return x.classList.add(gr.DELETE_BUTTON_ICON_CLASS), x.innerText = gr.DELETE_ICON_TEXT, x;
  }
  static createButton(x, w) {
    const O = document.createElement("div");
    return O.classList.add(DropdownItem.DROPDOWN_ITEM_IDENTIFIER, OptionButton.BUTTON_CLASS), OptionDeleteButtonEvents.addEvents(x, w, O), O;
  }
  static createContainer() {
    const x = document.createElement("div");
    return x.classList.add(OptionButton.BUTTON_CONTAINER_CLASS), x;
  }
  static create(x, w) {
    const O = gr.createContainer(), D = gr.createButton(x, w), U = gr.createIcon();
    return D.appendChild(U), O.appendChild(D), O;
  }
  static changeVisibility(x, w, O) {
    const D = x.children[1];
    if (D.style.display = O ? "block" : "none", O) {
      const U = D.children[0];
      U.style.left = `${O.offsetWidth - w}px`;
    }
  }
};
_OptionDeleteButton.DELETE_BUTTON_ICON_CLASS = "cell-dropdown-option-delete-button-icon";
_OptionDeleteButton.DELETE_ICON_TEXT = "×";
let OptionDeleteButton = _OptionDeleteButton;
class OptionButton {
  static changeVisibility(x, w, O) {
    if (x.isTrusted) {
      const D = x.target, U = w.scrollbarPresence.vertical ? 31 : 16;
      OptionDeleteButton.changeVisibility(D, U, O), Browser.IS_COLOR_PICKER_SUPPORTED && w.labelDetails && !w.labelDetails.colorPickerContainer && OptionColorButton.changeVisibility(D, U + 18, O);
    }
  }
  // prettier-ignore
  static hideAfterColorPickerContainerClose(x, w) {
    const { cellDropdown: { labelDetails: O } } = w;
    if (O != null && O.colorPickerContainer) {
      O.colorPickerContainer.style.display = "none";
      const D = O.colorPickerContainer.previousElementSibling;
      D.style.display = "none", delete O.colorPickerContainer, OptionColorButtonEvents.updateColumnLabelColors(x, w);
    }
  }
}
OptionButton.BUTTON_CONTAINER_CLASS = "cell-dropdown-option-button-container";
OptionButton.BUTTON_CLASS = "cell-dropdown-option-button";
class CellDropdownItemEvents {
  // prettier-ignore
  static blurItem(x, w, O) {
    var D;
    const { activeItems: U, labelDetails: W } = x;
    if (W != null && W.colorPickerContainer)
      return;
    const X = U[w];
    X !== void 0 && (w === "matchingWithCellText" || w === "hovered" && X !== U.matchingWithCellText) && (X.style.backgroundColor = "", W || (X.style.color = ((D = x.customItemStyle) == null ? void 0 : D.textColor) || ""), delete U[w]), O && x.canAddMoreOptions && OptionButton.changeVisibility(O, x);
  }
  // prettier-ignore
  static scrollToItem(x, w, O, D, U) {
    if (U.isTrusted)
      return;
    const W = ElementVisibility.isVerticallyVisibleInsideParent(w, x);
    W.isFullyVisible || (w.scrollIntoView({ block: "nearest" }), O && W.blockingSides.has(SIDE.BOTTOM) && CellDropdownHorizontalScrollFix.scrollDownFurther(D));
  }
  static highlightItem(x, w) {
    const { scrollbarPresence: O, activeItems: D, labelDetails: U, canAddMoreOptions: W, element: X, itemsDetails: G } = x;
    if (U != null && U.colorPickerContainer)
      return;
    D.hovered && (D.hovered.style.backgroundColor = "", U || (D.hovered.style.color = ""));
    const Y = w.target, K = Y.children[0].innerText;
    Y.style.backgroundColor = G[K].backgroundColor;
    const Z = Y.parentElement;
    CellDropdownItemEvents.scrollToItem(this, Y, O.horizontal, Z, w), Y === D.matchingWithCellText ? (U || (Y.style.color = "white"), delete D.hovered) : (U || (Y.style.backgroundColor = DropdownItemHighlightUtils.HOVER_BACKGROUND_COLOR), D.hovered = Y), W && OptionButton.changeVisibility(w, x, X);
  }
  static set(x, w, O) {
    w.onmouseenter = CellDropdownItemEvents.highlightItem.bind(x, O), w.onmouseleave = CellDropdownItemEvents.blurItem.bind(this, O, "hovered");
  }
}
const _CellDropdownItem = class It {
  // prettier-ignore
  static updateCellElementIfNotUpdated(x, w, O, D, U) {
    x.data[O][D] !== w && CellEvents.updateCell(x, w, O, D, { processText: !1, element: U });
  }
  // prettier-ignore
  static selectExistingItem(x, w, O, D, U) {
    var W;
    const X = CellElement.getText(w.children[0]);
    It.updateCellElementIfNotUpdated(x, X, O, D, U), LabelCellTextElement.isLabelText(U) && (U.style.backgroundColor = (W = x._columnsDetails[D].cellDropdown.itemsDetails[X]) == null ? void 0 : W.backgroundColor);
  }
  // prettier-ignore
  static addNewItem(x, w, O, D) {
    const { cellDropdown: { labelDetails: U } } = O, W = CellElement.getText(w);
    if (W === EMPTY_STRING)
      return;
    let X = "";
    if (U) {
      const { globalItemColors: { newColors: G, existingColors: Y } } = U;
      X = D || Y[W] || G[G.length - 1] || LabelColorUtils.getLatestPasteleColor(), w.style.backgroundColor = X, Y[W] ?? (Y[W] = X), G.pop() || LabelColorUtils.setNewLatestPasteleColor();
    } else
      X = It.ACTIVE_ITEM_BACKGROUND_COLOR;
    It.addItem(x, W, X, O), setTimeout(() => FireEvents.onColumnsUpdate(x));
  }
  // prettier-ignore
  static updateCellTextBgColor(x, w, O, D) {
    const U = CellElement.getText(w);
    if (x)
      w.style.backgroundColor = O.itemsDetails[U].backgroundColor;
    else if (!O.canAddMoreOptions || U === EMPTY_STRING || U === D)
      w.style.backgroundColor = "";
    else if (O.labelDetails) {
      const { globalItemColors: { newColors: W, existingColors: X } } = O.labelDetails;
      w.style.backgroundColor = X[U] || W?.[W.length - 1] || LabelColorUtils.getLatestPasteleColor();
    }
  }
  static updateItemColor(x, w) {
    x && (w.matchingWithCellText = x, x.dispatchEvent(new MouseEvent("mouseenter")));
  }
  static hideHoveredItemHighlight(x) {
    const { hovered: w, matchingWithCellText: O } = x;
    w ? w.style.backgroundColor = "" : x.hovered = O;
  }
  // prettier-ignore
  static attemptHighlightMatchingItemWithCell(x, w, O, D, U) {
    var W;
    const { activeItems: X, itemsDetails: G } = w, Y = CellElement.getText(x), K = U || ((W = G[Y]) == null ? void 0 : W.element);
    (!K || X.matchingWithCellText !== K) && (It.hideHoveredItemHighlight(X), CellDropdownItemEvents.blurItem(w, "matchingWithCellText")), It.updateItemColor(K, X), D && w.labelDetails && It.updateCellTextBgColor(K, x, w, O);
  }
  // prettier-ignore
  static setItemOnCell(x, w) {
    const { element: O, rowIndex: D, columnIndex: U } = x._focusedElements.cell, { cellDropdown: W, settings: { defaultText: X } } = x._columnsDetails[U], G = O.children[0], Y = CellElement.getText(w.children[0]);
    It.updateCellElementIfNotUpdated(x, Y, D, U, G), It.attemptHighlightMatchingItemWithCell(G, W, X, !0, w), CaretPosition.setToEndOfText(x, G);
  }
  // prettier-ignore
  static setSiblingItemOnCell(x, w, O) {
    const { hovered: D, matchingWithCellText: U } = w, W = D || U, X = W?.[O];
    if (X)
      It.setItemOnCell(x, X);
    else {
      const { columnIndex: G } = x._focusedElements.cell, Y = x._columnsDetails[G].cellDropdown.element;
      if (O === "nextSibling") {
        const K = Y.children[0];
        K && It.setItemOnCell(x, K);
      } else {
        const K = Y.children[Y.children.length - 1];
        K && It.setItemOnCell(x, K);
      }
    }
  }
  static addItemElement(x, w, O, D = !1) {
    const { cellDropdown: U } = O, W = DropdownItem.addPlaneButtonItem(U.element, w, D ? 0 : void 0);
    if (U.customItemStyle && (W.style.color = U.customItemStyle.textColor), U.canAddMoreOptions) {
      const X = OptionDeleteButton.create(x, O);
      if (W.appendChild(X), Browser.IS_COLOR_PICKER_SUPPORTED && U.labelDetails) {
        const G = OptionColorButton.create(x._columnsDetails, O);
        W.appendChild(G);
      }
    }
    return CellDropdownItemEvents.set(x.shadowRoot, W, U), W;
  }
  static addItem(x, w, O, D, U = !1) {
    D.cellDropdown.itemsDetails[w] = {
      backgroundColor: O,
      isCustomBackgroundColor: U,
      element: It.addItemElement(x, w, D)
    };
  }
  static addItems(x, w, O) {
    O.cellDropdown.element.replaceChildren(), O.cellDropdown.itemsDetails = {}, Object.keys(w).forEach((D) => {
      It.addItem(x, D, w[D].color, O, !!w[D].isCustom);
    });
  }
  static postProcessItemToColor(x, w, O) {
    x && delete w[O];
  }
  // prettier-ignore
  static processNewItemsToColor(x, w, O, D) {
    x.slice(1).reduce((U, W) => {
      const X = W[w];
      if (X !== EMPTY_STRING && !U[X])
        if (D) {
          const { globalItemColors: { newColors: G, existingColors: Y } } = D;
          U[X] = { color: Y[X] || G.pop() || LabelColorUtils.getLatestPasteleColorAndSetNew() }, Y[X] ?? (Y[X] = U[X].color);
        } else
          U[X] = { color: It.ACTIVE_ITEM_BACKGROUND_COLOR };
      return U;
    }, O);
  }
  // prettier-ignore
  static changeUserOptionsToItemToColor(x, w) {
    return x.reduce((O, D) => {
      var U;
      if (w) {
        const { globalItemColors: { newColors: W, existingColors: X } } = w;
        O[D.text] = { color: D.backgroundColor || X[D.text] || W.pop() || LabelColorUtils.getLatestPasteleColorAndSetNew(), isCustom: !0 }, X[U = D.text] ?? (X[U] = O[D.text].color);
      } else
        O[D.text] = { color: It.ACTIVE_ITEM_BACKGROUND_COLOR, isCustom: !0 };
      return O;
    }, {});
  }
  // prettier-ignore
  static populateItems(x, w) {
    const { data: O, _columnsDetails: D } = x, U = D[w], {
      cellDropdown: { labelDetails: W },
      settings: { defaultText: X, isDefaultTextRemovable: G },
      activeType: { cellDropdownProps: Y }
    } = U;
    if (!Y)
      return;
    let K = {};
    Y.options && (K = It.changeUserOptionsToItemToColor(Y.options, W)), Y.canAddMoreOptions && It.processNewItemsToColor(O, w, K, W), It.postProcessItemToColor(G, K, X), It.addItems(x, K, U);
  }
};
_CellDropdownItem.ACTIVE_ITEM_BACKGROUND_COLOR = "#4a69d4";
let CellDropdownItem = _CellDropdownItem;
const _LabelCellTextElement = class Xr {
  static isLabelText(x) {
    return x.classList.contains(Xr.TEXT_CLASS);
  }
  static setCellTextAsAnElement(x, w, O) {
    const D = CellTextElement.setCellTextAsAnElement(x, O);
    D.classList.add(Xr.TEXT_CLASS), D.style.backgroundColor = w;
  }
  // prettier-ignore
  static finaliseEditedText(x, w, O, D = !1) {
    var U;
    const W = x._columnsDetails[O], { cellDropdown: X, activeType: { cellDropdownProps: G }, settings: { defaultText: Y, isDefaultTextRemovable: K } } = W, Z = (U = X.itemsDetails[CellElement.getText(w)]) == null ? void 0 : U.backgroundColor;
    CellElement.getText(w) === EMPTY_STRING || K && CellElement.getText(w) === Y ? w.style.backgroundColor = "" : D && Z ? w.style.backgroundColor = Z : G != null && G.canAddMoreOptions && CellDropdownItem.addNewItem(x, w, W, w.style.backgroundColor);
  }
};
_LabelCellTextElement.TEXT_CLASS = "label-cell-text";
let LabelCellTextElement = _LabelCellTextElement;
class CellDropdownEvents {
  // instead of binding click event handlers with the context of current row index to individual item elements every
  // time the dropdown is displayed, click events are handled on the dropdown instead, the reason for this is
  // because it can be expensive to rebind an arbitrary amount of items e.g. 10000+
  // prettier-ignore
  static click(x) {
    const w = x.target;
    if (w.classList.contains(Dropdown.DROPDOWN_CLASS) || w.classList.contains(OptionButton.BUTTON_CLASS))
      return;
    const { rowIndex: O, columnIndex: D, element: U } = this._focusedElements.cell, W = w.classList.contains(DropdownItem.DROPDOWN_ITEM_CLASS) ? w : w.parentElement;
    CellDropdownItem.selectExistingItem(
      this,
      W,
      O,
      D,
      U.children[0]
    ), CellWithTextEvents.programmaticBlur(this);
  }
  // this is required to record to stop cell blur from closing the dropdown
  // additionally if the user clicks on dropdown scroll or padding, this will record it
  static mouseDown(x, w) {
    x.cellDropdown = w;
  }
  static set(x, w) {
    w.onmousedown = CellDropdownEvents.mouseDown.bind(this, x._focusedElements, w), w.onclick = CellDropdownEvents.click.bind(x);
  }
}
const _CellDropdown2 = class Ft {
  static generateRightPosition() {
    return "4px";
  }
  // prettier-ignore
  static generateBottomPosition(x, w, O) {
    const D = x.offsetParent, U = O.bottomWidth + O.topWidth;
    return `${D.offsetHeight - U - x.offsetTop - w.offsetTop + 6}px`;
  }
  // prettier-ignore
  static generateTopPosition(x, w, O) {
    const D = LabelCellTextElement.isLabelText(w) ? w.offsetTop + w.offsetHeight + 2 : x.offsetHeight - 8;
    return `${ElementOffset.processTop(x.offsetTop + D, O)}px`;
  }
  // prettier-ignore
  static generateLeftPosition(x, w, O) {
    const D = LabelCellTextElement.isLabelText(w) ? w.offsetLeft : 1;
    return `${ElementOffset.processLeft(x.offsetLeft + D, O)}px`;
  }
  // prettier-ignore
  static correctPosition(x, w, O, D) {
    const U = ElementVisibility.getDetailsInWindow(x, D);
    U.isFullyVisible || (U.blockingSides.has(SIDE.RIGHT) && (x.style.left = "", x.style.right = Ft.generateRightPosition()), U.blockingSides.has(SIDE.BOTTOM) && (x.style.top = "", x.style.bottom = Ft.generateBottomPosition(
      w,
      O,
      D
    )));
  }
  // prettier-ignore
  static correctPositionForOverflow(x, w, O) {
    w.offsetHeight !== O.scrollHeight && (x.style.top = `${w.offsetHeight - x.offsetHeight}px`), w.offsetWidth !== O.scrollWidth && (x.style.left = `${w.offsetWidth - x.offsetWidth}px`);
  }
  static setPosition(x, w, O) {
    const D = w.children[0];
    x.style.bottom = "", x.style.right = "", x.style.left = Ft.generateLeftPosition(w, D, O), x.style.top = Ft.generateTopPosition(w, D, O);
    const U = x.parentElement.parentElement, W = U.parentElement;
    OverflowUtils.isOverflowElement(W) ? Ft.correctPositionForOverflow(x, U, W) : Ft.correctPosition(x, w, D, O);
  }
  // prettier-ignore
  static updateCellDropdown(x, w, O, D, U, W) {
    const X = CellElement.getTextElement(x);
    CellDropdownItem.attemptHighlightMatchingItemWithCell(
      X,
      w,
      D,
      U,
      W
    ), U && Ft.setPosition(w.element, X.parentElement, O);
  }
  static focusItemOnDropdownOpen(x, w, O) {
    CellDropdownItem.attemptHighlightMatchingItemWithCell(x, w, O, !1);
  }
  // prettier-ignore
  static correctWidthForOverflow(x) {
    if (x.clientWidth !== x.scrollWidth) {
      const w = x.clientHeight !== x.scrollHeight ? 16 : 0, O = x.scrollWidth + w;
      x.style.width = `${Math.min(O, Ft.MAX_WIDTH)}px`;
    }
    x.children.length > 0 && x.scrollWidth < x.children[0].getBoundingClientRect().width && (x.style.width = `${x.clientWidth + 1}px`);
  }
  static getWidth(x, w, O) {
    if (O != null && O.width)
      return Number.parseInt(O.width);
    if (!w.labelDetails)
      return Math.max(x.offsetWidth - 2, Ft.MIN_WIDTH);
    const D = x.children[0];
    return Math.max(x.offsetWidth - D.offsetLeft * 2, Ft.MIN_WIDTH);
  }
  // prettier-ignore
  static display(x, w, O) {
    const { cellDropdown: D, settings: { defaultText: U }, activeType: { cellDropdownProps: W } } = x._columnsDetails[w], { element: X, itemsDetails: G } = D;
    if (Object.keys(G).length > 0 && W) {
      CellDropdownEvents.set(x, X), CellDropdownItemEvents.blurItem(D, "hovered"), CellDropdownItemEvents.blurItem(D, "matchingWithCellText"), X.style.width = `${Ft.getWidth(O, D, W.dropdownStyle)}px`, Dropdown.display(X), X.scrollLeft = 0, Ft.correctWidthForOverflow(X), CellDropdownScrollbar.setProperties(D), Ft.setPosition(X, O, x._tableDimensions.border);
      const Y = O.children[0];
      return Ft.focusItemOnDropdownOpen(Y, D, U), !0;
    }
    return !1;
  }
  static setCustomStyle(x, w) {
    const { paddingTop: O, paddingBottom: D, marginTop: U, marginLeft: W, border: X, textAlign: G } = w;
    x.element.style.paddingTop = O || Dropdown.DROPDOWN_VERTICAL_PX, x.element.style.paddingBottom = D || Dropdown.DROPDOWN_VERTICAL_PX, x.element.style.marginTop = U || "0px", x.element.style.marginLeft = W || "0px", x.element.style.border = X || "none", x.element.style.textAlign = G || "left";
  }
  static setCustomState(x, w) {
    x.customDropdownStyle = w.dropdownStyle, x.customItemStyle = w.optionStyle, x.canAddMoreOptions = !!w.canAddMoreOptions;
  }
  // prettier-ignore
  static setUpDropdown(x, w) {
    const { _columnsDetails: O, _globalItemColors: D } = x, { activeType: { cellDropdownProps: U }, cellDropdown: W } = O[w];
    U && (W.labelDetails = U.isBasicSelect ? void 0 : { globalItemColors: D }, Ft.setCustomState(W, U), CellDropdownItem.populateItems(x, w), U.dropdownStyle && Ft.setCustomStyle(W, U.dropdownStyle));
  }
  // REF-8 - Created for every column
  static createAndAppend(x) {
    const w = Dropdown.createBase();
    return w.style.maxHeight = Ft.MAX_HEIGHT_PX, w.classList.add(Ft.CELL_DROPDOWN_CLASS), x.appendChild(w), w;
  }
  static getDefaultObj(x) {
    return {
      itemsDetails: {},
      activeItems: {},
      element: x,
      canAddMoreOptions: !0,
      scrollbarPresence: {
        horizontal: !1,
        vertical: !1
      }
    };
  }
  static createContainerElement() {
    return document.createElement("div");
  }
};
_CellDropdown2.CELL_DROPDOWN_CLASS = "cell-dropdown";
_CellDropdown2.MAX_HEIGHT_PX = "147px";
_CellDropdown2.MIN_WIDTH = 70;
_CellDropdown2.MAX_WIDTH = 200;
let CellDropdown = _CellDropdown2;
const _ColumnDetails = class fr {
  // prettier-ignore
  static getHeaderDefaultColor(x, w, O, D) {
    var U, W, X, G, Y, K;
    return ((W = (U = D?.headerStyles) == null ? void 0 : U.default) == null ? void 0 : W[w]) || ((X = D?.cellStyle) == null ? void 0 : X[w]) || ((Y = (G = x.headerStyles) == null ? void 0 : G.default) == null ? void 0 : Y[w]) || ((K = x.cellStyle) == null ? void 0 : K[w]) || O;
  }
  // prettier-ignore
  static getHeaderHoverColor(x, w, O, D) {
    var U, W, X, G;
    return ((W = (U = D?.headerStyles) == null ? void 0 : U.hoverColors) == null ? void 0 : W[w]) || ((G = (X = x.headerStyles) == null ? void 0 : X.hoverColors) == null ? void 0 : G[w]) || fr.getHeaderDefaultColor(x, w, O, D);
  }
  // settings variable is a variable attached to columnDetails and can be either default or custom
  // prettier-ignore
  static createHeaderStateColors(x, w, O) {
    return {
      hover: {
        color: fr.getHeaderHoverColor(x, "color", O.color, w),
        backgroundColor: fr.getHeaderHoverColor(
          x,
          "backgroundColor",
          O.backgroundColor,
          w
        )
      },
      default: {
        color: fr.getHeaderDefaultColor(x, "color", "", w),
        backgroundColor: fr.getHeaderDefaultColor(x, "backgroundColor", "", w)
      }
    };
  }
  // prettier-ignore
  static createInitial(x, w, O, D, U) {
    const W = O || x;
    return {
      elements: [],
      processedStyle: [],
      settings: W,
      headerStateColors: fr.createHeaderStateColors(x, O, D),
      bordersOverwrittenBySiblings: {},
      activeType: ColumnTypesUtils.getActiveType(W),
      cellDropdown: CellDropdown.getDefaultObj(w),
      fireColumnsUpdate: U
    };
  }
  // prettier-ignore
  static updateWithNoSizer(x, w) {
    return Object.assign(x, { columnDropdownCellOverlay: w }), x;
  }
};
_ColumnDetails.MINIMAL_COLUMN_WIDTH = 34;
let ColumnDetails = _ColumnDetails;
class MaximumColumns {
  // the motivation behind minimal column length came from the fact that when we have set a table width and all the columns
  // have become too narrow (24px), upon adding any subsequent columns - the set table width would be ignored and the table
  // would expand - as an infinite amount of columns can't just be added to a table width a preset width
  // the actual minimal column length is usually not reached as dividing table width by its columns rarely produces it
  // originally this was set to 28, however the extra padding on the left column causes the table width to overflow
  // the set limit hence it is set to 34 instead
  // REF-24
  // this is a small effort to toggle off the add new column button when columns with set widths breach the table
  static isStaticContentBreachingSetTableWidth(x, w) {
    if (w)
      return !1;
    const O = x.width || x.maxWidth;
    return O !== void 0 && x.staticWidth > O;
  }
  // prettier-ignore
  static ignoreMinimalColumnWidthCheck(x, w, O) {
    return x.preserveNarrowColumns || !StaticTable.isStaticTableWidth(w, x) || O === 0;
  }
  // prettier-ignore
  static canAddMore(x) {
    const { _tableElementRef: w, _columnsDetails: O, _tableDimensions: D, maxColumns: U, preserveNarrowColumns: W } = x, X = O.length;
    if (U !== void 0 && U > 0 && U === X || MaximumColumns.isStaticContentBreachingSetTableWidth(D, W))
      return !1;
    const G = w;
    return MaximumColumns.ignoreMinimalColumnWidthCheck(D, G, X) ? !0 : (G.offsetWidth - D.staticWidth) / (X + 1) >= ColumnDetails.MINIMAL_COLUMN_WIDTH;
  }
}
const _AddNewColumnEvents = class dr {
  static setHeaderCellStyle(x, w, O) {
    const { default: D, hover: U } = w;
    x.style.color = O ? U.color : D.color, x.style.backgroundColor = O ? U.backgroundColor : D.backgroundColor;
  }
  static setDataCellStyle(x, w) {
    setTimeout(() => {
      x.forEach((O) => {
        O.style.backgroundColor = w;
      });
    });
  }
  // prettier-ignore
  static setDataCellsStyle(x, w, O) {
    const D = x ? O.hover.backgroundColor : O.default.backgroundColor, U = w.slice(1), W = Math.ceil(U.length / dr.NUMBER_OF_HIGHLIGHT_CHUNKS);
    for (let X = 0; X < U.length; X += W) {
      const G = U.slice(X, X + W);
      dr.setDataCellStyle(G, D);
    }
  }
  // prettier-ignore
  static toggleColor(x, w, O) {
    const { data: D, header: U } = O, W = w[0];
    W && dr.setHeaderCellStyle(W, U, x), w.length > 1 && dr.setDataCellsStyle(x, w, D);
  }
  // prettier-ignore
  static setEvents(x, w) {
    const { _addColumnCellsElementsRef: O, _frameComponents: { cellColors: D } } = x;
    w.onmouseenter = dr.toggleColor.bind(this, !0, O, D), w.onmouseleave = dr.toggleColor.bind(this, !1, O, D), w.onclick = InsertNewColumn.insertEvent.bind(x);
  }
};
_AddNewColumnEvents.NUMBER_OF_HIGHLIGHT_CHUNKS = 3;
let AddNewColumnEvents = _AddNewColumnEvents;
const _AddNewColumnElement = class Ot {
  // the toggling of the add new column element is not a simple display style change because the following selector:
  // .row > .cell:last-of-type which is responsible for not adding a right-border for the rightmost cell can only
  // detect the last .cell element, so when this button is displayed we want the selector to recognise it and
  // not display a border on the right and not affect the css of the cell before it. When it is not displayed,
  // we want the previous cell to be recognised by the selector. Unfortunately this is not possible as even
  // renaming the class names on this button does not re-trigger selector to identify the previous cell as last.
  // The only way to do this is to remove the cell element when not visible, which is what the code below is doing
  // and re-adding the cell when it is visible. (The cell still remains in the addColumnCellsElementsRef object).
  static setDisplay(x, w, O, D) {
    w ? O.children[D].appendChild(x) : x.remove();
  }
  static createCell(x, w) {
    var O;
    const D = CellElement.createBaseCell(w);
    return D.classList.add(
      CellElement.CELL_CLASS,
      GenericElementUtils.NOT_SELECTABLE_CLASS,
      Ot.ADD_COLUMN_CELL_CLASS
    ), Object.assign(D.style, x._defaultColumnsSettings.cellStyle, (O = x._frameComponents.styles) == null ? void 0 : O.default), AddNewColumnEvents.setEvents(x, D), D;
  }
  // prettier-ignore
  static createHeaderCell(x) {
    const { _defaultColumnsSettings: { headerStyles: w }, _frameComponents: { cellColors: O, inheritHeaderColors: D } } = x, U = Ot.createCell(x, !0);
    return U.style.width = Ot.DEFAULT_WIDTH_PX, U.innerText = "+", Object.assign(U.style, D ? w?.default : {}, O.header.default), U;
  }
  static createDataCell(x) {
    const w = Ot.createCell(x, !1);
    return Object.assign(w.style, x._frameComponents.cellColors.data.default), w;
  }
  static isDisplayed(x) {
    return GenericElementUtils.doesElementExistInDom(x[0]);
  }
  static createAndAppendToRow(x, w, O) {
    const { _addColumnCellsElementsRef: D, _columnsDetails: U } = x, W = D.length === 0 || Ot.isDisplayed(D), X = O === 0 ? Ot.createHeaderCell(x) : Ot.createDataCell(x);
    D.splice(O, 0, X);
    const G = U[U.length - 1];
    ColumnSettingsBorderUtils.unsetSubjectBorder(D, G.elements, "left", O), W && (MaximumColumns.canAddMore(x) ? w.appendChild(X) : O === 0 && TableElement.changeStaticWidthTotal(x._tableDimensions, -Ot.DEFAULT_WIDTH));
  }
  // prettier-ignore
  static toggleEachCell(x, w, O, D) {
    O.forEach((U, W) => {
      Ot.setDisplay(U, x, w, W);
    }), x || setTimeout(() => AddNewColumnEvents.toggleColor(!1, O, D));
  }
  static changeTableWidths(x, w, O) {
    const D = w ? Ot.DEFAULT_WIDTH : -Ot.DEFAULT_WIDTH;
    TableElement.changeStaticWidthTotal(x._tableDimensions, D), StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(x, O);
  }
  // prettier-ignore
  static toggle(x, w) {
    const {
      _addColumnCellsElementsRef: O,
      _tableBodyElementRef: D,
      _frameComponents: { displayAddNewColumn: U, cellColors: W }
    } = x;
    if (!U || !D)
      return;
    const X = MaximumColumns.canAddMore(x);
    X !== Ot.isDisplayed(O) && (X ? (Ot.toggleEachCell(X, D, O, W), Ot.changeTableWidths(x, X, w)) : (Ot.changeTableWidths(x, X, w), Ot.toggleEachCell(X, D, O, W)));
  }
};
_AddNewColumnElement.ADD_COLUMN_CELL_CLASS = "add-column-cell";
_AddNewColumnElement.DEFAULT_WIDTH = 25;
_AddNewColumnElement.DEFAULT_WIDTH_PX = `${_AddNewColumnElement.DEFAULT_WIDTH}px`;
let AddNewColumnElement = _AddNewColumnElement;
class ExtractElements {
  static textCellsArrFromRow(x) {
    return Array.from(x.children).filter(
      (w) => (w.tagName === CellElement.HEADER_TAG || w.tagName === CellElement.DATA_TAG) && !w.classList.contains(AddNewColumnElement.ADD_COLUMN_CELL_CLASS) && !w.classList.contains(IndexColumn.INDEX_CELL_CLASS)
    );
  }
  static textRowsArrFromTBody(x, w, O = 0) {
    return Array.from(x.children).slice(O, w.length);
  }
  static getRightColumnSiblingCell(x) {
    var w;
    return (w = x.nextSibling) == null ? void 0 : w.nextSibling;
  }
}
class ColumnSettingsFrameBorderUtils {
  // prettier-ignore
  static toggleFrameBorder(x, w, O, D) {
    if (x.length > 0) {
      const { subjectBorderStyle: U, siblingBorderStyle: W } = ColumnSettingsBorderUtils.getColumnBorderStyles(O), X = x[0], G = w[0];
      ColumnSettingsBorderUtils.isBorderDisplayed(G, W) ? ColumnSettingsBorderUtils.unsetSubjectBorder(x, w, O, 0) : X.style[U] === ColumnSettingsBorderUtils.UNSET_PX && ResetColumnStyles.applyDefaultStyles(x, D);
    }
  }
  // prettier-ignore
  static updateFrameColumns(x, w, O, D) {
    const U = w || O;
    if (!U)
      return;
    const {
      _defaultColumnsSettings: W,
      _addColumnCellsElementsRef: X,
      _frameComponents: { displayAddNewColumn: G, displayIndexColumn: Y }
    } = x;
    if (!D && G && ColumnSettingsFrameBorderUtils.toggleFrameBorder(
      X,
      U.elements,
      "left",
      W
    ), !O && Y) {
      const K = ExtractElements.textRowsArrFromTBody(x._tableBodyElementRef, x.data, 0).map((Z) => Z.children[0]);
      ColumnSettingsFrameBorderUtils.toggleFrameBorder(K, U.elements, "right", W);
    }
  }
}
const _ColumnSettingsBorderUtils = class Lt {
  // REF-23
  static overwriteSideBorderIfSiblingsHaveSettings(x, w) {
    const { left: O, right: D } = x.bordersOverwrittenBySiblings;
    w.forEach((U) => {
      O && (U.style.borderLeftWidth = Lt.UNSET_PX), D && (U.style.borderRightWidth = Lt.UNSET_PX);
    });
  }
  // prettier-ignore
  static getColumnBorderStyles(x) {
    return { subjectBorderStyle: x === "left" ? "borderLeftWidth" : "borderRightWidth", siblingBorderStyle: x === "left" ? "borderRightWidth" : "borderLeftWidth" };
  }
  static isBorderDisplayed(x, w) {
    return !!(x.style[w] && x.style[w] !== Lt.UNSET_PX);
  }
  // REF-23
  // prettier-ignore
  static unsetSubjectBorder(x, w, O, D, U) {
    const { subjectBorderStyle: W, siblingBorderStyle: X } = Lt.getColumnBorderStyles(O), G = x[D], Y = w[D];
    Lt.isBorderDisplayed(G, W) && Lt.isBorderDisplayed(Y, X) && (U && (U[O] = !0), x.forEach((K) => {
      ElementStyle.setStyle(K, W, Lt.UNSET_PX);
    }));
  }
  // prettier-ignore
  static unsetColumnBorder(x, w, O) {
    Lt.unsetSubjectBorder(
      x.elements,
      w.elements,
      O,
      0,
      x.bordersOverwrittenBySiblings
    );
  }
  // if current column and sibling have custom setting styles
  // REF-23
  // prettier-ignore
  static unsetBorders(x, w, O) {
    x && (x.settings.stylePrecedence ? (w && Lt.unsetColumnBorder(w, x, "right"), O && (O.settings.stylePrecedence ? Lt.unsetColumnBorder(x, O, "right") : O.settings.stylePrecedence || Lt.unsetColumnBorder(O, x, "left"))) : (O && O.settings.stylePrecedence && Lt.unsetColumnBorder(x, O, "right"), w && w.settings.stylePrecedence && Lt.unsetColumnBorder(x, w, "left")));
  }
  static resetBorderOverwritingState(x) {
    x && (x.bordersOverwrittenBySiblings.left = !1, x.bordersOverwrittenBySiblings.right = !1);
  }
  // prettier-ignore
  static resetIfBorderOverwritten(x, w, O, D) {
    O != null && O.bordersOverwrittenBySiblings[D] && (O.bordersOverwrittenBySiblings[D] = !1, ColumnSettingsStyleUtils.changeStyleFunc(x, w, x._columnsDetails[w].settings));
  }
  // REF-23
  static updateSiblingColumns(x, w) {
    const { _columnsDetails: O } = x, D = O[w], U = O[w - 1], W = O[w + 1];
    Lt.resetIfBorderOverwritten(x, w + 1, W, "left"), Lt.resetIfBorderOverwritten(x, w - 1, U, "right"), Lt.resetBorderOverwritingState(D), Lt.unsetBorders(D, U, W), ColumnSettingsFrameBorderUtils.updateFrameColumns(x, D, U, W);
  }
};
_ColumnSettingsBorderUtils.UNSET_PX = "0px";
let ColumnSettingsBorderUtils = _ColumnSettingsBorderUtils;
const _CellElement = class Ut {
  // prettier-ignore
  static setDefaultCellStyle(x, w, O) {
    Object.assign(x.style, w, O);
  }
  static createBaseCell(x) {
    const w = document.createElement(x ? Ut.HEADER_TAG : Ut.DATA_TAG);
    return x && w.classList.add(Ut.HEADER_CELL_CLASS), w.classList.add(Ut.CELL_CLASS), w;
  }
  // prettier-ignore
  static createDataCell(x, w, O, D) {
    const U = Ut.createBaseCell(x);
    return x && D && U.classList.add(GenericElementUtils.NOT_SELECTABLE_CLASS), U.setAttribute("role", "textbox"), Ut.setDefaultCellStyle(U, w, O), U;
  }
  static setCursor(x, w) {
    x.style.cursor = w ? "text" : "default";
  }
  static prepContentEditable(x, w, O = !1) {
    CaretDisplayFix.isIssueBrowser() ? (w && CaretDisplayFix.setTabIndex(x), CaretDisplayFix.removeContentEditable(x)) : x.contentEditable = String(w), O || Ut.setCursor(x, w);
  }
  // prettier-ignore
  // this is used for cases where element could be the cell element or the text inside a select/label cell
  static getCellElement(x) {
    return x.classList.contains(CellTextElement.CELL_TEXT_DIV_CLASS) || x.classList.contains(DateCellInputElement.DATE_INPUT_CONTAINER_CLASS) ? x.parentElement : x.classList.contains(DateCellInputElement.DATE_INPUT_CLASS) || x.classList.contains(DateCellCalendarIconElement.CALENDAR_ICON_CONTAINER_CLASS) ? x.parentElement.parentElement : x;
  }
  static getTextElement(x) {
    var w, O;
    return (w = x.children[0]) != null && w.classList.contains(CellTextElement.CELL_TEXT_DIV_CLASS) ? x.children[0] : (O = x.children[1]) != null && O.classList.contains(CellTextElement.CELL_TEXT_DIV_CLASS) ? x.children[1] : CheckboxCellElement.isCheckboxCell(x) ? x.children[0] : x;
  }
  // The reason why .trim() is used is because innerText/textContent property does not just return the cell text, but
  // additionally the new line characters (\n) which represent <br> elements within the cell that make it difficult
  // to compare cell text to other strings or use them for other programmatic purposes.
  // CAUTION-1 - The returned string should not be used to set text on other cells as .trim() removes \n chars for
  // <br> tags which are used to set the pointer position.
  static getText(x) {
    const w = CheckboxCellElement.getValue(x);
    return w !== void 0 ? w : x.innerText.trim();
  }
  // this is used for case where element could be cell element that contains a text div element,
  // hence we need to set the text into the correct container
  // CAUTION-1 - be careful that the text does not come from above method
  static setText(x, w) {
    if (!CheckboxCellElement.setValue(x, w)) {
      const O = Ut.getTextElement(x);
      O.innerText = w;
    }
  }
  // set text is optional as some elements may only need to toggle the BR padding
  // prettier-ignore
  static setNewText(x, w, O, D, U, W = !0) {
    W && Ut.setText(w, O), D ? setTimeout(() => CaretDisplayFix.toggleCellTextBRPadding(x, w, U)) : CaretDisplayFix.toggleCellTextBRPadding(x, w, U);
  }
  // REF-36
  static setColumnWidth(x, w, O, D) {
    if (!x._tableElementRef)
      return;
    const U = O?.widths || D?.widths;
    if (U != null && U.staticWidth)
      ColumnSettingsWidthUtils.updateColumnWidth(x, w, U, !0);
    else if (U != null && U.initialWidth) {
      const W = ColumnSettingsWidthUtils.getSettingsWidthNumber(x._tableElementRef, U, !1);
      w.style.width = `${W.number}px`;
    } else
      w.style.width = `${x._tableDimensions.newColumnWidth}px`;
  }
  // prettier-ignore
  static createCellElement(x, w, O, D) {
    var U, W, X;
    const { _defaultColumnsSettings: { cellStyle: G, headerStyles: Y }, _columnsDetails: K } = x, Z = K[O], q = (X = (W = (U = x._defaultColumnsSettings.columnDropdown) == null ? void 0 : U.displaySettings) == null ? void 0 : W.openMethod) == null ? void 0 : X.cellClick, J = Ut.createDataCell(
      D,
      G,
      D ? Y?.default : {},
      q
    ), { settings: ee } = Z;
    ColumnSettingsStyleUtils.applySettingsStyleOnCell(ee, J, D), ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(Z, [J]);
    const re = D ? !q && ee.isHeaderTextEditable : ee.isCellTextEditable;
    return Ut.prepContentEditable(J, !!re, q), D && Ut.setColumnWidth(x, J, ee, x._defaultColumnsSettings), Ut.setNewText(x, J, w, !0, !1), J;
  }
};
_CellElement.CELL_CLASS = "cell";
_CellElement.HEADER_CELL_CLASS = "header-cell";
_CellElement.HEADER_TAG = "TH";
_CellElement.DATA_TAG = "TD";
let CellElement = _CellElement;
const _FilterViaWebWorkers = class ur {
  // prettier-ignore
  static processOtherColumnsIfPresent(x, w, O, D) {
    FilterInternalUtils.ACTIVE_WORKERS -= 1, O.length > 1 && D.length > 0 ? ur.execute(x, w, O.slice(1), D) : FilterInternalUtils.ACTIVE_WORKERS === 0 && x();
  }
  // cannot use a direct link to a webworker file as parent project may not allow the component to access it
  // const worker = new Worker(new URL('./worker.js', import.meta.url))
  // using a string literal instead, ref:
  // https://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string
  static createWorkerBlobURL() {
    const x = new Blob([ur.CODE], { type: "application/javascript" });
    return URL.createObjectURL(x);
  }
  static hideRows(x, w, O, D) {
    const { colCells: U } = O[0], { matchingIndexes: W, notMatchingIndexes: X } = D.data;
    X.forEach((G) => {
      U[G].parentElement.classList.add(FilterInternalUtils.HIDDEN_ROW_CLASS);
    }), ur.processOtherColumnsIfPresent(x, w, O, W);
  }
  static toggleRows(x, w, O, D) {
    const U = [], { colCells: W } = O[0];
    D.data.forEach((X, G) => {
      const Y = W[G].parentElement;
      X ? (Y.classList.remove(FilterInternalUtils.HIDDEN_ROW_CLASS), U.push(G)) : Y.classList.add(FilterInternalUtils.HIDDEN_ROW_CLASS);
    }), ur.processOtherColumnsIfPresent(x, w, O, U);
  }
  // prettier-ignore
  static execute(x, w, O, D) {
    const U = new Worker(w);
    FilterInternalUtils.ACTIVE_WORKERS += 1, U.onmessage = D ? ur.hideRows.bind(this, x, w, O) : ur.toggleRows.bind(this, x, w, O);
    const W = O[0];
    U.postMessage({
      chunk: W.colCells.map((X) => CellElement.getText(X)),
      filterText: W.filterText,
      isCaseSensitive: W.isCaseSensitive,
      indexArray: D
    });
  }
};
_FilterViaWebWorkers.TRAVERSE_CHUNK = `
    const result = chunk.map((text) => (isCaseSensitive ? text : text.toLocaleLowerCase()).includes(filterText));
    self.postMessage(result);
  `;
_FilterViaWebWorkers.TRAVERSE_MATCHING_INDEXES = `
    const matchingIndexes = [];
    const notMatchingIndexes = [];
    indexArray.forEach((index) => {
      const text = chunk[index];
      const isMatching = (isCaseSensitive ? text : text.toLocaleLowerCase()).includes(filterText);
      if (isMatching) {
        matchingIndexes.push(index);
      } else {
        notMatchingIndexes.push(index);
      }
    });
    self.postMessage({matchingIndexes, notMatchingIndexes});
  `;
_FilterViaWebWorkers.CODE = `
    self.onmessage = function (event) {
      const {chunk, indexArray, filterText, isCaseSensitive} = event.data;
      if (indexArray) {
        ${_FilterViaWebWorkers.TRAVERSE_MATCHING_INDEXES}
      } else {
        ${_FilterViaWebWorkers.TRAVERSE_CHUNK}
      }
    };
  `;
let FilterViaWebWorkers = _FilterViaWebWorkers;
class FilterViaTimeouts {
  static processOtherColumnsIfPresent(x, w, O) {
    FilterInternalUtils.ACTIVE_WORKERS -= 1, w.length > 1 && O.length > 0 ? FilterViaTimeouts.processOtherColumns(x, w.slice(1), O) : FilterInternalUtils.ACTIVE_WORKERS === 0 && x();
  }
  static toggleRow(x, w, O, D) {
    const U = CellElement.getText(x), W = (w.isCaseSensitive ? U : U.toLocaleLowerCase()).includes(w.filterText), X = x.parentElement;
    W ? (X.classList.remove(FilterInternalUtils.HIDDEN_ROW_CLASS), O.push(D)) : X.classList.add(FilterInternalUtils.HIDDEN_ROW_CLASS);
  }
  static processOtherColumns(x, w, O) {
    setTimeout(() => {
      FilterInternalUtils.ACTIVE_WORKERS += 1;
      const D = [], U = w[0];
      O.forEach((W) => {
        const X = U.chunk[W];
        FilterViaTimeouts.toggleRow(X, U, D, W);
      }), FilterViaTimeouts.processOtherColumnsIfPresent(x, w, D);
    });
  }
  static execute(x, w) {
    FilterInternalUtils.ACTIVE_WORKERS += 1, setTimeout(() => {
      const O = [], D = w[0];
      D.chunk.forEach((U, W) => {
        FilterViaTimeouts.toggleRow(U, D, O, W);
      }), FilterViaTimeouts.processOtherColumnsIfPresent(x, w, O);
    });
  }
}
const _FilterInternalUtils = class ar {
  static finishFiltering(x) {
    x.pagination && (PageButtonContainerElement.repopulateButtons(x), PaginationUtils.displayRowsForDifferentButton(x, 1));
  }
  static getFilterFunc(x) {
    const w = ar.finishFiltering.bind(this, x);
    return window.Worker ? FilterViaWebWorkers.execute.bind(this, w, FilterViaWebWorkers.createWorkerBlobURL()) : FilterViaTimeouts.execute.bind(this, w);
  }
  static generateDefaultHeaderName(x, w) {
    var O, D, U;
    return w && ((O = x[0]) != null && O.find((W) => W === w)) ? w : ((D = x[0]) == null ? void 0 : D[0]) !== void 0 ? String((U = x[0]) == null ? void 0 : U[0]) : "";
  }
  static addConfig(x, w) {
    var O;
    const { placeholderTemplate: D, defaultColumnHeaderName: U } = w, W = {
      isCaseSensitive: !1,
      placeholderTemplate: D,
      defaultColumnHeaderName: U || ar.generateDefaultHeaderName(x.data)
    };
    return (O = x._visiblityInternal).filters ?? (O.filters = []), x._visiblityInternal.filters.push(W), W;
  }
  // colElements are used to identify active column (not using name as columns can have same names)
  static assignElements(x, w) {
    var O;
    const { data: D, _columnsDetails: U } = x;
    if (D.length !== 0)
      if (w.defaultColumnHeaderName) {
        const W = D[0].findIndex((X) => X === w.defaultColumnHeaderName);
        w.elements = U[W === -1 ? 0 : W].elements, delete w.defaultColumnHeaderName;
      } else
        w.elements && !((O = x.shadowRoot) != null && O.contains(w.elements[0])) && (w.elements = U[0].elements);
  }
  // prettier-ignore
  static resetInput(x, w) {
    const { _visiblityInternal: { filters: O } } = x;
    if (ar.assignElements(x, w), !w.elements || !O)
      return;
    const D = CellElement.getText(w.elements[0]);
    w.lastRegisteredHeaderName = D, FilterInputElement.setPlaceholder(w.inputElement, D, w.placeholderTemplate), FilterInputEvents.setEvents(x, w, O);
  }
  static unsetFilter(x) {
    x.value !== "" && (x.value = "", x.dispatchEvent(new Event("input")));
  }
  static unsetAllFilters(x) {
    var w, O;
    let D = !1;
    const { data: U, _visiblityInternal: W, _tableBodyElementRef: X } = x;
    return U[0] && U[0].length !== 0 && X && ((w = W.filters) == null || w.forEach((G) => {
      G.inputElement.value !== "" && (G.inputElement.value = "", D = !0);
    }), D && ((O = W.filters) == null || O[0].inputElement.dispatchEvent(new Event("input")))), D;
  }
  // prettier-ignore
  static resetAllInputs(x) {
    const { data: w, _visiblityInternal: { filters: O } } = x;
    if (!w[0] || w[0].length === 0 || !O)
      return FilterInputEvents.unsetEvents(O);
    O.forEach((D) => ar.resetInput(x, D)), ar.unsetAllFilters(x);
  }
  static completeReset(x) {
    const w = x._visiblityInternal.filters;
    w && (Array.isArray(x.filter) ? x.filter.forEach((O, D) => {
      w[D].defaultColumnHeaderName = O.defaultColumnHeaderName;
    }) : typeof x.filter == "object" && (w[0].defaultColumnHeaderName = x.filter.defaultColumnHeaderName), ar.resetAllInputs(x));
  }
  static isContainerRequired(x, w) {
    let O = !1;
    if (Array.isArray(x))
      O = !!x.find((D) => {
        const U = (D.position || FilterElements.DEFAULT_INPUT_POSITION).indexOf(w);
        return U !== void 0 && U >= 0;
      });
    else if (typeof x == "object") {
      const D = (x.position || FilterElements.DEFAULT_INPUT_POSITION).indexOf(w);
      O = D !== void 0 && D >= 0;
    } else if (typeof x == "boolean") {
      const D = FilterElements.DEFAULT_INPUT_POSITION.indexOf(w);
      O = D !== void 0 && D >= 0;
    }
    return O;
  }
  static extractUnfilteredRows(x, w) {
    return Array.from(x.children).slice(0, w).filter((O) => !O.classList.contains(ar.HIDDEN_ROW_CLASS));
  }
  // prettier-ignore
  static wasHeaderChanged(x, w, O, D) {
    const U = x[O].elements, W = w.find((X) => U === X.elements);
    return W && (W.lastRegisteredHeaderName !== CellElement.getText(U[0]) || D);
  }
};
_FilterInternalUtils.ACTIVE_WORKERS = 0;
_FilterInternalUtils.CHUNK_SIZE = 2;
_FilterInternalUtils.HIDDEN_ROW_CLASS = "filter-hidden-row";
let FilterInternalUtils = _FilterInternalUtils;
class FileImportInputElement {
  // always created as the user may want to trigger the importCSV method without the CSV buttons and need this to work
  static create(x) {
    const w = document.createElement("input");
    return w.type = "file", w.hidden = !0, setTimeout(() => {
      var O;
      (O = x._tableElementRef) == null || O.appendChild(w);
    }), w;
  }
}
class FilesUtils {
  static processStyles(x) {
    const w = { default: {}, hover: { backgroundColor: "#f0f0f0" }, click: { backgroundColor: "#e4e4e4" } };
    return x && (Object.assign(w.default, x.default), Object.assign(w.hover, x.hover), Object.assign(w.click, x.click)), w;
  }
  static createDefault(x) {
    return { inputElementRef: FileImportInputElement.create(x) };
  }
}
FilesUtils.DEFAULT_BUTTON_POSITION = "bottom-left";
const _OuterContainerElements = class wt {
  // REF-38
  static getColumnContentContainer(x) {
    return x.children[0].children[0];
  }
  static setContainerHeightBasedOnMiddleColumn(x) {
    if (x.getBoundingClientRect().height === 0) {
      const w = wt.getColumnContentContainer(x.children[1]);
      x.style.height = `${w.getBoundingClientRect().height}px`;
    }
  }
  static setHeightsWhenOnlyMiddleColumns(x) {
    setTimeout(() => {
      x.top && wt.setContainerHeightBasedOnMiddleColumn(x.top), x.bottom && wt.setContainerHeightBasedOnMiddleColumn(x.bottom);
    });
  }
  // REF-38
  static appendChildToColumn(x, w) {
    wt.getColumnContentContainer(x).appendChild(w);
  }
  // REF-38
  static addToContainer(x, w, O) {
    const D = x.indexOf("top") >= 0 ? w.top : w.bottom;
    x.indexOf("left") >= 0 ? wt.appendChildToColumn(D.children[0], O) : x.indexOf("center") >= 0 ? wt.appendChildToColumn(D.children[1], O) : wt.appendChildToColumn(D.children[2], O);
  }
  // REF-38
  // need an inner divs in order for the inserted components 'width' properties to work as CONTAINER_CLASS has width: 0px
  static createContainerColumn(x, w) {
    const O = document.createElement("div");
    O.classList.add(wt.COLUMN_CLASS, x);
    const D = document.createElement("div");
    D.classList.add(wt.COLUMN_INNER_CLASS);
    const U = document.createElement("div");
    return U.classList.add(wt.COLUMN_CONTENT_CLASS), D.appendChild(U), O.appendChild(D), O.style.gridColumn = w, O;
  }
  static createContainerElement() {
    const x = document.createElement("div");
    x.classList.add(wt.CONTAINER_CLASS);
    const w = wt.createContainerColumn(wt.LEFT_COLUMN_CLASS, "1");
    x.appendChild(w);
    const O = wt.createContainerColumn(wt.CENTER_COLUMN_CLASS, "2");
    x.appendChild(O);
    const D = wt.createContainerColumn(wt.RIGHT_COLUMN_CLASS, "3");
    return x.appendChild(D), x;
  }
  static addContainer(x, w, O) {
    const D = wt.createContainerElement();
    D.id = w, O != null && O.style.fontFamily && (D.style.fontFamily = O.style.fontFamily);
    const U = w === wt.TOP_CONTAINER_ID ? "beforebegin" : "afterend";
    return x.insertAdjacentElement(U, D), D;
  }
  // can be reused for other positional components
  static isRequired(x, w) {
    return !!Object.keys(x).find((O) => {
      const { position: D } = x[O];
      return D.indexOf(w) >= 0;
    });
  }
  static isContainerRequired(x, w) {
    var O;
    let D = !1;
    return x.pagination && (D = wt.isRequired(x._pagination.positions, w)), !D && (O = x.files) != null && O.buttons && (D = !!x.files.buttons.find((U) => (U.position || FilesUtils.DEFAULT_BUTTON_POSITION).indexOf(w) >= 0)), !D && x.filter && (D = FilterInternalUtils.isContainerRequired(x.filter, w)), D;
  }
  // we create a top and a bottom container only if they are required
  static create(x) {
    var w;
    const O = {}, D = wt.isContainerRequired(x, "top"), U = wt.isContainerRequired(x, "bottom"), { _tableElementRef: W } = x, X = ((w = x._overflow) == null ? void 0 : w.overflowContainer) || W;
    if (!X)
      return O;
    if (D) {
      const G = wt.addContainer(X, wt.TOP_CONTAINER_ID, W);
      O.top = G;
    }
    if (U) {
      const G = wt.addContainer(X, wt.BOTTOM_CONTAINER_ID, W);
      O.bottom = G;
    }
    return wt.setHeightsWhenOnlyMiddleColumns(O), O;
  }
};
_OuterContainerElements.ABSOULUTE_FULL_TABLE_CLASS = "absolute-container";
_OuterContainerElements.CONTAINER_CLASS = "outer-container";
_OuterContainerElements.TOP_CONTAINER_ID = "outer-top-container";
_OuterContainerElements.BOTTOM_CONTAINER_ID = "outer-bottom-container";
_OuterContainerElements.COLUMN_CLASS = "outer-container-column";
_OuterContainerElements.COLUMN_INNER_CLASS = "outer-container-column-inner";
_OuterContainerElements.COLUMN_CONTENT_CLASS = "outer-container-column-content";
_OuterContainerElements.LEFT_COLUMN_CLASS = "outer-container-left-column";
_OuterContainerElements.CENTER_COLUMN_CLASS = "outer-container-center-column";
_OuterContainerElements.RIGHT_COLUMN_CLASS = "outer-container-right-column";
let OuterContainerElements = _OuterContainerElements;
const _OuterDropdownButtonUtils = class Br {
  static processStatefulStyle(x) {
    x.hover ?? (x.hover = x.default), x.click ?? (x.click = x.hover);
  }
  static processAndApplyDefaultStyle(x, w) {
    w && (Br.processStatefulStyle(w), Object.assign(x.style, w.default));
  }
  static createArrow(x, w) {
    const O = document.createElement("div");
    O.classList.add(Br.ARROW_CONTAINER_CLASS, GenericElementUtils.NOT_SELECTABLE_CLASS), x && O.classList.add(...x);
    const D = SVGIconUtils.createSVGElement(ARROW_DOWN_SVG_STRING);
    return D.classList.add(Br.ARROW_ICON_CLASS), w && D.classList.add(...w), O.appendChild(D), O;
  }
};
_OuterDropdownButtonUtils.ARROW_CONTAINER_CLASS = "outer-dropdown-button-arrow-container";
_OuterDropdownButtonUtils.ARROW_ICON_CLASS = "outer-dropdown-button-arrow-icon";
let OuterDropdownButtonUtils = _OuterDropdownButtonUtils;
class RowsPerPageSelectButtonEvents {
  static mouseDown(x, w) {
    var O, D, U, W, X, G;
    Object.assign(w.style, (D = (O = x.styles.rowsPerPageSelect) == null ? void 0 : O.button) == null ? void 0 : D.click);
    const Y = w.children[0];
    Object.assign(Y.style, (W = (U = x.styles.rowsPerPageSelect) == null ? void 0 : U.buttonText) == null ? void 0 : W.click);
    const K = w.children[1];
    Object.assign(K.style, (G = (X = x.styles.rowsPerPageSelect) == null ? void 0 : X.buttonArrow) == null ? void 0 : G.click);
  }
  static mouseLeave(x, w) {
    RowsPerPageSelectButtonElement.applyStylesOnElements(w, "default", x.rowsPerPageSelect);
  }
  static mouseEnter(x, w) {
    RowsPerPageSelectButtonElement.applyStylesOnElements(w, "hover", x.rowsPerPageSelect);
  }
  static setEvents(x, w) {
    w.onmouseenter = RowsPerPageSelectButtonEvents.mouseEnter.bind(this, x._pagination.styles, w), w.onmouseleave = RowsPerPageSelectButtonEvents.mouseLeave.bind(this, x._pagination.styles, w), w.onmousedown = RowsPerPageSelectButtonEvents.mouseDown.bind(this, x._pagination, w), w.onmouseup = RowsPerPageSelectButtonEvents.mouseEnter.bind(this, x._pagination.styles, w);
  }
}
const _RowsPerPageSelectButtonElement = class xr {
  // prettier-ignore
  static applyStylesOnElements(x, w, O) {
    if (!O)
      return;
    const { button: D, buttonText: U, buttonArrow: W } = O;
    if (D && StatefulCSSEvents.apply(D, D[w], x), U) {
      const X = x.children[0];
      StatefulCSSEvents.apply(U, U[w], X);
    }
    if (W) {
      const X = x.children[1];
      StatefulCSSEvents.apply(W, W[w], X);
    }
  }
  static createButtonArrow(x) {
    var w;
    const O = OuterDropdownButtonUtils.createArrow();
    return OuterDropdownButtonUtils.processAndApplyDefaultStyle(O, (w = x.styles.rowsPerPageSelect) == null ? void 0 : w.buttonArrow), O;
  }
  static updateButtonText(x, w) {
    const O = x.children[0];
    O.innerText = w;
  }
  static createButtonText(x) {
    var w;
    const { isAllRowsOptionSelected: O, rowsPerPageOptionsItemText: D, rowsPerPage: U, styles: W } = x, X = document.createElement("div");
    return X.id = xr.TEXT_ID, X.classList.add(GenericElementUtils.NOT_SELECTABLE_CLASS), OuterDropdownButtonUtils.processAndApplyDefaultStyle(X, (w = W.rowsPerPageSelect) == null ? void 0 : w.buttonText), X.innerText = O ? D[0] : String(U), X;
  }
  static createOptionsButton(x) {
    var w;
    const O = document.createElement("div");
    return O.id = xr.BUTTON_ID, OuterDropdownButtonUtils.processAndApplyDefaultStyle(O, (w = x.styles.rowsPerPageSelect) == null ? void 0 : w.button), O;
  }
  static create(x) {
    const w = xr.createOptionsButton(x._pagination);
    return w.appendChild(xr.createButtonText(x._pagination)), w.appendChild(xr.createButtonArrow(x._pagination)), setTimeout(() => RowsPerPageSelectButtonEvents.setEvents(x, w)), w;
  }
};
_RowsPerPageSelectButtonElement.BUTTON_ID = "rows-per-page-select-button";
_RowsPerPageSelectButtonElement.TEXT_ID = "rows-per-page-select-button-text";
let RowsPerPageSelectButtonElement = _RowsPerPageSelectButtonElement;
class RowsPerPageDropdown {
  static getLeftPropertyToCenterDropdown(x, w) {
    return `${x.offsetLeft + x.offsetWidth / 2 - w / 2}px`;
  }
  static display(x, w, O) {
    const { dropdownWidth: D } = w._pagination, { element: U } = O;
    U.style.left = RowsPerPageDropdown.getLeftPropertyToCenterDropdown(x, D), OuterDropdownSimpleUtils.display(x, w, O);
  }
  static setWidth(x, w) {
    const O = w.rowsPerPageOptionsItemText.reduce((D, U) => isNaN(Number(U)) ? D : Math.max(D, U.length), 1) * 8;
    w.dropdownWidth = w.dropdownWidth + O, x.style.width = `${w.dropdownWidth}px`;
  }
  static create(x, w) {
    const O = OuterDropdownSimpleUtils.hide.bind(this, x._activeOverlayElements), D = RowsPerPageDropdown.display.bind(this, w), U = OuterDropdownElement.create(x, w, "bottom-center", {}, [], O, D);
    return RowsPerPageDropdownItem.populate(x, U.element, w), RowsPerPageDropdown.setWidth(U.element, x._pagination), U;
  }
}
const _RowsPerPageSelectElement = class Ar {
  static createText(x) {
    var w;
    const O = document.createElement("div");
    return O.id = Ar.TEXT_ID, O.style.marginRight = "8px", Object.assign(O.style, (w = x.styles.rowsPerPageSelect) == null ? void 0 : w.prefixText), O.innerText = x.rowsPerPageSelect.prefixText, O;
  }
  static createContainer(x) {
    var w;
    const O = document.createElement("div");
    return O.id = Ar.ID, O.classList.add(PaginationElements.PAGINATION_TEXT_COMPONENT_CLASS), O.style.order = String(x.positions.rowsPerPageSelect.order), Object.assign(O.style, (w = x.styles.rowsPerPageSelect) == null ? void 0 : w.container), O;
  }
  // prettier-ignore
  static create(x, w) {
    const O = Ar.createContainer(x._pagination);
    O.appendChild(Ar.createText(x._pagination));
    const D = RowsPerPageSelectButtonElement.create(x), U = RowsPerPageDropdown.create(x, D);
    return O.appendChild(D), O.appendChild(U.element), OuterContainerElements.addToContainer(
      x._pagination.positions.rowsPerPageSelect.position,
      w,
      O
    ), O;
  }
};
_RowsPerPageSelectElement.ID = "pagination-number-of-rows-select";
_RowsPerPageSelectElement.TEXT_ID = "pagination-number-of-rows-select-text";
let RowsPerPageSelectElement = _RowsPerPageSelectElement;
class PaginationElements {
  static create(x, w) {
    x._pagination.buttonContainer = PageButtonContainerElement.create(x), PageButtonContainerElement.addInitialElements(x, w), x._pagination.rowsPerPageOptionsItemText && RowsPerPageSelectElement.create(x, w), x._pagination.displayNumberOfVisibleRows && (x._pagination.numberOfVisibleRowsElement = NumberOfVisibleRowsElement.create(x, w));
  }
}
PaginationElements.PAGINATION_TEXT_COMPONENT_CLASS = "pagination-text-component";
const _NumberOfVisibleRowsElement = class Ir {
  static updateForRelativeRowNumber(x, w) {
    const { activePageNumber: O, rowsPerPage: D, numberOfVisibleRowsElement: U } = x, W = O * D, X = w < 1 ? 0 : Math.max(W - D + 1, 1), G = Math.min(w, W);
    U.innerText = `${X}-${G} of ${w}`;
  }
  static updateForAllRows(x, w) {
    x.innerText = `${Math.min(w, 1)}-${w} of ${w}`;
  }
  static update(x) {
    var w, O;
    const { _pagination: D, data: U, dataStartsAtHeader: W } = x, { numberOfVisibleRowsElement: X, isAllRowsOptionSelected: G } = D;
    if (!X)
      return;
    const Y = ((O = (w = x._pagination) == null ? void 0 : w.asyncStartData) == null ? void 0 : O.totalDataRows) || Math.max(W ? U.length : U.length - 1, 0);
    G ? Ir.updateForAllRows(X, Y) : Ir.updateForRelativeRowNumber(x._pagination, Y);
  }
  static create(x, w) {
    const O = document.createElement("div");
    O.id = Ir.ID, O.classList.add(PaginationElements.PAGINATION_TEXT_COMPONENT_CLASS);
    const { styles: D, positions: U } = x._pagination;
    return O.style.order = String(U.numberOfVisibleRows.order), Object.assign(O.style, D.numberOfVisibleRows), OuterContainerElements.addToContainer(U.numberOfVisibleRows.position, w, O), setTimeout(() => Ir.update(x)), O;
  }
};
_NumberOfVisibleRowsElement.ID = "pagination-number-of-visible-rows";
let NumberOfVisibleRowsElement = _NumberOfVisibleRowsElement;
class PageNumberButtonEvents {
  // REF-30
  static markClick(x) {
    x.clickedPageNumberButton = !0, setTimeout(() => x.clickedPageNumberButton = !1);
  }
  static buttonMouseUp(x, w) {
    PageNumberButtonEvents.markClick(this._pagination);
    const O = w.target, { pageButtons: D } = this._pagination.styles;
    this._pagination.activePageNumber === x || PaginationUtils.getAndApplyDataOnButtonClick(this, x), PageButtonStyle.mouseEnter(O, D, !1);
  }
  static setEvents(x, w, O) {
    O.onmouseup = PageNumberButtonEvents.buttonMouseUp.bind(x, w);
  }
}
class PageNumberButtonElement {
  static create(x, w) {
    const O = PageButtonElement.create(x._pagination.styles.pageButtons, !1);
    return O.innerHTML = String(w), setTimeout(() => PageNumberButtonEvents.setEvents(x, w, O)), O;
  }
}
class PaginationUpdatePageButtons {
  static removeLastNumberButton(x, w) {
    w[w.length - 1].remove();
    const O = w[0], D = Number(O.innerText);
    if (D > 1) {
      const U = PageNumberButtonElement.create(x, D - 1);
      O.insertAdjacentElement("beforebegin", U);
    }
  }
  static updateOnRowRemove(x) {
    const w = PaginationUtils.getPageNumberButtons(x._pagination), O = w[w.length - 1];
    Number(O.innerText) > PaginationUtils.getLastPossiblePageNumber(x) ? w.length > 1 && PaginationUpdatePageButtons.removeLastNumberButton(x, w) : x.data.length < (x.dataStartsAtHeader ? 1 : 2) && PageButtonElement.setDisabled(x._pagination);
  }
  static addNewNumberButtonAtEndIfNeeded(x, w) {
    const O = w[w.length - 1], D = PaginationUtils.getLastPossiblePageNumber(x, !0);
    if (Number(O.innerText) < D) {
      const U = PageNumberButtonElement.create(x, D);
      O.insertAdjacentElement("afterend", U);
    }
  }
  static updateOnRowInsert(x) {
    const w = x.dataStartsAtHeader ? 0 : 1;
    if (x.data.length === w)
      PageButtonElement.unsetDisabled(x._pagination);
    else {
      const O = PaginationUtils.getPageNumberButtons(x._pagination);
      O.length < x._pagination.maxNumberOfVisiblePageButtons && PaginationUpdatePageButtons.addNewNumberButtonAtEndIfNeeded(x, O);
    }
  }
  // prettier-ignore
  static shiftLeftwards(x, w, O) {
    const { activePageNumber: D } = x._pagination, U = w[0], W = Number(U.innerText);
    let X = D <= w.length / 2 ? W - 1 : O - D, G = W;
    X > w.length && (X = w.length, G = w.length + 1);
    for (let Y = X - 1; Y >= 0; Y -= 1) {
      const K = PageNumberButtonElement.create(x, G - Y - 1);
      U.insertAdjacentElement("beforebegin", K);
    }
    w.slice(w.length - X).forEach((Y) => Y.remove());
  }
  // prettier-ignore
  static shiftRightwards(x, w, O, D) {
    const { activePageNumber: U } = x._pagination, W = PaginationUtils.getLastPossiblePageNumber(x);
    let X = U > W - w.length / 2 ? W - O : U - D, G = O;
    X > w.length && (X = w.length, G = U - w.length);
    const Y = w[w.length - 1];
    for (let K = X - 1; K >= 0; K -= 1) {
      const Z = PageNumberButtonElement.create(x, K + G + 1);
      Y.insertAdjacentElement("afterend", Z);
    }
    w.slice(0, X).forEach((K) => K.remove());
  }
  static updateOnNewActive(x) {
    const w = PaginationUtils.getPageNumberButtons(x._pagination), { activePageNumber: O, maxNumberOfVisiblePageButtons: D } = x._pagination;
    if (w.length < D)
      return;
    const U = Number(w[w.length - 1].innerText), W = Math.floor(U - w.length / 2) + 1;
    if (O > W)
      PaginationUpdatePageButtons.shiftRightwards(x, w, U, W);
    else {
      const X = Math.ceil(U - w.length / 2);
      O < X && PaginationUpdatePageButtons.shiftLeftwards(x, w, X);
    }
  }
}
const _LoadingElement = class Ht {
  static createSpinner(x) {
    const w = document.createElement("span");
    return w.className = "loading-spinner", Object.assign(w.style, x), w;
  }
  static applyTableStyles(x, w, O) {
    x.forEach((D) => {
      w[D] && (O.style[D] = w[D]);
    });
  }
  static removeTableStyles(x, w) {
    x.forEach((O) => {
      delete w.style[O];
    });
  }
  static processCustom(x, w) {
    return x.style.display === "none" && (x.style.display = "block"), Object.assign(x.style, w?.container), x;
  }
  // prettier-ignore
  static createContainer(x, w) {
    const O = document.createElement("div");
    return w && Ht.applyTableStyles(
      ["width", "minWidth", "maxHeight", "height", "minHeight", "maxHeight", "border", "borderColor", "borderWidth"],
      w,
      O
    ), Object.assign(O.style, x?.container), O;
  }
  static createNew(x, w) {
    const O = Ht.createContainer(x, w);
    O.classList.add(Ht.DEFAULT_LOADING_CONTAINER_CLASS);
    const D = Ht.createSpinner(x?.spinner);
    return O.appendChild(D), O;
  }
  static processInitial(x) {
    const { loadingStyles: w, tableStyle: O } = x, D = x.children[0];
    return D ? Ht.processCustom(D, w) : Ht.createNew(w, O);
  }
  static addInitial(x) {
    var w;
    x._activeOverlayElements.loading = Ht.processInitial(x), (w = x.shadowRoot) == null || w.appendChild(x._activeOverlayElements.loading);
  }
  static update(x, w, O) {
    x.classList.contains(Ht.DEFAULT_LOADING_CONTAINER_CLASS) && w && (Ht.removeTableStyles(
      ["width", "minWidth", "maxHeight", "height", "minHeight", "maxHeight", "border", "borderColor", "borderWidth"],
      x
    ), Object.assign(x.style, O?.container)), O != null && O.loadingBackgroundColor && (x.style.backgroundColor = O?.loadingBackgroundColor);
  }
  static addActive(x) {
    var w;
    const { loading: O } = x._activeOverlayElements;
    O && (O.classList.contains(OuterContainerElements.ABSOULUTE_FULL_TABLE_CLASS) || (O.classList.add(OuterContainerElements.ABSOULUTE_FULL_TABLE_CLASS), Ht.update(O, x.tableStyle, x.loadingStyles)), (w = x._tableElementRef) == null || w.appendChild(O));
  }
};
_LoadingElement.DEFAULT_LOADING_CONTAINER_CLASS = "default-loading-container";
let LoadingElement = _LoadingElement;
class ErrorElement {
  static create() {
    const x = document.createElement("div");
    x.id = "error-container", x.classList.add(OuterContainerElements.ABSOULUTE_FULL_TABLE_CLASS);
    const w = document.createElement("div");
    return w.id = "error-text", w.innerHTML = "Error retrieving data", x.appendChild(w), x;
  }
  static display(x) {
    const { error: w } = x._activeOverlayElements;
    w && x._tableElementRef && x._tableElementRef.appendChild(w);
  }
  static remove(x) {
    var w;
    (w = x._activeOverlayElements.error) == null || w.remove();
  }
}
class PaginationAsyncUtils {
  static displayError(x, w) {
    ErrorElement.display(w), console.error(x), console.error("Error fetching page information");
  }
  // prettier-ignore
  static setNewElementText(x, w, O, D, U) {
    CellEvents.updateCell(
      x,
      w,
      U,
      D,
      { element: O, processText: !1, updateCellEvent: !1, updateTableEvent: !1 }
    ), ColumnTypesUtils.updateDataElements(x, U, D, O);
  }
  static insertData(x, w, O) {
    const D = x.dataStartsAtHeader ? 0 : 1, U = (O - 1) * 10 + D;
    w.length > x._pagination.rowsPerPage && (w = w.slice(0, x._pagination.rowsPerPage)), U + w.length > x.data.length && (w = w.slice(0, w.length - (U + w.length - x.data.length))), w.forEach((W, X) => {
      W.forEach((G, Y) => {
        const K = U + X, Z = x._columnsDetails[Y].elements[K];
        PaginationAsyncUtils.setNewElementText(x, G, Z, Y, K);
      });
    }), UpdateIndexColumnWidth.update(x);
  }
  static async getAndApplyNewData(x, w, O, D) {
    var U;
    const W = D || O;
    x._pagination.asyncGetId = W, ErrorElement.remove(x), LoadingElement.addActive(x), PageButtonElement.setActive(x, O);
    let X = [[]];
    try {
      if (X = await w.getPageData(O, x._pagination.rowsPerPage), x._pagination.asyncGetId !== W)
        return;
    } catch (G) {
      PaginationAsyncUtils.displayError(G, x);
    }
    PaginationAsyncUtils.insertData(x, X, O), (U = x._activeOverlayElements.loading) == null || U.remove(), PaginationUtils.displayRowsForDifferentButton(x, O);
  }
  static isAsyncPagination(x) {
    return typeof x == "object" && x.async;
  }
  static removeLoadingOverlay(x) {
    var w;
    PaginationAsyncUtils.isAsyncPagination(x.pagination) && ((w = x._activeOverlayElements.loading) == null || w.remove());
  }
  static preprocessTablePropertiesIfAsync(x) {
    var w;
    PaginationAsyncUtils.isAsyncPagination(x.pagination) && (x.displayAddNewRow = !1, x.displayAddNewColumn = !1, x.rowDropdown.displaySettings.isAvailable = !1, x.columnDropdown = { displaySettings: { isAvailable: !1 } }, x.files ?? (x.files = {}), x.files.buttons = (w = x.files.buttons) == null ? void 0 : w.filter((O) => !O.import), x.files.dragAndDrop = !1);
  }
}
const _PaginationUtils = class Et {
  static getLastPossiblePageNumber(x, w = !1) {
    const { _pagination: O, dataStartsAtHeader: D } = x;
    if (O.isAllRowsOptionSelected)
      return 1;
    const U = PaginationInternalUtils.getTotalNumberOfRows(x), W = D ? U + 1 : U, X = w ? W : W - 1;
    return Math.max(Math.ceil(X / O.rowsPerPage), 1);
  }
  static getPageNumberButtons(x) {
    const { buttonContainer: w, numberOfActionButtons: O } = x, D = Array.from(w.children), U = O / 2;
    return D.slice(U, D.length - U);
  }
  static hideRow(x) {
    var w;
    ((w = x.children[0]) == null ? void 0 : w.tagName) === CellElement.HEADER_TAG ? x.classList.add(Et.HIDDEN_ROW_CLASS) : x.style.display = "none";
  }
  static displayRow(x, w) {
    x.children[0].tagName === CellElement.HEADER_TAG ? x.classList.remove(Et.HIDDEN_ROW_CLASS) : x.style.display = "", w.push(x);
  }
  // changes to the page that the row was moved to
  static updateOnRowMove(x, w) {
    const { activePageNumber: O } = x._pagination;
    PaginationRowIndexes.getMaxVisibleRowIndex(x) <= w ? Et.displayRowsForDifferentButton(x, O + 1) : w > 0 && x._tableBodyElementRef && w < PaginationRowIndexes.getVisibleRowRealIndex(x._tableBodyElementRef, x._pagination, 0) && Et.displayRowsForDifferentButton(x, O - 1);
  }
  // prettier-ignore
  static getSiblingVisibleRow(x, w) {
    const O = x?.[w];
    if (!(!O || AddNewRowElement.isAddNewRowRow(O)))
      return O.classList.contains(FilterInternalUtils.HIDDEN_ROW_CLASS) ? Et.getSiblingVisibleRow(O, w) : O;
  }
  static updateRowsOnRemoval(x, w) {
    const { visibleRows: O, activePageNumber: D } = x._pagination;
    if (!(D === 1 && w === -1))
      if (O.splice(w, 1), O.length > 0) {
        const U = O[O.length - 1], W = Et.getSiblingVisibleRow(U, "nextSibling");
        W && Et.displayRow(W, O);
      } else
        D > 1 && (Et.displayRowsForDifferentButton(x, D - 1), x._visiblityInternal.filters && Et.getLastPossiblePageNumber(x) !== D - 1 && Et.displayRowsForDifferentButton(x, D));
  }
  static hideLastVisibleRow(x) {
    const { visibleRows: w } = x;
    if (w.length === 0)
      return;
    const O = w[w.length - 1];
    Et.hideRow(O), x.visibleRows.splice(x.visibleRows.length - 1, 1);
  }
  static updateRowsOnNewInsert(x, w, O) {
    const { rowsPerPage: D, visibleRows: U, activePageNumber: W, isAllRowsOptionSelected: X } = x._pagination;
    if (PaginationRowIndexes.getMaxVisibleRowIndex(x) > w && x._tableBodyElementRef) {
      U.length === D && !X && Et.hideLastVisibleRow(x._pagination);
      const G = PaginationRowIndexes.getVisibleRowIndex(x._tableBodyElementRef, x._pagination, w);
      U.splice(G === -1 ? U.length : G, 0, O);
    } else
      Et.hideRow(O), setTimeout(() => {
        const G = Et.getLastPossiblePageNumber(x), Y = W + 1;
        G < Y ? Et.setCorrectRowsAsVisible(x, G) : Et.displayRowsForDifferentButton(x, Y);
      });
  }
  // for removal - we pass visible row index as when filter is set - we need to get it before the element is removed
  static updateOnRowChange(x, w, O) {
    const { dataStartsAtHeader: D, _pagination: U } = x;
    !D && w === 0 && PaginationInternalUtils.getTotalNumberOfRows(x) === 0 || (PaginationVisibleButtonsUtils.unsetStateAndStyles(U), O ? (PaginationUpdatePageButtons.updateOnRowInsert(x), Et.updateRowsOnNewInsert(x, w, O)) : (PaginationUpdatePageButtons.updateOnRowRemove(x), Et.updateRowsOnRemoval(x, w)), PaginationPageActionButtonUtils.toggleActionButtons(x), PaginationVisibleButtonsUtils.setStateAndStyles(x), setTimeout(() => NumberOfVisibleRowsElement.update(x)));
  }
  static initialRowUpdates(x, w, O) {
    const D = x.dataStartsAtHeader ? w + 1 : w;
    D > x._pagination.rowsPerPage ? Et.hideRow(O) : D > 0 && x._pagination.visibleRows.push(O);
  }
  // REF-32
  static updateAddRowRow(x) {
    if (x._stripedRows && x._tableBodyElementRef && x._addRowCellElementRef) {
      const w = x._addRowCellElementRef.parentElement, O = Array.from(x._tableBodyElementRef.children).length - 1, D = Et.getLastPossiblePageNumber(x) !== x._pagination.activePageNumber;
      CustomRowProperties.updateRow(x, w, O, D, O);
    }
  }
  // prettier-ignore
  static setCorrectRowsAsVisible(x, w) {
    const { _pagination: { rowsPerPage: O, visibleRows: D }, _tableBodyElementRef: U, data: W, _visiblityInternal: X } = x, G = X != null && X.filters ? FilterInternalUtils.extractUnfilteredRows(U, W.length) : ExtractElements.textRowsArrFromTBody(U, W);
    let Y = O * (w - 1);
    x.dataStartsAtHeader || (Y += 1), G.slice(Y, Y + O).forEach((K) => {
      Et.displayRow(K, D);
    });
  }
  static hideAllRows(x) {
    x.visibleRows.forEach((w) => Et.hideRow(w)), x.visibleRows = [];
  }
  static displayRowsForDifferentButton(x, w) {
    Et.hideAllRows(x._pagination), Et.setCorrectRowsAsVisible(x, w), PageButtonElement.setActive(x, w), NumberOfVisibleRowsElement.update(x), x._frameComponents.displayAddNewRow && Et.updateAddRowRow(x);
  }
  static getFirstVisibleRow(x) {
    return x.find((w) => !w.classList.contains(FilterInternalUtils.HIDDEN_ROW_CLASS));
  }
  static async getAndApplyDataOnButtonClick(x, w, O) {
    x._pagination.async ? PaginationAsyncUtils.getAndApplyNewData(x, x._pagination.async, w, O) : Et.displayRowsForDifferentButton(x, w);
  }
};
_PaginationUtils.HIDDEN_ROW_CLASS = "hidden-row";
let PaginationUtils = _PaginationUtils;
class PaginationPageActionButtonUtils {
  static setButtonAsEnabled(x, w) {
    PageButtonStyle.setDefault(x, w, !0), x.classList.remove(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS);
  }
  static setButtonAsDisabled(x, w) {
    PageButtonStyle.setDisabled(x, w, !0), x.classList.add(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS);
  }
  // prettier-ignore
  static toggleRightButtons(x, w, O) {
    const { activePageNumber: D, styles: U } = x._pagination, W = PaginationUtils.getLastPossiblePageNumber(x), X = D === W ? PaginationPageActionButtonUtils.setButtonAsDisabled : PaginationPageActionButtonUtils.setButtonAsEnabled;
    w.slice(w.length - O).forEach((G) => X(G, U.pageButtons));
  }
  // prettier-ignore
  static toggleLeftButtons(x, w, O, D) {
    const U = w === 1 ? PaginationPageActionButtonUtils.setButtonAsDisabled : PaginationPageActionButtonUtils.setButtonAsEnabled;
    x.slice(0, O).forEach((W) => U(W, D.pageButtons));
  }
  static toggleActionButtons(x) {
    const { activePageNumber: w, styles: O, numberOfActionButtons: D, buttonContainer: U } = x._pagination, W = Array.from(U.children), X = D / 2;
    PaginationPageActionButtonUtils.toggleLeftButtons(W, w, X, O), PaginationPageActionButtonUtils.toggleRightButtons(x, W, X);
  }
}
class PageButtonEvents {
  static buttonMouseLeave(x, w, O) {
    const D = O.target;
    PageButtonStyle.mouseLeave(D, x, w);
  }
  static buttonMouseEnter(x, w, O) {
    const D = O.target;
    PageButtonStyle.mouseEnter(D, x, w);
  }
  static buttonMouseDown(x, w, O) {
    const D = O.target;
    PageButtonStyle.mouseDown(D, x, w);
  }
  static setEvents(x, w, O) {
    x.onmousedown = PageButtonEvents.buttonMouseDown.bind(this, w, O), x.onmouseenter = PageButtonEvents.buttonMouseEnter.bind(this, w, O), x.onmouseleave = PageButtonEvents.buttonMouseLeave.bind(this, w, O);
  }
}
const _PageButtonElement = class hr {
  static unsetDisabled(x) {
    const w = PaginationUtils.getPageNumberButtons(x)[0], { pageButtons: O } = x.styles;
    PageButtonStyle.setActive(w, O), w.classList.replace(hr.DISABLED_PAGINATION_BUTTON_CLASS, O.activeButtonClass);
  }
  static setDisabled(x) {
    const { buttonContainer: w, styles: O, numberOfActionButtons: D } = x, U = Array.from(w.children);
    for (let X = 0; X < D / 2; X += 1)
      PageButtonStyle.setDisabled(U[X], O.pageButtons, !0), PageButtonStyle.setDisabled(U[U.length - 1 - X], O.pageButtons, !0);
    const W = PaginationUtils.getPageNumberButtons(x)[0];
    PageButtonStyle.setDisabled(W, O.pageButtons, !1), W.classList.remove(O.pageButtons.activeButtonClass), U.forEach((X) => {
      X.classList.add(hr.DISABLED_PAGINATION_BUTTON_CLASS);
    });
  }
  // prettier-ignore
  static programmaticMouseEnterTrigger(x, w, O) {
    const D = x[O], { pageButtons: U } = w.styles;
    D && !D.classList.contains(U.activeButtonClass) && (PageButtonStyle.mouseEnter(D, U, !1), w.programaticallyHoveredPageNumberButton = D, setTimeout(() => delete w.programaticallyHoveredPageNumberButton));
  }
  static setNewActive(x, w) {
    const O = PaginationUtils.getPageNumberButtons(x), D = Number(O[O.length - 1].innerText), U = O.length - (D - w) - 1, W = O[U];
    return W.classList.add(x.styles.pageButtons.activeButtonClass), { newActiveButton: W, numberButtons: O };
  }
  static unsetPreviousActive(x, w) {
    const O = PaginationUtils.getPageNumberButtons(x), D = Number(O[O.length - 1].innerText), U = O.length - (D - x.activePageNumber) - 1, W = O[U], X = O.length - (D - w) - 1;
    return W ? (W.classList.remove(x.styles.pageButtons.activeButtonClass), { previousActiveButton: W, previousLocationOfNewIndex: X }) : { previousLocationOfNewIndex: X };
  }
  // prettier-ignore
  static setActive(x, w) {
    const { _pagination: O } = x, { styles: { pageButtons: D }, clickedPageNumberButton: U } = O, { previousActiveButton: W, previousLocationOfNewIndex: X } = hr.unsetPreviousActive(
      O,
      w
    );
    PaginationVisibleButtonsUtils.unsetStateAndStyles(x._pagination), O.activePageNumber = w, PaginationUpdatePageButtons.updateOnNewActive(x);
    const { newActiveButton: G, numberButtons: Y } = hr.setNewActive(O, w);
    PageButtonStyle.setActive(G, D, W), PaginationPageActionButtonUtils.toggleActionButtons(x), PaginationVisibleButtonsUtils.setStateAndStyles(x), U && hr.programmaticMouseEnterTrigger(Y, O, X);
  }
  static create(x, w) {
    const O = document.createElement("div");
    return O.classList.add(
      hr.PAGINATION_BUTTON_CLASS,
      PaginationElements.PAGINATION_TEXT_COMPONENT_CLASS,
      GenericElementUtils.NOT_SELECTABLE_CLASS
    ), PageButtonStyle.setDefault(O, x, w), setTimeout(() => PageButtonEvents.setEvents(O, x, w)), O;
  }
};
_PageButtonElement.PAGINATION_BUTTON_CLASS = "pagination-button";
_PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS = "pagination-button-disabled";
_PageButtonElement.ACTIVE_PAGINATION_BUTTON_CLASS = "pagination-button-active";
_PageButtonElement.PRECEDENCE_ACTIVE_PAGINATION_BUTTON_CLASS = "pagination-button-active-precedence";
let PageButtonElement = _PageButtonElement;
const _PaginationVisibleButtonsUtils = class yt {
  static getRightBorderWidthInStyleOverride(x) {
    return x.borderRightWidth ? Number.parseInt(x.borderRightWidth) : x.borderRight ? Number.parseInt(x.borderRight.split(" ")[0]) : -1;
  }
  // if the last button is active page (no action buttons displayed) and it has precedence, the override right border
  // will not take place and it will either have no right border or active style right border:
  // this is problematic as the border difference will cause the entire container to have a different width
  // which will in turn cause the pagination components to shift when the last button is clicked,
  // to prevent this we add the border style that would have been overriden
  static setBorderPaddingForLastPrecedence(x, w) {
    const O = yt.getRightBorderWidthInStyleOverride(w);
    if (isNaN(O) || O === 0)
      return;
    const D = Number.parseInt(getComputedStyle(x).borderRightWidth);
    D > 0 ? x.style.borderRightWidth = `${D + O}px` : x.style.borderRight = `${O}px solid #fafafa01`;
  }
  static setStyle(x, w, O, D) {
    if (!D)
      return;
    const U = new Set(Object.keys(D)), W = x.classList.contains(PageButtonElement.PRECEDENCE_ACTIVE_PAGINATION_BUTTON_CLASS);
    W && w.forEach((X) => U.delete(X)), U.forEach((X) => {
      ElementStyle.setStyle(x, X, D[X]);
    }), O && W && yt.setBorderPaddingForLastPrecedence(x, D);
  }
  // prettier-ignore
  static overrideOnMouseEvent(x, w) {
    const { firstVisibleButtonOverride: O, lastVisibleButtonOverride: D } = w;
    x.classList.contains(yt.FIRST_VISIBLE_CLASS) && yt.setStyle(
      x,
      yt.FIRST_PRECEDENCE_VALUES,
      !1,
      O
    ), x.classList.contains(yt.LAST_VISIBLE_CLASS) && yt.setStyle(
      x,
      yt.LAST_PRECEDENCE_VALUES,
      !0,
      D
    );
  }
  // prettier-ignore
  static unsetStateAndStyles(x) {
    const {
      styles: { pageButtons: { firstVisibleButtonOverride: w, lastVisibleButtonOverride: O } },
      visibleEdgeButtons: D
    } = x;
    D.length !== 0 && (w && ElementStyle.unsetStyle(D[0], w), D[0].classList.remove(yt.FIRST_VISIBLE_CLASS), O && ElementStyle.unsetStyle(D[1], O), D[1].classList.remove(yt.LAST_VISIBLE_CLASS), x.visibleEdgeButtons = []);
  }
  // when the button display property is false - clientWidth is 0
  static isButtonVisible(x) {
    return x.clientWidth > 0 && x.style.visibility !== "hidden";
  }
  // prettier-ignore
  static set(x, w, O) {
    const { styles: { pageButtons: { firstVisibleButtonOverride: D, lastVisibleButtonOverride: U } } } = O, W = x[w];
    if (!W)
      return;
    W.classList.contains(yt.FIRST_VISIBLE_CLASS) || (yt.setStyle(
      W,
      yt.FIRST_PRECEDENCE_VALUES,
      !1,
      D
    ), W.classList.add(yt.FIRST_VISIBLE_CLASS));
    const X = x.findLastIndex(yt.isButtonVisible), G = x[X];
    G.classList.contains(yt.LAST_VISIBLE_CLASS) || (yt.setStyle(
      G,
      yt.LAST_PRECEDENCE_VALUES,
      !0,
      U
    ), G.classList.add(yt.LAST_VISIBLE_CLASS)), O.visibleEdgeButtons = [W, G];
  }
  static setStateAndStyles(x) {
    const { _pagination: w, displayAddNewRow: O } = x, D = Array.from(w.buttonContainer.children), U = D.findIndex(yt.isButtonVisible);
    U === -1 ? setTimeout(() => {
      const W = D.findIndex(yt.isButtonVisible);
      yt.set(D, W, w);
    }) : yt.set(D, U, w), O || RowElement.toggleLastRowClass(x);
  }
};
_PaginationVisibleButtonsUtils.FIRST_VISIBLE_CLASS = "pagination-first-visible-button";
_PaginationVisibleButtonsUtils.LAST_VISIBLE_CLASS = "pagination-last-visible-button";
_PaginationVisibleButtonsUtils.FIRST_PRECEDENCE_VALUES = ["borderLeft", "borderLeftWidth", "borderLeftColor"];
_PaginationVisibleButtonsUtils.LAST_PRECEDENCE_VALUES = ["borderRight", "borderRightWidth", "borderRightColor"];
let PaginationVisibleButtonsUtils = _PaginationVisibleButtonsUtils;
function buildIcon$1(F) {
  return `<?xml version="1.0" encoding="utf-8"?>
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: ${F}">
      <path d="M5.5 5L11.7929 11.2929C12.1834 11.6834 12.1834 12.3166 11.7929 12.7071L5.5 19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>`;
}
const PREVIOUS_PAGE_ICON_SVG_STRING = buildIcon$1("rotate(180deg)"), NEXT_PAGE_ICON_SVG_STRING = buildIcon$1("");
class PreviousPageButtonEvents {
  static buttonMouseUp(x) {
    const { activePageNumber: w, styles: O } = this._pagination;
    if (w === 1)
      return;
    PaginationUtils.getAndApplyDataOnButtonClick(this, w - 1);
    const D = x.target;
    PageButtonStyle.mouseEnter(D, O.pageButtons, !0);
  }
  static setEvents(x, w) {
    w.onmouseup = PreviousPageButtonEvents.buttonMouseUp.bind(x);
  }
}
class PreviousPageButtonElement {
  static populate(x, w) {
    if (w)
      x.innerHTML = String(w);
    else {
      const O = SVGIconUtils.createSVGElement(PREVIOUS_PAGE_ICON_SVG_STRING);
      O.classList.add("pagination-prev-next-button"), x.appendChild(O);
    }
  }
  static create(x) {
    const { pageButtons: w } = x._pagination.styles, O = PageButtonElement.create(w, !0);
    return PreviousPageButtonElement.populate(O, w.actionButtons.previousText), setTimeout(() => PreviousPageButtonEvents.setEvents(x, O)), O;
  }
}
function buildIcon(F) {
  return `<?xml version="1.0" encoding="utf-8"?>
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: ${F}">
      <path d="M5.5 5L11.7929 11.2929C12.1834 11.6834 12.1834 12.3166 11.7929 12.7071L5.5 19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M13.5 5L19.7929 11.2929C20.1834 11.6834 20.1834 12.3166 19.7929 12.7071L13.5 19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>`;
}
const FIRST_PAGE_ICON_SVG_STRING = buildIcon("rotate(180deg)"), LAST_PAGE_ICON_SVG_STRING = buildIcon("");
class FirstPageButtonEvents {
  static buttonMouseUp(x) {
    const w = x.target;
    PageButtonStyle.mouseEnter(w, this._pagination.styles.pageButtons, !0), this._pagination.activePageNumber !== 1 && PaginationUtils.getAndApplyDataOnButtonClick(this, 1);
  }
  static setEvents(x, w) {
    w.onmouseup = FirstPageButtonEvents.buttonMouseUp.bind(x);
  }
}
class FirstPageButtonElement {
  static populate(x, w) {
    if (w)
      x.innerHTML = String(w);
    else {
      const O = SVGIconUtils.createSVGElement(FIRST_PAGE_ICON_SVG_STRING);
      O.classList.add("pagination-first-last-button"), x.appendChild(O);
    }
  }
  static create(x) {
    const { pageButtons: w } = x._pagination.styles, O = PageButtonElement.create(w, !0);
    return FirstPageButtonElement.populate(O, w.actionButtons.firstText), setTimeout(() => FirstPageButtonEvents.setEvents(x, O)), O;
  }
}
class LastPageButtonEvents {
  static buttonMouseUp(x) {
    const w = x.target, { activePageNumber: O, styles: D } = this._pagination;
    PageButtonStyle.mouseEnter(w, D.pageButtons, !0);
    const U = PaginationUtils.getLastPossiblePageNumber(this);
    U <= O || PaginationUtils.getAndApplyDataOnButtonClick(this, U);
  }
  static setEvents(x, w) {
    w.onmouseup = LastPageButtonEvents.buttonMouseUp.bind(x);
  }
}
class LastPageButtonElement {
  static populate(x, w) {
    if (w)
      x.innerHTML = String(w);
    else {
      const O = SVGIconUtils.createSVGElement(LAST_PAGE_ICON_SVG_STRING);
      O.classList.add("pagination-first-last-button"), x.appendChild(O);
    }
  }
  static create(x) {
    const { pageButtons: w } = x._pagination.styles, O = PageButtonElement.create(w, !0);
    return LastPageButtonElement.populate(O, w.actionButtons.lastText), setTimeout(() => LastPageButtonEvents.setEvents(x, O)), O;
  }
}
class NextPageButtonEvents {
  static buttonMouseUp(x) {
    const { activePageNumber: w, styles: O } = this._pagination;
    if (PaginationUtils.getLastPossiblePageNumber(this) <= w)
      return;
    PaginationUtils.getAndApplyDataOnButtonClick(this, w + 1);
    const D = x.target;
    PageButtonStyle.mouseEnter(D, O.pageButtons, !0);
  }
  static setEvents(x, w) {
    w.onmouseup = NextPageButtonEvents.buttonMouseUp.bind(x);
  }
}
class NextPageButtonElement {
  static populate(x, w) {
    if (w)
      x.innerHTML = String(w);
    else {
      const O = SVGIconUtils.createSVGElement(NEXT_PAGE_ICON_SVG_STRING);
      O.classList.add("pagination-prev-next-button"), x.appendChild(O);
    }
  }
  static create(x) {
    const { pageButtons: w } = x._pagination.styles, O = PageButtonElement.create(w, !0);
    return NextPageButtonElement.populate(O, w.actionButtons.nextText), setTimeout(() => NextPageButtonEvents.setEvents(x, O)), O;
  }
}
class PageButtonContainerEvents {
  // REF-31
  static containerMouseLeave(x) {
    const { clickedPageNumberButton: w, programaticallyHoveredPageNumberButton: O, styles: D } = x;
    w && O && PageButtonStyle.mouseLeave(O, D.pageButtons, !1);
  }
  static setEvents(x, w) {
    x.onmouseleave = PageButtonContainerEvents.containerMouseLeave.bind(this, w);
  }
}
const _PageButtonContainerElement = class Wt {
  static shouldButtonsBeActive(x) {
    const w = x.dataStartsAtHeader ? 1 : 2;
    return x.data.length >= w;
  }
  static setStyle(x, w) {
    Wt.shouldButtonsBeActive(x) ? PageButtonElement.setActive(x, w ?? 1) : PageButtonElement.setDisabled(x._pagination);
  }
  static addNumberButtons(x) {
    const w = PaginationUtils.getLastPossiblePageNumber(x), { maxNumberOfVisiblePageButtons: O, buttonContainer: D } = x._pagination;
    for (let U = 0; U < Math.min(w, O); U += 1) {
      const W = PageNumberButtonElement.create(x, U + 1);
      D.appendChild(W);
    }
  }
  static addButton(x, w) {
    x.buttonContainer.appendChild(w), x.numberOfActionButtons += 1;
  }
  static addButtons(x) {
    const { displayPrevNext: w, displayFirstLast: O } = x._pagination;
    O && Wt.addButton(x._pagination, FirstPageButtonElement.create(x)), w && Wt.addButton(x._pagination, PreviousPageButtonElement.create(x)), Wt.addNumberButtons(x), w && Wt.addButton(x._pagination, NextPageButtonElement.create(x)), O && Wt.addButton(x._pagination, LastPageButtonElement.create(x));
  }
  static resetState(x) {
    x.activePageNumber = 1, x.numberOfActionButtons = 0, x.visibleEdgeButtons = [];
  }
  static repopulateButtons(x) {
    Wt.resetState(x._pagination), x._pagination.buttonContainer.replaceChildren(), Wt.addButtons(x), Wt.setStyle(x);
  }
  static addInitialElements(x, w) {
    Wt.repopulateButtons(x), PaginationVisibleButtonsUtils.setStateAndStyles(x);
    const { positions: O, buttonContainer: D } = x._pagination;
    OuterContainerElements.addToContainer(O.pageButtons.position, w, D);
  }
  static create(x) {
    const w = document.createElement("div");
    w.id = Wt.PAGINATION_BUTTON_CONTAINER_ID;
    const { styles: O, positions: D } = x._pagination;
    return w.style.order = String(D.pageButtons.order), Object.assign(w.style, O.pageButtons.container), PageButtonContainerEvents.setEvents(w, x._pagination), w;
  }
};
_PageButtonContainerElement.PAGINATION_BUTTON_CONTAINER_ID = "pagination-button-container";
let PageButtonContainerElement = _PageButtonContainerElement;
class InitialDataProcessing {
  static cleanupDataThatDidNotGetAdded(x, w) {
    var O;
    ((O = x[0]) == null ? void 0 : O.length) - w.length > 0 && x.forEach((D) => D.splice(w.length)), w.length === 0 ? x.splice(0, x.length) : x.length > w[0].elements.length && x.splice(w[0].elements.length);
  }
  static postProcess(x, w) {
    setTimeout(() => InitialDataProcessing.cleanupDataThatDidNotGetAdded(x, w));
  }
  static fillRow(x, w) {
    const O = new Array(w - x.length).fill(EMPTY_STRING);
    x.splice(x.length, w - x.length, ...O);
  }
  static processRowDataByLength(x, w) {
    w === 0 && x.splice(0, x.length), x.forEach((O) => {
      O.length < w && InitialDataProcessing.fillRow(O, w);
    });
  }
  static getMaxRowLength(x) {
    return x.reduce((w, O) => Math.max(w, O.length), 0);
  }
  static removeRowsExceedingLimit(x, w) {
    w !== void 0 && w > 0 && x.length > w && x.splice(w, x.length - 1);
  }
  static removeDuplicateHeaders(x, w) {
    const O = x[0];
    O.reduce((D, U, W) => (D.has(U) ? O[W] = w || "" : D.add(U), D), /* @__PURE__ */ new Set());
  }
  static preProcess(x, w) {
    const { maxRows: O, allowDuplicateHeaders: D, _defaultColumnsSettings: U } = x;
    InitialDataProcessing.removeRowsExceedingLimit(w, O);
    const W = InitialDataProcessing.getMaxRowLength(w);
    InitialDataProcessing.processRowDataByLength(w, W), !D && w.length > 0 && InitialDataProcessing.removeDuplicateHeaders(w, U.defaultText);
  }
}
class PaginationAsyncStartData {
  static fillTotalDataRows(x, w) {
    var O;
    const { totalDataRows: D, data: U, failed: W } = w;
    if (x.data.length < D || W) {
      const X = Math.max(((O = x.data[0]) == null ? void 0 : O.length) || 0, InitialDataProcessing.getMaxRowLength(U)), G = +!x.dataStartsAtHeader, Y = new Array(D - x.data.length + G).fill(
        new Array(X).fill(EMPTY_STRING)
      ), K = x.data.length;
      x.data.splice(x.data.length, 0, ...Y), Y.forEach((Z, q) => {
        const J = InsertNewRow.insertNewRow(x, K + q, !1, Z);
        setTimeout(() => {
          UpdateCellsForRows.updateRowCells(x, J, K + q, CELL_UPDATE_TYPE.UPDATE, !1);
        });
      }), PageButtonContainerElement.repopulateButtons(x);
    }
  }
  static populate(x, w) {
    const { data: O, totalDataRows: D, failed: U } = w;
    O.length > 0 && D > 0 && (x.data.length > 0 || InitialDataProcessing.getMaxRowLength(O) > 0) && (PaginationAsyncStartData.fillTotalDataRows(x, w), U || PaginationAsyncUtils.insertData(x, O, 1));
  }
  static async get(x, w, O) {
    const { async: D, rowsPerPage: U } = w;
    if (!D)
      return;
    const { rowsPerPage: W } = O, X = typeof U == "number" ? U : W;
    try {
      const [G, Y] = await Promise.all([D.getTotalRows(), D.getPageData(1, X)]);
      return { totalDataRows: G, data: Y };
    } catch (G) {
      return setTimeout(() => PaginationAsyncUtils.displayError(G, x)), { totalDataRows: 0, data: [["", ""]], failed: !0 };
    }
  }
}
class FrameComponentsElements {
  // index and add column cells are added on row insertion
  // CAUTION-4
  static addFrameBodyElements(x) {
    var w, O;
    (O = x._tableBodyElementRef) == null || O.appendChild((w = x._addRowCellElementRef) == null ? void 0 : w.parentElement), ToggleAdditionElements.update(x, !0, AddNewRowElement.toggle);
  }
}
const _SheetJSInternalUtils = class ra {
  // REF-17
  static async execFuncWithExtractorModule(x) {
    const w = window.XLSX;
    w ? x(w) : console.error(ra.MODULE_NOT_FOUND_ERROR);
  }
};
_SheetJSInternalUtils.MODULE_NOT_FOUND_ERROR = "xlsx module was not found";
let SheetJSInternalUtils = _SheetJSInternalUtils;
class UpdateAllTableData {
  static toggleAdditionalElements(x) {
    FilterInternalUtils.completeReset(x), ToggleAdditionElements.update(x, !0, AddNewRowElement.toggle), setTimeout(() => {
      x._pagination && x._pagination.activePageNumber !== 1 && PaginationUtils.displayRowsForDifferentButton(x, 1);
    });
  }
  static insertData(x, w, O) {
    InsertMatrix.insert(x, w, O, 0, !0), O === 0 && RootCellElement.convertFromRootCell(x);
  }
  static changeTableData(x, w, O, D) {
    for (let U = x.data.length - 1; U >= O; U -= 1)
      RemoveRow.remove(x, U);
    InitialDataProcessing.preProcess(x, w), x._isPopulatingTable = !0, D ? (UpdateAllTableData.insertData(x, w, O), UpdateAllTableData.toggleAdditionalElements(x), x._isPopulatingTable = !0) : (setTimeout(() => {
      UpdateAllTableData.insertData(x, w, O);
    }), setTimeout(() => {
      UpdateAllTableData.toggleAdditionalElements(x), x._isPopulatingTable = !0;
    }, 6));
  }
  static update(x, w, O, D = !1) {
    if (!Array.isArray(w))
      return;
    let U = !1;
    x._visiblityInternal.filters && (U = FilterInternalUtils.unsetAllFilters(x)), !D && U ? setTimeout(() => UpdateAllTableData.changeTableData(x, w, O, D), 40) : UpdateAllTableData.changeTableData(x, w, O, D);
  }
}
class CSVImport {
  static getPaddedArray(x, w) {
    return x.map((O) => O.concat(Array(w).fill("")).slice(0, w));
  }
  static splitRow(x) {
    const w = /("[^"]*"|[^,]+)(,|$)/g, O = [];
    return x.replace(w, (D, U) => (O.push(U), "")), O;
  }
  static parseDataFromRow(x, w, O) {
    const D = CSVImport.splitRow(x);
    return D.length > 0 && (w.push(D), D.length > O && (O = D.length)), O;
  }
  // TO-DO validation and error handling
  static parseCSV(x) {
    try {
      const w = x.split(/\r\n|\n/), O = [];
      let D = 0;
      return w.forEach((U) => {
        D = CSVImport.parseDataFromRow(U, O, D);
      }), CSVImport.getPaddedArray(O, D);
    } catch {
      return console.error("Incorrect format"), null;
    }
  }
  static getStartRowIndex(x, w) {
    return w && typeof w.tableRowStartIndex == "number" ? w.tableRowStartIndex < 0 || w.tableRowStartIndex > x ? x : w.tableRowStartIndex : 0;
  }
  static processFile(x, w, O) {
    const D = CSVImport.parseCSV(w);
    if (D && O && typeof O.importRowStartIndex == "number" && D.splice(0, O.importRowStartIndex), !D || D.length === 0)
      return;
    const U = CSVImport.getStartRowIndex(x.data.length, O);
    UpdateAllTableData.update(x, D, U);
  }
  static import(x, w, O) {
    const D = new FileReader();
    D.readAsText(w), D.onload = (U) => {
      var W;
      return CSVImport.processFile(x, (W = U.target) == null ? void 0 : W.result, O);
    };
  }
}
class SheetJSImport {
  static import(x, w, O) {
    const D = new FileReader();
    D.readAsBinaryString(w), D.onload = (U) => {
      var W;
      const X = O.read((W = U.target) == null ? void 0 : W.result, { type: "binary" });
      X.SheetNames.forEach((G) => {
        const Y = O.utils.sheet_to_csv(X.Sheets[G]);
        CSVImport.processFile(x, Y);
      });
    };
  }
}
const ACCEPTED_FILE_FORMATS = ["csv", "xls", "xlsx", "ods", "txt"], DEFAULT_FILE_FORMATS = ["csv"];
class FileImportButtonEvents {
  static importFile(x, w, O, D) {
    O.find((U) => w.name.endsWith(U)) && (w.name.endsWith(".csv") ? CSVImport.import(x, w, D) : SheetJSInternalUtils.execFuncWithExtractorModule(SheetJSImport.import.bind(this, x, w)));
  }
  static inputChange(x, w, O) {
    var D;
    const U = O.target, W = (D = U.files) == null ? void 0 : D[0];
    FileImportButtonEvents.importFile(x, W, ACCEPTED_FILE_FORMATS, w), U.value = "";
  }
  static getAcceptedFormats(x) {
    return x != null && x.formats && x.formats.length > 0 ? x.formats : DEFAULT_FILE_FORMATS;
  }
  static triggerImportPrompt(x, w) {
    const O = x._files.inputElementRef, D = FileImportButtonEvents.getAcceptedFormats(w);
    O.accept = D.map((U) => `.${U}`).join(","), O.onchange = FileImportButtonEvents.inputChange.bind(this, x, w?.overwriteOptions), O.click();
  }
  static setEvents(x, w, O) {
    w.onclick = FileImportButtonEvents.triggerImportPrompt.bind(this, x, O);
  }
}
class DragAndDropEvents {
  static async uploadFile(x, w, O) {
    var D, U, W;
    const X = (U = (D = O.dataTransfer) == null ? void 0 : D.files) == null ? void 0 : U[0], G = typeof ((W = x.files) == null ? void 0 : W.dragAndDrop) == "object" ? x.files.dragAndDrop.overwriteOptions : void 0;
    FileImportButtonEvents.importFile(x, X, w, G);
  }
  static toggleOverlayElement(x, w) {
    x.style.display = w ? "block" : "none";
  }
  static getAcceptedFileFormats(x) {
    var w;
    if (typeof x?.dragAndDrop == "object" && x.dragAndDrop.formats)
      return x.dragAndDrop.formats;
    const O = (w = x?.buttons) == null ? void 0 : w.filter((D) => D.import).map((D) => typeof D.import == "object" && D.import.formats ? D.import.formats : DEFAULT_FILE_FORMATS).flat(1);
    return O && O.length > 0 ? Array.from(new Set(O)) : DEFAULT_FILE_FORMATS;
  }
  static setEvents(x, w, O) {
    const D = DragAndDropEvents.getAcceptedFileFormats(x.files);
    w.ondragenter = (U) => {
      U.preventDefault(), DragAndDropEvents.toggleOverlayElement(O, !0);
    }, O.ondragleave = (U) => {
      U.preventDefault(), DragAndDropEvents.toggleOverlayElement(O, !1);
    }, O.ondragover = (U) => {
      U.preventDefault();
    }, O.ondrop = (U) => {
      U.preventDefault(), DragAndDropEvents.uploadFile(x, D, U), DragAndDropEvents.toggleOverlayElement(O, !1);
    };
  }
}
class DragAndDropElement {
  static createOverlayElement(x) {
    const w = document.createElement("div");
    return w.id = "drag-and-drop-overlay", typeof x.dragAndDrop == "object" && Object.assign(w.style, x.dragAndDrop.overlayStyle), w;
  }
  static append(x, w) {
    const O = DragAndDropElement.createOverlayElement(x.files);
    DragAndDropEvents.setEvents(x, w, O), w.appendChild(O);
  }
  static isEnabled(x) {
    var w;
    return x?.dragAndDrop !== void 0 ? !!x.dragAndDrop : !!((w = x?.buttons) != null && w.find((O) => O.import));
  }
}
const _StickyPropsUtils = class aa {
  static process(x) {
    var w;
    typeof x.stickyHeader == "boolean" ? x._stickyProps.header = x.stickyHeader : (w = x.overflow) != null && w.maxHeight && (x._stickyProps.header = !0);
  }
  // REF-37
  // prettier-ignore
  static moveTopBorderToHeaderCells(x) {
    const { _tableElementRef: w, _tableBodyElementRef: O } = x;
    !w || !O || (O.classList.add(aa.NO_OVERFLOW_STICKY_HEADER_BODY_CLASS), w.style.border && (O.style.borderTop = w.style.border), w.style.borderColor && (O.style.borderTopColor = w.style.borderColor), ElementStyle.moveStyles(
      w,
      O,
      "borderTop",
      "borderTopColor",
      "borderTopWidth",
      "borderTopStyle"
    ), w.style.borderTop = "unset");
  }
};
_StickyPropsUtils.NO_OVERFLOW_STICKY_HEADER_BODY_CLASS = "no-overflow-sticky-header-body";
let StickyPropsUtils = _StickyPropsUtils;
class ColumnSizerSetWidth {
  static getWidthDelta(x, w) {
    return x < w.left ? w.left : x > w.right ? w.right : x;
  }
  static getNewColumnWidth(x, w) {
    const { moveLimits: O, mouseMoveOffset: D, initialOffset: U } = x, W = ColumnSizerSetWidth.getWidthDelta(D, O) - U;
    return Math.max(0, Number.parseFloat(w.style.width) + W);
  }
  static setColumnWidth(x, w) {
    const O = ColumnSizerSetWidth.getNewColumnWidth(x, w);
    w.style.width = `${O}px`;
  }
  // when the user moves the sizer to the start/end of a column in an attempt to completely crush the column,
  // the dom will not allow that and will leave enough space for the column to display its text,
  // the problem is that the widths will be set incorrectly and need to be corrected
  // prettier-ignore
  static correctWidths(x, w, O, D) {
    if (w.offsetWidth !== Math.round(Number.parseFloat(w.style.width))) {
      const U = `${w.offsetWidth}px`, W = `${D - w.offsetWidth}px`;
      w.style.width = U, O.style.width = W, x.wasAutoresized = !0, setTimeout(() => x.wasAutoresized = !1);
    }
  }
  // prettier-ignore
  static setWidths(x, w, O, D) {
    const U = ColumnSizerSetWidth.getNewColumnWidth(x, w), W = Math.max(0, D - U);
    w.style.width = `${U}px`, O.style.width = `${W}px`;
  }
  // prettier-ignore
  static setColumnsWidths(x, w, O) {
    const D = Number.parseFloat(w.style.width), U = Number.parseFloat(O.style.width), W = D + U;
    ColumnSizerSetWidth.setWidths(x, w, O, W), U > D ? ColumnSizerSetWidth.correctWidths(x, w, O, W) : ColumnSizerSetWidth.correctWidths(x, O, w, W);
  }
  // left or right header in respect to the position of the sizer element
  // prettier-ignore
  static set(x, w, O, D, U) {
    U && StaticTable.isStaticTableWidth(w, O) ? ColumnSizerSetWidth.setColumnsWidths(x, D, U) : ColumnSizerSetWidth.setColumnWidth(x, D), setTimeout(() => x.fireColumnsUpdate());
  }
}
class ColumnSizerExtrinsicEvents {
  static moveMovableElement(x, w, O) {
    const { columnSizer: D } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(x.id, w);
    D.movableElement.style.left = `${O}px`;
  }
  // prettier-ignore
  static windowMouseMove(x, w) {
    const { _activeOverlayElements: { selectedColumnSizer: O }, _columnsDetails: D } = x;
    if (O) {
      const { moveLimits: U, element: W } = O;
      O.mouseMoveOffset += w, O.mouseMoveOffset >= U.left && O.mouseMoveOffset <= U.right && ColumnSizerExtrinsicEvents.moveMovableElement(W, D, O.mouseMoveOffset);
    }
  }
  // prettier-ignore
  static setWidth(x, w, O, D, U) {
    ColumnSizerElement.unsetTransitionTime(x.element), ColumnSizerSetWidth.set(x, w, O, D, U);
  }
  // prettier-ignore
  static mouseUp(x) {
    var w;
    const { _activeOverlayElements: O, _columnsDetails: D, _tableDimensions: U, _tableElementRef: W } = x, X = O.selectedColumnSizer, { columnSizer: G, headerCell: Y, sizerNumber: K } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(
      X.element.id,
      D
    );
    ColumnSizerExtrinsicEvents.setWidth(
      X,
      W,
      U,
      Y,
      ColumnSizerGenericUtils.findNextResizableColumnHeader(D, K)
    ), MovableColumnSizerElement.hide(G.movableElement), UpdateRowElement.updateHeaderRowHeight((w = G.element.parentElement) == null ? void 0 : w.parentElement);
  }
  static setSizerStyleToHoverNoAnimation(x, w) {
    const { width: O } = x.styles.hover;
    ColumnSizerElement.setHoverStyle(x, O, !1, w), ColumnSizerElement.unsetBackgroundImage(x.element);
  }
  static mouseUpNotOnSizer(x) {
    const { element: w, styles: O, movableElement: D } = x;
    ColumnSizerExtrinsicEvents.setSizerStyleToHoverNoAnimation(x, D.style.backgroundColor), setTimeout(() => {
      ColumnSizerElement.setTransitionTime(w), ColumnSizerElement.unsetElementsToDefault(w, O.default.width, !1), ColumnSizerElement.hideWhenCellNotHovered(x, !0);
    }), setTimeout(() => {
      ColumnSizerElement.setBackgroundImage(w, O.default.backgroundImage), ColumnSizerElement.setBackgroundColor(w, SEMI_TRANSPARENT_COLOR);
    }, ColumnSizerElement.TRANSITION_TIME_ML);
  }
  // if the user clicks mouse up on the table first - this will not be activated as columnSizer selected will be removed
  // prettier-ignore
  static windowMouseUp(x) {
    const { columnSizer: w } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(
      x._activeOverlayElements.selectedColumnSizer.element.id,
      x._columnsDetails
    );
    ColumnSizerExtrinsicEvents.mouseUp(x), ColumnSizerExtrinsicEvents.mouseUpNotOnSizer(w), delete x._activeOverlayElements.selectedColumnSizer;
  }
  static mouseUpOnSizer(x) {
    ColumnSizerExtrinsicEvents.setSizerStyleToHoverNoAnimation(x), x.isMouseUpOnSizer = !0, setTimeout(() => {
      x.isMouseUpOnSizer = !1, ColumnSizerElement.setTransitionTime(x.element);
    });
  }
  // this method is used to get what exact element was clicked on as window events just returns the component as the target
  // prettier-ignore
  static tableMouseUp(x, w) {
    const O = x._activeOverlayElements.selectedColumnSizer, { columnSizer: D } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(
      O.element.id,
      x._columnsDetails
    );
    ColumnSizerExtrinsicEvents.mouseUp(x), MovableColumnSizerElement.isMovableColumnSizer(w) && !O.wasAutoresized ? ColumnSizerExtrinsicEvents.mouseUpOnSizer(D) : ColumnSizerExtrinsicEvents.mouseUpNotOnSizer(D), delete x._activeOverlayElements.selectedColumnSizer;
  }
}
class TableEvents {
  // not using hoveredElements state as the targetElement will be the element clicked, hence need to use
  // activeOverlayElements.datePickerCell to get the cell of the date picker input
  static closeDatePicker(x, w) {
    x.datePickerCell && (x.datePickerCell !== CellElement.getCellElement(w) && DateCellInputElement.toggle(x.datePickerCell, !1), delete x.datePickerCell);
  }
  // REF-44
  // text blur will not activate when the dropdown has been clicked and will not close if its scrollbar, padding
  // or delete category buttons are clicked. If the user clicks elsewhere on the table, the dropdown is closed
  // programmatically as follows
  // prettier-ignore
  static closeCellDropdown(x, w) {
    const { _focusedElements: O } = x;
    O.cellDropdown && !Dropdown.isPartOfDropdownElement(w) && !w.classList.contains(OptionColorButton.COLOR_BUTTON_CLASS) && O.cell.element !== CellElement.getCellElement(w) && CellWithTextEvents.programmaticBlur(x);
  }
  static onMouseDown(x) {
    const w = x.target;
    UserKeyEventsStateUtils.temporarilyIndicateEvent(this._userKeyEventsState, MOUSE_EVENT.DOWN), TableEvents.closeCellDropdown(this, w), TableEvents.closeDatePicker(this._activeOverlayElements, x.target);
  }
  static onMouseUp(x) {
    this._activeOverlayElements.selectedColumnSizer && ColumnSizerExtrinsicEvents.tableMouseUp(this, x.target);
  }
}
class TableElement {
  static changeStaticWidthTotal(x, w) {
    x.staticWidth += w;
  }
  // prettier-ignore
  static setStaticWidthContentTotal(x) {
    const { _frameComponents: { displayAddNewColumn: w, displayIndexColumn: O }, _tableDimensions: D } = x;
    D.staticWidth = D.border.leftWidth + D.border.rightWidth, w && (D.staticWidth += AddNewColumnElement.DEFAULT_WIDTH), O && (D.staticWidth += IndexColumn.DEFAULT_WIDTH);
  }
  // prettier-ignore
  static addOverlayElements(x, w, O) {
    var D;
    const U = FullTableOverlayElement.create(x);
    O.fullTableOverlay = U;
    const W = ((D = x._overflow) == null ? void 0 : D.overflowContainer) || w;
    W.appendChild(U), DragAndDropElement.isEnabled(x.files) && DragAndDropElement.append(x, W);
    const X = ColumnDropdown.create(x);
    if (w.appendChild(X), O.columnDropdown = X, x.rowDropdown.displaySettings.isAvailable) {
      const G = RowDropdown.create(x);
      w.appendChild(G), O.rowDropdown = G;
    }
  }
  static addCells(x) {
    MaximumColumns.canAddMore(x) && (StaticTableWidthUtils.toggleWidthUsingMaxWidth(x, !0), x.data.map((w, O) => InsertNewRow.insert(x, O, !1, w)), x._pagination.asyncStartData && PaginationAsyncStartData.populate(x, x._pagination.asyncStartData), StaticTableWidthUtils.toggleWidthUsingMaxWidth(x, !1));
  }
  static postProcessColumns(x) {
    StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(x, !0), InitialDataProcessing.postProcess(x.data, x._columnsDetails), setTimeout(() => {
      FireEvents.onColumnsUpdate(x), InsertRemoveColumnSizer.cleanUpCustomColumnSizers(x, x._columnsDetails.length - 1);
    });
  }
  static populateBody(x) {
    var w;
    (w = x._tableBodyElementRef) == null || w.replaceChildren(), StaticTableWidthUtils.setTableWidth(x), TableElement.addCells(x), TableElement.postProcessColumns(x), FrameComponentsElements.addFrameBodyElements(x), x._frameComponents.displayIndexColumn && UpdateIndexColumnWidth.update(x), ToggleAdditionElements.update(x, !0, AddNewColumnElement.toggle), CustomRowProperties.update(x);
  }
  static createTableBody(x) {
    const w = document.createElement("tbody");
    return x && w.classList.add("sticky-header-body"), w;
  }
  static createTableElement(x) {
    var w;
    const O = document.createElement("table");
    O.classList.add("table-controlled-width");
    const D = StringDimensionUtils.removeAllDimensions(JSON.parse(JSON.stringify(x.tableStyle)));
    return Object.assign(O.style, D), (w = O.style).fontFamily || (w.fontFamily = "Inter, sans-serif, Avenir, Helvetica, Arial"), O.onmousedown = TableEvents.onMouseDown.bind(x), O.onmouseup = TableEvents.onMouseUp.bind(x), O;
  }
  // CAUTION-4 - add row cell is created and ref assigned here - then it is added post render in addFrameBodyElements
  static createInfrastructureElements(x) {
    return FrameComponentsColors.setEventColors(x), x._tableElementRef = TableElement.createTableElement(x), x._tableBodyElementRef = TableElement.createTableBody(x._stickyProps.header), x._addRowCellElementRef = AddNewRowElement.create(x), x._tableElementRef.appendChild(x._tableBodyElementRef), x._cellDropdownContainer = CellDropdown.createContainerElement(), x._tableElementRef.appendChild(x._cellDropdownContainer), !x.overflow && x._stickyProps.header && StickyPropsUtils.moveTopBorderToHeaderCells(x), x._tableDimensions.border = TableBorderDimensionsUtils.generateUsingElement(x._tableElementRef), x._tableElementRef;
  }
}
const _OverflowUtils = class Gt {
  static isOverflowElement(x) {
    return x?.id === Gt.ID;
  }
  // a simple way to not take the border into consideration when doing table width calculation, however if there are issues
  // feel free to investigate a better way
  static unsetBorderDimensions(x, w) {
    w.number -= x.border.leftWidth + x.border.rightWidth, TableElement.changeStaticWidthTotal(x, -x.border.leftWidth), TableElement.changeStaticWidthTotal(x, -x.border.rightWidth), x.border.leftWidth = 0, x.border.rightWidth = 0, x.border.topWidth = 0, x.border.bottomWidth = 0;
  }
  static processNumberDimension(x, w) {
    Gt.unsetBorderDimensions(x, w), w.number -= Gt.SCROLLBAR_WIDTH;
  }
  // prettier-ignore
  static moveBorderToOverflowContainer(x, w) {
    ElementStyle.moveStyles(
      w,
      x,
      "borderRight",
      "borderLeft",
      "borderTop",
      "borderBottom",
      "borderRadius",
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ), w.style.border = "unset";
  }
  static adjustStyleForScrollbarWidth(x) {
    (Browser.IS_SAFARI || Browser.IS_FIREFOX) && x.maxHeight && !x.maxWidth && (x.overflowContainer.style.paddingRight = `${Gt.SCROLLBAR_WIDTH}px`);
  }
  static setDimensions(x, { width: w, height: O }) {
    w && (x.style.overflowX = "auto", x.style.maxWidth = `${w}px`), O && (x.style.overflowY = "auto", x.style.maxHeight = `${O}px`);
  }
  // prettier-ignore
  static getDimensions(x, w) {
    const O = StringDimensionUtils.generateNumberDimensionFromClientString(
      x.parentElement,
      w,
      "maxWidth",
      !0
    );
    O.number -= x._tableDimensions.border.leftWidth + x._tableDimensions.border.rightWidth, O.isPercentage && (w.isWidthPercentage = !0);
    const D = StringDimensionUtils.generateNumberDimensionFromClientString(
      x.parentElement,
      w,
      "maxHeight",
      !1
    );
    return D.number -= x._tableDimensions.border.topWidth + x._tableDimensions.border.bottomWidth, D.isPercentage && (w.isHeightPercentage = !0), { width: O.number, height: D.number };
  }
  static applyDimensions(x) {
    const { _overflow: w } = x;
    if (!w)
      return;
    const O = Gt.getDimensions(x, w);
    Gt.setDimensions(w.overflowContainer, O), Gt.adjustStyleForScrollbarWidth(w);
  }
  static setupContainer(x, w) {
    const O = document.createElement("div");
    x._overflow = { overflowContainer: O, ...x.overflow }, O.id = Gt.ID, Gt.moveBorderToOverflowContainer(O, w), O.appendChild(w);
  }
};
_OverflowUtils.ID = "overflow-container";
_OverflowUtils.SCROLLBAR_WIDTH = 15;
let OverflowUtils = _OverflowUtils;
class ElementVisibility {
  // prettier-ignore
  static getDetailsInWindow(x, w, O = !0) {
    const { topWidth: D, leftWidth: U } = O ? w : { topWidth: 0, leftWidth: 0 }, W = x.getBoundingClientRect(), X = (Browser.IS_CHROMIUM ? W.top - D : W.top) + window.scrollY, G = (Browser.IS_CHROMIUM ? W.left - U : W.left) + window.scrollX, Y = x.offsetWidth, K = x.offsetHeight, Z = document.body, q = /* @__PURE__ */ new Set();
    X < window.pageYOffset && q.add(SIDE.TOP);
    const J = Z.clientWidth < Z.scrollWidth ? OverflowUtils.SCROLLBAR_WIDTH : 0;
    X + K + D > window.pageYOffset + window.innerHeight - J && q.add(SIDE.BOTTOM), G < window.pageXOffset && q.add(SIDE.LEFT);
    const ee = Z.clientHeight < Z.scrollHeight ? OverflowUtils.SCROLLBAR_WIDTH : 0;
    return G + Y + U > window.pageXOffset + window.innerWidth - ee && q.add(SIDE.RIGHT), q.size > 0 ? { isFullyVisible: !1, blockingSides: q } : { isFullyVisible: !0 };
  }
  // no real need to take care of multiple blockages for now
  static isVerticallyVisibleInsideParent(x, w) {
    const O = x.parentElement || w, D = O.scrollTop, U = D + O.clientHeight, W = x.offsetTop, X = W + x.clientHeight;
    return W < D ? { isFullyVisible: !1, blockingSides: /* @__PURE__ */ new Set([SIDE.TOP]) } : X > U ? { isFullyVisible: !1, blockingSides: /* @__PURE__ */ new Set([SIDE.BOTTOM]) } : { isFullyVisible: !0 };
  }
}
class OuterDropdownEvents {
  static windowOnMouseDown(x) {
    x._activeOverlayElements.outerContainerDropdown && x._activeOverlayElements.outerContainerDropdown.hide();
  }
  static focusSiblingItem(x, w, O) {
    const D = w?.[O];
    if (D)
      DropdownItemNavigation.focusSiblingItem(D, x, !0, !0);
    else if (O === "nextSibling") {
      const U = x.children[0];
      U && DropdownItemNavigation.focusSiblingItem(U, x, !0, !0);
    } else {
      const U = x.children[x.children.length - 1];
      U && DropdownItemNavigation.focusSiblingItem(U, x, !1, !0);
    }
  }
  // prettier-ignore
  static windowOnKeyDownNavigation(x, w) {
    const O = x.getElementsByClassName(DropdownItem.ACTIVE_ITEM_CLASS)[0];
    w === KEYBOARD_KEY.TAB || w === KEYBOARD_KEY.ARROW_DOWN ? O ? OuterDropdownEvents.focusSiblingItem(x, O, "nextSibling") : DropdownItemNavigation.focusSiblingItem(x.children[0], x, !0, !0) : w === KEYBOARD_KEY.ARROW_UP && (O ? OuterDropdownEvents.focusSiblingItem(x, O, "previousSibling") : DropdownItemNavigation.focusSiblingItem(
      x.children[x.children.length - 1],
      x,
      !1,
      !0
    ));
  }
  // the reason why we track window key events is because the table is not actually focused when it is displayed,
  // (unlike column dropdown which has an input), hence initially clicking tab does not focus the dropdown and
  // instead we need to focus it programmatically here. Once focused, the actual dropdown events can take over.
  // prettier-ignore
  static windowOnKeyDown(x, w) {
    const { shadowRoot: O, _activeOverlayElements: { outerContainerDropdown: D } } = x;
    if (!D)
      return;
    w.preventDefault();
    const { element: U, hide: W } = D;
    w.key === KEYBOARD_KEY.ENTER || w.key === KEYBOARD_KEY.ESCAPE ? W() : O != null && O.activeElement || OuterDropdownEvents.windowOnKeyDownNavigation(U, w.key);
  }
  static dropdownOnKeyDown(x, w) {
    w.preventDefault(), w.key === KEYBOARD_KEY.ENTER ? w.target.dispatchEvent(new MouseEvent("mousedown")) : w.key === KEYBOARD_KEY.ESCAPE && x.hide(), DropdownEvents.itemKeyNavigation(this.shadowRoot, x.element, w);
  }
  static set(x, w) {
    w.element.onkeydown = OuterDropdownEvents.dropdownOnKeyDown.bind(x, w);
  }
}
const _OuterDropdownElement = class vr {
  static hide(x, w) {
    const O = x.outerContainerDropdown;
    O && (Dropdown.hide(O.element), O.button.classList.contains(ToggleableElement.AUTO_STYLING_CLASS) && ToggleableElement.unsetActive(O.button, w), delete x.outerContainerDropdown, DropdownItemHighlightUtils.fadeCurrentlyHighlighted(x));
  }
  static display(x, w) {
    w.button.classList.contains(ToggleableElement.AUTO_STYLING_CLASS) && ToggleableElement.setActive(w.button, w.activeButtonStyle), Dropdown.display(w.element), x._activeOverlayElements.outerContainerDropdown = w;
  }
  static displayReactToBottomVisibility(x, w) {
    w.element.classList.remove(vr.DROPUP_CLASS), vr.display(x, w);
    const O = ElementVisibility.getDetailsInWindow(w.element, x._tableDimensions.border, !1);
    !O.isFullyVisible && O.blockingSides.has(SIDE.BOTTOM) && w.element.classList.add(vr.DROPUP_CLASS);
  }
  static setOrientation(x, w) {
    w.endsWith("right") && (x.style.right = "0px");
  }
  static createElement(x) {
    const w = Dropdown.createBase();
    return w.style.width = "", w.classList.add("outer-container-dropdown"), x && w.classList.add(...x), w;
  }
  // prettier-ignore
  static create(x, w, O, D, U, W, X) {
    const G = vr.createElement(U), Y = { element: G, hide: W, button: w, activeButtonStyle: D };
    return vr.setOrientation(G, O), OuterDropdownButtonEvents.set(x, w, O, Y, X), OuterDropdownEvents.set(x, Y), Y;
  }
};
_OuterDropdownElement.DROPUP_CLASS = "active-table-dropup";
let OuterDropdownElement = _OuterDropdownElement;
class OuterDropdownSimpleUtils {
  static hide(x, w) {
    var O;
    OuterDropdownElement.hide(x, {});
    const D = (O = x.outerContainerDropdown) == null ? void 0 : O.element;
    if (D) {
      const U = w || Array.from(D.children);
      OuterDropdownItem.unsetHoverColors(U);
    }
  }
  static getDropdownTopPosition(x) {
    return `${x.offsetTop + x.offsetHeight}px`;
  }
  // this is a custom display function used by dropdowns that do not populate items on display (export, rows per page)
  static display(x, w, O) {
    const { element: D } = O;
    D.style.bottom = "", D.style.top = OuterDropdownSimpleUtils.getDropdownTopPosition(x), OuterDropdownElement.displayReactToBottomVisibility(w, O);
  }
}
class RowsPerPageDropdownItemUtil {
  static updateRowsAndPaginationComponents(x, w, O) {
    RowsPerPageSelectButtonElement.updateButtonText(w, O), PageButtonContainerElement.shouldButtonsBeActive(x) && (PageButtonContainerElement.repopulateButtons(x), PaginationUtils.getAndApplyDataOnButtonClick(x, 1, O));
  }
  static getNewRowsPerPage(x, w) {
    const { _pagination: O, data: D, dataStartsAtHeader: U } = x;
    return O.isAllRowsOptionSelected ? U ? D.length : D.length - 1 : Number(w);
  }
  static setNewRowsPerPage(x, w, O) {
    x._pagination.isAllRowsOptionSelected = O.toLocaleLowerCase() === RowsPerPageDropdownItem.ALL_ITEM_TEXT, x._pagination.rowsPerPage = RowsPerPageDropdownItemUtil.getNewRowsPerPage(x, O), RowsPerPageDropdownItemUtil.updateRowsAndPaginationComponents(x, w, O);
  }
}
class RowsPerPageDropdownItemEvents {
  static action(x, w, O, D) {
    x.rowsPerPage !== Number(D) && RowsPerPageDropdownItemUtil.setNewRowsPerPage(O, w, D);
  }
  static setEvents(x, w, O) {
    const D = RowsPerPageDropdownItemEvents.action.bind(this, x._pagination, O), U = OuterDropdownSimpleUtils.hide;
    w.onmousedown = OuterDropdownItemEvents.itemMouseDownCommon.bind(x, D, U);
  }
}
const _RowsPerPageDropdownItem = class na {
  // lower case as it will be compared against user set text
  static populate(x, w, O) {
    x._pagination.rowsPerPageOptionsItemText.forEach((U) => {
      const W = { text: String(U) }, X = DropdownItem.addButtonItem(x, w, W, na.ITEM_CLASS);
      RowsPerPageDropdownItemEvents.setEvents(x, X, O);
    });
    const D = String(x._pagination.rowsPerPage);
    OuterDropdownItem.setActive(Array.from(w.children), D);
  }
};
_RowsPerPageDropdownItem.ITEM_CLASS = "number-of-rows-dropdown-item";
_RowsPerPageDropdownItem.ALL_ITEM_TEXT = "all";
let RowsPerPageDropdownItem = _RowsPerPageDropdownItem;
const _PaginationInternalUtils = class Ct {
  static getTotalNumberOfRows(x) {
    const { data: w, _visiblityInternal: O, _tableBodyElementRef: D } = x;
    return O != null && O.filters ? FilterInternalUtils.extractUnfilteredRows(D, w.length).length : w.length;
  }
  static insertNewRowsPerPageOption(x, w) {
    let O = w.findIndex((D) => {
      const U = Number.parseInt(D);
      return isNaN(U) || x < U;
    });
    O === -1 && (O = 0), w.splice(O, 0, String(x));
  }
  static setFirstOptionAsRowsPerPage(x) {
    const { _pagination: w, dataStartsAtHeader: O } = x, D = w.rowsPerPageOptionsItemText[0];
    if (D.toLocaleLowerCase() === RowsPerPageDropdownItem.ALL_ITEM_TEXT) {
      w.isAllRowsOptionSelected = !0;
      const U = Ct.getTotalNumberOfRows(x);
      w.rowsPerPage = O ? U : U - 1;
    } else
      w.rowsPerPage = Number(D);
  }
  static processRowsPerPage(x, w) {
    const { rowsPerPageSelect: O } = w;
    if (x._pagination.rowsPerPage = Number.parseInt(String(x._pagination.rowsPerPage)), O || O === void 0) {
      const { rowsPerPageOptionsItemText: D, rowsPerPage: U } = x._pagination;
      if (!D.find((W) => W === String(U))) {
        const W = Number.parseInt(String(U));
        isNaN(W) ? Ct.setFirstOptionAsRowsPerPage(x) : Ct.insertNewRowsPerPageOption(W, D);
      }
    }
  }
  static processOptionsItemText(x) {
    const w = Number(x);
    return !isNaN(w) && w < 1 ? "2" : String(x);
  }
  // REF-32
  static changeOptionNumberToEven(x) {
    return x.map((w) => {
      const O = Number(w);
      return Number.isNaN(O) ? w : O % 2 === 1 ? O + 1 : O;
    });
  }
  // prettier-ignore
  static setRowsPerPageOptionsText(x) {
    const w = x.pagination, { rowsPerPageSelect: O } = w;
    if (O || O === void 0) {
      const D = x._pagination.rowsPerPageSelect.options;
      let U = O === void 0 || O === !0 || !O.options || O.options.length === 0 ? D : O.options;
      x.stripedRows && (U = Ct.changeOptionNumberToEven(U)), x._pagination.rowsPerPageOptionsItemText = U.map((W) => Ct.processOptionsItemText(W));
    }
  }
  static processRowsPerPageOptions(x) {
    const w = x.pagination, { rowsPerPageSelect: O } = w;
    O !== void 0 && typeof O != "boolean" && O.prefixText && (x._pagination.rowsPerPageSelect.prefixText = O.prefixText), Ct.setRowsPerPageOptionsText(x), delete w.rowsPerPageSelect;
  }
  static setDefaultBackgroundColors(x, w) {
    var O, D, U;
    const { def: W, hover: X, click: G } = w;
    (O = x.click).backgroundColor ?? (O.backgroundColor = x.hover.backgroundColor || x.default.backgroundColor || G), (D = x.hover).backgroundColor ?? (D.backgroundColor = x.default.backgroundColor || X), (U = x.default).backgroundColor ?? (U.backgroundColor = W), ["click", "hover", "default"].forEach((Y) => {
      x[Y].backgroundColor === void 0 && delete x[Y].backgroundColor;
    });
  }
  static setStatefulCSS(x, w) {
    var O, D, U;
    x[w] ?? (x[w] = {}), (O = x[w]).click ?? (O.click = JSON.parse(JSON.stringify(x[w].hover || x[w].default || {}))), (D = x[w]).hover ?? (D.hover = JSON.parse(JSON.stringify(x[w].default || {}))), (U = x[w]).default ?? (U.default = {});
  }
  // prettier-ignore
  static setRowsPerPageOptionsStyle(x) {
    var w;
    Ct.setStatefulCSS(x.rowsPerPageSelect, "button");
    const O = { def: "", hover: "#f5f5f5", click: "#f5f5f5" };
    Ct.setDefaultBackgroundColors(
      (w = x.rowsPerPageSelect) == null ? void 0 : w.button,
      O
    );
  }
  // activeButtons reuse buttons style
  static mergeButtonsStyleWithActiveStyle(x) {
    const { buttons: w, actionButtons: O, activeButton: D } = x, U = JSON.parse(JSON.stringify(w));
    return U.default.backgroundColor = "#e8e8e8", U.hover.backgroundColor = "#d6d6d6", U.click.backgroundColor = "#c8c8c8", D && (Object.assign(U.default, D.default), U.hover = D.hover, U.click = D.click), U;
  }
  // actionButtons reuse buttons style
  static mergeButtonsStylesWithActionStyles(x) {
    x.actionButtons ?? (x.actionButtons = {});
    const { buttons: w, actionButtons: O } = x, D = JSON.parse(JSON.stringify(w));
    return Object.assign(D.default, O.default), Object.assign(D.hover, O.hover), Object.assign(D.click, O.click), D.previousText = O.previousText, D.nextText = O.nextText, D.firstText = O.firstText, D.lastText = O.lastText, D;
  }
  // prettier-ignore
  static processPageButtonStyles(x) {
    var w, O, D, U;
    (w = x.styles).pageButtons ?? (w.pageButtons = {});
    const W = x.styles.pageButtons, X = { def: "white", hover: "#f5f5f5", click: "#c8c8c8" };
    Ct.setStatefulCSS(W, "buttons"), Ct.setDefaultBackgroundColors(x.styles.pageButtons.buttons, X), Ct.setStatefulCSS(W, "actionButtons"), Ct.setDefaultBackgroundColors(
      x.styles.pageButtons.actionButtons,
      {}
    );
    const G = Ct.mergeButtonsStylesWithActionStyles(W);
    x.styles.pageButtons.actionButtons = G;
    const Y = Ct.mergeButtonsStyleWithActiveStyle(W);
    x.styles.pageButtons.activeButton = Y, (O = x.styles.pageButtons).disabledButtons ?? (O.disabledButtons = { backgroundColor: "#f9f9f9", color: "#9d9d9d", stroke: "#9d9d9d" });
    const K = {
      borderLeft: "1px solid #0000004d",
      borderTopLeftRadius: "2px",
      borderBottomLeftRadius: "2px"
    };
    (D = x.styles.pageButtons).firstVisibleButtonOverride ?? (D.firstVisibleButtonOverride = K);
    const Z = {
      borderRight: "1px solid #0000004d",
      borderTopRightRadius: "2px",
      borderBottomRightRadius: "2px"
    };
    (U = x.styles.pageButtons).lastVisibleButtonOverride ?? (U.lastVisibleButtonOverride = Z), x.styles.pageButtons.activeButtonClass = x.styles.pageButtons.activeButtonPrecedence ? PageButtonElement.PRECEDENCE_ACTIVE_PAGINATION_BUTTON_CLASS : PageButtonElement.ACTIVE_PAGINATION_BUTTON_CLASS;
  }
  static processStyle(x, w) {
    var O, D;
    x.styles && Object.assign(w.styles, x.styles), Ct.processPageButtonStyles(w), x.rowsPerPageSelect !== !1 && ((O = w.styles).rowsPerPageSelect ?? (O.rowsPerPageSelect = {}), Ct.setRowsPerPageOptionsStyle(w.styles)), (D = w.styles).numberOfVisibleRows ?? (D.numberOfVisibleRows = {}), delete x.styles;
  }
  static processPositions(x) {
    Object.keys(x).forEach((w) => {
      const O = x[w];
      Ct.POSITIONS.has(O.position) || (O.position = Ct.DEFAULT_POSITION);
    });
  }
  static processPosition(x, w) {
    x.positions && Object.assign(w.positions, x.positions), Ct.processPositions(w.positions), delete x.positions;
  }
  static async process(x) {
    const { _pagination: w, _activeOverlayElements: O } = x;
    if (!x.pagination)
      return;
    const D = typeof x.pagination == "boolean" ? {} : x.pagination;
    D.async && (LoadingElement.addInitial(x), O.error = ErrorElement.create(), w.asyncStartData = await PaginationAsyncStartData.get(x, D, w)), D.maxNumberOfVisiblePageButtons !== void 0 && D.maxNumberOfVisiblePageButtons < 1 && (D.maxNumberOfVisiblePageButtons = 1), Ct.processPosition(D, w), Ct.processStyle(D, w), D.rowsPerPageSelect !== !1 && Ct.processRowsPerPageOptions(x), Object.assign(w, D), D.displayNumberOfVisibleRows !== !1 && Ct.processRowsPerPage(x, D);
  }
  static getDefault() {
    return {
      rowsPerPage: 10,
      rowsPerPageSelect: {
        options: [10, 25, 50, "All"],
        prefixText: "Rows per page:"
      },
      maxNumberOfVisiblePageButtons: 8,
      displayPrevNext: !0,
      displayFirstLast: !0,
      displayNumberOfVisibleRows: !0,
      styles: {},
      // this is going to be populated during the call of processInternal method
      visibleEdgeButtons: [],
      numberOfActionButtons: 0,
      dropdownWidth: 24,
      positions: {
        pageButtons: {
          position: Ct.DEFAULT_POSITION,
          order: 3
        },
        numberOfVisibleRows: {
          position: Ct.DEFAULT_POSITION,
          order: 2
        },
        rowsPerPageSelect: {
          position: Ct.DEFAULT_POSITION,
          order: 1
        }
      },
      visibleRows: [],
      activePageNumber: 1,
      isAllRowsOptionSelected: !1
    };
  }
};
_PaginationInternalUtils.DEFAULT_POSITION = "bottom-right";
_PaginationInternalUtils.POSITIONS = /* @__PURE__ */ new Set([
  "top-left",
  "top-center",
  "top-right",
  "bottom-left",
  "bottom-center",
  _PaginationInternalUtils.DEFAULT_POSITION
]);
let PaginationInternalUtils = _PaginationInternalUtils;
class ActiveOverlayElementsUtils {
  static createNew() {
    return {};
  }
}
class ProgrammaticStructureUpdate {
  static processData(x, w) {
    if (w)
      return x > w.length ? w.concat(DataUtils.createEmptyStringDataArray(x - w.length)) : x < w.length ? w.slice(0, x) : w;
  }
  // if -1 - last row, if above last index - last row, otherwise use the given index
  static processIndex(x, w, O) {
    return x = x > -1 ? x : O, x = x > O ? O : x, !w && x === O ? O - 1 : x;
  }
  // prettier-ignore
  static updateColumn(x, w, O, D) {
    var U;
    O = ProgrammaticStructureUpdate.processIndex(O, w, ((U = x.data[0]) == null ? void 0 : U.length) || 0), x.data.length === 0 ? D && UpdateAllTableData.update(x, D.map((W) => [W]), 0, !0) : w ? (D = ProgrammaticStructureUpdate.processData(x.data.length || 0, D), InsertNewColumn.insert(x, O, D)) : x.data.length > 0 && RemoveColumn.remove(x, O);
  }
  static updatePaginationAsync(x, w) {
    setTimeout(() => {
      var O;
      if (x._pagination) {
        const D = (O = x._pagination) == null ? void 0 : O.activePageNumber;
        w !== D ? PaginationUtils.displayRowsForDifferentButton(x, w) : w !== 1 && (PaginationUtils.displayRowsForDifferentButton(x, 1), PaginationUtils.displayRowsForDifferentButton(x, w));
      }
    });
  }
  static updateRow(x, w, O, D) {
    var U, W;
    if (O = ProgrammaticStructureUpdate.processIndex(O, w, x.data.length), x.data.length === 0)
      D && UpdateAllTableData.update(x, [D], 0, !0);
    else if (w) {
      const X = (U = x._pagination) == null ? void 0 : U.activePageNumber;
      D = ProgrammaticStructureUpdate.processData(((W = x.data[0]) == null ? void 0 : W.length) || 0, D), InsertNewRow.insert(x, O, !0, D), setTimeout(() => ProgrammaticStructureUpdate.updatePaginationAsync(x, X));
    } else
      RemoveRow.remove(x, O);
  }
  static update(x, w) {
    const { structure: O, isInsert: D, index: U, data: W } = w;
    typeof D != "boolean" || typeof U != "number" || (O === "row" ? ProgrammaticStructureUpdate.updateRow(x, D, U, W) : O === "column" && ProgrammaticStructureUpdate.updateColumn(x, D, U, W));
  }
}
class FrameComponentsInternalUtils {
  static set(x) {
    const { frameComponentsStyles: w, _frameComponents: O } = x;
    O.displayAddNewColumn = x.displayAddNewColumn, O.displayAddNewRow = x.displayAddNewRow, O.displayIndexColumn = x.displayIndexColumn, O.styles = w.styles, O.inheritHeaderColors = w.inheritHeaderColors ?? !0;
  }
  static getDefault() {
    return {
      displayAddNewColumn: !0,
      displayAddNewRow: !0,
      displayIndexColumn: !0,
      cellColors: FrameComponentsColors.getDefaultCellColors()
    };
  }
}
class RowDropdownSettingsUtil {
  static postprocessOpenMethod(x, w) {
    var O, D;
    !w.displayIndexColumn && (O = x.displaySettings.openMethod) != null && O.cellClick && ((D = x.displaySettings.openMethod) == null || delete D.cellClick, x.displaySettings.openMethod.overlayClick = !0);
  }
  // prettier-ignore
  static preprocessOpenMethod(x, w) {
    w && (x.displaySettings.openMethod === void 0 || Object.keys(x.displaySettings.openMethod).length === 0) && w.openMethod && (x.displaySettings.openMethod = JSON.parse(JSON.stringify(w.openMethod)));
  }
  static process(x) {
    var w;
    const { rowDropdown: O, _frameComponents: D, _defaultColumnsSettings: U } = x;
    O.isInsertUpAvailable ?? (O.isInsertUpAvailable = !0), O.isInsertDownAvailable ?? (O.isInsertDownAvailable = !0), O.isMoveAvailable ?? (O.isMoveAvailable = !0), O.canEditHeaderRow ?? (O.canEditHeaderRow = !0), O.isDeleteAvailable ?? (O.isDeleteAvailable = !0), O.displaySettings ?? (O.displaySettings = {}), RowDropdownSettingsUtil.preprocessOpenMethod(O, (w = U.columnDropdown) == null ? void 0 : w.displaySettings), DropdownDisplaySettingsUtil.process(O.displaySettings), RowDropdownSettingsUtil.postprocessOpenMethod(O, D);
  }
}
class ProgrammaticCellUpdate {
  static updateText(x, w) {
    var O;
    const { newText: D, rowIndex: U, columnIndex: W } = w;
    if (!ObjectUtils.areValuesFullyDefined(D, U, W) || typeof D != "string" && typeof D != "number")
      return;
    const X = (O = x._columnsDetails[W]) == null ? void 0 : O.elements[U];
    !X || D === CellElement.getText(X) || (CellEvents.updateCell(x, D, U, W, { element: X, processText: U > 0 }), ColumnTypesUtils.updateDataElements(x, U, W, X), U === 0 && (Dropdown.isDisplayed(x._activeOverlayElements.columnDropdown) && ColumnDropdown.processTextAndHide(x), HeaderText.onAttemptChange(x, X, W)));
  }
}
class SheetJSExport {
  static getFileName(x, w) {
    return w ? w.endsWith(`.${x}`) ? w : `${w}.${x}` : `table_data.${x}`;
  }
  // not csv
  static export(x, w, O, D) {
    const U = D.utils.book_new(), W = D.utils.aoa_to_sheet(x.data);
    D.utils.book_append_sheet(U, W, "Sheet");
    const X = SheetJSExport.getFileName(w, O);
    D.writeFile(U, X, { bookType: w });
  }
}
class CSVExport {
  static export(x, w) {
    const O = "data:text/csv;charset=utf-8," + x.data.map((W) => W.join(",")).join(`
`), D = encodeURI(O), U = document.createElement("a");
    U.setAttribute("href", D), U.setAttribute("download", w || "table_data.csv"), document.body.appendChild(U), U.click();
  }
}
class FileExportEvents {
  static export(x, w) {
    const O = w?.format || "csv";
    if (ACCEPTED_FILE_FORMATS.find((D) => O === D)) {
      const D = w?.fileName;
      O === "csv" ? CSVExport.export(x, D) : SheetJSInternalUtils.execFuncWithExtractorModule(SheetJSExport.export.bind(this, x, O, D));
    }
  }
  static setEvents(x, w, O) {
    var D;
    const U = O ? { format: (D = O.formats) == null ? void 0 : D[0], fileName: O.fileName } : void 0;
    w.onclick = FileExportEvents.export.bind(this, x, U);
  }
}
class FileExportDropdownItemEvents {
  static action(x, w) {
    const O = w.toLowerCase();
    FileExportEvents.export(x, { format: O });
  }
  static setEvents(x, w) {
    const O = FileExportDropdownItemEvents.action, D = OuterDropdownSimpleUtils.hide;
    w.onmousedown = OuterDropdownItemEvents.itemMouseDownCommon.bind(x, O, D);
  }
}
const _FileExportDropdownItem = class sa {
  // prettier-ignore
  static populate(x, w, O) {
    O.forEach((D) => {
      const U = { text: D.toUpperCase() }, W = DropdownItem.addButtonItem(
        x,
        w,
        U,
        sa.ITEM_CLASS,
        StaticDropdown.ITEM_CLASS
      );
      FileExportDropdownItemEvents.setEvents(x, W);
    });
  }
};
_FileExportDropdownItem.ITEM_CLASS = "export-formats-dropdown-item";
let FileExportDropdownItem = _FileExportDropdownItem;
class FileExportDropdown {
  static create(x, w, O) {
    const D = OuterDropdownSimpleUtils.hide.bind(this, x._activeOverlayElements), U = OuterDropdownSimpleUtils.display.bind(this, w), W = OuterDropdownElement.create(x, w, "bottom-right", {}, [], D, U);
    return W.element.classList.add(StaticDropdown.DROPDOWN_CLASS), FileExportDropdownItem.populate(x, W.element, O), W;
  }
}
const _FileExportButtonElement = class Fr {
  static createButtonArrow(x, w) {
    const O = OuterDropdownButtonUtils.createArrow(
      [Fr.ARROW_CONTAINER_CLASS],
      [Fr.ARROW_ICON_CLASS]
    ), D = typeof w == "object" && w.formats && w.buttonArrowStyles;
    return D && (OuterDropdownButtonUtils.processAndApplyDefaultStyle(O, D), setTimeout(() => StatefulCSSEvents.setEvents(x, D, void 0, O))), O;
  }
  // if there is more than 1 format - automatically create a dropdown
  static getDropdownFormats(x) {
    if (typeof x == "object" && x.formats) {
      const { formats: w } = x, O = w.filter((D) => Fr.VALID_FORMATS[D.toLocaleLowerCase()]);
      if (O.length > 1)
        return O;
    }
  }
  // prettier-ignore
  static applyDropdown(x, w, O, D, U) {
    const W = FileExportDropdown.create(x, w, D);
    O.appendChild(W.element), w.appendChild(Fr.createButtonArrow(w, U));
  }
};
_FileExportButtonElement.ARROW_CONTAINER_CLASS = "file-button-arrow-container";
_FileExportButtonElement.ARROW_ICON_CLASS = "file-button-arrow-container-icon";
_FileExportButtonElement.VALID_FORMATS = ["csv", "xls", "xlsx", "ods", "txt"].reduce((F, x) => (F[x] = !0, F), {});
let FileExportButtonElement = _FileExportButtonElement;
const _FileButtonElements = class wr {
  static setEvents(x, w, O) {
    w.import ? FileImportButtonEvents.setEvents(x, O, typeof w.import == "object" ? w.import : void 0) : w.export && FileExportEvents.setEvents(x, O, typeof w.export == "object" ? w.export : void 0);
  }
  // the main reason for this is to display a dropdown
  static wrapInRelativeContainer(x) {
    const w = document.createElement("div");
    return w.classList.add(wr.BUTTON_CONTAINER_CLASS), w.appendChild(x), w;
  }
  static createElement(x, w) {
    const { text: O, order: D, styles: U } = x, W = document.createElement("div");
    W.classList.add(wr.BUTTON_CLASS), W.textContent = O || w, W.style.order = String(D || 0);
    const X = FilesUtils.processStyles(U);
    return Object.assign(W.style, X.default), setTimeout(() => StatefulCSSEvents.setEvents(W, X)), W;
  }
  static create(x, w) {
    var O, D;
    (D = (O = x.files) == null ? void 0 : O.buttons) == null || D.forEach((U) => {
      if (!U.export && !U.import)
        return;
      const W = wr.createElement(U, U.import ? "Import" : "Export"), X = wr.wrapInRelativeContainer(W), G = U.export && FileExportButtonElement.getDropdownFormats(U.export);
      G ? FileExportButtonElement.applyDropdown(x, W, X, G, U.export) : setTimeout(() => wr.setEvents(x, U, W));
      const Y = U.position || FilesUtils.DEFAULT_BUTTON_POSITION;
      OuterContainerElements.addToContainer(Y, w, X);
    });
  }
};
_FileButtonElements.BUTTON_CLASS = "file-button";
_FileButtonElements.BUTTON_CONTAINER_CLASS = "file-button-container";
let FileButtonElements = _FileButtonElements;
class OuterTableComponents {
  static create(x) {
    const w = OuterContainerElements.create(x);
    x.pagination && PaginationElements.create(x, w), x.files && FileButtonElements.create(x, w), x.filter && FilterElements.create(x, w);
  }
}
class WebComponentStyleUtils {
  static add(x, w) {
    if (!(!w || !x))
      try {
        WebComponentStyleUtils.addStyleSheet(x, w);
      } catch {
        WebComponentStyleUtils.addStyleElement(x, w);
      }
  }
  static addStyleSheet(x, w) {
    const O = new CSSStyleSheet();
    O.replaceSync(x), w.adoptedStyleSheets.push(O);
  }
  static addStyleElement(x, w) {
    const O = document.createElement("style");
    O.innerHTML = x, w.appendChild(O);
  }
}
class FocusedElementsUtils {
  static createEmpty() {
    return { cell: FocusedCellUtils.createEmpty() };
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2 = (F) => (x, w) => {
  w !== void 0 ? w.addInitializer(() => {
    customElements.define(F, x);
  }) : customElements.define(F, x);
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1 = globalThis, e$2 = t$1.ShadowRoot && (t$1.ShadyCSS === void 0 || t$1.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$2 = Symbol(), o$4 = /* @__PURE__ */ new WeakMap();
let n$3 = class {
  constructor(F, x, w) {
    if (this._$cssResult$ = !0, w !== s$2)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = F, this.t = x;
  }
  get styleSheet() {
    let F = this.o;
    const x = this.t;
    if (e$2 && F === void 0) {
      const w = x !== void 0 && x.length === 1;
      w && (F = o$4.get(x)), F === void 0 && ((this.o = F = new CSSStyleSheet()).replaceSync(this.cssText), w && o$4.set(x, F));
    }
    return F;
  }
  toString() {
    return this.cssText;
  }
};
const r$4 = (F) => new n$3(typeof F == "string" ? F : F + "", void 0, s$2), i$3 = (F, ...x) => {
  const w = F.length === 1 ? F[0] : x.reduce((O, D, U) => O + ((W) => {
    if (W._$cssResult$ === !0)
      return W.cssText;
    if (typeof W == "number")
      return W;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + W + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(D) + F[U + 1], F[0]);
  return new n$3(w, F, s$2);
}, S$1 = (F, x) => {
  if (e$2)
    F.adoptedStyleSheets = x.map((w) => w instanceof CSSStyleSheet ? w : w.styleSheet);
  else
    for (const w of x) {
      const O = document.createElement("style"), D = t$1.litNonce;
      D !== void 0 && O.setAttribute("nonce", D), O.textContent = w.cssText, F.appendChild(O);
    }
}, c$2 = e$2 ? (F) => F : (F) => F instanceof CSSStyleSheet ? ((x) => {
  let w = "";
  for (const O of x.cssRules)
    w += O.cssText;
  return r$4(w);
})(F) : F;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: i$2, defineProperty: e$1, getOwnPropertyDescriptor: h$1, getOwnPropertyNames: r$3, getOwnPropertySymbols: o$3, getPrototypeOf: n$2 } = Object, a$1 = globalThis, c$1 = a$1.trustedTypes, l$1 = c$1 ? c$1.emptyScript : "", p$1 = a$1.reactiveElementPolyfillSupport, d$1 = (F, x) => F, u$1 = { toAttribute(F, x) {
  switch (x) {
    case Boolean:
      F = F ? l$1 : null;
      break;
    case Object:
    case Array:
      F = F == null ? F : JSON.stringify(F);
  }
  return F;
}, fromAttribute(F, x) {
  let w = F;
  switch (x) {
    case Boolean:
      w = F !== null;
      break;
    case Number:
      w = F === null ? null : Number(F);
      break;
    case Object:
    case Array:
      try {
        w = JSON.parse(F);
      } catch {
        w = null;
      }
  }
  return w;
} }, f$1 = (F, x) => !i$2(F, x), b = { attribute: !0, type: String, converter: u$1, reflect: !1, useDefault: !1, hasChanged: f$1 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a$1.litPropertyMetadata ?? (a$1.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class y extends HTMLElement {
  static addInitializer(x) {
    this._$Ei(), (this.l ?? (this.l = [])).push(x);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(x, w = b) {
    if (w.state && (w.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(x) && ((w = Object.create(w)).wrapped = !0), this.elementProperties.set(x, w), !w.noAccessor) {
      const O = Symbol(), D = this.getPropertyDescriptor(x, O, w);
      D !== void 0 && e$1(this.prototype, x, D);
    }
  }
  static getPropertyDescriptor(x, w, O) {
    const { get: D, set: U } = h$1(this.prototype, x) ?? { get() {
      return this[w];
    }, set(W) {
      this[w] = W;
    } };
    return { get: D, set(W) {
      const X = D?.call(this);
      U?.call(this, W), this.requestUpdate(x, X, O);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(x) {
    return this.elementProperties.get(x) ?? b;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$1("elementProperties")))
      return;
    const x = n$2(this);
    x.finalize(), x.l !== void 0 && (this.l = [...x.l]), this.elementProperties = new Map(x.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$1("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(d$1("properties"))) {
      const w = this.properties, O = [...r$3(w), ...o$3(w)];
      for (const D of O)
        this.createProperty(D, w[D]);
    }
    const x = this[Symbol.metadata];
    if (x !== null) {
      const w = litPropertyMetadata.get(x);
      if (w !== void 0)
        for (const [O, D] of w)
          this.elementProperties.set(O, D);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [w, O] of this.elementProperties) {
      const D = this._$Eu(w, O);
      D !== void 0 && this._$Eh.set(D, w);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(x) {
    const w = [];
    if (Array.isArray(x)) {
      const O = new Set(x.flat(1 / 0).reverse());
      for (const D of O)
        w.unshift(c$2(D));
    } else
      x !== void 0 && w.push(c$2(x));
    return w;
  }
  static _$Eu(x, w) {
    const O = w.attribute;
    return O === !1 ? void 0 : typeof O == "string" ? O : typeof x == "string" ? x.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var x;
    this._$ES = new Promise((w) => this.enableUpdating = w), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (x = this.constructor.l) == null || x.forEach((w) => w(this));
  }
  addController(x) {
    var w;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(x), this.renderRoot !== void 0 && this.isConnected && ((w = x.hostConnected) == null || w.call(x));
  }
  removeController(x) {
    var w;
    (w = this._$EO) == null || w.delete(x);
  }
  _$E_() {
    const x = /* @__PURE__ */ new Map(), w = this.constructor.elementProperties;
    for (const O of w.keys())
      this.hasOwnProperty(O) && (x.set(O, this[O]), delete this[O]);
    x.size > 0 && (this._$Ep = x);
  }
  createRenderRoot() {
    const x = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$1(x, this.constructor.elementStyles), x;
  }
  connectedCallback() {
    var x;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (x = this._$EO) == null || x.forEach((w) => {
      var O;
      return (O = w.hostConnected) == null ? void 0 : O.call(w);
    });
  }
  enableUpdating(x) {
  }
  disconnectedCallback() {
    var x;
    (x = this._$EO) == null || x.forEach((w) => {
      var O;
      return (O = w.hostDisconnected) == null ? void 0 : O.call(w);
    });
  }
  attributeChangedCallback(x, w, O) {
    this._$AK(x, O);
  }
  _$ET(x, w) {
    var O;
    const D = this.constructor.elementProperties.get(x), U = this.constructor._$Eu(x, D);
    if (U !== void 0 && D.reflect === !0) {
      const W = (((O = D.converter) == null ? void 0 : O.toAttribute) !== void 0 ? D.converter : u$1).toAttribute(w, D.type);
      this._$Em = x, W == null ? this.removeAttribute(U) : this.setAttribute(U, W), this._$Em = null;
    }
  }
  _$AK(x, w) {
    var O, D;
    const U = this.constructor, W = U._$Eh.get(x);
    if (W !== void 0 && this._$Em !== W) {
      const X = U.getPropertyOptions(W), G = typeof X.converter == "function" ? { fromAttribute: X.converter } : ((O = X.converter) == null ? void 0 : O.fromAttribute) !== void 0 ? X.converter : u$1;
      this._$Em = W, this[W] = G.fromAttribute(w, X.type) ?? ((D = this._$Ej) == null ? void 0 : D.get(W)) ?? null, this._$Em = null;
    }
  }
  requestUpdate(x, w, O) {
    var D;
    if (x !== void 0) {
      const U = this.constructor, W = this[x];
      if (O ?? (O = U.getPropertyOptions(x)), !((O.hasChanged ?? f$1)(W, w) || O.useDefault && O.reflect && W === ((D = this._$Ej) == null ? void 0 : D.get(x)) && !this.hasAttribute(U._$Eu(x, O))))
        return;
      this.C(x, w, O);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(x, w, { useDefault: O, reflect: D, wrapped: U }, W) {
    O && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(x) && (this._$Ej.set(x, W ?? w ?? this[x]), U !== !0 || W !== void 0) || (this._$AL.has(x) || (this.hasUpdated || O || (w = void 0), this._$AL.set(x, w)), D === !0 && this._$Em !== x && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(x));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (w) {
      Promise.reject(w);
    }
    const x = this.scheduleUpdate();
    return x != null && await x, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var x;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [U, W] of this._$Ep)
          this[U] = W;
        this._$Ep = void 0;
      }
      const D = this.constructor.elementProperties;
      if (D.size > 0)
        for (const [U, W] of D) {
          const { wrapped: X } = W, G = this[U];
          X !== !0 || this._$AL.has(U) || G === void 0 || this.C(U, void 0, W, G);
        }
    }
    let w = !1;
    const O = this._$AL;
    try {
      w = this.shouldUpdate(O), w ? (this.willUpdate(O), (x = this._$EO) == null || x.forEach((D) => {
        var U;
        return (U = D.hostUpdate) == null ? void 0 : U.call(D);
      }), this.update(O)) : this._$EM();
    } catch (D) {
      throw w = !1, this._$EM(), D;
    }
    w && this._$AE(O);
  }
  willUpdate(x) {
  }
  _$AE(x) {
    var w;
    (w = this._$EO) == null || w.forEach((O) => {
      var D;
      return (D = O.hostUpdated) == null ? void 0 : D.call(O);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(x)), this.updated(x);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(x) {
    return !0;
  }
  update(x) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((w) => this._$ET(w, this[w]))), this._$EM();
  }
  updated(x) {
  }
  firstUpdated(x) {
  }
}
y.elementStyles = [], y.shadowRootOptions = { mode: "open" }, y[d$1("elementProperties")] = /* @__PURE__ */ new Map(), y[d$1("finalized")] = /* @__PURE__ */ new Map(), p$1?.({ ReactiveElement: y }), (a$1.reactiveElementVersions ?? (a$1.reactiveElementVersions = [])).push("2.1.0");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$2 = { attribute: !0, type: String, converter: u$1, reflect: !1, hasChanged: f$1 }, r$2 = (F = o$2, x, w) => {
  const { kind: O, metadata: D } = w;
  let U = globalThis.litPropertyMetadata.get(D);
  if (U === void 0 && globalThis.litPropertyMetadata.set(D, U = /* @__PURE__ */ new Map()), O === "setter" && ((F = Object.create(F)).wrapped = !0), U.set(w.name, F), O === "accessor") {
    const { name: W } = w;
    return { set(X) {
      const G = x.get.call(this);
      x.set.call(this, X), this.requestUpdate(W, G, F);
    }, init(X) {
      return X !== void 0 && this.C(W, void 0, F, X), X;
    } };
  }
  if (O === "setter") {
    const { name: W } = w;
    return function(X) {
      const G = this[W];
      x.call(this, X), this.requestUpdate(W, G, F);
    };
  }
  throw Error("Unsupported decorator location: " + O);
};
function n$1(F) {
  return (x, w) => typeof w == "object" ? r$2(F, x, w) : ((O, D, U) => {
    const W = D.hasOwnProperty(U);
    return D.constructor.createProperty(U, O), W ? Object.getOwnPropertyDescriptor(D, U) : void 0;
  })(F, x, w);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$1(F) {
  return n$1({ ...F, state: !0, attribute: !1 });
}
class WindowEvents {
  static onKeyDown(x) {
    var w, O;
    Dropdown.isDisplayed((w = this._activeOverlayElements.outerContainerDropdown) == null ? void 0 : w.element) && OuterDropdownEvents.windowOnKeyDown(this, x), Dropdown.isDisplayed(this._activeOverlayElements.rowDropdown) && RowDropdownEvents.windowOnKeyDown(this, x);
    const { rowIndex: D, columnIndex: U, element: W } = this._focusedElements.cell;
    if (!(D === void 0 || U === void 0)) {
      if (D === 0 && !Dropdown.isDisplayed(this._activeOverlayElements.columnDropdown)) {
        if (x.key === KEYBOARD_KEY.ESCAPE)
          return HeaderText.onAttemptChange(this, W, U);
      } else if (Dropdown.isDisplayed(this._activeOverlayElements.columnDropdown) && !((O = this.shadowRoot) != null && O.activeElement))
        return ColumnDropdownEvents.onKeyDown.bind(this)(this._activeOverlayElements.columnDropdown, x);
      D > 0 && this._columnsDetails[U].activeType.cellDropdownProps && SelectCellTextBaseEvents.keyDownText(this, D, U, x);
    }
  }
  static onKeyUp(x) {
    x.key === KEYBOARD_KEY.ESCAPE ? (OptionColorButtonEvents.windowEventClosePicker(this._columnsDetails, this._focusedElements), DateCellInputEvents.escapeKeyInput(this)) : x.key === KEYBOARD_KEY.ENTER && OptionColorButtonEvents.windowEventClosePicker(this._columnsDetails, this._focusedElements);
  }
  // prettier-ignore
  static onMouseDown(x) {
    var w;
    if (OptionColorButtonEvents.windowEventClosePicker(this._columnsDetails, this._focusedElements), Dropdown.isDisplayed((w = this._activeOverlayElements.outerContainerDropdown) == null ? void 0 : w.element) && OuterDropdownEvents.windowOnMouseDown(this), x.target.tagName === ActiveTable._ELEMENT_TAG)
      return;
    const { _activeOverlayElements: { columnDropdown: O, rowDropdown: D }, _focusedElements: U } = this;
    Dropdown.isDisplayed(D) && RowDropdown.hide(this), Dropdown.isDisplayed(O) ? ColumnDropdown.processTextAndHide(this) : U.cellDropdown ? CellWithTextEvents.programmaticBlur(this) : this._activeOverlayElements.datePickerCell && (DateCellInputElement.toggle(this._activeOverlayElements.datePickerCell, !1), delete this._activeOverlayElements.datePickerCell);
  }
  static onMouseUp() {
    this._activeOverlayElements.selectedColumnSizer && ColumnSizerExtrinsicEvents.windowMouseUp(this), DragColumn.windowMouseUp(this), DragRow.windowMouseUp(this);
  }
  static onMouseMove(x) {
    this._activeOverlayElements.selectedColumnSizer && ColumnSizerExtrinsicEvents.windowMouseMove(this, x.movementX), this._focusedElements.colDragEl && DragColumn.windowDrag(this, this._focusedElements.colDragEl, x), this._focusedElements.rowDragEl && DragRow.windowDrag(this, x);
  }
}
class Render {
  // CAUTION-4 overwriting @properties causes the whole table to refresh and subsequently - an infinite render loop
  // prettier-ignore
  static refreshTableState(x) {
    var w;
    (w = x._cellDropdownContainer) == null || w.replaceChildren(), x._columnsDetails.splice(0, x._columnsDetails.length), x._tableDimensions.indexColumnWidth = IndexColumn.DEFAULT_WIDTH, x._addColumnCellsElementsRef.splice(0, x._addColumnCellsElementsRef.length), x._overflow && (x._tableDimensions.border = TableBorderDimensionsUtils.generateUsingElement(x._overflow.overflowContainer));
  }
  static renderTable(x) {
    x._isRendering = !0, TableDimensionsUtils.record(x), Render.refreshTableState(x), x._overflow && OverflowUtils.applyDimensions(x), TableElement.setStaticWidthContentTotal(x), TableDimensionsUtils.setTableDimensions(x), TableElement.populateBody(x), setTimeout(() => x._isRendering = !1);
  }
}
class WindowResize {
  // prettier-ignore
  static resize(x) {
    const { _tableDimensions: w } = this;
    (x.width && window.innerWidth !== w.recordedWindowWidth || x.height && window.innerHeight !== w.recordedWindowHeight) && Render.renderTable(this);
  }
  static extractPostfix(x) {
    if (typeof x == "string") {
      if (x.includes(VW))
        return VW;
      if (x.includes(VH))
        return VH;
    }
    return "";
  }
  static extractDimensionsToObserve(x) {
    const { tableStyle: w, _overflow: O } = x, D = [w.width, w.maxWidth, O?.maxHeight, O?.maxWidth].map(
      (U) => WindowResize.extractPostfix(U)
    );
    return {
      width: !!D.find((U) => U === VW),
      height: !!D.find((U) => U === VH)
    };
  }
  static observeIfRequired(x) {
    const w = WindowResize.extractDimensionsToObserve(x);
    (w.width || w.height) && window.addEventListener("resize", WindowResize.resize.bind(x, w));
  }
}
class WindowElement {
  static setEvents(x) {
    window.addEventListener("keydown", WindowEvents.onKeyDown.bind(x)), window.addEventListener("keyup", WindowEvents.onKeyUp.bind(x)), window.addEventListener("mousedown", WindowEvents.onMouseDown.bind(x)), window.addEventListener("mouseup", WindowEvents.onMouseUp.bind(x)), window.addEventListener("mousemove", WindowEvents.onMouseMove.bind(x)), WindowResize.observeIfRequired(x);
  }
}
const _GoogleFont = class Gr {
  static appendStyleSheetToHead() {
    const x = document.getElementsByTagName("head")[0];
    if (!Array.from(x.getElementsByTagName("link")).some(
      (w) => w.getAttribute("href") === Gr.FONT_URL
    )) {
      const w = document.createElement("link");
      w.rel = "stylesheet", w.href = Gr.FONT_URL, x.appendChild(w);
    }
  }
};
_GoogleFont.FONT_URL = "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap";
let GoogleFont = _GoogleFont;
class ParentResize {
  static doesOverflowNeedRerender(x, w) {
    if (!x._overflow)
      return !1;
    const { isHeightPercentage: O, isWidthPercentage: D } = x._overflow;
    return O && x._tableDimensions.recordedParentHeight !== w.offsetHeight || D && x._tableDimensions.recordedParentWidth !== w.offsetWidth;
  }
  static shouldRerenderTable(x) {
    if (!x)
      return !1;
    const w = x.parentElement;
    return w ? ParentResize.doesOverflowNeedRerender(x, w) ? !0 : x._tableDimensions.isPercentage && // Resize callback gets triggered on multiple occasions when the parent width has not changed:
    // on startup, after table has been resized, when parent height is changed and when column height is changed
    // This condition prevents the table from re-rendering itself when the above occurs
    x._tableDimensions.recordedParentWidth !== w.offsetWidth && // If the parent is resized to a width that does not impact the table width, do not bother re-rendering it
    (x._tableDimensions.maxWidth === void 0 || x.offsetWidth > w.offsetWidth) : !1;
  }
  static resizeCallback() {
    const x = this;
    ParentResize.shouldRerenderTable(x) && (x._tableDimensions.preserveNarrowColumns || (x._tableDimensions.preserveNarrowColumns = !0, setTimeout(() => x._tableDimensions.preserveNarrowColumns = !1)), Render.renderTable(x));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t = globalThis, i$1 = t.trustedTypes, s$1 = i$1 ? i$1.createPolicy("lit-html", { createHTML: (F) => F }) : void 0, e = "$lit$", h = `lit$${Math.random().toFixed(9).slice(2)}$`, o$1 = "?" + h, n = `<${o$1}>`, r = document, l = () => r.createComment(""), c = (F) => F === null || typeof F != "object" && typeof F != "function", a = Array.isArray, u = (F) => a(F) || typeof F?.[Symbol.iterator] == "function", d = `[ 	
\f\r]`, f = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v = /-->/g, _ = />/g, m = RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), p = /'/g, g = /"/g, $$1 = /^(?:script|style|textarea|title)$/i, T = Symbol.for("lit-noChange"), E = Symbol.for("lit-nothing"), A = /* @__PURE__ */ new WeakMap(), C = r.createTreeWalker(r, 129);
function P(F, x) {
  if (!a(F) || !F.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return s$1 !== void 0 ? s$1.createHTML(x) : x;
}
const V = (F, x) => {
  const w = F.length - 1, O = [];
  let D, U = x === 2 ? "<svg>" : x === 3 ? "<math>" : "", W = f;
  for (let X = 0; X < w; X++) {
    const G = F[X];
    let Y, K, Z = -1, q = 0;
    for (; q < G.length && (W.lastIndex = q, K = W.exec(G), K !== null); )
      q = W.lastIndex, W === f ? K[1] === "!--" ? W = v : K[1] !== void 0 ? W = _ : K[2] !== void 0 ? ($$1.test(K[2]) && (D = RegExp("</" + K[2], "g")), W = m) : K[3] !== void 0 && (W = m) : W === m ? K[0] === ">" ? (W = D ?? f, Z = -1) : K[1] === void 0 ? Z = -2 : (Z = W.lastIndex - K[2].length, Y = K[1], W = K[3] === void 0 ? m : K[3] === '"' ? g : p) : W === g || W === p ? W = m : W === v || W === _ ? W = f : (W = m, D = void 0);
    const J = W === m && F[X + 1].startsWith("/>") ? " " : "";
    U += W === f ? G + n : Z >= 0 ? (O.push(Y), G.slice(0, Z) + e + G.slice(Z) + h + J) : G + h + (Z === -2 ? X : J);
  }
  return [P(F, U + (F[w] || "<?>") + (x === 2 ? "</svg>" : x === 3 ? "</math>" : "")), O];
};
class N {
  constructor({ strings: x, _$litType$: w }, O) {
    let D;
    this.parts = [];
    let U = 0, W = 0;
    const X = x.length - 1, G = this.parts, [Y, K] = V(x, w);
    if (this.el = N.createElement(Y, O), C.currentNode = this.el.content, w === 2 || w === 3) {
      const Z = this.el.content.firstChild;
      Z.replaceWith(...Z.childNodes);
    }
    for (; (D = C.nextNode()) !== null && G.length < X; ) {
      if (D.nodeType === 1) {
        if (D.hasAttributes())
          for (const Z of D.getAttributeNames())
            if (Z.endsWith(e)) {
              const q = K[W++], J = D.getAttribute(Z).split(h), ee = /([.?@])?(.*)/.exec(q);
              G.push({ type: 1, index: U, name: ee[2], strings: J, ctor: ee[1] === "." ? H : ee[1] === "?" ? I : ee[1] === "@" ? L : k }), D.removeAttribute(Z);
            } else
              Z.startsWith(h) && (G.push({ type: 6, index: U }), D.removeAttribute(Z));
        if ($$1.test(D.tagName)) {
          const Z = D.textContent.split(h), q = Z.length - 1;
          if (q > 0) {
            D.textContent = i$1 ? i$1.emptyScript : "";
            for (let J = 0; J < q; J++)
              D.append(Z[J], l()), C.nextNode(), G.push({ type: 2, index: ++U });
            D.append(Z[q], l());
          }
        }
      } else if (D.nodeType === 8)
        if (D.data === o$1)
          G.push({ type: 2, index: U });
        else {
          let Z = -1;
          for (; (Z = D.data.indexOf(h, Z + 1)) !== -1; )
            G.push({ type: 7, index: U }), Z += h.length - 1;
        }
      U++;
    }
  }
  static createElement(x, w) {
    const O = r.createElement("template");
    return O.innerHTML = x, O;
  }
}
function S(F, x, w = F, O) {
  var D, U;
  if (x === T)
    return x;
  let W = O !== void 0 ? (D = w._$Co) == null ? void 0 : D[O] : w._$Cl;
  const X = c(x) ? void 0 : x._$litDirective$;
  return W?.constructor !== X && ((U = W?._$AO) == null || U.call(W, !1), X === void 0 ? W = void 0 : (W = new X(F), W._$AT(F, w, O)), O !== void 0 ? (w._$Co ?? (w._$Co = []))[O] = W : w._$Cl = W), W !== void 0 && (x = S(F, W._$AS(F, x.values), W, O)), x;
}
class M {
  constructor(x, w) {
    this._$AV = [], this._$AN = void 0, this._$AD = x, this._$AM = w;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(x) {
    const { el: { content: w }, parts: O } = this._$AD, D = (x?.creationScope ?? r).importNode(w, !0);
    C.currentNode = D;
    let U = C.nextNode(), W = 0, X = 0, G = O[0];
    for (; G !== void 0; ) {
      if (W === G.index) {
        let Y;
        G.type === 2 ? Y = new R(U, U.nextSibling, this, x) : G.type === 1 ? Y = new G.ctor(U, G.name, G.strings, this, x) : G.type === 6 && (Y = new z(U, this, x)), this._$AV.push(Y), G = O[++X];
      }
      W !== G?.index && (U = C.nextNode(), W++);
    }
    return C.currentNode = r, D;
  }
  p(x) {
    let w = 0;
    for (const O of this._$AV)
      O !== void 0 && (O.strings !== void 0 ? (O._$AI(x, O, w), w += O.strings.length - 2) : O._$AI(x[w])), w++;
  }
}
class R {
  get _$AU() {
    var x;
    return ((x = this._$AM) == null ? void 0 : x._$AU) ?? this._$Cv;
  }
  constructor(x, w, O, D) {
    this.type = 2, this._$AH = E, this._$AN = void 0, this._$AA = x, this._$AB = w, this._$AM = O, this.options = D, this._$Cv = D?.isConnected ?? !0;
  }
  get parentNode() {
    let x = this._$AA.parentNode;
    const w = this._$AM;
    return w !== void 0 && x?.nodeType === 11 && (x = w.parentNode), x;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(x, w = this) {
    x = S(this, x, w), c(x) ? x === E || x == null || x === "" ? (this._$AH !== E && this._$AR(), this._$AH = E) : x !== this._$AH && x !== T && this._(x) : x._$litType$ !== void 0 ? this.$(x) : x.nodeType !== void 0 ? this.T(x) : u(x) ? this.k(x) : this._(x);
  }
  O(x) {
    return this._$AA.parentNode.insertBefore(x, this._$AB);
  }
  T(x) {
    this._$AH !== x && (this._$AR(), this._$AH = this.O(x));
  }
  _(x) {
    this._$AH !== E && c(this._$AH) ? this._$AA.nextSibling.data = x : this.T(r.createTextNode(x)), this._$AH = x;
  }
  $(x) {
    var w;
    const { values: O, _$litType$: D } = x, U = typeof D == "number" ? this._$AC(x) : (D.el === void 0 && (D.el = N.createElement(P(D.h, D.h[0]), this.options)), D);
    if (((w = this._$AH) == null ? void 0 : w._$AD) === U)
      this._$AH.p(O);
    else {
      const W = new M(U, this), X = W.u(this.options);
      W.p(O), this.T(X), this._$AH = W;
    }
  }
  _$AC(x) {
    let w = A.get(x.strings);
    return w === void 0 && A.set(x.strings, w = new N(x)), w;
  }
  k(x) {
    a(this._$AH) || (this._$AH = [], this._$AR());
    const w = this._$AH;
    let O, D = 0;
    for (const U of x)
      D === w.length ? w.push(O = new R(this.O(l()), this.O(l()), this, this.options)) : O = w[D], O._$AI(U), D++;
    D < w.length && (this._$AR(O && O._$AB.nextSibling, D), w.length = D);
  }
  _$AR(x = this._$AA.nextSibling, w) {
    var O;
    for ((O = this._$AP) == null ? void 0 : O.call(this, !1, !0, w); x && x !== this._$AB; ) {
      const D = x.nextSibling;
      x.remove(), x = D;
    }
  }
  setConnected(x) {
    var w;
    this._$AM === void 0 && (this._$Cv = x, (w = this._$AP) == null || w.call(this, x));
  }
}
class k {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(x, w, O, D, U) {
    this.type = 1, this._$AH = E, this._$AN = void 0, this.element = x, this.name = w, this._$AM = D, this.options = U, O.length > 2 || O[0] !== "" || O[1] !== "" ? (this._$AH = Array(O.length - 1).fill(new String()), this.strings = O) : this._$AH = E;
  }
  _$AI(x, w = this, O, D) {
    const U = this.strings;
    let W = !1;
    if (U === void 0)
      x = S(this, x, w, 0), W = !c(x) || x !== this._$AH && x !== T, W && (this._$AH = x);
    else {
      const X = x;
      let G, Y;
      for (x = U[0], G = 0; G < U.length - 1; G++)
        Y = S(this, X[O + G], w, G), Y === T && (Y = this._$AH[G]), W || (W = !c(Y) || Y !== this._$AH[G]), Y === E ? x = E : x !== E && (x += (Y ?? "") + U[G + 1]), this._$AH[G] = Y;
    }
    W && !D && this.j(x);
  }
  j(x) {
    x === E ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, x ?? "");
  }
}
class H extends k {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(x) {
    this.element[this.name] = x === E ? void 0 : x;
  }
}
class I extends k {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(x) {
    this.element.toggleAttribute(this.name, !!x && x !== E);
  }
}
class L extends k {
  constructor(x, w, O, D, U) {
    super(x, w, O, D, U), this.type = 5;
  }
  _$AI(x, w = this) {
    if ((x = S(this, x, w, 0) ?? E) === T)
      return;
    const O = this._$AH, D = x === E && O !== E || x.capture !== O.capture || x.once !== O.once || x.passive !== O.passive, U = x !== E && (O === E || D);
    D && this.element.removeEventListener(this.name, this, O), U && this.element.addEventListener(this.name, this, x), this._$AH = x;
  }
  handleEvent(x) {
    var w;
    typeof this._$AH == "function" ? this._$AH.call(((w = this.options) == null ? void 0 : w.host) ?? this.element, x) : this._$AH.handleEvent(x);
  }
}
class z {
  constructor(x, w, O) {
    this.element = x, this.type = 6, this._$AN = void 0, this._$AM = w, this.options = O;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(x) {
    S(this, x);
  }
}
const j = t.litHtmlPolyfillSupport;
j?.(N, R), (t.litHtmlVersions ?? (t.litHtmlVersions = [])).push("3.3.0");
const B = (F, x, w) => {
  const O = w?.renderBefore ?? x;
  let D = O._$litPart$;
  if (D === void 0) {
    const U = w?.renderBefore ?? null;
    O._$litPart$ = D = new R(x.insertBefore(l(), U), U, void 0, w ?? {});
  }
  return D._$AI(F), D;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s = globalThis;
class i extends y {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var x;
    const w = super.createRenderRoot();
    return (x = this.renderOptions).renderBefore ?? (x.renderBefore = w.firstChild), w;
  }
  update(x) {
    const w = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(x), this._$Do = B(w, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var x;
    super.connectedCallback(), (x = this._$Do) == null || x.setConnected(!0);
  }
  disconnectedCallback() {
    var x;
    super.disconnectedCallback(), (x = this._$Do) == null || x.setConnected(!1);
  }
  render() {
    return T;
  }
}
var pt;
i._$litElement$ = !0, i.finalized = !0, (pt = s.litElementHydrateSupport) == null || pt.call(s, { LitElement: i });
const o = s.litElementPolyfillSupport;
o?.({ LitElement: i });
(s.litElementVersions ?? (s.litElementVersions = [])).push("4.2.0");
const activeTableStyle = i$3`
  /* this is used to shrink the width of the active-table element to the shadow-root width */
  :host {
    /* the following property prevents outside styles from affecting this component */
    all: initial;
    /* the following property is used to control the overall component width */
    display: inline-block;
  }

  table {
    border-spacing: 0px;
    position: relative;
    border: 1px solid #00000028;
    background-color: white;
  }

  /* REF-16 */
  .table-controlled-width {
    table-layout: fixed;
    /* fit-content does not work correctly in firefox when there are not enough columns to fit parent */
    width: min-content;
  }

  tbody {
    border-radius: inherit;
  }

  tbody > .row:first-child > *:first-child {
    border-top-left-radius: inherit;
  }

  /* using last-of-type as the last element is a divider which does not help with corner rounding */
  tbody > .row:first-child > .cell:last-of-type {
    border-top-right-radius: inherit;
  }

  #last-visible-row > *:first-child {
    border-bottom-left-radius: inherit;
  }

  #last-visible-row > .cell:last-of-type {
    border-bottom-right-radius: inherit;
  }

  .row {
    color: rgba(0, 0, 0, 0.87);
    font-size: 13px;
    font-weight: 400;
    /* the following is not supported in Firefox (on rows), hence rowHoverStyles will not have the border */
    border-radius: inherit;
  }

  tbody > .row:first-child {
    position: relative;
  }

  .row > *:first-child {
    border-left: none !important;
  }

  .row > .cell:last-of-type {
    border-right: none !important;
  }

  /* REF-25 */
  #last-visible-row > .cell {
    border-bottom: none !important;
  }

  .cell {
    text-align: left;
    padding: 11px 6px 6px;
    font-size: 14px;
    line-height: 17px;
    height: 42.5px;
    box-sizing: border-box;
    outline: none;
    overflow-wrap: anywhere;
    font-size: inherit;
    font-weight: inherit;
    border-bottom-style: solid;
    border-bottom-width: 1px;
    border-bottom-color: rgba(0, 0, 0, 0.12);
    vertical-align: top;
    text-align: left;
    border-right: 1px solid #00000021;
    color: #222222;
  }

  .cell-text-div {
    outline: none;
    overflow-wrap: anywhere;
    border-radius: 4px;
    width: fit-content;
    /* need padding for the cursor to show up */
    padding-left: 1px;
  }

  .select-cell-text {
    float: left;
  }

  .arrow-down-icon-container {
    position: relative;
  }

  .arrow-down-icon {
    position: absolute;
    right: 2px;
    top: 5px;
    text-align: center;
    cursor: pointer;
  }

  .label-cell-text {
    padding-left: 6px;
    padding-right: 6px;
    padding-top: 2px;
    padding-bottom: 2px;
  }

  .cell-divider {
    position: absolute;
    display: flex;
    justify-content: center;
  }

  .cell-divider > * {
    user-select: none;
    /* safari */
    -webkit-user-select: none;
    position: absolute;
    cursor: col-resize;
    justify-content: center;
    height: inherit;
  }

  /* this class needs to be after .cell to have style precendence */
  /* REF-1 */
  .header-cell {
    border-top: none !important;
    cursor: pointer;
    color: #626262;
    padding-top: 12px;
    padding-bottom: 12px;
    font-weight: 500;
  }

  .header-icon-container {
    float: left;
    pointer-events: none;
    /* the height is set to allow the text to be present below the icon when there is not enough space in the cell */
    height: 15px;
  }

  .header-icon-side-text {
    /* cannot use flex as pressing ENTER creates a new div */
    /* cannot use grid as it does not align in Safari */
    display: table-cell;
  }

  .not-selectable {
    user-select: none;
    /* safari */
    -webkit-user-select: none;
  }

  .column-sizer {
    /* need z-index for the sizer to display over header icon */
    z-index: 1;
    background-size: 20px 5px;
    position: absolute;
  }

  .column-sizer-filler {
    height: inherit;
    position: absolute;
    pointer-events: none;
  }

  .column-sizer-overlay {
    background-color: #ff000001;
    z-index: 1;
  }

  .movable-column-sizer {
    z-index: 1;
  }

  .movable-column-sizer-vertical-line {
    width: 1px;
    pointer-events: none;
  }

  #add-new-row-cell {
    padding-top: 8px;
    padding-left: 17px;
    min-height: 28px;
    line-height: 18px;
    font-size: 12px;
    color: #555555;
    vertical-align: middle;
    cursor: pointer;
  }

  .index-cell {
    text-align: center;
    padding: 11px 4px 0px !important;
  }

  .index-cell-overflow {
    overflow: hidden;
    overflow-wrap: normal;
  }

  #temp-invisible-index-number {
    color: #e2e2e200 !important;
  }

  .add-column-cell {
    cursor: pointer;
    text-align: center;
  }

  .header-cell-clone {
    position: absolute;
    cursor: move;
    top: 0px;
  }

  .header-cell-clone-animation {
    transition: 0.25s ease-out;
  }

  .cell-hidden {
    opacity: 0 !important;
  }

  .row-clone {
    position: absolute;
    display: flex;
    opacity: 0.8s;
  }

  .row-clone > * {
    cursor: move !important;
  }

  .row-drag-target-line {
    height: 4px;
    width: 100%;
    position: absolute;
    background-color: #69b0ff;
    pointer-events: none;
  }

  .root-cell {
    text-align: center;
    padding: 0px !important;
    border: none !important;
    // inheriting border radius as when frame components style background is set (add new row component), table border
    // radius is visibly not inherited
    border-radius: inherit;
  }

  .active-table-dropdown {
    position: absolute;
    box-shadow: rgb(15 15 15 / 5%) 0px 0px 0px 1px, rgb(15 15 15 / 10%) 0px 3px 6px, rgb(15 15 15 / 20%) 0px 9px 24px;
    border-radius: 5px;
    background-color: white;
    z-index: 1;
  }

  .active-table-dropup {
    box-shadow: rgba(15, 15, 15, 0.05) 0px 0px 0px 1px, rgba(15, 15, 15, 0.1) 0px 3px 6px,
      rgba(15, 15, 15, 0.2) 0px -2px 24px;
    top: unset !important;
    bottom: 100%;
  }

  .cell-dropdown {
    overflow: auto;
    white-space: nowrap;
  }

  .cell-dropdown::-webkit-scrollbar {
    width: 9px;
    height: 9px;
  }

  .cell-dropdown::-webkit-scrollbar-thumb {
    background-color: #aaaaaa;
    border-radius: 5px;
  }

  .cell-dropdown::-webkit-scrollbar-track {
    background-color: #f2f2f2;
  }

  .dropdown-item {
    padding-top: 3px;
    padding-bottom: 3px;
    padding-right: 5px;
    padding-left: 5px;
    color: #4b4b4b;
    position: relative;
    cursor: pointer;
    /* retaining the outline for dropdown input to make it easier to recognise */
    outline: none;
    font-size: 15px;
  }

  .cell-dropdown > .dropdown-item {
    /* the height of cell dropdown items seem to change depending on monitor size which inconsistently triggers overflow,
    this sets it to be consistent but ideally we should not do this and use a different way to allow any font sizes */
    height: 18px;
  }

  .dropdown-item-icon-container {
    display: flex;
    float: left;
    height: 90%;
    align-items: initial;
    padding-top: 2px;
    /* if items are not aligned in center - change align-items to center and revert changes
      in 0805a911cd5c7921aa05b13ffb9387d3d996c133 */
  }

  .dropdown-title-item {
    cursor: default;
    color: #7c7c7c;
    font-weight: 600;
    font-size: 0.75rem;
    margin-top: 2px;
  }

  .dropdown-input-item {
    text-align: center;
  }

  .dropdown-input {
    width: 92%;
    border: 1px solid grey;
    border-radius: 2px;
    color: #2d2d2d;
    font-size: 14px;
    padding: 3px;
    padding-top: 4px;
  }

  .dropdown-item-divider {
    border-bottom: 1px solid #d4d4d4;
    margin-top: 2px;
    margin-bottom: 2px;
  }

  .dropdown-highlightable-item:hover {
    background-color: #eaeaea;
  }

  .active-dropdown-item {
    background-color: #4a69d4;
    color: white;
  }

  /* using different class as standard dropdowns use above class in their functionality */
  .active-static-dropdown-item {
    background-color: #4a69d4;
    color: white;
  }

  .active-dropdown-item:focus {
    background-color: #2148d5 !important;
    color: white !important;
  }

  /* Do not want to set default height incase user has set a font or a font-family so
    setting a placeholder text and making it invisible */
  .dropdown-item-empty {
    color: #ffffae00 !important;
  }

  .dropdown-disabled-item {
    pointer-events: none;
    color: #9e9e9e8a;
  }

  .cell-dropdown-option-button-container {
    position: absolute;
    width: 100%;
    height: 0px;
    top: 5px;
    left: -5px;
    display: none;
  }

  .cell-dropdown-option-button {
    height: 13px;
    width: 13px;
    position: sticky;
    z-index: 1;
    border-radius: 12px;
    opacity: 0.3;
    background-color: white;
  }

  .cell-dropdown-option-button:hover {
    opacity: 1;
  }

  .cell-dropdown-option-button:active {
    background-color: #f8f8f8;
  }

  .cell-dropdown-option-button > div {
    font-size: 12px;
    height: 11px;
    pointer-events: none;
    color: black;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .cell-dropdown-option-delete-button-icon {
    font-size: 12.5px;
    width: 13px;
  }

  .cell-dropdown-option-color-button-icon {
    width: 12.5px;
  }

  .outer-container-dropdown {
    z-index: 2;
  }

  .color-input {
    width: 0px;
    height: 0px;
    padding: 0px;
    position: absolute;
    outline: none;
    pointer-events: none;
    opacity: 0;
    /* border unset stops color picker panel from appearing in safari */
  }

  .date-input-container {
    position: relative;
    float: right;
    cursor: pointer;
  }

  .date-input {
    top: 17px;
    width: 0px;
    height: 0px;
    border: unset;
    padding: 0px;
    right: 9px;
    position: absolute;
    outline: none;
  }

  .calender-icon-container {
    position: absolute;
    right: 2px;
    top: -4px;
    width: 15px;
    height: 25px;
    text-align: center;
  }

  #full-table-overlay {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100%;
  }

  #drag-and-drop-overlay {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100%;
    height: calc(100% - 10px);
    width: calc(100% - 10px);
    background-color: #70c6ff4d;
    border: 5px dashed #6dafff;
    display: none;
    z-index: 2;
  }

  .filter-hidden-row {
    display: none;
  }

  .dropdown-cell-overlay {
    cursor: pointer;
    background-color: grey;
  }

  .column-dropdown-cell-overlay {
    transition: height 0.2s;
    border-bottom-left-radius: 2px;
    border-bottom-right-radius: 2px;
  }

  .row-dropdown-cell-overlay {
    transition: width 0.2s;
    border-top-right-radius: 2px;
    border-bottom-right-radius: 2px;
  }

  #pagination-button-container {
    right: 0;
    display: flex;
    width: fit-content;
    height: fit-content;
  }

  .pagination-button {
    border: 1px solid #0000004d;
    border-right: unset;
    color: #353535;
    min-width: 31px;
    height: 30.5px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 15.5px;
    /* REF-40 */
    stroke: black;
  }

  .pagination-prev-next-button {
    width: 14.25px;
    padding-left: 4px;
  }

  .pagination-first-last-button {
    width: 13px;
  }

  .pagination-button > * {
    pointer-events: none;
  }

  .pagination-button-disabled {
    pointer-events: none;
    color: #7c7c7c;
    /* REF-40 */
    stroke: #7c7c7c;
  }

  .pagination-button > svg > path {
    /* REF-40 */
    stroke: inherit;
  }

  #pagination-number-of-visible-rows {
    padding-top: 6px;
    color: #252525;
    min-width: 82px;
    text-align: center;
    font-size: 15.5px;
    padding-top: 7.5px;
  }

  #pagination-number-of-rows-select {
    position: relative;
    color: #1d1d1d;
    min-width: max-content;
  }

  #pagination-number-of-rows-select-text {
    font-size: 15.5px;
    float: left;
    margin-top: 6px;
  }

  #rows-per-page-select-button {
    display: inline-block;
    background-color: white;
    border: 1px solid #0000004d;
    border-radius: 4px;
    height: 24px;
    padding-top: 3px;
    padding-bottom: 0.5px;
    padding-left: 6px;
    padding-right: 1px;
    margin-top: 1px;
    cursor: pointer;
  }

  .outer-dropdown-button-arrow-container {
    pointer-events: none;
    color: #353535;
    font-size: 16px;
    float: right;
    margin: 1px;
    margin-left: -1px;
    width: 19px;
  }

  .outer-dropdown-button-arrow-icon {
    width: 16px;
    transform: scale(0.9, 1);
    filter: brightness(0) saturate(100%) invert(11%) sepia(3%) saturate(99%) hue-rotate(157deg) brightness(97%)
      contrast(98%);
    padding-top: 2px;
    padding-left: 2px;
  }

  #rows-per-page-select-button-text {
    display: inline-block;
    pointer-events: none;
    padding-top: 1px;
  }

  .number-of-rows-dropdown-item {
    padding-right: 12.5px;
    text-align: right;
  }

  .file-button-container {
    position: relative;
  }

  .file-button {
    border: 1px solid #00000038;
    border-radius: 3px;
    color: #464646;
    text-align: center;
    cursor: pointer;
    user-select: none;
    background-color: #f8f8f9;
    font-size: 14.5px;
    align-items: center;
    display: flex;
    height: 29px;
    padding: 0px 10px 1px;
  }

  .file-button-arrow-container {
    margin-right: -5px;
  }

  .file-button-arrow-container-icon {
    width: 17px;
    padding-top: 5px;
  }

  .export-formats-dropdown-item {
    padding: 4px 10px;
    font-size: 14.5px;
  }

  .hidden-row {
    line-height: 0px;
    height: 0px !important;
    user-select: none;
    pointer-events: none;
  }

  .hidden-row > * {
    line-height: 0px;
    height: 0px;
    padding: 0px !important;
    font-size: 0px;
    border-bottom-width: 0px !important;
  }

  .hidden-row > th > * {
    display: none;
  }

  .outer-container {
    display: grid;
    position: relative;
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  #outer-top-container > div > div > div > * {
    margin-bottom: 13px;
  }

  #outer-bottom-container > div > div > div > * {
    margin-top: 13px;
  }

  /* REF-38 */
  .outer-container-column {
    display: flex;
    width: 0px;
  }

  .outer-container-column-inner {
    display: flex;
  }

  .outer-container-column-content {
    display: flex;
    /* use -webkit-max-content if the below does not work */
    width: max-content;
  }

  .outer-container-left-column .outer-container-column-content > div {
    margin-right: 10px;
  }

  .outer-container-center-column {
    justify-content: center;
    position: absolute;
  }

  .outer-container-center-column .outer-container-column-content > div {
    margin-left: 5px;
    margin-right: 5px;
  }

  .outer-container-right-column {
    justify-content: end;
  }

  .outer-container-right-column .outer-container-column-content > div {
    margin-left: 10px;
  }

  /* right sibling */
  .pagination-button-active-precedence + div {
    border-left-color: #fafafa01 !important;
  }

  .sticky-header-body > *:first-child {
    top: 0;
    position: sticky !important;
  }

  .sticky-header-body > *:first-child > th {
    background-color: white;
  }

  #overflow-container {
    border: 1px solid #00000026;
  }

  /* REF-37 */
  .no-overflow-sticky-header-body {
    border-top: 1px solid #00000026;
  }

  /* REF-37 */
  .no-overflow-sticky-header-body > *:first-child {
    border-top: inherit;
  }

  /* REF-37 */
  .no-overflow-sticky-header-body > *:first-child > th {
    border-top: inherit !important;
  }

  .filter-rows-container {
    position: relative;
  }

  .filter-rows-input {
    width: 150px;
    height: 20px;
    border: 1px solid #0000002b;
    border-radius: 4px;
    color: rgb(45, 45, 45);
    font-family: inherit;
    padding: 5px 6px;
    font-size: 14px;
  }

  .filter-rows-input::placeholder {
    color: var(--active-table-filter-placeholder-color);
  }

  .filter-rows-dropdown-button {
    position: absolute;
    right: 4px;
    top: 51.6%;
    transform: translateY(-50%);
    cursor: pointer;
    user-select: none;
    filter: brightness(0) saturate(100%) invert(49%) sepia(0%) saturate(974%) hue-rotate(66deg) brightness(97%)
      contrast(96%);
    width: 16px;
    height: 16px;
  }

  .filter-rows-dropdown-button + .filter-rows-case-button {
    right: 15px;
  }

  .filter-rows-case-button + .filter-rows-input {
    padding-right: 30px;
    width: 129px;
  }

  .filter-rows-dropdown-button + .filter-rows-input {
    padding-right: 22px;
    width: 137px;
  }

  .filter-rows-dropdown-button + .filter-rows-case-button + .filter-rows-input {
    padding-right: 45px;
    width: 114px;
  }

  .filter-rows-case-button {
    position: absolute;
    right: 0px;
    top: 49%;
    transform: translate(-50%, -50%);
    color: grey;
    font-size: 13px;
    cursor: pointer;
    user-select: none;
  }

  .filter-rows-dropdown {
    min-width: 100% !important;
    width: max-content !important;
  }

  .filter-rows-dropdown > .dropdown-item {
    padding-left: 8px;
    padding-right: 8px;
    padding-top: 4px;
    padding-bottom: 4px;
  }

  .default-loading-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 400px;
    width: 400px;
    border: 1px solid grey;
  }

  .loading-container-absolute {
    position: absolute;
    top: 0;
    height: 100%;
    width: 100%;
  }

  .absolute-container {
    position: absolute;
    top: 0;
    height: 100%;
    width: 100%;
  }

  .loading-spinner {
    width: 60px;
    height: 60px;
    border: 5px solid #38a4ff;
    border-bottom-color: transparent;
    border-radius: 50%;
    display: inline-block;
    box-sizing: border-box;
    animation: rotation 1s linear infinite;
  }

  #error-container {
    position: absolute;
    top: 0;
    height: 100%;
    width: 100%;
    background-color: #ff000006;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #error-text {
    font-size: 24px;
    color: red;
  }

  @keyframes rotation {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
`;
var __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __decorateClass = (F, x, w, O) => {
  for (var D = O > 1 ? void 0 : O ? __getOwnPropDesc(x, w) : x, U = F.length - 1, W; U >= 0; U--)
    (W = F[U]) && (D = (O ? W(x, w, D) : W(D)) || D);
  return O && D && __defProp(x, w, D), D;
};
let ActiveTable = class extends i {
  constructor() {
    super(), this.getData = () => JSON.parse(JSON.stringify(this.data)), this.getColumnsDetails = () => ColumnDetailsUtils.getAllColumnsDetails(this._columnsDetails), this.updateCell = (F) => {
      ProgrammaticCellUpdate.updateText(this, F);
    }, this.updateStructure = (F) => {
      ProgrammaticStructureUpdate.update(this, F);
    }, this.updateData = (F) => {
      UpdateAllTableData.update(this, F, 0);
    }, this.importFile = (F) => FileImportButtonEvents.triggerImportPrompt(this, F), this.exportFile = (F) => FileExportEvents.export(this, F), this.onCellUpdate = () => {
    }, this.onDataUpdate = () => {
    }, this.onColumnsUpdate = () => {
    }, this.onRender = () => {
    }, this.data = [
      // ['Planet', 'Diameter', 'Mass', 'Moons', 'Density'],
      // ['Earth', 12756, 5.97, 1, 5514],
      // ['Mars', 6792, 0.642, 2, 3934],
      // ['Jupiter', 142984, 1898, 79, 1326],
      // ['Saturn', 120536, 568, 82, 687],
      // ['Neptune', 49528, 102, 14, 1638],
    ], this.tableStyle = {}, this.allowDuplicateHeaders = !0, this.displayHeaderIcons = !0, this.spellCheck = !1, this.customColumnsSettings = [], this.dragRows = !0, this.dragColumns = !0, this.preserveNarrowColumns = !0, this.displayAddNewRow = !0, this.displayAddNewColumn = !0, this.displayIndexColumn = { wrapIndexCellText: !1 }, this.frameComponentsStyles = {}, this.dataStartsAtHeader = !1, this.columnResizerColors = {}, this.rowDropdown = { displaySettings: { isAvailable: !0, openMethod: { cellClick: !0 } } }, this.enterKeyMoveDown = !1, this._stickyProps = { header: !1 }, this._defaultColumnsSettings = {}, this._customColumnsSettings = {}, this._columnsDetails = [], this._addColumnCellsElementsRef = [], this._focusedElements = FocusedElementsUtils.createEmpty(), this._hoveredElements = {}, this._activeOverlayElements = ActiveOverlayElementsUtils.createNew(), this._eventFunctions = ElementEvents.getDefault(), this._userKeyEventsState = UserKeyEventsStateUtils.createNew(), this._tableDimensions = TableDimensionsUtils.getDefault(), this._globalItemColors = LabelColorUtils.generateGlobalItemColors(), this._defaultCellHoverColors = CellHighlightUtils.getDefaultHoverProperties(), this._frameComponents = FrameComponentsInternalUtils.getDefault(), this._rowDropdownCellOverlays = [], this._pagination = PaginationInternalUtils.getDefault(), this._files = FilesUtils.createDefault(this), this._visiblityInternal = {}, this._isRendering = !1, this._isPopulatingTable = !1, GoogleFont.appendStyleSheetToHead();
  }
  // CAUTION-4
  render() {
    Render.renderTable(this), this.onDataUpdate(this.data), new ResizeObserver(ParentResize.resizeCallback.bind(this)).observe(this.parentElement), FireEvents.onRender(this);
  }
  async update(F) {
    var x, w;
    PaginationAsyncUtils.preprocessTablePropertiesIfAsync(this), this._isPopulatingTable = !0, StickyPropsUtils.process(this), ColumnSettingsUtils.setUpInternalSettings(this), FrameComponentsInternalUtils.set(this), DefaultColumnTypes.createDropdownItemsForDefaultTypes(), RowDropdownSettingsUtil.process(this), this.pagination && await PaginationInternalUtils.process(this), this.stripedRows && StripedRows.process(this), this.rowHoverStyles && RowHoverEvents.process(this.rowHoverStyles, this._defaultCellHoverColors);
    const O = TableElement.createInfrastructureElements(this);
    this.overflow && OverflowUtils.setupContainer(this, O), TableElement.addOverlayElements(this, O, this._activeOverlayElements), PaginationAsyncUtils.removeLoadingOverlay(this), (w = this.shadowRoot) == null || w.appendChild(((x = this._overflow) == null ? void 0 : x.overflowContainer) || O), OuterTableComponents.create(this), InitialDataProcessing.preProcess(this, this.data), WindowElement.setEvents(this), this.spellcheck = this.spellCheck, this.auxiliaryStyle && this.shadowRoot && WebComponentStyleUtils.add(this.auxiliaryStyle, this.shadowRoot), setTimeout(() => this._isPopulatingTable = !1, 1), super.update(F);
  }
  connectedCallback() {
    Browser.IS_FIREFOX ? setTimeout(() => super.connectedCallback()) : super.connectedCallback();
  }
  // this is used to prevent a bug where the update method is called again (and adds another table) when a new property is
  // added - e.g. an event listener method
  shouldUpdate() {
    return !this._tableElementRef;
  }
};
ActiveTable._ELEMENT_TAG = "ACTIVE-TABLE";
ActiveTable.styles = [activeTableStyle];
__decorateClass([
  n$1({ attribute: !1 })
], ActiveTable.prototype, "getData", 2);
__decorateClass([
  n$1({ attribute: !1 })
], ActiveTable.prototype, "getColumnsDetails", 2);
__decorateClass([
  n$1({ attribute: !1 })
], ActiveTable.prototype, "updateCell", 2);
__decorateClass([
  n$1({ attribute: !1 })
], ActiveTable.prototype, "updateStructure", 2);
__decorateClass([
  n$1({ attribute: !1 })
], ActiveTable.prototype, "updateData", 2);
__decorateClass([
  n$1({ attribute: !1 })
], ActiveTable.prototype, "importFile", 2);
__decorateClass([
  n$1({ attribute: !1 })
], ActiveTable.prototype, "exportFile", 2);
__decorateClass([
  n$1({ converter: LITElementTypeConverters.convertToFunction })
], ActiveTable.prototype, "onCellUpdate", 2);
__decorateClass([
  n$1({ converter: LITElementTypeConverters.convertToFunction })
], ActiveTable.prototype, "onDataUpdate", 2);
__decorateClass([
  n$1({ converter: LITElementTypeConverters.convertToFunction })
], ActiveTable.prototype, "onColumnsUpdate", 2);
__decorateClass([
  n$1({ converter: LITElementTypeConverters.convertToFunction })
], ActiveTable.prototype, "onRender", 2);
__decorateClass([
  n$1({ type: Array })
], ActiveTable.prototype, "data", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "tableStyle", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "allowDuplicateHeaders", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "displayHeaderIcons", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "spellCheck", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "stickyHeader", 2);
__decorateClass([
  n$1({ type: Array })
], ActiveTable.prototype, "customColumnsSettings", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "rowHoverStyles", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "dragRows", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "dragColumns", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "preserveNarrowColumns", 2);
__decorateClass([
  n$1({ type: Number })
], ActiveTable.prototype, "maxColumns", 2);
__decorateClass([
  n$1({ type: Number })
], ActiveTable.prototype, "maxRows", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "displayAddNewRow", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "displayAddNewColumn", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "displayIndexColumn", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "frameComponentsStyles", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "dataStartsAtHeader", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "columnResizerColors", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "rowDropdown", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "stripedRows", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "overflow", 2);
__decorateClass([
  n$1({ type: String })
], ActiveTable.prototype, "defaultText", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "isDefaultTextRemovable", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "cellStyle", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "rootCell", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "isCellTextEditable", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "headerStyles", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "isHeaderTextEditable", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "headerIconStyle", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "isColumnResizable", 2);
__decorateClass([
  n$1({ type: Array })
], ActiveTable.prototype, "availableDefaultColumnTypes", 2);
__decorateClass([
  n$1({ type: Array })
], ActiveTable.prototype, "customColumnTypes", 2);
__decorateClass([
  n$1({ type: String })
], ActiveTable.prototype, "defaultColumnTypeName", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "columnDropdown", 2);
__decorateClass([
  n$1({
    type: Boolean,
    converter: LITElementTypeConverters.convertToBoolean
  })
], ActiveTable.prototype, "enterKeyMoveDown", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "pagination", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "loadingStyles", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "files", 2);
__decorateClass([
  n$1({ type: Object })
], ActiveTable.prototype, "filter", 2);
__decorateClass([
  n$1({ type: String })
], ActiveTable.prototype, "auxiliaryStyle", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_stickyProps", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_defaultColumnsSettings", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_customColumnsSettings", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_columnsDetails", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_tableElementRef", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_tableBodyElementRef", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_addRowCellElementRef", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_addColumnCellsElementsRef", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_focusedElements", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_hoveredElements", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_activeOverlayElements", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_eventFunctions", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_userKeyEventsState", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_tableDimensions", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_cellDropdownContainer", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_globalItemColors", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_defaultCellHoverColors", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_frameComponents", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_rowDropdownCellOverlays", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_stripedRows", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_overflow", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_pagination", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_files", 2);
__decorateClass([
  r$1()
], ActiveTable.prototype, "_visiblityInternal", 2);
__decorateClass([
  r$1({
    hasChanged() {
      return !1;
    }
  })
], ActiveTable.prototype, "_isRendering", 2);
__decorateClass([
  r$1({
    hasChanged() {
      return !1;
    }
  })
], ActiveTable.prototype, "_isPopulatingTable", 2);
ActiveTable = __decorateClass([
  t$2("active-table")
], ActiveTable);
var papaparse_min$1 = { exports: {} };
/* @license
Papa Parse
v5.5.3
https://github.com/mholt/PapaParse
License: MIT
*/
var papaparse_min = papaparse_min$1.exports, hasRequiredPapaparse_min;
function requirePapaparse_min() {
  return hasRequiredPapaparse_min || (hasRequiredPapaparse_min = 1, function(F, x) {
    ((w, O) => {
      F.exports = O();
    })(papaparse_min, function w() {
      var O = typeof self < "u" ? self : typeof window < "u" ? window : O !== void 0 ? O : {}, D, U = !O.document && !!O.postMessage, W = O.IS_PAPA_WORKER || !1, X = {}, G = 0, Y = {};
      function K(ae) {
        this._handle = null, this._finished = !1, this._completed = !1, this._halted = !1, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = { data: [], errors: [], meta: {} }, function(se) {
          var ce = Ee(se);
          ce.chunkSize = parseInt(ce.chunkSize), se.step || se.chunk || (ce.chunkSize = null), this._handle = new re(ce), (this._handle.streamer = this)._config = ce;
        }.call(this, ae), this.parseChunk = function(se, ce) {
          var xe = parseInt(this._config.skipFirstNLines) || 0;
          if (this.isFirstChunk && 0 < xe) {
            let ye = this._config.newline;
            ye || (Ce = this._config.quoteChar || '"', ye = this._handle.guessLineEndings(se, Ce)), se = [...se.split(ye).slice(xe)].join(ye);
          }
          this.isFirstChunk && de(this._config.beforeFirstChunk) && (Ce = this._config.beforeFirstChunk(se)) !== void 0 && (se = Ce), this.isFirstChunk = !1, this._halted = !1;
          var xe = this._partialLine + se, Ce = (this._partialLine = "", this._handle.parse(xe, this._baseIndex, !this._finished));
          if (!this._handle.paused() && !this._handle.aborted()) {
            if (se = Ce.meta.cursor, xe = (this._finished || (this._partialLine = xe.substring(se - this._baseIndex), this._baseIndex = se), Ce && Ce.data && (this._rowCount += Ce.data.length), this._finished || this._config.preview && this._rowCount >= this._config.preview), W) O.postMessage({ results: Ce, workerId: Y.WORKER_ID, finished: xe });
            else if (de(this._config.chunk) && !ce) {
              if (this._config.chunk(Ce, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = !0);
              this._completeResults = Ce = void 0;
            }
            return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(Ce.data), this._completeResults.errors = this._completeResults.errors.concat(Ce.errors), this._completeResults.meta = Ce.meta), this._completed || !xe || !de(this._config.complete) || Ce && Ce.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0), xe || Ce && Ce.meta.paused || this._nextChunk(), Ce;
          }
          this._halted = !0;
        }, this._sendError = function(se) {
          de(this._config.error) ? this._config.error(se) : W && this._config.error && O.postMessage({ workerId: Y.WORKER_ID, error: se, finished: !1 });
        };
      }
      function Z(ae) {
        var se;
        (ae = ae || {}).chunkSize || (ae.chunkSize = Y.RemoteChunkSize), K.call(this, ae), this._nextChunk = U ? function() {
          this._readChunk(), this._chunkLoaded();
        } : function() {
          this._readChunk();
        }, this.stream = function(ce) {
          this._input = ce, this._nextChunk();
        }, this._readChunk = function() {
          if (this._finished) this._chunkLoaded();
          else {
            if (se = new XMLHttpRequest(), this._config.withCredentials && (se.withCredentials = this._config.withCredentials), U || (se.onload = Te(this._chunkLoaded, this), se.onerror = Te(this._chunkError, this)), se.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !U), this._config.downloadRequestHeaders) {
              var ce, xe = this._config.downloadRequestHeaders;
              for (ce in xe) se.setRequestHeader(ce, xe[ce]);
            }
            var Ce;
            this._config.chunkSize && (Ce = this._start + this._config.chunkSize - 1, se.setRequestHeader("Range", "bytes=" + this._start + "-" + Ce));
            try {
              se.send(this._config.downloadRequestBody);
            } catch (ye) {
              this._chunkError(ye.message);
            }
            U && se.status === 0 && this._chunkError();
          }
        }, this._chunkLoaded = function() {
          se.readyState === 4 && (se.status < 200 || 400 <= se.status ? this._chunkError() : (this._start += this._config.chunkSize || se.responseText.length, this._finished = !this._config.chunkSize || this._start >= ((ce) => (ce = ce.getResponseHeader("Content-Range")) !== null ? parseInt(ce.substring(ce.lastIndexOf("/") + 1)) : -1)(se), this.parseChunk(se.responseText)));
        }, this._chunkError = function(ce) {
          ce = se.statusText || ce, this._sendError(new Error(ce));
        };
      }
      function q(ae) {
        (ae = ae || {}).chunkSize || (ae.chunkSize = Y.LocalChunkSize), K.call(this, ae);
        var se, ce, xe = typeof FileReader < "u";
        this.stream = function(Ce) {
          this._input = Ce, ce = Ce.slice || Ce.webkitSlice || Ce.mozSlice, xe ? ((se = new FileReader()).onload = Te(this._chunkLoaded, this), se.onerror = Te(this._chunkError, this)) : se = new FileReaderSync(), this._nextChunk();
        }, this._nextChunk = function() {
          this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
        }, this._readChunk = function() {
          var Ce = this._input, ye = (this._config.chunkSize && (ye = Math.min(this._start + this._config.chunkSize, this._input.size), Ce = ce.call(Ce, this._start, ye)), se.readAsText(Ce, this._config.encoding));
          xe || this._chunkLoaded({ target: { result: ye } });
        }, this._chunkLoaded = function(Ce) {
          this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(Ce.target.result);
        }, this._chunkError = function() {
          this._sendError(se.error);
        };
      }
      function J(ae) {
        var se;
        K.call(this, ae = ae || {}), this.stream = function(ce) {
          return se = ce, this._nextChunk();
        }, this._nextChunk = function() {
          var ce, xe;
          if (!this._finished) return ce = this._config.chunkSize, se = ce ? (xe = se.substring(0, ce), se.substring(ce)) : (xe = se, ""), this._finished = !se, this.parseChunk(xe);
        };
      }
      function ee(ae) {
        K.call(this, ae = ae || {});
        var se = [], ce = !0, xe = !1;
        this.pause = function() {
          K.prototype.pause.apply(this, arguments), this._input.pause();
        }, this.resume = function() {
          K.prototype.resume.apply(this, arguments), this._input.resume();
        }, this.stream = function(Ce) {
          this._input = Ce, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
        }, this._checkIsFinished = function() {
          xe && se.length === 1 && (this._finished = !0);
        }, this._nextChunk = function() {
          this._checkIsFinished(), se.length ? this.parseChunk(se.shift()) : ce = !0;
        }, this._streamData = Te(function(Ce) {
          try {
            se.push(typeof Ce == "string" ? Ce : Ce.toString(this._config.encoding)), ce && (ce = !1, this._checkIsFinished(), this.parseChunk(se.shift()));
          } catch (ye) {
            this._streamError(ye);
          }
        }, this), this._streamError = Te(function(Ce) {
          this._streamCleanUp(), this._sendError(Ce);
        }, this), this._streamEnd = Te(function() {
          this._streamCleanUp(), xe = !0, this._streamData("");
        }, this), this._streamCleanUp = Te(function() {
          this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
        }, this);
      }
      function re(ae) {
        var se, ce, xe, Ce, ye = Math.pow(2, 53), ze = -ye, De = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, et = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, Oe = this, Xe = 0, He = 0, Ae = !1, qe = !1, Ue = [], Re = { data: [], errors: [], meta: {} };
        function Me(fe) {
          return ae.skipEmptyLines === "greedy" ? fe.join("").trim() === "" : fe.length === 1 && fe[0].length === 0;
        }
        function je() {
          if (Re && xe && (rt("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + Y.DefaultDelimiter + "'"), xe = !1), ae.skipEmptyLines && (Re.data = Re.data.filter(function(me) {
            return !Me(me);
          })), Je()) {
            let me = function(ke, ue) {
              de(ae.transformHeader) && (ke = ae.transformHeader(ke, ue)), Ue.push(ke);
            };
            if (Re) if (Array.isArray(Re.data[0])) {
              for (var fe = 0; Je() && fe < Re.data.length; fe++) Re.data[fe].forEach(me);
              Re.data.splice(0, 1);
            } else Re.data.forEach(me);
          }
          function Se(me, ke) {
            for (var ue = ae.header ? {} : [], We = 0; We < me.length; We++) {
              var Ge = We, Pe = me[We], Pe = ((it, Ve) => ((st) => (ae.dynamicTypingFunction && ae.dynamicTyping[st] === void 0 && (ae.dynamicTyping[st] = ae.dynamicTypingFunction(st)), (ae.dynamicTyping[st] || ae.dynamicTyping) === !0))(it) ? Ve === "true" || Ve === "TRUE" || Ve !== "false" && Ve !== "FALSE" && (((st) => {
                if (De.test(st) && (st = parseFloat(st), ze < st && st < ye))
                  return 1;
              })(Ve) ? parseFloat(Ve) : et.test(Ve) ? new Date(Ve) : Ve === "" ? null : Ve) : Ve)(Ge = ae.header ? We >= Ue.length ? "__parsed_extra" : Ue[We] : Ge, Pe = ae.transform ? ae.transform(Pe, Ge) : Pe);
              Ge === "__parsed_extra" ? (ue[Ge] = ue[Ge] || [], ue[Ge].push(Pe)) : ue[Ge] = Pe;
            }
            return ae.header && (We > Ue.length ? rt("FieldMismatch", "TooManyFields", "Too many fields: expected " + Ue.length + " fields but parsed " + We, He + ke) : We < Ue.length && rt("FieldMismatch", "TooFewFields", "Too few fields: expected " + Ue.length + " fields but parsed " + We, He + ke)), ue;
          }
          var we;
          Re && (ae.header || ae.dynamicTyping || ae.transform) && (we = 1, !Re.data.length || Array.isArray(Re.data[0]) ? (Re.data = Re.data.map(Se), we = Re.data.length) : Re.data = Se(Re.data, 0), ae.header && Re.meta && (Re.meta.fields = Ue), He += we);
        }
        function Je() {
          return ae.header && Ue.length === 0;
        }
        function rt(fe, Se, we, me) {
          fe = { type: fe, code: Se, message: we }, me !== void 0 && (fe.row = me), Re.errors.push(fe);
        }
        de(ae.step) && (Ce = ae.step, ae.step = function(fe) {
          Re = fe, Je() ? je() : (je(), Re.data.length !== 0 && (Xe += fe.data.length, ae.preview && Xe > ae.preview ? ce.abort() : (Re.data = Re.data[0], Ce(Re, Oe))));
        }), this.parse = function(fe, Se, we) {
          var me = ae.quoteChar || '"', me = (ae.newline || (ae.newline = this.guessLineEndings(fe, me)), xe = !1, ae.delimiter ? de(ae.delimiter) && (ae.delimiter = ae.delimiter(fe), Re.meta.delimiter = ae.delimiter) : ((me = ((ke, ue, We, Ge, Pe) => {
            var it, Ve, st, dt;
            Pe = Pe || [",", "	", "|", ";", Y.RECORD_SEP, Y.UNIT_SEP];
            for (var ut = 0; ut < Pe.length; ut++) {
              for (var mt, at = Pe[ut], lt = 0, Ke = 0, _t = 0, gt = (st = void 0, new Q({ comments: Ge, delimiter: at, newline: ue, preview: 10 }).parse(ke)), ht = 0; ht < gt.data.length; ht++) We && Me(gt.data[ht]) ? _t++ : (mt = gt.data[ht].length, Ke += mt, st === void 0 ? st = mt : 0 < mt && (lt += Math.abs(mt - st), st = mt));
              0 < gt.data.length && (Ke /= gt.data.length - _t), (Ve === void 0 || lt <= Ve) && (dt === void 0 || dt < Ke) && 1.99 < Ke && (Ve = lt, it = at, dt = Ke);
            }
            return { successful: !!(ae.delimiter = it), bestDelimiter: it };
          })(fe, ae.newline, ae.skipEmptyLines, ae.comments, ae.delimitersToGuess)).successful ? ae.delimiter = me.bestDelimiter : (xe = !0, ae.delimiter = Y.DefaultDelimiter), Re.meta.delimiter = ae.delimiter), Ee(ae));
          return ae.preview && ae.header && me.preview++, se = fe, ce = new Q(me), Re = ce.parse(se, Se, we), je(), Ae ? { meta: { paused: !0 } } : Re || { meta: { paused: !1 } };
        }, this.paused = function() {
          return Ae;
        }, this.pause = function() {
          Ae = !0, ce.abort(), se = de(ae.chunk) ? "" : se.substring(ce.getCharIndex());
        }, this.resume = function() {
          Oe.streamer._halted ? (Ae = !1, Oe.streamer.parseChunk(se, !0)) : setTimeout(Oe.resume, 3);
        }, this.aborted = function() {
          return qe;
        }, this.abort = function() {
          qe = !0, ce.abort(), Re.meta.aborted = !0, de(ae.complete) && ae.complete(Re), se = "";
        }, this.guessLineEndings = function(ke, me) {
          ke = ke.substring(0, 1048576);
          var me = new RegExp(te(me) + "([^]*?)" + te(me), "gm"), we = (ke = ke.replace(me, "")).split("\r"), me = ke.split(`
`), ke = 1 < me.length && me[0].length < we[0].length;
          if (we.length === 1 || ke) return `
`;
          for (var ue = 0, We = 0; We < we.length; We++) we[We][0] === `
` && ue++;
          return ue >= we.length / 2 ? `\r
` : "\r";
        };
      }
      function te(ae) {
        return ae.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function Q(ae) {
        var se = (ae = ae || {}).delimiter, ce = ae.newline, xe = ae.comments, Ce = ae.step, ye = ae.preview, ze = ae.fastMode, De = null, et = !1, Oe = ae.quoteChar == null ? '"' : ae.quoteChar, Xe = Oe;
        if (ae.escapeChar !== void 0 && (Xe = ae.escapeChar), (typeof se != "string" || -1 < Y.BAD_DELIMITERS.indexOf(se)) && (se = ","), xe === se) throw new Error("Comment character same as delimiter");
        xe === !0 ? xe = "#" : (typeof xe != "string" || -1 < Y.BAD_DELIMITERS.indexOf(xe)) && (xe = !1), ce !== `
` && ce !== "\r" && ce !== `\r
` && (ce = `
`);
        var He = 0, Ae = !1;
        this.parse = function(qe, Ue, Re) {
          if (typeof qe != "string") throw new Error("Input must be a string");
          var Me = qe.length, je = se.length, Je = ce.length, rt = xe.length, fe = de(Ce), Se = [], we = [], me = [], ke = He = 0;
          if (!qe) return lt();
          if (ze || ze !== !1 && qe.indexOf(Oe) === -1) {
            for (var ue = qe.split(ce), We = 0; We < ue.length; We++) {
              if (me = ue[We], He += me.length, We !== ue.length - 1) He += ce.length;
              else if (Re) return lt();
              if (!xe || me.substring(0, rt) !== xe) {
                if (fe) {
                  if (Se = [], dt(me.split(se)), Ke(), Ae) return lt();
                } else dt(me.split(se));
                if (ye && ye <= We) return Se = Se.slice(0, ye), lt(!0);
              }
            }
            return lt();
          }
          for (var Ge = qe.indexOf(se, He), Pe = qe.indexOf(ce, He), it = new RegExp(te(Xe) + te(Oe), "g"), Ve = qe.indexOf(Oe, He); ; ) if (qe[He] === Oe) for (Ve = He, He++; ; ) {
            if ((Ve = qe.indexOf(Oe, Ve + 1)) === -1) return Re || we.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: Se.length, index: He }), mt();
            if (Ve === Me - 1) return mt(qe.substring(He, Ve).replace(it, Oe));
            if (Oe === Xe && qe[Ve + 1] === Xe) Ve++;
            else if (Oe === Xe || Ve === 0 || qe[Ve - 1] !== Xe) {
              Ge !== -1 && Ge < Ve + 1 && (Ge = qe.indexOf(se, Ve + 1));
              var st = ut((Pe = Pe !== -1 && Pe < Ve + 1 ? qe.indexOf(ce, Ve + 1) : Pe) === -1 ? Ge : Math.min(Ge, Pe));
              if (qe.substr(Ve + 1 + st, je) === se) {
                me.push(qe.substring(He, Ve).replace(it, Oe)), qe[He = Ve + 1 + st + je] !== Oe && (Ve = qe.indexOf(Oe, He)), Ge = qe.indexOf(se, He), Pe = qe.indexOf(ce, He);
                break;
              }
              if (st = ut(Pe), qe.substring(Ve + 1 + st, Ve + 1 + st + Je) === ce) {
                if (me.push(qe.substring(He, Ve).replace(it, Oe)), at(Ve + 1 + st + Je), Ge = qe.indexOf(se, He), Ve = qe.indexOf(Oe, He), fe && (Ke(), Ae)) return lt();
                if (ye && Se.length >= ye) return lt(!0);
                break;
              }
              we.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: Se.length, index: He }), Ve++;
            }
          }
          else if (xe && me.length === 0 && qe.substring(He, He + rt) === xe) {
            if (Pe === -1) return lt();
            He = Pe + Je, Pe = qe.indexOf(ce, He), Ge = qe.indexOf(se, He);
          } else if (Ge !== -1 && (Ge < Pe || Pe === -1)) me.push(qe.substring(He, Ge)), He = Ge + je, Ge = qe.indexOf(se, He);
          else {
            if (Pe === -1) break;
            if (me.push(qe.substring(He, Pe)), at(Pe + Je), fe && (Ke(), Ae)) return lt();
            if (ye && Se.length >= ye) return lt(!0);
          }
          return mt();
          function dt(_t) {
            Se.push(_t), ke = He;
          }
          function ut(_t) {
            var gt = 0;
            return gt = _t !== -1 && (_t = qe.substring(Ve + 1, _t)) && _t.trim() === "" ? _t.length : gt;
          }
          function mt(_t) {
            return Re || (_t === void 0 && (_t = qe.substring(He)), me.push(_t), He = Me, dt(me), fe && Ke()), lt();
          }
          function at(_t) {
            He = _t, dt(me), me = [], Pe = qe.indexOf(ce, He);
          }
          function lt(_t) {
            if (ae.header && !Ue && Se.length && !et) {
              var gt = Se[0], ht = /* @__PURE__ */ Object.create(null), Pt = new Set(gt);
              let kt = !1;
              for (let tt = 0; tt < gt.length; tt++) {
                let ft = gt[tt];
                if (ht[ft = de(ae.transformHeader) ? ae.transformHeader(ft, tt) : ft]) {
                  let St, bt = ht[ft];
                  for (; St = ft + "_" + bt, bt++, Pt.has(St); ) ;
                  Pt.add(St), gt[tt] = St, ht[ft]++, kt = !0, (De = De === null ? {} : De)[St] = ft;
                } else ht[ft] = 1, gt[tt] = ft;
                Pt.add(ft);
              }
              kt && console.warn("Duplicate headers found and renamed."), et = !0;
            }
            return { data: Se, errors: we, meta: { delimiter: se, linebreak: ce, aborted: Ae, truncated: !!_t, cursor: ke + (Ue || 0), renamedHeaders: De } };
          }
          function Ke() {
            Ce(lt()), Se = [], we = [];
          }
        }, this.abort = function() {
          Ae = !0;
        }, this.getCharIndex = function() {
          return He;
        };
      }
      function oe(ae) {
        var se = ae.data, ce = X[se.workerId], xe = !1;
        if (se.error) ce.userError(se.error, se.file);
        else if (se.results && se.results.data) {
          var Ce = { abort: function() {
            xe = !0, ne(se.workerId, { data: [], errors: [], meta: { aborted: !0 } });
          }, pause: le, resume: le };
          if (de(ce.userStep)) {
            for (var ye = 0; ye < se.results.data.length && (ce.userStep({ data: se.results.data[ye], errors: se.results.errors, meta: se.results.meta }, Ce), !xe); ye++) ;
            delete se.results;
          } else de(ce.userChunk) && (ce.userChunk(se.results, Ce, se.file), delete se.results);
        }
        se.finished && !xe && ne(se.workerId, se.results);
      }
      function ne(ae, se) {
        var ce = X[ae];
        de(ce.userComplete) && ce.userComplete(se), ce.terminate(), delete X[ae];
      }
      function le() {
        throw new Error("Not implemented.");
      }
      function Ee(ae) {
        if (typeof ae != "object" || ae === null) return ae;
        var se, ce = Array.isArray(ae) ? [] : {};
        for (se in ae) ce[se] = Ee(ae[se]);
        return ce;
      }
      function Te(ae, se) {
        return function() {
          ae.apply(se, arguments);
        };
      }
      function de(ae) {
        return typeof ae == "function";
      }
      return Y.parse = function(ae, se) {
        var ce = (se = se || {}).dynamicTyping || !1;
        if (de(ce) && (se.dynamicTypingFunction = ce, ce = {}), se.dynamicTyping = ce, se.transform = !!de(se.transform) && se.transform, !se.worker || !Y.WORKERS_SUPPORTED) return ce = null, Y.NODE_STREAM_INPUT, typeof ae == "string" ? (ae = ((xe) => xe.charCodeAt(0) !== 65279 ? xe : xe.slice(1))(ae), ce = new (se.download ? Z : J)(se)) : ae.readable === !0 && de(ae.read) && de(ae.on) ? ce = new ee(se) : (O.File && ae instanceof File || ae instanceof Object) && (ce = new q(se)), ce.stream(ae);
        (ce = (() => {
          var xe;
          return !!Y.WORKERS_SUPPORTED && (xe = (() => {
            var Ce = O.URL || O.webkitURL || null, ye = w.toString();
            return Y.BLOB_URL || (Y.BLOB_URL = Ce.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", ye, ")();"], { type: "text/javascript" })));
          })(), (xe = new O.Worker(xe)).onmessage = oe, xe.id = G++, X[xe.id] = xe);
        })()).userStep = se.step, ce.userChunk = se.chunk, ce.userComplete = se.complete, ce.userError = se.error, se.step = de(se.step), se.chunk = de(se.chunk), se.complete = de(se.complete), se.error = de(se.error), delete se.worker, ce.postMessage({ input: ae, config: se, workerId: ce.id });
      }, Y.unparse = function(ae, se) {
        var ce = !1, xe = !0, Ce = ",", ye = `\r
`, ze = '"', De = ze + ze, et = !1, Oe = null, Xe = !1, He = ((() => {
          if (typeof se == "object") {
            if (typeof se.delimiter != "string" || Y.BAD_DELIMITERS.filter(function(Ue) {
              return se.delimiter.indexOf(Ue) !== -1;
            }).length || (Ce = se.delimiter), typeof se.quotes != "boolean" && typeof se.quotes != "function" && !Array.isArray(se.quotes) || (ce = se.quotes), typeof se.skipEmptyLines != "boolean" && typeof se.skipEmptyLines != "string" || (et = se.skipEmptyLines), typeof se.newline == "string" && (ye = se.newline), typeof se.quoteChar == "string" && (ze = se.quoteChar), typeof se.header == "boolean" && (xe = se.header), Array.isArray(se.columns)) {
              if (se.columns.length === 0) throw new Error("Option columns is empty");
              Oe = se.columns;
            }
            se.escapeChar !== void 0 && (De = se.escapeChar + ze), se.escapeFormulae instanceof RegExp ? Xe = se.escapeFormulae : typeof se.escapeFormulae == "boolean" && se.escapeFormulae && (Xe = /^[=+\-@\t\r].*$/);
          }
        })(), new RegExp(te(ze), "g"));
        if (typeof ae == "string" && (ae = JSON.parse(ae)), Array.isArray(ae)) {
          if (!ae.length || Array.isArray(ae[0])) return Ae(null, ae, et);
          if (typeof ae[0] == "object") return Ae(Oe || Object.keys(ae[0]), ae, et);
        } else if (typeof ae == "object") return typeof ae.data == "string" && (ae.data = JSON.parse(ae.data)), Array.isArray(ae.data) && (ae.fields || (ae.fields = ae.meta && ae.meta.fields || Oe), ae.fields || (ae.fields = Array.isArray(ae.data[0]) ? ae.fields : typeof ae.data[0] == "object" ? Object.keys(ae.data[0]) : []), Array.isArray(ae.data[0]) || typeof ae.data[0] == "object" || (ae.data = [ae.data])), Ae(ae.fields || [], ae.data || [], et);
        throw new Error("Unable to serialize unrecognized input");
        function Ae(Ue, Re, Me) {
          var je = "", Je = (typeof Ue == "string" && (Ue = JSON.parse(Ue)), typeof Re == "string" && (Re = JSON.parse(Re)), Array.isArray(Ue) && 0 < Ue.length), rt = !Array.isArray(Re[0]);
          if (Je && xe) {
            for (var fe = 0; fe < Ue.length; fe++) 0 < fe && (je += Ce), je += qe(Ue[fe], fe);
            0 < Re.length && (je += ye);
          }
          for (var Se = 0; Se < Re.length; Se++) {
            var we = (Je ? Ue : Re[Se]).length, me = !1, ke = Je ? Object.keys(Re[Se]).length === 0 : Re[Se].length === 0;
            if (Me && !Je && (me = Me === "greedy" ? Re[Se].join("").trim() === "" : Re[Se].length === 1 && Re[Se][0].length === 0), Me === "greedy" && Je) {
              for (var ue = [], We = 0; We < we; We++) {
                var Ge = rt ? Ue[We] : We;
                ue.push(Re[Se][Ge]);
              }
              me = ue.join("").trim() === "";
            }
            if (!me) {
              for (var Pe = 0; Pe < we; Pe++) {
                0 < Pe && !ke && (je += Ce);
                var it = Je && rt ? Ue[Pe] : Pe;
                je += qe(Re[Se][it], Pe);
              }
              Se < Re.length - 1 && (!Me || 0 < we && !ke) && (je += ye);
            }
          }
          return je;
        }
        function qe(Ue, Re) {
          var Me, je;
          return Ue == null ? "" : Ue.constructor === Date ? JSON.stringify(Ue).slice(1, 25) : (je = !1, Xe && typeof Ue == "string" && Xe.test(Ue) && (Ue = "'" + Ue, je = !0), Me = Ue.toString().replace(He, De), (je = je || ce === !0 || typeof ce == "function" && ce(Ue, Re) || Array.isArray(ce) && ce[Re] || ((Je, rt) => {
            for (var fe = 0; fe < rt.length; fe++) if (-1 < Je.indexOf(rt[fe])) return !0;
            return !1;
          })(Me, Y.BAD_DELIMITERS) || -1 < Me.indexOf(Ce) || Me.charAt(0) === " " || Me.charAt(Me.length - 1) === " ") ? ze + Me + ze : Me);
        }
      }, Y.RECORD_SEP = "", Y.UNIT_SEP = "", Y.BYTE_ORDER_MARK = "\uFEFF", Y.BAD_DELIMITERS = ["\r", `
`, '"', Y.BYTE_ORDER_MARK], Y.WORKERS_SUPPORTED = !U && !!O.Worker, Y.NODE_STREAM_INPUT = 1, Y.LocalChunkSize = 10485760, Y.RemoteChunkSize = 5242880, Y.DefaultDelimiter = ",", Y.Parser = Q, Y.ParserHandle = re, Y.NetworkStreamer = Z, Y.FileStreamer = q, Y.StringStreamer = J, Y.ReadableStreamStreamer = ee, O.jQuery && ((D = O.jQuery).fn.parse = function(ae) {
        var se = ae.config || {}, ce = [];
        return this.each(function(ye) {
          if (!(D(this).prop("tagName").toUpperCase() === "INPUT" && D(this).attr("type").toLowerCase() === "file" && O.FileReader) || !this.files || this.files.length === 0) return !0;
          for (var ze = 0; ze < this.files.length; ze++) ce.push({ file: this.files[ze], inputElem: this, instanceConfig: D.extend({}, se) });
        }), xe(), this;
        function xe() {
          if (ce.length === 0) de(ae.complete) && ae.complete();
          else {
            var ye, ze, De, et, Oe = ce[0];
            if (de(ae.before)) {
              var Xe = ae.before(Oe.file, Oe.inputElem);
              if (typeof Xe == "object") {
                if (Xe.action === "abort") return ye = "AbortError", ze = Oe.file, De = Oe.inputElem, et = Xe.reason, void (de(ae.error) && ae.error({ name: ye }, ze, De, et));
                if (Xe.action === "skip") return void Ce();
                typeof Xe.config == "object" && (Oe.instanceConfig = D.extend(Oe.instanceConfig, Xe.config));
              } else if (Xe === "skip") return void Ce();
            }
            var He = Oe.instanceConfig.complete;
            Oe.instanceConfig.complete = function(Ae) {
              de(He) && He(Ae, Oe.file, Oe.inputElem), Ce();
            }, Y.parse(Oe.file, Oe.instanceConfig);
          }
        }
        function Ce() {
          ce.splice(0, 1), xe();
        }
      }), W && (O.onmessage = function(ae) {
        ae = ae.data, Y.WORKER_ID === void 0 && ae && (Y.WORKER_ID = ae.workerId), typeof ae.input == "string" ? O.postMessage({ workerId: Y.WORKER_ID, results: Y.parse(ae.input, ae.config), finished: !0 }) : (O.File && ae.input instanceof File || ae.input instanceof Object) && (ae = Y.parse(ae.input, ae.config)) && O.postMessage({ workerId: Y.WORKER_ID, results: ae, finished: !0 });
      }), (Z.prototype = Object.create(K.prototype)).constructor = Z, (q.prototype = Object.create(K.prototype)).constructor = q, (J.prototype = Object.create(J.prototype)).constructor = J, (ee.prototype = Object.create(K.prototype)).constructor = ee, Y;
    });
  }(papaparse_min$1)), papaparse_min$1.exports;
}
var papaparse_minExports = requirePapaparse_min();
const Papa = /* @__PURE__ */ getDefaultExportFromCjs(papaparse_minExports);
/*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
var XLSX = {};
XLSX.version = "0.20.3";
var current_codepage = 1200, current_ansi = 1252, $cptable, VALID_ANSI = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4], CS2CP = {
  0: 1252,
  /* ANSI */
  1: 65001,
  /* DEFAULT */
  2: 65001,
  /* SYMBOL */
  77: 1e4,
  /* MAC */
  128: 932,
  /* SHIFTJIS */
  129: 949,
  /* HANGUL */
  130: 1361,
  /* JOHAB */
  134: 936,
  /* GB2312 */
  136: 950,
  /* CHINESEBIG5 */
  161: 1253,
  /* GREEK */
  162: 1254,
  /* TURKISH */
  163: 1258,
  /* VIETNAMESE */
  177: 1255,
  /* HEBREW */
  178: 1256,
  /* ARABIC */
  186: 1257,
  /* BALTIC */
  204: 1251,
  /* RUSSIAN */
  222: 874,
  /* THAI */
  238: 1250,
  /* EASTEUROPE */
  255: 1252,
  /* OEM */
  69: 6969
  /* MISC */
}, set_ansi = function(F) {
  VALID_ANSI.indexOf(F) != -1 && (current_ansi = CS2CP[0] = F);
};
function reset_ansi() {
  set_ansi(1252);
}
var set_cp = function(F) {
  current_codepage = F, set_ansi(F);
};
function reset_cp() {
  set_cp(1200), reset_ansi();
}
function char_codes(F) {
  for (var x = [], w = 0, O = F.length; w < O; ++w) x[w] = F.charCodeAt(w);
  return x;
}
function utf16leread(F) {
  for (var x = [], w = 0; w < F.length >> 1; ++w) x[w] = String.fromCharCode(F.charCodeAt(2 * w) + (F.charCodeAt(2 * w + 1) << 8));
  return x.join("");
}
function utf16lereadu(F) {
  for (var x = [], w = 0; w < F.length >> 1; ++w) x[w] = String.fromCharCode(F[2 * w] + (F[2 * w + 1] << 8));
  return x.join("");
}
function utf16beread(F) {
  for (var x = [], w = 0; w < F.length >> 1; ++w) x[w] = String.fromCharCode(F.charCodeAt(2 * w + 1) + (F.charCodeAt(2 * w) << 8));
  return x.join("");
}
var debom = function(F) {
  var x = F.charCodeAt(0), w = F.charCodeAt(1);
  return x == 255 && w == 254 ? utf16leread(F.slice(2)) : x == 254 && w == 255 ? utf16beread(F.slice(2)) : x == 65279 ? F.slice(1) : F;
}, _getchar = function F(x) {
  return String.fromCharCode(x);
}, _getansi = function F(x) {
  return String.fromCharCode(x);
};
function set_cptable(F) {
  $cptable = F, set_cp = function(x) {
    current_codepage = x, set_ansi(x);
  }, debom = function(x) {
    return x.charCodeAt(0) === 255 && x.charCodeAt(1) === 254 ? $cptable.utils.decode(1200, char_codes(x.slice(2))) : x;
  }, _getchar = function(w) {
    return current_codepage === 1200 ? String.fromCharCode(w) : $cptable.utils.decode(current_codepage, [w & 255, w >> 8])[0];
  }, _getansi = function(w) {
    return $cptable.utils.decode(current_ansi, [w])[0];
  }, cpdoit();
}
var DENSE = null, Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function Base64_encode(F) {
  for (var x = "", w = 0, O = 0, D = 0, U = 0, W = 0, X = 0, G = 0, Y = 0; Y < F.length; )
    w = F.charCodeAt(Y++), U = w >> 2, O = F.charCodeAt(Y++), W = (w & 3) << 4 | O >> 4, D = F.charCodeAt(Y++), X = (O & 15) << 2 | D >> 6, G = D & 63, isNaN(O) ? X = G = 64 : isNaN(D) && (G = 64), x += Base64_map.charAt(U) + Base64_map.charAt(W) + Base64_map.charAt(X) + Base64_map.charAt(G);
  return x;
}
function Base64_encode_pass(F) {
  for (var x = "", w = 0, O = 0, D = 0, U = 0, W = 0, X = 0, G = 0, Y = 0; Y < F.length; )
    w = F.charCodeAt(Y++), w > 255 && (w = 95), U = w >> 2, O = F.charCodeAt(Y++), O > 255 && (O = 95), W = (w & 3) << 4 | O >> 4, D = F.charCodeAt(Y++), D > 255 && (D = 95), X = (O & 15) << 2 | D >> 6, G = D & 63, isNaN(O) ? X = G = 64 : isNaN(D) && (G = 64), x += Base64_map.charAt(U) + Base64_map.charAt(W) + Base64_map.charAt(X) + Base64_map.charAt(G);
  return x;
}
function Base64_encode_arr(F) {
  for (var x = "", w = 0, O = 0, D = 0, U = 0, W = 0, X = 0, G = 0, Y = 0; Y < F.length; )
    w = F[Y++], U = w >> 2, O = F[Y++], W = (w & 3) << 4 | O >> 4, D = F[Y++], X = (O & 15) << 2 | D >> 6, G = D & 63, isNaN(O) ? X = G = 64 : isNaN(D) && (G = 64), x += Base64_map.charAt(U) + Base64_map.charAt(W) + Base64_map.charAt(X) + Base64_map.charAt(G);
  return x;
}
function Base64_decode(F) {
  var x = "", w = 0, O = 0, D = 0, U = 0, W = 0, X = 0, G = 0;
  if (F.slice(0, 5) == "data:") {
    var Y = F.slice(0, 1024).indexOf(";base64,");
    Y > -1 && (F = F.slice(Y + 8));
  }
  F = F.replace(/[^\w\+\/\=]/g, "");
  for (var Y = 0; Y < F.length; )
    U = Base64_map.indexOf(F.charAt(Y++)), W = Base64_map.indexOf(F.charAt(Y++)), w = U << 2 | W >> 4, x += String.fromCharCode(w), X = Base64_map.indexOf(F.charAt(Y++)), O = (W & 15) << 4 | X >> 2, X !== 64 && (x += String.fromCharCode(O)), G = Base64_map.indexOf(F.charAt(Y++)), D = (X & 3) << 6 | G, G !== 64 && (x += String.fromCharCode(D));
  return x;
}
var has_buf = /* @__PURE__ */ function() {
  return typeof Buffer < "u" && typeof process < "u" && typeof process.versions < "u" && !!process.versions.node;
}(), Buffer_from = /* @__PURE__ */ function() {
  if (typeof Buffer < "u") {
    var F = !Buffer.from;
    if (!F) try {
      Buffer.from("foo", "utf8");
    } catch {
      F = !0;
    }
    return F ? function(x, w) {
      return w ? new Buffer(x, w) : new Buffer(x);
    } : Buffer.from.bind(Buffer);
  }
  return function() {
  };
}(), buf_utf16le = /* @__PURE__ */ function() {
  if (typeof Buffer > "u") return !1;
  var F = Buffer_from([65, 0]);
  if (!F) return !1;
  var x = F.toString("utf16le");
  return x.length == 1;
}();
function new_raw_buf(F) {
  return has_buf ? Buffer.alloc ? Buffer.alloc(F) : new Buffer(F) : typeof Uint8Array < "u" ? new Uint8Array(F) : new Array(F);
}
function new_unsafe_buf(F) {
  return has_buf ? Buffer.allocUnsafe ? Buffer.allocUnsafe(F) : new Buffer(F) : typeof Uint8Array < "u" ? new Uint8Array(F) : new Array(F);
}
var s2a = function F(x) {
  return has_buf ? Buffer_from(x, "binary") : x.split("").map(function(w) {
    return w.charCodeAt(0) & 255;
  });
};
function s2ab(F) {
  if (typeof ArrayBuffer > "u") return s2a(F);
  for (var x = new ArrayBuffer(F.length), w = new Uint8Array(x), O = 0; O != F.length; ++O) w[O] = F.charCodeAt(O) & 255;
  return x;
}
function a2s(F) {
  if (Array.isArray(F)) return F.map(function(O) {
    return String.fromCharCode(O);
  }).join("");
  for (var x = [], w = 0; w < F.length; ++w) x[w] = String.fromCharCode(F[w]);
  return x.join("");
}
function a2u(F) {
  if (typeof Uint8Array > "u") throw new Error("Unsupported");
  return new Uint8Array(F);
}
function ab2a(F) {
  if (typeof ArrayBuffer > "u") throw new Error("Unsupported");
  if (F instanceof ArrayBuffer) return ab2a(new Uint8Array(F));
  for (var x = new Array(F.length), w = 0; w < F.length; ++w) x[w] = F[w];
  return x;
}
var bconcat = has_buf ? function(F) {
  return Buffer.concat(F.map(function(x) {
    return Buffer.isBuffer(x) ? x : Buffer_from(x);
  }));
} : function(F) {
  if (typeof Uint8Array < "u") {
    var x = 0, w = 0;
    for (x = 0; x < F.length; ++x) w += F[x].length;
    var O = new Uint8Array(w), D = 0;
    for (x = 0, w = 0; x < F.length; w += D, ++x)
      D = F[x].length, F[x] instanceof Uint8Array ? O.set(F[x], w) : typeof F[x] == "string" ? O.set(new Uint8Array(s2a(F[x])), w) : O.set(new Uint8Array(F[x]), w);
    return O;
  }
  return [].concat.apply([], F.map(function(U) {
    return Array.isArray(U) ? U : [].slice.call(U);
  }));
};
function utf8decode(F) {
  for (var x = [], w = 0, O = F.length + 250, D = new_raw_buf(F.length + 255), U = 0; U < F.length; ++U) {
    var W = F.charCodeAt(U);
    if (W < 128) D[w++] = W;
    else if (W < 2048)
      D[w++] = 192 | W >> 6 & 31, D[w++] = 128 | W & 63;
    else if (W >= 55296 && W < 57344) {
      W = (W & 1023) + 64;
      var X = F.charCodeAt(++U) & 1023;
      D[w++] = 240 | W >> 8 & 7, D[w++] = 128 | W >> 2 & 63, D[w++] = 128 | X >> 6 & 15 | (W & 3) << 4, D[w++] = 128 | X & 63;
    } else
      D[w++] = 224 | W >> 12 & 15, D[w++] = 128 | W >> 6 & 63, D[w++] = 128 | W & 63;
    w > O && (x.push(D.slice(0, w)), w = 0, D = new_raw_buf(65535), O = 65530);
  }
  return x.push(D.slice(0, w)), bconcat(x);
}
var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;
function _strrev(F) {
  for (var x = "", w = F.length - 1; w >= 0; ) x += F.charAt(w--);
  return x;
}
function pad0(F, x) {
  var w = "" + F;
  return w.length >= x ? w : fill("0", x - w.length) + w;
}
function pad_(F, x) {
  var w = "" + F;
  return w.length >= x ? w : fill(" ", x - w.length) + w;
}
function rpad_(F, x) {
  var w = "" + F;
  return w.length >= x ? w : w + fill(" ", x - w.length);
}
function pad0r1(F, x) {
  var w = "" + Math.round(F);
  return w.length >= x ? w : fill("0", x - w.length) + w;
}
function pad0r2(F, x) {
  var w = "" + F;
  return w.length >= x ? w : fill("0", x - w.length) + w;
}
var p2_32 = /* @__PURE__ */ Math.pow(2, 32);
function pad0r(F, x) {
  if (F > p2_32 || F < -p2_32) return pad0r1(F, x);
  var w = Math.round(F);
  return pad0r2(w, x);
}
function SSF_isgeneral(F, x) {
  return x = x || 0, F.length >= 7 + x && (F.charCodeAt(x) | 32) === 103 && (F.charCodeAt(x + 1) | 32) === 101 && (F.charCodeAt(x + 2) | 32) === 110 && (F.charCodeAt(x + 3) | 32) === 101 && (F.charCodeAt(x + 4) | 32) === 114 && (F.charCodeAt(x + 5) | 32) === 97 && (F.charCodeAt(x + 6) | 32) === 108;
}
var days = [
  ["Sun", "Sunday"],
  ["Mon", "Monday"],
  ["Tue", "Tuesday"],
  ["Wed", "Wednesday"],
  ["Thu", "Thursday"],
  ["Fri", "Friday"],
  ["Sat", "Saturday"]
], months = [
  ["J", "Jan", "January"],
  ["F", "Feb", "February"],
  ["M", "Mar", "March"],
  ["A", "Apr", "April"],
  ["M", "May", "May"],
  ["J", "Jun", "June"],
  ["J", "Jul", "July"],
  ["A", "Aug", "August"],
  ["S", "Sep", "September"],
  ["O", "Oct", "October"],
  ["N", "Nov", "November"],
  ["D", "Dec", "December"]
];
function SSF_init_table(F) {
  return F || (F = {}), F[0] = "General", F[1] = "0", F[2] = "0.00", F[3] = "#,##0", F[4] = "#,##0.00", F[9] = "0%", F[10] = "0.00%", F[11] = "0.00E+00", F[12] = "# ?/?", F[13] = "# ??/??", F[14] = "m/d/yy", F[15] = "d-mmm-yy", F[16] = "d-mmm", F[17] = "mmm-yy", F[18] = "h:mm AM/PM", F[19] = "h:mm:ss AM/PM", F[20] = "h:mm", F[21] = "h:mm:ss", F[22] = "m/d/yy h:mm", F[37] = "#,##0 ;(#,##0)", F[38] = "#,##0 ;[Red](#,##0)", F[39] = "#,##0.00;(#,##0.00)", F[40] = "#,##0.00;[Red](#,##0.00)", F[45] = "mm:ss", F[46] = "[h]:mm:ss", F[47] = "mmss.0", F[48] = "##0.0E+0", F[49] = "@", F[56] = '"上午/下午 "hh"時"mm"分"ss"秒 "', F;
}
var table_fmt = {
  0: "General",
  1: "0",
  2: "0.00",
  3: "#,##0",
  4: "#,##0.00",
  9: "0%",
  10: "0.00%",
  11: "0.00E+00",
  12: "# ?/?",
  13: "# ??/??",
  14: "m/d/yy",
  15: "d-mmm-yy",
  16: "d-mmm",
  17: "mmm-yy",
  18: "h:mm AM/PM",
  19: "h:mm:ss AM/PM",
  20: "h:mm",
  21: "h:mm:ss",
  22: "m/d/yy h:mm",
  37: "#,##0 ;(#,##0)",
  38: "#,##0 ;[Red](#,##0)",
  39: "#,##0.00;(#,##0.00)",
  40: "#,##0.00;[Red](#,##0.00)",
  45: "mm:ss",
  46: "[h]:mm:ss",
  47: "mmss.0",
  48: "##0.0E+0",
  49: "@",
  56: '"上午/下午 "hh"時"mm"分"ss"秒 "'
}, SSF_default_map = {
  5: 37,
  6: 38,
  7: 39,
  8: 40,
  //  5 -> 37 ...  8 -> 40
  23: 0,
  24: 0,
  25: 0,
  26: 0,
  // 23 ->  0 ... 26 ->  0
  27: 14,
  28: 14,
  29: 14,
  30: 14,
  31: 14,
  // 27 -> 14 ... 31 -> 14
  50: 14,
  51: 14,
  52: 14,
  53: 14,
  54: 14,
  // 50 -> 14 ... 58 -> 14
  55: 14,
  56: 14,
  57: 14,
  58: 14,
  59: 1,
  60: 2,
  61: 3,
  62: 4,
  // 59 ->  1 ... 62 ->  4
  67: 9,
  68: 10,
  // 67 ->  9 ... 68 -> 10
  69: 12,
  70: 13,
  71: 14,
  // 69 -> 12 ... 71 -> 14
  72: 14,
  73: 15,
  74: 16,
  75: 17,
  // 72 -> 14 ... 75 -> 17
  76: 20,
  77: 21,
  78: 22,
  // 76 -> 20 ... 78 -> 22
  79: 45,
  80: 46,
  81: 47,
  // 79 -> 45 ... 81 -> 47
  82: 0
  // 82 ->  0 ... 65536 -> 0 (omitted)
}, SSF_default_str = {
  //  5 -- Currency,   0 decimal, black negative
  5: '"$"#,##0_);\\("$"#,##0\\)',
  63: '"$"#,##0_);\\("$"#,##0\\)',
  //  6 -- Currency,   0 decimal, red   negative
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  //  7 -- Currency,   2 decimal, black negative
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  //  8 -- Currency,   2 decimal, red   negative
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  // 41 -- Accounting, 0 decimal, No Symbol
  41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
  // 42 -- Accounting, 0 decimal, $  Symbol
  42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
  // 43 -- Accounting, 2 decimal, No Symbol
  43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
  // 44 -- Accounting, 2 decimal, $  Symbol
  44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
};
function SSF_frac(F, x, w) {
  for (var O = F < 0 ? -1 : 1, D = F * O, U = 0, W = 1, X = 0, G = 1, Y = 0, K = 0, Z = Math.floor(D); Y < x && (Z = Math.floor(D), X = Z * W + U, K = Z * Y + G, !(D - Z < 5e-8)); )
    D = 1 / (D - Z), U = W, W = X, G = Y, Y = K;
  if (K > x && (Y > x ? (K = G, X = U) : (K = Y, X = W)), !w) return [0, O * X, K];
  var q = Math.floor(O * X / K);
  return [q, O * X - q * K, K];
}
function SSF_normalize_xl_unsafe(F) {
  var x = F.toPrecision(16);
  if (x.indexOf("e") > -1) {
    var w = x.slice(0, x.indexOf("e"));
    return w = w.indexOf(".") > -1 ? w.slice(0, w.slice(0, 2) == "0." ? 17 : 16) : w.slice(0, 15) + fill("0", w.length - 15), w + x.slice(x.indexOf("e"));
  }
  var O = x.indexOf(".") > -1 ? x.slice(0, x.slice(0, 2) == "0." ? 17 : 16) : x.slice(0, 15) + fill("0", x.length - 15);
  return Number(O);
}
function SSF_parse_date_code(F, x, w) {
  if (F > 2958465 || F < 0) return null;
  F = SSF_normalize_xl_unsafe(F);
  var O = F | 0, D = Math.floor(86400 * (F - O)), U = 0, W = [], X = { D: O, T: D, u: 86400 * (F - O) - D, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
  if (Math.abs(X.u) < 1e-6 && (X.u = 0), x && x.date1904 && (O += 1462), X.u > 0.9999 && (X.u = 0, ++D == 86400 && (X.T = D = 0, ++O, ++X.D)), O === 60)
    W = w ? [1317, 10, 29] : [1900, 2, 29], U = 3;
  else if (O === 0)
    W = w ? [1317, 8, 29] : [1900, 1, 0], U = 6;
  else {
    O > 60 && --O;
    var G = new Date(1900, 0, 1);
    G.setDate(G.getDate() + O - 1), W = [G.getFullYear(), G.getMonth() + 1, G.getDate()], U = G.getDay(), O < 60 && (U = (U + 6) % 7), w && (U = SSF_fix_hijri(G, W));
  }
  return X.y = W[0], X.m = W[1], X.d = W[2], X.S = D % 60, D = Math.floor(D / 60), X.M = D % 60, D = Math.floor(D / 60), X.H = D, X.q = U, X;
}
function SSF_strip_decimal(F) {
  return F.indexOf(".") == -1 ? F : F.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
}
function SSF_normalize_exp(F) {
  return F.indexOf("E") == -1 ? F : F.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
}
function SSF_small_exp(F) {
  var x = F < 0 ? 12 : 11, w = SSF_strip_decimal(F.toFixed(12));
  return w.length <= x || (w = F.toPrecision(10), w.length <= x) ? w : F.toExponential(5);
}
function SSF_large_exp(F) {
  var x = SSF_strip_decimal(F.toFixed(11));
  return x.length > (F < 0 ? 12 : 11) || x === "0" || x === "-0" ? F.toPrecision(6) : x;
}
function SSF_general_num(F) {
  if (!isFinite(F)) return isNaN(F) ? "#NUM!" : "#DIV/0!";
  var x = Math.floor(Math.log(Math.abs(F)) * Math.LOG10E), w;
  return x >= -4 && x <= -1 ? w = F.toPrecision(10 + x) : Math.abs(x) <= 9 ? w = SSF_small_exp(F) : x === 10 ? w = F.toFixed(10).substr(0, 12) : w = SSF_large_exp(F), SSF_strip_decimal(SSF_normalize_exp(w.toUpperCase()));
}
function SSF_general(F, x) {
  switch (typeof F) {
    case "string":
      return F;
    case "boolean":
      return F ? "TRUE" : "FALSE";
    case "number":
      return (F | 0) === F ? F.toString(10) : SSF_general_num(F);
    case "undefined":
      return "";
    case "object":
      if (F == null) return "";
      if (F instanceof Date) return SSF_format(14, datenum(F, x && x.date1904), x);
  }
  throw new Error("unsupported value in General format: " + F);
}
function SSF_fix_hijri(F, x) {
  x[0] -= 581;
  var w = F.getDay();
  return F < 60 && (w = (w + 6) % 7), w;
}
function SSF_write_date(F, x, w, O) {
  var D = "", U = 0, W = 0, X = w.y, G, Y = 0;
  switch (F) {
    case 98:
      X = w.y + 543;
    /* falls through */
    case 121:
      switch (x.length) {
        case 1:
        case 2:
          G = X % 100, Y = 2;
          break;
        default:
          G = X % 1e4, Y = 4;
          break;
      }
      break;
    case 109:
      switch (x.length) {
        case 1:
        case 2:
          G = w.m, Y = x.length;
          break;
        case 3:
          return months[w.m - 1][1];
        case 5:
          return months[w.m - 1][0];
        default:
          return months[w.m - 1][2];
      }
      break;
    case 100:
      switch (x.length) {
        case 1:
        case 2:
          G = w.d, Y = x.length;
          break;
        case 3:
          return days[w.q][0];
        default:
          return days[w.q][1];
      }
      break;
    case 104:
      switch (x.length) {
        case 1:
        case 2:
          G = 1 + (w.H + 11) % 12, Y = x.length;
          break;
        default:
          throw "bad hour format: " + x;
      }
      break;
    case 72:
      switch (x.length) {
        case 1:
        case 2:
          G = w.H, Y = x.length;
          break;
        default:
          throw "bad hour format: " + x;
      }
      break;
    case 77:
      switch (x.length) {
        case 1:
        case 2:
          G = w.M, Y = x.length;
          break;
        default:
          throw "bad minute format: " + x;
      }
      break;
    case 115:
      if (x != "s" && x != "ss" && x != ".0" && x != ".00" && x != ".000") throw "bad second format: " + x;
      return w.u === 0 && (x == "s" || x == "ss") ? pad0(w.S, x.length) : (O >= 2 ? W = O === 3 ? 1e3 : 100 : W = O === 1 ? 10 : 1, U = Math.round(W * (w.S + w.u)), U >= 60 * W && (U = 0), x === "s" ? U === 0 ? "0" : "" + U / W : (D = pad0(U, 2 + O), x === "ss" ? D.substr(0, 2) : "." + D.substr(2, x.length - 1)));
    case 90:
      switch (x) {
        case "[h]":
        case "[hh]":
          G = w.D * 24 + w.H;
          break;
        case "[m]":
        case "[mm]":
          G = (w.D * 24 + w.H) * 60 + w.M;
          break;
        case "[s]":
        case "[ss]":
          G = ((w.D * 24 + w.H) * 60 + w.M) * 60 + (O == 0 ? Math.round(w.S + w.u) : w.S);
          break;
        default:
          throw "bad abstime format: " + x;
      }
      Y = x.length === 3 ? 1 : 2;
      break;
    case 101:
      G = X, Y = 1;
      break;
  }
  var K = Y > 0 ? pad0(G, Y) : "";
  return K;
}
function commaify(F) {
  var x = 3;
  if (F.length <= x) return F;
  for (var w = F.length % x, O = F.substr(0, w); w != F.length; w += x) O += (O.length > 0 ? "," : "") + F.substr(w, x);
  return O;
}
var pct1 = /%/g;
function write_num_pct(F, x, w) {
  var O = x.replace(pct1, ""), D = x.length - O.length;
  return write_num(F, O, w * Math.pow(10, 2 * D)) + fill("%", D);
}
function write_num_cm(F, x, w) {
  for (var O = x.length - 1; x.charCodeAt(O - 1) === 44; ) --O;
  return write_num(F, x.substr(0, O), w / Math.pow(10, 3 * (x.length - O)));
}
function write_num_exp(F, x) {
  var w, O = F.indexOf("E") - F.indexOf(".") - 1;
  if (F.match(/^#+0.0E\+0$/)) {
    if (x == 0) return "0.0E+0";
    if (x < 0) return "-" + write_num_exp(F, -x);
    var D = F.indexOf(".");
    D === -1 && (D = F.indexOf("E"));
    var U = Math.floor(Math.log(x) * Math.LOG10E) % D;
    if (U < 0 && (U += D), w = (x / Math.pow(10, U)).toPrecision(O + 1 + (D + U) % D), w.indexOf("e") === -1) {
      var W = Math.floor(Math.log(x) * Math.LOG10E);
      for (w.indexOf(".") === -1 ? w = w.charAt(0) + "." + w.substr(1) + "E+" + (W - w.length + U) : w += "E+" + (W - U); w.substr(0, 2) === "0."; )
        w = w.charAt(0) + w.substr(2, D) + "." + w.substr(2 + D), w = w.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
      w = w.replace(/\+-/, "-");
    }
    w = w.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(X, G, Y, K) {
      return G + Y + K.substr(0, (D + U) % D) + "." + K.substr(U) + "E";
    });
  } else w = x.toExponential(O);
  return F.match(/E\+00$/) && w.match(/e[+-]\d$/) && (w = w.substr(0, w.length - 1) + "0" + w.charAt(w.length - 1)), F.match(/E\-/) && w.match(/e\+/) && (w = w.replace(/e\+/, "e")), w.replace("e", "E");
}
var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
function write_num_f1(F, x, w) {
  var O = parseInt(F[4], 10), D = Math.round(x * O), U = Math.floor(D / O), W = D - U * O, X = O;
  return w + (U === 0 ? "" : "" + U) + " " + (W === 0 ? fill(" ", F[1].length + 1 + F[4].length) : pad_(W, F[1].length) + F[2] + "/" + F[3] + pad0(X, F[4].length));
}
function write_num_f2(F, x, w) {
  return w + (x === 0 ? "" : "" + x) + fill(" ", F[1].length + 2 + F[4].length);
}
var dec1 = /^#*0*\.([0#]+)/, closeparen = /\)[^)]*[0#]/, phone = /\(###\) ###\\?-####/;
function hashq(F) {
  for (var x = "", w, O = 0; O != F.length; ++O) switch (w = F.charCodeAt(O)) {
    case 35:
      break;
    case 63:
      x += " ";
      break;
    case 48:
      x += "0";
      break;
    default:
      x += String.fromCharCode(w);
  }
  return x;
}
function rnd(F, x) {
  var w = Math.pow(10, x);
  return "" + Math.round(F * w) / w;
}
function dec(F, x) {
  var w = F - Math.floor(F), O = Math.pow(10, x);
  return x < ("" + Math.round(w * O)).length ? 0 : Math.round(w * O);
}
function carry(F, x) {
  return x < ("" + Math.round((F - Math.floor(F)) * Math.pow(10, x))).length ? 1 : 0;
}
function flr(F) {
  return F < 2147483647 && F > -2147483648 ? "" + (F >= 0 ? F | 0 : F - 1 | 0) : "" + Math.floor(F);
}
function write_num_flt(F, x, w) {
  if (F.charCodeAt(0) === 40 && !x.match(closeparen)) {
    var O = x.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    return w >= 0 ? write_num_flt("n", O, w) : "(" + write_num_flt("n", O, -w) + ")";
  }
  if (x.charCodeAt(x.length - 1) === 44) return write_num_cm(F, x, w);
  if (x.indexOf("%") !== -1) return write_num_pct(F, x, w);
  if (x.indexOf("E") !== -1) return write_num_exp(x, w);
  if (x.charCodeAt(0) === 36) return "$" + write_num_flt(F, x.substr(x.charAt(1) == " " ? 2 : 1), w);
  var D, U, W, X, G = Math.abs(w), Y = w < 0 ? "-" : "";
  if (x.match(/^00+$/)) return Y + pad0r(G, x.length);
  if (x.match(/^[#?]+$/))
    return D = pad0r(w, 0), D === "0" && (D = ""), D.length > x.length ? D : hashq(x.substr(0, x.length - D.length)) + D;
  if (U = x.match(frac1)) return write_num_f1(U, G, Y);
  if (x.match(/^#+0+$/)) return Y + pad0r(G, x.length - x.indexOf("0"));
  if (U = x.match(dec1))
    return D = rnd(w, U[1].length).replace(/^([^\.]+)$/, "$1." + hashq(U[1])).replace(/\.$/, "." + hashq(U[1])).replace(/\.(\d*)$/, function(ee, re) {
      return "." + re + fill("0", hashq(
        /*::(*/
        U[1]
      ).length - re.length);
    }), x.indexOf("0.") !== -1 ? D : D.replace(/^0\./, ".");
  if (x = x.replace(/^#+([0.])/, "$1"), U = x.match(/^(0*)\.(#*)$/))
    return Y + rnd(G, U[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, U[1].length ? "0." : ".");
  if (U = x.match(/^#{1,3},##0(\.?)$/)) return Y + commaify(pad0r(G, 0));
  if (U = x.match(/^#,##0\.([#0]*0)$/))
    return w < 0 ? "-" + write_num_flt(F, x, -w) : commaify("" + (Math.floor(w) + carry(w, U[1].length))) + "." + pad0(dec(w, U[1].length), U[1].length);
  if (U = x.match(/^#,#*,#0/)) return write_num_flt(F, x.replace(/^#,#*,/, ""), w);
  if (U = x.match(/^([0#]+)(\\?-([0#]+))+$/))
    return D = _strrev(write_num_flt(F, x.replace(/[\\-]/g, ""), w)), W = 0, _strrev(_strrev(x.replace(/\\/g, "")).replace(/[0#]/g, function(ee) {
      return W < D.length ? D.charAt(W++) : ee === "0" ? "0" : "";
    }));
  if (x.match(phone))
    return D = write_num_flt(F, "##########", w), "(" + D.substr(0, 3) + ") " + D.substr(3, 3) + "-" + D.substr(6);
  var K = "";
  if (U = x.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))
    return W = Math.min(
      /*::String(*/
      U[4].length,
      7
    ), X = SSF_frac(G, Math.pow(10, W) - 1, !1), D = "" + Y, K = write_num(
      "n",
      /*::String(*/
      U[1],
      X[1]
    ), K.charAt(K.length - 1) == " " && (K = K.substr(0, K.length - 1) + "0"), D += K + /*::String(*/
    U[2] + "/" + /*::String(*/
    U[3], K = rpad_(X[2], W), K.length < U[4].length && (K = hashq(U[4].substr(U[4].length - K.length)) + K), D += K, D;
  if (U = x.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))
    return W = Math.min(Math.max(U[1].length, U[4].length), 7), X = SSF_frac(G, Math.pow(10, W) - 1, !0), Y + (X[0] || (X[1] ? "" : "0")) + " " + (X[1] ? pad_(X[1], W) + U[2] + "/" + U[3] + rpad_(X[2], W) : fill(" ", 2 * W + 1 + U[2].length + U[3].length));
  if (U = x.match(/^[#0?]+$/))
    return D = pad0r(w, 0), x.length <= D.length ? D : hashq(x.substr(0, x.length - D.length)) + D;
  if (U = x.match(/^([#0?]+)\.([#0]+)$/)) {
    D = "" + w.toFixed(Math.min(U[2].length, 10)).replace(/([^0])0+$/, "$1"), W = D.indexOf(".");
    var Z = x.indexOf(".") - W, q = x.length - D.length - Z;
    return hashq(x.substr(0, Z) + D + x.substr(x.length - q));
  }
  if (U = x.match(/^00,000\.([#0]*0)$/))
    return W = dec(w, U[1].length), w < 0 ? "-" + write_num_flt(F, x, -w) : commaify(flr(w)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(ee) {
      return "00," + (ee.length < 3 ? pad0(0, 3 - ee.length) : "") + ee;
    }) + "." + pad0(W, U[1].length);
  switch (x) {
    case "###,##0.00":
      return write_num_flt(F, "#,##0.00", w);
    case "###,###":
    case "##,###":
    case "#,###":
      var J = commaify(pad0r(G, 0));
      return J !== "0" ? Y + J : "";
    case "###,###.00":
      return write_num_flt(F, "###,##0.00", w).replace(/^0\./, ".");
    case "#,###.00":
      return write_num_flt(F, "#,##0.00", w).replace(/^0\./, ".");
  }
  throw new Error("unsupported format |" + x + "|");
}
function write_num_cm2(F, x, w) {
  for (var O = x.length - 1; x.charCodeAt(O - 1) === 44; ) --O;
  return write_num(F, x.substr(0, O), w / Math.pow(10, 3 * (x.length - O)));
}
function write_num_pct2(F, x, w) {
  var O = x.replace(pct1, ""), D = x.length - O.length;
  return write_num(F, O, w * Math.pow(10, 2 * D)) + fill("%", D);
}
function write_num_exp2(F, x) {
  var w, O = F.indexOf("E") - F.indexOf(".") - 1;
  if (F.match(/^#+0.0E\+0$/)) {
    if (x == 0) return "0.0E+0";
    if (x < 0) return "-" + write_num_exp2(F, -x);
    var D = F.indexOf(".");
    D === -1 && (D = F.indexOf("E"));
    var U = Math.floor(Math.log(x) * Math.LOG10E) % D;
    if (U < 0 && (U += D), w = (x / Math.pow(10, U)).toPrecision(O + 1 + (D + U) % D), !w.match(/[Ee]/)) {
      var W = Math.floor(Math.log(x) * Math.LOG10E);
      w.indexOf(".") === -1 ? w = w.charAt(0) + "." + w.substr(1) + "E+" + (W - w.length + U) : w += "E+" + (W - U), w = w.replace(/\+-/, "-");
    }
    w = w.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(X, G, Y, K) {
      return G + Y + K.substr(0, (D + U) % D) + "." + K.substr(U) + "E";
    });
  } else w = x.toExponential(O);
  return F.match(/E\+00$/) && w.match(/e[+-]\d$/) && (w = w.substr(0, w.length - 1) + "0" + w.charAt(w.length - 1)), F.match(/E\-/) && w.match(/e\+/) && (w = w.replace(/e\+/, "e")), w.replace("e", "E");
}
function write_num_int(F, x, w) {
  if (F.charCodeAt(0) === 40 && !x.match(closeparen)) {
    var O = x.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    return w >= 0 ? write_num_int("n", O, w) : "(" + write_num_int("n", O, -w) + ")";
  }
  if (x.charCodeAt(x.length - 1) === 44) return write_num_cm2(F, x, w);
  if (x.indexOf("%") !== -1) return write_num_pct2(F, x, w);
  if (x.indexOf("E") !== -1) return write_num_exp2(x, w);
  if (x.charCodeAt(0) === 36) return "$" + write_num_int(F, x.substr(x.charAt(1) == " " ? 2 : 1), w);
  var D, U, W, X, G = Math.abs(w), Y = w < 0 ? "-" : "";
  if (x.match(/^00+$/)) return Y + pad0(G, x.length);
  if (x.match(/^[#?]+$/))
    return D = "" + w, w === 0 && (D = ""), D.length > x.length ? D : hashq(x.substr(0, x.length - D.length)) + D;
  if (U = x.match(frac1)) return write_num_f2(U, G, Y);
  if (x.match(/^#+0+$/)) return Y + pad0(G, x.length - x.indexOf("0"));
  if (U = x.match(dec1))
    return D = ("" + w).replace(/^([^\.]+)$/, "$1." + hashq(U[1])).replace(/\.$/, "." + hashq(U[1])), D = D.replace(/\.(\d*)$/, function(ee, re) {
      return "." + re + fill("0", hashq(U[1]).length - re.length);
    }), x.indexOf("0.") !== -1 ? D : D.replace(/^0\./, ".");
  if (x = x.replace(/^#+([0.])/, "$1"), U = x.match(/^(0*)\.(#*)$/))
    return Y + ("" + G).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, U[1].length ? "0." : ".");
  if (U = x.match(/^#{1,3},##0(\.?)$/)) return Y + commaify("" + G);
  if (U = x.match(/^#,##0\.([#0]*0)$/))
    return w < 0 ? "-" + write_num_int(F, x, -w) : commaify("" + w) + "." + fill("0", U[1].length);
  if (U = x.match(/^#,#*,#0/)) return write_num_int(F, x.replace(/^#,#*,/, ""), w);
  if (U = x.match(/^([0#]+)(\\?-([0#]+))+$/))
    return D = _strrev(write_num_int(F, x.replace(/[\\-]/g, ""), w)), W = 0, _strrev(_strrev(x.replace(/\\/g, "")).replace(/[0#]/g, function(ee) {
      return W < D.length ? D.charAt(W++) : ee === "0" ? "0" : "";
    }));
  if (x.match(phone))
    return D = write_num_int(F, "##########", w), "(" + D.substr(0, 3) + ") " + D.substr(3, 3) + "-" + D.substr(6);
  var K = "";
  if (U = x.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))
    return W = Math.min(
      /*::String(*/
      U[4].length,
      7
    ), X = SSF_frac(G, Math.pow(10, W) - 1, !1), D = "" + Y, K = write_num(
      "n",
      /*::String(*/
      U[1],
      X[1]
    ), K.charAt(K.length - 1) == " " && (K = K.substr(0, K.length - 1) + "0"), D += K + /*::String(*/
    U[2] + "/" + /*::String(*/
    U[3], K = rpad_(X[2], W), K.length < U[4].length && (K = hashq(U[4].substr(U[4].length - K.length)) + K), D += K, D;
  if (U = x.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))
    return W = Math.min(Math.max(U[1].length, U[4].length), 7), X = SSF_frac(G, Math.pow(10, W) - 1, !0), Y + (X[0] || (X[1] ? "" : "0")) + " " + (X[1] ? pad_(X[1], W) + U[2] + "/" + U[3] + rpad_(X[2], W) : fill(" ", 2 * W + 1 + U[2].length + U[3].length));
  if (U = x.match(/^[#0?]+$/))
    return D = "" + w, x.length <= D.length ? D : hashq(x.substr(0, x.length - D.length)) + D;
  if (U = x.match(/^([#0]+)\.([#0]+)$/)) {
    D = "" + w.toFixed(Math.min(U[2].length, 10)).replace(/([^0])0+$/, "$1"), W = D.indexOf(".");
    var Z = x.indexOf(".") - W, q = x.length - D.length - Z;
    return hashq(x.substr(0, Z) + D + x.substr(x.length - q));
  }
  if (U = x.match(/^00,000\.([#0]*0)$/))
    return w < 0 ? "-" + write_num_int(F, x, -w) : commaify("" + w).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(ee) {
      return "00," + (ee.length < 3 ? pad0(0, 3 - ee.length) : "") + ee;
    }) + "." + pad0(0, U[1].length);
  switch (x) {
    case "###,###":
    case "##,###":
    case "#,###":
      var J = commaify("" + G);
      return J !== "0" ? Y + J : "";
    default:
      if (x.match(/\.[0#?]*$/)) return write_num_int(F, x.slice(0, x.lastIndexOf(".")), w) + hashq(x.slice(x.lastIndexOf(".")));
  }
  throw new Error("unsupported format |" + x + "|");
}
function write_num(F, x, w) {
  return (w | 0) === w ? write_num_int(F, x, w) : write_num_flt(F, x, w);
}
function SSF_split_fmt(F) {
  for (var x = [], w = !1, O = 0, D = 0; O < F.length; ++O) switch (
    /*cc=*/
    F.charCodeAt(O)
  ) {
    case 34:
      w = !w;
      break;
    case 95:
    case 42:
    case 92:
      ++O;
      break;
    case 59:
      x[x.length] = F.substr(D, O - D), D = O + 1;
  }
  if (x[x.length] = F.substr(D), w === !0) throw new Error("Format |" + F + "| unterminated string ");
  return x;
}
var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
function fmt_is_date(F) {
  for (var x = 0, w = "", O = ""; x < F.length; )
    switch (w = F.charAt(x)) {
      case "G":
        SSF_isgeneral(F, x) && (x += 6), x++;
        break;
      case '"':
        for (
          ;
          /*cc=*/
          F.charCodeAt(++x) !== 34 && x < F.length;
        )
          ;
        ++x;
        break;
      case "\\":
        x += 2;
        break;
      case "_":
        x += 2;
        break;
      case "@":
        ++x;
        break;
      case "B":
      case "b":
        if (F.charAt(x + 1) === "1" || F.charAt(x + 1) === "2") return !0;
      /* falls through */
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
      /* falls through */
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        return !0;
      case "A":
      case "a":
      case "上":
        if (F.substr(x, 3).toUpperCase() === "A/P" || F.substr(x, 5).toUpperCase() === "AM/PM" || F.substr(x, 5).toUpperCase() === "上午/下午") return !0;
        ++x;
        break;
      case "[":
        for (O = w; F.charAt(x++) !== "]" && x < F.length; ) O += F.charAt(x);
        if (O.match(SSF_abstime)) return !0;
        break;
      case ".":
      /* falls through */
      case "0":
      case "#":
        for (; x < F.length && ("0#?.,E+-%".indexOf(w = F.charAt(++x)) > -1 || w == "\\" && F.charAt(x + 1) == "-" && "0#".indexOf(F.charAt(x + 2)) > -1); )
          ;
        break;
      case "?":
        for (; F.charAt(++x) === w; )
          ;
        break;
      case "*":
        ++x, (F.charAt(x) == " " || F.charAt(x) == "*") && ++x;
        break;
      case "(":
      case ")":
        ++x;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        for (; x < F.length && "0123456789".indexOf(F.charAt(++x)) > -1; )
          ;
        break;
      case " ":
        ++x;
        break;
      default:
        ++x;
        break;
    }
  return !1;
}
function eval_fmt(F, x, w, O) {
  for (var D = [], U = "", W = 0, X = "", G = "t", Y, K, Z, q = "H"; W < F.length; )
    switch (X = F.charAt(W)) {
      case "G":
        if (!SSF_isgeneral(F, W)) throw new Error("unrecognized character " + X + " in " + F);
        D[D.length] = { t: "G", v: "General" }, W += 7;
        break;
      case '"':
        for (U = ""; (Z = F.charCodeAt(++W)) !== 34 && W < F.length; ) U += String.fromCharCode(Z);
        D[D.length] = { t: "t", v: U }, ++W;
        break;
      case "\\":
        var J = F.charAt(++W), ee = J === "(" || J === ")" ? J : "t";
        D[D.length] = { t: ee, v: J }, ++W;
        break;
      case "_":
        D[D.length] = { t: "t", v: " " }, W += 2;
        break;
      case "@":
        D[D.length] = { t: "T", v: x }, ++W;
        break;
      case "B":
      case "b":
        if (F.charAt(W + 1) === "1" || F.charAt(W + 1) === "2") {
          if (Y == null && (Y = SSF_parse_date_code(x, w, F.charAt(W + 1) === "2"), Y == null))
            return "";
          D[D.length] = { t: "X", v: F.substr(W, 2) }, G = X, W += 2;
          break;
        }
      /* falls through */
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
        X = X.toLowerCase();
      /* falls through */
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        if (x < 0 || Y == null && (Y = SSF_parse_date_code(x, w), Y == null))
          return "";
        for (U = X; ++W < F.length && F.charAt(W).toLowerCase() === X; ) U += X;
        X === "m" && G.toLowerCase() === "h" && (X = "M"), X === "h" && (X = q), D[D.length] = { t: X, v: U }, G = X;
        break;
      case "A":
      case "a":
      case "上":
        var re = { t: X, v: X };
        if (Y == null && (Y = SSF_parse_date_code(x, w)), F.substr(W, 3).toUpperCase() === "A/P" ? (Y != null && (re.v = Y.H >= 12 ? F.charAt(W + 2) : X), re.t = "T", q = "h", W += 3) : F.substr(W, 5).toUpperCase() === "AM/PM" ? (Y != null && (re.v = Y.H >= 12 ? "PM" : "AM"), re.t = "T", W += 5, q = "h") : F.substr(W, 5).toUpperCase() === "上午/下午" ? (Y != null && (re.v = Y.H >= 12 ? "下午" : "上午"), re.t = "T", W += 5, q = "h") : (re.t = "t", ++W), Y == null && re.t === "T") return "";
        D[D.length] = re, G = X;
        break;
      case "[":
        for (U = X; F.charAt(W++) !== "]" && W < F.length; ) U += F.charAt(W);
        if (U.slice(-1) !== "]") throw 'unterminated "[" block: |' + U + "|";
        if (U.match(SSF_abstime)) {
          if (Y == null && (Y = SSF_parse_date_code(x, w), Y == null))
            return "";
          D[D.length] = { t: "Z", v: U.toLowerCase() }, G = U.charAt(1);
        } else U.indexOf("$") > -1 && (U = (U.match(/\$([^-\[\]]*)/) || [])[1] || "$", fmt_is_date(F) || (D[D.length] = { t: "t", v: U }));
        break;
      /* Numbers */
      case ".":
        if (Y != null) {
          for (U = X; ++W < F.length && (X = F.charAt(W)) === "0"; ) U += X;
          D[D.length] = { t: "s", v: U };
          break;
        }
      /* falls through */
      case "0":
      case "#":
        for (U = X; ++W < F.length && "0#?.,E+-%".indexOf(X = F.charAt(W)) > -1; ) U += X;
        D[D.length] = { t: "n", v: U };
        break;
      case "?":
        for (U = X; F.charAt(++W) === X; ) U += X;
        D[D.length] = { t: X, v: U }, G = X;
        break;
      case "*":
        ++W, (F.charAt(W) == " " || F.charAt(W) == "*") && ++W;
        break;
      // **
      case "(":
      case ")":
        D[D.length] = { t: O === 1 ? "t" : X, v: X }, ++W;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        for (U = X; W < F.length && "0123456789".indexOf(F.charAt(++W)) > -1; ) U += F.charAt(W);
        D[D.length] = { t: "D", v: U };
        break;
      case " ":
        D[D.length] = { t: X, v: X }, ++W;
        break;
      case "$":
        D[D.length] = { t: "t", v: "$" }, ++W;
        break;
      default:
        if (",$-+/():!^&'~{}<>=€acfijklopqrtuvwxzP".indexOf(X) === -1) throw new Error("unrecognized character " + X + " in " + F);
        D[D.length] = { t: "t", v: X }, ++W;
        break;
    }
  var te = 0, Q = 0, oe;
  for (W = D.length - 1, G = "t"; W >= 0; --W)
    switch (D[W].t) {
      case "h":
      case "H":
        D[W].t = q, G = "h", te < 1 && (te = 1);
        break;
      case "s":
        (oe = D[W].v.match(/\.0+$/)) && (Q = Math.max(Q, oe[0].length - 1), te = 4), te < 3 && (te = 3);
      /* falls through */
      case "d":
      case "y":
      case "e":
        G = D[W].t;
        break;
      case "M":
        G = D[W].t, te < 2 && (te = 2);
        break;
      case "m":
        G === "s" && (D[W].t = "M", te < 2 && (te = 2));
        break;
      case "X":
        break;
      case "Z":
        te < 1 && D[W].v.match(/[Hh]/) && (te = 1), te < 2 && D[W].v.match(/[Mm]/) && (te = 2), te < 3 && D[W].v.match(/[Ss]/) && (te = 3);
    }
  var ne;
  switch (te) {
    case 0:
      break;
    case 1:
    case 2:
    case 3:
      Y.u >= 0.5 && (Y.u = 0, ++Y.S), Y.S >= 60 && (Y.S = 0, ++Y.M), Y.M >= 60 && (Y.M = 0, ++Y.H), Y.H >= 24 && (Y.H = 0, ++Y.D, ne = SSF_parse_date_code(Y.D), ne.u = Y.u, ne.S = Y.S, ne.M = Y.M, ne.H = Y.H, Y = ne);
      break;
    case 4:
      switch (Q) {
        case 1:
          Y.u = Math.round(Y.u * 10) / 10;
          break;
        case 2:
          Y.u = Math.round(Y.u * 100) / 100;
          break;
        case 3:
          Y.u = Math.round(Y.u * 1e3) / 1e3;
          break;
      }
      Y.u >= 1 && (Y.u = 0, ++Y.S), Y.S >= 60 && (Y.S = 0, ++Y.M), Y.M >= 60 && (Y.M = 0, ++Y.H), Y.H >= 24 && (Y.H = 0, ++Y.D, ne = SSF_parse_date_code(Y.D), ne.u = Y.u, ne.S = Y.S, ne.M = Y.M, ne.H = Y.H, Y = ne);
      break;
  }
  var le = "", Ee;
  for (W = 0; W < D.length; ++W)
    switch (D[W].t) {
      case "t":
      case "T":
      case " ":
      case "D":
        break;
      case "X":
        D[W].v = "", D[W].t = ";";
        break;
      case "d":
      case "m":
      case "y":
      case "h":
      case "H":
      case "M":
      case "s":
      case "e":
      case "b":
      case "Z":
        D[W].v = SSF_write_date(D[W].t.charCodeAt(0), D[W].v, Y, Q), D[W].t = "t";
        break;
      case "n":
      case "?":
        for (Ee = W + 1; D[Ee] != null && ((X = D[Ee].t) === "?" || X === "D" || (X === " " || X === "t") && D[Ee + 1] != null && (D[Ee + 1].t === "?" || D[Ee + 1].t === "t" && D[Ee + 1].v === "/") || D[W].t === "(" && (X === " " || X === "n" || X === ")") || X === "t" && (D[Ee].v === "/" || D[Ee].v === " " && D[Ee + 1] != null && D[Ee + 1].t == "?")); )
          D[W].v += D[Ee].v, D[Ee] = { v: "", t: ";" }, ++Ee;
        le += D[W].v, W = Ee - 1;
        break;
      case "G":
        D[W].t = "t", D[W].v = SSF_general(x, w);
        break;
    }
  var Te = "", de, ae;
  if (le.length > 0) {
    le.charCodeAt(0) == 40 ? (de = x < 0 && le.charCodeAt(0) === 45 ? -x : x, ae = write_num("n", le, de)) : (de = x < 0 && O > 1 ? -x : x, ae = write_num("n", le, de), de < 0 && D[0] && D[0].t == "t" && (ae = ae.substr(1), D[0].v = "-" + D[0].v)), Ee = ae.length - 1;
    var se = D.length;
    for (W = 0; W < D.length; ++W) if (D[W] != null && D[W].t != "t" && D[W].v.indexOf(".") > -1) {
      se = W;
      break;
    }
    var ce = D.length;
    if (se === D.length && ae.indexOf("E") === -1) {
      for (W = D.length - 1; W >= 0; --W)
        D[W] == null || "n?".indexOf(D[W].t) === -1 || (Ee >= D[W].v.length - 1 ? (Ee -= D[W].v.length, D[W].v = ae.substr(Ee + 1, D[W].v.length)) : Ee < 0 ? D[W].v = "" : (D[W].v = ae.substr(0, Ee + 1), Ee = -1), D[W].t = "t", ce = W);
      Ee >= 0 && ce < D.length && (D[ce].v = ae.substr(0, Ee + 1) + D[ce].v);
    } else if (se !== D.length && ae.indexOf("E") === -1) {
      for (Ee = ae.indexOf(".") - 1, W = se; W >= 0; --W)
        if (!(D[W] == null || "n?".indexOf(D[W].t) === -1)) {
          for (K = D[W].v.indexOf(".") > -1 && W === se ? D[W].v.indexOf(".") - 1 : D[W].v.length - 1, Te = D[W].v.substr(K + 1); K >= 0; --K)
            Ee >= 0 && (D[W].v.charAt(K) === "0" || D[W].v.charAt(K) === "#") && (Te = ae.charAt(Ee--) + Te);
          D[W].v = Te, D[W].t = "t", ce = W;
        }
      for (Ee >= 0 && ce < D.length && (D[ce].v = ae.substr(0, Ee + 1) + D[ce].v), Ee = ae.indexOf(".") + 1, W = se; W < D.length; ++W)
        if (!(D[W] == null || "n?(".indexOf(D[W].t) === -1 && W !== se)) {
          for (K = D[W].v.indexOf(".") > -1 && W === se ? D[W].v.indexOf(".") + 1 : 0, Te = D[W].v.substr(0, K); K < D[W].v.length; ++K)
            Ee < ae.length && (Te += ae.charAt(Ee++));
          D[W].v = Te, D[W].t = "t", ce = W;
        }
    }
  }
  for (W = 0; W < D.length; ++W) D[W] != null && "n?".indexOf(D[W].t) > -1 && (de = O > 1 && x < 0 && W > 0 && D[W - 1].v === "-" ? -x : x, D[W].v = write_num(D[W].t, D[W].v, de), D[W].t = "t");
  var xe = "";
  for (W = 0; W !== D.length; ++W) D[W] != null && (xe += D[W].v);
  return xe;
}
var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
function chkcond(F, x) {
  if (x == null) return !1;
  var w = parseFloat(x[2]);
  switch (x[1]) {
    case "=":
      if (F == w) return !0;
      break;
    case ">":
      if (F > w) return !0;
      break;
    case "<":
      if (F < w) return !0;
      break;
    case "<>":
      if (F != w) return !0;
      break;
    case ">=":
      if (F >= w) return !0;
      break;
    case "<=":
      if (F <= w) return !0;
      break;
  }
  return !1;
}
function choose_fmt(F, x) {
  var w = SSF_split_fmt(F), O = w.length, D = w[O - 1].indexOf("@");
  if (O < 4 && D > -1 && --O, w.length > 4) throw new Error("cannot find right format for |" + w.join("|") + "|");
  if (typeof x != "number") return [4, w.length === 4 || D > -1 ? w[w.length - 1] : "@"];
  switch (typeof x == "number" && !isFinite(x) && (x = 0), w.length) {
    case 1:
      w = D > -1 ? ["General", "General", "General", w[0]] : [w[0], w[0], w[0], "@"];
      break;
    case 2:
      w = D > -1 ? [w[0], w[0], w[0], w[1]] : [w[0], w[1], w[0], "@"];
      break;
    case 3:
      w = D > -1 ? [w[0], w[1], w[0], w[2]] : [w[0], w[1], w[2], "@"];
      break;
  }
  var U = x > 0 ? w[0] : x < 0 ? w[1] : w[2];
  if (w[0].indexOf("[") === -1 && w[1].indexOf("[") === -1) return [O, U];
  if (w[0].match(/\[[=<>]/) != null || w[1].match(/\[[=<>]/) != null) {
    var W = w[0].match(cfregex2), X = w[1].match(cfregex2);
    return chkcond(x, W) ? [O, w[0]] : chkcond(x, X) ? [O, w[1]] : [O, w[W != null && X != null ? 2 : 1]];
  }
  return [O, U];
}
function SSF_format(F, x, w) {
  w == null && (w = {});
  var O = "";
  switch (typeof F) {
    case "string":
      F == "m/d/yy" && w.dateNF ? O = w.dateNF : O = F;
      break;
    case "number":
      F == 14 && w.dateNF ? O = w.dateNF : O = (w.table != null ? w.table : table_fmt)[F], O == null && (O = w.table && w.table[SSF_default_map[F]] || table_fmt[SSF_default_map[F]]), O == null && (O = SSF_default_str[F] || "General");
      break;
  }
  if (SSF_isgeneral(O, 0)) return SSF_general(x, w);
  x instanceof Date && (x = datenum(x, w.date1904));
  var D = choose_fmt(O, x);
  if (SSF_isgeneral(D[1])) return SSF_general(x, w);
  if (x === !0) x = "TRUE";
  else if (x === !1) x = "FALSE";
  else {
    if (x === "" || x == null) return "";
    if (isNaN(x) && D[1].indexOf("0") > -1) return "#NUM!";
    if (!isFinite(x) && D[1].indexOf("0") > -1) return "#DIV/0!";
  }
  return eval_fmt(D[1], x, w, D[0]);
}
function SSF_load(F, x) {
  if (typeof x != "number") {
    x = +x || -1;
    for (var w = 0; w < 392; ++w) {
      if (table_fmt[w] == null) {
        x < 0 && (x = w);
        continue;
      }
      if (table_fmt[w] == F) {
        x = w;
        break;
      }
    }
    x < 0 && (x = 391);
  }
  return table_fmt[x] = F, x;
}
function SSF_load_table(F) {
  for (var x = 0; x != 392; ++x)
    F[x] !== void 0 && SSF_load(F[x], x);
}
function make_ssf() {
  table_fmt = SSF_init_table();
}
var SSF = {
  format: SSF_format,
  load: SSF_load,
  _table: table_fmt,
  load_table: SSF_load_table,
  parse_date_code: SSF_parse_date_code,
  is_date: fmt_is_date,
  get_table: function F() {
    return SSF._table = table_fmt;
  }
}, SSFImplicit = {
  5: '"$"#,##0_);\\("$"#,##0\\)',
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  23: "General",
  24: "General",
  25: "General",
  26: "General",
  27: "m/d/yy",
  28: "m/d/yy",
  29: "m/d/yy",
  30: "m/d/yy",
  31: "m/d/yy",
  32: "h:mm:ss",
  33: "h:mm:ss",
  34: "h:mm:ss",
  35: "h:mm:ss",
  36: "m/d/yy",
  41: '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
  42: '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
  43: '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
  44: '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
  50: "m/d/yy",
  51: "m/d/yy",
  52: "m/d/yy",
  53: "m/d/yy",
  54: "m/d/yy",
  55: "m/d/yy",
  56: "m/d/yy",
  57: "m/d/yy",
  58: "m/d/yy",
  59: "0",
  60: "0.00",
  61: "#,##0",
  62: "#,##0.00",
  63: '"$"#,##0_);\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  67: "0%",
  68: "0.00%",
  69: "# ?/?",
  70: "# ??/??",
  71: "m/d/yy",
  72: "m/d/yy",
  73: "d-mmm-yy",
  74: "d-mmm",
  75: "mmm-yy",
  76: "h:mm",
  77: "h:mm:ss",
  78: "m/d/yy h:mm",
  79: "mm:ss",
  80: "[h]:mm:ss",
  81: "mmss.0"
}, dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
function dateNF_regex(F) {
  var x = typeof F == "number" ? table_fmt[F] : F;
  return x = x.replace(dateNFregex, "(\\d+)"), dateNFregex.lastIndex = 0, new RegExp("^" + x + "$");
}
function dateNF_fix(F, x, w) {
  var O = -1, D = -1, U = -1, W = -1, X = -1, G = -1;
  (x.match(dateNFregex) || []).forEach(function(Z, q) {
    var J = parseInt(w[q + 1], 10);
    switch (Z.toLowerCase().charAt(0)) {
      case "y":
        O = J;
        break;
      case "d":
        U = J;
        break;
      case "h":
        W = J;
        break;
      case "s":
        G = J;
        break;
      case "m":
        W >= 0 ? X = J : D = J;
        break;
    }
  }), dateNFregex.lastIndex = 0, G >= 0 && X == -1 && D >= 0 && (X = D, D = -1);
  var Y = ("" + (O >= 0 ? O : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (D >= 1 ? D : 1)).slice(-2) + "-" + ("00" + (U >= 1 ? U : 1)).slice(-2);
  Y.length == 7 && (Y = "0" + Y), Y.length == 8 && (Y = "20" + Y);
  var K = ("00" + (W >= 0 ? W : 0)).slice(-2) + ":" + ("00" + (X >= 0 ? X : 0)).slice(-2) + ":" + ("00" + (G >= 0 ? G : 0)).slice(-2);
  return W == -1 && X == -1 && G == -1 ? Y : O == -1 && D == -1 && U == -1 ? K : Y + "T" + K;
}
var bad_formats = {
  "d.m": "d\\.m"
  // Issue #2571 Google Sheets writes invalid format 'd.m', correct format is 'd"."m' or 'd\\.m'
};
function SSF__load(F, x) {
  return SSF_load(bad_formats[F] || F, x);
}
var CRC32 = /* @__PURE__ */ function() {
  var F = {};
  F.version = "1.2.0";
  function x() {
    for (var de = 0, ae = new Array(256), se = 0; se != 256; ++se)
      de = se, de = de & 1 ? -306674912 ^ de >>> 1 : de >>> 1, de = de & 1 ? -306674912 ^ de >>> 1 : de >>> 1, de = de & 1 ? -306674912 ^ de >>> 1 : de >>> 1, de = de & 1 ? -306674912 ^ de >>> 1 : de >>> 1, de = de & 1 ? -306674912 ^ de >>> 1 : de >>> 1, de = de & 1 ? -306674912 ^ de >>> 1 : de >>> 1, de = de & 1 ? -306674912 ^ de >>> 1 : de >>> 1, de = de & 1 ? -306674912 ^ de >>> 1 : de >>> 1, ae[se] = de;
    return typeof Int32Array < "u" ? new Int32Array(ae) : ae;
  }
  var w = x();
  function O(de) {
    var ae = 0, se = 0, ce = 0, xe = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
    for (ce = 0; ce != 256; ++ce) xe[ce] = de[ce];
    for (ce = 0; ce != 256; ++ce)
      for (se = de[ce], ae = 256 + ce; ae < 4096; ae += 256) se = xe[ae] = se >>> 8 ^ de[se & 255];
    var Ce = [];
    for (ce = 1; ce != 16; ++ce) Ce[ce - 1] = typeof Int32Array < "u" && typeof xe.subarray == "function" ? xe.subarray(ce * 256, ce * 256 + 256) : xe.slice(ce * 256, ce * 256 + 256);
    return Ce;
  }
  var D = O(w), U = D[0], W = D[1], X = D[2], G = D[3], Y = D[4], K = D[5], Z = D[6], q = D[7], J = D[8], ee = D[9], re = D[10], te = D[11], Q = D[12], oe = D[13], ne = D[14];
  function le(de, ae) {
    for (var se = ae ^ -1, ce = 0, xe = de.length; ce < xe; ) se = se >>> 8 ^ w[(se ^ de.charCodeAt(ce++)) & 255];
    return ~se;
  }
  function Ee(de, ae) {
    for (var se = ae ^ -1, ce = de.length - 15, xe = 0; xe < ce; ) se = ne[de[xe++] ^ se & 255] ^ oe[de[xe++] ^ se >> 8 & 255] ^ Q[de[xe++] ^ se >> 16 & 255] ^ te[de[xe++] ^ se >>> 24] ^ re[de[xe++]] ^ ee[de[xe++]] ^ J[de[xe++]] ^ q[de[xe++]] ^ Z[de[xe++]] ^ K[de[xe++]] ^ Y[de[xe++]] ^ G[de[xe++]] ^ X[de[xe++]] ^ W[de[xe++]] ^ U[de[xe++]] ^ w[de[xe++]];
    for (ce += 15; xe < ce; ) se = se >>> 8 ^ w[(se ^ de[xe++]) & 255];
    return ~se;
  }
  function Te(de, ae) {
    for (var se = ae ^ -1, ce = 0, xe = de.length, Ce = 0, ye = 0; ce < xe; )
      Ce = de.charCodeAt(ce++), Ce < 128 ? se = se >>> 8 ^ w[(se ^ Ce) & 255] : Ce < 2048 ? (se = se >>> 8 ^ w[(se ^ (192 | Ce >> 6 & 31)) & 255], se = se >>> 8 ^ w[(se ^ (128 | Ce & 63)) & 255]) : Ce >= 55296 && Ce < 57344 ? (Ce = (Ce & 1023) + 64, ye = de.charCodeAt(ce++) & 1023, se = se >>> 8 ^ w[(se ^ (240 | Ce >> 8 & 7)) & 255], se = se >>> 8 ^ w[(se ^ (128 | Ce >> 2 & 63)) & 255], se = se >>> 8 ^ w[(se ^ (128 | ye >> 6 & 15 | (Ce & 3) << 4)) & 255], se = se >>> 8 ^ w[(se ^ (128 | ye & 63)) & 255]) : (se = se >>> 8 ^ w[(se ^ (224 | Ce >> 12 & 15)) & 255], se = se >>> 8 ^ w[(se ^ (128 | Ce >> 6 & 63)) & 255], se = se >>> 8 ^ w[(se ^ (128 | Ce & 63)) & 255]);
    return ~se;
  }
  return F.table = w, F.bstr = le, F.buf = Ee, F.str = Te, F;
}(), CFB = /* @__PURE__ */ function F() {
  var x = (
    /*::(*/
    {}
  );
  x.version = "1.2.2";
  function w(ie, ge) {
    for (var he = ie.split("/"), pe = ge.split("/"), _e = 0, ve = 0, Ie = Math.min(he.length, pe.length); _e < Ie; ++_e) {
      if (ve = he[_e].length - pe[_e].length) return ve;
      if (he[_e] != pe[_e]) return he[_e] < pe[_e] ? -1 : 1;
    }
    return he.length - pe.length;
  }
  function O(ie) {
    if (ie.charAt(ie.length - 1) == "/") return ie.slice(0, -1).indexOf("/") === -1 ? ie : O(ie.slice(0, -1));
    var ge = ie.lastIndexOf("/");
    return ge === -1 ? ie : ie.slice(0, ge + 1);
  }
  function D(ie) {
    if (ie.charAt(ie.length - 1) == "/") return D(ie.slice(0, -1));
    var ge = ie.lastIndexOf("/");
    return ge === -1 ? ie : ie.slice(ge + 1);
  }
  function U(ie, ge) {
    typeof ge == "string" && (ge = new Date(ge));
    var he = ge.getHours();
    he = he << 6 | ge.getMinutes(), he = he << 5 | ge.getSeconds() >>> 1, ie.write_shift(2, he);
    var pe = ge.getFullYear() - 1980;
    pe = pe << 4 | ge.getMonth() + 1, pe = pe << 5 | ge.getDate(), ie.write_shift(2, pe);
  }
  function W(ie) {
    var ge = ie.read_shift(2) & 65535, he = ie.read_shift(2) & 65535, pe = /* @__PURE__ */ new Date(), _e = he & 31;
    he >>>= 5;
    var ve = he & 15;
    he >>>= 4, pe.setMilliseconds(0), pe.setFullYear(he + 1980), pe.setMonth(ve - 1), pe.setDate(_e);
    var Ie = ge & 31;
    ge >>>= 5;
    var Ne = ge & 63;
    return ge >>>= 6, pe.setHours(ge), pe.setMinutes(Ne), pe.setSeconds(Ie << 1), pe;
  }
  function X(ie) {
    prep_blob(ie, 0);
    for (var ge = (
      /*::(*/
      {}
    ), he = 0; ie.l <= ie.length - 4; ) {
      var pe = ie.read_shift(2), _e = ie.read_shift(2), ve = ie.l + _e, Ie = {};
      switch (pe) {
        /* UNIX-style Timestamps */
        case 21589:
          he = ie.read_shift(1), he & 1 && (Ie.mtime = ie.read_shift(4)), _e > 5 && (he & 2 && (Ie.atime = ie.read_shift(4)), he & 4 && (Ie.ctime = ie.read_shift(4))), Ie.mtime && (Ie.mt = new Date(Ie.mtime * 1e3));
          break;
        /* ZIP64 Extended Information Field */
        case 1:
          {
            var Ne = ie.read_shift(4), be = ie.read_shift(4);
            Ie.usz = be * Math.pow(2, 32) + Ne, Ne = ie.read_shift(4), be = ie.read_shift(4), Ie.csz = be * Math.pow(2, 32) + Ne;
          }
          break;
      }
      ie.l = ve, ge[pe] = Ie;
    }
    return ge;
  }
  var G;
  function Y() {
    return G || (G = _fs);
  }
  function K(ie, ge) {
    if (ie[0] == 80 && ie[1] == 75) return Yr(ie, ge);
    if ((ie[0] | 32) == 109 && (ie[1] | 32) == 105) return ha(ie, ge);
    if (ie.length < 512) throw new Error("CFB file size " + ie.length + " < 512");
    var he = 3, pe = 512, _e = 0, ve = 0, Ie = 0, Ne = 0, be = 0, Fe = [], Le = (
      /*::(*/
      ie.slice(0, 512)
    );
    prep_blob(Le, 0);
    var $e = Z(Le);
    switch (he = $e[0], he) {
      case 3:
        pe = 512;
        break;
      case 4:
        pe = 4096;
        break;
      case 0:
        if ($e[1] == 0) return Yr(ie, ge);
      /* falls through */
      default:
        throw new Error("Major Version: Expected 3 or 4 saw " + he);
    }
    pe !== 512 && (Le = /*::(*/
    ie.slice(0, pe), prep_blob(
      Le,
      28
      /* blob.l */
    ));
    var Ze = ie.slice(0, pe);
    q(Le, he);
    var ot = Le.read_shift(4, "i");
    if (he === 3 && ot !== 0) throw new Error("# Directory Sectors: Expected 0 saw " + ot);
    Le.l += 4, Ie = Le.read_shift(4, "i"), Le.l += 4, Le.chk("00100000", "Mini Stream Cutoff Size: "), Ne = Le.read_shift(4, "i"), _e = Le.read_shift(4, "i"), be = Le.read_shift(4, "i"), ve = Le.read_shift(4, "i");
    for (var Ye = -1, Qe = 0; Qe < 109 && (Ye = Le.read_shift(4, "i"), !(Ye < 0)); ++Qe)
      Fe[Qe] = Ye;
    var ct = J(ie, pe);
    te(be, ve, ct, pe, Fe);
    var Tt = oe(ct, Ie, Fe, pe);
    Ie < Tt.length && (Tt[Ie].name = "!Directory"), _e > 0 && Ne !== ye && (Tt[Ne].name = "!MiniFAT"), Tt[Fe[0]].name = "!FAT", Tt.fat_addrs = Fe, Tt.ssz = pe;
    var At = {}, Nt = [], Er = [], Cr = [];
    ne(Ie, Tt, ct, Nt, _e, At, Er, Ne), ee(Er, Cr, Nt), Nt.shift();
    var Sr = {
      FileIndex: Er,
      FullPaths: Cr
    };
    return ge && ge.raw && (Sr.raw = { header: Ze, sectors: ct }), Sr;
  }
  function Z(ie) {
    if (ie[ie.l] == 80 && ie[ie.l + 1] == 75) return [0, 0];
    ie.chk(ze, "Header Signature: "), ie.l += 16;
    var ge = ie.read_shift(2, "u");
    return [ie.read_shift(2, "u"), ge];
  }
  function q(ie, ge) {
    var he = 9;
    switch (ie.l += 2, he = ie.read_shift(2)) {
      case 9:
        if (ge != 3) throw new Error("Sector Shift: Expected 9 saw " + he);
        break;
      case 12:
        if (ge != 4) throw new Error("Sector Shift: Expected 12 saw " + he);
        break;
      default:
        throw new Error("Sector Shift: Expected 9 or 12 saw " + he);
    }
    ie.chk("0600", "Mini Sector Shift: "), ie.chk("000000000000", "Reserved: ");
  }
  function J(ie, ge) {
    for (var he = Math.ceil(ie.length / ge) - 1, pe = [], _e = 1; _e < he; ++_e) pe[_e - 1] = ie.slice(_e * ge, (_e + 1) * ge);
    return pe[he - 1] = ie.slice(he * ge), pe;
  }
  function ee(ie, ge, he) {
    for (var pe = 0, _e = 0, ve = 0, Ie = 0, Ne = 0, be = he.length, Fe = [], Le = []; pe < be; ++pe)
      Fe[pe] = Le[pe] = pe, ge[pe] = he[pe];
    for (; Ne < Le.length; ++Ne)
      pe = Le[Ne], _e = ie[pe].L, ve = ie[pe].R, Ie = ie[pe].C, Fe[pe] === pe && (_e !== -1 && Fe[_e] !== _e && (Fe[pe] = Fe[_e]), ve !== -1 && Fe[ve] !== ve && (Fe[pe] = Fe[ve])), Ie !== -1 && (Fe[Ie] = pe), _e !== -1 && pe != Fe[pe] && (Fe[_e] = Fe[pe], Le.lastIndexOf(_e) < Ne && Le.push(_e)), ve !== -1 && pe != Fe[pe] && (Fe[ve] = Fe[pe], Le.lastIndexOf(ve) < Ne && Le.push(ve));
    for (pe = 1; pe < be; ++pe) Fe[pe] === pe && (ve !== -1 && Fe[ve] !== ve ? Fe[pe] = Fe[ve] : _e !== -1 && Fe[_e] !== _e && (Fe[pe] = Fe[_e]));
    for (pe = 1; pe < be; ++pe)
      if (ie[pe].type !== 0) {
        if (Ne = pe, Ne != Fe[Ne]) do
          Ne = Fe[Ne], ge[pe] = ge[Ne] + "/" + ge[pe];
        while (Ne !== 0 && Fe[Ne] !== -1 && Ne != Fe[Ne]);
        Fe[pe] = -1;
      }
    for (ge[0] += "/", pe = 1; pe < be; ++pe)
      ie[pe].type !== 2 && (ge[pe] += "/");
  }
  function re(ie, ge, he) {
    for (var pe = ie.start, _e = ie.size, ve = [], Ie = pe; he && _e > 0 && Ie >= 0; )
      ve.push(ge.slice(Ie * Ce, Ie * Ce + Ce)), _e -= Ce, Ie = __readInt32LE(he, Ie * 4);
    return ve.length === 0 ? new_buf(0) : bconcat(ve).slice(0, ie.size);
  }
  function te(ie, ge, he, pe, _e) {
    var ve = ye;
    if (ie === ye) {
      if (ge !== 0) throw new Error("DIFAT chain shorter than expected");
    } else if (ie !== -1) {
      var Ie = he[ie], Ne = (pe >>> 2) - 1;
      if (!Ie) return;
      for (var be = 0; be < Ne && (ve = __readInt32LE(Ie, be * 4)) !== ye; ++be)
        _e.push(ve);
      ge >= 1 && te(__readInt32LE(Ie, pe - 4), ge - 1, he, pe, _e);
    }
  }
  function Q(ie, ge, he, pe, _e) {
    var ve = [], Ie = [];
    _e || (_e = []);
    var Ne = pe - 1, be = 0, Fe = 0;
    for (be = ge; be >= 0; ) {
      _e[be] = !0, ve[ve.length] = be, Ie.push(ie[be]);
      var Le = he[Math.floor(be * 4 / pe)];
      if (Fe = be * 4 & Ne, pe < 4 + Fe) throw new Error("FAT boundary crossed: " + be + " 4 " + pe);
      if (!ie[Le]) break;
      be = __readInt32LE(ie[Le], Fe);
    }
    return { nodes: ve, data: __toBuffer([Ie]) };
  }
  function oe(ie, ge, he, pe) {
    var _e = ie.length, ve = [], Ie = [], Ne = [], be = [], Fe = pe - 1, Le = 0, $e = 0, Ze = 0, ot = 0;
    for (Le = 0; Le < _e; ++Le)
      if (Ne = [], Ze = Le + ge, Ze >= _e && (Ze -= _e), !Ie[Ze]) {
        be = [];
        var Ye = [];
        for ($e = Ze; $e >= 0; ) {
          Ye[$e] = !0, Ie[$e] = !0, Ne[Ne.length] = $e, be.push(ie[$e]);
          var Qe = he[Math.floor($e * 4 / pe)];
          if (ot = $e * 4 & Fe, pe < 4 + ot) throw new Error("FAT boundary crossed: " + $e + " 4 " + pe);
          if (!ie[Qe] || ($e = __readInt32LE(ie[Qe], ot), Ye[$e])) break;
        }
        ve[Ze] = { nodes: Ne, data: __toBuffer([be]) };
      }
    return ve;
  }
  function ne(ie, ge, he, pe, _e, ve, Ie, Ne) {
    for (var be = 0, Fe = pe.length ? 2 : 0, Le = ge[ie].data, $e = 0, Ze = 0, ot; $e < Le.length; $e += 128) {
      var Ye = (
        /*::(*/
        Le.slice($e, $e + 128)
      );
      prep_blob(Ye, 64), Ze = Ye.read_shift(2), ot = __utf16le(Ye, 0, Ze - Fe), pe.push(ot);
      var Qe = {
        name: ot,
        type: Ye.read_shift(1),
        color: Ye.read_shift(1),
        L: Ye.read_shift(4, "i"),
        R: Ye.read_shift(4, "i"),
        C: Ye.read_shift(4, "i"),
        clsid: Ye.read_shift(16),
        state: Ye.read_shift(4, "i"),
        start: 0,
        size: 0
      }, ct = Ye.read_shift(2) + Ye.read_shift(2) + Ye.read_shift(2) + Ye.read_shift(2);
      ct !== 0 && (Qe.ct = le(Ye, Ye.l - 8));
      var Tt = Ye.read_shift(2) + Ye.read_shift(2) + Ye.read_shift(2) + Ye.read_shift(2);
      Tt !== 0 && (Qe.mt = le(Ye, Ye.l - 8)), Qe.start = Ye.read_shift(4, "i"), Qe.size = Ye.read_shift(4, "i"), Qe.size < 0 && Qe.start < 0 && (Qe.size = Qe.type = 0, Qe.start = ye, Qe.name = ""), Qe.type === 5 ? (be = Qe.start, _e > 0 && be !== ye && (ge[be].name = "!StreamData")) : Qe.size >= 4096 ? (Qe.storage = "fat", ge[Qe.start] === void 0 && (ge[Qe.start] = Q(he, Qe.start, ge.fat_addrs, ge.ssz)), ge[Qe.start].name = Qe.name, Qe.content = ge[Qe.start].data.slice(0, Qe.size)) : (Qe.storage = "minifat", Qe.size < 0 ? Qe.size = 0 : be !== ye && Qe.start !== ye && ge[be] && (Qe.content = re(Qe, ge[be].data, (ge[Ne] || {}).data))), Qe.content && prep_blob(Qe.content, 0), ve[ot] = Qe, Ie.push(Qe);
    }
  }
  function le(ie, ge) {
    return new Date((__readUInt32LE(ie, ge + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(ie, ge) / 1e7 - 11644473600) * 1e3);
  }
  function Ee(ie, ge) {
    return Y(), K(G.readFileSync(ie), ge);
  }
  function Te(ie, ge) {
    var he = ge && ge.type;
    switch (he || has_buf && Buffer.isBuffer(ie) && (he = "buffer"), he || "base64") {
      case "file":
        return Ee(ie, ge);
      case "base64":
        return K(s2a(Base64_decode(ie)), ge);
      case "binary":
        return K(s2a(ie), ge);
    }
    return K(
      /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
      ie,
      ge
    );
  }
  function de(ie, ge) {
    var he = ge || {}, pe = he.root || "Root Entry";
    if (ie.FullPaths || (ie.FullPaths = []), ie.FileIndex || (ie.FileIndex = []), ie.FullPaths.length !== ie.FileIndex.length) throw new Error("inconsistent CFB structure");
    ie.FullPaths.length === 0 && (ie.FullPaths[0] = pe + "/", ie.FileIndex[0] = { name: pe, type: 5 }), he.CLSID && (ie.FileIndex[0].clsid = he.CLSID), ae(ie);
  }
  function ae(ie) {
    var ge = "Sh33tJ5";
    if (!CFB.find(ie, "/" + ge)) {
      var he = new_buf(4);
      he[0] = 55, he[1] = he[3] = 50, he[2] = 54, ie.FileIndex.push({ name: ge, type: 2, content: he, size: 4, L: 69, R: 69, C: 69 }), ie.FullPaths.push(ie.FullPaths[0] + ge), se(ie);
    }
  }
  function se(ie, ge) {
    de(ie);
    for (var he = !1, pe = !1, _e = ie.FullPaths.length - 1; _e >= 0; --_e) {
      var ve = ie.FileIndex[_e];
      switch (ve.type) {
        case 0:
          pe ? he = !0 : (ie.FileIndex.pop(), ie.FullPaths.pop());
          break;
        case 1:
        case 2:
        case 5:
          pe = !0, isNaN(ve.R * ve.L * ve.C) && (he = !0), ve.R > -1 && ve.L > -1 && ve.R == ve.L && (he = !0);
          break;
        default:
          he = !0;
          break;
      }
    }
    if (!(!he && !ge)) {
      var Ie = new Date(1987, 1, 19), Ne = 0, be = Object.create ? /* @__PURE__ */ Object.create(null) : {}, Fe = [];
      for (_e = 0; _e < ie.FullPaths.length; ++_e)
        be[ie.FullPaths[_e]] = !0, ie.FileIndex[_e].type !== 0 && Fe.push([ie.FullPaths[_e], ie.FileIndex[_e]]);
      for (_e = 0; _e < Fe.length; ++_e) {
        var Le = O(Fe[_e][0]);
        for (pe = be[Le]; !pe; ) {
          for (; O(Le) && !be[O(Le)]; ) Le = O(Le);
          Fe.push([Le, {
            name: D(Le).replace("/", ""),
            type: 1,
            clsid: et,
            ct: Ie,
            mt: Ie,
            content: null
          }]), be[Le] = !0, Le = O(Fe[_e][0]), pe = be[Le];
        }
      }
      for (Fe.sort(function(ot, Ye) {
        return w(ot[0], Ye[0]);
      }), ie.FullPaths = [], ie.FileIndex = [], _e = 0; _e < Fe.length; ++_e)
        ie.FullPaths[_e] = Fe[_e][0], ie.FileIndex[_e] = Fe[_e][1];
      for (_e = 0; _e < Fe.length; ++_e) {
        var $e = ie.FileIndex[_e], Ze = ie.FullPaths[_e];
        if ($e.name = D(Ze).replace("/", ""), $e.L = $e.R = $e.C = -($e.color = 1), $e.size = $e.content ? $e.content.length : 0, $e.start = 0, $e.clsid = $e.clsid || et, _e === 0)
          $e.C = Fe.length > 1 ? 1 : -1, $e.size = 0, $e.type = 5;
        else if (Ze.slice(-1) == "/") {
          for (Ne = _e + 1; Ne < Fe.length && O(ie.FullPaths[Ne]) != Ze; ++Ne) ;
          for ($e.C = Ne >= Fe.length ? -1 : Ne, Ne = _e + 1; Ne < Fe.length && O(ie.FullPaths[Ne]) != O(Ze); ++Ne) ;
          $e.R = Ne >= Fe.length ? -1 : Ne, $e.type = 1;
        } else
          O(ie.FullPaths[_e + 1] || "") == O(Ze) && ($e.R = _e + 1), $e.type = 2;
      }
    }
  }
  function ce(ie, ge) {
    var he = ge || {};
    if (he.fileType == "mad") return pa(ie, he);
    switch (se(ie), he.fileType) {
      case "zip":
        return oa(ie, he);
    }
    var pe = function(ot) {
      for (var Ye = 0, Qe = 0, ct = 0; ct < ot.FileIndex.length; ++ct) {
        var Tt = ot.FileIndex[ct];
        if (Tt.content) {
          var At = Tt.content.length;
          At > 0 && (At < 4096 ? Ye += At + 63 >> 6 : Qe += At + 511 >> 9);
        }
      }
      for (var Nt = ot.FullPaths.length + 3 >> 2, Er = Ye + 7 >> 3, Cr = Ye + 127 >> 7, Sr = Er + Qe + Nt + Cr, sr = Sr + 127 >> 7, Ur = sr <= 109 ? 0 : Math.ceil((sr - 109) / 127); Sr + sr + Ur + 127 >> 7 > sr; ) Ur = ++sr <= 109 ? 0 : Math.ceil((sr - 109) / 127);
      var $t = [1, Ur, sr, Cr, Nt, Qe, Ye, 0];
      return ot.FileIndex[0].size = Ye << 6, $t[7] = (ot.FileIndex[0].start = $t[0] + $t[1] + $t[2] + $t[3] + $t[4] + $t[5]) + ($t[6] + 7 >> 3), $t;
    }(ie), _e = new_buf(pe[7] << 9), ve = 0, Ie = 0;
    {
      for (ve = 0; ve < 8; ++ve) _e.write_shift(1, De[ve]);
      for (ve = 0; ve < 8; ++ve) _e.write_shift(2, 0);
      for (_e.write_shift(2, 62), _e.write_shift(2, 3), _e.write_shift(2, 65534), _e.write_shift(2, 9), _e.write_shift(2, 6), ve = 0; ve < 3; ++ve) _e.write_shift(2, 0);
      for (_e.write_shift(4, 0), _e.write_shift(4, pe[2]), _e.write_shift(4, pe[0] + pe[1] + pe[2] + pe[3] - 1), _e.write_shift(4, 0), _e.write_shift(4, 4096), _e.write_shift(4, pe[3] ? pe[0] + pe[1] + pe[2] - 1 : ye), _e.write_shift(4, pe[3]), _e.write_shift(-4, pe[1] ? pe[0] - 1 : ye), _e.write_shift(4, pe[1]), ve = 0; ve < 109; ++ve) _e.write_shift(-4, ve < pe[2] ? pe[1] + ve : -1);
    }
    if (pe[1])
      for (Ie = 0; Ie < pe[1]; ++Ie) {
        for (; ve < 236 + Ie * 127; ++ve) _e.write_shift(-4, ve < pe[2] ? pe[1] + ve : -1);
        _e.write_shift(-4, Ie === pe[1] - 1 ? ye : Ie + 1);
      }
    var Ne = function(ot) {
      for (Ie += ot; ve < Ie - 1; ++ve) _e.write_shift(-4, ve + 1);
      ot && (++ve, _e.write_shift(-4, ye));
    };
    for (Ie = ve = 0, Ie += pe[1]; ve < Ie; ++ve) _e.write_shift(-4, Oe.DIFSECT);
    for (Ie += pe[2]; ve < Ie; ++ve) _e.write_shift(-4, Oe.FATSECT);
    Ne(pe[3]), Ne(pe[4]);
    for (var be = 0, Fe = 0, Le = ie.FileIndex[0]; be < ie.FileIndex.length; ++be)
      Le = ie.FileIndex[be], Le.content && (Fe = Le.content.length, !(Fe < 4096) && (Le.start = Ie, Ne(Fe + 511 >> 9)));
    for (Ne(pe[6] + 7 >> 3); _e.l & 511; ) _e.write_shift(-4, Oe.ENDOFCHAIN);
    for (Ie = ve = 0, be = 0; be < ie.FileIndex.length; ++be)
      Le = ie.FileIndex[be], Le.content && (Fe = Le.content.length, !(!Fe || Fe >= 4096) && (Le.start = Ie, Ne(Fe + 63 >> 6)));
    for (; _e.l & 511; ) _e.write_shift(-4, Oe.ENDOFCHAIN);
    for (ve = 0; ve < pe[4] << 2; ++ve) {
      var $e = ie.FullPaths[ve];
      if (!$e || $e.length === 0) {
        for (be = 0; be < 17; ++be) _e.write_shift(4, 0);
        for (be = 0; be < 3; ++be) _e.write_shift(4, -1);
        for (be = 0; be < 12; ++be) _e.write_shift(4, 0);
        continue;
      }
      Le = ie.FileIndex[ve], ve === 0 && (Le.start = Le.size ? Le.start - 1 : ye);
      var Ze = ve === 0 && he.root || Le.name;
      if (Ze.length > 31 && (console.error("Name " + Ze + " will be truncated to " + Ze.slice(0, 31)), Ze = Ze.slice(0, 31)), Fe = 2 * (Ze.length + 1), _e.write_shift(64, Ze, "utf16le"), _e.write_shift(2, Fe), _e.write_shift(1, Le.type), _e.write_shift(1, Le.color), _e.write_shift(-4, Le.L), _e.write_shift(-4, Le.R), _e.write_shift(-4, Le.C), Le.clsid) _e.write_shift(16, Le.clsid, "hex");
      else for (be = 0; be < 4; ++be) _e.write_shift(4, 0);
      _e.write_shift(4, Le.state || 0), _e.write_shift(4, 0), _e.write_shift(4, 0), _e.write_shift(4, 0), _e.write_shift(4, 0), _e.write_shift(4, Le.start), _e.write_shift(4, Le.size), _e.write_shift(4, 0);
    }
    for (ve = 1; ve < ie.FileIndex.length; ++ve)
      if (Le = ie.FileIndex[ve], Le.size >= 4096)
        if (_e.l = Le.start + 1 << 9, has_buf && Buffer.isBuffer(Le.content))
          Le.content.copy(_e, _e.l, 0, Le.size), _e.l += Le.size + 511 & -512;
        else {
          for (be = 0; be < Le.size; ++be) _e.write_shift(1, Le.content[be]);
          for (; be & 511; ++be) _e.write_shift(1, 0);
        }
    for (ve = 1; ve < ie.FileIndex.length; ++ve)
      if (Le = ie.FileIndex[ve], Le.size > 0 && Le.size < 4096)
        if (has_buf && Buffer.isBuffer(Le.content))
          Le.content.copy(_e, _e.l, 0, Le.size), _e.l += Le.size + 63 & -64;
        else {
          for (be = 0; be < Le.size; ++be) _e.write_shift(1, Le.content[be]);
          for (; be & 63; ++be) _e.write_shift(1, 0);
        }
    if (has_buf)
      _e.l = _e.length;
    else
      for (; _e.l < _e.length; ) _e.write_shift(1, 0);
    return _e;
  }
  function xe(ie, ge) {
    var he = ie.FullPaths.map(function(be) {
      return be.toUpperCase();
    }), pe = he.map(function(be) {
      var Fe = be.split("/");
      return Fe[Fe.length - (be.slice(-1) == "/" ? 2 : 1)];
    }), _e = !1;
    ge.charCodeAt(0) === 47 ? (_e = !0, ge = he[0].slice(0, -1) + ge) : _e = ge.indexOf("/") !== -1;
    var ve = ge.toUpperCase(), Ie = _e === !0 ? he.indexOf(ve) : pe.indexOf(ve);
    if (Ie !== -1) return ie.FileIndex[Ie];
    var Ne = !ve.match(chr1);
    for (ve = ve.replace(chr0, ""), Ne && (ve = ve.replace(chr1, "!")), Ie = 0; Ie < he.length; ++Ie)
      if ((Ne ? he[Ie].replace(chr1, "!") : he[Ie]).replace(chr0, "") == ve || (Ne ? pe[Ie].replace(chr1, "!") : pe[Ie]).replace(chr0, "") == ve) return ie.FileIndex[Ie];
    return null;
  }
  var Ce = 64, ye = -2, ze = "d0cf11e0a1b11ae1", De = [208, 207, 17, 224, 161, 177, 26, 225], et = "00000000000000000000000000000000", Oe = {
    /* 2.1 Compund File Sector Numbers and Types */
    MAXREGSECT: -6,
    DIFSECT: -4,
    FATSECT: -3,
    ENDOFCHAIN: ye,
    FREESECT: -1,
    /* 2.2 Compound File Header */
    HEADER_SIGNATURE: ze,
    HEADER_MINOR_VERSION: "3e00",
    MAXREGSID: -6,
    NOSTREAM: -1,
    HEADER_CLSID: et,
    /* 2.6.1 Compound File Directory Entry */
    EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
  };
  function Xe(ie, ge, he) {
    Y();
    var pe = ce(ie, he);
    G.writeFileSync(ge, pe);
  }
  function He(ie) {
    for (var ge = new Array(ie.length), he = 0; he < ie.length; ++he) ge[he] = String.fromCharCode(ie[he]);
    return ge.join("");
  }
  function Ae(ie, ge) {
    var he = ce(ie, ge);
    switch (ge && ge.type || "buffer") {
      case "file":
        return Y(), G.writeFileSync(ge.filename, he), he;
      case "binary":
        return typeof he == "string" ? he : He(he);
      case "base64":
        return Base64_encode(typeof he == "string" ? he : He(he));
      case "buffer":
        if (has_buf) return Buffer.isBuffer(he) ? he : Buffer_from(he);
      /* falls through */
      case "array":
        return typeof he == "string" ? s2a(he) : he;
    }
    return he;
  }
  var qe;
  function Ue(ie) {
    try {
      var ge = ie.InflateRaw, he = new ge();
      if (he._processChunk(new Uint8Array([3, 0]), he._finishFlushFlag), he.bytesRead) qe = ie;
      else throw new Error("zlib does not expose bytesRead");
    } catch (pe) {
      console.error("cannot use native zlib: " + (pe.message || pe));
    }
  }
  function Re(ie, ge) {
    if (!qe) return zr(ie, ge);
    var he = qe.InflateRaw, pe = new he(), _e = pe._processChunk(ie.slice(ie.l), pe._finishFlushFlag);
    return ie.l += pe.bytesRead, _e;
  }
  function Me(ie) {
    return qe ? qe.deflateRawSync(ie) : kt(ie);
  }
  var je = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], Je = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258], rt = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
  function fe(ie) {
    var ge = (ie << 1 | ie << 11) & 139536 | (ie << 5 | ie << 15) & 558144;
    return (ge >> 16 | ge >> 8 | ge) & 255;
  }
  for (var Se = typeof Uint8Array < "u", we = Se ? new Uint8Array(256) : [], me = 0; me < 256; ++me) we[me] = fe(me);
  function ke(ie, ge) {
    var he = we[ie & 255];
    return ge <= 8 ? he >>> 8 - ge : (he = he << 8 | we[ie >> 8 & 255], ge <= 16 ? he >>> 16 - ge : (he = he << 8 | we[ie >> 16 & 255], he >>> 24 - ge));
  }
  function ue(ie, ge) {
    var he = ge & 7, pe = ge >>> 3;
    return (ie[pe] | (he <= 6 ? 0 : ie[pe + 1] << 8)) >>> he & 3;
  }
  function We(ie, ge) {
    var he = ge & 7, pe = ge >>> 3;
    return (ie[pe] | (he <= 5 ? 0 : ie[pe + 1] << 8)) >>> he & 7;
  }
  function Ge(ie, ge) {
    var he = ge & 7, pe = ge >>> 3;
    return (ie[pe] | (he <= 4 ? 0 : ie[pe + 1] << 8)) >>> he & 15;
  }
  function Pe(ie, ge) {
    var he = ge & 7, pe = ge >>> 3;
    return (ie[pe] | (he <= 3 ? 0 : ie[pe + 1] << 8)) >>> he & 31;
  }
  function it(ie, ge) {
    var he = ge & 7, pe = ge >>> 3;
    return (ie[pe] | (he <= 1 ? 0 : ie[pe + 1] << 8)) >>> he & 127;
  }
  function Ve(ie, ge, he) {
    var pe = ge & 7, _e = ge >>> 3, ve = (1 << he) - 1, Ie = ie[_e] >>> pe;
    return he < 8 - pe || (Ie |= ie[_e + 1] << 8 - pe, he < 16 - pe) || (Ie |= ie[_e + 2] << 16 - pe, he < 24 - pe) || (Ie |= ie[_e + 3] << 24 - pe), Ie & ve;
  }
  function st(ie, ge, he) {
    var pe = ge & 7, _e = ge >>> 3;
    return pe <= 5 ? ie[_e] |= (he & 7) << pe : (ie[_e] |= he << pe & 255, ie[_e + 1] = (he & 7) >> 8 - pe), ge + 3;
  }
  function dt(ie, ge, he) {
    var pe = ge & 7, _e = ge >>> 3;
    return he = (he & 1) << pe, ie[_e] |= he, ge + 1;
  }
  function ut(ie, ge, he) {
    var pe = ge & 7, _e = ge >>> 3;
    return he <<= pe, ie[_e] |= he & 255, he >>>= 8, ie[_e + 1] = he, ge + 8;
  }
  function mt(ie, ge, he) {
    var pe = ge & 7, _e = ge >>> 3;
    return he <<= pe, ie[_e] |= he & 255, he >>>= 8, ie[_e + 1] = he & 255, ie[_e + 2] = he >>> 8, ge + 16;
  }
  function at(ie, ge) {
    var he = ie.length, pe = 2 * he > ge ? 2 * he : ge + 5, _e = 0;
    if (he >= ge) return ie;
    if (has_buf) {
      var ve = new_unsafe_buf(pe);
      if (ie.copy) ie.copy(ve);
      else for (; _e < ie.length; ++_e) ve[_e] = ie[_e];
      return ve;
    } else if (Se) {
      var Ie = new Uint8Array(pe);
      if (Ie.set) Ie.set(ie);
      else for (; _e < he; ++_e) Ie[_e] = ie[_e];
      return Ie;
    }
    return ie.length = pe, ie;
  }
  function lt(ie) {
    for (var ge = new Array(ie), he = 0; he < ie; ++he) ge[he] = 0;
    return ge;
  }
  function Ke(ie, ge, he) {
    var pe = 1, _e = 0, ve = 0, Ie = 0, Ne = 0, be = ie.length, Fe = Se ? new Uint16Array(32) : lt(32);
    for (ve = 0; ve < 32; ++ve) Fe[ve] = 0;
    for (ve = be; ve < he; ++ve) ie[ve] = 0;
    be = ie.length;
    var Le = Se ? new Uint16Array(be) : lt(be);
    for (ve = 0; ve < be; ++ve)
      Fe[_e = ie[ve]]++, pe < _e && (pe = _e), Le[ve] = 0;
    for (Fe[0] = 0, ve = 1; ve <= pe; ++ve) Fe[ve + 16] = Ne = Ne + Fe[ve - 1] << 1;
    for (ve = 0; ve < be; ++ve)
      Ne = ie[ve], Ne != 0 && (Le[ve] = Fe[Ne + 16]++);
    var $e = 0;
    for (ve = 0; ve < be; ++ve)
      if ($e = ie[ve], $e != 0)
        for (Ne = ke(Le[ve], pe) >> pe - $e, Ie = (1 << pe + 4 - $e) - 1; Ie >= 0; --Ie)
          ge[Ne | Ie << $e] = $e & 15 | ve << 4;
    return pe;
  }
  var _t = Se ? new Uint16Array(512) : lt(512), gt = Se ? new Uint16Array(32) : lt(32);
  if (!Se) {
    for (var ht = 0; ht < 512; ++ht) _t[ht] = 0;
    for (ht = 0; ht < 32; ++ht) gt[ht] = 0;
  }
  (function() {
    for (var ie = [], ge = 0; ge < 32; ge++) ie.push(5);
    Ke(ie, gt, 32);
    var he = [];
    for (ge = 0; ge <= 143; ge++) he.push(8);
    for (; ge <= 255; ge++) he.push(9);
    for (; ge <= 279; ge++) he.push(7);
    for (; ge <= 287; ge++) he.push(8);
    Ke(he, _t, 288);
  })();
  var Pt = /* @__PURE__ */ function() {
    for (var ge = Se ? new Uint8Array(32768) : [], he = 0, pe = 0; he < rt.length - 1; ++he)
      for (; pe < rt[he + 1]; ++pe) ge[pe] = he;
    for (; pe < 32768; ++pe) ge[pe] = 29;
    var _e = Se ? new Uint8Array(259) : [];
    for (he = 0, pe = 0; he < Je.length - 1; ++he)
      for (; pe < Je[he + 1]; ++pe) _e[pe] = he;
    function ve(Ne, be) {
      for (var Fe = 0; Fe < Ne.length; ) {
        var Le = Math.min(65535, Ne.length - Fe), $e = Fe + Le == Ne.length;
        for (be.write_shift(1, +$e), be.write_shift(2, Le), be.write_shift(2, ~Le & 65535); Le-- > 0; ) be[be.l++] = Ne[Fe++];
      }
      return be.l;
    }
    function Ie(Ne, be) {
      for (var Fe = 0, Le = 0, $e = Se ? new Uint16Array(32768) : []; Le < Ne.length; ) {
        var Ze = (
          /* data.length - boff; */
          Math.min(65535, Ne.length - Le)
        );
        if (Ze < 10) {
          for (Fe = st(be, Fe, +(Le + Ze == Ne.length)), Fe & 7 && (Fe += 8 - (Fe & 7)), be.l = Fe / 8 | 0, be.write_shift(2, Ze), be.write_shift(2, ~Ze & 65535); Ze-- > 0; ) be[be.l++] = Ne[Le++];
          Fe = be.l * 8;
          continue;
        }
        Fe = st(be, Fe, +(Le + Ze == Ne.length) + 2);
        for (var ot = 0; Ze-- > 0; ) {
          var Ye = Ne[Le];
          ot = (ot << 5 ^ Ye) & 32767;
          var Qe = -1, ct = 0;
          if ((Qe = $e[ot]) && (Qe |= Le & -32768, Qe > Le && (Qe -= 32768), Qe < Le))
            for (; Ne[Qe + ct] == Ne[Le + ct] && ct < 250; ) ++ct;
          if (ct > 2) {
            Ye = _e[ct], Ye <= 22 ? Fe = ut(be, Fe, we[Ye + 1] >> 1) - 1 : (ut(be, Fe, 3), Fe += 5, ut(be, Fe, we[Ye - 23] >> 5), Fe += 3);
            var Tt = Ye < 8 ? 0 : Ye - 4 >> 2;
            Tt > 0 && (mt(be, Fe, ct - Je[Ye]), Fe += Tt), Ye = ge[Le - Qe], Fe = ut(be, Fe, we[Ye] >> 3), Fe -= 3;
            var At = Ye < 4 ? 0 : Ye - 2 >> 1;
            At > 0 && (mt(be, Fe, Le - Qe - rt[Ye]), Fe += At);
            for (var Nt = 0; Nt < ct; ++Nt)
              $e[ot] = Le & 32767, ot = (ot << 5 ^ Ne[Le]) & 32767, ++Le;
            Ze -= ct - 1;
          } else
            Ye <= 143 ? Ye = Ye + 48 : Fe = dt(be, Fe, 1), Fe = ut(be, Fe, we[Ye]), $e[ot] = Le & 32767, ++Le;
        }
        Fe = ut(be, Fe, 0) - 1;
      }
      return be.l = (Fe + 7) / 8 | 0, be.l;
    }
    return function(be, Fe) {
      return be.length < 8 ? ve(be, Fe) : Ie(be, Fe);
    };
  }();
  function kt(ie) {
    var ge = new_buf(50 + Math.floor(ie.length * 1.1)), he = Pt(ie, ge);
    return ge.slice(0, he);
  }
  var tt = Se ? new Uint16Array(32768) : lt(32768), ft = Se ? new Uint16Array(32768) : lt(32768), St = Se ? new Uint16Array(128) : lt(128), bt = 1, zt = 1;
  function nr(ie, ge) {
    var he = Pe(ie, ge) + 257;
    ge += 5;
    var pe = Pe(ie, ge) + 1;
    ge += 5;
    var _e = Ge(ie, ge) + 4;
    ge += 4;
    for (var ve = 0, Ie = Se ? new Uint8Array(19) : lt(19), Ne = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], be = 1, Fe = Se ? new Uint8Array(8) : lt(8), Le = Se ? new Uint8Array(8) : lt(8), $e = Ie.length, Ze = 0; Ze < _e; ++Ze)
      Ie[je[Ze]] = ve = We(ie, ge), be < ve && (be = ve), Fe[ve]++, ge += 3;
    var ot = 0;
    for (Fe[0] = 0, Ze = 1; Ze <= be; ++Ze) Le[Ze] = ot = ot + Fe[Ze - 1] << 1;
    for (Ze = 0; Ze < $e; ++Ze) (ot = Ie[Ze]) != 0 && (Ne[Ze] = Le[ot]++);
    var Ye = 0;
    for (Ze = 0; Ze < $e; ++Ze)
      if (Ye = Ie[Ze], Ye != 0) {
        ot = we[Ne[Ze]] >> 8 - Ye;
        for (var Qe = (1 << 7 - Ye) - 1; Qe >= 0; --Qe) St[ot | Qe << Ye] = Ye & 7 | Ze << 3;
      }
    var ct = [];
    for (be = 1; ct.length < he + pe; )
      switch (ot = St[it(ie, ge)], ge += ot & 7, ot >>>= 3) {
        case 16:
          for (ve = 3 + ue(ie, ge), ge += 2, ot = ct[ct.length - 1]; ve-- > 0; ) ct.push(ot);
          break;
        case 17:
          for (ve = 3 + We(ie, ge), ge += 3; ve-- > 0; ) ct.push(0);
          break;
        case 18:
          for (ve = 11 + it(ie, ge), ge += 7; ve-- > 0; ) ct.push(0);
          break;
        default:
          ct.push(ot), be < ot && (be = ot);
          break;
      }
    var Tt = ct.slice(0, he), At = ct.slice(he);
    for (Ze = he; Ze < 286; ++Ze) Tt[Ze] = 0;
    for (Ze = pe; Ze < 30; ++Ze) At[Ze] = 0;
    return bt = Ke(Tt, tt, 286), zt = Ke(At, ft, 30), ge;
  }
  function Lr(ie, ge) {
    if (ie[0] == 3 && !(ie[1] & 3))
      return [new_raw_buf(ge), 2];
    for (var he = 0, pe = 0, _e = new_unsafe_buf(ge || 1 << 18), ve = 0, Ie = _e.length >>> 0, Ne = 0, be = 0; (pe & 1) == 0; ) {
      if (pe = We(ie, he), he += 3, pe >>> 1)
        pe >> 1 == 1 ? (Ne = 9, be = 5) : (he = nr(ie, he), Ne = bt, be = zt);
      else {
        he & 7 && (he += 8 - (he & 7));
        var Fe = ie[he >>> 3] | ie[(he >>> 3) + 1] << 8;
        if (he += 32, Fe > 0)
          for (!ge && Ie < ve + Fe && (_e = at(_e, ve + Fe), Ie = _e.length); Fe-- > 0; )
            _e[ve++] = ie[he >>> 3], he += 8;
        continue;
      }
      for (; ; ) {
        !ge && Ie < ve + 32767 && (_e = at(_e, ve + 32767), Ie = _e.length);
        var Le = Ve(ie, he, Ne), $e = pe >>> 1 == 1 ? _t[Le] : tt[Le];
        if (he += $e & 15, $e >>>= 4, ($e >>> 8 & 255) === 0) _e[ve++] = $e;
        else {
          if ($e == 256) break;
          $e -= 257;
          var Ze = $e < 8 ? 0 : $e - 4 >> 2;
          Ze > 5 && (Ze = 0);
          var ot = ve + Je[$e];
          Ze > 0 && (ot += Ve(ie, he, Ze), he += Ze), Le = Ve(ie, he, be), $e = pe >>> 1 == 1 ? gt[Le] : ft[Le], he += $e & 15, $e >>>= 4;
          var Ye = $e < 4 ? 0 : $e - 2 >> 1, Qe = rt[$e];
          for (Ye > 0 && (Qe += Ve(ie, he, Ye), he += Ye), !ge && Ie < ot && (_e = at(_e, ot + 100), Ie = _e.length); ve < ot; )
            _e[ve] = _e[ve - Qe], ++ve;
        }
      }
    }
    return ge ? [_e, he + 7 >>> 3] : [_e.slice(0, ve), he + 7 >>> 3];
  }
  function zr(ie, ge) {
    var he = ie.slice(ie.l || 0), pe = Lr(he, ge);
    return ie.l += pe[1], pe[0];
  }
  function $r(ie, ge) {
    if (ie)
      typeof console < "u" && console.error(ge);
    else throw new Error(ge);
  }
  function Yr(ie, ge) {
    var he = (
      /*::(*/
      ie
    );
    prep_blob(he, 0);
    var pe = [], _e = [], ve = {
      FileIndex: pe,
      FullPaths: _e
    };
    de(ve, { root: ge.root });
    for (var Ie = he.length - 4; (he[Ie] != 80 || he[Ie + 1] != 75 || he[Ie + 2] != 5 || he[Ie + 3] != 6) && Ie >= 0; ) --Ie;
    he.l = Ie + 4, he.l += 4;
    var Ne = he.read_shift(2);
    he.l += 6;
    var be = he.read_shift(4);
    for (he.l = be, Ie = 0; Ie < Ne; ++Ie) {
      he.l += 20;
      var Fe = he.read_shift(4), Le = he.read_shift(4), $e = he.read_shift(2), Ze = he.read_shift(2), ot = he.read_shift(2);
      he.l += 8;
      var Ye = he.read_shift(4), Qe = X(
        /*::(*/
        he.slice(he.l + $e, he.l + $e + Ze)
        /*:: :any)*/
      );
      he.l += $e + Ze + ot;
      var ct = he.l;
      he.l = Ye + 4, Qe && Qe[1] && ((Qe[1] || {}).usz && (Le = Qe[1].usz), (Qe[1] || {}).csz && (Fe = Qe[1].csz)), ia(he, Fe, Le, ve, Qe), he.l = ct;
    }
    return ve;
  }
  function ia(ie, ge, he, pe, _e) {
    ie.l += 2;
    var ve = ie.read_shift(2), Ie = ie.read_shift(2), Ne = W(ie);
    if (ve & 8257) throw new Error("Unsupported ZIP encryption");
    for (var be = ie.read_shift(4), Fe = ie.read_shift(4), Le = ie.read_shift(4), $e = ie.read_shift(2), Ze = ie.read_shift(2), ot = "", Ye = 0; Ye < $e; ++Ye) ot += String.fromCharCode(ie[ie.l++]);
    if (Ze) {
      var Qe = X(
        /*::(*/
        ie.slice(ie.l, ie.l + Ze)
        /*:: :any)*/
      );
      (Qe[21589] || {}).mt && (Ne = Qe[21589].mt), (Qe[1] || {}).usz && (Le = Qe[1].usz), (Qe[1] || {}).csz && (Fe = Qe[1].csz), _e && ((_e[21589] || {}).mt && (Ne = _e[21589].mt), (_e[1] || {}).usz && (Le = _e[1].usz), (_e[1] || {}).csz && (Fe = _e[1].csz));
    }
    ie.l += Ze;
    var ct = ie.slice(ie.l, ie.l + Fe);
    switch (Ie) {
      case 8:
        ct = Re(ie, Le);
        break;
      case 0:
        ie.l += Fe;
        break;
      // TODO: scan for magic number
      default:
        throw new Error("Unsupported ZIP Compression method " + Ie);
    }
    var Tt = !1;
    ve & 8 && (be = ie.read_shift(4), be == 134695760 && (be = ie.read_shift(4), Tt = !0), Fe = ie.read_shift(4), Le = ie.read_shift(4)), Fe != ge && $r(Tt, "Bad compressed size: " + ge + " != " + Fe), Le != he && $r(Tt, "Bad uncompressed size: " + he + " != " + Le), Dr(pe, ot, ct, { unsafe: !0, mt: Ne });
  }
  function oa(ie, ge) {
    var he = ge || {}, pe = [], _e = [], ve = new_buf(1), Ie = he.compression ? 8 : 0, Ne = 0, be = 0, Fe = 0, Le = 0, $e = 0, Ze = ie.FullPaths[0], ot = Ze, Ye = ie.FileIndex[0], Qe = [], ct = 0;
    for (be = 1; be < ie.FullPaths.length; ++be)
      if (ot = ie.FullPaths[be].slice(Ze.length), Ye = ie.FileIndex[be], !(!Ye.size || !Ye.content || Array.isArray(Ye.content) && Ye.content.length == 0 || ot == "Sh33tJ5")) {
        var Tt = Le, At = new_buf(ot.length);
        for (Fe = 0; Fe < ot.length; ++Fe) At.write_shift(1, ot.charCodeAt(Fe) & 127);
        At = At.slice(0, At.l), Qe[$e] = typeof Ye.content == "string" ? CRC32.bstr(Ye.content, 0) : CRC32.buf(
          /*::((*/
          Ye.content,
          0
        );
        var Nt = typeof Ye.content == "string" ? s2a(Ye.content) : Ye.content;
        Ie == 8 && (Nt = Me(Nt)), ve = new_buf(30), ve.write_shift(4, 67324752), ve.write_shift(2, 20), ve.write_shift(2, Ne), ve.write_shift(2, Ie), Ye.mt ? U(ve, Ye.mt) : ve.write_shift(4, 0), ve.write_shift(-4, Qe[$e]), ve.write_shift(4, Nt.length), ve.write_shift(
          4,
          /*::(*/
          Ye.content.length
        ), ve.write_shift(2, At.length), ve.write_shift(2, 0), Le += ve.length, pe.push(ve), Le += At.length, pe.push(At), Le += Nt.length, pe.push(Nt), ve = new_buf(46), ve.write_shift(4, 33639248), ve.write_shift(2, 0), ve.write_shift(2, 20), ve.write_shift(2, Ne), ve.write_shift(2, Ie), ve.write_shift(4, 0), ve.write_shift(-4, Qe[$e]), ve.write_shift(4, Nt.length), ve.write_shift(
          4,
          /*::(*/
          Ye.content.length
        ), ve.write_shift(2, At.length), ve.write_shift(2, 0), ve.write_shift(2, 0), ve.write_shift(2, 0), ve.write_shift(2, 0), ve.write_shift(4, 0), ve.write_shift(4, Tt), ct += ve.l, _e.push(ve), ct += At.length, _e.push(At), ++$e;
      }
    return ve = new_buf(22), ve.write_shift(4, 101010256), ve.write_shift(2, 0), ve.write_shift(2, 0), ve.write_shift(2, $e), ve.write_shift(2, $e), ve.write_shift(4, ct), ve.write_shift(4, Le), ve.write_shift(2, 0), bconcat([bconcat(pe), bconcat(_e), ve]);
  }
  var kr = {
    htm: "text/html",
    xml: "text/xml",
    gif: "image/gif",
    jpg: "image/jpeg",
    png: "image/png",
    mso: "application/x-mso",
    thmx: "application/vnd.ms-officetheme",
    sh33tj5: "application/octet-stream"
  };
  function la(ie, ge) {
    if (ie.ctype) return ie.ctype;
    var he = ie.name || "", pe = he.match(/\.([^\.]+)$/);
    return pe && kr[pe[1]] || ge && (pe = (he = ge).match(/[\.\\]([^\.\\])+$/), pe && kr[pe[1]]) ? kr[pe[1]] : "application/octet-stream";
  }
  function ca(ie) {
    for (var ge = Base64_encode(ie), he = [], pe = 0; pe < ge.length; pe += 76) he.push(ge.slice(pe, pe + 76));
    return he.join(`\r
`) + `\r
`;
  }
  function fa(ie) {
    var ge = ie.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(Fe) {
      var Le = Fe.charCodeAt(0).toString(16).toUpperCase();
      return "=" + (Le.length == 1 ? "0" + Le : Le);
    });
    ge = ge.replace(/ $/mg, "=20").replace(/\t$/mg, "=09"), ge.charAt(0) == `
` && (ge = "=0D" + ge.slice(1)), ge = ge.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, `
=0A`).replace(/([^\r\n])\n/mg, "$1=0A");
    for (var he = [], pe = ge.split(`\r
`), _e = 0; _e < pe.length; ++_e) {
      var ve = pe[_e];
      if (ve.length == 0) {
        he.push("");
        continue;
      }
      for (var Ie = 0; Ie < ve.length; ) {
        var Ne = 76, be = ve.slice(Ie, Ie + Ne);
        be.charAt(Ne - 1) == "=" ? Ne-- : be.charAt(Ne - 2) == "=" ? Ne -= 2 : be.charAt(Ne - 3) == "=" && (Ne -= 3), be = ve.slice(Ie, Ie + Ne), Ie += Ne, Ie < ve.length && (be += "="), he.push(be);
      }
    }
    return he.join(`\r
`);
  }
  function da(ie) {
    for (var ge = [], he = 0; he < ie.length; ++he) {
      for (var pe = ie[he]; he <= ie.length && pe.charAt(pe.length - 1) == "="; ) pe = pe.slice(0, pe.length - 1) + ie[++he];
      ge.push(pe);
    }
    for (var _e = 0; _e < ge.length; ++_e) ge[_e] = ge[_e].replace(/[=][0-9A-Fa-f]{2}/g, function(ve) {
      return String.fromCharCode(parseInt(ve.slice(1), 16));
    });
    return s2a(ge.join(`\r
`));
  }
  function ua(ie, ge, he) {
    for (var pe = "", _e = "", ve = "", Ie, Ne = 0; Ne < 10; ++Ne) {
      var be = ge[Ne];
      if (!be || be.match(/^\s*$/)) break;
      var Fe = be.match(/^([^:]*?):\s*([^\s].*)$/);
      if (Fe) switch (Fe[1].toLowerCase()) {
        case "content-location":
          pe = Fe[2].trim();
          break;
        case "content-type":
          ve = Fe[2].trim();
          break;
        case "content-transfer-encoding":
          _e = Fe[2].trim();
          break;
      }
    }
    switch (++Ne, _e.toLowerCase()) {
      case "base64":
        Ie = s2a(Base64_decode(ge.slice(Ne).join("")));
        break;
      case "quoted-printable":
        Ie = da(ge.slice(Ne));
        break;
      default:
        throw new Error("Unsupported Content-Transfer-Encoding " + _e);
    }
    var Le = Dr(ie, pe.slice(he.length), Ie, { unsafe: !0 });
    ve && (Le.ctype = ve);
  }
  function ha(ie, ge) {
    if (He(ie.slice(0, 13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
    var he = ge && ge.root || "", pe = (has_buf && Buffer.isBuffer(ie) ? ie.toString("binary") : He(ie)).split(`\r
`), _e = 0, ve = "";
    for (_e = 0; _e < pe.length; ++_e)
      if (ve = pe[_e], !!/^Content-Location:/i.test(ve) && (ve = ve.slice(ve.indexOf("file")), he || (he = ve.slice(0, ve.lastIndexOf("/") + 1)), ve.slice(0, he.length) != he))
        for (; he.length > 0 && (he = he.slice(0, he.length - 1), he = he.slice(0, he.lastIndexOf("/") + 1), ve.slice(0, he.length) != he); )
          ;
    var Ie = (pe[1] || "").match(/boundary="(.*?)"/);
    if (!Ie) throw new Error("MAD cannot find boundary");
    var Ne = "--" + (Ie[1] || ""), be = [], Fe = [], Le = {
      FileIndex: be,
      FullPaths: Fe
    };
    de(Le);
    var $e, Ze = 0;
    for (_e = 0; _e < pe.length; ++_e) {
      var ot = pe[_e];
      ot !== Ne && ot !== Ne + "--" || (Ze++ && ua(Le, pe.slice($e, _e), he), $e = _e);
    }
    return Le;
  }
  function pa(ie, ge) {
    var he = ge || {}, pe = he.boundary || "SheetJS";
    pe = "------=" + pe;
    for (var _e = [
      "MIME-Version: 1.0",
      'Content-Type: multipart/related; boundary="' + pe.slice(2) + '"',
      "",
      "",
      ""
    ], ve = ie.FullPaths[0], Ie = ve, Ne = ie.FileIndex[0], be = 1; be < ie.FullPaths.length; ++be)
      if (Ie = ie.FullPaths[be].slice(ve.length), Ne = ie.FileIndex[be], !(!Ne.size || !Ne.content || Ie == "Sh33tJ5")) {
        Ie = Ie.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(ct) {
          return "_x" + ct.charCodeAt(0).toString(16) + "_";
        }).replace(/[\u0080-\uFFFF]/g, function(ct) {
          return "_u" + ct.charCodeAt(0).toString(16) + "_";
        });
        for (var Fe = Ne.content, Le = has_buf && Buffer.isBuffer(Fe) ? Fe.toString("binary") : He(Fe), $e = 0, Ze = Math.min(1024, Le.length), ot = 0, Ye = 0; Ye <= Ze; ++Ye) (ot = Le.charCodeAt(Ye)) >= 32 && ot < 128 && ++$e;
        var Qe = $e >= Ze * 4 / 5;
        _e.push(pe), _e.push("Content-Location: " + (he.root || "file:///C:/SheetJS/") + Ie), _e.push("Content-Transfer-Encoding: " + (Qe ? "quoted-printable" : "base64")), _e.push("Content-Type: " + la(Ne, Ie)), _e.push(""), _e.push(Qe ? fa(Le) : ca(Le));
      }
    return _e.push(pe + `--\r
`), _e.join(`\r
`);
  }
  function ma(ie) {
    var ge = {};
    return de(ge, ie), ge;
  }
  function Dr(ie, ge, he, pe) {
    var _e = pe && pe.unsafe;
    _e || de(ie);
    var ve = !_e && CFB.find(ie, ge);
    if (!ve) {
      var Ie = ie.FullPaths[0];
      ge.slice(0, Ie.length) == Ie ? Ie = ge : (Ie.slice(-1) != "/" && (Ie += "/"), Ie = (Ie + ge).replace("//", "/")), ve = { name: D(ge), type: 2 }, ie.FileIndex.push(ve), ie.FullPaths.push(Ie), _e || CFB.utils.cfb_gc(ie);
    }
    return ve.content = he, ve.size = he ? he.length : 0, pe && (pe.CLSID && (ve.clsid = pe.CLSID), pe.mt && (ve.mt = pe.mt), pe.ct && (ve.ct = pe.ct)), ve;
  }
  function _a(ie, ge) {
    de(ie);
    var he = CFB.find(ie, ge);
    if (he) {
      for (var pe = 0; pe < ie.FileIndex.length; ++pe) if (ie.FileIndex[pe] == he)
        return ie.FileIndex.splice(pe, 1), ie.FullPaths.splice(pe, 1), !0;
    }
    return !1;
  }
  function ga(ie, ge, he) {
    de(ie);
    var pe = CFB.find(ie, ge);
    if (pe) {
      for (var _e = 0; _e < ie.FileIndex.length; ++_e) if (ie.FileIndex[_e] == pe)
        return ie.FileIndex[_e].name = D(he), ie.FullPaths[_e] = he, !0;
    }
    return !1;
  }
  function xa(ie) {
    se(ie, !0);
  }
  return x.find = xe, x.read = Te, x.parse = K, x.write = Ae, x.writeFile = Xe, x.utils = {
    cfb_new: ma,
    cfb_add: Dr,
    cfb_del: _a,
    cfb_mov: ga,
    cfb_gc: xa,
    ReadShift,
    CheckField,
    prep_blob,
    bconcat,
    use_zlib: Ue,
    _deflateRaw: kt,
    _inflateRaw: zr,
    consts: Oe
  }, x;
}(), _fs;
function set_fs(F) {
  _fs = F;
}
function blobify(F) {
  return typeof F == "string" ? s2ab(F) : Array.isArray(F) ? a2u(F) : F;
}
function write_dl(F, x, w) {
  if (typeof _fs < "u" && _fs.writeFileSync) return w ? _fs.writeFileSync(F, x, w) : _fs.writeFileSync(F, x);
  if (typeof Deno < "u") {
    if (w && typeof x == "string") switch (w) {
      case "utf8":
        x = new TextEncoder(w).encode(x);
        break;
      case "binary":
        x = s2ab(x);
        break;
      /* TODO: binary equivalent */
      default:
        throw new Error("Unsupported encoding " + w);
    }
    return Deno.writeFileSync(F, x);
  }
  var O = w == "utf8" ? utf8write(x) : x;
  if (typeof IE_SaveFile < "u") return IE_SaveFile(O, F);
  if (typeof Blob < "u") {
    var D = new Blob([blobify(O)], { type: "application/octet-stream" });
    if (typeof navigator < "u" && navigator.msSaveBlob) return navigator.msSaveBlob(D, F);
    if (typeof saveAs < "u") return saveAs(D, F);
    if (typeof URL < "u" && typeof document < "u" && document.createElement && URL.createObjectURL) {
      var U = URL.createObjectURL(D);
      if (typeof chrome == "object" && typeof (chrome.downloads || {}).download == "function")
        return URL.revokeObjectURL && typeof setTimeout < "u" && setTimeout(function() {
          URL.revokeObjectURL(U);
        }, 6e4), chrome.downloads.download({ url: U, filename: F, saveAs: !0 });
      var W = document.createElement("a");
      if (W.download != null)
        return W.download = F, W.href = U, document.body.appendChild(W), W.click(), document.body.removeChild(W), URL.revokeObjectURL && typeof setTimeout < "u" && setTimeout(function() {
          URL.revokeObjectURL(U);
        }, 6e4), U;
    } else if (typeof URL < "u" && !URL.createObjectURL && typeof chrome == "object") {
      var X = "data:application/octet-stream;base64," + Base64_encode_arr(new Uint8Array(blobify(O)));
      return chrome.downloads.download({ url: X, filename: F, saveAs: !0 });
    }
  }
  if (typeof $ < "u" && typeof File < "u" && typeof Folder < "u") try {
    var G = File(F);
    return G.open("w"), G.encoding = "binary", Array.isArray(x) && (x = a2s(x)), G.write(x), G.close(), x;
  } catch (Y) {
    if (!Y.message || Y.message.indexOf("onstruct") == -1) throw Y;
  }
  throw new Error("cannot save file " + F);
}
function read_binary(F) {
  if (typeof _fs < "u") return _fs.readFileSync(F);
  if (typeof Deno < "u") return Deno.readFileSync(F);
  if (typeof $ < "u" && typeof File < "u" && typeof Folder < "u") try {
    var x = File(F);
    x.open("r"), x.encoding = "binary";
    var w = x.read();
    return x.close(), w;
  } catch (O) {
    if (!O.message || O.message.indexOf("onstruct") == -1) throw O;
  }
  throw new Error("Cannot access file " + F);
}
function keys(F) {
  for (var x = Object.keys(F), w = [], O = 0; O < x.length; ++O) Object.prototype.hasOwnProperty.call(F, x[O]) && w.push(x[O]);
  return w;
}
function evert_key(F, x) {
  for (var w = [], O = keys(F), D = 0; D !== O.length; ++D) w[F[O[D]][x]] == null && (w[F[O[D]][x]] = O[D]);
  return w;
}
function evert(F) {
  for (var x = [], w = keys(F), O = 0; O !== w.length; ++O) x[F[w[O]]] = w[O];
  return x;
}
function evert_num(F) {
  for (var x = [], w = keys(F), O = 0; O !== w.length; ++O) x[F[w[O]]] = parseInt(w[O], 10);
  return x;
}
function evert_arr(F) {
  for (var x = [], w = keys(F), O = 0; O !== w.length; ++O)
    x[F[w[O]]] == null && (x[F[w[O]]] = []), x[F[w[O]]].push(w[O]);
  return x;
}
var dnthresh = /* @__PURE__ */ Date.UTC(1899, 11, 30, 0, 0, 0), dnthresh1 = /* @__PURE__ */ Date.UTC(1899, 11, 31, 0, 0, 0), dnthresh2 = /* @__PURE__ */ Date.UTC(1904, 0, 1, 0, 0, 0);
function datenum(F, x) {
  var w = /* @__PURE__ */ F.getTime(), O = (w - dnthresh) / (1440 * 60 * 1e3);
  return x ? (O -= 1462, O < -1402 ? O - 1 : O) : O < 60 ? O - 1 : O;
}
function numdate(F) {
  if (F >= 60 && F < 61) return F;
  var x = /* @__PURE__ */ new Date();
  return x.setTime((F > 60 ? F : F + 1) * 24 * 60 * 60 * 1e3 + dnthresh), x;
}
function parse_isodur(F) {
  var x = 0, w = 0, O = !1, D = F.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);
  if (!D) throw new Error("|" + F + "| is not an ISO8601 Duration");
  for (var U = 1; U != D.length; ++U)
    if (D[U]) {
      switch (w = 1, U > 3 && (O = !0), D[U].slice(D[U].length - 1)) {
        case "Y":
          throw new Error("Unsupported ISO Duration Field: " + D[U].slice(D[U].length - 1));
        case "D":
          w *= 24;
        /* falls through */
        case "H":
          w *= 60;
        /* falls through */
        case "M":
          if (O) w *= 60;
          else throw new Error("Unsupported ISO Duration Field: M");
      }
      x += w * parseInt(D[U], 10);
    }
  return x;
}
var pdre1 = /^(\d+):(\d+)(:\d+)?(\.\d+)?$/, pdre2 = /^(\d+)-(\d+)-(\d+)$/, pdre3 = /^(\d+)-(\d+)-(\d+)[T ](\d+):(\d+)(:\d+)?(\.\d+)?$/;
function parseDate(F, x) {
  if (F instanceof Date) return F;
  var w = F.match(pdre1);
  if (w) return new Date((x ? dnthresh2 : dnthresh1) + ((parseInt(w[1], 10) * 60 + parseInt(w[2], 10)) * 60 + (w[3] ? parseInt(w[3].slice(1), 10) : 0)) * 1e3 + (w[4] ? parseInt((w[4] + "000").slice(1, 4), 10) : 0));
  if (w = F.match(pdre2), w) return new Date(Date.UTC(+w[1], +w[2] - 1, +w[3], 0, 0, 0, 0));
  if (w = F.match(pdre3), w) return new Date(Date.UTC(+w[1], +w[2] - 1, +w[3], +w[4], +w[5], w[6] && parseInt(w[6].slice(1), 10) || 0, w[7] && parseInt((w[7] + "0000").slice(1, 4), 10) || 0));
  var O = new Date(F);
  return O;
}
function cc2str(F, x) {
  if (has_buf && Buffer.isBuffer(F)) {
    if (x && buf_utf16le) {
      if (F[0] == 255 && F[1] == 254) return utf8write(F.slice(2).toString("utf16le"));
      if (F[1] == 254 && F[2] == 255) return utf8write(utf16beread(F.slice(2).toString("binary")));
    }
    return F.toString("binary");
  }
  if (typeof TextDecoder < "u") try {
    if (x) {
      if (F[0] == 255 && F[1] == 254) return utf8write(new TextDecoder("utf-16le").decode(F.slice(2)));
      if (F[0] == 254 && F[1] == 255) return utf8write(new TextDecoder("utf-16be").decode(F.slice(2)));
    }
    var w = {
      "€": "",
      "‚": "",
      ƒ: "",
      "„": "",
      "…": "",
      "†": "",
      "‡": "",
      "ˆ": "",
      "‰": "",
      Š: "",
      "‹": "",
      Œ: "",
      Ž: "",
      "‘": "",
      "’": "",
      "“": "",
      "”": "",
      "•": "",
      "–": "",
      "—": "",
      "˜": "",
      "™": "",
      š: "",
      "›": "",
      œ: "",
      ž: "",
      Ÿ: ""
    };
    return Array.isArray(F) && (F = new Uint8Array(F)), new TextDecoder("latin1").decode(F).replace(/[€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ]/g, function(U) {
      return w[U] || U;
    });
  } catch {
  }
  var O = [], D = 0;
  try {
    for (D = 0; D < F.length - 65536; D += 65536) O.push(String.fromCharCode.apply(0, F.slice(D, D + 65536)));
    O.push(String.fromCharCode.apply(0, F.slice(D)));
  } catch {
    try {
      for (; D < F.length - 16384; D += 16384) O.push(String.fromCharCode.apply(0, F.slice(D, D + 16384)));
      O.push(String.fromCharCode.apply(0, F.slice(D)));
    } catch {
      for (; D != F.length; ++D) O.push(String.fromCharCode(F[D]));
    }
  }
  return O.join("");
}
function dup(F) {
  if (typeof JSON < "u" && !Array.isArray(F)) return JSON.parse(JSON.stringify(F));
  if (typeof F != "object" || F == null) return F;
  if (F instanceof Date) return new Date(F.getTime());
  var x = {};
  for (var w in F) Object.prototype.hasOwnProperty.call(F, w) && (x[w] = dup(F[w]));
  return x;
}
function fill(F, x) {
  for (var w = ""; w.length < x; ) w += F;
  return w;
}
function fuzzynum(F) {
  var x = Number(F);
  if (!isNaN(x)) return isFinite(x) ? x : NaN;
  if (!/\d/.test(F)) return x;
  var w = 1, O = F.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
    return w *= 100, "";
  });
  return !isNaN(x = Number(O)) || (O = O.replace(/[(]([^()]*)[)]/, function(D, U) {
    return w = -w, U;
  }), !isNaN(x = Number(O))) ? x / w : x;
}
var FDRE1 = /^(0?\d|1[0-2])(?:|:([0-5]?\d)(?:|(\.\d+)(?:|:([0-5]?\d))|:([0-5]?\d)(|\.\d+)))\s+([ap])m?$/, FDRE2 = /^([01]?\d|2[0-3])(?:|:([0-5]?\d)(?:|(\.\d+)(?:|:([0-5]?\d))|:([0-5]?\d)(|\.\d+)))$/, FDISO = /^(\d+)-(\d+)-(\d+)[T ](\d+):(\d+)(:\d+)(\.\d+)?[Z]?$/, utc_append_works = (/* @__PURE__ */ new Date("6/9/69 00:00 UTC")).valueOf() == -177984e5;
function fuzzytime1(F) {
  return F[2] ? F[3] ? F[4] ? new Date(Date.UTC(1899, 11, 31, +F[1] % 12 + (F[7] == "p" ? 12 : 0), +F[2], +F[4], parseFloat(F[3]) * 1e3)) : new Date(Date.UTC(1899, 11, 31, F[7] == "p" ? 12 : 0, +F[1], +F[2], parseFloat(F[3]) * 1e3)) : F[5] ? new Date(Date.UTC(1899, 11, 31, +F[1] % 12 + (F[7] == "p" ? 12 : 0), +F[2], +F[5], F[6] ? parseFloat(F[6]) * 1e3 : 0)) : new Date(Date.UTC(1899, 11, 31, +F[1] % 12 + (F[7] == "p" ? 12 : 0), +F[2], 0, 0)) : new Date(Date.UTC(1899, 11, 31, +F[1] % 12 + (F[7] == "p" ? 12 : 0), 0, 0, 0));
}
function fuzzytime2(F) {
  return F[2] ? F[3] ? F[4] ? new Date(Date.UTC(1899, 11, 31, +F[1], +F[2], +F[4], parseFloat(F[3]) * 1e3)) : new Date(Date.UTC(1899, 11, 31, 0, +F[1], +F[2], parseFloat(F[3]) * 1e3)) : F[5] ? new Date(Date.UTC(1899, 11, 31, +F[1], +F[2], +F[5], F[6] ? parseFloat(F[6]) * 1e3 : 0)) : new Date(Date.UTC(1899, 11, 31, +F[1], +F[2], 0, 0)) : new Date(Date.UTC(1899, 11, 31, +F[1], 0, 0, 0));
}
var lower_months = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function fuzzydate(F) {
  if (FDISO.test(F)) return F.indexOf("Z") == -1 ? local_to_utc(new Date(F)) : new Date(F);
  var x = F.toLowerCase(), w = x.replace(/\s+/g, " ").trim(), O = w.match(FDRE1);
  if (O) return fuzzytime1(O);
  if (O = w.match(FDRE2), O) return fuzzytime2(O);
  if (O = w.match(pdre3), O) return new Date(Date.UTC(+O[1], +O[2] - 1, +O[3], +O[4], +O[5], O[6] && parseInt(O[6].slice(1), 10) || 0, O[7] && parseInt((O[7] + "0000").slice(1, 4), 10) || 0));
  var D = new Date(utc_append_works && F.indexOf("UTC") == -1 ? F + " UTC" : F), U = /* @__PURE__ */ new Date(NaN), W = D.getYear();
  D.getMonth();
  var X = D.getDate();
  if (isNaN(X)) return U;
  if (x.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
    if (x = x.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, ""), x.length > 3 && lower_months.indexOf(x) == -1) return U;
  } else if (x.replace(/[ap]m?/, "").match(/[a-z]/)) return U;
  return W < 0 || W > 8099 || F.match(/[^-0-9:,\/\\\ ]/) ? U : D;
}
var split_regex = /* @__PURE__ */ function() {
  var F = "abacaba".split(/(:?b)/i).length == 5;
  return function(w, O, D) {
    if (F || typeof O == "string") return w.split(O);
    for (var U = w.split(O), W = [U[0]], X = 1; X < U.length; ++X)
      W.push(D), W.push(U[X]);
    return W;
  };
}();
function utc_to_local(F) {
  return new Date(F.getUTCFullYear(), F.getUTCMonth(), F.getUTCDate(), F.getUTCHours(), F.getUTCMinutes(), F.getUTCSeconds(), F.getUTCMilliseconds());
}
function local_to_utc(F) {
  return new Date(Date.UTC(F.getFullYear(), F.getMonth(), F.getDate(), F.getHours(), F.getMinutes(), F.getSeconds(), F.getMilliseconds()));
}
function remove_doctype(F) {
  var x = F.slice(0, 1024), w = x.indexOf("<!DOCTYPE");
  if (w == -1) return F;
  var O = F.match(/<[\w]/);
  return O ? F.slice(0, w) + F.slice(O.index) : F;
}
function str_match_ng(F, x, w) {
  for (var O = [], D = F.indexOf(x); D > -1; ) {
    var U = F.indexOf(w, D + x.length);
    if (U == -1) break;
    O.push(F.slice(D, U + w.length)), D = F.indexOf(x, U + w.length);
  }
  return O.length > 0 ? O : null;
}
function str_remove_ng(F, x, w) {
  var O = [], D = 0, U = F.indexOf(x);
  if (U == -1) return F;
  for (; U > -1; ) {
    O.push(F.slice(D, U));
    var W = F.indexOf(w, U + x.length);
    if (W == -1) break;
    (U = F.indexOf(x, D = W + w.length)) == -1 && O.push(F.slice(D));
  }
  return O.join("");
}
var xml_boundary = { " ": 1, "	": 1, "\r": 1, "\n": 1, ">": 1 };
function str_match_xml(F, x) {
  for (var w = F.indexOf("<" + x), O = x.length + 1, D = F.length; w >= 0 && w <= D - O && !xml_boundary[F.charAt(w + O)]; ) w = F.indexOf("<" + x, w + 1);
  if (w === -1) return null;
  var U = F.indexOf(">", w + x.length);
  if (U === -1) return null;
  var W = "</" + x + ">", X = F.indexOf(W, U);
  return X == -1 ? null : [F.slice(w, X + W.length), F.slice(U + 1, X)];
}
var str_match_xml_ns = /* @__PURE__ */ function() {
  var F = {};
  return function(w, O) {
    var D = F[O];
    D || (F[O] = D = [
      new RegExp("<(?:\\w+:)?" + O + "\\b[^<>]*>", "g"),
      new RegExp("</(?:\\w+:)?" + O + ">", "g")
    ]), D[0].lastIndex = D[1].lastIndex = 0;
    var U = D[0].exec(w);
    if (!U) return null;
    var W = U.index, X = D[0].lastIndex;
    if (D[1].lastIndex = D[0].lastIndex, U = D[1].exec(w), !U) return null;
    var G = U.index, Y = D[1].lastIndex;
    return [w.slice(W, Y), w.slice(X, G)];
  };
}(), str_match_xml_ns_g = /* @__PURE__ */ function() {
  var F = {};
  return function(w, O) {
    var D = [], U = F[O];
    U || (F[O] = U = [
      new RegExp("<(?:\\w+:)?" + O + "\\b[^<>]*>", "g"),
      new RegExp("</(?:\\w+:)?" + O + ">", "g")
    ]), U[0].lastIndex = U[1].lastIndex = 0;
    for (var W; W = U[0].exec(w); ) {
      var X = W.index;
      if (U[1].lastIndex = U[0].lastIndex, W = U[1].exec(w), !W) return null;
      var G = U[1].lastIndex;
      D.push(w.slice(X, G)), U[0].lastIndex = U[1].lastIndex;
    }
    return D.length == 0 ? null : D;
  };
}(), str_remove_xml_ns_g = /* @__PURE__ */ function() {
  var F = {};
  return function(w, O) {
    var D = [], U = F[O];
    U || (F[O] = U = [
      new RegExp("<(?:\\w+:)?" + O + "\\b[^<>]*>", "g"),
      new RegExp("</(?:\\w+:)?" + O + ">", "g")
    ]), U[0].lastIndex = U[1].lastIndex = 0;
    for (var W, X = 0, G = 0; W = U[0].exec(w); ) {
      if (X = W.index, D.push(w.slice(G, X)), G = X, U[1].lastIndex = U[0].lastIndex, W = U[1].exec(w), !W) return null;
      G = U[1].lastIndex, U[0].lastIndex = U[1].lastIndex;
    }
    return D.push(w.slice(G)), D.length == 0 ? "" : D.join("");
  };
}(), str_match_xml_ig = /* @__PURE__ */ function() {
  var F = {};
  return function(w, O) {
    var D = [], U = F[O];
    U || (F[O] = U = [
      new RegExp("<" + O + "\\b[^<>]*>", "ig"),
      new RegExp("</" + O + ">", "ig")
    ]), U[0].lastIndex = U[1].lastIndex = 0;
    for (var W; W = U[0].exec(w); ) {
      var X = W.index;
      if (U[1].lastIndex = U[0].lastIndex, W = U[1].exec(w), !W) return null;
      var G = U[1].lastIndex;
      D.push(w.slice(X, G)), U[0].lastIndex = U[1].lastIndex;
    }
    return D.length == 0 ? null : D;
  };
}();
function getdatastr(F) {
  return F ? F.content && F.type ? cc2str(F.content, !0) : F.data ? debom(F.data) : F.asNodeBuffer && has_buf ? debom(F.asNodeBuffer().toString("binary")) : F.asBinary ? debom(F.asBinary()) : F._data && F._data.getContent ? debom(cc2str(Array.prototype.slice.call(F._data.getContent(), 0))) : null : null;
}
function getdatabin(F) {
  if (!F) return null;
  if (F.data) return char_codes(F.data);
  if (F.asNodeBuffer && has_buf) return F.asNodeBuffer();
  if (F._data && F._data.getContent) {
    var x = F._data.getContent();
    return typeof x == "string" ? char_codes(x) : Array.prototype.slice.call(x);
  }
  return F.content && F.type ? F.content : null;
}
function getdata(F) {
  return F && F.name.slice(-4) === ".bin" ? getdatabin(F) : getdatastr(F);
}
function safegetzipfile(F, x) {
  for (var w = F.FullPaths || keys(F.files), O = x.toLowerCase().replace(/[\/]/g, "\\"), D = O.replace(/\\/g, "/"), U = 0; U < w.length; ++U) {
    var W = w[U].replace(/^Root Entry[\/]/, "").toLowerCase();
    if (O == W || D == W) return F.files ? F.files[w[U]] : F.FileIndex[U];
  }
  return null;
}
function getzipfile(F, x) {
  var w = safegetzipfile(F, x);
  if (w == null) throw new Error("Cannot find file " + x + " in zip");
  return w;
}
function getzipdata(F, x, w) {
  if (!w) return getdata(getzipfile(F, x));
  if (!x) return null;
  try {
    return getzipdata(F, x);
  } catch {
    return null;
  }
}
function getzipstr(F, x, w) {
  if (!w) return getdatastr(getzipfile(F, x));
  if (!x) return null;
  try {
    return getzipstr(F, x);
  } catch {
    return null;
  }
}
function getzipbin(F, x, w) {
  return getdatabin(getzipfile(F, x));
}
function zipentries(F) {
  for (var x = F.FullPaths || keys(F.files), w = [], O = 0; O < x.length; ++O) x[O].slice(-1) != "/" && w.push(x[O].replace(/^Root Entry[\/]/, ""));
  return w.sort();
}
function zip_add_file(F, x, w) {
  if (F.FullPaths) {
    if (Array.isArray(w) && typeof w[0] == "string" && (w = w.join("")), typeof w == "string") {
      var O;
      return has_buf ? O = Buffer_from(w) : O = utf8decode(w), CFB.utils.cfb_add(F, x, O);
    }
    CFB.utils.cfb_add(F, x, w);
  } else F.file(x, w);
}
function zip_new() {
  return CFB.utils.cfb_new();
}
function zip_read(F, x) {
  switch (x.type) {
    case "base64":
      return CFB.read(F, { type: "base64" });
    case "binary":
      return CFB.read(F, { type: "binary" });
    case "buffer":
    case "array":
      return CFB.read(F, { type: "buffer" });
  }
  throw new Error("Unrecognized type " + x.type);
}
function resolve_path(F, x) {
  if (F.charAt(0) == "/") return F.slice(1);
  var w = x.split("/");
  x.slice(-1) != "/" && w.pop();
  for (var O = F.split("/"); O.length !== 0; ) {
    var D = O.shift();
    D === ".." ? w.pop() : D !== "." && w.push(D);
  }
  return w.join("/");
}
var XML_HEADER = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r
`, attregexg = /\s([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g, tagregex1 = /<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?<>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'"<>\s=]+))*\s*[\/\?]?>/mg, tagregex2 = /<[^<>]*>/g, tagregex = /* @__PURE__ */ XML_HEADER.match(tagregex1) ? tagregex1 : tagregex2, nsregex = /<\w*:/, nsregex2 = /<(\/?)\w+:/;
function parsexmltag(F, x, w) {
  for (var O = {}, D = 0, U = 0; D !== F.length && !((U = F.charCodeAt(D)) === 32 || U === 10 || U === 13); ++D) ;
  if (x || (O[0] = F.slice(0, D)), D === F.length) return O;
  var W = F.match(attregexg), X = 0, G = "", Y = 0, K = "", Z = "", q = 1;
  if (W) for (Y = 0; Y != W.length; ++Y) {
    for (Z = W[Y].slice(1), U = 0; U != Z.length && Z.charCodeAt(U) !== 61; ++U) ;
    for (K = Z.slice(0, U).trim(); Z.charCodeAt(U + 1) == 32; ) ++U;
    for (q = (D = Z.charCodeAt(U + 1)) == 34 || D == 39 ? 1 : 0, G = Z.slice(U + 1 + q, Z.length - q), X = 0; X != K.length && K.charCodeAt(X) !== 58; ++X) ;
    if (X === K.length)
      K.indexOf("_") > 0 && (K = K.slice(0, K.indexOf("_"))), O[K] = G, O[K.toLowerCase()] = G;
    else {
      var J = (X === 5 && K.slice(0, 5) === "xmlns" ? "xmlns" : "") + K.slice(X + 1);
      if (O[J] && K.slice(X - 3, X) == "ext") continue;
      O[J] = G, O[J.toLowerCase()] = G;
    }
  }
  return O;
}
function parsexmltagraw(F, x, w) {
  for (var O = {}, D = 0, U = 0; D !== F.length && !((U = F.charCodeAt(D)) === 32 || U === 10 || U === 13); ++D) ;
  if (D === F.length) return O;
  var W = F.match(attregexg), X = "", G = 0, Y = "", K = "", Z = 1;
  if (W) for (G = 0; G != W.length; ++G) {
    for (K = W[G].slice(1), U = 0; U != K.length && K.charCodeAt(U) !== 61; ++U) ;
    for (Y = K.slice(0, U).trim(); K.charCodeAt(U + 1) == 32; ) ++U;
    Z = (D = K.charCodeAt(U + 1)) == 34 || D == 39 ? 1 : 0, X = K.slice(U + 1 + Z, K.length - Z), Y.indexOf("_") > 0 && (Y = Y.slice(0, Y.indexOf("_"))), O[Y] = X, O[Y.toLowerCase()] = X;
  }
  return O;
}
function strip_ns(F) {
  return F.replace(nsregex2, "<$1");
}
var encodings = {
  "&quot;": '"',
  "&apos;": "'",
  "&gt;": ">",
  "&lt;": "<",
  "&amp;": "&"
}, rencoding = /* @__PURE__ */ evert(encodings), unescapexml = /* @__PURE__ */ function() {
  var F = /&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/ig, x = /_x([\da-fA-F]{4})_/ig;
  function w(O) {
    var D = O + "", U = D.indexOf("<![CDATA[");
    if (U == -1) return D.replace(F, function(X, G) {
      return encodings[X] || String.fromCharCode(parseInt(G, X.indexOf("x") > -1 ? 16 : 10)) || X;
    }).replace(x, function(X, G) {
      return String.fromCharCode(parseInt(G, 16));
    });
    var W = D.indexOf("]]>");
    return w(D.slice(0, U)) + D.slice(U + 9, W) + w(D.slice(W + 3));
  }
  return function(D, U) {
    var W = w(D);
    return U ? W.replace(/\r\n/g, `
`) : W;
  };
}(), decregex = /[&<>'"]/g, charegex = /[\u0000-\u0008\u000b-\u001f\uFFFE-\uFFFF]/g;
function escapexml(F) {
  var x = F + "";
  return x.replace(decregex, function(w) {
    return rencoding[w];
  }).replace(charegex, function(w) {
    return "_x" + ("000" + w.charCodeAt(0).toString(16)).slice(-4) + "_";
  });
}
function escapexmltag(F) {
  return escapexml(F).replace(/ /g, "_x0020_");
}
var htmlcharegex = /[\u0000-\u001f]/g;
function escapehtml(F) {
  var x = F + "";
  return x.replace(decregex, function(w) {
    return rencoding[w];
  }).replace(/\n/g, "<br/>").replace(htmlcharegex, function(w) {
    return "&#x" + ("000" + w.charCodeAt(0).toString(16)).slice(-4) + ";";
  });
}
function escapexlml(F) {
  var x = F + "";
  return x.replace(decregex, function(w) {
    return rencoding[w];
  }).replace(htmlcharegex, function(w) {
    return "&#x" + w.charCodeAt(0).toString(16).toUpperCase() + ";";
  });
}
var xlml_fixstr = /* @__PURE__ */ function() {
  var F = /&#(\d+);/g;
  function x(w, O) {
    return String.fromCharCode(parseInt(O, 10));
  }
  return function(O) {
    return O.replace(F, x);
  };
}();
function xlml_unfixstr(F) {
  return F.replace(/(\r\n|[\r\n])/g, "&#10;");
}
function parsexmlbool(F) {
  switch (F) {
    case 1:
    case !0:
    case "1":
    case "true":
      return !0;
    case 0:
    case !1:
    case "0":
    case "false":
      return !1;
  }
  return !1;
}
function utf8reada(F) {
  for (var x = "", w = 0, O = 0, D = 0, U = 0, W = 0, X = 0; w < F.length; ) {
    if (O = F.charCodeAt(w++), O < 128) {
      x += String.fromCharCode(O);
      continue;
    }
    if (D = F.charCodeAt(w++), O > 191 && O < 224) {
      W = (O & 31) << 6, W |= D & 63, x += String.fromCharCode(W);
      continue;
    }
    if (U = F.charCodeAt(w++), O < 240) {
      x += String.fromCharCode((O & 15) << 12 | (D & 63) << 6 | U & 63);
      continue;
    }
    W = F.charCodeAt(w++), X = ((O & 7) << 18 | (D & 63) << 12 | (U & 63) << 6 | W & 63) - 65536, x += String.fromCharCode(55296 + (X >>> 10 & 1023)), x += String.fromCharCode(56320 + (X & 1023));
  }
  return x;
}
function utf8readb(F) {
  var x = new_raw_buf(2 * F.length), w, O, D = 1, U = 0, W = 0, X;
  for (O = 0; O < F.length; O += D)
    D = 1, (X = F.charCodeAt(O)) < 128 ? w = X : X < 224 ? (w = (X & 31) * 64 + (F.charCodeAt(O + 1) & 63), D = 2) : X < 240 ? (w = (X & 15) * 4096 + (F.charCodeAt(O + 1) & 63) * 64 + (F.charCodeAt(O + 2) & 63), D = 3) : (D = 4, w = (X & 7) * 262144 + (F.charCodeAt(O + 1) & 63) * 4096 + (F.charCodeAt(O + 2) & 63) * 64 + (F.charCodeAt(O + 3) & 63), w -= 65536, W = 55296 + (w >>> 10 & 1023), w = 56320 + (w & 1023)), W !== 0 && (x[U++] = W & 255, x[U++] = W >>> 8, W = 0), x[U++] = w % 256, x[U++] = w >>> 8;
  return x.slice(0, U).toString("ucs2");
}
function utf8readc(F) {
  return Buffer_from(F, "binary").toString("utf8");
}
var utf8corpus = "foo bar bazâð£", utf8read = has_buf && (/* @__PURE__ */ utf8readc(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readc || /* @__PURE__ */ utf8readb(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readb) || utf8reada, utf8write = has_buf ? function(F) {
  return Buffer_from(F, "utf8").toString("binary");
} : function(F) {
  for (var x = [], w = 0, O = 0, D = 0; w < F.length; )
    switch (O = F.charCodeAt(w++), !0) {
      case O < 128:
        x.push(String.fromCharCode(O));
        break;
      case O < 2048:
        x.push(String.fromCharCode(192 + (O >> 6))), x.push(String.fromCharCode(128 + (O & 63)));
        break;
      case (O >= 55296 && O < 57344):
        O -= 55296, D = F.charCodeAt(w++) - 56320 + (O << 10), x.push(String.fromCharCode(240 + (D >> 18 & 7))), x.push(String.fromCharCode(144 + (D >> 12 & 63))), x.push(String.fromCharCode(128 + (D >> 6 & 63))), x.push(String.fromCharCode(128 + (D & 63)));
        break;
      default:
        x.push(String.fromCharCode(224 + (O >> 12))), x.push(String.fromCharCode(128 + (O >> 6 & 63))), x.push(String.fromCharCode(128 + (O & 63)));
    }
  return x.join("");
}, htmldecode = /* @__PURE__ */ function() {
  var F = [
    ["nbsp", " "],
    ["middot", "·"],
    ["quot", '"'],
    ["apos", "'"],
    ["gt", ">"],
    ["lt", "<"],
    ["amp", "&"]
  ].map(function(x) {
    return [new RegExp("&" + x[0] + ";", "ig"), x[1]];
  });
  return function(w) {
    for (var O = w.replace(/^[\t\n\r ]+/, "").replace(/(^|[^\t\n\r ])[\t\n\r ]+$/, "$1").replace(/>\s+/g, ">").replace(/\b\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, `
`).replace(/<[^<>]*>/g, ""), D = 0; D < F.length; ++D) O = O.replace(F[D][0], F[D][1]);
    return O;
  };
}(), vtvregex = /<\/?(?:vt:)?variant>/g, vtmregex = /<(?:vt:)([^<"'>]*)>([\s\S]*)</;
function parseVector(F, x) {
  var w = parsexmltag(F), O = str_match_xml_ns_g(F, w.baseType) || [], D = [];
  if (O.length != w.size) {
    if (x.WTF) throw new Error("unexpected vector length " + O.length + " != " + w.size);
    return D;
  }
  return O.forEach(function(U) {
    var W = U.replace(vtvregex, "").match(vtmregex);
    W && D.push({ v: utf8read(W[2]), t: W[1] });
  }), D;
}
var wtregex = /(^\s|\s$|\n)/;
function writetag(F, x) {
  return "<" + F + (x.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + x + "</" + F + ">";
}
function wxt_helper(F) {
  return keys(F).map(function(x) {
    return " " + x + '="' + F[x] + '"';
  }).join("");
}
function writextag(F, x, w) {
  return "<" + F + (w != null ? wxt_helper(w) : "") + (x != null ? (x.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + x + "</" + F : "/") + ">";
}
function write_w3cdtf(F, x) {
  try {
    return F.toISOString().replace(/\.\d*/, "");
  } catch (w) {
    if (x) throw w;
  }
  return "";
}
function write_vt(F, x) {
  switch (typeof F) {
    case "string":
      var w = writextag("vt:lpwstr", escapexml(F));
      return w = w.replace(/&quot;/g, "_x0022_"), w;
    case "number":
      return writextag((F | 0) == F ? "vt:i4" : "vt:r8", escapexml(String(F)));
    case "boolean":
      return writextag("vt:bool", F ? "true" : "false");
  }
  if (F instanceof Date) return writextag("vt:filetime", write_w3cdtf(F));
  throw new Error("Unable to serialize " + F);
}
function xlml_normalize(F) {
  if (has_buf && /*::typeof Buffer !== "undefined" && d != null && d instanceof Buffer &&*/
  Buffer.isBuffer(F)) return F.toString("utf8");
  if (typeof F == "string") return F;
  if (typeof Uint8Array < "u" && F instanceof Uint8Array) return utf8read(a2s(ab2a(F)));
  throw new Error("Bad input format: expected Buffer or string");
}
var xlmlregex = /<([\/]?)([^\s?><!\/:"]*:|)([^\s?<>:\/"]+)(?:\s+[^<>=?"'\s]+="[^"]*?")*\s*[\/]?>/mg, XMLNS = {
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
  CT: "http://schemas.openxmlformats.org/package/2006/content-types",
  RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
  TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
  dc: "http://purl.org/dc/elements/1.1/",
  dcterms: "http://purl.org/dc/terms/",
  dcmitype: "http://purl.org/dc/dcmitype/",
  mx: "http://schemas.microsoft.com/office/mac/excel/2008/main",
  r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  sjs: "http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",
  vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
  xsi: "http://www.w3.org/2001/XMLSchema-instance",
  xsd: "http://www.w3.org/2001/XMLSchema"
}, XMLNS_main = [
  "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "http://purl.oclc.org/ooxml/spreadsheetml/main",
  "http://schemas.microsoft.com/office/excel/2006/main",
  "http://schemas.microsoft.com/office/excel/2006/2"
], XLMLNS = {
  o: "urn:schemas-microsoft-com:office:office",
  x: "urn:schemas-microsoft-com:office:excel",
  ss: "urn:schemas-microsoft-com:office:spreadsheet",
  dt: "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
  mv: "http://macVmlSchemaUri",
  v: "urn:schemas-microsoft-com:vml",
  html: "http://www.w3.org/TR/REC-html40"
};
function read_double_le(F, x) {
  for (var w = 1 - 2 * (F[x + 7] >>> 7), O = ((F[x + 7] & 127) << 4) + (F[x + 6] >>> 4 & 15), D = F[x + 6] & 15, U = 5; U >= 0; --U) D = D * 256 + F[x + U];
  return O == 2047 ? D == 0 ? w * (1 / 0) : NaN : (O == 0 ? O = -1022 : (O -= 1023, D += Math.pow(2, 52)), w * Math.pow(2, O - 52) * D);
}
function write_double_le(F, x, w) {
  var O = (x < 0 || 1 / x == -1 / 0 ? 1 : 0) << 7, D = 0, U = 0, W = O ? -x : x;
  isFinite(W) ? W == 0 ? D = U = 0 : (D = Math.floor(Math.log(W) / Math.LN2), U = W * Math.pow(2, 52 - D), D <= -1023 && (!isFinite(U) || U < Math.pow(2, 52)) ? D = -1022 : (U -= Math.pow(2, 52), D += 1023)) : (D = 2047, U = isNaN(x) ? 26985 : 0);
  for (var X = 0; X <= 5; ++X, U /= 256) F[w + X] = U & 255;
  F[w + 6] = (D & 15) << 4 | U & 15, F[w + 7] = D >> 4 | O;
}
var ___toBuffer = function(F) {
  for (var x = [], w = 10240, O = 0; O < F[0].length; ++O) if (F[0][O]) for (var D = 0, U = F[0][O].length; D < U; D += w) x.push.apply(x, F[0][O].slice(D, D + w));
  return x;
}, __toBuffer = has_buf ? function(F) {
  return F[0].length > 0 && Buffer.isBuffer(F[0][0]) ? Buffer.concat(F[0].map(function(x) {
    return Buffer.isBuffer(x) ? x : Buffer_from(x);
  })) : ___toBuffer(F);
} : ___toBuffer, ___utf16le = function(F, x, w) {
  for (var O = [], D = x; D < w; D += 2) O.push(String.fromCharCode(__readUInt16LE(F, D)));
  return O.join("").replace(chr0, "");
}, __utf16le = has_buf ? function(F, x, w) {
  return !Buffer.isBuffer(F) || !buf_utf16le ? ___utf16le(F, x, w) : F.toString("utf16le", x, w).replace(chr0, "");
} : ___utf16le, ___hexlify = function(F, x, w) {
  for (var O = [], D = x; D < x + w; ++D) O.push(("0" + F[D].toString(16)).slice(-2));
  return O.join("");
}, __hexlify = has_buf ? function(F, x, w) {
  return Buffer.isBuffer(F) ? F.toString("hex", x, x + w) : ___hexlify(F, x, w);
} : ___hexlify, ___utf8 = function(F, x, w) {
  for (var O = [], D = x; D < w; D++) O.push(String.fromCharCode(__readUInt8(F, D)));
  return O.join("");
}, __utf8 = has_buf ? function F(x, w, O) {
  return Buffer.isBuffer(x) ? x.toString("utf8", w, O) : ___utf8(x, w, O);
} : ___utf8, ___lpstr = function(F, x) {
  var w = __readUInt32LE(F, x);
  return w > 0 ? __utf8(F, x + 4, x + 4 + w - 1) : "";
}, __lpstr = ___lpstr, ___cpstr = function(F, x) {
  var w = __readUInt32LE(F, x);
  return w > 0 ? __utf8(F, x + 4, x + 4 + w - 1) : "";
}, __cpstr = ___cpstr, ___lpwstr = function(F, x) {
  var w = 2 * __readUInt32LE(F, x);
  return w > 0 ? __utf8(F, x + 4, x + 4 + w - 1) : "";
}, __lpwstr = ___lpwstr, ___lpp4 = function F(x, w) {
  var O = __readUInt32LE(x, w);
  return O > 0 ? __utf16le(x, w + 4, w + 4 + O) : "";
}, __lpp4 = ___lpp4, ___8lpp4 = function(F, x) {
  var w = __readUInt32LE(F, x);
  return w > 0 ? __utf8(F, x + 4, x + 4 + w) : "";
}, __8lpp4 = ___8lpp4, ___double = function(F, x) {
  return read_double_le(F, x);
}, __double = ___double, is_buf = function F(x) {
  return Array.isArray(x) || typeof Uint8Array < "u" && x instanceof Uint8Array;
};
has_buf && (__lpstr = function(x, w) {
  if (!Buffer.isBuffer(x)) return ___lpstr(x, w);
  var O = x.readUInt32LE(w);
  return O > 0 ? x.toString("utf8", w + 4, w + 4 + O - 1) : "";
}, __cpstr = function(x, w) {
  if (!Buffer.isBuffer(x)) return ___cpstr(x, w);
  var O = x.readUInt32LE(w);
  return O > 0 ? x.toString("utf8", w + 4, w + 4 + O - 1) : "";
}, __lpwstr = function(x, w) {
  if (!Buffer.isBuffer(x) || !buf_utf16le) return ___lpwstr(x, w);
  var O = 2 * x.readUInt32LE(w);
  return x.toString("utf16le", w + 4, w + 4 + O - 1);
}, __lpp4 = function(x, w) {
  if (!Buffer.isBuffer(x) || !buf_utf16le) return ___lpp4(x, w);
  var O = x.readUInt32LE(w);
  return x.toString("utf16le", w + 4, w + 4 + O);
}, __8lpp4 = function(x, w) {
  if (!Buffer.isBuffer(x)) return ___8lpp4(x, w);
  var O = x.readUInt32LE(w);
  return x.toString("utf8", w + 4, w + 4 + O);
}, __double = function(x, w) {
  return Buffer.isBuffer(x) ? x.readDoubleLE(w) : ___double(x, w);
}, is_buf = function(x) {
  return Buffer.isBuffer(x) || Array.isArray(x) || typeof Uint8Array < "u" && x instanceof Uint8Array;
});
function cpdoit() {
  __utf16le = function(F, x, w) {
    return $cptable.utils.decode(1200, F.slice(x, w)).replace(chr0, "");
  }, __utf8 = function(F, x, w) {
    return $cptable.utils.decode(65001, F.slice(x, w));
  }, __lpstr = function(F, x) {
    var w = __readUInt32LE(F, x);
    return w > 0 ? $cptable.utils.decode(current_ansi, F.slice(x + 4, x + 4 + w - 1)) : "";
  }, __cpstr = function(F, x) {
    var w = __readUInt32LE(F, x);
    return w > 0 ? $cptable.utils.decode(current_codepage, F.slice(x + 4, x + 4 + w - 1)) : "";
  }, __lpwstr = function(F, x) {
    var w = 2 * __readUInt32LE(F, x);
    return w > 0 ? $cptable.utils.decode(1200, F.slice(x + 4, x + 4 + w - 1)) : "";
  }, __lpp4 = function(F, x) {
    var w = __readUInt32LE(F, x);
    return w > 0 ? $cptable.utils.decode(1200, F.slice(x + 4, x + 4 + w)) : "";
  }, __8lpp4 = function(F, x) {
    var w = __readUInt32LE(F, x);
    return w > 0 ? $cptable.utils.decode(65001, F.slice(x + 4, x + 4 + w)) : "";
  };
}
typeof $cptable < "u" && cpdoit();
var __readUInt8 = function(F, x) {
  return F[x];
}, __readUInt16LE = function(F, x) {
  return F[x + 1] * 256 + F[x];
}, __readInt16LE = function(F, x) {
  var w = F[x + 1] * 256 + F[x];
  return w < 32768 ? w : (65535 - w + 1) * -1;
}, __readUInt32LE = function(F, x) {
  return F[x + 3] * (1 << 24) + (F[x + 2] << 16) + (F[x + 1] << 8) + F[x];
}, __readInt32LE = function(F, x) {
  return F[x + 3] << 24 | F[x + 2] << 16 | F[x + 1] << 8 | F[x];
}, __readInt32BE = function(F, x) {
  return F[x] << 24 | F[x + 1] << 16 | F[x + 2] << 8 | F[x + 3];
};
function ReadShift(F, x) {
  var w = "", O, D, U = [], W, X, G, Y;
  switch (x) {
    case "dbcs":
      if (Y = this.l, has_buf && Buffer.isBuffer(this) && buf_utf16le) w = this.slice(this.l, this.l + 2 * F).toString("utf16le");
      else for (G = 0; G < F; ++G)
        w += String.fromCharCode(__readUInt16LE(this, Y)), Y += 2;
      F *= 2;
      break;
    case "utf8":
      w = __utf8(this, this.l, this.l + F);
      break;
    case "utf16le":
      F *= 2, w = __utf16le(this, this.l, this.l + F);
      break;
    case "wstr":
      if (typeof $cptable < "u") w = $cptable.utils.decode(current_codepage, this.slice(this.l, this.l + 2 * F));
      else return ReadShift.call(this, F, "dbcs");
      F = 2 * F;
      break;
    /* [MS-OLEDS] 2.1.4 LengthPrefixedAnsiString */
    case "lpstr-ansi":
      w = __lpstr(this, this.l), F = 4 + __readUInt32LE(this, this.l);
      break;
    case "lpstr-cp":
      w = __cpstr(this, this.l), F = 4 + __readUInt32LE(this, this.l);
      break;
    /* [MS-OLEDS] 2.1.5 LengthPrefixedUnicodeString */
    case "lpwstr":
      w = __lpwstr(this, this.l), F = 4 + 2 * __readUInt32LE(this, this.l);
      break;
    /* [MS-OFFCRYPTO] 2.1.2 Length-Prefixed Padded Unicode String (UNICODE-LP-P4) */
    case "lpp4":
      F = 4 + __readUInt32LE(this, this.l), w = __lpp4(this, this.l), F & 2 && (F += 2);
      break;
    /* [MS-OFFCRYPTO] 2.1.3 Length-Prefixed UTF-8 String (UTF-8-LP-P4) */
    case "8lpp4":
      F = 4 + __readUInt32LE(this, this.l), w = __8lpp4(this, this.l), F & 3 && (F += 4 - (F & 3));
      break;
    case "cstr":
      for (F = 0, w = ""; (W = __readUInt8(this, this.l + F++)) !== 0; ) U.push(_getchar(W));
      w = U.join("");
      break;
    case "_wstr":
      for (F = 0, w = ""; (W = __readUInt16LE(this, this.l + F)) !== 0; )
        U.push(_getchar(W)), F += 2;
      F += 2, w = U.join("");
      break;
    /* sbcs and dbcs support continue records in the SST way TODO codepages */
    case "dbcs-cont":
      for (w = "", Y = this.l, G = 0; G < F; ++G) {
        if (this.lens && this.lens.indexOf(Y) !== -1)
          return W = __readUInt8(this, Y), this.l = Y + 1, X = ReadShift.call(this, F - G, W ? "dbcs-cont" : "sbcs-cont"), U.join("") + X;
        U.push(_getchar(__readUInt16LE(this, Y))), Y += 2;
      }
      w = U.join(""), F *= 2;
      break;
    case "cpstr":
      if (typeof $cptable < "u") {
        w = $cptable.utils.decode(current_codepage, this.slice(this.l, this.l + F));
        break;
      }
    /* falls through */
    case "sbcs-cont":
      for (w = "", Y = this.l, G = 0; G != F; ++G) {
        if (this.lens && this.lens.indexOf(Y) !== -1)
          return W = __readUInt8(this, Y), this.l = Y + 1, X = ReadShift.call(this, F - G, W ? "dbcs-cont" : "sbcs-cont"), U.join("") + X;
        U.push(_getchar(__readUInt8(this, Y))), Y += 1;
      }
      w = U.join("");
      break;
    default:
      switch (F) {
        case 1:
          return O = __readUInt8(this, this.l), this.l++, O;
        case 2:
          return O = (x === "i" ? __readInt16LE : __readUInt16LE)(this, this.l), this.l += 2, O;
        case 4:
        case -4:
          return x === "i" || (this[this.l + 3] & 128) === 0 ? (O = (F > 0 ? __readInt32LE : __readInt32BE)(this, this.l), this.l += 4, O) : (D = __readUInt32LE(this, this.l), this.l += 4, D);
        case 8:
        case -8:
          if (x === "f")
            return F == 8 ? D = __double(this, this.l) : D = __double([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0), this.l += 8, D;
          F = 8;
        /* falls through */
        case 16:
          w = __hexlify(this, this.l, F);
          break;
      }
  }
  return this.l += F, w;
}
var __writeUInt32LE = function(F, x, w) {
  F[w] = x & 255, F[w + 1] = x >>> 8 & 255, F[w + 2] = x >>> 16 & 255, F[w + 3] = x >>> 24 & 255;
}, __writeInt32LE = function(F, x, w) {
  F[w] = x & 255, F[w + 1] = x >> 8 & 255, F[w + 2] = x >> 16 & 255, F[w + 3] = x >> 24 & 255;
}, __writeUInt16LE = function(F, x, w) {
  F[w] = x & 255, F[w + 1] = x >>> 8 & 255;
};
function WriteShift(F, x, w) {
  var O = 0, D = 0;
  if (w === "dbcs") {
    for (D = 0; D != x.length; ++D) __writeUInt16LE(this, x.charCodeAt(D), this.l + 2 * D);
    O = 2 * x.length;
  } else if (w === "sbcs" || w == "cpstr")
    if (typeof $cptable < "u" && current_ansi == 874) {
      for (D = 0; D != x.length; ++D) {
        var U = $cptable.utils.encode(current_ansi, x.charAt(D));
        this[this.l + D] = U[0];
      }
      O = x.length;
    } else if (typeof $cptable < "u" && w == "cpstr") {
      if (U = $cptable.utils.encode(current_codepage, x), U.length == x.length) for (D = 0; D < x.length; ++D) U[D] == 0 && x.charCodeAt(D) != 0 && (U[D] = 95);
      if (U.length == 2 * x.length) for (D = 0; D < x.length; ++D) U[2 * D] == 0 && U[2 * D + 1] == 0 && x.charCodeAt(D) != 0 && (U[2 * D] = 95);
      for (D = 0; D < U.length; ++D) this[this.l + D] = U[D];
      O = U.length;
    } else {
      for (x = x.replace(/[^\x00-\x7F]/g, "_"), D = 0; D != x.length; ++D) this[this.l + D] = x.charCodeAt(D) & 255;
      O = x.length;
    }
  else if (w === "hex") {
    for (; D < F; ++D)
      this[this.l++] = parseInt(x.slice(2 * D, 2 * D + 2), 16) || 0;
    return this;
  } else if (w === "utf16le") {
    var W = Math.min(this.l + F, this.length);
    for (D = 0; D < Math.min(x.length, F); ++D) {
      var X = x.charCodeAt(D);
      this[this.l++] = X & 255, this[this.l++] = X >> 8;
    }
    for (; this.l < W; ) this[this.l++] = 0;
    return this;
  } else switch (F) {
    case 1:
      O = 1, this[this.l] = x & 255;
      break;
    case 2:
      O = 2, this[this.l] = x & 255, x >>>= 8, this[this.l + 1] = x & 255;
      break;
    case 3:
      O = 3, this[this.l] = x & 255, x >>>= 8, this[this.l + 1] = x & 255, x >>>= 8, this[this.l + 2] = x & 255;
      break;
    case 4:
      O = 4, __writeUInt32LE(this, x, this.l);
      break;
    case 8:
      if (O = 8, w === "f") {
        write_double_le(this, x, this.l);
        break;
      }
    /* falls through */
    case 16:
      break;
    case -4:
      O = 4, __writeInt32LE(this, x, this.l);
      break;
  }
  return this.l += O, this;
}
function CheckField(F, x) {
  var w = __hexlify(this, this.l, F.length >> 1);
  if (w !== F) throw new Error(x + "Expected " + F + " saw " + w);
  this.l += F.length >> 1;
}
function prep_blob(F, x) {
  F.l = x, F.read_shift = /*::(*/
  ReadShift, F.chk = CheckField, F.write_shift = WriteShift;
}
function parsenoop(F, x) {
  F.l += x;
}
function new_buf(F) {
  var x = new_raw_buf(F);
  return prep_blob(x, 0), x;
}
function recordhopper(F, x, w) {
  if (F) {
    var O, D, U;
    prep_blob(F, F.l || 0);
    for (var W = F.length, X = 0, G = 0; F.l < W; ) {
      X = F.read_shift(1), X & 128 && (X = (X & 127) + ((F.read_shift(1) & 127) << 7));
      var Y = XLSBRecordEnum[X] || XLSBRecordEnum[65535];
      for (O = F.read_shift(1), U = O & 127, D = 1; D < 4 && O & 128; ++D) U += ((O = F.read_shift(1)) & 127) << 7 * D;
      G = F.l + U;
      var K = Y.f && Y.f(F, U, w);
      if (F.l = G, x(K, Y, X)) return;
    }
  }
}
function buf_array() {
  var F = [], x = has_buf ? 16384 : 2048;
  has_buf && new_buf(x).copy;
  var w = function(K) {
    var Z = new_buf(K);
    return prep_blob(Z, 0), Z;
  }, O = w(x), D = function() {
    O && (O.l && (O.length > O.l && (O = O.slice(0, O.l), O.l = O.length), O.length > 0 && F.push(O)), O = null);
  }, U = function(K) {
    return O && K < O.length - O.l ? O : (D(), O = w(Math.max(K + 1, x)));
  }, W = function() {
    return D(), bconcat(F);
  }, X = function() {
    return D(), F;
  }, G = function(K) {
    D(), O = K, O.l == null && (O.l = O.length), U(x);
  };
  return { next: U, push: G, end: W, _bufs: F, end2: X };
}
function write_record(F, x, w, O) {
  var D = +x, U;
  if (!isNaN(D)) {
    O || (O = XLSBRecordEnum[D].p || (w || []).length || 0), U = 1 + (D >= 128 ? 1 : 0) + 1, O >= 128 && ++U, O >= 16384 && ++U, O >= 2097152 && ++U;
    var W = F.next(U);
    D <= 127 ? W.write_shift(1, D) : (W.write_shift(1, (D & 127) + 128), W.write_shift(1, D >> 7));
    for (var X = 0; X != 4; ++X)
      if (O >= 128)
        W.write_shift(1, (O & 127) + 128), O >>= 7;
      else {
        W.write_shift(1, O);
        break;
      }
    /*:: length != null &&*/
    O > 0 && is_buf(w) && F.push(w);
  }
}
function shift_cell_xls(F, x, w) {
  var O = dup(F);
  if (x.s ? (O.cRel && (O.c += x.s.c), O.rRel && (O.r += x.s.r)) : (O.cRel && (O.c += x.c), O.rRel && (O.r += x.r)), !w || w.biff < 12) {
    for (; O.c >= 256; ) O.c -= 256;
    for (; O.r >= 65536; ) O.r -= 65536;
  }
  return O;
}
function shift_range_xls(F, x, w) {
  var O = dup(F);
  return O.s = shift_cell_xls(O.s, x.s, w), O.e = shift_cell_xls(O.e, x.s, w), O;
}
function encode_cell_xls(F, x) {
  if (F.cRel && F.c < 0)
    for (F = dup(F); F.c < 0; ) F.c += x > 8 ? 16384 : 256;
  if (F.rRel && F.r < 0)
    for (F = dup(F); F.r < 0; ) F.r += x > 8 ? 1048576 : x > 5 ? 65536 : 16384;
  var w = encode_cell(F);
  return !F.cRel && F.cRel != null && (w = fix_col(w)), !F.rRel && F.rRel != null && (w = fix_row(w)), w;
}
function encode_range_xls(F, x) {
  return F.s.r == 0 && !F.s.rRel && F.e.r == (x.biff >= 12 ? 1048575 : x.biff >= 8 ? 65536 : 16384) && !F.e.rRel ? (F.s.cRel ? "" : "$") + encode_col(F.s.c) + ":" + (F.e.cRel ? "" : "$") + encode_col(F.e.c) : F.s.c == 0 && !F.s.cRel && F.e.c == (x.biff >= 12 ? 16383 : 255) && !F.e.cRel ? (F.s.rRel ? "" : "$") + encode_row(F.s.r) + ":" + (F.e.rRel ? "" : "$") + encode_row(F.e.r) : encode_cell_xls(F.s, x.biff) + ":" + encode_cell_xls(F.e, x.biff);
}
function decode_row(F) {
  return parseInt(unfix_row(F), 10) - 1;
}
function encode_row(F) {
  return "" + (F + 1);
}
function fix_row(F) {
  return F.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
}
function unfix_row(F) {
  return F.replace(/\$(\d+)$/, "$1");
}
function decode_col(F) {
  for (var x = unfix_col(F), w = 0, O = 0; O !== x.length; ++O) w = 26 * w + x.charCodeAt(O) - 64;
  return w - 1;
}
function encode_col(F) {
  if (F < 0) throw new Error("invalid column " + F);
  var x = "";
  for (++F; F; F = Math.floor((F - 1) / 26)) x = String.fromCharCode((F - 1) % 26 + 65) + x;
  return x;
}
function fix_col(F) {
  return F.replace(/^([A-Z])/, "$$$1");
}
function unfix_col(F) {
  return F.replace(/^\$([A-Z])/, "$1");
}
function split_cell(F) {
  return F.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
}
function decode_cell(F) {
  for (var x = 0, w = 0, O = 0; O < F.length; ++O) {
    var D = F.charCodeAt(O);
    D >= 48 && D <= 57 ? x = 10 * x + (D - 48) : D >= 65 && D <= 90 && (w = 26 * w + (D - 64));
  }
  return { c: w - 1, r: x - 1 };
}
function encode_cell(F) {
  for (var x = F.c + 1, w = ""; x; x = (x - 1) / 26 | 0) w = String.fromCharCode((x - 1) % 26 + 65) + w;
  return w + (F.r + 1);
}
function decode_range(F) {
  var x = F.indexOf(":");
  return x == -1 ? { s: decode_cell(F), e: decode_cell(F) } : { s: decode_cell(F.slice(0, x)), e: decode_cell(F.slice(x + 1)) };
}
function encode_range(F, x) {
  return typeof x > "u" || typeof x == "number" ? encode_range(F.s, F.e) : (typeof F != "string" && (F = encode_cell(F)), typeof x != "string" && (x = encode_cell(x)), F == x ? F : F + ":" + x);
}
function fix_range(F) {
  var x = decode_range(F);
  return "$" + encode_col(x.s.c) + "$" + encode_row(x.s.r) + ":$" + encode_col(x.e.c) + "$" + encode_row(x.e.r);
}
function formula_quote_sheet_name(F, x) {
  if (!F && !(x && x.biff <= 5 && x.biff >= 2)) throw new Error("empty sheet name");
  return /[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(F) ? "'" + F.replace(/'/g, "''") + "'" : F;
}
function safe_decode_range(F) {
  var x = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } }, w = 0, O = 0, D = 0, U = F.length;
  for (w = 0; O < U && !((D = F.charCodeAt(O) - 64) < 1 || D > 26); ++O)
    w = 26 * w + D;
  for (x.s.c = --w, w = 0; O < U && !((D = F.charCodeAt(O) - 48) < 0 || D > 9); ++O)
    w = 10 * w + D;
  if (x.s.r = --w, O === U || D != 10)
    return x.e.c = x.s.c, x.e.r = x.s.r, x;
  for (++O, w = 0; O != U && !((D = F.charCodeAt(O) - 64) < 1 || D > 26); ++O)
    w = 26 * w + D;
  for (x.e.c = --w, w = 0; O != U && !((D = F.charCodeAt(O) - 48) < 0 || D > 9); ++O)
    w = 10 * w + D;
  return x.e.r = --w, x;
}
function safe_format_cell(F, x) {
  var w = F.t == "d" && x instanceof Date;
  if (F.z != null) try {
    return F.w = SSF_format(F.z, w ? datenum(x) : x);
  } catch {
  }
  try {
    return F.w = SSF_format((F.XF || {}).numFmtId || (w ? 14 : 0), w ? datenum(x) : x);
  } catch {
    return "" + x;
  }
}
function format_cell(F, x, w) {
  return F == null || F.t == null || F.t == "z" ? "" : F.w !== void 0 ? F.w : (F.t == "d" && !F.z && w && w.dateNF && (F.z = w.dateNF), F.t == "e" ? BErr[F.v] || F.v : x == null ? safe_format_cell(F, F.v) : safe_format_cell(F, x));
}
function sheet_to_workbook(F, x) {
  var w = x && x.sheet ? x.sheet : "Sheet1", O = {};
  return O[w] = F, { SheetNames: [w], Sheets: O };
}
function sheet_new(F) {
  var x = {}, w = F || {};
  return w.dense && (x["!data"] = []), x;
}
function sheet_add_aoa(F, x, w) {
  var O = w || {}, D = F ? F["!data"] != null : O.dense, U = F || (D ? { "!data": [] } : {});
  D && !U["!data"] && (U["!data"] = []);
  var W = 0, X = 0;
  if (U && O.origin != null)
    if (typeof O.origin == "number") W = O.origin;
    else {
      var G = typeof O.origin == "string" ? decode_cell(O.origin) : O.origin;
      W = G.r, X = G.c;
    }
  var Y = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
  if (U["!ref"]) {
    var K = safe_decode_range(U["!ref"]);
    Y.s.c = K.s.c, Y.s.r = K.s.r, Y.e.c = Math.max(Y.e.c, K.e.c), Y.e.r = Math.max(Y.e.r, K.e.r), W == -1 && (Y.e.r = W = U["!ref"] ? K.e.r + 1 : 0);
  } else
    Y.s.c = Y.e.c = Y.s.r = Y.e.r = 0;
  for (var Z = [], q = !1, J = 0; J != x.length; ++J)
    if (x[J]) {
      if (!Array.isArray(x[J])) throw new Error("aoa_to_sheet expects an array of arrays");
      var ee = W + J;
      D && (U["!data"][ee] || (U["!data"][ee] = []), Z = U["!data"][ee]);
      for (var re = x[J], te = 0; te != re.length; ++te)
        if (!(typeof re[te] > "u")) {
          var Q = { v: re[te], t: "" }, oe = X + te;
          if (Y.s.r > ee && (Y.s.r = ee), Y.s.c > oe && (Y.s.c = oe), Y.e.r < ee && (Y.e.r = ee), Y.e.c < oe && (Y.e.c = oe), q = !0, re[te] && typeof re[te] == "object" && !Array.isArray(re[te]) && !(re[te] instanceof Date)) Q = re[te];
          else if (Array.isArray(Q.v) && (Q.f = re[te][1], Q.v = Q.v[0]), Q.v === null)
            if (Q.f) Q.t = "n";
            else if (O.nullError)
              Q.t = "e", Q.v = 0;
            else if (O.sheetStubs) Q.t = "z";
            else continue;
          else typeof Q.v == "number" ? isFinite(Q.v) ? Q.t = "n" : isNaN(Q.v) ? (Q.t = "e", Q.v = 15) : (Q.t = "e", Q.v = 7) : typeof Q.v == "boolean" ? Q.t = "b" : Q.v instanceof Date ? (Q.z = O.dateNF || table_fmt[14], O.UTC || (Q.v = local_to_utc(Q.v)), O.cellDates ? (Q.t = "d", Q.w = SSF_format(Q.z, datenum(Q.v, O.date1904))) : (Q.t = "n", Q.v = datenum(Q.v, O.date1904), Q.w = SSF_format(Q.z, Q.v))) : Q.t = "s";
          if (D)
            Z[oe] && Z[oe].z && (Q.z = Z[oe].z), Z[oe] = Q;
          else {
            var ne = encode_col(oe) + (ee + 1);
            U[ne] && U[ne].z && (Q.z = U[ne].z), U[ne] = Q;
          }
        }
    }
  return q && Y.s.c < 104e5 && (U["!ref"] = encode_range(Y)), U;
}
function aoa_to_sheet(F, x) {
  return sheet_add_aoa(null, F, x);
}
function parse_Int32LE(F) {
  return F.read_shift(4, "i");
}
function write_UInt32LE(F, x) {
  return x || (x = new_buf(4)), x.write_shift(4, F), x;
}
function parse_XLWideString(F) {
  var x = F.read_shift(4);
  return x === 0 ? "" : F.read_shift(x, "dbcs");
}
function write_XLWideString(F, x) {
  var w = !1;
  return x == null && (w = !0, x = new_buf(4 + 2 * F.length)), x.write_shift(4, F.length), F.length > 0 && x.write_shift(0, F, "dbcs"), w ? x.slice(0, x.l) : x;
}
function parse_StrRun(F) {
  return { ich: F.read_shift(2), ifnt: F.read_shift(2) };
}
function write_StrRun(F, x) {
  return x || (x = new_buf(4)), x.write_shift(2, 0), x.write_shift(2, 0), x;
}
function parse_RichStr(F, x) {
  var w = F.l, O = F.read_shift(1), D = parse_XLWideString(F), U = [], W = { t: D, h: D };
  if ((O & 1) !== 0) {
    for (var X = F.read_shift(4), G = 0; G != X; ++G) U.push(parse_StrRun(F));
    W.r = U;
  } else W.r = [{ ich: 0, ifnt: 0 }];
  return F.l = w + x, W;
}
function write_RichStr(F, x) {
  var w = !1;
  return x == null && (w = !0, x = new_buf(15 + 4 * F.t.length)), x.write_shift(1, 0), write_XLWideString(F.t, x), w ? x.slice(0, x.l) : x;
}
var parse_BrtCommentText = parse_RichStr;
function write_BrtCommentText(F, x) {
  var w = !1;
  return x == null && (w = !0, x = new_buf(23 + 4 * F.t.length)), x.write_shift(1, 1), write_XLWideString(F.t, x), x.write_shift(4, 1), write_StrRun({ ich: 0, ifnt: 0 }, x), w ? x.slice(0, x.l) : x;
}
function parse_XLSBCell(F) {
  var x = F.read_shift(4), w = F.read_shift(2);
  return w += F.read_shift(1) << 16, F.l++, { c: x, iStyleRef: w };
}
function write_XLSBCell(F, x) {
  return x == null && (x = new_buf(8)), x.write_shift(-4, F.c), x.write_shift(3, F.iStyleRef || F.s), x.write_shift(1, 0), x;
}
function parse_XLSBShortCell(F) {
  var x = F.read_shift(2);
  return x += F.read_shift(1) << 16, F.l++, { c: -1, iStyleRef: x };
}
function write_XLSBShortCell(F, x) {
  return x == null && (x = new_buf(4)), x.write_shift(3, F.iStyleRef || F.s), x.write_shift(1, 0), x;
}
var parse_XLSBCodeName = parse_XLWideString, write_XLSBCodeName = write_XLWideString;
function parse_XLNullableWideString(F) {
  var x = F.read_shift(4);
  return x === 0 || x === 4294967295 ? "" : F.read_shift(x, "dbcs");
}
function write_XLNullableWideString(F, x) {
  var w = !1;
  return x == null && (w = !0, x = new_buf(127)), x.write_shift(4, F.length > 0 ? F.length : 4294967295), F.length > 0 && x.write_shift(0, F, "dbcs"), w ? x.slice(0, x.l) : x;
}
var parse_XLNameWideString = parse_XLWideString, parse_RelID = parse_XLNullableWideString, write_RelID = write_XLNullableWideString;
function parse_RkNumber(F) {
  var x = F.slice(F.l, F.l + 4), w = x[0] & 1, O = x[0] & 2;
  F.l += 4;
  var D = O === 0 ? __double([0, 0, 0, 0, x[0] & 252, x[1], x[2], x[3]], 0) : __readInt32LE(x, 0) >> 2;
  return w ? D / 100 : D;
}
function write_RkNumber(F, x) {
  x == null && (x = new_buf(4));
  var w = 0, O = 0, D = F * 100;
  if (F == (F | 0) && F >= -(1 << 29) && F < 1 << 29 ? O = 1 : D == (D | 0) && D >= -(1 << 29) && D < 1 << 29 && (O = 1, w = 1), O) x.write_shift(-4, ((w ? D : F) << 2) + (w + 2));
  else throw new Error("unsupported RkNumber " + F);
}
function parse_RfX(F) {
  var x = { s: {}, e: {} };
  return x.s.r = F.read_shift(4), x.e.r = F.read_shift(4), x.s.c = F.read_shift(4), x.e.c = F.read_shift(4), x;
}
function write_RfX(F, x) {
  return x || (x = new_buf(16)), x.write_shift(4, F.s.r), x.write_shift(4, F.e.r), x.write_shift(4, F.s.c), x.write_shift(4, F.e.c), x;
}
var parse_UncheckedRfX = parse_RfX, write_UncheckedRfX = write_RfX;
function parse_Xnum(F) {
  if (F.length - F.l < 8) throw "XLS Xnum Buffer underflow";
  return F.read_shift(8, "f");
}
function write_Xnum(F, x) {
  return (x || new_buf(8)).write_shift(8, F, "f");
}
function parse_BrtColor(F) {
  var x = {}, w = F.read_shift(1), O = w >>> 1, D = F.read_shift(1), U = F.read_shift(2, "i"), W = F.read_shift(1), X = F.read_shift(1), G = F.read_shift(1);
  switch (F.l++, O) {
    case 0:
      x.auto = 1;
      break;
    case 1:
      x.index = D;
      var Y = XLSIcv[D];
      Y && (x.rgb = rgb2Hex(Y));
      break;
    case 2:
      x.rgb = rgb2Hex([W, X, G]);
      break;
    case 3:
      x.theme = D;
      break;
  }
  return U != 0 && (x.tint = U > 0 ? U / 32767 : U / 32768), x;
}
function write_BrtColor(F, x) {
  if (x || (x = new_buf(8)), !F || F.auto)
    return x.write_shift(4, 0), x.write_shift(4, 0), x;
  F.index != null ? (x.write_shift(1, 2), x.write_shift(1, F.index)) : F.theme != null ? (x.write_shift(1, 6), x.write_shift(1, F.theme)) : (x.write_shift(1, 5), x.write_shift(1, 0));
  var w = F.tint || 0;
  if (w > 0 ? w *= 32767 : w < 0 && (w *= 32768), x.write_shift(2, w), !F.rgb || F.theme != null)
    x.write_shift(2, 0), x.write_shift(1, 0), x.write_shift(1, 0);
  else {
    var O = F.rgb || "FFFFFF";
    typeof O == "number" && (O = ("000000" + O.toString(16)).slice(-6)), x.write_shift(1, parseInt(O.slice(0, 2), 16)), x.write_shift(1, parseInt(O.slice(2, 4), 16)), x.write_shift(1, parseInt(O.slice(4, 6), 16)), x.write_shift(1, 255);
  }
  return x;
}
function parse_FontFlags(F) {
  var x = F.read_shift(1);
  F.l++;
  var w = {
    fBold: x & 1,
    fItalic: x & 2,
    fUnderline: x & 4,
    fStrikeout: x & 8,
    fOutline: x & 16,
    fShadow: x & 32,
    fCondense: x & 64,
    fExtend: x & 128
  };
  return w;
}
function write_FontFlags(F, x) {
  x || (x = new_buf(2));
  var w = (F.italic ? 2 : 0) | (F.strike ? 8 : 0) | (F.outline ? 16 : 0) | (F.shadow ? 32 : 0) | (F.condense ? 64 : 0) | (F.extend ? 128 : 0);
  return x.write_shift(1, w), x.write_shift(1, 0), x;
}
function parse_ClipboardFormatOrString(F, x) {
  var w = { 2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE" }, O = F.read_shift(4);
  switch (O) {
    case 0:
      return "";
    case 4294967295:
    case 4294967294:
      return w[F.read_shift(4)] || "";
  }
  if (O > 400) throw new Error("Unsupported Clipboard: " + O.toString(16));
  return F.l -= 4, F.read_shift(0, x == 1 ? "lpstr" : "lpwstr");
}
function parse_ClipboardFormatOrAnsiString(F) {
  return parse_ClipboardFormatOrString(F, 1);
}
function parse_ClipboardFormatOrUnicodeString(F) {
  return parse_ClipboardFormatOrString(F, 2);
}
var VT_I2 = 2, VT_I4 = 3, VT_BOOL = 11, VT_VARIANT = 12, VT_UI4 = 19, VT_FILETIME = 64, VT_BLOB = 65, VT_CF = 71, VT_VECTOR_VARIANT = 4108, VT_VECTOR_LPSTR = 4126, VT_STRING = 80, VT_USTR = 81, VT_CUSTOM = [VT_STRING, VT_USTR], DocSummaryPIDDSI = {
  1: { n: "CodePage", t: VT_I2 },
  2: { n: "Category", t: VT_STRING },
  3: { n: "PresentationFormat", t: VT_STRING },
  4: { n: "ByteCount", t: VT_I4 },
  5: { n: "LineCount", t: VT_I4 },
  6: { n: "ParagraphCount", t: VT_I4 },
  7: { n: "SlideCount", t: VT_I4 },
  8: { n: "NoteCount", t: VT_I4 },
  9: { n: "HiddenCount", t: VT_I4 },
  10: { n: "MultimediaClipCount", t: VT_I4 },
  11: { n: "ScaleCrop", t: VT_BOOL },
  12: {
    n: "HeadingPairs",
    t: VT_VECTOR_VARIANT
    /* VT_VECTOR | VT_VARIANT */
  },
  13: {
    n: "TitlesOfParts",
    t: VT_VECTOR_LPSTR
    /* VT_VECTOR | VT_LPSTR */
  },
  14: { n: "Manager", t: VT_STRING },
  15: { n: "Company", t: VT_STRING },
  16: { n: "LinksUpToDate", t: VT_BOOL },
  17: { n: "CharacterCount", t: VT_I4 },
  19: { n: "SharedDoc", t: VT_BOOL },
  22: { n: "HyperlinksChanged", t: VT_BOOL },
  23: { n: "AppVersion", t: VT_I4, p: "version" },
  24: { n: "DigSig", t: VT_BLOB },
  26: { n: "ContentType", t: VT_STRING },
  27: { n: "ContentStatus", t: VT_STRING },
  28: { n: "Language", t: VT_STRING },
  29: { n: "Version", t: VT_STRING },
  255: {},
  /* [MS-OLEPS] 2.18 */
  2147483648: { n: "Locale", t: VT_UI4 },
  2147483651: { n: "Behavior", t: VT_UI4 },
  1919054434: {}
}, SummaryPIDSI = {
  1: { n: "CodePage", t: VT_I2 },
  2: { n: "Title", t: VT_STRING },
  3: { n: "Subject", t: VT_STRING },
  4: { n: "Author", t: VT_STRING },
  5: { n: "Keywords", t: VT_STRING },
  6: { n: "Comments", t: VT_STRING },
  7: { n: "Template", t: VT_STRING },
  8: { n: "LastAuthor", t: VT_STRING },
  9: { n: "RevNumber", t: VT_STRING },
  10: { n: "EditTime", t: VT_FILETIME },
  11: { n: "LastPrinted", t: VT_FILETIME },
  12: { n: "CreatedDate", t: VT_FILETIME },
  13: { n: "ModifiedDate", t: VT_FILETIME },
  14: { n: "PageCount", t: VT_I4 },
  15: { n: "WordCount", t: VT_I4 },
  16: { n: "CharCount", t: VT_I4 },
  17: { n: "Thumbnail", t: VT_CF },
  18: { n: "Application", t: VT_STRING },
  19: { n: "DocSecurity", t: VT_I4 },
  255: {},
  /* [MS-OLEPS] 2.18 */
  2147483648: { n: "Locale", t: VT_UI4 },
  2147483651: { n: "Behavior", t: VT_UI4 },
  1919054434: {}
}, CountryEnum = {
  1: "US",
  // United States
  2: "CA",
  // Canada
  3: "",
  // Latin America (except Brazil)
  7: "RU",
  // Russia
  20: "EG",
  // Egypt
  30: "GR",
  // Greece
  31: "NL",
  // Netherlands
  32: "BE",
  // Belgium
  33: "FR",
  // France
  34: "ES",
  // Spain
  36: "HU",
  // Hungary
  39: "IT",
  // Italy
  41: "CH",
  // Switzerland
  43: "AT",
  // Austria
  44: "GB",
  // United Kingdom
  45: "DK",
  // Denmark
  46: "SE",
  // Sweden
  47: "NO",
  // Norway
  48: "PL",
  // Poland
  49: "DE",
  // Germany
  52: "MX",
  // Mexico
  55: "BR",
  // Brazil
  61: "AU",
  // Australia
  64: "NZ",
  // New Zealand
  66: "TH",
  // Thailand
  81: "JP",
  // Japan
  82: "KR",
  // Korea
  84: "VN",
  // Viet Nam
  86: "CN",
  // China
  90: "TR",
  // Turkey
  105: "JS",
  // Ramastan
  213: "DZ",
  // Algeria
  216: "MA",
  // Morocco
  218: "LY",
  // Libya
  351: "PT",
  // Portugal
  354: "IS",
  // Iceland
  358: "FI",
  // Finland
  420: "CZ",
  // Czech Republic
  886: "TW",
  // Taiwan
  961: "LB",
  // Lebanon
  962: "JO",
  // Jordan
  963: "SY",
  // Syria
  964: "IQ",
  // Iraq
  965: "KW",
  // Kuwait
  966: "SA",
  // Saudi Arabia
  971: "AE",
  // United Arab Emirates
  972: "IL",
  // Israel
  974: "QA",
  // Qatar
  981: "IR",
  // Iran
  65535: "US"
  // United States
}, XLSFillPattern = [
  null,
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
];
function rgbify(F) {
  return F.map(function(x) {
    return [x >> 16 & 255, x >> 8 & 255, x & 255];
  });
}
var _XLSIcv = /* @__PURE__ */ rgbify([
  /* Color Constants */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  /* Overridable Defaults */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  8388608,
  32768,
  128,
  8421376,
  8388736,
  32896,
  12632256,
  8421504,
  10066431,
  10040166,
  16777164,
  13434879,
  6684774,
  16744576,
  26316,
  13421823,
  128,
  16711935,
  16776960,
  65535,
  8388736,
  8388608,
  32896,
  255,
  52479,
  13434879,
  13434828,
  16777113,
  10079487,
  16751052,
  13408767,
  16764057,
  3368703,
  3394764,
  10079232,
  16763904,
  16750848,
  16737792,
  6710937,
  9868950,
  13158,
  3381606,
  13056,
  3355392,
  10040064,
  10040166,
  3355545,
  3355443,
  /* Other entries to appease BIFF8/12 */
  0,
  /* 0x40 icvForeground ?? */
  16777215,
  /* 0x41 icvBackground ?? */
  0,
  /* 0x42 icvFrame ?? */
  0,
  /* 0x43 icv3D ?? */
  0,
  /* 0x44 icv3DText ?? */
  0,
  /* 0x45 icv3DHilite ?? */
  0,
  /* 0x46 icv3DShadow ?? */
  0,
  /* 0x47 icvHilite ?? */
  0,
  /* 0x48 icvCtlText ?? */
  0,
  /* 0x49 icvCtlScrl ?? */
  0,
  /* 0x4A icvCtlInv ?? */
  0,
  /* 0x4B icvCtlBody ?? */
  0,
  /* 0x4C icvCtlFrame ?? */
  0,
  /* 0x4D icvCtlFore ?? */
  0,
  /* 0x4E icvCtlBack ?? */
  0,
  /* 0x4F icvCtlNeutral */
  0,
  /* 0x50 icvInfoBk ?? */
  0
  /* 0x51 icvInfoText ?? */
]), XLSIcv = /* @__PURE__ */ dup(_XLSIcv), BErr = {
  0: "#NULL!",
  7: "#DIV/0!",
  15: "#VALUE!",
  23: "#REF!",
  29: "#NAME?",
  36: "#NUM!",
  42: "#N/A",
  43: "#GETTING_DATA",
  255: "#WTF?"
}, RBErr = {
  "#NULL!": 0,
  "#DIV/0!": 7,
  "#VALUE!": 15,
  "#REF!": 23,
  "#NAME?": 29,
  "#NUM!": 36,
  "#N/A": 42,
  "#GETTING_DATA": 43,
  "#WTF?": 255
}, XLSLblBuiltIn = [
  "_xlnm.Consolidate_Area",
  "_xlnm.Auto_Open",
  "_xlnm.Auto_Close",
  "_xlnm.Extract",
  "_xlnm.Database",
  "_xlnm.Criteria",
  "_xlnm.Print_Area",
  "_xlnm.Print_Titles",
  "_xlnm.Recorder",
  "_xlnm.Data_Form",
  "_xlnm.Auto_Activate",
  "_xlnm.Auto_Deactivate",
  "_xlnm.Sheet_Title",
  "_xlnm._FilterDatabase"
], ct2type = {
  /* Workbook */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
  "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
  /* Worksheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
  "application/vnd.ms-excel.worksheet": "sheets",
  "application/vnd.ms-excel.binIndexWs": "TODO",
  /* Binary Index */
  /* Chartsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
  "application/vnd.ms-excel.chartsheet": "charts",
  /* Macrosheet */
  "application/vnd.ms-excel.macrosheet+xml": "macros",
  "application/vnd.ms-excel.macrosheet": "macros",
  "application/vnd.ms-excel.intlmacrosheet": "TODO",
  "application/vnd.ms-excel.binIndexMs": "TODO",
  /* Binary Index */
  /* Dialogsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
  "application/vnd.ms-excel.dialogsheet": "dialogs",
  /* Shared Strings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
  "application/vnd.ms-excel.sharedStrings": "strs",
  /* Styles */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
  "application/vnd.ms-excel.styles": "styles",
  /* File Properties */
  "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
  /* Custom Data Properties */
  "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
  /* Comments */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
  "application/vnd.ms-excel.comments": "comments",
  "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
  "application/vnd.ms-excel.person+xml": "people",
  /* Metadata (Stock/Geography and Dynamic Array) */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
  "application/vnd.ms-excel.sheetMetadata": "metadata",
  /* PivotTable */
  "application/vnd.ms-excel.pivotTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
  /* Chart Objects */
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
  /* Chart Colors */
  "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
  /* Chart Style */
  "application/vnd.ms-office.chartstyle+xml": "TODO",
  /* Chart Advanced */
  "application/vnd.ms-office.chartex+xml": "TODO",
  /* Calculation Chain */
  "application/vnd.ms-excel.calcChain": "calcchains",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
  /* Printer Settings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
  /* ActiveX */
  "application/vnd.ms-office.activeX": "TODO",
  "application/vnd.ms-office.activeX+xml": "TODO",
  /* Custom Toolbars */
  "application/vnd.ms-excel.attachedToolbars": "TODO",
  /* External Data Connections */
  "application/vnd.ms-excel.connections": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
  /* External Links */
  "application/vnd.ms-excel.externalLink": "links",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
  /* PivotCache */
  "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
  "application/vnd.ms-excel.pivotCacheRecords": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
  /* Query Table */
  "application/vnd.ms-excel.queryTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
  /* Shared Workbook */
  "application/vnd.ms-excel.userNames": "TODO",
  "application/vnd.ms-excel.revisionHeaders": "TODO",
  "application/vnd.ms-excel.revisionLog": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
  /* Single Cell Table */
  "application/vnd.ms-excel.tableSingleCells": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
  /* Slicer */
  "application/vnd.ms-excel.slicer": "TODO",
  "application/vnd.ms-excel.slicerCache": "TODO",
  "application/vnd.ms-excel.slicer+xml": "TODO",
  "application/vnd.ms-excel.slicerCache+xml": "TODO",
  /* Sort Map */
  "application/vnd.ms-excel.wsSortMap": "TODO",
  /* Table */
  "application/vnd.ms-excel.table": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
  /* Themes */
  "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
  /* Theme Override */
  "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
  /* Timeline */
  "application/vnd.ms-excel.Timeline+xml": "TODO",
  /* verify */
  "application/vnd.ms-excel.TimelineCache+xml": "TODO",
  /* verify */
  /* VBA */
  "application/vnd.ms-office.vbaProject": "vba",
  "application/vnd.ms-office.vbaProjectSignature": "TODO",
  /* Volatile Dependencies */
  "application/vnd.ms-office.volatileDependencies": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
  /* Control Properties */
  "application/vnd.ms-excel.controlproperties+xml": "TODO",
  /* Data Model */
  "application/vnd.openxmlformats-officedocument.model+data": "TODO",
  /* Survey */
  "application/vnd.ms-excel.Survey+xml": "TODO",
  /* Drawing */
  "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
  /* VML */
  "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
  "application/vnd.openxmlformats-package.relationships+xml": "rels",
  "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
  /* Image */
  "image/png": "TODO",
  sheet: "js"
}, CT_LIST = {
  workbooks: {
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
    xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
    xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
    xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
    xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
  },
  strs: {
    /* Shared Strings */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
    xlsb: "application/vnd.ms-excel.sharedStrings"
  },
  comments: {
    /* Comments */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
    xlsb: "application/vnd.ms-excel.comments"
  },
  sheets: {
    /* Worksheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
    xlsb: "application/vnd.ms-excel.worksheet"
  },
  charts: {
    /* Chartsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
    xlsb: "application/vnd.ms-excel.chartsheet"
  },
  dialogs: {
    /* Dialogsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
    xlsb: "application/vnd.ms-excel.dialogsheet"
  },
  macros: {
    /* Macrosheet (Excel 4.0 Macros) */
    xlsx: "application/vnd.ms-excel.macrosheet+xml",
    xlsb: "application/vnd.ms-excel.macrosheet"
  },
  metadata: {
    /* Metadata (Stock/Geography and Dynamic Array) */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
    xlsb: "application/vnd.ms-excel.sheetMetadata"
  },
  styles: {
    /* Styles */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
    xlsb: "application/vnd.ms-excel.styles"
  }
};
function new_ct() {
  return {
    workbooks: [],
    sheets: [],
    charts: [],
    dialogs: [],
    macros: [],
    rels: [],
    strs: [],
    comments: [],
    threadedcomments: [],
    links: [],
    coreprops: [],
    extprops: [],
    custprops: [],
    themes: [],
    styles: [],
    calcchains: [],
    vba: [],
    drawings: [],
    metadata: [],
    people: [],
    TODO: [],
    xmlns: ""
  };
}
function parse_ct(F) {
  var x = new_ct();
  if (!F || !F.match) return x;
  var w = {};
  if ((F.match(tagregex) || []).forEach(function(O) {
    var D = parsexmltag(O);
    switch (D[0].replace(nsregex, "<")) {
      case "<?xml":
        break;
      case "<Types":
        x.xmlns = D["xmlns" + (D[0].match(/<(\w+):/) || ["", ""])[1]];
        break;
      case "<Default":
        w[D.Extension.toLowerCase()] = D.ContentType;
        break;
      case "<Override":
        x[ct2type[D.ContentType]] !== void 0 && x[ct2type[D.ContentType]].push(D.PartName);
        break;
    }
  }), x.xmlns !== XMLNS.CT) throw new Error("Unknown Namespace: " + x.xmlns);
  return x.calcchain = x.calcchains.length > 0 ? x.calcchains[0] : "", x.sst = x.strs.length > 0 ? x.strs[0] : "", x.style = x.styles.length > 0 ? x.styles[0] : "", x.defaults = w, delete x.calcchains, x;
}
function write_ct(F, x, w) {
  var O = evert_arr(ct2type), D = [], U;
  D[D.length] = XML_HEADER, D[D.length] = writextag("Types", null, {
    xmlns: XMLNS.CT,
    "xmlns:xsd": XMLNS.xsd,
    "xmlns:xsi": XMLNS.xsi
  }), D = D.concat([
    ["xml", "application/xml"],
    ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"],
    ["vml", "application/vnd.openxmlformats-officedocument.vmlDrawing"],
    ["data", "application/vnd.openxmlformats-officedocument.model+data"],
    /* from test files */
    ["bmp", "image/bmp"],
    ["png", "image/png"],
    ["gif", "image/gif"],
    ["emf", "image/x-emf"],
    ["wmf", "image/x-wmf"],
    ["jpg", "image/jpeg"],
    ["jpeg", "image/jpeg"],
    ["tif", "image/tiff"],
    ["tiff", "image/tiff"],
    ["pdf", "application/pdf"],
    ["rels", "application/vnd.openxmlformats-package.relationships+xml"]
  ].map(function(Y) {
    return writextag("Default", null, { Extension: Y[0], ContentType: Y[1] });
  }));
  var W = function(Y) {
    F[Y] && F[Y].length > 0 && (U = F[Y][0], D[D.length] = writextag("Override", null, {
      PartName: (U[0] == "/" ? "" : "/") + U,
      ContentType: CT_LIST[Y][x.bookType] || CT_LIST[Y].xlsx
    }));
  }, X = function(Y) {
    (F[Y] || []).forEach(function(K) {
      D[D.length] = writextag("Override", null, {
        PartName: (K[0] == "/" ? "" : "/") + K,
        ContentType: CT_LIST[Y][x.bookType] || CT_LIST[Y].xlsx
      });
    });
  }, G = function(Y) {
    (F[Y] || []).forEach(function(K) {
      D[D.length] = writextag("Override", null, {
        PartName: (K[0] == "/" ? "" : "/") + K,
        ContentType: O[Y][0]
      });
    });
  };
  return W("workbooks"), X("sheets"), X("charts"), G("themes"), ["strs", "styles"].forEach(W), ["coreprops", "extprops", "custprops"].forEach(G), G("vba"), G("comments"), G("threadedcomments"), G("drawings"), X("metadata"), G("people"), D.length > 2 && (D[D.length] = "</Types>", D[1] = D[1].replace("/>", ">")), D.join("");
}
var RELS = {
  WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
  XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
  XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
  CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
  CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
  CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
  SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
  CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
  CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
  WS: [
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
  ],
  DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
  MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
  IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
  XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
  TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
  PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
  CONN: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/connections",
  VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
};
function get_rels_path(F) {
  var x = F.lastIndexOf("/");
  return F.slice(0, x + 1) + "_rels/" + F.slice(x + 1) + ".rels";
}
function parse_rels(F, x) {
  var w = { "!id": {} };
  if (!F) return w;
  x.charAt(0) !== "/" && (x = "/" + x);
  var O = {};
  return (F.match(tagregex) || []).forEach(function(D) {
    var U = parsexmltag(D);
    if (U[0] === "<Relationship") {
      var W = {};
      W.Type = U.Type, W.Target = unescapexml(U.Target), W.Id = U.Id, U.TargetMode && (W.TargetMode = U.TargetMode);
      var X = U.TargetMode === "External" ? U.Target : resolve_path(U.Target, x);
      w[X] = W, O[U.Id] = W;
    }
  }), w["!id"] = O, w;
}
function write_rels(F) {
  var x = [XML_HEADER, writextag("Relationships", null, {
    //'xmlns:ns0': XMLNS.RELS,
    xmlns: XMLNS.RELS
  })];
  return keys(F["!id"]).forEach(function(w) {
    x[x.length] = writextag("Relationship", null, F["!id"][w]);
  }), x.length > 2 && (x[x.length] = "</Relationships>", x[1] = x[1].replace("/>", ">")), x.join("");
}
function add_rels(F, x, w, O, D, U) {
  if (D || (D = {}), F["!id"] || (F["!id"] = {}), F["!idx"] || (F["!idx"] = 1), x < 0) for (x = F["!idx"]; F["!id"]["rId" + x]; ++x)
    ;
  if (F["!idx"] = x + 1, D.Id = "rId" + x, D.Type = O, D.Target = w, [RELS.HLINK, RELS.XPATH, RELS.XMISS].indexOf(D.Type) > -1 && (D.TargetMode = "External"), F["!id"][D.Id]) throw new Error("Cannot rewrite rId " + x);
  return F["!id"][D.Id] = D, F[("/" + D.Target).replace("//", "/")] = D, x;
}
var CT_ODS = "application/vnd.oasis.opendocument.spreadsheet";
function parse_manifest(F, x) {
  for (var w = xlml_normalize(F), O, D; O = xlmlregex.exec(w); )
    switch (O[3]) {
      case "manifest":
        break;
      case "file-entry":
        if (D = parsexmltag(O[0], !1), D.path == "/" && D.type !== CT_ODS)
          throw new Error("This OpenDocument is not a spreadsheet");
        break;
      case "encryption-data":
      case "algorithm":
      case "start-key-generation":
      case "key-derivation":
        throw new Error("Unsupported ODS Encryption");
      default:
        if (x && x.WTF)
          throw O;
    }
}
function write_manifest(F) {
  var x = [XML_HEADER];
  x.push(`<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">
`), x.push(`  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>
`);
  for (var w = 0; w < F.length; ++w)
    x.push('  <manifest:file-entry manifest:full-path="' + F[w][0] + '" manifest:media-type="' + F[w][1] + `"/>
`);
  return x.push("</manifest:manifest>"), x.join("");
}
function write_rdf_type(F, x, w) {
  return [
    '  <rdf:Description rdf:about="' + F + `">
`,
    '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (w || "odf") + "#" + x + `"/>
`,
    `  </rdf:Description>
`
  ].join("");
}
function write_rdf_has(F, x) {
  return [
    '  <rdf:Description rdf:about="' + F + `">
`,
    '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + x + `"/>
`,
    `  </rdf:Description>
`
  ].join("");
}
function write_rdf(F) {
  var x = [XML_HEADER];
  x.push(`<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
`);
  for (var w = 0; w != F.length; ++w)
    x.push(write_rdf_type(F[w][0], F[w][1])), x.push(write_rdf_has("", F[w][0]));
  return x.push(write_rdf_type("", "Document", "pkg")), x.push("</rdf:RDF>"), x.join("");
}
function write_meta_ods(F, x) {
  return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>SheetJS ' + XLSX.version + "</meta:generator></office:meta></office:document-meta>";
}
var CORE_PROPS = [
  ["cp:category", "Category"],
  ["cp:contentStatus", "ContentStatus"],
  ["cp:keywords", "Keywords"],
  ["cp:lastModifiedBy", "LastAuthor"],
  ["cp:lastPrinted", "LastPrinted"],
  ["cp:revision", "RevNumber"],
  ["cp:version", "Version"],
  ["dc:creator", "Author"],
  ["dc:description", "Comments"],
  ["dc:identifier", "Identifier"],
  ["dc:language", "Language"],
  ["dc:subject", "Subject"],
  ["dc:title", "Title"],
  ["dcterms:created", "CreatedDate", "date"],
  ["dcterms:modified", "ModifiedDate", "date"]
];
function parse_core_props(F) {
  var x = {};
  F = utf8read(F);
  for (var w = 0; w < CORE_PROPS.length; ++w) {
    var O = CORE_PROPS[w], D = str_match_xml(F, O[0]);
    D != null && D.length > 0 && (x[O[1]] = unescapexml(D[1])), O[2] === "date" && x[O[1]] && (x[O[1]] = parseDate(x[O[1]]));
  }
  return x;
}
function cp_doit(F, x, w, O, D) {
  D[F] != null || x == null || x === "" || (D[F] = x, x = escapexml(x), O[O.length] = w ? writextag(F, x, w) : writetag(F, x));
}
function write_core_props(F, x) {
  var w = x || {}, O = [XML_HEADER, writextag("cp:coreProperties", null, {
    //'xmlns': XMLNS.CORE_PROPS,
    "xmlns:cp": XMLNS.CORE_PROPS,
    "xmlns:dc": XMLNS.dc,
    "xmlns:dcterms": XMLNS.dcterms,
    "xmlns:dcmitype": XMLNS.dcmitype,
    "xmlns:xsi": XMLNS.xsi
  })], D = {};
  if (!F && !w.Props) return O.join("");
  F && (F.CreatedDate != null && cp_doit("dcterms:created", typeof F.CreatedDate == "string" ? F.CreatedDate : write_w3cdtf(F.CreatedDate, w.WTF), { "xsi:type": "dcterms:W3CDTF" }, O, D), F.ModifiedDate != null && cp_doit("dcterms:modified", typeof F.ModifiedDate == "string" ? F.ModifiedDate : write_w3cdtf(F.ModifiedDate, w.WTF), { "xsi:type": "dcterms:W3CDTF" }, O, D));
  for (var U = 0; U != CORE_PROPS.length; ++U) {
    var W = CORE_PROPS[U], X = w.Props && w.Props[W[1]] != null ? w.Props[W[1]] : F ? F[W[1]] : null;
    X === !0 ? X = "1" : X === !1 ? X = "0" : typeof X == "number" && (X = String(X)), X != null && cp_doit(W[0], X, null, O, D);
  }
  return O.length > 2 && (O[O.length] = "</cp:coreProperties>", O[1] = O[1].replace("/>", ">")), O.join("");
}
var EXT_PROPS = [
  ["Application", "Application", "string"],
  ["AppVersion", "AppVersion", "string"],
  ["Company", "Company", "string"],
  ["DocSecurity", "DocSecurity", "string"],
  ["Manager", "Manager", "string"],
  ["HyperlinksChanged", "HyperlinksChanged", "bool"],
  ["SharedDoc", "SharedDoc", "bool"],
  ["LinksUpToDate", "LinksUpToDate", "bool"],
  ["ScaleCrop", "ScaleCrop", "bool"],
  ["HeadingPairs", "HeadingPairs", "raw"],
  ["TitlesOfParts", "TitlesOfParts", "raw"]
], PseudoPropsPairs = [
  "Worksheets",
  "SheetNames",
  "NamedRanges",
  "DefinedNames",
  "Chartsheets",
  "ChartNames"
];
function load_props_pairs(F, x, w, O) {
  var D = [];
  if (typeof F == "string") D = parseVector(F, O);
  else for (var U = 0; U < F.length; ++U) D = D.concat(F[U].map(function(K) {
    return { v: K };
  }));
  var W = typeof x == "string" ? parseVector(x, O).map(function(K) {
    return K.v;
  }) : x, X = 0, G = 0;
  if (W.length > 0) for (var Y = 0; Y !== D.length; Y += 2) {
    switch (G = +D[Y + 1].v, D[Y].v) {
      case "Worksheets":
      case "工作表":
      case "Листы":
      case "أوراق العمل":
      case "ワークシート":
      case "גליונות עבודה":
      case "Arbeitsblätter":
      case "Çalışma Sayfaları":
      case "Feuilles de calcul":
      case "Fogli di lavoro":
      case "Folhas de cálculo":
      case "Planilhas":
      case "Regneark":
      case "Hojas de cálculo":
      case "Werkbladen":
        w.Worksheets = G, w.SheetNames = W.slice(X, X + G);
        break;
      case "Named Ranges":
      case "Rangos con nombre":
      case "名前付き一覧":
      case "Benannte Bereiche":
      case "Navngivne områder":
        w.NamedRanges = G, w.DefinedNames = W.slice(X, X + G);
        break;
      case "Charts":
      case "Diagramme":
        w.Chartsheets = G, w.ChartNames = W.slice(X, X + G);
        break;
    }
    X += G;
  }
}
function parse_ext_props(F, x, w) {
  var O = {};
  return x || (x = {}), F = utf8read(F), EXT_PROPS.forEach(function(D) {
    var U = (str_match_xml_ns(F, D[0]) || [])[1];
    switch (D[2]) {
      case "string":
        U && (x[D[1]] = unescapexml(U));
        break;
      case "bool":
        x[D[1]] = U === "true";
        break;
      case "raw":
        var W = str_match_xml(F, D[0]);
        W && W.length > 0 && (O[D[1]] = W[1]);
        break;
    }
  }), O.HeadingPairs && O.TitlesOfParts && load_props_pairs(O.HeadingPairs, O.TitlesOfParts, x, w), x;
}
function write_ext_props(F) {
  var x = [], w = writextag;
  return F || (F = {}), F.Application = "SheetJS", x[x.length] = XML_HEADER, x[x.length] = writextag("Properties", null, {
    xmlns: XMLNS.EXT_PROPS,
    "xmlns:vt": XMLNS.vt
  }), EXT_PROPS.forEach(function(O) {
    if (F[O[1]] !== void 0) {
      var D;
      switch (O[2]) {
        case "string":
          D = escapexml(String(F[O[1]]));
          break;
        case "bool":
          D = F[O[1]] ? "true" : "false";
          break;
      }
      D !== void 0 && (x[x.length] = w(O[0], D));
    }
  }), x[x.length] = w("HeadingPairs", w("vt:vector", w("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + w("vt:variant", w("vt:i4", String(F.Worksheets))), { size: 2, baseType: "variant" })), x[x.length] = w("TitlesOfParts", w("vt:vector", F.SheetNames.map(function(O) {
    return "<vt:lpstr>" + escapexml(O) + "</vt:lpstr>";
  }).join(""), { size: F.Worksheets, baseType: "lpstr" })), x.length > 2 && (x[x.length] = "</Properties>", x[1] = x[1].replace("/>", ">")), x.join("");
}
var custregex = /<[^<>]+>[^<]*/g;
function parse_cust_props(F, x) {
  var w = {}, O = "", D = F.match(custregex);
  if (D) for (var U = 0; U != D.length; ++U) {
    var W = D[U], X = parsexmltag(W);
    switch (strip_ns(X[0])) {
      case "<?xml":
        break;
      case "<Properties":
        break;
      case "<property":
        O = unescapexml(X.name);
        break;
      case "</property>":
        O = null;
        break;
      default:
        if (W.indexOf("<vt:") === 0) {
          var G = W.split(">"), Y = G[0].slice(4), K = G[1];
          switch (Y) {
            case "lpstr":
            case "bstr":
            case "lpwstr":
              w[O] = unescapexml(K);
              break;
            case "bool":
              w[O] = parsexmlbool(K);
              break;
            case "i1":
            case "i2":
            case "i4":
            case "i8":
            case "int":
            case "uint":
              w[O] = parseInt(K, 10);
              break;
            case "r4":
            case "r8":
            case "decimal":
              w[O] = parseFloat(K);
              break;
            case "filetime":
            case "date":
              w[O] = parseDate(K);
              break;
            case "cy":
            case "error":
              w[O] = unescapexml(K);
              break;
            default:
              if (Y.slice(-1) == "/") break;
              x.WTF && typeof console < "u" && console.warn("Unexpected", W, Y, G);
          }
        } else if (W.slice(0, 2) !== "</") {
          if (x.WTF) throw new Error(W);
        }
    }
  }
  return w;
}
function write_cust_props(F) {
  var x = [XML_HEADER, writextag("Properties", null, {
    xmlns: XMLNS.CUST_PROPS,
    "xmlns:vt": XMLNS.vt
  })];
  if (!F) return x.join("");
  var w = 1;
  return keys(F).forEach(function(D) {
    ++w, x[x.length] = writextag("property", write_vt(F[D]), {
      fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
      pid: w,
      name: escapexml(D)
    });
  }), x.length > 2 && (x[x.length] = "</Properties>", x[1] = x[1].replace("/>", ">")), x.join("");
}
var XLMLDocPropsMap = {
  Title: "Title",
  Subject: "Subject",
  Author: "Author",
  Keywords: "Keywords",
  Comments: "Description",
  LastAuthor: "LastAuthor",
  RevNumber: "Revision",
  Application: "AppName",
  /* TotalTime: 'TotalTime', */
  LastPrinted: "LastPrinted",
  CreatedDate: "Created",
  ModifiedDate: "LastSaved",
  /* Pages */
  /* Words */
  /* Characters */
  Category: "Category",
  /* PresentationFormat */
  Manager: "Manager",
  Company: "Company",
  /* Guid */
  /* HyperlinkBase */
  /* Bytes */
  /* Lines */
  /* Paragraphs */
  /* CharactersWithSpaces */
  AppVersion: "Version",
  ContentStatus: "ContentStatus",
  /* NOTE: missing from schema */
  Identifier: "Identifier",
  /* NOTE: missing from schema */
  Language: "Language"
  /* NOTE: missing from schema */
}, evert_XLMLDPM;
function xlml_set_prop(F, x, w) {
  evert_XLMLDPM || (evert_XLMLDPM = evert(XLMLDocPropsMap)), x = evert_XLMLDPM[x] || x, F[x] = w;
}
function xlml_write_docprops(F, x) {
  var w = [];
  return keys(XLMLDocPropsMap).map(function(O) {
    for (var D = 0; D < CORE_PROPS.length; ++D) if (CORE_PROPS[D][1] == O) return CORE_PROPS[D];
    for (D = 0; D < EXT_PROPS.length; ++D) if (EXT_PROPS[D][1] == O) return EXT_PROPS[D];
    throw O;
  }).forEach(function(O) {
    if (F[O[1]] != null) {
      var D = x && x.Props && x.Props[O[1]] != null ? x.Props[O[1]] : F[O[1]];
      switch (O[2]) {
        case "date":
          D = new Date(D).toISOString().replace(/\.\d*Z/, "Z");
          break;
      }
      typeof D == "number" ? D = String(D) : D === !0 || D === !1 ? D = D ? "1" : "0" : D instanceof Date && (D = new Date(D).toISOString().replace(/\.\d*Z/, "")), w.push(writetag(XLMLDocPropsMap[O[1]] || O[1], D));
    }
  }), writextag("DocumentProperties", w.join(""), { xmlns: XLMLNS.o });
}
function xlml_write_custprops(F, x) {
  var w = ["Worksheets", "SheetNames"], O = "CustomDocumentProperties", D = [];
  return F && keys(F).forEach(function(U) {
    if (Object.prototype.hasOwnProperty.call(F, U)) {
      for (var W = 0; W < CORE_PROPS.length; ++W) if (U == CORE_PROPS[W][1]) return;
      for (W = 0; W < EXT_PROPS.length; ++W) if (U == EXT_PROPS[W][1]) return;
      for (W = 0; W < w.length; ++W) if (U == w[W]) return;
      var X = F[U], G = "string";
      typeof X == "number" ? (G = "float", X = String(X)) : X === !0 || X === !1 ? (G = "boolean", X = X ? "1" : "0") : X = String(X), D.push(writextag(escapexmltag(U), X, { "dt:dt": G }));
    }
  }), x && keys(x).forEach(function(U) {
    if (Object.prototype.hasOwnProperty.call(x, U) && !(F && Object.prototype.hasOwnProperty.call(F, U))) {
      var W = x[U], X = "string";
      typeof W == "number" ? (X = "float", W = String(W)) : W === !0 || W === !1 ? (X = "boolean", W = W ? "1" : "0") : W instanceof Date ? (X = "dateTime.tz", W = W.toISOString()) : W = String(W), D.push(writextag(escapexmltag(U), W, { "dt:dt": X }));
    }
  }), "<" + O + ' xmlns="' + XLMLNS.o + '">' + D.join("") + "</" + O + ">";
}
function parse_FILETIME(F) {
  var x = F.read_shift(4), w = F.read_shift(4);
  return new Date((w / 1e7 * Math.pow(2, 32) + x / 1e7 - 11644473600) * 1e3).toISOString().replace(/\.000/, "");
}
function write_FILETIME(F) {
  var x = typeof F == "string" ? new Date(Date.parse(F)) : F, w = x.getTime() / 1e3 + 11644473600, O = w % Math.pow(2, 32), D = (w - O) / Math.pow(2, 32);
  O *= 1e7, D *= 1e7;
  var U = O / Math.pow(2, 32) | 0;
  U > 0 && (O = O % Math.pow(2, 32), D += U);
  var W = new_buf(8);
  return W.write_shift(4, O), W.write_shift(4, D), W;
}
function parse_lpstr(F, x, w) {
  var O = F.l, D = F.read_shift(0, "lpstr-cp");
  if (w) for (; F.l - O & 3; ) ++F.l;
  return D;
}
function parse_lpwstr(F, x, w) {
  var O = F.read_shift(0, "lpwstr");
  return O;
}
function parse_VtStringBase(F, x, w) {
  return x === 31 ? parse_lpwstr(F) : parse_lpstr(F, x, w);
}
function parse_VtString(F, x, w) {
  return parse_VtStringBase(F, x, w === !1 ? 0 : 4);
}
function parse_VtUnalignedString(F, x) {
  if (!x) throw new Error("VtUnalignedString must have positive length");
  return parse_VtStringBase(F, x, 0);
}
function parse_VtVecLpwstrValue(F) {
  for (var x = F.read_shift(4), w = [], O = 0; O != x; ++O) {
    var D = F.l;
    w[O] = F.read_shift(0, "lpwstr").replace(chr0, ""), F.l - D & 2 && (F.l += 2);
  }
  return w;
}
function parse_VtVecUnalignedLpstrValue(F) {
  for (var x = F.read_shift(4), w = [], O = 0; O != x; ++O) w[O] = F.read_shift(0, "lpstr-cp").replace(chr0, "");
  return w;
}
function parse_VtHeadingPair(F) {
  var x = F.l, w = parse_TypedPropertyValue(F, VT_USTR);
  F[F.l] == 0 && F[F.l + 1] == 0 && F.l - x & 2 && (F.l += 2);
  var O = parse_TypedPropertyValue(F, VT_I4);
  return [w, O];
}
function parse_VtVecHeadingPairValue(F) {
  for (var x = F.read_shift(4), w = [], O = 0; O < x / 2; ++O) w.push(parse_VtHeadingPair(F));
  return w;
}
function parse_dictionary(F, x) {
  for (var w = F.read_shift(4), O = {}, D = 0; D != w; ++D) {
    var U = F.read_shift(4), W = F.read_shift(4);
    O[U] = F.read_shift(W, x === 1200 ? "utf16le" : "utf8").replace(chr0, "").replace(chr1, "!"), x === 1200 && W % 2 && (F.l += 2);
  }
  return F.l & 3 && (F.l = F.l >> 3 << 2), O;
}
function parse_BLOB(F) {
  var x = F.read_shift(4), w = F.slice(F.l, F.l + x);
  return F.l += x, (x & 3) > 0 && (F.l += 4 - (x & 3) & 3), w;
}
function parse_ClipboardData(F) {
  var x = {};
  return x.Size = F.read_shift(4), F.l += x.Size + 3 - (x.Size - 1) % 4, x;
}
function parse_TypedPropertyValue(F, x, w) {
  var O = F.read_shift(2), D, U = w || {};
  if (F.l += 2, x !== VT_VARIANT && O !== x && VT_CUSTOM.indexOf(x) === -1 && !((x & 65534) == 4126 && (O & 65534) == 4126))
    throw new Error("Expected type " + x + " saw " + O);
  switch (x === VT_VARIANT ? O : x) {
    case 2:
      return D = F.read_shift(2, "i"), U.raw || (F.l += 2), D;
    case 3:
      return D = F.read_shift(4, "i"), D;
    case 11:
      return F.read_shift(4) !== 0;
    case 19:
      return D = F.read_shift(4), D;
    case 30:
      F.l += 4, val = parse_VtString(F, F[F.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
      break;
    case 31:
      F.l += 4, val = parse_VtString(F, F[F.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
      break;
    case 64:
      return parse_FILETIME(F);
    case 65:
      return parse_BLOB(F);
    case 71:
      return parse_ClipboardData(F);
    case 80:
      return parse_VtString(F, O, !U.raw).replace(chr0, "");
    case 81:
      return parse_VtUnalignedString(
        F,
        O
        /*, 4*/
      ).replace(chr0, "");
    case 4108:
      return parse_VtVecHeadingPairValue(F);
    case 4126:
    case 4127:
      return O == 4127 ? parse_VtVecLpwstrValue(F) : parse_VtVecUnalignedLpstrValue(F);
    default:
      throw new Error("TypedPropertyValue unrecognized type " + x + " " + O);
  }
}
function write_TypedPropertyValue(F, x) {
  var w = new_buf(4), O = new_buf(4);
  switch (w.write_shift(4, F == 80 ? 31 : F), F) {
    case 3:
      O.write_shift(-4, x);
      break;
    case 5:
      O = new_buf(8), O.write_shift(8, x, "f");
      break;
    case 11:
      O.write_shift(4, x ? 1 : 0);
      break;
    case 64:
      O = write_FILETIME(x);
      break;
    case 31:
    case 80:
      for (O = new_buf(4 + 2 * (x.length + 1) + (x.length % 2 ? 0 : 2)), O.write_shift(4, x.length + 1), O.write_shift(0, x, "dbcs"); O.l != O.length; ) O.write_shift(1, 0);
      break;
    default:
      throw new Error("TypedPropertyValue unrecognized type " + F + " " + x);
  }
  return bconcat([w, O]);
}
function parse_PropertySet(F, x) {
  var w = F.l, O = F.read_shift(4), D = F.read_shift(4), U = [], W = 0, X = 0, G = -1, Y = {};
  for (W = 0; W != D; ++W) {
    var K = F.read_shift(4), Z = F.read_shift(4);
    U[W] = [K, Z + w];
  }
  U.sort(function(oe, ne) {
    return oe[1] - ne[1];
  });
  var q = {};
  for (W = 0; W != D; ++W) {
    if (F.l !== U[W][1]) {
      var J = !0;
      if (W > 0 && x) switch (x[U[W - 1][0]].t) {
        case 2:
          F.l + 2 === U[W][1] && (F.l += 2, J = !1);
          break;
        case 80:
          F.l <= U[W][1] && (F.l = U[W][1], J = !1);
          break;
        case 4108:
          F.l <= U[W][1] && (F.l = U[W][1], J = !1);
          break;
      }
      if ((!x || W == 0) && F.l <= U[W][1] && (J = !1, F.l = U[W][1]), J) throw new Error("Read Error: Expected address " + U[W][1] + " at " + F.l + " :" + W);
    }
    if (x) {
      if (U[W][0] == 0 && U.length > W + 1 && U[W][1] == U[W + 1][1]) continue;
      var ee = x[U[W][0]];
      if (q[ee.n] = parse_TypedPropertyValue(F, ee.t, { raw: !0 }), ee.p === "version" && (q[ee.n] = String(q[ee.n] >> 16) + "." + ("0000" + String(q[ee.n] & 65535)).slice(-4)), ee.n == "CodePage") switch (q[ee.n]) {
        case 0:
          q[ee.n] = 1252;
        /* falls through */
        case 874:
        case 932:
        case 936:
        case 949:
        case 950:
        case 1250:
        case 1251:
        case 1253:
        case 1254:
        case 1255:
        case 1256:
        case 1257:
        case 1258:
        case 1e4:
        case 1200:
        case 1201:
        case 1252:
        case 65e3:
        case -536:
        case 65001:
        case -535:
          set_cp(X = q[ee.n] >>> 0 & 65535);
          break;
        default:
          throw new Error("Unsupported CodePage: " + q[ee.n]);
      }
    } else if (U[W][0] === 1) {
      if (X = q.CodePage = parse_TypedPropertyValue(F, VT_I2), set_cp(X), G !== -1) {
        var re = F.l;
        F.l = U[G][1], Y = parse_dictionary(F, X), F.l = re;
      }
    } else if (U[W][0] === 0) {
      if (X === 0) {
        G = W, F.l = U[W + 1][1];
        continue;
      }
      Y = parse_dictionary(F, X);
    } else {
      var te = Y[U[W][0]], Q;
      switch (F[F.l]) {
        case 65:
          F.l += 4, Q = parse_BLOB(F);
          break;
        case 30:
          F.l += 4, Q = parse_VtString(F, F[F.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
          break;
        case 31:
          F.l += 4, Q = parse_VtString(F, F[F.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
          break;
        case 3:
          F.l += 4, Q = F.read_shift(4, "i");
          break;
        case 19:
          F.l += 4, Q = F.read_shift(4);
          break;
        case 5:
          F.l += 4, Q = F.read_shift(8, "f");
          break;
        case 11:
          F.l += 4, Q = parsebool(F, 4);
          break;
        case 64:
          F.l += 4, Q = parseDate(parse_FILETIME(F));
          break;
        default:
          throw new Error("unparsed value: " + F[F.l]);
      }
      q[te] = Q;
    }
  }
  return F.l = w + O, q;
}
var XLSPSSkip = ["CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID"];
function guess_property_type(F) {
  switch (typeof F) {
    case "boolean":
      return 11;
    case "number":
      return (F | 0) == F ? 3 : 5;
    case "string":
      return 31;
    case "object":
      if (F instanceof Date) return 64;
      break;
  }
  return -1;
}
function write_PropertySet(F, x, w) {
  var O = new_buf(8), D = [], U = [], W = 8, X = 0, G = new_buf(8), Y = new_buf(8);
  if (G.write_shift(4, 2), G.write_shift(4, 1200), Y.write_shift(4, 1), U.push(G), D.push(Y), W += 8 + G.length, !x) {
    Y = new_buf(8), Y.write_shift(4, 0), D.unshift(Y);
    var K = [new_buf(4)];
    for (K[0].write_shift(4, F.length), X = 0; X < F.length; ++X) {
      var Z = F[X][0];
      for (G = new_buf(8 + 2 * (Z.length + 1) + (Z.length % 2 ? 0 : 2)), G.write_shift(4, X + 2), G.write_shift(4, Z.length + 1), G.write_shift(0, Z, "dbcs"); G.l != G.length; ) G.write_shift(1, 0);
      K.push(G);
    }
    G = bconcat(K), U.unshift(G), W += 8 + G.length;
  }
  for (X = 0; X < F.length; ++X)
    if (!(x && !x[F[X][0]]) && !(XLSPSSkip.indexOf(F[X][0]) > -1 || PseudoPropsPairs.indexOf(F[X][0]) > -1) && F[X][1] != null) {
      var q = F[X][1], J = 0;
      if (x) {
        J = +x[F[X][0]];
        var ee = w[J];
        if (ee.p == "version" && typeof q == "string") {
          var re = q.split(".");
          q = (+re[0] << 16) + (+re[1] || 0);
        }
        G = write_TypedPropertyValue(ee.t, q);
      } else {
        var te = guess_property_type(q);
        te == -1 && (te = 31, q = String(q)), G = write_TypedPropertyValue(te, q);
      }
      U.push(G), Y = new_buf(8), Y.write_shift(4, x ? J : 2 + X), D.push(Y), W += 8 + G.length;
    }
  var Q = 8 * (U.length + 1);
  for (X = 0; X < U.length; ++X)
    D[X].write_shift(4, Q), Q += U[X].length;
  return O.write_shift(4, W), O.write_shift(4, U.length), bconcat([O].concat(D).concat(U));
}
function parse_PropertySetStream(F, x, w) {
  var O = F.content;
  if (!O) return {};
  prep_blob(O, 0);
  var D, U, W, X, G = 0;
  O.chk("feff", "Byte Order: "), O.read_shift(2);
  var Y = O.read_shift(4), K = O.read_shift(16);
  if (K !== CFB.utils.consts.HEADER_CLSID && K !== w) throw new Error("Bad PropertySet CLSID " + K);
  if (D = O.read_shift(4), D !== 1 && D !== 2) throw new Error("Unrecognized #Sets: " + D);
  if (U = O.read_shift(16), X = O.read_shift(4), D === 1 && X !== O.l) throw new Error("Length mismatch: " + X + " !== " + O.l);
  D === 2 && (W = O.read_shift(16), G = O.read_shift(4));
  var Z = parse_PropertySet(O, x), q = { SystemIdentifier: Y };
  for (var J in Z) q[J] = Z[J];
  if (q.FMTID = U, D === 1) return q;
  if (G - O.l == 2 && (O.l += 2), O.l !== G) throw new Error("Length mismatch 2: " + O.l + " !== " + G);
  var ee;
  try {
    ee = parse_PropertySet(O, null);
  } catch {
  }
  for (J in ee) q[J] = ee[J];
  return q.FMTID = [U, W], q;
}
function write_PropertySetStream(F, x, w, O, D, U) {
  var W = new_buf(D ? 68 : 48), X = [W];
  W.write_shift(2, 65534), W.write_shift(2, 0), W.write_shift(4, 842412599), W.write_shift(16, CFB.utils.consts.HEADER_CLSID, "hex"), W.write_shift(4, D ? 2 : 1), W.write_shift(16, x, "hex"), W.write_shift(4, D ? 68 : 48);
  var G = write_PropertySet(F, w, O);
  if (X.push(G), D) {
    var Y = write_PropertySet(D, null, null);
    W.write_shift(16, U, "hex"), W.write_shift(4, 68 + G.length), X.push(Y);
  }
  return bconcat(X);
}
function parsenoop2(F, x) {
  return F.read_shift(x), null;
}
function writezeroes(F, x) {
  x || (x = new_buf(F));
  for (var w = 0; w < F; ++w) x.write_shift(1, 0);
  return x;
}
function parslurp(F, x, w) {
  for (var O = [], D = F.l + x; F.l < D; ) O.push(w(F, D - F.l));
  if (D !== F.l) throw new Error("Slurp error");
  return O;
}
function parsebool(F, x) {
  return F.read_shift(x) === 1;
}
function writebool(F, x) {
  return x || (x = new_buf(2)), x.write_shift(2, +!!F), x;
}
function parseuint16(F) {
  return F.read_shift(2, "u");
}
function writeuint16(F, x) {
  return x || (x = new_buf(2)), x.write_shift(2, F), x;
}
function parseuint16a(F, x) {
  return parslurp(F, x, parseuint16);
}
function parse_Bes(F) {
  var x = F.read_shift(1), w = F.read_shift(1);
  return w === 1 ? x : x === 1;
}
function write_Bes(F, x, w) {
  return w || (w = new_buf(2)), w.write_shift(1, x == "e" ? +F : +!!F), w.write_shift(1, x == "e" ? 1 : 0), w;
}
function parse_ShortXLUnicodeString(F, x, w) {
  var O = F.read_shift(w && w.biff >= 12 ? 2 : 1), D = "sbcs-cont", U = current_codepage;
  if (w && w.biff >= 8 && (current_codepage = 1200), !w || w.biff == 8) {
    var W = F.read_shift(1);
    W && (D = "dbcs-cont");
  } else w.biff == 12 && (D = "wstr");
  w.biff >= 2 && w.biff <= 5 && (D = "cpstr");
  var X = O ? F.read_shift(O, D) : "";
  return current_codepage = U, X;
}
function parse_XLUnicodeRichExtendedString(F) {
  var x = current_codepage;
  current_codepage = 1200;
  var w = F.read_shift(2), O = F.read_shift(1), D = O & 4, U = O & 8, W = 1 + (O & 1), X = 0, G, Y = {};
  U && (X = F.read_shift(2)), D && (G = F.read_shift(4));
  var K = W == 2 ? "dbcs-cont" : "sbcs-cont", Z = w === 0 ? "" : F.read_shift(w, K);
  return U && (F.l += 4 * X), D && (F.l += G), Y.t = Z, U || (Y.raw = "<t>" + Y.t + "</t>", Y.r = Y.t), current_codepage = x, Y;
}
function write_XLUnicodeRichExtendedString(F) {
  var x = F.t || "", w = new_buf(3);
  w.write_shift(2, x.length), w.write_shift(1, 1);
  var O = new_buf(2 * x.length);
  O.write_shift(2 * x.length, x, "utf16le");
  var D = [w, O];
  return bconcat(D);
}
function parse_XLUnicodeStringNoCch(F, x, w) {
  var O;
  if (w) {
    if (w.biff >= 2 && w.biff <= 5) return F.read_shift(x, "cpstr");
    if (w.biff >= 12) return F.read_shift(x, "dbcs-cont");
  }
  var D = F.read_shift(1);
  return D === 0 ? O = F.read_shift(x, "sbcs-cont") : O = F.read_shift(x, "dbcs-cont"), O;
}
function parse_XLUnicodeString(F, x, w) {
  var O = F.read_shift(w && w.biff == 2 ? 1 : 2);
  return O === 0 ? (F.l++, "") : parse_XLUnicodeStringNoCch(F, O, w);
}
function parse_XLUnicodeString2(F, x, w) {
  if (w.biff > 5) return parse_XLUnicodeString(F, x, w);
  var O = F.read_shift(1);
  return O === 0 ? (F.l++, "") : F.read_shift(O, w.biff <= 4 || !F.lens ? "cpstr" : "sbcs-cont");
}
function write_XLUnicodeString(F, x, w) {
  return w || (w = new_buf(3 + 2 * F.length)), w.write_shift(2, F.length), w.write_shift(1, 1), w.write_shift(31, F, "utf16le"), w;
}
function parse_ControlInfo(F) {
  var x = F.read_shift(1);
  F.l++;
  var w = F.read_shift(2);
  return F.l += 2, [x, w];
}
function parse_URLMoniker(F) {
  var x = F.read_shift(4), w = F.l, O = !1;
  x > 24 && (F.l += x - 24, F.read_shift(16) === "795881f43b1d7f48af2c825dc4852763" && (O = !0), F.l = w);
  var D = F.read_shift((O ? x - 24 : x) >> 1, "utf16le").replace(chr0, "");
  return O && (F.l += 24), D;
}
function parse_FileMoniker(F) {
  for (var x = F.read_shift(2), w = ""; x-- > 0; ) w += "../";
  var O = F.read_shift(0, "lpstr-ansi");
  if (F.l += 2, F.read_shift(2) != 57005) throw new Error("Bad FileMoniker");
  var D = F.read_shift(4);
  if (D === 0) return w + O.replace(/\\/g, "/");
  var U = F.read_shift(4);
  if (F.read_shift(2) != 3) throw new Error("Bad FileMoniker");
  var W = F.read_shift(U >> 1, "utf16le").replace(chr0, "");
  return w + W;
}
function parse_HyperlinkMoniker(F, x) {
  var w = F.read_shift(16);
  switch (w) {
    case "e0c9ea79f9bace118c8200aa004ba90b":
      return parse_URLMoniker(F);
    case "0303000000000000c000000000000046":
      return parse_FileMoniker(F);
    default:
      throw new Error("Unsupported Moniker " + w);
  }
}
function parse_HyperlinkString(F) {
  var x = F.read_shift(4), w = x > 0 ? F.read_shift(x, "utf16le").replace(chr0, "") : "";
  return w;
}
function write_HyperlinkString(F, x) {
  x || (x = new_buf(6 + F.length * 2)), x.write_shift(4, 1 + F.length);
  for (var w = 0; w < F.length; ++w) x.write_shift(2, F.charCodeAt(w));
  return x.write_shift(2, 0), x;
}
function parse_Hyperlink(F, x) {
  var w = F.l + x, O = F.read_shift(4);
  if (O !== 2) throw new Error("Unrecognized streamVersion: " + O);
  var D = F.read_shift(2);
  F.l += 2;
  var U, W, X, G, Y = "", K, Z;
  D & 16 && (U = parse_HyperlinkString(F, w - F.l)), D & 128 && (W = parse_HyperlinkString(F, w - F.l)), (D & 257) === 257 && (X = parse_HyperlinkString(F, w - F.l)), (D & 257) === 1 && (G = parse_HyperlinkMoniker(F, w - F.l)), D & 8 && (Y = parse_HyperlinkString(F, w - F.l)), D & 32 && (K = F.read_shift(16)), D & 64 && (Z = parse_FILETIME(
    F
    /*, 8*/
  )), F.l = w;
  var q = W || X || G || "";
  q && Y && (q += "#" + Y), q || (q = "#" + Y), D & 2 && q.charAt(0) == "/" && q.charAt(1) != "/" && (q = "file://" + q);
  var J = { Target: q };
  return K && (J.guid = K), Z && (J.time = Z), U && (J.Tooltip = U), J;
}
function write_Hyperlink(F) {
  var x = new_buf(512), w = 0, O = F.Target;
  O.slice(0, 7) == "file://" && (O = O.slice(7));
  var D = O.indexOf("#"), U = D > -1 ? 31 : 23;
  switch (O.charAt(0)) {
    case "#":
      U = 28;
      break;
    case ".":
      U &= -3;
      break;
  }
  x.write_shift(4, 2), x.write_shift(4, U);
  var W = [8, 6815827, 6619237, 4849780, 83];
  for (w = 0; w < W.length; ++w) x.write_shift(4, W[w]);
  if (U == 28)
    O = O.slice(1), write_HyperlinkString(O, x);
  else if (U & 2) {
    for (W = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" "), w = 0; w < W.length; ++w) x.write_shift(1, parseInt(W[w], 16));
    var X = D > -1 ? O.slice(0, D) : O;
    for (x.write_shift(4, 2 * (X.length + 1)), w = 0; w < X.length; ++w) x.write_shift(2, X.charCodeAt(w));
    x.write_shift(2, 0), U & 8 && write_HyperlinkString(D > -1 ? O.slice(D + 1) : "", x);
  } else {
    for (W = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" "), w = 0; w < W.length; ++w) x.write_shift(1, parseInt(W[w], 16));
    for (var G = 0; O.slice(G * 3, G * 3 + 3) == "../" || O.slice(G * 3, G * 3 + 3) == "..\\"; ) ++G;
    for (x.write_shift(2, G), x.write_shift(4, O.length - 3 * G + 1), w = 0; w < O.length - 3 * G; ++w) x.write_shift(1, O.charCodeAt(w + 3 * G) & 255);
    for (x.write_shift(1, 0), x.write_shift(2, 65535), x.write_shift(2, 57005), w = 0; w < 6; ++w) x.write_shift(4, 0);
  }
  return x.slice(0, x.l);
}
function parse_LongRGBA(F) {
  var x = F.read_shift(1), w = F.read_shift(1), O = F.read_shift(1), D = F.read_shift(1);
  return [x, w, O, D];
}
function parse_LongRGB(F, x) {
  var w = parse_LongRGBA(F);
  return w[3] = 0, w;
}
function parse_XLSCell(F, x, w) {
  var O = F.read_shift(2), D = F.read_shift(2), U = { r: O, c: D, ixfe: 0 };
  if (w && w.biff == 2 || x == 7) {
    var W = F.read_shift(1);
    U.ixfe = W & 63, F.l += 2;
  } else U.ixfe = F.read_shift(2);
  return U;
}
function write_XLSCell(F, x, w, O) {
  return O || (O = new_buf(6)), O.write_shift(2, F), O.write_shift(2, x), O.write_shift(2, w || 0), O;
}
function parse_frtHeader(F) {
  var x = F.read_shift(2), w = F.read_shift(2);
  return F.l += 8, { type: x, flags: w };
}
function parse_OptXLUnicodeString(F, x, w) {
  return x === 0 ? "" : parse_XLUnicodeString2(F, x, w);
}
function parse_XTI(F, x, w) {
  var O = w.biff > 8 ? 4 : 2, D = F.read_shift(O), U = F.read_shift(O, "i"), W = F.read_shift(O, "i");
  return [D, U, W];
}
function parse_RkRec(F) {
  var x = F.read_shift(2), w = parse_RkNumber(F);
  return [x, w];
}
function parse_AddinUdf(F, x, w) {
  F.l += 4, x -= 4;
  var O = F.l + x, D = parse_ShortXLUnicodeString(F, x, w), U = F.read_shift(2);
  if (O -= F.l, U !== O) throw new Error("Malformed AddinUdf: padding = " + O + " != " + U);
  return F.l += U, D;
}
function parse_Ref8U(F) {
  var x = F.read_shift(2), w = F.read_shift(2), O = F.read_shift(2), D = F.read_shift(2);
  return { s: { c: O, r: x }, e: { c: D, r: w } };
}
function write_Ref8U(F, x) {
  return x || (x = new_buf(8)), x.write_shift(2, F.s.r), x.write_shift(2, F.e.r), x.write_shift(2, F.s.c), x.write_shift(2, F.e.c), x;
}
function parse_RefU(F) {
  var x = F.read_shift(2), w = F.read_shift(2), O = F.read_shift(1), D = F.read_shift(1);
  return { s: { c: O, r: x }, e: { c: D, r: w } };
}
var parse_Ref = parse_RefU;
function parse_FtCmo(F) {
  F.l += 4;
  var x = F.read_shift(2), w = F.read_shift(2), O = F.read_shift(2);
  return F.l += 12, [w, x, O];
}
function parse_FtNts(F) {
  var x = {};
  return F.l += 4, F.l += 16, x.fSharedNote = F.read_shift(2), F.l += 4, x;
}
function parse_FtCf(F) {
  var x = {};
  return F.l += 4, F.cf = F.read_shift(2), x;
}
function parse_FtSkip(F) {
  F.l += 2, F.l += F.read_shift(2);
}
var FtTab = {
  0: parse_FtSkip,
  /* FtEnd */
  4: parse_FtSkip,
  /* FtMacro */
  5: parse_FtSkip,
  /* FtButton */
  6: parse_FtSkip,
  /* FtGmo */
  7: parse_FtCf,
  /* FtCf */
  8: parse_FtSkip,
  /* FtPioGrbit */
  9: parse_FtSkip,
  /* FtPictFmla */
  10: parse_FtSkip,
  /* FtCbls */
  11: parse_FtSkip,
  /* FtRbo */
  12: parse_FtSkip,
  /* FtSbs */
  13: parse_FtNts,
  /* FtNts */
  14: parse_FtSkip,
  /* FtSbsFmla */
  15: parse_FtSkip,
  /* FtGboData */
  16: parse_FtSkip,
  /* FtEdoData */
  17: parse_FtSkip,
  /* FtRboData */
  18: parse_FtSkip,
  /* FtCblsData */
  19: parse_FtSkip,
  /* FtLbsData */
  20: parse_FtSkip,
  /* FtCblsFmla */
  21: parse_FtCmo
};
function parse_FtArray(F, x) {
  for (var w = F.l + x, O = []; F.l < w; ) {
    var D = F.read_shift(2);
    F.l -= 2;
    try {
      O[D] = FtTab[D](F, w - F.l);
    } catch {
      return F.l = w, O;
    }
  }
  return F.l != w && (F.l = w), O;
}
function parse_BOF(F, x) {
  var w = { BIFFVer: 0, dt: 0 };
  switch (w.BIFFVer = F.read_shift(2), x -= 2, x >= 2 && (w.dt = F.read_shift(2), F.l -= 2), w.BIFFVer) {
    case 1536:
    /* BIFF8 */
    case 1280:
    /* BIFF5 */
    case 1024:
    /* BIFF4 */
    case 768:
    /* BIFF3 */
    case 512:
    /* BIFF2 */
    case 2:
    case 7:
      break;
    default:
      if (x > 6) throw new Error("Unexpected BIFF Ver " + w.BIFFVer);
  }
  return F.read_shift(x), w;
}
function write_BOF(F, x, w) {
  var O = 1536, D = 16;
  switch (w.bookType) {
    case "biff8":
      break;
    case "biff5":
      O = 1280, D = 8;
      break;
    case "biff4":
      O = 4, D = 6;
      break;
    case "biff3":
      O = 3, D = 6;
      break;
    case "biff2":
      O = 2, D = 4;
      break;
    case "xla":
      break;
    default:
      throw new Error("unsupported BIFF version");
  }
  var U = new_buf(D);
  return U.write_shift(2, O), U.write_shift(2, x), D > 4 && U.write_shift(2, 29282), D > 6 && U.write_shift(2, 1997), D > 8 && (U.write_shift(2, 49161), U.write_shift(2, 1), U.write_shift(2, 1798), U.write_shift(2, 0)), U;
}
function parse_InterfaceHdr(F, x) {
  return x === 0 || F.read_shift(2), 1200;
}
function parse_WriteAccess(F, x, w) {
  if (w.enc)
    return F.l += x, "";
  var O = F.l, D = parse_XLUnicodeString2(F, 0, w);
  return F.read_shift(x + O - F.l), D;
}
function write_WriteAccess(F, x) {
  var w = !x || x.biff == 8, O = new_buf(w ? 112 : 54);
  for (O.write_shift(x.biff == 8 ? 2 : 1, 7), w && O.write_shift(1, 0), O.write_shift(4, 859007059), O.write_shift(4, 5458548 | (w ? 0 : 536870912)); O.l < O.length; ) O.write_shift(1, w ? 0 : 32);
  return O;
}
function parse_WsBool(F, x, w) {
  var O = w && w.biff == 8 || x == 2 ? F.read_shift(2) : (F.l += x, 0);
  return { fDialog: O & 16, fBelow: O & 64, fRight: O & 128 };
}
function parse_BoundSheet8(F, x, w) {
  var O = "";
  if (w.biff == 4)
    return O = parse_ShortXLUnicodeString(F, 0, w), O.length === 0 && (O = "Sheet1"), { name: O };
  var D = F.read_shift(4), U = F.read_shift(1) & 3, W = F.read_shift(1);
  switch (W) {
    case 0:
      W = "Worksheet";
      break;
    case 1:
      W = "Macrosheet";
      break;
    case 2:
      W = "Chartsheet";
      break;
    case 6:
      W = "VBAModule";
      break;
  }
  return O = parse_ShortXLUnicodeString(F, 0, w), O.length === 0 && (O = "Sheet1"), { pos: D, hs: U, dt: W, name: O };
}
function write_BoundSheet8(F, x) {
  var w = !x || x.biff >= 8 ? 2 : 1, O = new_buf(8 + w * F.name.length);
  O.write_shift(4, F.pos), O.write_shift(1, F.hs || 0), O.write_shift(1, F.dt), O.write_shift(1, F.name.length), x.biff >= 8 && O.write_shift(1, 1), O.write_shift(w * F.name.length, F.name, x.biff < 8 ? "sbcs" : "utf16le");
  var D = O.slice(0, O.l);
  return D.l = O.l, D;
}
function parse_SST(F, x) {
  for (var w = F.l + x, O = F.read_shift(4), D = F.read_shift(4), U = [], W = 0; W != D && F.l < w; ++W)
    U.push(parse_XLUnicodeRichExtendedString(F));
  return U.Count = O, U.Unique = D, U;
}
function write_SST(F, x) {
  var w = new_buf(8);
  w.write_shift(4, F.Count), w.write_shift(4, F.Unique);
  for (var O = [], D = 0; D < F.length; ++D) O[D] = write_XLUnicodeRichExtendedString(F[D]);
  var U = bconcat([w].concat(O));
  return U.parts = [w.length].concat(O.map(function(W) {
    return W.length;
  })), U;
}
function parse_ExtSST(F, x) {
  var w = {};
  return w.dsst = F.read_shift(2), F.l += x - 2, w;
}
function parse_Row(F) {
  var x = {};
  x.r = F.read_shift(2), x.c = F.read_shift(2), x.cnt = F.read_shift(2) - x.c;
  var w = F.read_shift(2);
  F.l += 4;
  var O = F.read_shift(1);
  return F.l += 3, O & 7 && (x.level = O & 7), O & 32 && (x.hidden = !0), O & 64 && (x.hpt = w / 20), x;
}
function parse_ForceFullCalculation(F) {
  var x = parse_frtHeader(F);
  if (x.type != 2211) throw new Error("Invalid Future Record " + x.type);
  var w = F.read_shift(4);
  return w !== 0;
}
function parse_RecalcId(F) {
  return F.read_shift(2), F.read_shift(4);
}
function parse_DefaultRowHeight(F, x, w) {
  var O = 0;
  w && w.biff == 2 || (O = F.read_shift(2));
  var D = F.read_shift(2);
  w && w.biff == 2 && (O = 1 - (D >> 15), D &= 32767);
  var U = { Unsynced: O & 1, DyZero: (O & 2) >> 1, ExAsc: (O & 4) >> 2, ExDsc: (O & 8) >> 3 };
  return [U, D];
}
function parse_Window1(F) {
  var x = F.read_shift(2), w = F.read_shift(2), O = F.read_shift(2), D = F.read_shift(2), U = F.read_shift(2), W = F.read_shift(2), X = F.read_shift(2), G = F.read_shift(2), Y = F.read_shift(2);
  return {
    Pos: [x, w],
    Dim: [O, D],
    Flags: U,
    CurTab: W,
    FirstTab: X,
    Selected: G,
    TabRatio: Y
  };
}
function write_Window1() {
  var F = new_buf(18);
  return F.write_shift(2, 0), F.write_shift(2, 0), F.write_shift(2, 29280), F.write_shift(2, 17600), F.write_shift(2, 56), F.write_shift(2, 0), F.write_shift(2, 0), F.write_shift(2, 1), F.write_shift(2, 500), F;
}
function parse_Window2(F, x, w) {
  if (w && w.biff >= 2 && w.biff < 5) return {};
  var O = F.read_shift(2);
  return { RTL: O & 64 };
}
function write_Window2(F) {
  var x = new_buf(18), w = 1718;
  return F && F.RTL && (w |= 64), x.write_shift(2, w), x.write_shift(4, 0), x.write_shift(4, 64), x.write_shift(4, 0), x.write_shift(4, 0), x;
}
function parse_Pane() {
}
function parse_Font(F, x, w) {
  var O = {
    dyHeight: F.read_shift(2),
    fl: F.read_shift(2)
  };
  switch (w && w.biff || 8) {
    case 2:
      break;
    case 3:
    case 4:
      F.l += 2;
      break;
    default:
      F.l += 10;
      break;
  }
  return O.name = parse_ShortXLUnicodeString(F, 0, w), O;
}
function write_Font(F, x) {
  var w = F.name || "Arial", O = x.biff == 5, D = O ? 15 + w.length : 16 + 2 * w.length, U = new_buf(D);
  return U.write_shift(2, (F.sz || 12) * 20), U.write_shift(4, 0), U.write_shift(2, 400), U.write_shift(4, 0), U.write_shift(2, 0), U.write_shift(1, w.length), O || U.write_shift(1, 1), U.write_shift((O ? 1 : 2) * w.length, w, O ? "sbcs" : "utf16le"), U;
}
function parse_LabelSst(F, x, w) {
  var O = parse_XLSCell(F, x, w);
  return O.isst = F.read_shift(4), O;
}
function write_LabelSst(F, x, w, O) {
  var D = new_buf(10);
  return write_XLSCell(F, x, O, D), D.write_shift(4, w), D;
}
function parse_Label(F, x, w) {
  w.biffguess && w.biff == 2 && (w.biff = 5);
  var O = F.l + x, D = parse_XLSCell(F, x, w), U = parse_XLUnicodeString(F, O - F.l, w);
  return D.val = U, D;
}
function write_Label(F, x, w, O, D) {
  var U = !D || D.biff == 8, W = new_buf(8 + +U + (1 + U) * w.length);
  return write_XLSCell(F, x, O, W), W.write_shift(2, w.length), U && W.write_shift(1, 1), W.write_shift((1 + U) * w.length, w, U ? "utf16le" : "sbcs"), W;
}
function parse_Format(F, x, w) {
  var O = F.read_shift(2), D = parse_XLUnicodeString2(F, 0, w);
  return [O, D];
}
function write_Format(F, x, w, O) {
  var D = w.biff == 5;
  O || (O = new_buf(D ? 3 + x.length : 5 + 2 * x.length)), O.write_shift(2, F), O.write_shift(D ? 1 : 2, x.length), D || O.write_shift(1, 1), O.write_shift((D ? 1 : 2) * x.length, x, D ? "sbcs" : "utf16le");
  var U = O.length > O.l ? O.slice(0, O.l) : O;
  return U.l == null && (U.l = U.length), U;
}
var parse_BIFF2Format = parse_XLUnicodeString2;
function write_BIFF2Format(F) {
  var x = new_buf(1 + F.length);
  return x.write_shift(1, F.length), x.write_shift(F.length, F, "sbcs"), x;
}
function write_BIFF4Format(F) {
  var x = new_buf(3 + F.length);
  return x.l += 2, x.write_shift(1, F.length), x.write_shift(F.length, F, "sbcs"), x;
}
function parse_Dimensions(F, x, w) {
  var O = F.l + x, D = w.biff == 8 || !w.biff ? 4 : 2, U = F.read_shift(D), W = F.read_shift(D), X = F.read_shift(2), G = F.read_shift(2);
  return F.l = O, { s: { r: U, c: X }, e: { r: W, c: G } };
}
function write_Dimensions(F, x) {
  var w = x.biff == 8 || !x.biff ? 4 : 2, O = new_buf(2 * w + 6);
  return O.write_shift(w, F.s.r), O.write_shift(w, F.e.r + 1), O.write_shift(2, F.s.c), O.write_shift(2, F.e.c + 1), O.write_shift(2, 0), O;
}
function parse_RK(F) {
  var x = F.read_shift(2), w = F.read_shift(2), O = parse_RkRec(F);
  return { r: x, c: w, ixfe: O[0], rknum: O[1] };
}
function parse_MulRk(F, x) {
  for (var w = F.l + x - 2, O = F.read_shift(2), D = F.read_shift(2), U = []; F.l < w; ) U.push(parse_RkRec(F));
  if (F.l !== w) throw new Error("MulRK read error");
  var W = F.read_shift(2);
  if (U.length != W - D + 1) throw new Error("MulRK length mismatch");
  return { r: O, c: D, C: W, rkrec: U };
}
function parse_MulBlank(F, x) {
  for (var w = F.l + x - 2, O = F.read_shift(2), D = F.read_shift(2), U = []; F.l < w; ) U.push(F.read_shift(2));
  if (F.l !== w) throw new Error("MulBlank read error");
  var W = F.read_shift(2);
  if (U.length != W - D + 1) throw new Error("MulBlank length mismatch");
  return { r: O, c: D, C: W, ixfe: U };
}
function parse_CellStyleXF(F, x, w, O) {
  var D = {}, U = F.read_shift(4), W = F.read_shift(4), X = F.read_shift(4), G = F.read_shift(2);
  return D.patternType = XLSFillPattern[X >> 26], O.cellStyles && (D.alc = U & 7, D.fWrap = U >> 3 & 1, D.alcV = U >> 4 & 7, D.fJustLast = U >> 7 & 1, D.trot = U >> 8 & 255, D.cIndent = U >> 16 & 15, D.fShrinkToFit = U >> 20 & 1, D.iReadOrder = U >> 22 & 2, D.fAtrNum = U >> 26 & 1, D.fAtrFnt = U >> 27 & 1, D.fAtrAlc = U >> 28 & 1, D.fAtrBdr = U >> 29 & 1, D.fAtrPat = U >> 30 & 1, D.fAtrProt = U >> 31 & 1, D.dgLeft = W & 15, D.dgRight = W >> 4 & 15, D.dgTop = W >> 8 & 15, D.dgBottom = W >> 12 & 15, D.icvLeft = W >> 16 & 127, D.icvRight = W >> 23 & 127, D.grbitDiag = W >> 30 & 3, D.icvTop = X & 127, D.icvBottom = X >> 7 & 127, D.icvDiag = X >> 14 & 127, D.dgDiag = X >> 21 & 15, D.icvFore = G & 127, D.icvBack = G >> 7 & 127, D.fsxButton = G >> 14 & 1), D;
}
function parse_XF(F, x, w) {
  var O = {};
  return O.ifnt = F.read_shift(2), O.numFmtId = F.read_shift(2), O.flags = F.read_shift(2), O.fStyle = O.flags >> 2 & 1, x -= 6, O.data = parse_CellStyleXF(F, x, O.fStyle, w), O;
}
function write_XF(F, x, w, O) {
  var D = w.biff == 5;
  O || (O = new_buf(D ? 16 : 20)), O.write_shift(2, 0), F.style ? (O.write_shift(2, F.numFmtId || 0), O.write_shift(2, 65524)) : (O.write_shift(2, F.numFmtId || 0), O.write_shift(2, x << 4));
  var U = 0;
  return F.numFmtId > 0 && D && (U |= 1024), O.write_shift(4, U), O.write_shift(4, 0), D || O.write_shift(4, 0), O.write_shift(2, 0), O;
}
function parse_BIFF2XF(F) {
  var x = {};
  return x.ifnt = F.read_shift(1), F.l++, x.flags = F.read_shift(1), x.numFmtId = x.flags & 63, x.flags >>= 6, x.fStyle = 0, x.data = {}, x;
}
function write_BIFF2XF(F) {
  var x = new_buf(4);
  return x.l += 2, x.write_shift(1, F.numFmtId), x.l++, x;
}
function write_BIFF3XF(F) {
  var x = new_buf(12);
  return x.l++, x.write_shift(1, F.numFmtId), x.l += 10, x;
}
var write_BIFF4XF = write_BIFF3XF;
function parse_BIFF3XF(F) {
  var x = {};
  return x.ifnt = F.read_shift(1), x.numFmtId = F.read_shift(1), x.flags = F.read_shift(2), x.fStyle = x.flags >> 2 & 1, x.data = {}, x;
}
function parse_BIFF4XF(F) {
  var x = {};
  return x.ifnt = F.read_shift(1), x.numFmtId = F.read_shift(1), x.flags = F.read_shift(2), x.fStyle = x.flags >> 2 & 1, x.data = {}, x;
}
function parse_Guts(F) {
  F.l += 4;
  var x = [F.read_shift(2), F.read_shift(2)];
  if (x[0] !== 0 && x[0]--, x[1] !== 0 && x[1]--, x[0] > 7 || x[1] > 7) throw new Error("Bad Gutters: " + x.join("|"));
  return x;
}
function write_Guts(F) {
  var x = new_buf(8);
  return x.write_shift(4, 0), x.write_shift(2, 0), x.write_shift(2, 0), x;
}
function parse_BoolErr(F, x, w) {
  var O = parse_XLSCell(F, 6, w), D = parse_Bes(F);
  return O.val = D, O.t = D === !0 || D === !1 ? "b" : "e", O;
}
function write_BoolErr(F, x, w, O, D, U) {
  var W = new_buf(8);
  return write_XLSCell(F, x, O, W), write_Bes(w, U, W), W;
}
function parse_Number(F, x, w) {
  w.biffguess && w.biff == 2 && (w.biff = 5);
  var O = parse_XLSCell(F, 6, w), D = parse_Xnum(F);
  return O.val = D, O;
}
function write_Number(F, x, w, O) {
  var D = new_buf(14);
  return write_XLSCell(F, x, O, D), write_Xnum(w, D), D;
}
var parse_XLHeaderFooter = parse_OptXLUnicodeString;
function parse_SupBook(F, x, w) {
  var O = F.l + x, D = F.read_shift(2), U = F.read_shift(2);
  if (w.sbcch = U, U == 1025 || U == 14849) return [U, D];
  if (U < 1 || U > 255) throw new Error("Unexpected SupBook type: " + U);
  for (var W = parse_XLUnicodeStringNoCch(F, U), X = []; O > F.l; ) X.push(parse_XLUnicodeString(F));
  return [U, D, W, X];
}
function parse_ExternName(F, x, w) {
  var O = F.read_shift(2), D, U = {
    fBuiltIn: O & 1,
    fWantAdvise: O >>> 1 & 1,
    fWantPict: O >>> 2 & 1,
    fOle: O >>> 3 & 1,
    fOleLink: O >>> 4 & 1,
    cf: O >>> 5 & 1023,
    fIcon: O >>> 15 & 1
  };
  return w.sbcch === 14849 && (D = parse_AddinUdf(F, x - 2, w)), U.body = D || F.read_shift(x - 2), typeof D == "string" && (U.Name = D), U;
}
function parse_Lbl(F, x, w) {
  var O = F.l + x, D = F.read_shift(2), U = F.read_shift(1), W = F.read_shift(1), X = F.read_shift(w && w.biff == 2 ? 1 : 2), G = 0;
  (!w || w.biff >= 5) && (w.biff != 5 && (F.l += 2), G = F.read_shift(2), w.biff == 5 && (F.l += 2), F.l += 4);
  var Y = parse_XLUnicodeStringNoCch(F, W, w);
  D & 32 && (Y = XLSLblBuiltIn[Y.charCodeAt(0)]);
  var K = O - F.l;
  w && w.biff == 2 && --K;
  var Z = O == F.l || X === 0 || !(K > 0) ? [] : parse_NameParsedFormula(F, K, w, X);
  return {
    chKey: U,
    Name: Y,
    itab: G,
    rgce: Z
  };
}
function parse_ExternSheet(F, x, w) {
  if (w.biff < 8 || !(w.biff > 8) && x == F[F.l] + (F[F.l + 1] == 3 ? 1 : 0) + 1) return parse_BIFF5ExternSheet(F, x, w);
  for (var O = [], D = F.l + x, U = F.read_shift(w.biff > 8 ? 4 : 2); U-- !== 0; ) O.push(parse_XTI(F, w.biff > 8 ? 12 : 6, w));
  if (F.l != D) throw new Error("Bad ExternSheet: " + F.l + " != " + D);
  return O;
}
function parse_BIFF5ExternSheet(F, x, w) {
  F[F.l + 1] == 3 && F[F.l]++;
  var O = parse_ShortXLUnicodeString(F, x, w);
  return O.charCodeAt(0) == 3 ? O.slice(1) : O;
}
function parse_NameCmt(F, x, w) {
  if (w.biff < 8) {
    F.l += x;
    return;
  }
  var O = F.read_shift(2), D = F.read_shift(2), U = parse_XLUnicodeStringNoCch(F, O, w), W = parse_XLUnicodeStringNoCch(F, D, w);
  return [U, W];
}
function parse_ShrFmla(F, x, w) {
  var O = parse_RefU(F);
  F.l++;
  var D = F.read_shift(1);
  return x -= 8, [parse_SharedParsedFormula(F, x, w), D, O];
}
function parse_Array(F, x, w) {
  var O = parse_Ref(F);
  switch (w.biff) {
    case 2:
      F.l++, x -= 7;
      break;
    case 3:
    case 4:
      F.l += 2, x -= 8;
      break;
    default:
      F.l += 6, x -= 12;
  }
  return [O, parse_ArrayParsedFormula(F, x, w)];
}
function parse_MTRSettings(F) {
  var x = F.read_shift(4) !== 0, w = F.read_shift(4) !== 0, O = F.read_shift(4);
  return [x, w, O];
}
function parse_NoteSh(F, x, w) {
  var O = F.read_shift(2), D = F.read_shift(2), U = F.read_shift(2), W = F.read_shift(2), X = parse_XLUnicodeString2(F, 0, w);
  return [{ r: O, c: D }, X, W, U];
}
function parse_Note(F, x, w) {
  if (w && w.biff < 8) {
    var O = F.read_shift(2), D = F.read_shift(2);
    if (O == 65535 || O == -1) return;
    var U = F.read_shift(2), W = F.read_shift(Math.min(U, 2048), "cpstr");
    return [{ r: O, c: D }, W];
  }
  return parse_NoteSh(F, x, w);
}
function write_NOTE_BIFF2(F, x, w, O) {
  var D = new_buf(6 + (O || F.length));
  return D.write_shift(2, x), D.write_shift(2, w), D.write_shift(2, O || F.length), D.write_shift(F.length, F, "sbcs"), D;
}
function parse_MergeCells(F, x) {
  for (var w = [], O = F.read_shift(2); O--; ) w.push(parse_Ref8U(F));
  return w;
}
function write_MergeCells(F) {
  var x = new_buf(2 + F.length * 8);
  x.write_shift(2, F.length);
  for (var w = 0; w < F.length; ++w) write_Ref8U(F[w], x);
  return x;
}
function parse_Obj(F, x, w) {
  if (w && w.biff < 8) return parse_BIFF5Obj(F, x, w);
  var O = parse_FtCmo(F), D = parse_FtArray(F, x - 22, O[1]);
  return { cmo: O, ft: D };
}
var parse_BIFF5OT = {
  8: function(F, x) {
    var w = F.l + x;
    F.l += 10;
    var O = F.read_shift(2);
    F.l += 4, F.l += 2, F.l += 2, F.l += 2, F.l += 4;
    var D = F.read_shift(1);
    return F.l += D, F.l = w, { fmt: O };
  }
};
function parse_BIFF5Obj(F, x, w) {
  F.l += 4;
  var O = F.read_shift(2), D = F.read_shift(2), U = F.read_shift(2);
  F.l += 2, F.l += 2, F.l += 2, F.l += 2, F.l += 2, F.l += 2, F.l += 2, F.l += 2, F.l += 2, F.l += 6, x -= 36;
  var W = [];
  return W.push((parse_BIFF5OT[O] || parsenoop)(F, x, w)), { cmo: [D, O, U], ft: W };
}
function parse_TxO(F, x, w) {
  var O = F.l, D = "";
  try {
    F.l += 4;
    var U = (w.lastobj || { cmo: [0, 0] }).cmo[1], W;
    [0, 5, 7, 11, 12, 14].indexOf(U) == -1 ? F.l += 6 : W = parse_ControlInfo(F, 6, w);
    var X = F.read_shift(2);
    F.read_shift(2), parseuint16(F, 2);
    var G = F.read_shift(2);
    F.l += G;
    for (var Y = 1; Y < F.lens.length - 1; ++Y) {
      if (F.l - O != F.lens[Y]) throw new Error("TxO: bad continue record");
      var K = F[F.l], Z = parse_XLUnicodeStringNoCch(F, F.lens[Y + 1] - F.lens[Y] - 1);
      if (D += Z, D.length >= (K ? X : 2 * X)) break;
    }
    if (D.length !== X && D.length !== X * 2)
      throw new Error("cchText: " + X + " != " + D.length);
    return F.l = O + x, { t: D };
  } catch {
    return F.l = O + x, { t: D };
  }
}
function parse_HLink(F, x) {
  var w = parse_Ref8U(F);
  F.l += 16;
  var O = parse_Hyperlink(F, x - 24);
  return [w, O];
}
function write_HLink(F) {
  var x = new_buf(24), w = decode_cell(F[0]);
  x.write_shift(2, w.r), x.write_shift(2, w.r), x.write_shift(2, w.c), x.write_shift(2, w.c);
  for (var O = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" "), D = 0; D < 16; ++D) x.write_shift(1, parseInt(O[D], 16));
  return bconcat([x, write_Hyperlink(F[1])]);
}
function parse_HLinkTooltip(F, x) {
  F.read_shift(2);
  var w = parse_Ref8U(F), O = F.read_shift((x - 10) / 2, "dbcs-cont");
  return O = O.replace(chr0, ""), [w, O];
}
function write_HLinkTooltip(F) {
  var x = F[1].Tooltip, w = new_buf(10 + 2 * (x.length + 1));
  w.write_shift(2, 2048);
  var O = decode_cell(F[0]);
  w.write_shift(2, O.r), w.write_shift(2, O.r), w.write_shift(2, O.c), w.write_shift(2, O.c);
  for (var D = 0; D < x.length; ++D) w.write_shift(2, x.charCodeAt(D));
  return w.write_shift(2, 0), w;
}
function parse_Country(F) {
  var x = [0, 0], w;
  return w = F.read_shift(2), x[0] = CountryEnum[w] || w, w = F.read_shift(2), x[1] = CountryEnum[w] || w, x;
}
function write_Country(F) {
  return F || (F = new_buf(4)), F.write_shift(2, 1), F.write_shift(2, 1), F;
}
function parse_ClrtClient(F) {
  for (var x = F.read_shift(2), w = []; x-- > 0; ) w.push(parse_LongRGB(F));
  return w;
}
function parse_Palette(F) {
  for (var x = F.read_shift(2), w = []; x-- > 0; ) w.push(parse_LongRGB(F));
  return w;
}
function parse_XFCRC(F) {
  F.l += 2;
  var x = { cxfs: 0, crc: 0 };
  return x.cxfs = F.read_shift(2), x.crc = F.read_shift(4), x;
}
function parse_ColInfo(F, x, w) {
  if (!w.cellStyles) return parsenoop(F, x);
  var O = w && w.biff >= 12 ? 4 : 2, D = F.read_shift(O), U = F.read_shift(O), W = F.read_shift(O), X = F.read_shift(O), G = F.read_shift(2);
  O == 2 && (F.l += 2);
  var Y = { s: D, e: U, w: W, ixfe: X, flags: G };
  return (w.biff >= 5 || !w.biff) && (Y.level = G >> 8 & 7), Y;
}
function write_ColInfo(F, x) {
  var w = new_buf(12);
  w.write_shift(2, x), w.write_shift(2, x), w.write_shift(2, F.width * 256), w.write_shift(2, 0);
  var O = 0;
  return F.hidden && (O |= 1), w.write_shift(1, O), O = F.level || 0, w.write_shift(1, O), w.write_shift(2, 0), w;
}
function parse_Setup(F, x) {
  var w = {};
  return x < 32 || (F.l += 16, w.header = parse_Xnum(F), w.footer = parse_Xnum(F), F.l += 2), w;
}
function parse_ShtProps(F, x, w) {
  var O = { area: !1 };
  if (w.biff != 5)
    return F.l += x, O;
  var D = F.read_shift(1);
  return F.l += 3, D & 16 && (O.area = !0), O;
}
function write_RRTabId(F) {
  for (var x = new_buf(2 * F), w = 0; w < F; ++w) x.write_shift(2, w + 1);
  return x;
}
var parse_Blank = parse_XLSCell, parse_Scl = parseuint16a, parse_String = parse_XLUnicodeString;
function parse_ImData(F) {
  var x = F.read_shift(2), w = F.read_shift(2), O = F.read_shift(4), D = { fmt: x, env: w, len: O, data: F.slice(F.l, F.l + O) };
  return F.l += O, D;
}
function write_BIFF2Cell(F, x, w, O, D) {
  return F || (F = new_buf(7)), F.write_shift(2, x), F.write_shift(2, w), F.write_shift(
    1,
    O || 0
    /* & 0x3F */
  ), F.write_shift(
    1,
    D || 0
    /* & 0x3F */
  ), F.write_shift(1, 0), F;
}
function parse_BIFF2STR(F, x, w) {
  w.biffguess && w.biff == 5 && (w.biff = 2);
  var O = parse_XLSCell(F, 7, w), D = parse_XLUnicodeString2(F, x - 7, w);
  return O.t = "str", O.val = D, O;
}
function parse_BIFF2NUM(F, x, w) {
  var O = parse_XLSCell(F, 7, w), D = parse_Xnum(F);
  return O.t = "n", O.val = D, O;
}
function write_BIFF2NUM(F, x, w, O, D) {
  var U = new_buf(15);
  return write_BIFF2Cell(U, F, x, O || 0, D || 0), U.write_shift(8, w, "f"), U;
}
function parse_BIFF2INT(F, x, w) {
  var O = parse_XLSCell(F, 7, w), D = F.read_shift(2);
  return O.t = "n", O.val = D, O;
}
function write_BIFF2INT(F, x, w, O, D) {
  var U = new_buf(9);
  return write_BIFF2Cell(U, F, x, O || 0, D || 0), U.write_shift(2, w), U;
}
function parse_BIFF2STRING(F) {
  var x = F.read_shift(1);
  return x === 0 ? (F.l++, "") : F.read_shift(x, "sbcs-cont");
}
function parse_BIFF2BOOLERR(F, x, w) {
  var O = F.l + 7, D = parse_XLSCell(F, 6, w);
  F.l = O;
  var U = parse_Bes(F);
  return D.val = U, D.t = U === !0 || U === !1 ? "b" : "e", D;
}
function parse_BIFF2FONTXTRA(F, x) {
  F.l += 6, F.l += 2, F.l += 1, F.l += 3, F.l += 1, F.l += x - 13;
}
function parse_RString(F, x, w) {
  var O = F.l + x, D = parse_XLSCell(F, 6, w), U = F.read_shift(2), W = parse_XLUnicodeStringNoCch(F, U, w);
  return F.l = O, D.t = "str", D.val = W, D;
}
function parse_BIFF4SheetInfo(F) {
  var x = F.read_shift(4), w = F.read_shift(1), O = F.read_shift(w, "sbcs");
  return O.length === 0 && (O = "Sheet1"), { flags: x, name: O };
}
var DBF_SUPPORTED_VERSIONS = [2, 3, 48, 49, 131, 139, 140, 245], DBF = /* @__PURE__ */ function() {
  var F = {
    /* Code Pages Supported by Visual FoxPro */
    1: 437,
    2: 850,
    3: 1252,
    4: 1e4,
    100: 852,
    101: 866,
    102: 865,
    103: 861,
    104: 895,
    105: 620,
    106: 737,
    107: 857,
    120: 950,
    121: 949,
    122: 936,
    123: 932,
    124: 874,
    125: 1255,
    126: 1256,
    150: 10007,
    151: 10029,
    152: 10006,
    200: 1250,
    201: 1251,
    202: 1254,
    203: 1253,
    /* shapefile DBF extension */
    0: 20127,
    8: 865,
    9: 437,
    10: 850,
    11: 437,
    13: 437,
    14: 850,
    15: 437,
    16: 850,
    17: 437,
    18: 850,
    19: 932,
    20: 850,
    21: 437,
    22: 850,
    23: 865,
    24: 437,
    25: 437,
    26: 850,
    27: 437,
    28: 863,
    29: 850,
    31: 852,
    34: 852,
    35: 852,
    36: 860,
    37: 850,
    38: 866,
    55: 850,
    64: 852,
    77: 936,
    78: 949,
    79: 950,
    80: 874,
    87: 1252,
    88: 1252,
    89: 1252,
    108: 863,
    134: 737,
    135: 852,
    136: 857,
    204: 1257,
    255: 16969
  }, x = evert({
    1: 437,
    2: 850,
    3: 1252,
    4: 1e4,
    100: 852,
    101: 866,
    102: 865,
    103: 861,
    104: 895,
    105: 620,
    106: 737,
    107: 857,
    120: 950,
    121: 949,
    122: 936,
    123: 932,
    124: 874,
    125: 1255,
    126: 1256,
    150: 10007,
    151: 10029,
    152: 10006,
    200: 1250,
    201: 1251,
    202: 1254,
    203: 1253,
    0: 20127
  });
  function w(X, G) {
    var Y = [], K = new_raw_buf(1);
    switch (G.type) {
      case "base64":
        K = s2a(Base64_decode(X));
        break;
      case "binary":
        K = s2a(X);
        break;
      case "buffer":
      case "array":
        K = X;
        break;
    }
    prep_blob(K, 0);
    var Z = K.read_shift(1), q = !!(Z & 136), J = !1, ee = !1;
    switch (Z) {
      case 2:
        break;
      // dBASE II
      case 3:
        break;
      // dBASE III
      case 48:
        J = !0, q = !0;
        break;
      // VFP
      case 49:
        J = !0, q = !0;
        break;
      // VFP with autoincrement
      // 0x43 dBASE IV SQL table files
      // 0x63 dBASE IV SQL system files
      case 131:
        break;
      // dBASE III with memo
      case 139:
        break;
      // dBASE IV with memo
      case 140:
        ee = !0;
        break;
      // dBASE Level 7 with memo
      // case 0xCB dBASE IV SQL table files with memo
      case 245:
        break;
      // FoxPro 2.x with memo
      // case 0xFB FoxBASE
      default:
        throw new Error("DBF Unsupported Version: " + Z.toString(16));
    }
    var re = 0, te = 521;
    Z == 2 && (re = K.read_shift(2)), K.l += 3, Z != 2 && (re = K.read_shift(4)), re > 1048576 && (re = 1e6), Z != 2 && (te = K.read_shift(2));
    var Q = K.read_shift(2), oe = G.codepage || 1252;
    Z != 2 && (K.l += 16, K.read_shift(1), K[K.l] !== 0 && (oe = F[K[K.l]]), K.l += 1, K.l += 2), ee && (K.l += 36);
    for (var ne = [], le = {}, Ee = Math.min(K.length, Z == 2 ? 521 : te - 10 - (J ? 264 : 0)), Te = ee ? 32 : 11; K.l < Ee && K[K.l] != 13; )
      switch (le = {}, le.name = (typeof $cptable < "u" ? $cptable.utils.decode(oe, K.slice(K.l, K.l + Te)) : a2s(K.slice(K.l, K.l + Te))).replace(/[\u0000\r\n][\S\s]*$/g, ""), K.l += Te, le.type = String.fromCharCode(K.read_shift(1)), Z != 2 && !ee && (le.offset = K.read_shift(4)), le.len = K.read_shift(1), Z == 2 && (le.offset = K.read_shift(2)), le.dec = K.read_shift(1), le.name.length && ne.push(le), Z != 2 && (K.l += ee ? 13 : 14), le.type) {
        case "B":
          (!J || le.len != 8) && G.WTF && console.log("Skipping " + le.name + ":" + le.type);
          break;
        case "G":
        // General (FoxPro and dBASE L7)
        case "P":
          G.WTF && console.log("Skipping " + le.name + ":" + le.type);
          break;
        case "+":
        // Autoincrement (dBASE L7 only)
        case "0":
        // _NullFlags (VFP only)
        case "@":
        // Timestamp (dBASE L7 only)
        case "C":
        // Character (dBASE II)
        case "D":
        // Date (dBASE III)
        case "F":
        // Float (dBASE IV)
        case "I":
        // Long (VFP and dBASE L7)
        case "L":
        // Logical (dBASE II)
        case "M":
        // Memo (dBASE III)
        case "N":
        // Number (dBASE II)
        case "O":
        // Double (dBASE L7 only)
        case "T":
        // Datetime (VFP only)
        case "Y":
          break;
        default:
          throw new Error("Unknown Field Type: " + le.type);
      }
    if (K[K.l] !== 13 && (K.l = te - 1), K.read_shift(1) !== 13) throw new Error("DBF Terminator not found " + K.l + " " + K[K.l]);
    K.l = te;
    var de = 0, ae = 0;
    for (Y[0] = [], ae = 0; ae != ne.length; ++ae) Y[0][ae] = ne[ae].name;
    for (; re-- > 0; ) {
      if (K[K.l] === 42) {
        K.l += Q;
        continue;
      }
      for (++K.l, Y[++de] = [], ae = 0, ae = 0; ae != ne.length; ++ae) {
        var se = K.slice(K.l, K.l + ne[ae].len);
        K.l += ne[ae].len, prep_blob(se, 0);
        var ce = typeof $cptable < "u" ? $cptable.utils.decode(oe, se) : a2s(se);
        switch (ne[ae].type) {
          case "C":
            ce.trim().length && (Y[de][ae] = ce.replace(/([^\s])\s+$/, "$1"));
            break;
          case "D":
            ce.length === 8 ? (Y[de][ae] = new Date(Date.UTC(+ce.slice(0, 4), +ce.slice(4, 6) - 1, +ce.slice(6, 8), 0, 0, 0, 0)), G.UTC || (Y[de][ae] = utc_to_local(Y[de][ae]))) : Y[de][ae] = ce;
            break;
          case "F":
            Y[de][ae] = parseFloat(ce.trim());
            break;
          case "+":
          case "I":
            Y[de][ae] = ee ? se.read_shift(-4, "i") ^ 2147483648 : se.read_shift(4, "i");
            break;
          case "L":
            switch (ce.trim().toUpperCase()) {
              case "Y":
              case "T":
                Y[de][ae] = !0;
                break;
              case "N":
              case "F":
                Y[de][ae] = !1;
                break;
              case "":
              case "\0":
              case "?":
                break;
              default:
                throw new Error("DBF Unrecognized L:|" + ce + "|");
            }
            break;
          case "M":
            if (!q) throw new Error("DBF Unexpected MEMO for type " + Z.toString(16));
            Y[de][ae] = "##MEMO##" + (ee ? parseInt(ce.trim(), 10) : se.read_shift(4));
            break;
          case "N":
            ce = ce.replace(/\u0000/g, "").trim(), ce && ce != "." && (Y[de][ae] = +ce || 0);
            break;
          case "@":
            Y[de][ae] = new Date(se.read_shift(-8, "f") - 621356832e5);
            break;
          case "T":
            {
              var xe = se.read_shift(4), Ce = se.read_shift(4);
              if (xe == 0 && Ce == 0) break;
              Y[de][ae] = new Date((xe - 2440588) * 864e5 + Ce), G.UTC || (Y[de][ae] = utc_to_local(Y[de][ae]));
            }
            break;
          case "Y":
            Y[de][ae] = se.read_shift(4, "i") / 1e4 + se.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
            break;
          case "O":
            Y[de][ae] = -se.read_shift(-8, "f");
            break;
          case "B":
            if (J && ne[ae].len == 8) {
              Y[de][ae] = se.read_shift(8, "f");
              break;
            }
          /* falls through */
          case "G":
          case "P":
            se.l += ne[ae].len;
            break;
          case "0":
            if (ne[ae].name === "_NullFlags") break;
          /* falls through */
          default:
            throw new Error("DBF Unsupported data type " + ne[ae].type);
        }
      }
    }
    if (Z != 2 && K.l < K.length && K[K.l++] != 26) throw new Error("DBF EOF Marker missing " + (K.l - 1) + " of " + K.length + " " + K[K.l - 1].toString(16));
    return G.sheetRows && (Y = Y.slice(0, G.sheetRows)), G.DBF = ne, Y;
  }
  function O(X, G) {
    var Y = G || {};
    Y.dateNF || (Y.dateNF = "yyyymmdd");
    var K = aoa_to_sheet(w(X, Y), Y);
    return K["!cols"] = Y.DBF.map(function(Z) {
      return {
        wch: Z.len,
        DBF: Z
      };
    }), delete Y.DBF, K;
  }
  function D(X, G) {
    try {
      var Y = sheet_to_workbook(O(X, G), G);
      return Y.bookType = "dbf", Y;
    } catch (K) {
      if (G && G.WTF) throw K;
    }
    return { SheetNames: [], Sheets: {} };
  }
  var U = { B: 8, C: 250, L: 1, D: 8, "?": 0, "": 0 };
  function W(X, G) {
    if (!X["!ref"]) throw new Error("Cannot export empty sheet to DBF");
    var Y = G || {}, K = current_codepage;
    if (+Y.codepage >= 0 && set_cp(+Y.codepage), Y.type == "string") throw new Error("Cannot write DBF to JS string");
    var Z = buf_array(), q = sheet_to_json(X, { header: 1, raw: !0, cellDates: !0 }), J = q[0], ee = q.slice(1), re = X["!cols"] || [], te = 0, Q = 0, oe = 0, ne = 1;
    for (te = 0; te < J.length; ++te) {
      if (((re[te] || {}).DBF || {}).name) {
        J[te] = re[te].DBF.name, ++oe;
        continue;
      }
      if (J[te] != null) {
        if (++oe, typeof J[te] == "number" && (J[te] = J[te].toString(10)), typeof J[te] != "string") throw new Error("DBF Invalid column name " + J[te] + " |" + typeof J[te] + "|");
        if (J.indexOf(J[te]) !== te) {
          for (Q = 0; Q < 1024; ++Q)
            if (J.indexOf(J[te] + "_" + Q) == -1) {
              J[te] += "_" + Q;
              break;
            }
        }
      }
    }
    var le = safe_decode_range(X["!ref"]), Ee = [], Te = [], de = [];
    for (te = 0; te <= le.e.c - le.s.c; ++te) {
      var ae = "", se = "", ce = 0, xe = [];
      for (Q = 0; Q < ee.length; ++Q)
        ee[Q][te] != null && xe.push(ee[Q][te]);
      if (xe.length == 0 || J[te] == null) {
        Ee[te] = "?";
        continue;
      }
      for (Q = 0; Q < xe.length; ++Q) {
        switch (typeof xe[Q]) {
          /* TODO: check if L2 compat is desired */
          case "number":
            se = "B";
            break;
          case "string":
            se = "C";
            break;
          case "boolean":
            se = "L";
            break;
          case "object":
            se = xe[Q] instanceof Date ? "D" : "C";
            break;
          default:
            se = "C";
        }
        ce = Math.max(ce, (typeof $cptable < "u" && typeof xe[Q] == "string" ? $cptable.utils.encode(current_ansi, xe[Q]) : String(xe[Q])).length), ae = ae && ae != se ? "C" : se;
      }
      ce > 250 && (ce = 250), se = ((re[te] || {}).DBF || {}).type, se == "C" && re[te].DBF.len > ce && (ce = re[te].DBF.len), ae == "B" && se == "N" && (ae = "N", de[te] = re[te].DBF.dec, ce = re[te].DBF.len), Te[te] = ae == "C" || se == "N" ? ce : U[ae] || 0, ne += Te[te], Ee[te] = ae;
    }
    var Ce = Z.next(32);
    for (Ce.write_shift(4, 318902576), Ce.write_shift(4, ee.length), Ce.write_shift(2, 296 + 32 * oe), Ce.write_shift(2, ne), te = 0; te < 4; ++te) Ce.write_shift(4, 0);
    var ye = +x[
      /*::String(*/
      current_codepage
      /*::)*/
    ] || 3;
    for (Ce.write_shift(4, 0 | ye << 8), F[ye] != +Y.codepage && (Y.codepage && console.error("DBF Unsupported codepage " + current_codepage + ", using 1252"), current_codepage = 1252), te = 0, Q = 0; te < J.length; ++te)
      if (J[te] != null) {
        var ze = Z.next(32), De = (J[te].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
        ze.write_shift(1, De, "sbcs"), ze.write_shift(1, Ee[te] == "?" ? "C" : Ee[te], "sbcs"), ze.write_shift(4, Q), ze.write_shift(1, Te[te] || U[Ee[te]] || 0), ze.write_shift(1, de[te] || 0), ze.write_shift(1, 2), ze.write_shift(4, 0), ze.write_shift(1, 0), ze.write_shift(4, 0), ze.write_shift(4, 0), Q += Te[te] || U[Ee[te]] || 0;
      }
    var et = Z.next(264);
    for (et.write_shift(4, 13), te = 0; te < 65; ++te) et.write_shift(4, 0);
    for (te = 0; te < ee.length; ++te) {
      var Oe = Z.next(ne);
      for (Oe.write_shift(1, 0), Q = 0; Q < J.length; ++Q)
        if (J[Q] != null)
          switch (Ee[Q]) {
            case "L":
              Oe.write_shift(1, ee[te][Q] == null ? 63 : ee[te][Q] ? 84 : 70);
              break;
            case "B":
              Oe.write_shift(8, ee[te][Q] || 0, "f");
              break;
            case "N":
              var Xe = "0";
              for (typeof ee[te][Q] == "number" && (Xe = ee[te][Q].toFixed(de[Q] || 0)), Xe.length > Te[Q] && (Xe = Xe.slice(0, Te[Q])), oe = 0; oe < Te[Q] - Xe.length; ++oe) Oe.write_shift(1, 32);
              Oe.write_shift(1, Xe, "sbcs");
              break;
            case "D":
              ee[te][Q] ? (Oe.write_shift(4, ("0000" + ee[te][Q].getFullYear()).slice(-4), "sbcs"), Oe.write_shift(2, ("00" + (ee[te][Q].getMonth() + 1)).slice(-2), "sbcs"), Oe.write_shift(2, ("00" + ee[te][Q].getDate()).slice(-2), "sbcs")) : Oe.write_shift(8, "00000000", "sbcs");
              break;
            case "C":
              var He = Oe.l, Ae = String(ee[te][Q] != null ? ee[te][Q] : "").slice(0, Te[Q]);
              for (Oe.write_shift(1, Ae, "cpstr"), He += Te[Q] - Oe.l, oe = 0; oe < He; ++oe) Oe.write_shift(1, 32);
              break;
          }
    }
    return current_codepage = K, Z.next(1).write_shift(1, 26), Z.end();
  }
  return {
    to_workbook: D,
    to_sheet: O,
    from_sheet: W
  };
}(), SYLK = /* @__PURE__ */ function() {
  var F = {
    AA: "À",
    BA: "Á",
    CA: "Â",
    DA: 195,
    HA: "Ä",
    JA: 197,
    AE: "È",
    BE: "É",
    CE: "Ê",
    HE: "Ë",
    AI: "Ì",
    BI: "Í",
    CI: "Î",
    HI: "Ï",
    AO: "Ò",
    BO: "Ó",
    CO: "Ô",
    DO: 213,
    HO: "Ö",
    AU: "Ù",
    BU: "Ú",
    CU: "Û",
    HU: "Ü",
    Aa: "à",
    Ba: "á",
    Ca: "â",
    Da: 227,
    Ha: "ä",
    Ja: 229,
    Ae: "è",
    Be: "é",
    Ce: "ê",
    He: "ë",
    Ai: "ì",
    Bi: "í",
    Ci: "î",
    Hi: "ï",
    Ao: "ò",
    Bo: "ó",
    Co: "ô",
    Do: 245,
    Ho: "ö",
    Au: "ù",
    Bu: "ú",
    Cu: "û",
    Hu: "ü",
    KC: "Ç",
    Kc: "ç",
    q: "æ",
    z: "œ",
    a: "Æ",
    j: "Œ",
    DN: 209,
    Dn: 241,
    Hy: 255,
    S: 169,
    c: 170,
    R: 174,
    "B ": 180,
    0: 176,
    1: 177,
    2: 178,
    3: 179,
    5: 181,
    6: 182,
    7: 183,
    Q: 185,
    k: 186,
    b: 208,
    i: 216,
    l: 222,
    s: 240,
    y: 248,
    "!": 161,
    '"': 162,
    "#": 163,
    "(": 164,
    "%": 165,
    "'": 167,
    "H ": 168,
    "+": 171,
    ";": 187,
    "<": 188,
    "=": 189,
    ">": 190,
    "?": 191,
    "{": 223
  }, x = new RegExp("\x1BN(" + keys(F).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1").replace("{", "\\{") + "|\\|)", "gm");
  try {
    x = new RegExp("\x1BN(" + keys(F).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm");
  } catch {
  }
  var w = function(J, ee) {
    var re = F[ee];
    return typeof re == "number" ? _getansi(re) : re;
  }, O = function(J, ee, re) {
    var te = ee.charCodeAt(0) - 32 << 4 | re.charCodeAt(0) - 48;
    return te == 59 ? J : _getansi(te);
  };
  F["|"] = 254;
  var D = function(J) {
    return J.replace(/\n/g, "\x1B :").replace(/\r/g, "\x1B =");
  };
  function U(J, ee) {
    switch (ee.type) {
      case "base64":
        return W(Base64_decode(J), ee);
      case "binary":
        return W(J, ee);
      case "buffer":
        return W(has_buf && Buffer.isBuffer(J) ? J.toString("binary") : a2s(J), ee);
      case "array":
        return W(cc2str(J), ee);
    }
    throw new Error("Unrecognized type " + ee.type);
  }
  function W(J, ee) {
    var re = J.split(/[\n\r]+/), te = -1, Q = -1, oe = 0, ne = 0, le = [], Ee = [], Te = null, de = {}, ae = [], se = [], ce = [], xe = 0, Ce, ye = { Workbook: { WBProps: {}, Names: [] } };
    for (+ee.codepage >= 0 && set_cp(+ee.codepage); oe !== re.length; ++oe) {
      xe = 0;
      var ze = re[oe].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, O).replace(x, w), De = ze.replace(/;;/g, "\0").split(";").map(function(me) {
        return me.replace(/\u0000/g, ";");
      }), et = De[0], Oe;
      if (ze.length > 0) switch (et) {
        case "ID":
          break;
        /* header */
        case "E":
          break;
        /* EOF */
        case "B":
          break;
        /* dimensions */
        case "O":
          for (ne = 1; ne < De.length; ++ne) switch (De[ne].charAt(0)) {
            case "V":
              {
                var Xe = parseInt(De[ne].slice(1), 10);
                Xe >= 1 && Xe <= 4 && (ye.Workbook.WBProps.date1904 = !0);
              }
              break;
          }
          break;
        case "W":
          break;
        /* window */
        case "P":
          switch (De[1].charAt(0)) {
            case "P":
              Ee.push(ze.slice(3).replace(/;;/g, ";"));
              break;
          }
          break;
        case "NN":
          {
            var He = { Sheet: 0 };
            for (ne = 1; ne < De.length; ++ne) switch (De[ne].charAt(0)) {
              case "N":
                He.Name = De[ne].slice(1);
                break;
              case "E":
                He.Ref = (ee && ee.sheet || "Sheet1") + "!" + rc_to_a1(De[ne].slice(1));
                break;
            }
            ye.Workbook.Names.push(He);
          }
          break;
        // case 'NE': // ??
        // case 'NU': // ??
        case "C":
          var Ae = !1, qe = !1, Ue = !1, Re = !1, Me = -1, je = -1, Je = "", rt = "z", fe = "";
          for (ne = 1; ne < De.length; ++ne) switch (De[ne].charAt(0)) {
            case "A":
              fe = De[ne].slice(1);
              break;
            // TODO: comment
            case "X":
              Q = parseInt(De[ne].slice(1), 10) - 1, qe = !0;
              break;
            case "Y":
              for (te = parseInt(De[ne].slice(1), 10) - 1, qe || (Q = 0), Ce = le.length; Ce <= te; ++Ce) le[Ce] = [];
              break;
            case "K":
              Oe = De[ne].slice(1), Oe.charAt(0) === '"' ? (Oe = Oe.slice(1, Oe.length - 1), rt = "s") : Oe === "TRUE" || Oe === "FALSE" ? (Oe = Oe === "TRUE", rt = "b") : Oe.charAt(0) == "#" && RBErr[Oe] != null ? (rt = "e", Oe = RBErr[Oe]) : isNaN(fuzzynum(Oe)) || (Oe = fuzzynum(Oe), rt = "n", Te !== null && fmt_is_date(Te) && ee.cellDates && (Oe = numdate(ye.Workbook.WBProps.date1904 ? Oe + 1462 : Oe), rt = typeof Oe == "number" ? "n" : "d")), typeof $cptable < "u" && typeof Oe == "string" && (ee || {}).type != "string" && (ee || {}).codepage && (Oe = $cptable.utils.decode(ee.codepage, Oe)), Ae = !0;
              break;
            case "E":
              Re = !0, Je = rc_to_a1(De[ne].slice(1), { r: te, c: Q });
              break;
            case "S":
              Ue = !0;
              break;
            case "G":
              break;
            // unknown
            case "R":
              Me = parseInt(De[ne].slice(1), 10) - 1;
              break;
            case "C":
              je = parseInt(De[ne].slice(1), 10) - 1;
              break;
            // case 'P': // ??
            // case 'D': // ??
            default:
              if (ee && ee.WTF) throw new Error("SYLK bad record " + ze);
          }
          if (Ae && (le[te][Q] ? (le[te][Q].t = rt, le[te][Q].v = Oe) : le[te][Q] = { t: rt, v: Oe }, Te && (le[te][Q].z = Te), ee.cellText !== !1 && Te && (le[te][Q].w = SSF_format(le[te][Q].z, le[te][Q].v, { date1904: ye.Workbook.WBProps.date1904 })), Te = null), Ue) {
            if (Re) throw new Error("SYLK shared formula cannot have own formula");
            var Se = Me > -1 && le[Me][je];
            if (!Se || !Se[1]) throw new Error("SYLK shared formula cannot find base");
            Je = shift_formula_str(Se[1], { r: te - Me, c: Q - je });
          }
          Je && (le[te][Q] ? le[te][Q].f = Je : le[te][Q] = { t: "n", f: Je }), fe && (le[te][Q] || (le[te][Q] = { t: "z" }), le[te][Q].c = [{ a: "SheetJSYLK", t: fe }]);
          break;
        case "F":
          var we = 0;
          for (ne = 1; ne < De.length; ++ne) switch (De[ne].charAt(0)) {
            case "X":
              Q = parseInt(De[ne].slice(1), 10) - 1, ++we;
              break;
            case "Y":
              for (te = parseInt(De[ne].slice(1), 10) - 1, Ce = le.length; Ce <= te; ++Ce) le[Ce] = [];
              break;
            case "M":
              xe = parseInt(De[ne].slice(1), 10) / 20;
              break;
            case "F":
              break;
            /* ??? */
            case "G":
              break;
            /* hide grid */
            case "P":
              Te = Ee[parseInt(De[ne].slice(1), 10)];
              break;
            case "S":
              break;
            /* cell style */
            case "D":
              break;
            /* column */
            case "N":
              break;
            /* font */
            case "W":
              for (ce = De[ne].slice(1).split(" "), Ce = parseInt(ce[0], 10); Ce <= parseInt(ce[1], 10); ++Ce)
                xe = parseInt(ce[2], 10), se[Ce - 1] = xe === 0 ? { hidden: !0 } : { wch: xe };
              break;
            case "C":
              Q = parseInt(De[ne].slice(1), 10) - 1, se[Q] || (se[Q] = {});
              break;
            case "R":
              te = parseInt(De[ne].slice(1), 10) - 1, ae[te] || (ae[te] = {}), xe > 0 ? (ae[te].hpt = xe, ae[te].hpx = pt2px(xe)) : xe === 0 && (ae[te].hidden = !0);
              break;
            // case 'K': // ??
            // case 'E': // ??
            default:
              if (ee && ee.WTF) throw new Error("SYLK bad record " + ze);
          }
          we < 1 && (Te = null);
          break;
        default:
          if (ee && ee.WTF) throw new Error("SYLK bad record " + ze);
      }
    }
    return ae.length > 0 && (de["!rows"] = ae), se.length > 0 && (de["!cols"] = se), se.forEach(function(me) {
      process_col(me);
    }), ee && ee.sheetRows && (le = le.slice(0, ee.sheetRows)), [le, de, ye];
  }
  function X(J, ee) {
    var re = U(J, ee), te = re[0], Q = re[1], oe = re[2], ne = dup(ee);
    ne.date1904 = (((oe || {}).Workbook || {}).WBProps || {}).date1904;
    var le = aoa_to_sheet(te, ne);
    keys(Q).forEach(function(Te) {
      le[Te] = Q[Te];
    });
    var Ee = sheet_to_workbook(le, ee);
    return keys(oe).forEach(function(Te) {
      Ee[Te] = oe[Te];
    }), Ee.bookType = "sylk", Ee;
  }
  function G(J, ee, re, te, Q, oe) {
    var ne = "C;Y" + (re + 1) + ";X" + (te + 1) + ";K";
    switch (J.t) {
      case "n":
        ne += isFinite(J.v) ? J.v || 0 : BErr[isNaN(J.v) ? 36 : 7], J.f && !J.F && (ne += ";E" + a1_to_rc(J.f, { r: re, c: te }));
        break;
      case "b":
        ne += J.v ? "TRUE" : "FALSE";
        break;
      case "e":
        ne += J.w || BErr[J.v] || J.v;
        break;
      case "d":
        ne += datenum(parseDate(J.v, oe), oe);
        break;
      case "s":
        ne += '"' + (J.v == null ? "" : String(J.v)).replace(/"/g, "").replace(/;/g, ";;") + '"';
        break;
    }
    return ne;
  }
  function Y(J, ee, re) {
    var te = "C;Y" + (ee + 1) + ";X" + (re + 1) + ";A";
    return te += D(J.map(function(Q) {
      return Q.t;
    }).join("")), te;
  }
  function K(J, ee) {
    ee.forEach(function(re, te) {
      var Q = "F;W" + (te + 1) + " " + (te + 1) + " ";
      re.hidden ? Q += "0" : (typeof re.width == "number" && !re.wpx && (re.wpx = width2px(re.width)), typeof re.wpx == "number" && !re.wch && (re.wch = px2char(re.wpx)), typeof re.wch == "number" && (Q += Math.round(re.wch))), Q.charAt(Q.length - 1) != " " && J.push(Q);
    });
  }
  function Z(J, ee) {
    ee.forEach(function(re, te) {
      var Q = "F;";
      re.hidden ? Q += "M0;" : re.hpt ? Q += "M" + 20 * re.hpt + ";" : re.hpx && (Q += "M" + 20 * px2pt(re.hpx) + ";"), Q.length > 2 && J.push(Q + "R" + (te + 1));
    });
  }
  function q(J, ee, re) {
    ee || (ee = {}), ee._formats = ["General"];
    var te = ["ID;PSheetJS;N;E"], Q = [], oe = safe_decode_range(J["!ref"] || "A1"), ne, le = J["!data"] != null, Ee = `\r
`, Te = (((re || {}).Workbook || {}).WBProps || {}).date1904, de = "General";
    te.push("P;PGeneral");
    var ae = oe.s.r, se = oe.s.c, ce = [];
    if (J["!ref"]) {
      for (ae = oe.s.r; ae <= oe.e.r; ++ae)
        if (!(le && !J["!data"][ae])) {
          for (ce = [], se = oe.s.c; se <= oe.e.c; ++se)
            ne = le ? J["!data"][ae][se] : J[encode_col(se) + encode_row(ae)], !(!ne || !ne.c) && ce.push(Y(ne.c, ae, se));
          ce.length && Q.push(ce.join(Ee));
        }
    }
    if (J["!ref"]) {
      for (ae = oe.s.r; ae <= oe.e.r; ++ae)
        if (!(le && !J["!data"][ae])) {
          for (ce = [], se = oe.s.c; se <= oe.e.c; ++se)
            if (ne = le ? J["!data"][ae][se] : J[encode_col(se) + encode_row(ae)], !(!ne || ne.v == null && (!ne.f || ne.F))) {
              if ((ne.z || (ne.t == "d" ? table_fmt[14] : "General")) != de) {
                var xe = ee._formats.indexOf(ne.z);
                xe == -1 && (ee._formats.push(ne.z), xe = ee._formats.length - 1, te.push("P;P" + ne.z.replace(/;/g, ";;"))), ce.push("F;P" + xe + ";Y" + (ae + 1) + ";X" + (se + 1));
              }
              ce.push(G(ne, J, ae, se, ee, Te));
            }
          Q.push(ce.join(Ee));
        }
    }
    return te.push("F;P0;DG0G8;M255"), J["!cols"] && K(te, J["!cols"]), J["!rows"] && Z(te, J["!rows"]), J["!ref"] && te.push("B;Y" + (oe.e.r - oe.s.r + 1) + ";X" + (oe.e.c - oe.s.c + 1) + ";D" + [oe.s.c, oe.s.r, oe.e.c, oe.e.r].join(" ")), te.push("O;L;D;B" + (Te ? ";V4" : "") + ";K47;G100 0.001"), delete ee._formats, te.join(Ee) + Ee + Q.join(Ee) + Ee + "E" + Ee;
  }
  return {
    to_workbook: X,
    from_sheet: q
  };
}(), DIF = /* @__PURE__ */ function() {
  function F(X, G) {
    switch (G.type) {
      case "base64":
        return x(Base64_decode(X), G);
      case "binary":
        return x(X, G);
      case "buffer":
        return x(has_buf && Buffer.isBuffer(X) ? X.toString("binary") : a2s(X), G);
      case "array":
        return x(cc2str(X), G);
    }
    throw new Error("Unrecognized type " + G.type);
  }
  function x(X, G) {
    for (var Y = X.split(`
`), K = -1, Z = -1, q = 0, J = []; q !== Y.length; ++q) {
      if (Y[q].trim() === "BOT") {
        J[++K] = [], Z = 0;
        continue;
      }
      if (!(K < 0)) {
        var ee = Y[q].trim().split(","), re = ee[0], te = ee[1];
        ++q;
        for (var Q = Y[q] || ""; (Q.match(/["]/g) || []).length & 1 && q < Y.length - 1; ) Q += `
` + Y[++q];
        switch (Q = Q.trim(), +re) {
          case -1:
            if (Q === "BOT") {
              J[++K] = [], Z = 0;
              continue;
            } else if (Q !== "EOD") throw new Error("Unrecognized DIF special command " + Q);
            break;
          case 0:
            Q === "TRUE" ? J[K][Z] = !0 : Q === "FALSE" ? J[K][Z] = !1 : isNaN(fuzzynum(te)) ? isNaN(fuzzydate(te).getDate()) ? J[K][Z] = te : (J[K][Z] = parseDate(te), G && G.UTC || (J[K][Z] = utc_to_local(J[K][Z]))) : J[K][Z] = fuzzynum(te), ++Z;
            break;
          case 1:
            Q = Q.slice(1, Q.length - 1), Q = Q.replace(/""/g, '"'), Q && Q.match(/^=".*"$/) && (Q = Q.slice(2, -1)), J[K][Z++] = Q !== "" ? Q : null;
            break;
        }
        if (Q === "EOD") break;
      }
    }
    return G && G.sheetRows && (J = J.slice(0, G.sheetRows)), J;
  }
  function w(X, G) {
    return aoa_to_sheet(F(X, G), G);
  }
  function O(X, G) {
    var Y = sheet_to_workbook(w(X, G), G);
    return Y.bookType = "dif", Y;
  }
  function D(X, G) {
    return "0," + String(X) + `\r
` + G;
  }
  function U(X) {
    return `1,0\r
"` + X.replace(/"/g, '""') + '"';
  }
  function W(X) {
    if (!X["!ref"]) throw new Error("Cannot export empty sheet to DIF");
    for (var G = safe_decode_range(X["!ref"]), Y = X["!data"] != null, K = [
      `TABLE\r
0,1\r
"sheetjs"\r
`,
      `VECTORS\r
0,` + (G.e.r - G.s.r + 1) + `\r
""\r
`,
      `TUPLES\r
0,` + (G.e.c - G.s.c + 1) + `\r
""\r
`,
      `DATA\r
0,0\r
""\r
`
    ], Z = G.s.r; Z <= G.e.r; ++Z) {
      for (var q = Y ? X["!data"][Z] : [], J = `-1,0\r
BOT\r
`, ee = G.s.c; ee <= G.e.c; ++ee) {
        var re = Y ? q && q[ee] : X[encode_cell({ r: Z, c: ee })];
        if (re == null) {
          J += `1,0\r
""\r
`;
          continue;
        }
        switch (re.t) {
          case "n":
            re.w != null ? J += "0," + re.w + `\r
V` : re.v != null ? J += D(re.v, "V") : re.f != null && !re.F ? J += U("=" + re.f) : J += `1,0\r
""`;
            break;
          case "b":
            J += re.v ? D(1, "TRUE") : D(0, "FALSE");
            break;
          case "s":
            J += U(isNaN(+re.v) ? re.v : '="' + re.v + '"');
            break;
          case "d":
            re.w || (re.w = SSF_format(re.z || table_fmt[14], datenum(parseDate(re.v)))), J += D(re.w, "V");
            break;
          default:
            J += `1,0\r
""`;
        }
        J += `\r
`;
      }
      K.push(J);
    }
    return K.join("") + `-1,0\r
EOD`;
  }
  return {
    to_workbook: O,
    to_sheet: w,
    from_sheet: W
  };
}(), ETH = /* @__PURE__ */ function() {
  function F(Z) {
    return Z.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, `
`);
  }
  function x(Z) {
    return Z.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
  }
  function w(Z, q) {
    for (var J = Z.split(`
`), ee = -1, re = -1, te = 0, Q = []; te !== J.length; ++te) {
      var oe = J[te].trim().split(":");
      if (oe[0] === "cell") {
        var ne = decode_cell(oe[1]);
        if (Q.length <= ne.r) for (ee = Q.length; ee <= ne.r; ++ee) Q[ee] || (Q[ee] = []);
        switch (ee = ne.r, re = ne.c, oe[2]) {
          case "t":
            Q[ee][re] = F(oe[3]);
            break;
          case "v":
            Q[ee][re] = +oe[3];
            break;
          case "vtf":
            var le = oe[oe.length - 1];
          /* falls through */
          case "vtc":
            switch (oe[3]) {
              case "nl":
                Q[ee][re] = !!+oe[4];
                break;
              default:
                Q[ee][re] = oe[oe.length - 1].charAt(0) == "#" ? { t: "e", v: RBErr[oe[oe.length - 1]] } : +oe[4];
                break;
            }
            oe[2] == "vtf" && (Q[ee][re] = [Q[ee][re], le]);
        }
      }
    }
    return q && q.sheetRows && (Q = Q.slice(0, q.sheetRows)), Q;
  }
  function O(Z, q) {
    return aoa_to_sheet(w(Z, q), q);
  }
  function D(Z, q) {
    return sheet_to_workbook(O(Z, q), q);
  }
  var U = [
    "socialcalc:version:1.5",
    "MIME-Version: 1.0",
    "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
  ].join(`
`), W = [
    "--SocialCalcSpreadsheetControlSave",
    "Content-type: text/plain; charset=UTF-8"
  ].join(`
`) + `
`, X = [
    "# SocialCalc Spreadsheet Control Save",
    "part:sheet"
  ].join(`
`), G = "--SocialCalcSpreadsheetControlSave--";
  function Y(Z) {
    if (!Z || !Z["!ref"]) return "";
    for (var q = [], J = [], ee, re = "", te = decode_range(Z["!ref"]), Q = Z["!data"] != null, oe = te.s.r; oe <= te.e.r; ++oe)
      for (var ne = te.s.c; ne <= te.e.c; ++ne)
        if (re = encode_cell({ r: oe, c: ne }), ee = Q ? (Z["!data"][oe] || [])[ne] : Z[re], !(!ee || ee.v == null || ee.t === "z")) {
          switch (J = ["cell", re, "t"], ee.t) {
            case "s":
              J.push(x(ee.v));
              break;
            case "b":
              J[2] = "vt" + (ee.f ? "f" : "c"), J[3] = "nl", J[4] = ee.v ? "1" : "0", J[5] = x(ee.f || (ee.v ? "TRUE" : "FALSE"));
              break;
            case "d":
              var le = datenum(parseDate(ee.v));
              J[2] = "vtc", J[3] = "nd", J[4] = "" + le, J[5] = ee.w || SSF_format(ee.z || table_fmt[14], le);
              break;
            case "n":
              isFinite(ee.v) ? ee.f ? (J[2] = "vtf", J[3] = "n", J[4] = ee.v, J[5] = x(ee.f)) : (J[2] = "v", J[3] = ee.v) : (J[2] = "vt" + (ee.f ? "f" : "c"), J[3] = "e" + BErr[isNaN(ee.v) ? 36 : 7], J[4] = "0", J[5] = ee.f || J[3].slice(1), J[6] = "e", J[7] = J[3].slice(1));
              break;
            case "e":
              continue;
          }
          q.push(J.join(":"));
        }
    return q.push("sheet:c:" + (te.e.c - te.s.c + 1) + ":r:" + (te.e.r - te.s.r + 1) + ":tvf:1"), q.push("valueformat:1:text-wiki"), q.join(`
`);
  }
  function K(Z) {
    return [U, W, X, W, Y(Z), G].join(`
`);
  }
  return {
    to_workbook: D,
    to_sheet: O,
    from_sheet: K
  };
}(), PRN = /* @__PURE__ */ function() {
  function F(K, Z, q, J, ee) {
    ee.raw ? Z[q][J] = K : K === "" || (K === "TRUE" ? Z[q][J] = !0 : K === "FALSE" ? Z[q][J] = !1 : isNaN(fuzzynum(K)) ? isNaN(fuzzydate(K).getDate()) ? K.charCodeAt(0) == 35 && RBErr[K] != null ? Z[q][J] = { t: "e", v: RBErr[K], w: K } : Z[q][J] = K : Z[q][J] = parseDate(K) : Z[q][J] = fuzzynum(K));
  }
  function x(K, Z) {
    var q = Z || {}, J = [];
    if (!K || K.length === 0) return J;
    for (var ee = K.split(/[\r\n]/), re = ee.length - 1; re >= 0 && ee[re].length === 0; ) --re;
    for (var te = 10, Q = 0, oe = 0; oe <= re; ++oe)
      Q = ee[oe].indexOf(" "), Q == -1 ? Q = ee[oe].length : Q++, te = Math.max(te, Q);
    for (oe = 0; oe <= re; ++oe) {
      J[oe] = [];
      var ne = 0;
      for (F(ee[oe].slice(0, te).trim(), J, oe, ne, q), ne = 1; ne <= (ee[oe].length - te) / 10 + 1; ++ne)
        F(ee[oe].slice(te + (ne - 1) * 10, te + ne * 10).trim(), J, oe, ne, q);
    }
    return q.sheetRows && (J = J.slice(0, q.sheetRows)), J;
  }
  var w = {
    44: ",",
    9: "	",
    59: ";",
    124: "|"
  }, O = {
    44: 3,
    9: 2,
    59: 1,
    124: 0
  };
  function D(K) {
    for (var Z = {}, q = !1, J = 0, ee = 0; J < K.length; ++J)
      (ee = K.charCodeAt(J)) == 34 ? q = !q : !q && ee in w && (Z[ee] = (Z[ee] || 0) + 1);
    ee = [];
    for (J in Z) Object.prototype.hasOwnProperty.call(Z, J) && ee.push([Z[J], J]);
    if (!ee.length) {
      Z = O;
      for (J in Z) Object.prototype.hasOwnProperty.call(Z, J) && ee.push([Z[J], J]);
    }
    return ee.sort(function(re, te) {
      return re[0] - te[0] || O[re[1]] - O[te[1]];
    }), w[ee.pop()[1]] || 44;
  }
  function U(K, Z) {
    var q = Z || {}, J = "", ee = {};
    q.dense && (ee["!data"] = []);
    var re = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    K.slice(0, 4) == "sep=" ? K.charCodeAt(5) == 13 && K.charCodeAt(6) == 10 ? (J = K.charAt(4), K = K.slice(7)) : K.charCodeAt(5) == 13 || K.charCodeAt(5) == 10 ? (J = K.charAt(4), K = K.slice(6)) : J = D(K.slice(0, 1024)) : q.FS ? J = q.FS : J = D(K.slice(0, 1024));
    var te = 0, Q = 0, oe = 0, ne = 0, le = 0, Ee = J.charCodeAt(0), Te = !1, de = 0, ae = K.charCodeAt(0), se = q.dateNF != null ? dateNF_regex(q.dateNF) : null;
    function ce() {
      var xe = K.slice(ne, le);
      xe.slice(-1) == "\r" && (xe = xe.slice(0, -1));
      var Ce = {};
      if (xe.charAt(0) == '"' && xe.charAt(xe.length - 1) == '"' && (xe = xe.slice(1, -1).replace(/""/g, '"')), q.cellText !== !1 && (Ce.w = xe), xe.length === 0) Ce.t = "z";
      else if (q.raw)
        Ce.t = "s", Ce.v = xe;
      else if (xe.trim().length === 0)
        Ce.t = "s", Ce.v = xe;
      else if (xe.charCodeAt(0) == 61)
        xe.charCodeAt(1) == 34 && xe.charCodeAt(xe.length - 1) == 34 ? (Ce.t = "s", Ce.v = xe.slice(2, -1).replace(/""/g, '"')) : fuzzyfmla(xe) ? (Ce.t = "s", Ce.f = xe.slice(1), Ce.v = xe) : (Ce.t = "s", Ce.v = xe);
      else if (xe == "TRUE")
        Ce.t = "b", Ce.v = !0;
      else if (xe == "FALSE")
        Ce.t = "b", Ce.v = !1;
      else if (!isNaN(oe = fuzzynum(xe)))
        Ce.t = "n", Ce.v = oe;
      else if (!isNaN((oe = fuzzydate(xe)).getDate()) || se && xe.match(se)) {
        if (Ce.z = q.dateNF || table_fmt[14], se && xe.match(se)) {
          var ye = dateNF_fix(xe, q.dateNF, xe.match(se) || []);
          oe = parseDate(ye), q.UTC === !1 && (oe = utc_to_local(oe));
        } else q.UTC === !1 ? oe = utc_to_local(oe) : q.cellText !== !1 && q.dateNF && (Ce.w = SSF_format(Ce.z, oe));
        q.cellDates ? (Ce.t = "d", Ce.v = oe) : (Ce.t = "n", Ce.v = datenum(oe)), q.cellNF || delete Ce.z;
      } else xe.charCodeAt(0) == 35 && RBErr[xe] != null ? (Ce.t = "e", Ce.w = xe, Ce.v = RBErr[xe]) : (Ce.t = "s", Ce.v = xe);
      if (Ce.t == "z" || (q.dense ? (ee["!data"][te] || (ee["!data"][te] = []), ee["!data"][te][Q] = Ce) : ee[encode_cell({ c: Q, r: te })] = Ce), ne = le + 1, ae = K.charCodeAt(ne), re.e.c < Q && (re.e.c = Q), re.e.r < te && (re.e.r = te), de == Ee) ++Q;
      else if (Q = 0, ++te, q.sheetRows && q.sheetRows <= te) return !0;
    }
    e: for (; le < K.length; ++le) switch (de = K.charCodeAt(le)) {
      case 34:
        ae === 34 && (Te = !Te);
        break;
      case 13:
        if (Te) break;
        K.charCodeAt(le + 1) == 10 && ++le;
      /* falls through */
      case Ee:
      case 10:
        if (!Te && ce()) break e;
        break;
    }
    return le - ne > 0 && ce(), ee["!ref"] = encode_range(re), ee;
  }
  function W(K, Z) {
    return !(Z && Z.PRN) || Z.FS || K.slice(0, 4) == "sep=" || K.indexOf("	") >= 0 || K.indexOf(",") >= 0 || K.indexOf(";") >= 0 ? U(K, Z) : aoa_to_sheet(x(K, Z), Z);
  }
  function X(K, Z) {
    var q = "", J = Z.type == "string" ? [0, 0, 0, 0] : firstbyte(K, Z);
    switch (Z.type) {
      case "base64":
        q = Base64_decode(K);
        break;
      case "binary":
        q = K;
        break;
      case "buffer":
        Z.codepage == 65001 ? q = K.toString("utf8") : Z.codepage && typeof $cptable < "u" ? q = $cptable.utils.decode(Z.codepage, K) : q = has_buf && Buffer.isBuffer(K) ? K.toString("binary") : a2s(K);
        break;
      case "array":
        q = cc2str(K);
        break;
      case "string":
        q = K;
        break;
      default:
        throw new Error("Unrecognized type " + Z.type);
    }
    return J[0] == 239 && J[1] == 187 && J[2] == 191 ? q = utf8read(q.slice(3)) : Z.type != "string" && Z.type != "buffer" && Z.codepage == 65001 ? q = utf8read(q) : Z.type == "binary" && typeof $cptable < "u" && Z.codepage && (q = $cptable.utils.decode(Z.codepage, $cptable.utils.encode(28591, q))), q.slice(0, 19) == "socialcalc:version:" ? ETH.to_sheet(Z.type == "string" ? q : utf8read(q), Z) : W(q, Z);
  }
  function G(K, Z) {
    return sheet_to_workbook(X(K, Z), Z);
  }
  function Y(K) {
    var Z = [];
    if (!K["!ref"]) return "";
    for (var q = safe_decode_range(K["!ref"]), J, ee = K["!data"] != null, re = q.s.r; re <= q.e.r; ++re) {
      for (var te = [], Q = q.s.c; Q <= q.e.c; ++Q) {
        var oe = encode_cell({ r: re, c: Q });
        if (J = ee ? (K["!data"][re] || [])[Q] : K[oe], !J || J.v == null) {
          te.push("          ");
          continue;
        }
        for (var ne = (J.w || (format_cell(J), J.w) || "").slice(0, 10); ne.length < 10; ) ne += " ";
        te.push(ne + (Q === 0 ? " " : ""));
      }
      Z.push(te.join(""));
    }
    return Z.join(`
`);
  }
  return {
    to_workbook: G,
    to_sheet: X,
    from_sheet: Y
  };
}();
function read_wb_ID(F, x) {
  var w = x || {}, O = !!w.WTF;
  w.WTF = !0;
  try {
    var D = SYLK.to_workbook(F, w);
    return w.WTF = O, D;
  } catch (U) {
    if (w.WTF = O, U.message.indexOf("SYLK bad record ID") == -1 && O) throw U;
    return PRN.to_workbook(F, x);
  }
}
var WK_ = /* @__PURE__ */ function() {
  function F(fe, Se, we) {
    if (fe) {
      prep_blob(fe, fe.l || 0);
      for (var me = we.Enum || Re; fe.l < fe.length; ) {
        var ke = fe.read_shift(2), ue = me[ke] || me[65535], We = fe.read_shift(2), Ge = fe.l + We, Pe = ue.f && ue.f(fe, We, we);
        if (fe.l = Ge, Se(Pe, ue, ke)) return;
      }
    }
  }
  function x(fe, Se) {
    switch (Se.type) {
      case "base64":
        return O(s2a(Base64_decode(fe)), Se);
      case "binary":
        return O(s2a(fe), Se);
      case "buffer":
      case "array":
        return O(fe, Se);
    }
    throw "Unsupported type " + Se.type;
  }
  var w = [
    "mmmm",
    "dd-mmm-yyyy",
    "dd-mmm",
    "mmm-yyyy",
    "@",
    // "text"?
    "mm/dd",
    "hh:mm:ss AM/PM",
    // 7
    "hh:mm AM/PM",
    "mm/dd/yyyy",
    "mm/dd",
    "hh:mm:ss",
    "hh:mm"
    // 12
  ];
  function O(fe, Se) {
    if (!fe) return fe;
    var we = Se || {}, me = {}, ke = "Sheet1", ue = "", We = 0, Ge = {}, Pe = [], it = [], Ve = [];
    we.dense && (Ve = me["!data"] = []);
    var st = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, dt = we.sheetRows || 0, ut = {};
    if (fe[4] == 81 && fe[5] == 80 && fe[6] == 87) return rt(fe, Se);
    if (fe[2] == 0 && (fe[3] == 8 || fe[3] == 9) && fe.length >= 16 && fe[14] == 5 && fe[15] === 108)
      throw new Error("Unsupported Works 3 for Mac file");
    if (fe[2] == 2)
      we.Enum = Re, F(fe, function(Ke, _t, gt) {
        switch (gt) {
          case 0:
            we.vers = Ke, Ke >= 4096 && (we.qpro = !0);
            break;
          case 255:
            we.vers = Ke, we.works = !0;
            break;
          case 6:
            st = Ke;
            break;
          /* RANGE */
          case 204:
            Ke && (ue = Ke);
            break;
          /* SHEETNAMECS */
          case 222:
            ue = Ke;
            break;
          /* SHEETNAMELP */
          case 15:
          /* LABEL */
          case 51:
            (!we.qpro && !we.works || gt == 51) && Ke[1].v.charCodeAt(0) < 48 && (Ke[1].v = Ke[1].v.slice(1)), (we.works || we.works2) && (Ke[1].v = Ke[1].v.replace(/\r\n/g, `
`));
          /* falls through */
          case 13:
          /* INTEGER */
          case 14:
          /* NUMBER */
          case 16:
            (Ke[2] & 112) == 112 && (Ke[2] & 15) > 1 && (Ke[2] & 15) < 15 && (Ke[1].z = we.dateNF || w[(Ke[2] & 15) - 1] || table_fmt[14], we.cellDates && (Ke[1].v = numdate(Ke[1].v), Ke[1].t = typeof Ke[1].v == "number" ? "n" : "d")), we.qpro && Ke[3] > We && (me["!ref"] = encode_range(st), Ge[ke] = me, Pe.push(ke), me = {}, we.dense && (Ve = me["!data"] = []), st = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, We = Ke[3], ke = ue || "Sheet" + (We + 1), ue = "");
            var ht = we.dense ? (Ve[Ke[0].r] || [])[Ke[0].c] : me[encode_cell(Ke[0])];
            if (ht) {
              ht.t = Ke[1].t, ht.v = Ke[1].v, Ke[1].z != null && (ht.z = Ke[1].z), Ke[1].f != null && (ht.f = Ke[1].f), ut = ht;
              break;
            }
            we.dense ? (Ve[Ke[0].r] || (Ve[Ke[0].r] = []), Ve[Ke[0].r][Ke[0].c] = Ke[1]) : me[encode_cell(Ke[0])] = Ke[1], ut = Ke[1];
            break;
          case 21509:
            we.works2 = !0;
            break;
          case 21506:
            Ke == 5281 && (ut.z = "hh:mm:ss", we.cellDates && ut.t == "n" && (ut.v = numdate(ut.v), ut.t = typeof ut.v == "number" ? "n" : "d"));
            break;
        }
      }, we);
    else if (fe[2] == 26 || fe[2] == 14)
      we.Enum = Me, fe[2] == 14 && (we.qpro = !0, fe.l = 0), F(fe, function(Ke, _t, gt) {
        switch (gt) {
          case 204:
            ke = Ke;
            break;
          /* SHEETNAMECS */
          case 22:
            Ke[1].v.charCodeAt(0) < 48 && (Ke[1].v = Ke[1].v.slice(1)), Ke[1].v = Ke[1].v.replace(/\x0F./g, function(ht) {
              return String.fromCharCode(ht.charCodeAt(1) - 32);
            }).replace(/\r\n/g, `
`);
          /* falls through */
          case 23:
          /* NUMBER17 */
          case 24:
          /* NUMBER18 */
          case 25:
          /* FORMULA19 */
          case 37:
          /* NUMBER25 */
          case 39:
          /* NUMBER27 */
          case 40:
            if (Ke[3] > We && (me["!ref"] = encode_range(st), Ge[ke] = me, Pe.push(ke), me = {}, we.dense && (Ve = me["!data"] = []), st = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, We = Ke[3], ke = "Sheet" + (We + 1)), dt > 0 && Ke[0].r >= dt) break;
            we.dense ? (Ve[Ke[0].r] || (Ve[Ke[0].r] = []), Ve[Ke[0].r][Ke[0].c] = Ke[1]) : me[encode_cell(Ke[0])] = Ke[1], st.e.c < Ke[0].c && (st.e.c = Ke[0].c), st.e.r < Ke[0].r && (st.e.r = Ke[0].r);
            break;
          case 27:
            Ke[14e3] && (it[Ke[14e3][0]] = Ke[14e3][1]);
            break;
          case 1537:
            it[Ke[0]] = Ke[1], Ke[0] == We && (ke = Ke[1]);
            break;
        }
      }, we);
    else throw new Error("Unrecognized LOTUS BOF " + fe[2]);
    if (me["!ref"] = encode_range(st), Ge[ue || ke] = me, Pe.push(ue || ke), !it.length) return { SheetNames: Pe, Sheets: Ge };
    for (var mt = {}, at = [], lt = 0; lt < it.length; ++lt) Ge[Pe[lt]] ? (at.push(it[lt] || Pe[lt]), mt[it[lt]] = Ge[it[lt]] || Ge[Pe[lt]]) : (at.push(it[lt]), mt[it[lt]] = { "!ref": "A1" });
    return { SheetNames: at, Sheets: mt };
  }
  function D(fe, Se) {
    var we = Se || {};
    if (+we.codepage >= 0 && set_cp(+we.codepage), we.type == "string") throw new Error("Cannot write WK1 to JS string");
    var me = buf_array();
    if (!fe["!ref"]) throw new Error("Cannot export empty sheet to WK1");
    var ke = safe_decode_range(fe["!ref"]), ue = fe["!data"] != null, We = [];
    write_biff_rec(me, 0, W(1030)), write_biff_rec(me, 6, Y(ke));
    for (var Ge = Math.min(ke.e.r, 8191), Pe = ke.s.c; Pe <= ke.e.c; ++Pe) We[Pe] = encode_col(Pe);
    for (var it = ke.s.r; it <= Ge; ++it) {
      var Ve = encode_row(it);
      for (Pe = ke.s.c; Pe <= ke.e.c; ++Pe) {
        var st = ue ? (fe["!data"][it] || [])[Pe] : fe[We[Pe] + Ve];
        if (!(!st || st.t == "z"))
          switch (st.t) {
            case "n":
              (st.v | 0) == st.v && st.v >= -32768 && st.v <= 32767 ? write_biff_rec(me, 13, te(it, Pe, st)) : write_biff_rec(me, 14, oe(it, Pe, st));
              break;
            case "d":
              var dt = datenum(st.v);
              (dt | 0) == dt && dt >= -32768 && dt <= 32767 ? write_biff_rec(me, 13, te(it, Pe, { t: "n", v: dt, z: st.z || table_fmt[14] })) : write_biff_rec(me, 14, oe(it, Pe, { t: "n", v: dt, z: st.z || table_fmt[14] }));
              break;
            default:
              var ut = format_cell(st);
              write_biff_rec(me, 15, J(it, Pe, ut.slice(0, 239)));
          }
      }
    }
    return write_biff_rec(me, 1), me.end();
  }
  function U(fe, Se) {
    var we = Se || {};
    if (+we.codepage >= 0 && set_cp(+we.codepage), we.type == "string") throw new Error("Cannot write WK3 to JS string");
    var me = buf_array();
    write_biff_rec(me, 0, X(fe));
    for (var ke = 0, ue = 0; ke < fe.SheetNames.length; ++ke) (fe.Sheets[fe.SheetNames[ke]] || {})["!ref"] && write_biff_rec(me, 27, Ue(fe.SheetNames[ke], ue++));
    var We = 0;
    for (ke = 0; ke < fe.SheetNames.length; ++ke) {
      var Ge = fe.Sheets[fe.SheetNames[ke]];
      if (!(!Ge || !Ge["!ref"])) {
        for (var Pe = safe_decode_range(Ge["!ref"]), it = Ge["!data"] != null, Ve = [], st = Math.min(Pe.e.r, 8191), dt = Pe.s.r; dt <= st; ++dt)
          for (var ut = encode_row(dt), mt = Pe.s.c; mt <= Pe.e.c; ++mt) {
            dt === Pe.s.r && (Ve[mt] = encode_col(mt));
            var at = Ve[mt] + ut, lt = it ? (Ge["!data"][dt] || [])[mt] : Ge[at];
            if (!(!lt || lt.t == "z"))
              if (lt.t == "n")
                write_biff_rec(me, 23, ye(dt, mt, We, lt.v));
              else {
                var Ke = format_cell(lt);
                write_biff_rec(me, 22, ce(dt, mt, We, Ke.slice(0, 239)));
              }
          }
        ++We;
      }
    }
    return write_biff_rec(me, 1), me.end();
  }
  function W(fe) {
    var Se = new_buf(2);
    return Se.write_shift(2, fe), Se;
  }
  function X(fe) {
    var Se = new_buf(26);
    Se.write_shift(2, 4096), Se.write_shift(2, 4), Se.write_shift(4, 0);
    for (var we = 0, me = 0, ke = 0, ue = 0; ue < fe.SheetNames.length; ++ue) {
      var We = fe.SheetNames[ue], Ge = fe.Sheets[We];
      if (!(!Ge || !Ge["!ref"])) {
        ++ke;
        var Pe = decode_range(Ge["!ref"]);
        we < Pe.e.r && (we = Pe.e.r), me < Pe.e.c && (me = Pe.e.c);
      }
    }
    return we > 8191 && (we = 8191), Se.write_shift(2, we), Se.write_shift(1, ke), Se.write_shift(1, me), Se.write_shift(2, 0), Se.write_shift(2, 0), Se.write_shift(1, 1), Se.write_shift(1, 2), Se.write_shift(4, 0), Se.write_shift(4, 0), Se;
  }
  function G(fe, Se, we) {
    var me = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    return Se == 8 && we.qpro ? (me.s.c = fe.read_shift(1), fe.l++, me.s.r = fe.read_shift(2), me.e.c = fe.read_shift(1), fe.l++, me.e.r = fe.read_shift(2), me) : (me.s.c = fe.read_shift(2), me.s.r = fe.read_shift(2), Se == 12 && we.qpro && (fe.l += 2), me.e.c = fe.read_shift(2), me.e.r = fe.read_shift(2), Se == 12 && we.qpro && (fe.l += 2), me.s.c == 65535 && (me.s.c = me.e.c = me.s.r = me.e.r = 0), me);
  }
  function Y(fe) {
    var Se = new_buf(8);
    return Se.write_shift(2, fe.s.c), Se.write_shift(2, fe.s.r), Se.write_shift(2, fe.e.c), Se.write_shift(2, fe.e.r), Se;
  }
  function K(fe, Se, we) {
    var me = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
    return we.qpro && we.vers != 20768 ? (me[0].c = fe.read_shift(1), me[3] = fe.read_shift(1), me[0].r = fe.read_shift(2), fe.l += 2) : we.works ? (me[0].c = fe.read_shift(2), me[0].r = fe.read_shift(2), me[2] = fe.read_shift(2)) : (me[2] = fe.read_shift(1), me[0].c = fe.read_shift(2), me[0].r = fe.read_shift(2)), me;
  }
  function Z(fe) {
    return fe.z && fmt_is_date(fe.z) ? 240 | (w.indexOf(fe.z) + 1 || 2) : 255;
  }
  function q(fe, Se, we) {
    var me = fe.l + Se, ke = K(fe, Se, we);
    if (ke[1].t = "s", (we.vers & 65534) == 20768) {
      fe.l++;
      var ue = fe.read_shift(1);
      return ke[1].v = fe.read_shift(ue, "utf8"), ke;
    }
    return we.qpro && fe.l++, ke[1].v = fe.read_shift(me - fe.l, "cstr"), ke;
  }
  function J(fe, Se, we) {
    var me = new_buf(7 + we.length);
    me.write_shift(1, 255), me.write_shift(2, Se), me.write_shift(2, fe), me.write_shift(1, 39);
    for (var ke = 0; ke < me.length; ++ke) {
      var ue = we.charCodeAt(ke);
      me.write_shift(1, ue >= 128 ? 95 : ue);
    }
    return me.write_shift(1, 0), me;
  }
  function ee(fe, Se, we) {
    var me = fe.l + Se, ke = K(fe, Se, we);
    if (ke[1].t = "s", we.vers == 20768) {
      var ue = fe.read_shift(1);
      return ke[1].v = fe.read_shift(ue, "utf8"), ke;
    }
    return ke[1].v = fe.read_shift(me - fe.l, "cstr"), ke;
  }
  function re(fe, Se, we) {
    var me = K(fe, Se, we);
    return me[1].v = fe.read_shift(2, "i"), me;
  }
  function te(fe, Se, we) {
    var me = new_buf(7);
    return me.write_shift(1, Z(we)), me.write_shift(2, Se), me.write_shift(2, fe), me.write_shift(2, we.v, "i"), me;
  }
  function Q(fe, Se, we) {
    var me = K(fe, Se, we);
    return me[1].v = fe.read_shift(8, "f"), me;
  }
  function oe(fe, Se, we) {
    var me = new_buf(13);
    return me.write_shift(1, Z(we)), me.write_shift(2, Se), me.write_shift(2, fe), me.write_shift(8, we.v, "f"), me;
  }
  function ne(fe, Se, we) {
    var me = fe.l + Se, ke = K(fe, Se, we);
    if (ke[1].v = fe.read_shift(8, "f"), we.qpro) fe.l = me;
    else {
      var ue = fe.read_shift(2);
      de(fe.slice(fe.l, fe.l + ue), ke), fe.l += ue;
    }
    return ke;
  }
  function le(fe, Se, we) {
    var me = Se & 32768;
    return Se &= -32769, Se = (me ? fe : 0) + (Se >= 8192 ? Se - 16384 : Se), (me ? "" : "$") + (we ? encode_col(Se) : encode_row(Se));
  }
  var Ee = {
    31: ["NA", 0],
    // 0x20: ["ERR", 0],
    33: ["ABS", 1],
    34: ["TRUNC", 1],
    35: ["SQRT", 1],
    36: ["LOG", 1],
    37: ["LN", 1],
    38: ["PI", 0],
    39: ["SIN", 1],
    40: ["COS", 1],
    41: ["TAN", 1],
    42: ["ATAN2", 2],
    43: ["ATAN", 1],
    44: ["ASIN", 1],
    45: ["ACOS", 1],
    46: ["EXP", 1],
    47: ["MOD", 2],
    // 0x30
    49: ["ISNA", 1],
    50: ["ISERR", 1],
    51: ["FALSE", 0],
    52: ["TRUE", 0],
    53: ["RAND", 0],
    54: ["DATE", 3],
    // 0x37 NOW
    // 0x38 PMT
    // 0x39 PV
    // 0x3A FV
    // 0x3B IF
    // 0x3C DAY
    // 0x3D MONTH
    // 0x3E YEAR
    63: ["ROUND", 2],
    64: ["TIME", 3],
    // 0x41 HOUR
    // 0x42 MINUTE
    // 0x43 SECOND
    68: ["ISNUMBER", 1],
    69: ["ISTEXT", 1],
    70: ["LEN", 1],
    71: ["VALUE", 1],
    // 0x48: ["FIXED", ?? 1],
    73: ["MID", 3],
    74: ["CHAR", 1],
    // 0x4B
    // 0x4C FIND
    // 0x4D DATEVALUE
    // 0x4E TIMEVALUE
    // 0x4F CELL
    80: ["SUM", 69],
    81: ["AVERAGEA", 69],
    82: ["COUNTA", 69],
    83: ["MINA", 69],
    84: ["MAXA", 69],
    // 0x55 VLOOKUP
    // 0x56 NPV
    // 0x57 VAR
    // 0x58 STD
    // 0x59 IRR
    // 0x5A HLOOKUP
    // 0x5B DSUM
    // 0x5C DAVERAGE
    // 0x5D DCOUNTA
    // 0x5E DMIN
    // 0x5F DMAX
    // 0x60 DVARP
    // 0x61 DSTDEVP
    // 0x62 INDEX
    // 0x63 COLS
    // 0x64 ROWS
    // 0x65 REPEAT
    102: ["UPPER", 1],
    103: ["LOWER", 1],
    // 0x68 LEFT
    // 0x69 RIGHT
    // 0x6A REPLACE
    107: ["PROPER", 1],
    // 0x6C CELL
    109: ["TRIM", 1],
    // 0x6E CLEAN
    111: ["T", 1]
    // 0x70 V
  }, Te = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "",
    "+",
    "-",
    "*",
    "/",
    "^",
    "=",
    "<>",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "<=",
    ">=",
    "<",
    ">",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "&",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
    // eslint-disable-line no-mixed-spaces-and-tabs
  ];
  function de(fe, Se) {
    prep_blob(fe, 0);
    for (var we = [], me = 0, ke = "", ue = "", We = "", Ge = ""; fe.l < fe.length; ) {
      var Pe = fe[fe.l++];
      switch (Pe) {
        case 0:
          we.push(fe.read_shift(8, "f"));
          break;
        case 1:
          ue = le(Se[0].c, fe.read_shift(2), !0), ke = le(Se[0].r, fe.read_shift(2), !1), we.push(ue + ke);
          break;
        case 2:
          {
            var it = le(Se[0].c, fe.read_shift(2), !0), Ve = le(Se[0].r, fe.read_shift(2), !1);
            ue = le(Se[0].c, fe.read_shift(2), !0), ke = le(Se[0].r, fe.read_shift(2), !1), we.push(it + Ve + ":" + ue + ke);
          }
          break;
        case 3:
          if (fe.l < fe.length) {
            console.error("WK1 premature formula end");
            return;
          }
          break;
        case 4:
          we.push("(" + we.pop() + ")");
          break;
        case 5:
          we.push(fe.read_shift(2));
          break;
        case 6:
          {
            for (var st = ""; Pe = fe[fe.l++]; ) st += String.fromCharCode(Pe);
            we.push('"' + st.replace(/"/g, '""') + '"');
          }
          break;
        case 8:
          we.push("-" + we.pop());
          break;
        case 23:
          we.push("+" + we.pop());
          break;
        case 22:
          we.push("NOT(" + we.pop() + ")");
          break;
        case 20:
        case 21:
          Ge = we.pop(), We = we.pop(), we.push(["AND", "OR"][Pe - 20] + "(" + We + "," + Ge + ")");
          break;
        default:
          if (Pe < 32 && Te[Pe])
            Ge = we.pop(), We = we.pop(), we.push(We + Te[Pe] + Ge);
          else if (Ee[Pe]) {
            if (me = Ee[Pe][1], me == 69 && (me = fe[fe.l++]), me > we.length) {
              console.error("WK1 bad formula parse 0x" + Pe.toString(16) + ":|" + we.join("|") + "|");
              return;
            }
            var dt = we.slice(-me);
            we.length -= me, we.push(Ee[Pe][0] + "(" + dt.join(",") + ")");
          } else return Pe <= 7 ? console.error("WK1 invalid opcode " + Pe.toString(16)) : Pe <= 24 ? console.error("WK1 unsupported op " + Pe.toString(16)) : Pe <= 30 ? console.error("WK1 invalid opcode " + Pe.toString(16)) : Pe <= 115 ? console.error("WK1 unsupported function opcode " + Pe.toString(16)) : console.error("WK1 unrecognized opcode " + Pe.toString(16));
      }
    }
    we.length == 1 ? Se[1].f = "" + we[0] : console.error("WK1 bad formula parse |" + we.join("|") + "|");
  }
  function ae(fe) {
    var Se = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
    return Se[0].r = fe.read_shift(2), Se[3] = fe[fe.l++], Se[0].c = fe[fe.l++], Se;
  }
  function se(fe, Se) {
    var we = ae(fe);
    return we[1].t = "s", we[1].v = fe.read_shift(Se - 4, "cstr"), we;
  }
  function ce(fe, Se, we, me) {
    var ke = new_buf(6 + me.length);
    ke.write_shift(2, fe), ke.write_shift(1, we), ke.write_shift(1, Se), ke.write_shift(1, 39);
    for (var ue = 0; ue < me.length; ++ue) {
      var We = me.charCodeAt(ue);
      ke.write_shift(1, We >= 128 ? 95 : We);
    }
    return ke.write_shift(1, 0), ke;
  }
  function xe(fe, Se) {
    var we = ae(fe);
    we[1].v = fe.read_shift(2);
    var me = we[1].v >> 1;
    if (we[1].v & 1)
      switch (me & 7) {
        case 0:
          me = (me >> 3) * 5e3;
          break;
        case 1:
          me = (me >> 3) * 500;
          break;
        case 2:
          me = (me >> 3) / 20;
          break;
        case 3:
          me = (me >> 3) / 200;
          break;
        case 4:
          me = (me >> 3) / 2e3;
          break;
        case 5:
          me = (me >> 3) / 2e4;
          break;
        case 6:
          me = (me >> 3) / 16;
          break;
        case 7:
          me = (me >> 3) / 64;
          break;
      }
    return we[1].v = me, we;
  }
  function Ce(fe, Se) {
    var we = ae(fe), me = fe.read_shift(4), ke = fe.read_shift(4), ue = fe.read_shift(2);
    if (ue == 65535)
      return me === 0 && ke === 3221225472 ? (we[1].t = "e", we[1].v = 15) : me === 0 && ke === 3489660928 ? (we[1].t = "e", we[1].v = 42) : we[1].v = 0, we;
    var We = ue & 32768;
    return ue = (ue & 32767) - 16446, we[1].v = (1 - We * 2) * (ke * Math.pow(2, ue + 32) + me * Math.pow(2, ue)), we;
  }
  function ye(fe, Se, we, me) {
    var ke = new_buf(14);
    if (ke.write_shift(2, fe), ke.write_shift(1, we), ke.write_shift(1, Se), me == 0)
      return ke.write_shift(4, 0), ke.write_shift(4, 0), ke.write_shift(2, 65535), ke;
    var ue = 0, We = 0, Ge = 0, Pe = 0;
    return me < 0 && (ue = 1, me = -me), We = Math.log2(me) | 0, me /= Math.pow(2, We - 31), Pe = me >>> 0, (Pe & 2147483648) == 0 && (me /= 2, ++We, Pe = me >>> 0), me -= Pe, Pe |= 2147483648, Pe >>>= 0, me *= Math.pow(2, 32), Ge = me >>> 0, ke.write_shift(4, Ge), ke.write_shift(4, Pe), We += 16383 + (ue ? 32768 : 0), ke.write_shift(2, We), ke;
  }
  function ze(fe, Se) {
    var we = Ce(fe);
    return fe.l += Se - 14, we;
  }
  function De(fe, Se) {
    var we = ae(fe), me = fe.read_shift(4);
    return we[1].v = me >> 6, we;
  }
  function et(fe, Se) {
    var we = ae(fe), me = fe.read_shift(8, "f");
    return we[1].v = me, we;
  }
  function Oe(fe, Se) {
    var we = et(fe);
    return fe.l += Se - 12, we;
  }
  function Xe(fe, Se) {
    return fe[fe.l + Se - 1] == 0 ? fe.read_shift(Se, "cstr") : "";
  }
  function He(fe, Se) {
    var we = fe[fe.l++];
    we > Se - 1 && (we = Se - 1);
    for (var me = ""; me.length < we; ) me += String.fromCharCode(fe[fe.l++]);
    return me;
  }
  function Ae(fe, Se, we) {
    if (!(!we.qpro || Se < 21)) {
      var me = fe.read_shift(1);
      fe.l += 17, fe.l += 1, fe.l += 2;
      var ke = fe.read_shift(Se - 21, "cstr");
      return [me, ke];
    }
  }
  function qe(fe, Se) {
    for (var we = {}, me = fe.l + Se; fe.l < me; ) {
      var ke = fe.read_shift(2);
      if (ke == 14e3) {
        for (we[ke] = [0, ""], we[ke][0] = fe.read_shift(2); fe[fe.l]; )
          we[ke][1] += String.fromCharCode(fe[fe.l]), fe.l++;
        fe.l++;
      }
    }
    return we;
  }
  function Ue(fe, Se) {
    var we = new_buf(5 + fe.length);
    we.write_shift(2, 14e3), we.write_shift(2, Se);
    for (var me = 0; me < fe.length; ++me) {
      var ke = fe.charCodeAt(me);
      we[we.l++] = ke > 127 ? 95 : ke;
    }
    return we[we.l++] = 0, we;
  }
  var Re = {
    0: { n: "BOF", f: parseuint16 },
    1: { n: "EOF" },
    2: { n: "CALCMODE" },
    3: { n: "CALCORDER" },
    4: { n: "SPLIT" },
    5: { n: "SYNC" },
    6: { n: "RANGE", f: G },
    7: { n: "WINDOW1" },
    8: { n: "COLW1" },
    9: { n: "WINTWO" },
    10: { n: "COLW2" },
    11: { n: "NAME" },
    12: { n: "BLANK" },
    13: { n: "INTEGER", f: re },
    14: { n: "NUMBER", f: Q },
    15: { n: "LABEL", f: q },
    16: { n: "FORMULA", f: ne },
    24: { n: "TABLE" },
    25: { n: "ORANGE" },
    26: { n: "PRANGE" },
    27: { n: "SRANGE" },
    28: { n: "FRANGE" },
    29: { n: "KRANGE1" },
    32: { n: "HRANGE" },
    35: { n: "KRANGE2" },
    36: { n: "PROTEC" },
    37: { n: "FOOTER" },
    38: { n: "HEADER" },
    39: { n: "SETUP" },
    40: { n: "MARGINS" },
    41: { n: "LABELFMT" },
    42: { n: "TITLES" },
    43: { n: "SHEETJS" },
    45: { n: "GRAPH" },
    46: { n: "NGRAPH" },
    47: { n: "CALCCOUNT" },
    48: { n: "UNFORMATTED" },
    49: { n: "CURSORW12" },
    50: { n: "WINDOW" },
    51: { n: "STRING", f: ee },
    55: { n: "PASSWORD" },
    56: { n: "LOCKED" },
    60: { n: "QUERY" },
    61: { n: "QUERYNAME" },
    62: { n: "PRINT" },
    63: { n: "PRINTNAME" },
    64: { n: "GRAPH2" },
    65: { n: "GRAPHNAME" },
    66: { n: "ZOOM" },
    67: { n: "SYMSPLIT" },
    68: { n: "NSROWS" },
    69: { n: "NSCOLS" },
    70: { n: "RULER" },
    71: { n: "NNAME" },
    72: { n: "ACOMM" },
    73: { n: "AMACRO" },
    74: { n: "PARSE" },
    // 0x0064
    102: { n: "PRANGES??" },
    103: { n: "RRANGES??" },
    104: { n: "FNAME??" },
    105: { n: "MRANGES??" },
    // 0x0096
    // 0x0099
    // 0x009A
    // 0x009B
    // 0x009C
    // 0x00C0
    // 0x00C7
    // 0x00C9
    204: { n: "SHEETNAMECS", f: Xe },
    // 0x00CD
    222: { n: "SHEETNAMELP", f: He },
    255: { n: "BOF", f: parseuint16 },
    21506: { n: "WKSNF", f: parseuint16 },
    65535: { n: "" }
  }, Me = {
    0: { n: "BOF" },
    1: { n: "EOF" },
    2: { n: "PASSWORD" },
    3: { n: "CALCSET" },
    4: { n: "WINDOWSET" },
    5: { n: "SHEETCELLPTR" },
    6: { n: "SHEETLAYOUT" },
    7: { n: "COLUMNWIDTH" },
    8: { n: "HIDDENCOLUMN" },
    9: { n: "USERRANGE" },
    10: { n: "SYSTEMRANGE" },
    11: { n: "ZEROFORCE" },
    12: { n: "SORTKEYDIR" },
    13: { n: "FILESEAL" },
    14: { n: "DATAFILLNUMS" },
    15: { n: "PRINTMAIN" },
    16: { n: "PRINTSTRING" },
    17: { n: "GRAPHMAIN" },
    18: { n: "GRAPHSTRING" },
    19: { n: "??" },
    20: { n: "ERRCELL" },
    21: { n: "NACELL" },
    22: { n: "LABEL16", f: se },
    23: { n: "NUMBER17", f: Ce },
    24: { n: "NUMBER18", f: xe },
    25: { n: "FORMULA19", f: ze },
    26: { n: "FORMULA1A" },
    27: { n: "XFORMAT", f: qe },
    28: { n: "DTLABELMISC" },
    29: { n: "DTLABELCELL" },
    30: { n: "GRAPHWINDOW" },
    31: { n: "CPA" },
    32: { n: "LPLAUTO" },
    33: { n: "QUERY" },
    34: { n: "HIDDENSHEET" },
    35: { n: "??" },
    37: { n: "NUMBER25", f: De },
    38: { n: "??" },
    39: { n: "NUMBER27", f: et },
    40: { n: "FORMULA28", f: Oe },
    142: { n: "??" },
    147: { n: "??" },
    150: { n: "??" },
    151: { n: "??" },
    152: { n: "??" },
    153: { n: "??" },
    154: { n: "??" },
    155: { n: "??" },
    156: { n: "??" },
    163: { n: "??" },
    174: { n: "??" },
    175: { n: "??" },
    176: { n: "??" },
    177: { n: "??" },
    184: { n: "??" },
    185: { n: "??" },
    186: { n: "??" },
    187: { n: "??" },
    188: { n: "??" },
    195: { n: "??" },
    201: { n: "??" },
    204: { n: "SHEETNAMECS", f: Xe },
    205: { n: "??" },
    206: { n: "??" },
    207: { n: "??" },
    208: { n: "??" },
    256: { n: "??" },
    259: { n: "??" },
    260: { n: "??" },
    261: { n: "??" },
    262: { n: "??" },
    263: { n: "??" },
    265: { n: "??" },
    266: { n: "??" },
    267: { n: "??" },
    268: { n: "??" },
    270: { n: "??" },
    271: { n: "??" },
    384: { n: "??" },
    389: { n: "??" },
    390: { n: "??" },
    393: { n: "??" },
    396: { n: "??" },
    512: { n: "??" },
    514: { n: "??" },
    513: { n: "??" },
    516: { n: "??" },
    517: { n: "??" },
    640: { n: "??" },
    641: { n: "??" },
    642: { n: "??" },
    643: { n: "??" },
    644: { n: "??" },
    645: { n: "??" },
    646: { n: "??" },
    647: { n: "??" },
    648: { n: "??" },
    658: { n: "??" },
    659: { n: "??" },
    660: { n: "??" },
    661: { n: "??" },
    662: { n: "??" },
    665: { n: "??" },
    666: { n: "??" },
    768: { n: "??" },
    772: { n: "??" },
    1537: { n: "SHEETINFOQP", f: Ae },
    1600: { n: "??" },
    1602: { n: "??" },
    1793: { n: "??" },
    1794: { n: "??" },
    1795: { n: "??" },
    1796: { n: "??" },
    1920: { n: "??" },
    2048: { n: "??" },
    2049: { n: "??" },
    2052: { n: "??" },
    2688: { n: "??" },
    10998: { n: "??" },
    12849: { n: "??" },
    28233: { n: "??" },
    28484: { n: "??" },
    65535: { n: "" }
  }, je = {
    5: "dd-mmm-yy",
    6: "dd-mmm",
    7: "mmm-yy",
    8: "mm/dd/yy",
    // Long Date Intl
    10: "hh:mm:ss AM/PM",
    11: "hh:mm AM/PM",
    14: "dd-mmm-yyyy",
    15: "mmm-yyyy",
    /* It is suspected that the the low nybble specifies decimal places */
    34: "0.00",
    50: "0.00;[Red]0.00",
    66: "0.00;(0.00)",
    82: "0.00;[Red](0.00)",
    162: '"$"#,##0.00;\\("$"#,##0.00\\)',
    288: "0%",
    304: "0E+00",
    320: "# ?/?"
  };
  function Je(fe) {
    var Se = fe.read_shift(2), we = fe.read_shift(1);
    if (we != 0) throw "unsupported QPW string type " + we.toString(16);
    return fe.read_shift(Se, "sbcs-cont");
  }
  function rt(fe, Se) {
    prep_blob(fe, 0);
    var we = Se || {}, me = {};
    we.dense && (me["!data"] = []);
    var ke = [], ue = "", We = { s: { r: -1, c: -1 }, e: { r: -1, c: -1 } }, Ge = 0, Pe = 0, it = 0, Ve = 0, st = { SheetNames: [], Sheets: {} }, dt = [];
    e: for (; fe.l < fe.length; ) {
      var ut = fe.read_shift(2), mt = fe.read_shift(2), at = fe.slice(fe.l, fe.l + mt);
      switch (prep_blob(at, 0), ut) {
        case 1:
          if (at.read_shift(4) != 962023505) throw "Bad QPW9 BOF!";
          break;
        case 2:
          break e;
        case 8:
          break;
        // TODO: this is tied to custom number formats
        case 10:
          for (var lt = at.read_shift(4), Ke = (at.length - at.l) / lt | 0, _t = 0; _t < lt; ++_t) {
            var gt = at.l + Ke, ht = {};
            at.l += 2, ht.numFmtId = at.read_shift(2), je[ht.numFmtId] && (ht.z = je[ht.numFmtId]), at.l = gt, dt.push(ht);
          }
          break;
        /* TODO: The behavior here should be consistent with Numbers: QP Notebook ~ .TN.SheetArchive, QP Sheet ~ .TST.TableModelArchive */
        case 1025:
          break;
        case 1026:
          break;
        case 1031:
          for (at.l += 12; at.l < at.length; )
            Ge = at.read_shift(2), Pe = at.read_shift(1), ke.push(at.read_shift(Ge, "cstr"));
          break;
        case 1032:
          break;
        case 1537:
          {
            var Pt = at.read_shift(2);
            me = {}, we.dense && (me["!data"] = []), We.s.c = at.read_shift(2), We.e.c = at.read_shift(2), We.s.r = at.read_shift(4), We.e.r = at.read_shift(4), at.l += 4, at.l + 2 < at.length && (Ge = at.read_shift(2), Pe = at.read_shift(1), ue = Ge == 0 ? "" : at.read_shift(Ge, "cstr")), ue || (ue = encode_col(Pt));
          }
          break;
        case 1538:
          {
            if (We.s.c > 255 || We.s.r > 999999) break;
            We.e.c < We.s.c && (We.e.c = We.s.c), We.e.r < We.s.r && (We.e.r = We.s.r), me["!ref"] = encode_range(We), book_append_sheet(st, me, ue);
          }
          break;
        case 2561:
          it = at.read_shift(2), We.e.c < it && (We.e.c = it), We.s.c > it && (We.s.c = it), Ve = at.read_shift(4), We.s.r > Ve && (We.s.r = Ve), Ve = at.read_shift(4), We.e.r < Ve && (We.e.r = Ve);
          break;
        case 3073:
          {
            Ve = at.read_shift(4), Ge = at.read_shift(4), We.s.r > Ve && (We.s.r = Ve), We.e.r < Ve + Ge - 1 && (We.e.r = Ve + Ge - 1);
            for (var kt = encode_col(it); at.l < at.length; ) {
              var tt = { t: "z" }, ft = at.read_shift(1), St = -1;
              ft & 128 && (St = at.read_shift(2));
              var bt = ft & 64 ? at.read_shift(2) - 1 : 0;
              switch (ft & 31) {
                case 0:
                  break;
                case 1:
                  break;
                case 2:
                  tt = { t: "n", v: at.read_shift(2) };
                  break;
                case 3:
                  tt = { t: "n", v: at.read_shift(2, "i") };
                  break;
                case 4:
                  tt = { t: "n", v: parse_RkNumber(at) };
                  break;
                case 5:
                  tt = { t: "n", v: at.read_shift(8, "f") };
                  break;
                case 7:
                  tt = { t: "s", v: ke[Pe = at.read_shift(4) - 1] };
                  break;
                case 8:
                  tt = { t: "n", v: at.read_shift(8, "f") }, at.l += 2, at.l += 4, isNaN(tt.v) && (tt = { t: "e", v: 15 });
                  break;
                default:
                  throw "Unrecognized QPW cell type " + (ft & 31);
              }
              St != -1 && (dt[St - 1] || {}).z && (tt.z = dt[St - 1].z);
              var zt = 0;
              if (ft & 32) switch (ft & 31) {
                case 2:
                  zt = at.read_shift(2);
                  break;
                case 3:
                  zt = at.read_shift(2, "i");
                  break;
                case 7:
                  zt = at.read_shift(2);
                  break;
                default:
                  throw "Unsupported delta for QPW cell type " + (ft & 31);
              }
              if (!(!we.sheetStubs && tt.t == "z")) {
                var nr = dup(tt);
                tt.t == "n" && tt.z && fmt_is_date(tt.z) && we.cellDates && (nr.v = numdate(tt.v), nr.t = typeof nr.v == "number" ? "n" : "d"), me["!data"] != null ? (me["!data"][Ve] || (me["!data"][Ve] = []), me["!data"][Ve][it] = nr) : me[kt + encode_row(Ve)] = nr;
              }
              for (++Ve, --Ge; bt-- > 0 && Ge >= 0; ) {
                if (ft & 32) switch (ft & 31) {
                  case 2:
                    tt = { t: "n", v: tt.v + zt & 65535 };
                    break;
                  case 3:
                    tt = { t: "n", v: tt.v + zt & 65535 }, tt.v > 32767 && (tt.v -= 65536);
                    break;
                  case 7:
                    tt = { t: "s", v: ke[Pe = Pe + zt >>> 0] };
                    break;
                  default:
                    throw "Cannot apply delta for QPW cell type " + (ft & 31);
                }
                else switch (ft & 31) {
                  case 1:
                    tt = { t: "z" };
                    break;
                  case 2:
                    tt = { t: "n", v: at.read_shift(2) };
                    break;
                  case 7:
                    tt = { t: "s", v: ke[Pe = at.read_shift(4) - 1] };
                    break;
                  default:
                    throw "Cannot apply repeat for QPW cell type " + (ft & 31);
                }
                !we.sheetStubs && tt.t == "z" || (me["!data"] != null ? (me["!data"][Ve] || (me["!data"][Ve] = []), me["!data"][Ve][it] = tt) : me[kt + encode_row(Ve)] = tt), ++Ve, --Ge;
              }
            }
          }
          break;
        case 3074:
          {
            it = at.read_shift(2), Ve = at.read_shift(4);
            var Lr = Je(at);
            me["!data"] != null ? (me["!data"][Ve] || (me["!data"][Ve] = []), me["!data"][Ve][it] = { t: "s", v: Lr }) : me[encode_col(it) + encode_row(Ve)] = { t: "s", v: Lr };
          }
          break;
      }
      fe.l += mt;
    }
    return st;
  }
  return {
    sheet_to_wk1: D,
    book_to_wk3: U,
    to_workbook: x
  };
}();
function parse_rpr(F) {
  var x = {}, w = F.match(tagregex), O = 0, D = !1;
  if (w) for (; O != w.length; ++O) {
    var U = parsexmltag(w[O]);
    switch (U[0].replace(/<\w*:/g, "<")) {
      /* 18.8.12 condense CT_BooleanProperty */
      /* ** not required . */
      case "<condense":
        break;
      /* 18.8.17 extend CT_BooleanProperty */
      /* ** not required . */
      case "<extend":
        break;
      /* 18.8.36 shadow CT_BooleanProperty */
      /* ** not required . */
      case "<shadow":
        if (!U.val) break;
      /* falls through */
      case "<shadow>":
      case "<shadow/>":
        x.shadow = 1;
        break;
      case "</shadow>":
        break;
      /* 18.4.1 charset CT_IntProperty TODO */
      case "<charset":
        if (U.val == "1") break;
        x.cp = CS2CP[parseInt(U.val, 10)];
        break;
      /* 18.4.2 outline CT_BooleanProperty TODO */
      case "<outline":
        if (!U.val) break;
      /* falls through */
      case "<outline>":
      case "<outline/>":
        x.outline = 1;
        break;
      case "</outline>":
        break;
      /* 18.4.5 rFont CT_FontName */
      case "<rFont":
        x.name = U.val;
        break;
      /* 18.4.11 sz CT_FontSize */
      case "<sz":
        x.sz = U.val;
        break;
      /* 18.4.10 strike CT_BooleanProperty */
      case "<strike":
        if (!U.val) break;
      /* falls through */
      case "<strike>":
      case "<strike/>":
        x.strike = 1;
        break;
      case "</strike>":
        break;
      /* 18.4.13 u CT_UnderlineProperty */
      case "<u":
        if (!U.val) break;
        switch (U.val) {
          case "double":
            x.uval = "double";
            break;
          case "singleAccounting":
            x.uval = "single-accounting";
            break;
          case "doubleAccounting":
            x.uval = "double-accounting";
            break;
        }
      /* falls through */
      case "<u>":
      case "<u/>":
        x.u = 1;
        break;
      case "</u>":
        break;
      /* 18.8.2 b */
      case "<b":
        if (U.val == "0") break;
      /* falls through */
      case "<b>":
      case "<b/>":
        x.b = 1;
        break;
      case "</b>":
        break;
      /* 18.8.26 i */
      case "<i":
        if (U.val == "0") break;
      /* falls through */
      case "<i>":
      case "<i/>":
        x.i = 1;
        break;
      case "</i>":
        break;
      /* 18.3.1.15 color CT_Color TODO: tint, theme, auto, indexed */
      case "<color":
        U.rgb && (x.color = U.rgb.slice(2, 8));
        break;
      case "<color>":
      case "<color/>":
      case "</color>":
        break;
      /* 18.8.18 family ST_FontFamily */
      case "<family":
        x.family = U.val;
        break;
      case "<family>":
      case "<family/>":
      case "</family>":
        break;
      /* 18.4.14 vertAlign CT_VerticalAlignFontProperty TODO */
      case "<vertAlign":
        x.valign = U.val;
        break;
      case "<vertAlign>":
      case "<vertAlign/>":
      case "</vertAlign>":
        break;
      /* 18.8.35 scheme CT_FontScheme TODO */
      case "<scheme":
        break;
      case "<scheme>":
      case "<scheme/>":
      case "</scheme>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        D = !0;
        break;
      case "</ext>":
        D = !1;
        break;
      default:
        if (U[0].charCodeAt(1) !== 47 && !D) throw new Error("Unrecognized rich format " + U[0]);
    }
  }
  return x;
}
var parse_rs = /* @__PURE__ */ function() {
  function F(O) {
    var D = str_match_xml_ns(O, "t");
    if (!D) return { t: "s", v: "" };
    var U = { t: "s", v: unescapexml(D[1]) }, W = str_match_xml_ns(O, "rPr");
    return W && (U.s = parse_rpr(W[1])), U;
  }
  var x = /<(?:\w+:)?r>/g, w = /<\/(?:\w+:)?r>/;
  return function(D) {
    return D.replace(x, "").split(w).map(F).filter(function(U) {
      return U.v;
    });
  };
}(), rs_to_html = /* @__PURE__ */ function F() {
  var x = /(\r\n|\n)/g;
  function w(D, U, W) {
    var X = [];
    D.u && X.push("text-decoration: underline;"), D.uval && X.push("text-underline-style:" + D.uval + ";"), D.sz && X.push("font-size:" + D.sz + "pt;"), D.outline && X.push("text-effect: outline;"), D.shadow && X.push("text-shadow: auto;"), U.push('<span style="' + X.join("") + '">'), D.b && (U.push("<b>"), W.push("</b>")), D.i && (U.push("<i>"), W.push("</i>")), D.strike && (U.push("<s>"), W.push("</s>"));
    var G = D.valign || "";
    return G == "superscript" || G == "super" ? G = "sup" : G == "subscript" && (G = "sub"), G != "" && (U.push("<" + G + ">"), W.push("</" + G + ">")), W.push("</span>"), D;
  }
  function O(D) {
    var U = [[], D.v, []];
    return D.v ? (D.s && w(D.s, U[0], U[2]), U[0].join("") + U[1].replace(x, "<br/>") + U[2].join("")) : "";
  }
  return function(U) {
    return U.map(O).join("");
  };
}(), sitregex = /<(?:\w+:)?t\b[^<>]*>([^<]*)<\/(?:\w+:)?t>/g, sirregex = /<(?:\w+:)?r\b[^<>]*>/;
function parse_si(F, x) {
  var w = x ? x.cellHTML : !0, O = {};
  return F ? (F.match(/^\s*<(?:\w+:)?t[^>]*>/) ? (O.t = unescapexml(utf8read(F.slice(F.indexOf(">") + 1).split(/<\/(?:\w+:)?t>/)[0] || ""), !0), O.r = utf8read(F), w && (O.h = escapehtml(O.t))) : (
    /*y = */
    F.match(sirregex) && (O.r = utf8read(F), O.t = unescapexml(utf8read((str_remove_xml_ns_g(F, "rPh").match(sitregex) || []).join("").replace(tagregex, "")), !0), w && (O.h = rs_to_html(parse_rs(O.r))))
  ), O) : { t: "" };
}
var sstr1 = /<(?:\w+:)?(?:si|sstItem)>/g, sstr2 = /<\/(?:\w+:)?(?:si|sstItem)>/;
function parse_sst_xml(F, x) {
  var w = [], O = "";
  if (!F) return w;
  var D = str_match_xml_ns(F, "sst");
  if (D) {
    O = D[1].replace(sstr1, "").split(sstr2);
    for (var U = 0; U != O.length; ++U) {
      var W = parse_si(O[U].trim(), x);
      W != null && (w[w.length] = W);
    }
    D = parsexmltag(D[0].slice(0, D[0].indexOf(">"))), w.Count = D.count, w.Unique = D.uniqueCount;
  }
  return w;
}
var straywsregex = /^\s|\s$|[\t\n\r]/;
function write_sst_xml(F, x) {
  if (!x.bookSST) return "";
  var w = [XML_HEADER];
  w[w.length] = writextag("sst", null, {
    xmlns: XMLNS_main[0],
    count: F.Count,
    uniqueCount: F.Unique
  });
  for (var O = 0; O != F.length; ++O)
    if (F[O] != null) {
      var D = F[O], U = "<si>";
      D.r ? U += D.r : (U += "<t", D.t || (D.t = ""), typeof D.t != "string" && (D.t = String(D.t)), D.t.match(straywsregex) && (U += ' xml:space="preserve"'), U += ">" + escapexml(D.t) + "</t>"), U += "</si>", w[w.length] = U;
    }
  return w.length > 2 && (w[w.length] = "</sst>", w[1] = w[1].replace("/>", ">")), w.join("");
}
function parse_BrtBeginSst(F) {
  return [F.read_shift(4), F.read_shift(4)];
}
function parse_sst_bin(F, x) {
  var w = [], O = !1;
  return recordhopper(F, function(U, W, X) {
    switch (X) {
      case 159:
        w.Count = U[0], w.Unique = U[1];
        break;
      case 19:
        w.push(U);
        break;
      case 160:
        return !0;
      case 35:
        O = !0;
        break;
      case 36:
        O = !1;
        break;
      default:
        if (W.T, !O || x.WTF) throw new Error("Unexpected record 0x" + X.toString(16));
    }
  }), w;
}
function write_BrtBeginSst(F, x) {
  return x || (x = new_buf(8)), x.write_shift(4, F.Count), x.write_shift(4, F.Unique), x;
}
var write_BrtSSTItem = write_RichStr;
function write_sst_bin(F) {
  var x = buf_array();
  write_record(x, 159, write_BrtBeginSst(F));
  for (var w = 0; w < F.length; ++w) write_record(x, 19, write_BrtSSTItem(F[w]));
  return write_record(
    x,
    160
    /* BrtEndSst */
  ), x.end();
}
function _JS2ANSI(F) {
  if (typeof $cptable < "u") return $cptable.utils.encode(current_ansi, F);
  for (var x = [], w = F.split(""), O = 0; O < w.length; ++O) x[O] = w[O].charCodeAt(0);
  return x;
}
function parse_CRYPTOVersion(F, x) {
  var w = {};
  return w.Major = F.read_shift(2), w.Minor = F.read_shift(2), x >= 4 && (F.l += x - 4), w;
}
function parse_DataSpaceVersionInfo(F) {
  var x = {};
  return x.id = F.read_shift(0, "lpp4"), x.R = parse_CRYPTOVersion(F, 4), x.U = parse_CRYPTOVersion(F, 4), x.W = parse_CRYPTOVersion(F, 4), x;
}
function parse_DataSpaceMapEntry(F) {
  for (var x = F.read_shift(4), w = F.l + x - 4, O = {}, D = F.read_shift(4), U = []; D-- > 0; ) U.push({ t: F.read_shift(4), v: F.read_shift(0, "lpp4") });
  if (O.name = F.read_shift(0, "lpp4"), O.comps = U, F.l != w) throw new Error("Bad DataSpaceMapEntry: " + F.l + " != " + w);
  return O;
}
function parse_DataSpaceMap(F) {
  var x = [];
  F.l += 4;
  for (var w = F.read_shift(4); w-- > 0; ) x.push(parse_DataSpaceMapEntry(F));
  return x;
}
function parse_DataSpaceDefinition(F) {
  var x = [];
  F.l += 4;
  for (var w = F.read_shift(4); w-- > 0; ) x.push(F.read_shift(0, "lpp4"));
  return x;
}
function parse_TransformInfoHeader(F) {
  var x = {};
  return F.read_shift(4), F.l += 4, x.id = F.read_shift(0, "lpp4"), x.name = F.read_shift(0, "lpp4"), x.R = parse_CRYPTOVersion(F, 4), x.U = parse_CRYPTOVersion(F, 4), x.W = parse_CRYPTOVersion(F, 4), x;
}
function parse_Primary(F) {
  var x = parse_TransformInfoHeader(F);
  if (x.ename = F.read_shift(0, "8lpp4"), x.blksz = F.read_shift(4), x.cmode = F.read_shift(4), F.read_shift(4) != 4) throw new Error("Bad !Primary record");
  return x;
}
function parse_EncryptionHeader(F, x) {
  var w = F.l + x, O = {};
  O.Flags = F.read_shift(4) & 63, F.l += 4, O.AlgID = F.read_shift(4);
  var D = !1;
  switch (O.AlgID) {
    case 26126:
    case 26127:
    case 26128:
      D = O.Flags == 36;
      break;
    case 26625:
      D = O.Flags == 4;
      break;
    case 0:
      D = O.Flags == 16 || O.Flags == 4 || O.Flags == 36;
      break;
    default:
      throw "Unrecognized encryption algorithm: " + O.AlgID;
  }
  if (!D) throw new Error("Encryption Flags/AlgID mismatch");
  return O.AlgIDHash = F.read_shift(4), O.KeySize = F.read_shift(4), O.ProviderType = F.read_shift(4), F.l += 8, O.CSPName = F.read_shift(w - F.l >> 1, "utf16le"), F.l = w, O;
}
function parse_EncryptionVerifier(F, x) {
  var w = {}, O = F.l + x;
  return F.l += 4, w.Salt = F.slice(F.l, F.l + 16), F.l += 16, w.Verifier = F.slice(F.l, F.l + 16), F.l += 16, F.read_shift(4), w.VerifierHash = F.slice(F.l, O), F.l = O, w;
}
function parse_EncryptionInfo(F) {
  var x = parse_CRYPTOVersion(F);
  switch (x.Minor) {
    case 2:
      return [x.Minor, parse_EncInfoStd(F)];
    case 3:
      return [x.Minor, parse_EncInfoExt()];
    case 4:
      return [x.Minor, parse_EncInfoAgl(F)];
  }
  throw new Error("ECMA-376 Encrypted file unrecognized Version: " + x.Minor);
}
function parse_EncInfoStd(F) {
  var x = F.read_shift(4);
  if ((x & 63) != 36) throw new Error("EncryptionInfo mismatch");
  var w = F.read_shift(4), O = parse_EncryptionHeader(F, w), D = parse_EncryptionVerifier(F, F.length - F.l);
  return { t: "Std", h: O, v: D };
}
function parse_EncInfoExt() {
  throw new Error("File is password-protected: ECMA-376 Extensible");
}
function parse_EncInfoAgl(F) {
  var x = ["saltSize", "blockSize", "keyBits", "hashSize", "cipherAlgorithm", "cipherChaining", "hashAlgorithm", "saltValue"];
  F.l += 4;
  var w = F.read_shift(F.length - F.l, "utf8"), O = {};
  return w.replace(tagregex, function(U) {
    var W = parsexmltag(U);
    switch (strip_ns(W[0])) {
      case "<?xml":
        break;
      case "<encryption":
      case "</encryption>":
        break;
      case "<keyData":
        x.forEach(function(X) {
          O[X] = W[X];
        });
        break;
      case "<dataIntegrity":
        O.encryptedHmacKey = W.encryptedHmacKey, O.encryptedHmacValue = W.encryptedHmacValue;
        break;
      case "<keyEncryptors>":
      case "<keyEncryptors":
        O.encs = [];
        break;
      case "</keyEncryptors>":
        break;
      case "<keyEncryptor":
        O.uri = W.uri;
        break;
      case "</keyEncryptor>":
        break;
      case "<encryptedKey":
        O.encs.push(W);
        break;
      default:
        throw W[0];
    }
  }), O;
}
function parse_RC4CryptoHeader(F, x) {
  var w = {}, O = w.EncryptionVersionInfo = parse_CRYPTOVersion(F, 4);
  if (x -= 4, O.Minor != 2) throw new Error("unrecognized minor version code: " + O.Minor);
  if (O.Major > 4 || O.Major < 2) throw new Error("unrecognized major version code: " + O.Major);
  w.Flags = F.read_shift(4), x -= 4;
  var D = F.read_shift(4);
  return x -= 4, w.EncryptionHeader = parse_EncryptionHeader(F, D), x -= D, w.EncryptionVerifier = parse_EncryptionVerifier(F, x), w;
}
function parse_RC4Header(F) {
  var x = {}, w = x.EncryptionVersionInfo = parse_CRYPTOVersion(F, 4);
  if (w.Major != 1 || w.Minor != 1) throw "unrecognized version code " + w.Major + " : " + w.Minor;
  return x.Salt = F.read_shift(16), x.EncryptedVerifier = F.read_shift(16), x.EncryptedVerifierHash = F.read_shift(16), x;
}
function crypto_CreatePasswordVerifier_Method1(F) {
  var x = 0, w, O = _JS2ANSI(F), D = O.length + 1, U, W, X, G, Y;
  for (w = new_raw_buf(D), w[0] = O.length, U = 1; U != D; ++U) w[U] = O[U - 1];
  for (U = D - 1; U >= 0; --U)
    W = w[U], X = (x & 16384) === 0 ? 0 : 1, G = x << 1 & 32767, Y = X | G, x = Y ^ W;
  return x ^ 52811;
}
var crypto_CreateXorArray_Method1 = /* @__PURE__ */ function() {
  var F = [187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0], x = [57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163], w = [44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628], O = function(W) {
    return (W / 2 | W * 128) & 255;
  }, D = function(W, X) {
    return O(W ^ X);
  }, U = function(W) {
    for (var X = x[W.length - 1], G = 104, Y = W.length - 1; Y >= 0; --Y)
      for (var K = W[Y], Z = 0; Z != 7; ++Z)
        K & 64 && (X ^= w[G]), K *= 2, --G;
    return X;
  };
  return function(W) {
    for (var X = _JS2ANSI(W), G = U(X), Y = X.length, K = new_raw_buf(16), Z = 0; Z != 16; ++Z) K[Z] = 0;
    var q, J, ee;
    for ((Y & 1) === 1 && (q = G >> 8, K[Y] = D(F[0], q), --Y, q = G & 255, J = X[X.length - 1], K[Y] = D(J, q)); Y > 0; )
      --Y, q = G >> 8, K[Y] = D(X[Y], q), --Y, q = G & 255, K[Y] = D(X[Y], q);
    for (Y = 15, ee = 15 - X.length; ee > 0; )
      q = G >> 8, K[Y] = D(F[ee], q), --Y, --ee, q = G & 255, K[Y] = D(X[Y], q), --Y, --ee;
    return K;
  };
}(), crypto_DecryptData_Method1 = function(F, x, w, O, D) {
  D || (D = x), O || (O = crypto_CreateXorArray_Method1(F));
  var U, W;
  for (U = 0; U != x.length; ++U)
    W = x[U], W ^= O[w], W = (W >> 5 | W << 3) & 255, D[U] = W, ++w;
  return [D, w, O];
}, crypto_MakeXorDecryptor = function(F) {
  var x = 0, w = crypto_CreateXorArray_Method1(F);
  return function(O) {
    var D = crypto_DecryptData_Method1("", O, x, w);
    return x = D[1], D[0];
  };
};
function parse_XORObfuscation(F, x, w, O) {
  var D = { key: parseuint16(F), verificationBytes: parseuint16(F) };
  return w.password && (D.verifier = crypto_CreatePasswordVerifier_Method1(w.password)), O.valid = D.verificationBytes === D.verifier, O.valid && (O.insitu = crypto_MakeXorDecryptor(w.password)), D;
}
function parse_FilePassHeader(F, x, w) {
  var O = w;
  return O.Info = F.read_shift(2), F.l -= 2, O.Info === 1 ? O.Data = parse_RC4Header(F) : O.Data = parse_RC4CryptoHeader(F, x), O;
}
function parse_FilePass(F, x, w) {
  var O = { Type: w.biff >= 8 ? F.read_shift(2) : 0 };
  return O.Type ? parse_FilePassHeader(F, x - 2, O) : parse_XORObfuscation(F, w.biff >= 8 ? x : x - 2, w, O), O;
}
function rtf_to_sheet(F, x) {
  switch (x.type) {
    case "base64":
      return rtf_to_sheet_str(Base64_decode(F), x);
    case "binary":
      return rtf_to_sheet_str(F, x);
    case "buffer":
      return rtf_to_sheet_str(has_buf && Buffer.isBuffer(F) ? F.toString("binary") : a2s(F), x);
    case "array":
      return rtf_to_sheet_str(cc2str(F), x);
  }
  throw new Error("Unrecognized type " + x.type);
}
function rtf_to_sheet_str(F, x) {
  var w = x || {}, O = {}, D = w.dense;
  D && (O["!data"] = []);
  var U = str_match_ng(F, "\\trowd", "\\row");
  if (!U)
    throw new Error("RTF missing table");
  var W = { s: { c: 0, r: 0 }, e: { c: 0, r: U.length - 1 } }, X = [];
  return U.forEach(function(G, Y) {
    D && (X = O["!data"][Y] = []);
    for (var K = /\\[\w\-]+\b/g, Z = 0, q, J = -1, ee = []; (q = K.exec(G)) != null; ) {
      var re = G.slice(Z, K.lastIndex - q[0].length);
      switch (re.charCodeAt(0) == 32 && (re = re.slice(1)), re.length && ee.push(re), q[0]) {
        case "\\cell":
          if (++J, ee.length) {
            var te = { v: ee.join(""), t: "s" };
            te.v == "TRUE" || te.v == "FALSE" ? (te.v = te.v == "TRUE", te.t = "b") : isNaN(fuzzynum(te.v)) ? RBErr[te.v] != null && (te.t = "e", te.w = te.v, te.v = RBErr[te.v]) : (te.t = "n", w.cellText !== !1 && (te.w = te.v), te.v = fuzzynum(te.v)), D ? X[J] = te : O[encode_cell({ r: Y, c: J })] = te;
          }
          ee = [];
          break;
        case "\\par":
          ee.push(`
`);
          break;
      }
      Z = K.lastIndex;
    }
    J > W.e.c && (W.e.c = J);
  }), O["!ref"] = encode_range(W), O;
}
function rtf_to_workbook(F, x) {
  var w = sheet_to_workbook(rtf_to_sheet(F, x), x);
  return w.bookType = "rtf", w;
}
function sheet_to_rtf(F, x) {
  var w = ["{\\rtf1\\ansi"];
  if (!F["!ref"])
    return w[0] + "}";
  for (var O = safe_decode_range(F["!ref"]), D, U = F["!data"] != null, W = [], X = O.s.r; X <= O.e.r; ++X) {
    w.push("\\trowd\\trautofit1");
    for (var G = O.s.c; G <= O.e.c; ++G)
      w.push("\\cellx" + (G + 1));
    for (w.push("\\pard\\intbl"), U && (W = F["!data"][X] || []), G = O.s.c; G <= O.e.c; ++G) {
      var Y = encode_cell({ r: X, c: G });
      if (D = U ? W[G] : F[Y], !D || D.v == null && (!D.f || D.F)) {
        w.push(" \\cell");
        continue;
      }
      w.push(" " + (D.w || (format_cell(D), D.w) || "").replace(/[\r\n]/g, "\\par ")), w.push("\\cell");
    }
    w.push("\\pard\\intbl\\row");
  }
  return w.join("") + "}";
}
function hex2RGB(F) {
  var x = F.slice(F[0] === "#" ? 1 : 0).slice(0, 6);
  return [parseInt(x.slice(0, 2), 16), parseInt(x.slice(2, 4), 16), parseInt(x.slice(4, 6), 16)];
}
function rgb2Hex(F) {
  for (var x = 0, w = 1; x != 3; ++x) w = w * 256 + (F[x] > 255 ? 255 : F[x] < 0 ? 0 : F[x]);
  return w.toString(16).toUpperCase().slice(1);
}
function rgb2HSL(F) {
  var x = F[0] / 255, w = F[1] / 255, O = F[2] / 255, D = Math.max(x, w, O), U = Math.min(x, w, O), W = D - U;
  if (W === 0) return [0, 0, x];
  var X = 0, G = 0, Y = D + U;
  switch (G = W / (Y > 1 ? 2 - Y : Y), D) {
    case x:
      X = ((w - O) / W + 6) % 6;
      break;
    case w:
      X = (O - x) / W + 2;
      break;
    case O:
      X = (x - w) / W + 4;
      break;
  }
  return [X / 6, G, Y / 2];
}
function hsl2RGB(F) {
  var x = F[0], w = F[1], O = F[2], D = w * 2 * (O < 0.5 ? O : 1 - O), U = O - D / 2, W = [U, U, U], X = 6 * x, G;
  if (w !== 0) switch (X | 0) {
    case 0:
    case 6:
      G = D * X, W[0] += D, W[1] += G;
      break;
    case 1:
      G = D * (2 - X), W[0] += G, W[1] += D;
      break;
    case 2:
      G = D * (X - 2), W[1] += D, W[2] += G;
      break;
    case 3:
      G = D * (4 - X), W[1] += G, W[2] += D;
      break;
    case 4:
      G = D * (X - 4), W[2] += D, W[0] += G;
      break;
    case 5:
      G = D * (6 - X), W[2] += G, W[0] += D;
      break;
  }
  for (var Y = 0; Y != 3; ++Y) W[Y] = Math.round(W[Y] * 255);
  return W;
}
function rgb_tint(F, x) {
  if (x === 0) return F;
  var w = rgb2HSL(hex2RGB(F));
  return x < 0 ? w[2] = w[2] * (1 + x) : w[2] = 1 - (1 - w[2]) * (1 - x), rgb2Hex(hsl2RGB(w));
}
var DEF_MDW = 6, MAX_MDW = 15, MIN_MDW = 1, MDW = DEF_MDW;
function width2px(F) {
  return Math.floor((F + Math.round(128 / MDW) / 256) * MDW);
}
function px2char(F) {
  return Math.floor((F - 5) / MDW * 100 + 0.5) / 100;
}
function char2width(F) {
  return Math.round((F * MDW + 5) / MDW * 256) / 256;
}
function cycle_width(F) {
  return char2width(px2char(width2px(F)));
}
function find_mdw_colw(F) {
  var x = Math.abs(F - cycle_width(F)), w = MDW;
  if (x > 5e-3) for (MDW = MIN_MDW; MDW < MAX_MDW; ++MDW) Math.abs(F - cycle_width(F)) <= x && (x = Math.abs(F - cycle_width(F)), w = MDW);
  MDW = w;
}
function process_col(F) {
  F.width ? (F.wpx = width2px(F.width), F.wch = px2char(F.wpx), F.MDW = MDW) : F.wpx ? (F.wch = px2char(F.wpx), F.width = char2width(F.wch), F.MDW = MDW) : typeof F.wch == "number" && (F.width = char2width(F.wch), F.wpx = width2px(F.width), F.MDW = MDW), F.customWidth && delete F.customWidth;
}
var DEF_PPI = 96, PPI = DEF_PPI;
function px2pt(F) {
  return F * 96 / PPI;
}
function pt2px(F) {
  return F * PPI / 96;
}
var XLMLPatternTypeMap = {
  None: "none",
  Solid: "solid",
  Gray50: "mediumGray",
  Gray75: "darkGray",
  Gray25: "lightGray",
  HorzStripe: "darkHorizontal",
  VertStripe: "darkVertical",
  ReverseDiagStripe: "darkDown",
  DiagStripe: "darkUp",
  DiagCross: "darkGrid",
  ThickDiagCross: "darkTrellis",
  ThinHorzStripe: "lightHorizontal",
  ThinVertStripe: "lightVertical",
  ThinReverseDiagStripe: "lightDown",
  ThinHorzCross: "lightGrid"
};
function parse_borders(F, x, w, O) {
  x.Borders = [];
  var D = {}, U = !1;
  (F.match(tagregex) || []).forEach(function(W) {
    var X = parsexmltag(W);
    switch (strip_ns(X[0])) {
      case "<borders":
      case "<borders>":
      case "</borders>":
        break;
      /* 18.8.4 border CT_Border */
      case "<border":
      case "<border>":
      case "<border/>":
        D = /*::(*/
        {}, X.diagonalUp && (D.diagonalUp = parsexmlbool(X.diagonalUp)), X.diagonalDown && (D.diagonalDown = parsexmlbool(X.diagonalDown)), x.Borders.push(D);
        break;
      case "</border>":
        break;
      /* note: not in spec, appears to be CT_BorderPr */
      case "<left/>":
        break;
      case "<left":
      case "<left>":
        break;
      case "</left>":
        break;
      /* note: not in spec, appears to be CT_BorderPr */
      case "<right/>":
        break;
      case "<right":
      case "<right>":
        break;
      case "</right>":
        break;
      /* 18.8.43 top CT_BorderPr */
      case "<top/>":
        break;
      case "<top":
      case "<top>":
        break;
      case "</top>":
        break;
      /* 18.8.6 bottom CT_BorderPr */
      case "<bottom/>":
        break;
      case "<bottom":
      case "<bottom>":
        break;
      case "</bottom>":
        break;
      /* 18.8.13 diagonal CT_BorderPr */
      case "<diagonal":
      case "<diagonal>":
      case "<diagonal/>":
        break;
      case "</diagonal>":
        break;
      /* 18.8.25 horizontal CT_BorderPr */
      case "<horizontal":
      case "<horizontal>":
      case "<horizontal/>":
        break;
      case "</horizontal>":
        break;
      /* 18.8.44 vertical CT_BorderPr */
      case "<vertical":
      case "<vertical>":
      case "<vertical/>":
        break;
      case "</vertical>":
        break;
      /* 18.8.37 start CT_BorderPr */
      case "<start":
      case "<start>":
      case "<start/>":
        break;
      case "</start>":
        break;
      /* 18.8.16 end CT_BorderPr */
      case "<end":
      case "<end>":
      case "<end/>":
        break;
      case "</end>":
        break;
      /* 18.8.? color CT_Color */
      case "<color":
      case "<color>":
        break;
      case "<color/>":
      case "</color>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        U = !0;
        break;
      case "</ext>":
        U = !1;
        break;
      default:
        if (O && O.WTF && !U)
          throw new Error("unrecognized " + X[0] + " in borders");
    }
  });
}
function parse_fills(F, x, w, O) {
  x.Fills = [];
  var D = {}, U = !1;
  (F.match(tagregex) || []).forEach(function(W) {
    var X = parsexmltag(W);
    switch (strip_ns(X[0])) {
      case "<fills":
      case "<fills>":
      case "</fills>":
        break;
      /* 18.8.20 fill CT_Fill */
      case "<fill>":
      case "<fill":
      case "<fill/>":
        D = {}, x.Fills.push(D);
        break;
      case "</fill>":
        break;
      /* 18.8.24 gradientFill CT_GradientFill */
      case "<gradientFill>":
        break;
      case "<gradientFill":
      case "</gradientFill>":
        x.Fills.push(D), D = {};
        break;
      /* 18.8.32 patternFill CT_PatternFill */
      case "<patternFill":
      case "<patternFill>":
        X.patternType && (D.patternType = X.patternType);
        break;
      case "<patternFill/>":
      case "</patternFill>":
        break;
      /* 18.8.3 bgColor CT_Color */
      case "<bgColor":
        D.bgColor || (D.bgColor = {}), X.indexed && (D.bgColor.indexed = parseInt(X.indexed, 10)), X.theme && (D.bgColor.theme = parseInt(X.theme, 10)), X.tint && (D.bgColor.tint = parseFloat(X.tint)), X.rgb && (D.bgColor.rgb = X.rgb.slice(-6));
        break;
      case "<bgColor/>":
      case "</bgColor>":
        break;
      /* 18.8.19 fgColor CT_Color */
      case "<fgColor":
        D.fgColor || (D.fgColor = {}), X.theme && (D.fgColor.theme = parseInt(X.theme, 10)), X.tint && (D.fgColor.tint = parseFloat(X.tint)), X.rgb != null && (D.fgColor.rgb = X.rgb.slice(-6));
        break;
      case "<fgColor/>":
      case "</fgColor>":
        break;
      /* 18.8.38 stop CT_GradientStop */
      case "<stop":
      case "<stop/>":
        break;
      case "</stop>":
        break;
      /* 18.8.? color CT_Color */
      case "<color":
      case "<color/>":
        break;
      case "</color>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        U = !0;
        break;
      case "</ext>":
        U = !1;
        break;
      default:
        if (O && O.WTF && !U)
          throw new Error("unrecognized " + X[0] + " in fills");
    }
  });
}
function parse_fonts(F, x, w, O) {
  x.Fonts = [];
  var D = {}, U = !1;
  (F.match(tagregex) || []).forEach(function(W) {
    var X = parsexmltag(W);
    switch (strip_ns(X[0])) {
      case "<fonts":
      case "<fonts>":
      case "</fonts>":
        break;
      /* 18.8.22 font CT_Font */
      case "<font":
      case "<font>":
        break;
      case "</font>":
      case "<font/>":
        x.Fonts.push(D), D = {};
        break;
      /* 18.8.29 name CT_FontName */
      case "<name":
        X.val && (D.name = utf8read(X.val));
        break;
      case "<name/>":
      case "</name>":
        break;
      /* 18.8.2  b CT_BooleanProperty */
      case "<b":
        D.bold = X.val ? parsexmlbool(X.val) : 1;
        break;
      case "<b/>":
        D.bold = 1;
        break;
      case "</b>":
      case "</b":
        break;
      /* 18.8.26 i CT_BooleanProperty */
      case "<i":
        D.italic = X.val ? parsexmlbool(X.val) : 1;
        break;
      case "<i/>":
        D.italic = 1;
        break;
      case "</i>":
      case "</i":
        break;
      /* 18.4.13 u CT_UnderlineProperty */
      case "<u":
        switch (X.val) {
          case "none":
            D.underline = 0;
            break;
          case "single":
            D.underline = 1;
            break;
          case "double":
            D.underline = 2;
            break;
          case "singleAccounting":
            D.underline = 33;
            break;
          case "doubleAccounting":
            D.underline = 34;
            break;
        }
        break;
      case "<u/>":
        D.underline = 1;
        break;
      case "</u>":
      case "</u":
        break;
      /* 18.4.10 strike CT_BooleanProperty */
      case "<strike":
        D.strike = X.val ? parsexmlbool(X.val) : 1;
        break;
      case "<strike/>":
        D.strike = 1;
        break;
      case "</strike>":
      case "</strike":
        break;
      /* 18.4.2  outline CT_BooleanProperty */
      case "<outline":
        D.outline = X.val ? parsexmlbool(X.val) : 1;
        break;
      case "<outline/>":
        D.outline = 1;
        break;
      case "</outline>":
      case "</outline":
        break;
      /* 18.8.36 shadow CT_BooleanProperty */
      case "<shadow":
        D.shadow = X.val ? parsexmlbool(X.val) : 1;
        break;
      case "<shadow/>":
        D.shadow = 1;
        break;
      case "</shadow>":
      case "</shadow":
        break;
      /* 18.8.12 condense CT_BooleanProperty */
      case "<condense":
        D.condense = X.val ? parsexmlbool(X.val) : 1;
        break;
      case "<condense/>":
        D.condense = 1;
        break;
      case "</condense>":
      case "</condense":
        break;
      /* 18.8.17 extend CT_BooleanProperty */
      case "<extend":
        D.extend = X.val ? parsexmlbool(X.val) : 1;
        break;
      case "<extend/>":
        D.extend = 1;
        break;
      case "</extend>":
      case "</extend":
        break;
      /* 18.4.11 sz CT_FontSize */
      case "<sz":
        X.val && (D.sz = +X.val);
        break;
      case "<sz/>":
      case "</sz>":
      case "</sz":
        break;
      /* 18.4.14 vertAlign CT_VerticalAlignFontProperty */
      case "<vertAlign":
        X.val && (D.vertAlign = X.val);
        break;
      case "<vertAlign/>":
      case "</vertAlign>":
      case "</vertAlign":
        break;
      /* 18.8.18 family CT_FontFamily */
      case "<family":
        X.val && (D.family = parseInt(X.val, 10));
        break;
      case "<family/>":
      case "</family>":
      case "</family":
        break;
      /* 18.8.35 scheme CT_FontScheme */
      case "<scheme":
        X.val && (D.scheme = X.val);
        break;
      case "<scheme/>":
      case "</scheme>":
      case "</scheme":
        break;
      /* 18.4.1 charset CT_IntProperty */
      case "<charset":
        if (X.val == "1") break;
        X.codepage = CS2CP[parseInt(X.val, 10)];
        break;
      case "<charset/>":
      case "</charset>":
      case "</charset":
        break;
      /* 18.?.? color CT_Color */
      case "<color":
        if (D.color || (D.color = {}), X.auto && (D.color.auto = parsexmlbool(X.auto)), X.rgb) D.color.rgb = X.rgb.slice(-6);
        else if (X.indexed) {
          D.color.index = parseInt(X.indexed, 10);
          var G = XLSIcv[D.color.index];
          D.color.index == 81 && (G = XLSIcv[1]), G || (G = XLSIcv[1]), D.color.rgb = G[0].toString(16) + G[1].toString(16) + G[2].toString(16);
        } else X.theme && (D.color.theme = parseInt(X.theme, 10), X.tint && (D.color.tint = parseFloat(X.tint)), X.theme && w.themeElements && w.themeElements.clrScheme && (D.color.rgb = rgb_tint(w.themeElements.clrScheme[D.color.theme].rgb, D.color.tint || 0)));
        break;
      case "<color/>":
      case "</color>":
      case "</color":
        break;
      /* note: sometimes mc:AlternateContent appears bare */
      case "<AlternateContent":
        U = !0;
        break;
      case "</AlternateContent>":
      case "</AlternateContent":
        U = !1;
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        U = !0;
        break;
      case "</ext>":
        U = !1;
        break;
      default:
        if (O && O.WTF && !U)
          throw new Error("unrecognized " + X[0] + " in fonts");
    }
  });
}
function parse_numFmts(F, x, w) {
  x.NumberFmt = [];
  for (var O = keys(table_fmt), D = 0; D < O.length; ++D) x.NumberFmt[O[D]] = table_fmt[O[D]];
  var U = F.match(tagregex);
  if (U)
    for (D = 0; D < U.length; ++D) {
      var W = parsexmltag(U[D]);
      switch (strip_ns(W[0])) {
        case "<numFmts":
        case "</numFmts>":
        case "<numFmts/>":
        case "<numFmts>":
          break;
        case "<numFmt":
          {
            var X = unescapexml(utf8read(W.formatCode)), G = parseInt(W.numFmtId, 10);
            if (x.NumberFmt[G] = X, G > 0) {
              if (G > 392) {
                for (G = 392; G > 60 && x.NumberFmt[G] != null; --G) ;
                x.NumberFmt[G] = X;
              }
              SSF__load(X, G);
            }
          }
          break;
        case "</numFmt>":
          break;
        default:
          if (w.WTF) throw new Error("unrecognized " + W[0] + " in numFmts");
      }
    }
}
function write_numFmts(F) {
  var x = ["<numFmts>"];
  return [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(w) {
    for (var O = w[0]; O <= w[1]; ++O) F[O] != null && (x[x.length] = writextag("numFmt", null, { numFmtId: O, formatCode: escapexml(F[O]) }));
  }), x.length === 1 ? "" : (x[x.length] = "</numFmts>", x[0] = writextag("numFmts", null, { count: x.length - 2 }).replace("/>", ">"), x.join(""));
}
var cellXF_uint = ["numFmtId", "fillId", "fontId", "borderId", "xfId"], cellXF_bool = ["applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix"];
function parse_cellXfs(F, x, w) {
  x.CellXf = [];
  var O, D = !1;
  (F.match(tagregex) || []).forEach(function(U) {
    var W = parsexmltag(U), X = 0;
    switch (strip_ns(W[0])) {
      case "<cellXfs":
      case "<cellXfs>":
      case "<cellXfs/>":
      case "</cellXfs>":
        break;
      /* 18.8.45 xf CT_Xf */
      case "<xf":
      case "<xf/>":
      case "<xf>":
        for (O = W, delete O[0], X = 0; X < cellXF_uint.length; ++X) O[cellXF_uint[X]] && (O[cellXF_uint[X]] = parseInt(O[cellXF_uint[X]], 10));
        for (X = 0; X < cellXF_bool.length; ++X) O[cellXF_bool[X]] && (O[cellXF_bool[X]] = parsexmlbool(O[cellXF_bool[X]]));
        if (x.NumberFmt && O.numFmtId > 392) {
          for (X = 392; X > 60; --X) if (x.NumberFmt[O.numFmtId] == x.NumberFmt[X]) {
            O.numFmtId = X;
            break;
          }
        }
        x.CellXf.push(O);
        break;
      case "</xf>":
        break;
      /* 18.8.1 alignment CT_CellAlignment */
      case "<alignment":
      case "<alignment/>":
      case "<alignment>":
        var G = {};
        W.vertical && (G.vertical = W.vertical), W.horizontal && (G.horizontal = W.horizontal), W.textRotation != null && (G.textRotation = W.textRotation), W.indent && (G.indent = W.indent), W.wrapText && (G.wrapText = parsexmlbool(W.wrapText)), O.alignment = G;
        break;
      case "</alignment>":
        break;
      /* 18.8.33 protection CT_CellProtection */
      case "<protection":
      case "<protection>":
        break;
      case "</protection>":
      case "<protection/>":
        break;
      /* note: sometimes mc:AlternateContent appears bare */
      case "<AlternateContent":
      case "<AlternateContent>":
        D = !0;
        break;
      case "</AlternateContent>":
        D = !1;
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        D = !0;
        break;
      case "</ext>":
        D = !1;
        break;
      default:
        if (w && w.WTF && !D)
          throw new Error("unrecognized " + W[0] + " in cellXfs");
    }
  });
}
function write_cellXfs(F) {
  var x = [];
  return x[x.length] = writextag("cellXfs", null), F.forEach(function(w) {
    x[x.length] = writextag("xf", null, w);
  }), x[x.length] = "</cellXfs>", x.length === 2 ? "" : (x[0] = writextag("cellXfs", null, { count: x.length - 2 }).replace("/>", ">"), x.join(""));
}
var parse_sty_xml = /* @__PURE__ */ function F() {
  return function(w, O, D) {
    var U = {};
    if (!w) return U;
    w = remove_doctype(str_remove_ng(w, "<!--", "-->"));
    var W;
    return (W = str_match_xml_ns(w, "numFmts")) && parse_numFmts(W[0], U, D), (W = str_match_xml_ns(w, "fonts")) && parse_fonts(W[0], U, O, D), (W = str_match_xml_ns(w, "fills")) && parse_fills(W[0], U, O, D), (W = str_match_xml_ns(w, "borders")) && parse_borders(W[0], U, O, D), (W = str_match_xml_ns(w, "cellXfs")) && parse_cellXfs(W[0], U, D), U;
  };
}();
function write_sty_xml(F, x) {
  var w = [XML_HEADER, writextag("styleSheet", null, {
    xmlns: XMLNS_main[0],
    "xmlns:vt": XMLNS.vt
  })], O;
  return F.SSF && (O = write_numFmts(F.SSF)) != null && (w[w.length] = O), w[w.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>', w[w.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>', w[w.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>', w[w.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>', (O = write_cellXfs(x.cellXfs)) && (w[w.length] = O), w[w.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>', w[w.length] = '<dxfs count="0"/>', w[w.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>', w.length > 2 && (w[w.length] = "</styleSheet>", w[1] = w[1].replace("/>", ">")), w.join("");
}
function parse_BrtFmt(F, x) {
  var w = F.read_shift(2), O = parse_XLWideString(F);
  return [w, O];
}
function write_BrtFmt(F, x, w) {
  w || (w = new_buf(6 + 4 * x.length)), w.write_shift(2, F), write_XLWideString(x, w);
  var O = w.length > w.l ? w.slice(0, w.l) : w;
  return w.l == null && (w.l = w.length), O;
}
function parse_BrtFont(F, x, w) {
  var O = {};
  O.sz = F.read_shift(2) / 20;
  var D = parse_FontFlags(F);
  D.fItalic && (O.italic = 1), D.fCondense && (O.condense = 1), D.fExtend && (O.extend = 1), D.fShadow && (O.shadow = 1), D.fOutline && (O.outline = 1), D.fStrikeout && (O.strike = 1);
  var U = F.read_shift(2);
  switch (U === 700 && (O.bold = 1), F.read_shift(2)) {
    /* case 0: out.vertAlign = "baseline"; break; */
    case 1:
      O.vertAlign = "superscript";
      break;
    case 2:
      O.vertAlign = "subscript";
      break;
  }
  var W = F.read_shift(1);
  W != 0 && (O.underline = W);
  var X = F.read_shift(1);
  X > 0 && (O.family = X);
  var G = F.read_shift(1);
  switch (G > 0 && (O.charset = G), F.l++, O.color = parse_BrtColor(F), F.read_shift(1)) {
    /* case 0: out.scheme = "none": break; */
    case 1:
      O.scheme = "major";
      break;
    case 2:
      O.scheme = "minor";
      break;
  }
  return O.name = parse_XLWideString(F), O;
}
function write_BrtFont(F, x) {
  x || (x = new_buf(153)), x.write_shift(2, F.sz * 20), write_FontFlags(F, x), x.write_shift(2, F.bold ? 700 : 400);
  var w = 0;
  F.vertAlign == "superscript" ? w = 1 : F.vertAlign == "subscript" && (w = 2), x.write_shift(2, w), x.write_shift(1, F.underline || 0), x.write_shift(1, F.family || 0), x.write_shift(1, F.charset || 0), x.write_shift(1, 0), write_BrtColor(F.color, x);
  var O = 0;
  return F.scheme == "major" && (O = 1), F.scheme == "minor" && (O = 2), x.write_shift(1, O), write_XLWideString(F.name, x), x.length > x.l ? x.slice(0, x.l) : x;
}
var XLSBFillPTNames = [
  "none",
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
], rev_XLSBFillPTNames, parse_BrtFill = parsenoop;
function write_BrtFill(F, x) {
  x || (x = new_buf(84)), rev_XLSBFillPTNames || (rev_XLSBFillPTNames = evert(XLSBFillPTNames));
  var w = rev_XLSBFillPTNames[F.patternType];
  w == null && (w = 40), x.write_shift(4, w);
  var O = 0;
  if (w != 40)
    for (write_BrtColor({ auto: 1 }, x), write_BrtColor({ auto: 1 }, x); O < 12; ++O) x.write_shift(4, 0);
  else {
    for (; O < 4; ++O) x.write_shift(4, 0);
    for (; O < 12; ++O) x.write_shift(4, 0);
  }
  return x.length > x.l ? x.slice(0, x.l) : x;
}
function parse_BrtXF(F, x) {
  var w = F.l + x, O = F.read_shift(2), D = F.read_shift(2);
  return F.l = w, { ixfe: O, numFmtId: D };
}
function write_BrtXF(F, x, w) {
  w || (w = new_buf(16)), w.write_shift(2, x || 0), w.write_shift(2, F.numFmtId || 0), w.write_shift(2, 0), w.write_shift(2, 0), w.write_shift(2, 0), w.write_shift(1, 0), w.write_shift(1, 0);
  var O = 0;
  return w.write_shift(1, O), w.write_shift(1, 0), w.write_shift(1, 0), w.write_shift(1, 0), w;
}
function write_Blxf(F, x) {
  return x || (x = new_buf(10)), x.write_shift(1, 0), x.write_shift(1, 0), x.write_shift(4, 0), x.write_shift(4, 0), x;
}
var parse_BrtBorder = parsenoop;
function write_BrtBorder(F, x) {
  return x || (x = new_buf(51)), x.write_shift(1, 0), write_Blxf(null, x), write_Blxf(null, x), write_Blxf(null, x), write_Blxf(null, x), write_Blxf(null, x), x.length > x.l ? x.slice(0, x.l) : x;
}
function write_BrtStyle(F, x) {
  return x || (x = new_buf(52)), x.write_shift(4, F.xfId), x.write_shift(2, 1), x.write_shift(1, +F.builtinId), x.write_shift(1, 0), write_XLNullableWideString(F.name || "", x), x.length > x.l ? x.slice(0, x.l) : x;
}
function write_BrtBeginTableStyles(F, x, w) {
  var O = new_buf(2052);
  return O.write_shift(4, F), write_XLNullableWideString(x, O), write_XLNullableWideString(w, O), O.length > O.l ? O.slice(0, O.l) : O;
}
function parse_sty_bin(F, x, w) {
  var O = {};
  O.NumberFmt = [];
  for (var D in table_fmt) O.NumberFmt[D] = table_fmt[D];
  O.CellXf = [], O.Fonts = [];
  var U = [], W = !1;
  return recordhopper(F, function(G, Y, K) {
    switch (K) {
      case 44:
        O.NumberFmt[G[0]] = G[1], SSF__load(G[1], G[0]);
        break;
      case 43:
        O.Fonts.push(G), G.color.theme != null && x && x.themeElements && x.themeElements.clrScheme && (G.color.rgb = rgb_tint(x.themeElements.clrScheme[G.color.theme].rgb, G.color.tint || 0));
        break;
      case 1025:
        break;
      case 45:
        break;
      case 46:
        break;
      case 47:
        U[U.length - 1] == 617 && O.CellXf.push(G);
        break;
      case 48:
      /* BrtStyle */
      case 507:
      /* BrtDXF */
      case 572:
      /* BrtMRUColor */
      case 475:
        break;
      case 1171:
      /* BrtDXF14 */
      case 2102:
      /* BrtDXF15 */
      case 1130:
      /* BrtSlicerStyleElement */
      case 512:
      /* BrtTableStyleElement */
      case 2095:
      /* BrtTimelineStyleElement */
      case 3072:
        break;
      case 35:
        W = !0;
        break;
      case 36:
        W = !1;
        break;
      case 37:
        U.push(K), W = !0;
        break;
      case 38:
        U.pop(), W = !1;
        break;
      default:
        if (Y.T > 0) U.push(K);
        else if (Y.T < 0) U.pop();
        else if (!W || w.WTF && U[U.length - 1] != 37) throw new Error("Unexpected record 0x" + K.toString(16));
    }
  }), O;
}
function write_FMTS_bin(F, x) {
  if (x) {
    var w = 0;
    [[5, 8], [23, 26], [41, 44], [
      /*63*/
      50,
      /*66],[164,*/
      392
    ]].forEach(function(O) {
      for (var D = O[0]; D <= O[1]; ++D) x[D] != null && ++w;
    }), w != 0 && (write_record(F, 615, write_UInt32LE(w)), [[5, 8], [23, 26], [41, 44], [
      /*63*/
      50,
      /*66],[164,*/
      392
    ]].forEach(function(O) {
      for (var D = O[0]; D <= O[1]; ++D) x[D] != null && write_record(F, 44, write_BrtFmt(D, x[D]));
    }), write_record(
      F,
      616
      /* BrtEndFmts */
    ));
  }
}
function write_FONTS_bin(F) {
  var x = 1;
  write_record(F, 611, write_UInt32LE(x)), write_record(F, 43, write_BrtFont({
    sz: 12,
    color: { theme: 1 },
    name: "Calibri",
    family: 2,
    scheme: "minor"
  })), write_record(
    F,
    612
    /* BrtEndFonts */
  );
}
function write_FILLS_bin(F) {
  var x = 2;
  write_record(F, 603, write_UInt32LE(x)), write_record(F, 45, write_BrtFill({ patternType: "none" })), write_record(F, 45, write_BrtFill({ patternType: "gray125" })), write_record(
    F,
    604
    /* BrtEndFills */
  );
}
function write_BORDERS_bin(F) {
  var x = 1;
  write_record(F, 613, write_UInt32LE(x)), write_record(F, 46, write_BrtBorder()), write_record(
    F,
    614
    /* BrtEndBorders */
  );
}
function write_CELLSTYLEXFS_bin(F) {
  var x = 1;
  write_record(F, 626, write_UInt32LE(x)), write_record(F, 47, write_BrtXF({
    numFmtId: 0,
    fontId: 0,
    fillId: 0,
    borderId: 0
  }, 65535)), write_record(
    F,
    627
    /* BrtEndCellStyleXFs */
  );
}
function write_CELLXFS_bin(F, x) {
  write_record(F, 617, write_UInt32LE(x.length)), x.forEach(function(w) {
    write_record(F, 47, write_BrtXF(w, 0));
  }), write_record(
    F,
    618
    /* BrtEndCellXFs */
  );
}
function write_STYLES_bin(F) {
  var x = 1;
  write_record(F, 619, write_UInt32LE(x)), write_record(F, 48, write_BrtStyle({
    xfId: 0,
    builtinId: 0,
    name: "Normal"
  })), write_record(
    F,
    620
    /* BrtEndStyles */
  );
}
function write_DXFS_bin(F) {
  var x = 0;
  write_record(F, 505, write_UInt32LE(x)), write_record(
    F,
    506
    /* BrtEndDXFs */
  );
}
function write_TABLESTYLES_bin(F) {
  var x = 0;
  write_record(F, 508, write_BrtBeginTableStyles(x, "TableStyleMedium9", "PivotStyleMedium4")), write_record(
    F,
    509
    /* BrtEndTableStyles */
  );
}
function write_sty_bin(F, x) {
  var w = buf_array();
  return write_record(
    w,
    278
    /* BrtBeginStyleSheet */
  ), write_FMTS_bin(w, F.SSF), write_FONTS_bin(w), write_FILLS_bin(w), write_BORDERS_bin(w), write_CELLSTYLEXFS_bin(w), write_CELLXFS_bin(w, x.cellXfs), write_STYLES_bin(w), write_DXFS_bin(w), write_TABLESTYLES_bin(w), write_record(
    w,
    279
    /* BrtEndStyleSheet */
  ), w.end();
}
var XLSXThemeClrScheme = [
  "</a:lt1>",
  "</a:dk1>",
  "</a:lt2>",
  "</a:dk2>",
  "</a:accent1>",
  "</a:accent2>",
  "</a:accent3>",
  "</a:accent4>",
  "</a:accent5>",
  "</a:accent6>",
  "</a:hlink>",
  "</a:folHlink>"
];
function parse_clrScheme(F, x, w) {
  x.themeElements.clrScheme = [];
  var O = {};
  (F[0].match(tagregex) || []).forEach(function(D) {
    var U = parsexmltag(D);
    switch (U[0]) {
      /* 20.1.6.2 clrScheme (Color Scheme) CT_ColorScheme */
      case "<a:clrScheme":
      case "</a:clrScheme>":
        break;
      /* 20.1.2.3.32 srgbClr CT_SRgbColor */
      case "<a:srgbClr":
        O.rgb = U.val;
        break;
      case "</a:srgbClr>":
        break;
      /* 20.1.2.3.33 sysClr CT_SystemColor */
      case "<a:sysClr":
        O.rgb = U.lastClr;
        break;
      case "</a:sysClr>":
        break;
      /* 20.1.4.1.1 accent1 (Accent 1) */
      /* 20.1.4.1.2 accent2 (Accent 2) */
      /* 20.1.4.1.3 accent3 (Accent 3) */
      /* 20.1.4.1.4 accent4 (Accent 4) */
      /* 20.1.4.1.5 accent5 (Accent 5) */
      /* 20.1.4.1.6 accent6 (Accent 6) */
      /* 20.1.4.1.9 dk1 (Dark 1) */
      /* 20.1.4.1.10 dk2 (Dark 2) */
      /* 20.1.4.1.15 folHlink (Followed Hyperlink) */
      /* 20.1.4.1.19 hlink (Hyperlink) */
      /* 20.1.4.1.22 lt1 (Light 1) */
      /* 20.1.4.1.23 lt2 (Light 2) */
      case "</a:dk1>":
      case "</a:lt1>":
      case "<a:dk1>":
      case "<a:lt1>":
      case "<a:dk2>":
      case "</a:dk2>":
      case "<a:lt2>":
      case "</a:lt2>":
      case "<a:accent1>":
      case "</a:accent1>":
      case "<a:accent2>":
      case "</a:accent2>":
      case "<a:accent3>":
      case "</a:accent3>":
      case "<a:accent4>":
      case "</a:accent4>":
      case "<a:accent5>":
      case "</a:accent5>":
      case "<a:accent6>":
      case "</a:accent6>":
      case "<a:hlink>":
      case "</a:hlink>":
      case "<a:folHlink>":
      case "</a:folHlink>":
        U[0].charAt(1) === "/" ? (x.themeElements.clrScheme[XLSXThemeClrScheme.indexOf(U[0])] = O, O = {}) : O.name = U[0].slice(3, U[0].length - 1);
        break;
      default:
        if (w && w.WTF) throw new Error("Unrecognized " + U[0] + " in clrScheme");
    }
  });
}
function parse_themeElements(F, x, w) {
  x.themeElements = {};
  var O;
  if (!(O = str_match_xml(F, "a:clrScheme"))) throw new Error("clrScheme not found in themeElements");
  if (parse_clrScheme(O, x, w), !(O = str_match_xml(F, "a:fontScheme"))) throw new Error("fontScheme not found in themeElements");
  if (!(O = str_match_xml(F, "a:fmtScheme"))) throw new Error("fmtScheme not found in themeElements");
}
function parse_theme_xml(F, x) {
  (!F || F.length === 0) && (F = write_theme());
  var w, O = {};
  if (!(w = str_match_xml(F, "a:themeElements"))) throw new Error("themeElements not found in theme");
  return parse_themeElements(w[0], O, x), O.raw = F, O;
}
function write_theme(F, x) {
  if (x && x.themeXLSX) return x.themeXLSX;
  if (F && typeof F.raw == "string") return F.raw;
  var w = [XML_HEADER];
  return w[w.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">', w[w.length] = "<a:themeElements>", w[w.length] = '<a:clrScheme name="Office">', w[w.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>', w[w.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>', w[w.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>', w[w.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>', w[w.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>', w[w.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>', w[w.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>', w[w.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>', w[w.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>', w[w.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>', w[w.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>', w[w.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>', w[w.length] = "</a:clrScheme>", w[w.length] = '<a:fontScheme name="Office">', w[w.length] = "<a:majorFont>", w[w.length] = '<a:latin typeface="Cambria"/>', w[w.length] = '<a:ea typeface=""/>', w[w.length] = '<a:cs typeface=""/>', w[w.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>', w[w.length] = '<a:font script="Hang" typeface="맑은 고딕"/>', w[w.length] = '<a:font script="Hans" typeface="宋体"/>', w[w.length] = '<a:font script="Hant" typeface="新細明體"/>', w[w.length] = '<a:font script="Arab" typeface="Times New Roman"/>', w[w.length] = '<a:font script="Hebr" typeface="Times New Roman"/>', w[w.length] = '<a:font script="Thai" typeface="Tahoma"/>', w[w.length] = '<a:font script="Ethi" typeface="Nyala"/>', w[w.length] = '<a:font script="Beng" typeface="Vrinda"/>', w[w.length] = '<a:font script="Gujr" typeface="Shruti"/>', w[w.length] = '<a:font script="Khmr" typeface="MoolBoran"/>', w[w.length] = '<a:font script="Knda" typeface="Tunga"/>', w[w.length] = '<a:font script="Guru" typeface="Raavi"/>', w[w.length] = '<a:font script="Cans" typeface="Euphemia"/>', w[w.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', w[w.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', w[w.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', w[w.length] = '<a:font script="Thaa" typeface="MV Boli"/>', w[w.length] = '<a:font script="Deva" typeface="Mangal"/>', w[w.length] = '<a:font script="Telu" typeface="Gautami"/>', w[w.length] = '<a:font script="Taml" typeface="Latha"/>', w[w.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', w[w.length] = '<a:font script="Orya" typeface="Kalinga"/>', w[w.length] = '<a:font script="Mlym" typeface="Kartika"/>', w[w.length] = '<a:font script="Laoo" typeface="DokChampa"/>', w[w.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', w[w.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', w[w.length] = '<a:font script="Viet" typeface="Times New Roman"/>', w[w.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', w[w.length] = '<a:font script="Geor" typeface="Sylfaen"/>', w[w.length] = "</a:majorFont>", w[w.length] = "<a:minorFont>", w[w.length] = '<a:latin typeface="Calibri"/>', w[w.length] = '<a:ea typeface=""/>', w[w.length] = '<a:cs typeface=""/>', w[w.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>', w[w.length] = '<a:font script="Hang" typeface="맑은 고딕"/>', w[w.length] = '<a:font script="Hans" typeface="宋体"/>', w[w.length] = '<a:font script="Hant" typeface="新細明體"/>', w[w.length] = '<a:font script="Arab" typeface="Arial"/>', w[w.length] = '<a:font script="Hebr" typeface="Arial"/>', w[w.length] = '<a:font script="Thai" typeface="Tahoma"/>', w[w.length] = '<a:font script="Ethi" typeface="Nyala"/>', w[w.length] = '<a:font script="Beng" typeface="Vrinda"/>', w[w.length] = '<a:font script="Gujr" typeface="Shruti"/>', w[w.length] = '<a:font script="Khmr" typeface="DaunPenh"/>', w[w.length] = '<a:font script="Knda" typeface="Tunga"/>', w[w.length] = '<a:font script="Guru" typeface="Raavi"/>', w[w.length] = '<a:font script="Cans" typeface="Euphemia"/>', w[w.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', w[w.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', w[w.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', w[w.length] = '<a:font script="Thaa" typeface="MV Boli"/>', w[w.length] = '<a:font script="Deva" typeface="Mangal"/>', w[w.length] = '<a:font script="Telu" typeface="Gautami"/>', w[w.length] = '<a:font script="Taml" typeface="Latha"/>', w[w.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', w[w.length] = '<a:font script="Orya" typeface="Kalinga"/>', w[w.length] = '<a:font script="Mlym" typeface="Kartika"/>', w[w.length] = '<a:font script="Laoo" typeface="DokChampa"/>', w[w.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', w[w.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', w[w.length] = '<a:font script="Viet" typeface="Arial"/>', w[w.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', w[w.length] = '<a:font script="Geor" typeface="Sylfaen"/>', w[w.length] = "</a:minorFont>", w[w.length] = "</a:fontScheme>", w[w.length] = '<a:fmtScheme name="Office">', w[w.length] = "<a:fillStyleLst>", w[w.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', w[w.length] = '<a:gradFill rotWithShape="1">', w[w.length] = "<a:gsLst>", w[w.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', w[w.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', w[w.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', w[w.length] = "</a:gsLst>", w[w.length] = '<a:lin ang="16200000" scaled="1"/>', w[w.length] = "</a:gradFill>", w[w.length] = '<a:gradFill rotWithShape="1">', w[w.length] = "<a:gsLst>", w[w.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>', w[w.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', w[w.length] = "</a:gsLst>", w[w.length] = '<a:lin ang="16200000" scaled="0"/>', w[w.length] = "</a:gradFill>", w[w.length] = "</a:fillStyleLst>", w[w.length] = "<a:lnStyleLst>", w[w.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>', w[w.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', w[w.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', w[w.length] = "</a:lnStyleLst>", w[w.length] = "<a:effectStyleLst>", w[w.length] = "<a:effectStyle>", w[w.length] = "<a:effectLst>", w[w.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>', w[w.length] = "</a:effectLst>", w[w.length] = "</a:effectStyle>", w[w.length] = "<a:effectStyle>", w[w.length] = "<a:effectLst>", w[w.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', w[w.length] = "</a:effectLst>", w[w.length] = "</a:effectStyle>", w[w.length] = "<a:effectStyle>", w[w.length] = "<a:effectLst>", w[w.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', w[w.length] = "</a:effectLst>", w[w.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>', w[w.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>', w[w.length] = "</a:effectStyle>", w[w.length] = "</a:effectStyleLst>", w[w.length] = "<a:bgFillStyleLst>", w[w.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', w[w.length] = '<a:gradFill rotWithShape="1">', w[w.length] = "<a:gsLst>", w[w.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', w[w.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', w[w.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>', w[w.length] = "</a:gsLst>", w[w.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>', w[w.length] = "</a:gradFill>", w[w.length] = '<a:gradFill rotWithShape="1">', w[w.length] = "<a:gsLst>", w[w.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', w[w.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>', w[w.length] = "</a:gsLst>", w[w.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>', w[w.length] = "</a:gradFill>", w[w.length] = "</a:bgFillStyleLst>", w[w.length] = "</a:fmtScheme>", w[w.length] = "</a:themeElements>", w[w.length] = "<a:objectDefaults>", w[w.length] = "<a:spDef>", w[w.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>', w[w.length] = "</a:spDef>", w[w.length] = "<a:lnDef>", w[w.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>', w[w.length] = "</a:lnDef>", w[w.length] = "</a:objectDefaults>", w[w.length] = "<a:extraClrSchemeLst/>", w[w.length] = "</a:theme>", w.join("");
}
function parse_Theme(F, x, w) {
  var O = F.l + x, D = F.read_shift(4);
  if (D !== 124226) {
    if (!w.cellStyles) {
      F.l = O;
      return;
    }
    var U = F.slice(F.l);
    F.l = O;
    var W;
    try {
      W = zip_read(U, { type: "array" });
    } catch {
      return;
    }
    var X = getzipstr(W, "theme/theme/theme1.xml", !0);
    if (X)
      return parse_theme_xml(X, w);
  }
}
function parse_ColorTheme(F) {
  return F.read_shift(4);
}
function parse_FullColorExt(F) {
  var x = {};
  switch (x.xclrType = F.read_shift(2), x.nTintShade = F.read_shift(2), x.xclrType) {
    case 0:
      F.l += 4;
      break;
    case 1:
      x.xclrValue = parse_IcvXF(F, 4);
      break;
    case 2:
      x.xclrValue = parse_LongRGBA(F);
      break;
    case 3:
      x.xclrValue = parse_ColorTheme(F);
      break;
    case 4:
      F.l += 4;
      break;
  }
  return F.l += 8, x;
}
function parse_IcvXF(F, x) {
  return parsenoop(F, x);
}
function parse_XFExtGradient(F, x) {
  return parsenoop(F, x);
}
function parse_ExtProp(F) {
  var x = F.read_shift(2), w = F.read_shift(2) - 4, O = [x];
  switch (x) {
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 13:
      O[1] = parse_FullColorExt(F);
      break;
    case 6:
      O[1] = parse_XFExtGradient(F, w);
      break;
    case 14:
    case 15:
      O[1] = F.read_shift(w === 1 ? 1 : 2);
      break;
    default:
      throw new Error("Unrecognized ExtProp type: " + x + " " + w);
  }
  return O;
}
function parse_XFExt(F, x) {
  var w = F.l + x;
  F.l += 2;
  var O = F.read_shift(2);
  F.l += 2;
  for (var D = F.read_shift(2), U = []; D-- > 0; ) U.push(parse_ExtProp(F, w - F.l));
  return { ixfe: O, ext: U };
}
function update_xfext(F, x) {
  x.forEach(function(w) {
    w[0];
  });
}
function parse_BrtMdtinfo(F, x) {
  return {
    flags: F.read_shift(4),
    version: F.read_shift(4),
    name: parse_XLWideString(F)
  };
}
function write_BrtMdtinfo(F) {
  var x = new_buf(12 + 2 * F.name.length);
  return x.write_shift(4, F.flags), x.write_shift(4, F.version), write_XLWideString(F.name, x), x.slice(0, x.l);
}
function parse_BrtMdb(F) {
  for (var x = [], w = F.read_shift(4); w-- > 0; )
    x.push([F.read_shift(4), F.read_shift(4)]);
  return x;
}
function write_BrtMdb(F) {
  var x = new_buf(4 + 8 * F.length);
  x.write_shift(4, F.length);
  for (var w = 0; w < F.length; ++w)
    x.write_shift(4, F[w][0]), x.write_shift(4, F[w][1]);
  return x;
}
function write_BrtBeginEsfmd(F, x) {
  var w = new_buf(8 + 2 * x.length);
  return w.write_shift(4, F), write_XLWideString(x, w), w.slice(0, w.l);
}
function parse_BrtBeginEsmdb(F) {
  return F.l += 4, F.read_shift(4) != 0;
}
function write_BrtBeginEsmdb(F, x) {
  var w = new_buf(8);
  return w.write_shift(4, F), w.write_shift(4, 1), w;
}
function parse_xlmeta_bin(F, x, w) {
  var O = { Types: [], Cell: [], Value: [] }, D = w || {}, U = [], W = !1, X = 2;
  return recordhopper(F, function(G, Y, K) {
    switch (K) {
      case 335:
        O.Types.push({ name: G.name });
        break;
      case 51:
        G.forEach(function(Z) {
          X == 1 ? O.Cell.push({ type: O.Types[Z[0] - 1].name, index: Z[1] }) : X == 0 && O.Value.push({ type: O.Types[Z[0] - 1].name, index: Z[1] });
        });
        break;
      case 337:
        X = G ? 1 : 0;
        break;
      case 338:
        X = 2;
        break;
      case 35:
        U.push(K), W = !0;
        break;
      case 36:
        U.pop(), W = !1;
        break;
      default:
        if (!Y.T) {
          if (!W || D.WTF && U[U.length - 1] != 35)
            throw new Error("Unexpected record 0x" + K.toString(16));
        }
    }
  }), O;
}
function write_xlmeta_bin() {
  var F = buf_array();
  return write_record(F, 332), write_record(F, 334, write_UInt32LE(1)), write_record(F, 335, write_BrtMdtinfo({
    name: "XLDAPR",
    version: 12e4,
    flags: 3496657072
  })), write_record(F, 336), write_record(F, 339, write_BrtBeginEsfmd(1, "XLDAPR")), write_record(F, 52), write_record(F, 35, write_UInt32LE(514)), write_record(F, 4096, write_UInt32LE(0)), write_record(F, 4097, writeuint16(1)), write_record(F, 36), write_record(F, 53), write_record(F, 340), write_record(F, 337, write_BrtBeginEsmdb(1)), write_record(F, 51, write_BrtMdb([[1, 0]])), write_record(F, 338), write_record(F, 333), F.end();
}
function parse_xlmeta_xml(F, x, w) {
  var O = { Types: [], Cell: [], Value: [] };
  if (!F)
    return O;
  var D = !1, U = 2, W;
  return F.replace(tagregex, function(X) {
    var G = parsexmltag(X);
    switch (strip_ns(G[0])) {
      case "<?xml":
        break;
      case "<metadata":
      case "</metadata>":
        break;
      case "<metadataTypes":
      case "</metadataTypes>":
        break;
      case "<metadataType":
        O.Types.push({ name: G.name });
        break;
      case "</metadataType>":
        break;
      case "<futureMetadata":
        for (var Y = 0; Y < O.Types.length; ++Y)
          O.Types[Y].name == G.name && (W = O.Types[Y]);
        break;
      case "</futureMetadata>":
        break;
      case "<bk>":
        break;
      case "</bk>":
        break;
      case "<rc":
        U == 1 ? O.Cell.push({ type: O.Types[G.t - 1].name, index: +G.v }) : U == 0 && O.Value.push({ type: O.Types[G.t - 1].name, index: +G.v });
        break;
      case "</rc>":
        break;
      case "<cellMetadata":
        U = 1;
        break;
      case "</cellMetadata>":
        U = 2;
        break;
      case "<valueMetadata":
        U = 0;
        break;
      case "</valueMetadata>":
        U = 2;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        D = !0;
        break;
      case "</ext>":
        D = !1;
        break;
      case "<rvb":
        if (!W)
          break;
        W.offsets || (W.offsets = []), W.offsets.push(+G.i);
        break;
      default:
        if (!D && w?.WTF)
          throw new Error("unrecognized " + G[0] + " in metadata");
    }
    return X;
  }), O;
}
function write_xlmeta_xml() {
  var F = [XML_HEADER];
  return F.push(`<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">
  <metadataTypes count="1">
    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>
  </metadataTypes>
  <futureMetadata name="XLDAPR" count="1">
    <bk>
      <extLst>
        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">
          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>
        </ext>
      </extLst>
    </bk>
  </futureMetadata>
  <cellMetadata count="1">
    <bk>
      <rc t="1" v="0"/>
    </bk>
  </cellMetadata>
</metadata>`), F.join("");
}
function parse_cc_xml(F) {
  var x = [];
  if (!F) return x;
  var w = 1;
  return (F.match(tagregex) || []).forEach(function(O) {
    var D = parsexmltag(O);
    switch (D[0]) {
      case "<?xml":
        break;
      /* 18.6.2  calcChain CT_CalcChain 1 */
      case "<calcChain":
      case "<calcChain>":
      case "</calcChain>":
        break;
      /* 18.6.1  c CT_CalcCell 1 */
      case "<c":
        delete D[0], D.i ? w = D.i : D.i = w, x.push(D);
        break;
    }
  }), x;
}
function parse_BrtCalcChainItem$(F) {
  var x = {};
  x.i = F.read_shift(4);
  var w = {};
  w.r = F.read_shift(4), w.c = F.read_shift(4), x.r = encode_cell(w);
  var O = F.read_shift(1);
  return O & 2 && (x.l = "1"), O & 8 && (x.a = "1"), x;
}
function parse_cc_bin(F, x, w) {
  var O = [];
  return recordhopper(F, function(U, W, X) {
    switch (X) {
      case 63:
        O.push(U);
        break;
      default:
        if (!W.T) throw new Error("Unexpected record 0x" + X.toString(16));
    }
  }), O;
}
function parse_xlink_xml() {
}
function parse_xlink_bin(F, x, w, O) {
  if (!F) return F;
  var D = O || {}, U = !1;
  recordhopper(F, function(X, G, Y) {
    switch (Y) {
      case 359:
      /* 'BrtSupTabs' */
      case 363:
      /* 'BrtExternTableStart' */
      case 364:
      /* 'BrtExternTableEnd' */
      case 366:
      /* 'BrtExternRowHdr' */
      case 367:
      /* 'BrtExternCellBlank' */
      case 368:
      /* 'BrtExternCellReal' */
      case 369:
      /* 'BrtExternCellBool' */
      case 370:
      /* 'BrtExternCellError' */
      case 371:
      /* 'BrtExternCellString' */
      case 472:
      /* 'BrtExternValueMeta' */
      case 577:
      /* 'BrtSupNameStart' */
      case 578:
      /* 'BrtSupNameValueStart' */
      case 579:
      /* 'BrtSupNameValueEnd' */
      case 580:
      /* 'BrtSupNameNum' */
      case 581:
      /* 'BrtSupNameErr' */
      case 582:
      /* 'BrtSupNameSt' */
      case 583:
      /* 'BrtSupNameNil' */
      case 584:
      /* 'BrtSupNameBool' */
      case 585:
      /* 'BrtSupNameFmla' */
      case 586:
      /* 'BrtSupNameBits' */
      case 587:
        break;
      case 35:
        U = !0;
        break;
      case 36:
        U = !1;
        break;
      default:
        if (!G.T) {
          if (!U || D.WTF) throw new Error("Unexpected record 0x" + Y.toString(16));
        }
    }
  }, D);
}
function parse_drawing(F, x) {
  if (!F) return "??";
  var w = (F.match(/<c:chart [^<>]*r:id="([^<>"]*)"/) || ["", ""])[1];
  return x["!id"][w].Target;
}
function parse_vml(F, x, w) {
  var O = 0;
  (str_match_xml_ns_g(F, "shape") || []).forEach(function(D) {
    var U = "", W = !0, X = -1, G = -1, Y = -1;
    switch (D.replace(tagregex, function(Z, q) {
      var J = parsexmltag(Z);
      switch (strip_ns(J[0])) {
        case "<ClientData":
          J.ObjectType && (U = J.ObjectType);
          break;
        case "<Visible":
        case "<Visible/>":
          W = !1;
          break;
        case "<Row":
        case "<Row>":
          X = q + Z.length;
          break;
        case "</Row>":
          G = +D.slice(X, q).trim();
          break;
        case "<Column":
        case "<Column>":
          X = q + Z.length;
          break;
        case "</Column>":
          Y = +D.slice(X, q).trim();
          break;
      }
      return "";
    }), U) {
      case "Note":
        var K = ws_get_cell_stub(x, G >= 0 && Y >= 0 ? encode_cell({ r: G, c: Y }) : w[O].ref);
        K.c && (K.c.hidden = W), ++O;
        break;
    }
  });
}
function write_vml(F, x, w) {
  var O = [21600, 21600], D = ["m0,0l0", O[1], O[0], O[1], O[0], "0xe"].join(","), U = [
    writextag("xml", null, { "xmlns:v": XLMLNS.v, "xmlns:o": XLMLNS.o, "xmlns:x": XLMLNS.x, "xmlns:mv": XLMLNS.mv }).replace(/\/>/, ">"),
    writextag("o:shapelayout", writextag("o:idmap", null, { "v:ext": "edit", data: F }), { "v:ext": "edit" })
  ], W = 65536 * F, X = x || [];
  return X.length > 0 && U.push(writextag("v:shapetype", [
    writextag("v:stroke", null, { joinstyle: "miter" }),
    writextag("v:path", null, { gradientshapeok: "t", "o:connecttype": "rect" })
  ].join(""), { id: "_x0000_t202", coordsize: O.join(","), "o:spt": 202, path: D })), X.forEach(function(G) {
    ++W, U.push(write_vml_comment(G, W));
  }), U.push("</xml>"), U.join("");
}
function write_vml_comment(F, x, w) {
  var O = decode_cell(F[0]), D = (
    /*::(*/
    { color2: "#BEFF82", type: "gradient" }
  );
  D.type == "gradient" && (D.angle = "-180");
  var U = D.type == "gradient" ? writextag("o:fill", null, { type: "gradientUnscaled", "v:ext": "view" }) : null, W = writextag("v:fill", U, D), X = { on: "t", obscured: "t" };
  return [
    "<v:shape" + wxt_helper({
      id: "_x0000_s" + x,
      type: "#_x0000_t202",
      style: "position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (F[1].hidden ? ";visibility:hidden" : ""),
      fillcolor: "#ECFAD4",
      strokecolor: "#edeaa1"
    }) + ">",
    W,
    writextag("v:shadow", null, X),
    writextag("v:path", null, { "o:connecttype": "none" }),
    '<v:textbox><div style="text-align:left"></div></v:textbox>',
    '<x:ClientData ObjectType="Note">',
    "<x:MoveWithCells/>",
    "<x:SizeWithCells/>",
    /* Part 4 19.4.2.3 Anchor (Anchor) */
    writetag("x:Anchor", [O.c + 1, 0, O.r + 1, 0, O.c + 3, 20, O.r + 5, 20].join(",")),
    writetag("x:AutoFill", "False"),
    writetag("x:Row", String(O.r)),
    writetag("x:Column", String(O.c)),
    F[1].hidden ? "" : "<x:Visible/>",
    "</x:ClientData>",
    "</v:shape>"
  ].join("");
}
function sheet_insert_comments(F, x, w, O) {
  var D = F["!data"] != null, U;
  x.forEach(function(W) {
    var X = decode_cell(W.ref);
    if (!(X.r < 0 || X.c < 0)) {
      if (D ? (F["!data"][X.r] || (F["!data"][X.r] = []), U = F["!data"][X.r][X.c]) : U = F[W.ref], !U) {
        U = { t: "z" }, D ? F["!data"][X.r][X.c] = U : F[W.ref] = U;
        var G = safe_decode_range(F["!ref"] || "BDWGO1000001:A1");
        G.s.r > X.r && (G.s.r = X.r), G.e.r < X.r && (G.e.r = X.r), G.s.c > X.c && (G.s.c = X.c), G.e.c < X.c && (G.e.c = X.c);
        var Y = encode_range(G);
        F["!ref"] = Y;
      }
      U.c || (U.c = []);
      var K = { a: W.author, t: W.t, r: W.r, T: w };
      W.h && (K.h = W.h);
      for (var Z = U.c.length - 1; Z >= 0; --Z) {
        if (!w && U.c[Z].T) return;
        w && !U.c[Z].T && U.c.splice(Z, 1);
      }
      if (w && O) {
        for (Z = 0; Z < O.length; ++Z)
          if (K.a == O[Z].id) {
            K.a = O[Z].name || K.a;
            break;
          }
      }
      U.c.push(K);
    }
  });
}
function parse_comments_xml(F, x) {
  if (F.match(/<(?:\w+:)?comments *\/>/)) return [];
  var w = [], O = [], D = str_match_xml_ns(F, "authors");
  D && D[1] && D[1].split(/<\/\w*:?author>/).forEach(function(W) {
    if (!(W === "" || W.trim() === "")) {
      var X = W.match(/<(?:\w+:)?author[^<>]*>(.*)/);
      X && w.push(X[1]);
    }
  });
  var U = str_match_xml_ns(F, "commentList");
  return U && U[1] && U[1].split(/<\/\w*:?comment>/).forEach(function(W) {
    if (!(W === "" || W.trim() === "")) {
      var X = W.match(/<(?:\w+:)?comment[^<>]*>/);
      if (X) {
        var G = parsexmltag(X[0]), Y = { author: G.authorId && w[G.authorId] || "sheetjsghost", ref: G.ref, guid: G.guid }, K = decode_cell(G.ref);
        if (!(x.sheetRows && x.sheetRows <= K.r)) {
          var Z = str_match_xml_ns(W, "text"), q = !!Z && !!Z[1] && parse_si(Z[1]) || { r: "", t: "", h: "" };
          Y.r = q.r, q.r == "<t></t>" && (q.t = q.h = ""), Y.t = (q.t || "").replace(/\r\n/g, `
`).replace(/\r/g, `
`), x.cellHTML && (Y.h = q.h), O.push(Y);
        }
      }
    }
  }), O;
}
function write_comments_xml(F) {
  var x = [XML_HEADER, writextag("comments", null, { xmlns: XMLNS_main[0] })], w = [];
  return x.push("<authors>"), F.forEach(function(O) {
    O[1].forEach(function(D) {
      var U = escapexml(D.a);
      w.indexOf(U) == -1 && (w.push(U), x.push("<author>" + U + "</author>")), D.T && D.ID && w.indexOf("tc=" + D.ID) == -1 && (w.push("tc=" + D.ID), x.push("<author>tc=" + D.ID + "</author>"));
    });
  }), w.length == 0 && (w.push("SheetJ5"), x.push("<author>SheetJ5</author>")), x.push("</authors>"), x.push("<commentList>"), F.forEach(function(O) {
    var D = 0, U = [], W = 0;
    if (O[1][0] && O[1][0].T && O[1][0].ID && (D = w.indexOf("tc=" + O[1][0].ID)), O[1].forEach(function(Y) {
      Y.a && (D = w.indexOf(escapexml(Y.a))), Y.T && ++W, U.push(Y.t == null ? "" : escapexml(Y.t));
    }), W === 0)
      O[1].forEach(function(Y) {
        x.push('<comment ref="' + O[0] + '" authorId="' + w.indexOf(escapexml(Y.a)) + '"><text>'), x.push(writetag("t", Y.t == null ? "" : escapexml(Y.t))), x.push("</text></comment>");
      });
    else {
      O[1][0] && O[1][0].T && O[1][0].ID && (D = w.indexOf("tc=" + O[1][0].ID)), x.push('<comment ref="' + O[0] + '" authorId="' + D + '"><text>');
      for (var X = `Comment:
    ` + U[0] + `
`, G = 1; G < U.length; ++G) X += `Reply:
    ` + U[G] + `
`;
      x.push(writetag("t", escapexml(X))), x.push("</text></comment>");
    }
  }), x.push("</commentList>"), x.length > 2 && (x[x.length] = "</comments>", x[1] = x[1].replace("/>", ">")), x.join("");
}
function parse_tcmnt_xml(F, x) {
  var w = [], O = !1, D = {}, U = 0;
  return F.replace(tagregex, function(X, G) {
    var Y = parsexmltag(X);
    switch (strip_ns(Y[0])) {
      case "<?xml":
        break;
      /* 2.6.207 ThreadedComments CT_ThreadedComments */
      case "<ThreadedComments":
        break;
      case "</ThreadedComments>":
        break;
      /* 2.6.205 threadedComment CT_ThreadedComment */
      case "<threadedComment":
        D = { author: Y.personId, guid: Y.id, ref: Y.ref, T: 1 };
        break;
      case "</threadedComment>":
        D.t != null && w.push(D);
        break;
      case "<text>":
      case "<text":
        U = G + X.length;
        break;
      case "</text>":
        D.t = F.slice(U, G).replace(/\r\n/g, `
`).replace(/\r/g, `
`);
        break;
      /* 2.6.206 mentions CT_ThreadedCommentMentions TODO */
      case "<mentions":
      case "<mentions>":
        O = !0;
        break;
      case "</mentions>":
        O = !1;
        break;
      /* 2.6.202 mention CT_Mention TODO */
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      /* 18.2.7  ext CT_Extension + */
      case "<ext":
        O = !0;
        break;
      case "</ext>":
        O = !1;
        break;
      default:
        if (!O && x.WTF) throw new Error("unrecognized " + Y[0] + " in threaded comments");
    }
    return X;
  }), w;
}
function write_tcmnt_xml(F, x, w) {
  var O = [XML_HEADER, writextag("ThreadedComments", null, { xmlns: XMLNS.TCMNT }).replace(/[\/]>/, ">")];
  return F.forEach(function(D) {
    var U = "";
    (D[1] || []).forEach(function(W, X) {
      if (!W.T) {
        delete W.ID;
        return;
      }
      W.a && x.indexOf(W.a) == -1 && x.push(W.a);
      var G = {
        ref: D[0],
        id: "{54EE7951-7262-4200-6969-" + ("000000000000" + w.tcid++).slice(-12) + "}"
      };
      X == 0 ? U = G.id : G.parentId = U, W.ID = G.id, W.a && (G.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + x.indexOf(W.a)).slice(-12) + "}"), O.push(writextag("threadedComment", writetag("text", W.t || ""), G));
    });
  }), O.push("</ThreadedComments>"), O.join("");
}
function parse_people_xml(F, x) {
  var w = [], O = !1;
  return F.replace(tagregex, function(U) {
    var W = parsexmltag(U);
    switch (strip_ns(W[0])) {
      case "<?xml":
        break;
      /* 2.4.85 personList CT_PersonList */
      case "<personList":
        break;
      case "</personList>":
        break;
      /* 2.6.203 person CT_Person TODO: providers */
      case "<person":
        w.push({ name: W.displayname, id: W.id });
        break;
      case "</person>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      /* 18.2.7  ext CT_Extension + */
      case "<ext":
        O = !0;
        break;
      case "</ext>":
        O = !1;
        break;
      default:
        if (!O && x.WTF) throw new Error("unrecognized " + W[0] + " in threaded comments");
    }
    return U;
  }), w;
}
function write_people_xml(F) {
  var x = [XML_HEADER, writextag("personList", null, {
    xmlns: XMLNS.TCMNT,
    "xmlns:x": XMLNS_main[0]
  }).replace(/[\/]>/, ">")];
  return F.forEach(function(w, O) {
    x.push(writextag("person", null, {
      displayName: w,
      id: "{54EE7950-7262-4200-6969-" + ("000000000000" + O).slice(-12) + "}",
      userId: w,
      providerId: "None"
    }));
  }), x.push("</personList>"), x.join("");
}
function parse_BrtBeginComment(F) {
  var x = {};
  x.iauthor = F.read_shift(4);
  var w = parse_UncheckedRfX(F);
  return x.rfx = w.s, x.ref = encode_cell(w.s), F.l += 16, x;
}
function write_BrtBeginComment(F, x) {
  return x == null && (x = new_buf(36)), x.write_shift(4, F[1].iauthor), write_UncheckedRfX(F[0], x), x.write_shift(4, 0), x.write_shift(4, 0), x.write_shift(4, 0), x.write_shift(4, 0), x;
}
var parse_BrtCommentAuthor = parse_XLWideString;
function write_BrtCommentAuthor(F) {
  return write_XLWideString(F.slice(0, 54));
}
function parse_comments_bin(F, x) {
  var w = [], O = [], D = {}, U = !1;
  return recordhopper(F, function(X, G, Y) {
    switch (Y) {
      case 632:
        O.push(X);
        break;
      case 635:
        D = X;
        break;
      case 637:
        D.t = X.t, D.h = X.h, D.r = X.r;
        break;
      case 636:
        if (D.author = O[D.iauthor], delete D.iauthor, x.sheetRows && D.rfx && x.sheetRows <= D.rfx.r) break;
        D.t || (D.t = ""), delete D.rfx, w.push(D);
        break;
      case 3072:
        break;
      case 35:
        U = !0;
        break;
      case 36:
        U = !1;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (!G.T) {
          if (!U || x.WTF) throw new Error("Unexpected record 0x" + Y.toString(16));
        }
    }
  }), w;
}
function write_comments_bin(F) {
  var x = buf_array(), w = [];
  return write_record(
    x,
    628
    /* BrtBeginComments */
  ), write_record(
    x,
    630
    /* BrtBeginCommentAuthors */
  ), F.forEach(function(O) {
    O[1].forEach(function(D) {
      w.indexOf(D.a) > -1 || (w.push(D.a.slice(0, 54)), write_record(x, 632, write_BrtCommentAuthor(D.a)), D.T && D.ID && w.indexOf("tc=" + D.ID) == -1 && (w.push("tc=" + D.ID), write_record(x, 632, write_BrtCommentAuthor("tc=" + D.ID))));
    });
  }), write_record(
    x,
    631
    /* BrtEndCommentAuthors */
  ), write_record(
    x,
    633
    /* BrtBeginCommentList */
  ), F.forEach(function(O) {
    O[1].forEach(function(D) {
      var U = -1;
      D.ID && (U = w.indexOf("tc=" + D.ID)), U == -1 && O[1][0].T && O[1][0].ID && (U = w.indexOf("tc=" + O[1][0].ID)), U == -1 && (U = w.indexOf(D.a)), D.iauthor = U;
      var W = { s: decode_cell(O[0]), e: decode_cell(O[0]) };
      write_record(x, 635, write_BrtBeginComment([W, D])), D.t && D.t.length > 0 && write_record(x, 637, write_BrtCommentText(D)), write_record(
        x,
        636
        /* BrtEndComment */
      ), delete D.iauthor;
    });
  }), write_record(
    x,
    634
    /* BrtEndCommentList */
  ), write_record(
    x,
    629
    /* BrtEndComments */
  ), x.end();
}
var CT_VBA = "application/vnd.ms-office.vbaProject";
function make_vba_xls(F) {
  var x = CFB.utils.cfb_new({ root: "R" });
  return F.FullPaths.forEach(function(w, O) {
    if (!(w.slice(-1) === "/" || !w.match(/_VBA_PROJECT_CUR/))) {
      var D = w.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");
      CFB.utils.cfb_add(x, D, F.FileIndex[O].content);
    }
  }), CFB.write(x);
}
function fill_vba_xls(F, x) {
  x.FullPaths.forEach(function(w, O) {
    if (O != 0) {
      var D = w.replace(/^[\/]*[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
      D.slice(-1) !== "/" && CFB.utils.cfb_add(F, D, x.FileIndex[O].content);
    }
  });
}
var VBAFMTS = ["xlsb", "xlsm", "xlam", "biff8", "xla"];
function parse_ds_bin() {
  return { "!type": "dialog" };
}
function parse_ds_xml() {
  return { "!type": "dialog" };
}
function parse_ms_bin() {
  return { "!type": "macro" };
}
function parse_ms_xml() {
  return { "!type": "macro" };
}
var rc_to_a1 = /* @__PURE__ */ function() {
  var F = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g, x = { r: 0, c: 0 };
  function w(O, D, U, W) {
    var X = !1, G = !1;
    U.length == 0 ? G = !0 : U.charAt(0) == "[" && (G = !0, U = U.slice(1, -1)), W.length == 0 ? X = !0 : W.charAt(0) == "[" && (X = !0, W = W.slice(1, -1));
    var Y = U.length > 0 ? parseInt(U, 10) | 0 : 0, K = W.length > 0 ? parseInt(W, 10) | 0 : 0;
    return X ? K += x.c : --K, G ? Y += x.r : --Y, D + (X ? "" : "$") + encode_col(K) + (G ? "" : "$") + encode_row(Y);
  }
  return function(D, U) {
    return x = U, D.replace(F, w);
  };
}(), crefregex = /(^|[^._A-Z0-9])(\$?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])(\$?)(\d{1,7})(?![_.\(A-Za-z0-9])/g;
try {
  crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
} catch (F) {
}
var a1_to_rc = /* @__PURE__ */ function() {
  return function(x, w) {
    return x.replace(crefregex, function(O, D, U, W, X, G) {
      var Y = decode_col(W) - (U ? 0 : w.c), K = decode_row(G) - (X ? 0 : w.r), Z = X == "$" ? K + 1 : K == 0 ? "" : "[" + K + "]", q = U == "$" ? Y + 1 : Y == 0 ? "" : "[" + Y + "]";
      return D + "R" + Z + "C" + q;
    });
  };
}();
function shift_formula_str(F, x) {
  return F.replace(crefregex, function(w, O, D, U, W, X) {
    return O + (D == "$" ? D + U : encode_col(decode_col(U) + x.c)) + (W == "$" ? W + X : encode_row(decode_row(X) + x.r));
  });
}
function shift_formula_xlsx(F, x, w) {
  var O = decode_range(x), D = O.s, U = decode_cell(w), W = { r: U.r - D.r, c: U.c - D.c };
  return shift_formula_str(F, W);
}
function fuzzyfmla(F) {
  return F.length != 1;
}
function _xlfn(F) {
  return F.replace(/_xlfn\./g, "");
}
function parseread1(F) {
  F.l += 1;
}
function parse_ColRelU(F, x) {
  var w = F.read_shift(2);
  return [w & 16383, w >> 14 & 1, w >> 15 & 1];
}
function parse_RgceArea(F, x, w) {
  var O = 2;
  if (w) {
    if (w.biff >= 2 && w.biff <= 5) return parse_RgceArea_BIFF2(F);
    w.biff == 12 && (O = 4);
  }
  var D = F.read_shift(O), U = F.read_shift(O), W = parse_ColRelU(F), X = parse_ColRelU(F);
  return { s: { r: D, c: W[0], cRel: W[1], rRel: W[2] }, e: { r: U, c: X[0], cRel: X[1], rRel: X[2] } };
}
function parse_RgceArea_BIFF2(F) {
  var x = parse_ColRelU(F), w = parse_ColRelU(F), O = F.read_shift(1), D = F.read_shift(1);
  return { s: { r: x[0], c: O, cRel: x[1], rRel: x[2] }, e: { r: w[0], c: D, cRel: w[1], rRel: w[2] } };
}
function parse_RgceAreaRel(F, x, w) {
  if (w.biff < 8) return parse_RgceArea_BIFF2(F);
  var O = F.read_shift(w.biff == 12 ? 4 : 2), D = F.read_shift(w.biff == 12 ? 4 : 2), U = parse_ColRelU(F), W = parse_ColRelU(F);
  return { s: { r: O, c: U[0], cRel: U[1], rRel: U[2] }, e: { r: D, c: W[0], cRel: W[1], rRel: W[2] } };
}
function parse_RgceLoc(F, x, w) {
  if (w && w.biff >= 2 && w.biff <= 5) return parse_RgceLoc_BIFF2(F);
  var O = F.read_shift(w && w.biff == 12 ? 4 : 2), D = parse_ColRelU(F);
  return { r: O, c: D[0], cRel: D[1], rRel: D[2] };
}
function parse_RgceLoc_BIFF2(F) {
  var x = parse_ColRelU(F), w = F.read_shift(1);
  return { r: x[0], c: w, cRel: x[1], rRel: x[2] };
}
function parse_RgceElfLoc(F) {
  var x = F.read_shift(2), w = F.read_shift(2);
  return { r: x, c: w & 255, fQuoted: !!(w & 16384), cRel: w >> 15, rRel: w >> 15 };
}
function parse_RgceLocRel(F, x, w) {
  var O = w && w.biff ? w.biff : 8;
  if (O >= 2 && O <= 5) return parse_RgceLocRel_BIFF2(F);
  var D = F.read_shift(O >= 12 ? 4 : 2), U = F.read_shift(2), W = (U & 16384) >> 14, X = (U & 32768) >> 15;
  if (U &= 16383, X == 1) for (; D > 524287; ) D -= 1048576;
  if (W == 1) for (; U > 8191; ) U = U - 16384;
  return { r: D, c: U, cRel: W, rRel: X };
}
function parse_RgceLocRel_BIFF2(F) {
  var x = F.read_shift(2), w = F.read_shift(1), O = (x & 32768) >> 15, D = (x & 16384) >> 14;
  return x &= 16383, O == 1 && x >= 8192 && (x = x - 16384), D == 1 && w >= 128 && (w = w - 256), { r: x, c: w, cRel: D, rRel: O };
}
function parse_PtgArea(F, x, w) {
  var O = (F[F.l++] & 96) >> 5, D = parse_RgceArea(F, w.biff >= 2 && w.biff <= 5 ? 6 : 8, w);
  return [O, D];
}
function parse_PtgArea3d(F, x, w) {
  var O = (F[F.l++] & 96) >> 5, D = F.read_shift(2, "i"), U = 8;
  if (w) switch (w.biff) {
    case 5:
      F.l += 12, U = 6;
      break;
    case 12:
      U = 12;
      break;
  }
  var W = parse_RgceArea(F, U, w);
  return [O, D, W];
}
function parse_PtgAreaErr(F, x, w) {
  var O = (F[F.l++] & 96) >> 5;
  return F.l += w && w.biff > 8 ? 12 : w.biff < 8 ? 6 : 8, [O];
}
function parse_PtgAreaErr3d(F, x, w) {
  var O = (F[F.l++] & 96) >> 5, D = F.read_shift(2), U = 8;
  if (w) switch (w.biff) {
    case 5:
      F.l += 12, U = 6;
      break;
    case 12:
      U = 12;
      break;
  }
  return F.l += U, [O, D];
}
function parse_PtgAreaN(F, x, w) {
  var O = (F[F.l++] & 96) >> 5, D = parse_RgceAreaRel(F, x - 1, w);
  return [O, D];
}
function parse_PtgArray(F, x, w) {
  var O = (F[F.l++] & 96) >> 5;
  return F.l += w.biff == 2 ? 6 : w.biff == 12 ? 14 : 7, [O];
}
function parse_PtgAttrBaxcel(F) {
  var x = F[F.l + 1] & 1, w = 1;
  return F.l += 4, [x, w];
}
function parse_PtgAttrChoose(F, x, w) {
  F.l += 2;
  for (var O = F.read_shift(w && w.biff == 2 ? 1 : 2), D = [], U = 0; U <= O; ++U) D.push(F.read_shift(w && w.biff == 2 ? 1 : 2));
  return D;
}
function parse_PtgAttrGoto(F, x, w) {
  var O = F[F.l + 1] & 255 ? 1 : 0;
  return F.l += 2, [O, F.read_shift(w && w.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIf(F, x, w) {
  var O = F[F.l + 1] & 255 ? 1 : 0;
  return F.l += 2, [O, F.read_shift(w && w.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIfError(F) {
  var x = F[F.l + 1] & 255 ? 1 : 0;
  return F.l += 2, [x, F.read_shift(2)];
}
function parse_PtgAttrSemi(F, x, w) {
  var O = F[F.l + 1] & 255 ? 1 : 0;
  return F.l += w && w.biff == 2 ? 3 : 4, [O];
}
function parse_PtgAttrSpaceType(F) {
  var x = F.read_shift(1), w = F.read_shift(1);
  return [x, w];
}
function parse_PtgAttrSpace(F) {
  return F.read_shift(2), parse_PtgAttrSpaceType(F);
}
function parse_PtgAttrSpaceSemi(F) {
  return F.read_shift(2), parse_PtgAttrSpaceType(F);
}
function parse_PtgRef(F, x, w) {
  var O = (F[F.l] & 96) >> 5;
  F.l += 1;
  var D = parse_RgceLoc(F, 0, w);
  return [O, D];
}
function parse_PtgRefN(F, x, w) {
  var O = (F[F.l] & 96) >> 5;
  F.l += 1;
  var D = parse_RgceLocRel(F, 0, w);
  return [O, D];
}
function parse_PtgRef3d(F, x, w) {
  var O = (F[F.l] & 96) >> 5;
  F.l += 1;
  var D = F.read_shift(2);
  w && w.biff == 5 && (F.l += 12);
  var U = parse_RgceLoc(F, 0, w);
  return [O, D, U];
}
function parse_PtgFunc(F, x, w) {
  var O = (F[F.l] & 96) >> 5;
  F.l += 1;
  var D = F.read_shift(w && w.biff <= 3 ? 1 : 2);
  return [FtabArgc[D], Ftab[D], O];
}
function parse_PtgFuncVar(F, x, w) {
  var O = F[F.l++], D = F.read_shift(1), U = w && w.biff <= 3 ? [O == 88 ? -1 : 0, F.read_shift(1)] : parsetab(F);
  return [D, (U[0] === 0 ? Ftab : Cetab)[U[1]]];
}
function parsetab(F) {
  return [F[F.l + 1] >> 7, F.read_shift(2) & 32767];
}
function parse_PtgAttrSum(F, x, w) {
  F.l += w && w.biff == 2 ? 3 : 4;
}
function parse_PtgExp(F, x, w) {
  if (F.l++, w && w.biff == 12) return [F.read_shift(4, "i"), 0];
  var O = F.read_shift(2), D = F.read_shift(w && w.biff == 2 ? 1 : 2);
  return [O, D];
}
function parse_PtgErr(F) {
  return F.l++, BErr[F.read_shift(1)];
}
function parse_PtgInt(F) {
  return F.l++, F.read_shift(2);
}
function parse_PtgBool(F) {
  return F.l++, F.read_shift(1) !== 0;
}
function parse_PtgNum(F) {
  return F.l++, parse_Xnum(F);
}
function parse_PtgStr(F, x, w) {
  return F.l++, parse_ShortXLUnicodeString(F, x - 1, w);
}
function parse_SerAr(F, x) {
  var w = [F.read_shift(1)];
  if (x == 12) switch (w[0]) {
    case 2:
      w[0] = 4;
      break;
    /* SerBool */
    case 4:
      w[0] = 16;
      break;
    /* SerErr */
    case 0:
      w[0] = 1;
      break;
    /* SerNum */
    case 1:
      w[0] = 2;
      break;
  }
  switch (w[0]) {
    case 4:
      w[1] = parsebool(F, 1) ? "TRUE" : "FALSE", x != 12 && (F.l += 7);
      break;
    case 37:
    /* appears to be an alias */
    case 16:
      w[1] = BErr[F[F.l]], F.l += x == 12 ? 4 : 8;
      break;
    case 0:
      F.l += 8;
      break;
    case 1:
      w[1] = parse_Xnum(F);
      break;
    case 2:
      w[1] = parse_XLUnicodeString2(F, 0, { biff: x > 0 && x < 8 ? 2 : x });
      break;
    default:
      throw new Error("Bad SerAr: " + w[0]);
  }
  return w;
}
function parse_PtgExtraMem(F, x, w) {
  for (var O = F.read_shift(w.biff == 12 ? 4 : 2), D = [], U = 0; U != O; ++U) D.push((w.biff == 12 ? parse_UncheckedRfX : parse_Ref8U)(F));
  return D;
}
function parse_PtgExtraArray(F, x, w) {
  var O = 0, D = 0;
  w.biff == 12 ? (O = F.read_shift(4), D = F.read_shift(4)) : (D = 1 + F.read_shift(1), O = 1 + F.read_shift(2)), w.biff >= 2 && w.biff < 8 && (--O, --D == 0 && (D = 256));
  for (var U = 0, W = []; U != O && (W[U] = []); ++U)
    for (var X = 0; X != D; ++X) W[U][X] = parse_SerAr(F, w.biff);
  return W;
}
function parse_PtgName(F, x, w) {
  var O = F.read_shift(1) >>> 5 & 3, D = !w || w.biff >= 8 ? 4 : 2, U = F.read_shift(D);
  switch (w.biff) {
    case 2:
      F.l += 5;
      break;
    case 3:
    case 4:
      F.l += 8;
      break;
    case 5:
      F.l += 12;
      break;
  }
  return [O, 0, U];
}
function parse_PtgNameX(F, x, w) {
  if (w.biff == 5) return parse_PtgNameX_BIFF5(F);
  var O = F.read_shift(1) >>> 5 & 3, D = F.read_shift(2), U = F.read_shift(4);
  return [O, D, U];
}
function parse_PtgNameX_BIFF5(F) {
  var x = F.read_shift(1) >>> 5 & 3, w = F.read_shift(2, "i");
  F.l += 8;
  var O = F.read_shift(2);
  return F.l += 12, [x, w, O];
}
function parse_PtgMemArea(F, x, w) {
  var O = F.read_shift(1) >>> 5 & 3;
  F.l += w && w.biff == 2 ? 3 : 4;
  var D = F.read_shift(w && w.biff == 2 ? 1 : 2);
  return [O, D];
}
function parse_PtgMemFunc(F, x, w) {
  var O = F.read_shift(1) >>> 5 & 3, D = F.read_shift(w && w.biff == 2 ? 1 : 2);
  return [O, D];
}
function parse_PtgRefErr(F, x, w) {
  var O = F.read_shift(1) >>> 5 & 3;
  return F.l += 4, w.biff < 8 && F.l--, w.biff == 12 && (F.l += 2), [O];
}
function parse_PtgRefErr3d(F, x, w) {
  var O = (F[F.l++] & 96) >> 5, D = F.read_shift(2), U = 4;
  if (w) switch (w.biff) {
    case 5:
      U = 15;
      break;
    case 12:
      U = 6;
      break;
  }
  return F.l += U, [O, D];
}
var parse_PtgMemErr = parsenoop, parse_PtgMemNoMem = parsenoop, parse_PtgTbl = parsenoop;
function parse_PtgElfLoc(F, x, w) {
  return F.l += 2, [parse_RgceElfLoc(F)];
}
function parse_PtgElfNoop(F) {
  return F.l += 6, [];
}
var parse_PtgElfCol = parse_PtgElfLoc, parse_PtgElfColS = parse_PtgElfNoop, parse_PtgElfColSV = parse_PtgElfNoop, parse_PtgElfColV = parse_PtgElfLoc;
function parse_PtgElfLel(F) {
  return F.l += 2, [parseuint16(F), F.read_shift(2) & 1];
}
var parse_PtgElfRadical = parse_PtgElfLoc, parse_PtgElfRadicalLel = parse_PtgElfLel, parse_PtgElfRadicalS = parse_PtgElfNoop, parse_PtgElfRw = parse_PtgElfLoc, parse_PtgElfRwV = parse_PtgElfLoc, PtgListRT = [
  "Data",
  "All",
  "Headers",
  "??",
  "?Data2",
  "??",
  "?DataHeaders",
  "??",
  "Totals",
  "??",
  "??",
  "??",
  "?DataTotals",
  "??",
  "??",
  "??",
  "?Current"
];
function parse_PtgList(F) {
  F.l += 2;
  var x = F.read_shift(2), w = F.read_shift(2), O = F.read_shift(4), D = F.read_shift(2), U = F.read_shift(2), W = PtgListRT[w >> 2 & 31];
  return { ixti: x, coltype: w & 3, rt: W, idx: O, c: D, C: U };
}
function parse_PtgSxName(F) {
  return F.l += 2, [F.read_shift(4)];
}
function parse_PtgSheet(F, x, w) {
  return F.l += 5, F.l += 2, F.l += w.biff == 2 ? 1 : 4, ["PTGSHEET"];
}
function parse_PtgEndSheet(F, x, w) {
  return F.l += w.biff == 2 ? 4 : 5, ["PTGENDSHEET"];
}
function parse_PtgMemAreaN(F) {
  var x = F.read_shift(1) >>> 5 & 3, w = F.read_shift(2);
  return [x, w];
}
function parse_PtgMemNoMemN(F) {
  var x = F.read_shift(1) >>> 5 & 3, w = F.read_shift(2);
  return [x, w];
}
function parse_PtgAttrNoop(F) {
  return F.l += 4, [0, 0];
}
var PtgTypes = {
  1: { n: "PtgExp", f: parse_PtgExp },
  2: { n: "PtgTbl", f: parse_PtgTbl },
  3: { n: "PtgAdd", f: parseread1 },
  4: { n: "PtgSub", f: parseread1 },
  5: { n: "PtgMul", f: parseread1 },
  6: { n: "PtgDiv", f: parseread1 },
  7: { n: "PtgPower", f: parseread1 },
  8: { n: "PtgConcat", f: parseread1 },
  9: { n: "PtgLt", f: parseread1 },
  10: { n: "PtgLe", f: parseread1 },
  11: { n: "PtgEq", f: parseread1 },
  12: { n: "PtgGe", f: parseread1 },
  13: { n: "PtgGt", f: parseread1 },
  14: { n: "PtgNe", f: parseread1 },
  15: { n: "PtgIsect", f: parseread1 },
  16: { n: "PtgUnion", f: parseread1 },
  17: { n: "PtgRange", f: parseread1 },
  18: { n: "PtgUplus", f: parseread1 },
  19: { n: "PtgUminus", f: parseread1 },
  20: { n: "PtgPercent", f: parseread1 },
  21: { n: "PtgParen", f: parseread1 },
  22: { n: "PtgMissArg", f: parseread1 },
  23: { n: "PtgStr", f: parse_PtgStr },
  26: { n: "PtgSheet", f: parse_PtgSheet },
  27: { n: "PtgEndSheet", f: parse_PtgEndSheet },
  28: { n: "PtgErr", f: parse_PtgErr },
  29: { n: "PtgBool", f: parse_PtgBool },
  30: { n: "PtgInt", f: parse_PtgInt },
  31: { n: "PtgNum", f: parse_PtgNum },
  32: { n: "PtgArray", f: parse_PtgArray },
  33: { n: "PtgFunc", f: parse_PtgFunc },
  34: { n: "PtgFuncVar", f: parse_PtgFuncVar },
  35: { n: "PtgName", f: parse_PtgName },
  36: { n: "PtgRef", f: parse_PtgRef },
  37: { n: "PtgArea", f: parse_PtgArea },
  38: { n: "PtgMemArea", f: parse_PtgMemArea },
  39: { n: "PtgMemErr", f: parse_PtgMemErr },
  40: { n: "PtgMemNoMem", f: parse_PtgMemNoMem },
  41: { n: "PtgMemFunc", f: parse_PtgMemFunc },
  42: { n: "PtgRefErr", f: parse_PtgRefErr },
  43: { n: "PtgAreaErr", f: parse_PtgAreaErr },
  44: { n: "PtgRefN", f: parse_PtgRefN },
  45: { n: "PtgAreaN", f: parse_PtgAreaN },
  46: { n: "PtgMemAreaN", f: parse_PtgMemAreaN },
  47: { n: "PtgMemNoMemN", f: parse_PtgMemNoMemN },
  57: { n: "PtgNameX", f: parse_PtgNameX },
  58: { n: "PtgRef3d", f: parse_PtgRef3d },
  59: { n: "PtgArea3d", f: parse_PtgArea3d },
  60: { n: "PtgRefErr3d", f: parse_PtgRefErr3d },
  61: { n: "PtgAreaErr3d", f: parse_PtgAreaErr3d },
  255: {}
}, PtgDupes = {
  64: 32,
  96: 32,
  65: 33,
  97: 33,
  66: 34,
  98: 34,
  67: 35,
  99: 35,
  68: 36,
  100: 36,
  69: 37,
  101: 37,
  70: 38,
  102: 38,
  71: 39,
  103: 39,
  72: 40,
  104: 40,
  73: 41,
  105: 41,
  74: 42,
  106: 42,
  75: 43,
  107: 43,
  76: 44,
  108: 44,
  77: 45,
  109: 45,
  78: 46,
  110: 46,
  79: 47,
  111: 47,
  88: 34,
  120: 34,
  89: 57,
  121: 57,
  90: 58,
  122: 58,
  91: 59,
  123: 59,
  92: 60,
  124: 60,
  93: 61,
  125: 61
}, Ptg18 = {
  1: { n: "PtgElfLel", f: parse_PtgElfLel },
  2: { n: "PtgElfRw", f: parse_PtgElfRw },
  3: { n: "PtgElfCol", f: parse_PtgElfCol },
  6: { n: "PtgElfRwV", f: parse_PtgElfRwV },
  7: { n: "PtgElfColV", f: parse_PtgElfColV },
  10: { n: "PtgElfRadical", f: parse_PtgElfRadical },
  11: { n: "PtgElfRadicalS", f: parse_PtgElfRadicalS },
  13: { n: "PtgElfColS", f: parse_PtgElfColS },
  15: { n: "PtgElfColSV", f: parse_PtgElfColSV },
  16: { n: "PtgElfRadicalLel", f: parse_PtgElfRadicalLel },
  25: { n: "PtgList", f: parse_PtgList },
  29: { n: "PtgSxName", f: parse_PtgSxName },
  255: {}
}, Ptg19 = {
  0: { n: "PtgAttrNoop", f: parse_PtgAttrNoop },
  1: { n: "PtgAttrSemi", f: parse_PtgAttrSemi },
  2: { n: "PtgAttrIf", f: parse_PtgAttrIf },
  4: { n: "PtgAttrChoose", f: parse_PtgAttrChoose },
  8: { n: "PtgAttrGoto", f: parse_PtgAttrGoto },
  16: { n: "PtgAttrSum", f: parse_PtgAttrSum },
  32: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  33: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  64: { n: "PtgAttrSpace", f: parse_PtgAttrSpace },
  65: { n: "PtgAttrSpaceSemi", f: parse_PtgAttrSpaceSemi },
  128: { n: "PtgAttrIfError", f: parse_PtgAttrIfError },
  255: {}
};
function parse_RgbExtra(F, x, w, O) {
  if (O.biff < 8) return parsenoop(F, x);
  for (var D = F.l + x, U = [], W = 0; W !== w.length; ++W)
    switch (w[W][0]) {
      case "PtgArray":
        w[W][1] = parse_PtgExtraArray(F, 0, O), U.push(w[W][1]);
        break;
      case "PtgMemArea":
        w[W][2] = parse_PtgExtraMem(F, w[W][1], O), U.push(w[W][2]);
        break;
      case "PtgExp":
        O && O.biff == 12 && (w[W][1][1] = F.read_shift(4), U.push(w[W][1]));
        break;
      case "PtgList":
      /* TODO: PtgList -> PtgExtraList */
      case "PtgElfRadicalS":
      /* TODO: PtgElfRadicalS -> PtgExtraElf */
      case "PtgElfColS":
      /* TODO: PtgElfColS -> PtgExtraElf */
      case "PtgElfColSV":
        throw "Unsupported " + w[W][0];
    }
  return x = D - F.l, x !== 0 && U.push(parsenoop(F, x)), U;
}
function parse_Rgce(F, x, w) {
  for (var O = F.l + x, D, U, W = []; O != F.l; )
    x = O - F.l, U = F[F.l], D = PtgTypes[U] || PtgTypes[PtgDupes[U]], (U === 24 || U === 25) && (D = (U === 24 ? Ptg18 : Ptg19)[F[F.l + 1]]), !D || !D.f ? parsenoop(F, x) : W.push([D.n, D.f(F, x, w)]);
  return W;
}
function stringify_array(F) {
  for (var x = [], w = 0; w < F.length; ++w) {
    for (var O = F[w], D = [], U = 0; U < O.length; ++U) {
      var W = O[U];
      if (W) switch (W[0]) {
        // TODO: handle embedded quotes
        case 2:
          D.push('"' + W[1].replace(/"/g, '""') + '"');
          break;
        default:
          D.push(W[1]);
      }
      else D.push("");
    }
    x.push(D.join(","));
  }
  return x.join(";");
}
var PtgBinOp = {
  PtgAdd: "+",
  PtgConcat: "&",
  PtgDiv: "/",
  PtgEq: "=",
  PtgGe: ">=",
  PtgGt: ">",
  PtgLe: "<=",
  PtgLt: "<",
  PtgMul: "*",
  PtgNe: "<>",
  PtgPower: "^",
  PtgSub: "-"
};
function make_3d_range(F, x) {
  var w = F.lastIndexOf("!"), O = x.lastIndexOf("!");
  return w == -1 && O == -1 ? F + ":" + x : w > 0 && O > 0 && F.slice(0, w).toLowerCase() == x.slice(0, O).toLowerCase() ? F + ":" + x.slice(O + 1) : (console.error("Cannot hydrate range", F, x), F + ":" + x);
}
function get_ixti_raw(F, x, w) {
  if (!F) return "SH33TJSERR0";
  if (w.biff > 8 && (!F.XTI || !F.XTI[x])) return F.SheetNames[x];
  if (!F.XTI) return "SH33TJSERR6";
  var O = F.XTI[x];
  if (w.biff < 8)
    return x > 1e4 && (x -= 65536), x < 0 && (x = -x), x == 0 ? "" : F.XTI[x - 1];
  if (!O) return "SH33TJSERR1";
  var D = "";
  if (w.biff > 8) switch (F[O[0]][0]) {
    case 357:
      return D = O[1] == -1 ? "#REF" : F.SheetNames[O[1]], O[1] == O[2] ? D : D + ":" + F.SheetNames[O[2]];
    case 358:
      return w.SID != null ? F.SheetNames[w.SID] : "SH33TJSSAME" + F[O[0]][0];
    case 355:
    /* 'BrtSupBookSrc' */
    /* falls through */
    default:
      return "SH33TJSSRC" + F[O[0]][0];
  }
  switch (F[O[0]][0][0]) {
    case 1025:
      return D = O[1] == -1 ? "#REF" : F.SheetNames[O[1]] || "SH33TJSERR3", O[1] == O[2] ? D : D + ":" + F.SheetNames[O[2]];
    case 14849:
      return F[O[0]].slice(1).map(function(U) {
        return U.Name;
      }).join(";;");
    //return "SH33TJSERR8";
    default:
      return F[O[0]][0][3] ? (D = O[1] == -1 ? "#REF" : F[O[0]][0][3][O[1]] || "SH33TJSERR4", O[1] == O[2] ? D : D + ":" + F[O[0]][0][3][O[2]]) : "SH33TJSERR2";
  }
}
function get_ixti(F, x, w) {
  var O = get_ixti_raw(F, x, w);
  return O == "#REF" ? O : formula_quote_sheet_name(O, w);
}
function stringify_formula(F, x, w, O, D) {
  var U = D && D.biff || 8, W = (
    /*range != null ? range :*/
    { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } }
  ), X = [], G, Y, K, Z = 0, q = 0, J, ee = "";
  if (!F[0] || !F[0][0]) return "";
  for (var re = -1, te = "", Q = 0, oe = F[0].length; Q < oe; ++Q) {
    var ne = F[0][Q];
    switch (ne[0]) {
      case "PtgUminus":
        X.push("-" + X.pop());
        break;
      case "PtgUplus":
        X.push("+" + X.pop());
        break;
      case "PtgPercent":
        X.push(X.pop() + "%");
        break;
      case "PtgAdd":
      /* [MS-XLS] 2.5.198.26 */
      case "PtgConcat":
      /* [MS-XLS] 2.5.198.43 */
      case "PtgDiv":
      /* [MS-XLS] 2.5.198.45 */
      case "PtgEq":
      /* [MS-XLS] 2.5.198.56 */
      case "PtgGe":
      /* [MS-XLS] 2.5.198.64 */
      case "PtgGt":
      /* [MS-XLS] 2.5.198.65 */
      case "PtgLe":
      /* [MS-XLS] 2.5.198.68 */
      case "PtgLt":
      /* [MS-XLS] 2.5.198.69 */
      case "PtgMul":
      /* [MS-XLS] 2.5.198.75 */
      case "PtgNe":
      /* [MS-XLS] 2.5.198.78 */
      case "PtgPower":
      /* [MS-XLS] 2.5.198.82 */
      case "PtgSub":
        if (G = X.pop(), Y = X.pop(), re >= 0) {
          switch (F[0][re][1][0]) {
            case 0:
              te = fill(" ", F[0][re][1][1]);
              break;
            case 1:
              te = fill("\r", F[0][re][1][1]);
              break;
            default:
              if (te = "", D.WTF) throw new Error("Unexpected PtgAttrSpaceType " + F[0][re][1][0]);
          }
          Y = Y + te, re = -1;
        }
        X.push(Y + PtgBinOp[ne[0]] + G);
        break;
      case "PtgIsect":
        G = X.pop(), Y = X.pop(), X.push(Y + " " + G);
        break;
      case "PtgUnion":
        G = X.pop(), Y = X.pop(), X.push(Y + "," + G);
        break;
      case "PtgRange":
        G = X.pop(), Y = X.pop(), X.push(make_3d_range(Y, G));
        break;
      case "PtgAttrChoose":
        break;
      case "PtgAttrGoto":
        break;
      case "PtgAttrIf":
        break;
      case "PtgAttrIfError":
        break;
      case "PtgRef":
        K = shift_cell_xls(ne[1][1], W, D), X.push(encode_cell_xls(K, U));
        break;
      case "PtgRefN":
        K = w ? shift_cell_xls(ne[1][1], w, D) : ne[1][1], X.push(encode_cell_xls(K, U));
        break;
      case "PtgRef3d":
        Z = /*::Number(*/
        ne[1][1], K = shift_cell_xls(ne[1][2], W, D), ee = get_ixti(O, Z, D), X.push(ee + "!" + encode_cell_xls(K, U));
        break;
      case "PtgFunc":
      /* [MS-XLS] 2.5.198.62 */
      case "PtgFuncVar":
        var le = ne[1][0], Ee = ne[1][1];
        le || (le = 0), le &= 127;
        var Te = le == 0 ? [] : X.slice(-le);
        X.length -= le, Ee === "User" && (Ee = Te.shift()), X.push(Ee + "(" + Te.join(",") + ")");
        break;
      case "PtgBool":
        X.push(ne[1] ? "TRUE" : "FALSE");
        break;
      case "PtgInt":
        X.push(
          /*::String(*/
          ne[1]
          /*::)*/
        );
        break;
      case "PtgNum":
        X.push(String(ne[1]));
        break;
      case "PtgStr":
        X.push('"' + ne[1].replace(/"/g, '""') + '"');
        break;
      case "PtgErr":
        X.push(
          /*::String(*/
          ne[1]
          /*::)*/
        );
        break;
      case "PtgAreaN":
        J = shift_range_xls(ne[1][1], w ? { s: w } : W, D), X.push(encode_range_xls(J, D));
        break;
      case "PtgArea":
        J = shift_range_xls(ne[1][1], W, D), X.push(encode_range_xls(J, D));
        break;
      case "PtgArea3d":
        Z = /*::Number(*/
        ne[1][1], J = ne[1][2], ee = get_ixti(O, Z, D), X.push(ee + "!" + encode_range_xls(J, D));
        break;
      case "PtgAttrSum":
        X.push("SUM(" + X.pop() + ")");
        break;
      case "PtgAttrBaxcel":
      /* [MS-XLS] 2.5.198.33 */
      case "PtgAttrSemi":
        break;
      case "PtgName":
        q = ne[1][2];
        var de = (O.names || [])[q - 1] || (O[0] || [])[q], ae = de ? de.Name : "SH33TJSNAME" + String(q);
        ae && ae.slice(0, 6) == "_xlfn." && !D.xlfn && (ae = ae.slice(6)), X.push(ae);
        break;
      case "PtgNameX":
        var se = ne[1][1];
        q = ne[1][2];
        var ce;
        if (D.biff <= 5)
          se < 0 && (se = -se), O[se] && (ce = O[se][q]);
        else {
          var xe = "";
          if (((O[se] || [])[0] || [])[0] == 14849 || (((O[se] || [])[0] || [])[0] == 1025 ? O[se][q] && O[se][q].itab > 0 && (xe = O.SheetNames[O[se][q].itab - 1] + "!") : xe = O.SheetNames[q - 1] + "!"), O[se] && O[se][q]) xe += O[se][q].Name;
          else if (O[0] && O[0][q]) xe += O[0][q].Name;
          else {
            var Ce = (get_ixti_raw(O, se, D) || "").split(";;");
            Ce[q - 1] ? xe = Ce[q - 1] : xe += "SH33TJSERRX";
          }
          X.push(xe);
          break;
        }
        ce || (ce = { Name: "SH33TJSERRY" }), X.push(ce.Name);
        break;
      case "PtgParen":
        var ye = "(", ze = ")";
        if (re >= 0) {
          switch (te = "", F[0][re][1][0]) {
            // $FlowIgnore
            case 2:
              ye = fill(" ", F[0][re][1][1]) + ye;
              break;
            // $FlowIgnore
            case 3:
              ye = fill("\r", F[0][re][1][1]) + ye;
              break;
            // $FlowIgnore
            case 4:
              ze = fill(" ", F[0][re][1][1]) + ze;
              break;
            // $FlowIgnore
            case 5:
              ze = fill("\r", F[0][re][1][1]) + ze;
              break;
            default:
              if (D.WTF) throw new Error("Unexpected PtgAttrSpaceType " + F[0][re][1][0]);
          }
          re = -1;
        }
        X.push(ye + X.pop() + ze);
        break;
      case "PtgRefErr":
        X.push("#REF!");
        break;
      case "PtgRefErr3d":
        X.push("#REF!");
        break;
      case "PtgExp":
        K = { c: ne[1][1], r: ne[1][0] };
        var De = { c: w.c, r: w.r };
        if (O.sharedf[encode_cell(K)]) {
          var et = O.sharedf[encode_cell(K)];
          X.push(stringify_formula(et, W, De, O, D));
        } else {
          var Oe = !1;
          for (G = 0; G != O.arrayf.length; ++G)
            if (Y = O.arrayf[G], !(K.c < Y[0].s.c || K.c > Y[0].e.c) && !(K.r < Y[0].s.r || K.r > Y[0].e.r)) {
              X.push(stringify_formula(Y[1], W, De, O, D)), Oe = !0;
              break;
            }
          Oe || X.push(
            /*::String(*/
            ne[1]
            /*::)*/
          );
        }
        break;
      case "PtgArray":
        X.push("{" + stringify_array(
          /*::(*/
          ne[1]
          /*:: :any)*/
        ) + "}");
        break;
      case "PtgMemArea":
        break;
      case "PtgAttrSpace":
      /* [MS-XLS] 2.5.198.38 */
      case "PtgAttrSpaceSemi":
        re = Q;
        break;
      case "PtgTbl":
        break;
      case "PtgMemErr":
        break;
      case "PtgMissArg":
        X.push("");
        break;
      case "PtgAreaErr":
        X.push("#REF!");
        break;
      case "PtgAreaErr3d":
        X.push("#REF!");
        break;
      case "PtgList":
        X.push("Table" + ne[1].idx + "[#" + ne[1].rt + "]");
        break;
      case "PtgMemAreaN":
      case "PtgMemNoMemN":
      case "PtgAttrNoop":
      case "PtgSheet":
      case "PtgEndSheet":
        break;
      case "PtgMemFunc":
        break;
      case "PtgMemNoMem":
        break;
      case "PtgElfCol":
      /* [MS-XLS] 2.5.198.46 */
      case "PtgElfColS":
      /* [MS-XLS] 2.5.198.47 */
      case "PtgElfColSV":
      /* [MS-XLS] 2.5.198.48 */
      case "PtgElfColV":
      /* [MS-XLS] 2.5.198.49 */
      case "PtgElfLel":
      /* [MS-XLS] 2.5.198.50 */
      case "PtgElfRadical":
      /* [MS-XLS] 2.5.198.51 */
      case "PtgElfRadicalLel":
      /* [MS-XLS] 2.5.198.52 */
      case "PtgElfRadicalS":
      /* [MS-XLS] 2.5.198.53 */
      case "PtgElfRw":
      /* [MS-XLS] 2.5.198.54 */
      case "PtgElfRwV":
        throw new Error("Unsupported ELFs");
      case "PtgSxName":
        throw new Error("Unrecognized Formula Token: " + String(ne));
      default:
        throw new Error("Unrecognized Formula Token: " + String(ne));
    }
    var Xe = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
    if (D.biff != 3 && re >= 0 && Xe.indexOf(F[0][Q][0]) == -1) {
      ne = F[0][re];
      var He = !0;
      switch (ne[1][0]) {
        /* note: some bad XLSB files omit the PtgParen */
        case 4:
          He = !1;
        /* falls through */
        case 0:
          te = fill(" ", ne[1][1]);
          break;
        case 5:
          He = !1;
        /* falls through */
        case 1:
          te = fill("\r", ne[1][1]);
          break;
        default:
          if (te = "", D.WTF) throw new Error("Unexpected PtgAttrSpaceType " + ne[1][0]);
      }
      X.push((He ? te : "") + X.pop() + (He ? "" : te)), re = -1;
    }
  }
  if (X.length > 1 && D.WTF) throw new Error("bad formula stack");
  return X[0] == "TRUE" ? !0 : X[0] == "FALSE" ? !1 : X[0];
}
function parse_ArrayParsedFormula(F, x, w) {
  var O = F.l + x, D = w.biff == 2 ? 1 : 2, U, W = F.read_shift(D);
  if (W == 65535) return [[], parsenoop(F, x - 2)];
  var X = parse_Rgce(F, W, w);
  return x !== W + D && (U = parse_RgbExtra(F, x - W - D, X, w)), F.l = O, [X, U];
}
function parse_XLSCellParsedFormula(F, x, w) {
  var O = F.l + x, D = w.biff == 2 ? 1 : 2, U, W = F.read_shift(D);
  if (W == 65535) return [[], parsenoop(F, x - 2)];
  var X = parse_Rgce(F, W, w);
  return x !== W + D && (U = parse_RgbExtra(F, x - W - D, X, w)), F.l = O, [X, U];
}
function parse_NameParsedFormula(F, x, w, O) {
  var D = F.l + x, U = parse_Rgce(F, O, w), W;
  return D !== F.l && (W = parse_RgbExtra(F, D - F.l, U, w)), [U, W];
}
function parse_SharedParsedFormula(F, x, w) {
  var O = F.l + x, D, U = F.read_shift(2), W = parse_Rgce(F, U, w);
  return U == 65535 ? [[], parsenoop(F, x - 2)] : (x !== U + 2 && (D = parse_RgbExtra(F, O - U - 2, W, w)), [W, D]);
}
function parse_FormulaValue(F) {
  var x;
  if (__readUInt16LE(F, F.l + 6) !== 65535) return [parse_Xnum(F), "n"];
  switch (F[F.l]) {
    case 0:
      return F.l += 8, ["String", "s"];
    case 1:
      return x = F[F.l + 2] === 1, F.l += 8, [x, "b"];
    case 2:
      return x = F[F.l + 2], F.l += 8, [x, "e"];
    case 3:
      return F.l += 8, ["", "s"];
  }
  return [];
}
function write_FormulaValue(F) {
  if (F == null) {
    var x = new_buf(8);
    return x.write_shift(1, 3), x.write_shift(1, 0), x.write_shift(2, 0), x.write_shift(2, 0), x.write_shift(2, 65535), x;
  } else if (typeof F == "number") return write_Xnum(F);
  return write_Xnum(0);
}
function parse_Formula(F, x, w) {
  var O = F.l + x, D = parse_XLSCell(F, 6, w), U = parse_FormulaValue(F), W = F.read_shift(1);
  w.biff != 2 && (F.read_shift(1), w.biff >= 5 && F.read_shift(4));
  var X = parse_XLSCellParsedFormula(F, O - F.l, w);
  return { cell: D, val: U[0], formula: X, shared: W >> 3 & 1, tt: U[1] };
}
function write_Formula(F, x, w, O, D) {
  var U = write_XLSCell(x, w, D), W = write_FormulaValue(F.v), X = new_buf(6), G = 33;
  X.write_shift(2, G), X.write_shift(4, 0);
  for (var Y = new_buf(F.bf.length), K = 0; K < F.bf.length; ++K) Y[K] = F.bf[K];
  var Z = bconcat([U, W, X, Y]);
  return Z;
}
function parse_XLSBParsedFormula(F, x, w) {
  var O = F.read_shift(4), D = parse_Rgce(F, O, w), U = F.read_shift(4), W = U > 0 ? parse_RgbExtra(F, U, D, w) : null;
  return [D, W];
}
var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula, parse_XLSBCellParsedFormula = parse_XLSBParsedFormula, parse_XLSBNameParsedFormula = parse_XLSBParsedFormula, parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
function write_XLSBFormulaNum(F) {
  if ((F | 0) == F && F < Math.pow(2, 16) && F >= 0) {
    var x = new_buf(11);
    return x.write_shift(4, 3), x.write_shift(1, 30), x.write_shift(2, F), x.write_shift(4, 0), x;
  }
  var w = new_buf(17);
  return w.write_shift(4, 11), w.write_shift(1, 31), w.write_shift(8, F), w.write_shift(4, 0), w;
}
function write_XLSBFormulaErr(F) {
  var x = new_buf(10);
  return x.write_shift(4, 2), x.write_shift(1, 28), x.write_shift(1, F), x.write_shift(4, 0), x;
}
function write_XLSBFormulaBool(F) {
  var x = new_buf(10);
  return x.write_shift(4, 2), x.write_shift(1, 29), x.write_shift(1, F ? 1 : 0), x.write_shift(4, 0), x;
}
function write_XLSBFormulaStr(F) {
  var x = new_buf(7);
  x.write_shift(4, 3 + 2 * F.length), x.write_shift(1, 23), x.write_shift(2, F.length);
  var w = new_buf(2 * F.length);
  w.write_shift(2 * F.length, F, "utf16le");
  var O = new_buf(4);
  return O.write_shift(4, 0), bconcat([x, w, O]);
}
function write_XLSBFormulaRef(F) {
  var x = decode_cell(F), w = new_buf(15);
  return w.write_shift(4, 7), w.write_shift(1, 36), w.write_shift(4, x.r), w.write_shift(2, x.c | (F.charAt(0) == "$" ? 0 : 1) << 14 | (F.match(/\$\d/) ? 0 : 1) << 15), w.write_shift(4, 0), w;
}
function write_XLSBFormulaRef3D(F, x) {
  var w = F.lastIndexOf("!"), O = F.slice(0, w);
  F = F.slice(w + 1);
  var D = decode_cell(F);
  O.charAt(0) == "'" && (O = O.slice(1, -1).replace(/''/g, "'"));
  var U = new_buf(17);
  return U.write_shift(4, 9), U.write_shift(1, 58), U.write_shift(2, 2 + x.SheetNames.map(function(W) {
    return W.toLowerCase();
  }).indexOf(O.toLowerCase())), U.write_shift(4, D.r), U.write_shift(2, D.c | (F.charAt(0) == "$" ? 0 : 1) << 14 | (F.match(/\$\d/) ? 0 : 1) << 15), U.write_shift(4, 0), U;
}
function write_XLSBFormulaRefErr3D(F, x) {
  var w = F.lastIndexOf("!"), O = F.slice(0, w);
  F = F.slice(w + 1), O.charAt(0) == "'" && (O = O.slice(1, -1).replace(/''/g, "'"));
  var D = new_buf(17);
  return D.write_shift(4, 9), D.write_shift(1, 60), D.write_shift(2, 2 + x.SheetNames.map(function(U) {
    return U.toLowerCase();
  }).indexOf(O.toLowerCase())), D.write_shift(4, 0), D.write_shift(2, 0), D.write_shift(4, 0), D;
}
function write_XLSBFormulaRange(F) {
  var x = F.split(":"), w = x[0], O = new_buf(23);
  O.write_shift(4, 15), w = x[0];
  var D = decode_cell(w);
  return O.write_shift(1, 36), O.write_shift(4, D.r), O.write_shift(2, D.c | (w.charAt(0) == "$" ? 0 : 1) << 14 | (w.match(/\$\d/) ? 0 : 1) << 15), O.write_shift(4, 0), w = x[1], D = decode_cell(w), O.write_shift(1, 36), O.write_shift(4, D.r), O.write_shift(2, D.c | (w.charAt(0) == "$" ? 0 : 1) << 14 | (w.match(/\$\d/) ? 0 : 1) << 15), O.write_shift(4, 0), O.write_shift(1, 17), O.write_shift(4, 0), O;
}
function write_XLSBFormulaRangeWS(F, x) {
  var w = F.lastIndexOf("!"), O = F.slice(0, w);
  F = F.slice(w + 1), O.charAt(0) == "'" && (O = O.slice(1, -1).replace(/''/g, "'"));
  var D = F.split(":"), U = new_buf(27);
  U.write_shift(4, 19);
  var W = D[0], X = decode_cell(W);
  return U.write_shift(1, 58), U.write_shift(2, 2 + x.SheetNames.map(function(G) {
    return G.toLowerCase();
  }).indexOf(O.toLowerCase())), U.write_shift(4, X.r), U.write_shift(2, X.c | (W.charAt(0) == "$" ? 0 : 1) << 14 | (W.match(/\$\d/) ? 0 : 1) << 15), W = D[1], X = decode_cell(W), U.write_shift(1, 58), U.write_shift(2, 2 + x.SheetNames.map(function(G) {
    return G.toLowerCase();
  }).indexOf(O.toLowerCase())), U.write_shift(4, X.r), U.write_shift(2, X.c | (W.charAt(0) == "$" ? 0 : 1) << 14 | (W.match(/\$\d/) ? 0 : 1) << 15), U.write_shift(1, 17), U.write_shift(4, 0), U;
}
function write_XLSBFormulaArea3D(F, x) {
  var w = F.lastIndexOf("!"), O = F.slice(0, w);
  F = F.slice(w + 1), O.charAt(0) == "'" && (O = O.slice(1, -1).replace(/''/g, "'"));
  var D = decode_range(F), U = new_buf(23);
  return U.write_shift(4, 15), U.write_shift(1, 59), U.write_shift(2, 2 + x.SheetNames.map(function(W) {
    return W.toLowerCase();
  }).indexOf(O.toLowerCase())), U.write_shift(4, D.s.r), U.write_shift(4, D.e.r), U.write_shift(2, D.s.c), U.write_shift(2, D.e.c), U.write_shift(4, 0), U;
}
function write_XLSBFormula(F, x) {
  if (typeof F == "number") return write_XLSBFormulaNum(F);
  if (typeof F == "boolean") return write_XLSBFormulaBool(F);
  if (/^#(DIV\/0!|GETTING_DATA|N\/A|NAME\?|NULL!|NUM!|REF!|VALUE!)$/.test(F)) return write_XLSBFormulaErr(+RBErr[F]);
  if (F.match(/^\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRef(F);
  if (F.match(/^\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRange(F);
  if (F.match(/^#REF!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaArea3D(F, x);
  if (F.match(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,<.>]*)!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRef3D(F, x);
  if (F.match(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,<.>]*)!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRangeWS(F, x);
  if (/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,<.>]*)!#REF!$/.test(F)) return write_XLSBFormulaRefErr3D(F, x);
  if (/^".*"$/.test(F)) return write_XLSBFormulaStr(F);
  if (/^[+-]\d+$/.test(F)) return write_XLSBFormulaNum(parseInt(F, 10));
  throw "Formula |" + F + "| not supported for XLSB";
}
var write_XLSBNameParsedFormula = write_XLSBFormula, Cetab = {
  0: "BEEP",
  1: "OPEN",
  2: "OPEN.LINKS",
  3: "CLOSE.ALL",
  4: "SAVE",
  5: "SAVE.AS",
  6: "FILE.DELETE",
  7: "PAGE.SETUP",
  8: "PRINT",
  9: "PRINTER.SETUP",
  10: "QUIT",
  11: "NEW.WINDOW",
  12: "ARRANGE.ALL",
  13: "WINDOW.SIZE",
  14: "WINDOW.MOVE",
  15: "FULL",
  16: "CLOSE",
  17: "RUN",
  22: "SET.PRINT.AREA",
  23: "SET.PRINT.TITLES",
  24: "SET.PAGE.BREAK",
  25: "REMOVE.PAGE.BREAK",
  26: "FONT",
  27: "DISPLAY",
  28: "PROTECT.DOCUMENT",
  29: "PRECISION",
  30: "A1.R1C1",
  31: "CALCULATE.NOW",
  32: "CALCULATION",
  34: "DATA.FIND",
  35: "EXTRACT",
  36: "DATA.DELETE",
  37: "SET.DATABASE",
  38: "SET.CRITERIA",
  39: "SORT",
  40: "DATA.SERIES",
  41: "TABLE",
  42: "FORMAT.NUMBER",
  43: "ALIGNMENT",
  44: "STYLE",
  45: "BORDER",
  46: "CELL.PROTECTION",
  47: "COLUMN.WIDTH",
  48: "UNDO",
  49: "CUT",
  50: "COPY",
  51: "PASTE",
  52: "CLEAR",
  53: "PASTE.SPECIAL",
  54: "EDIT.DELETE",
  55: "INSERT",
  56: "FILL.RIGHT",
  57: "FILL.DOWN",
  61: "DEFINE.NAME",
  62: "CREATE.NAMES",
  63: "FORMULA.GOTO",
  64: "FORMULA.FIND",
  65: "SELECT.LAST.CELL",
  66: "SHOW.ACTIVE.CELL",
  67: "GALLERY.AREA",
  68: "GALLERY.BAR",
  69: "GALLERY.COLUMN",
  70: "GALLERY.LINE",
  71: "GALLERY.PIE",
  72: "GALLERY.SCATTER",
  73: "COMBINATION",
  74: "PREFERRED",
  75: "ADD.OVERLAY",
  76: "GRIDLINES",
  77: "SET.PREFERRED",
  78: "AXES",
  79: "LEGEND",
  80: "ATTACH.TEXT",
  81: "ADD.ARROW",
  82: "SELECT.CHART",
  83: "SELECT.PLOT.AREA",
  84: "PATTERNS",
  85: "MAIN.CHART",
  86: "OVERLAY",
  87: "SCALE",
  88: "FORMAT.LEGEND",
  89: "FORMAT.TEXT",
  90: "EDIT.REPEAT",
  91: "PARSE",
  92: "JUSTIFY",
  93: "HIDE",
  94: "UNHIDE",
  95: "WORKSPACE",
  96: "FORMULA",
  97: "FORMULA.FILL",
  98: "FORMULA.ARRAY",
  99: "DATA.FIND.NEXT",
  100: "DATA.FIND.PREV",
  101: "FORMULA.FIND.NEXT",
  102: "FORMULA.FIND.PREV",
  103: "ACTIVATE",
  104: "ACTIVATE.NEXT",
  105: "ACTIVATE.PREV",
  106: "UNLOCKED.NEXT",
  107: "UNLOCKED.PREV",
  108: "COPY.PICTURE",
  109: "SELECT",
  110: "DELETE.NAME",
  111: "DELETE.FORMAT",
  112: "VLINE",
  113: "HLINE",
  114: "VPAGE",
  115: "HPAGE",
  116: "VSCROLL",
  117: "HSCROLL",
  118: "ALERT",
  119: "NEW",
  120: "CANCEL.COPY",
  121: "SHOW.CLIPBOARD",
  122: "MESSAGE",
  124: "PASTE.LINK",
  125: "APP.ACTIVATE",
  126: "DELETE.ARROW",
  127: "ROW.HEIGHT",
  128: "FORMAT.MOVE",
  129: "FORMAT.SIZE",
  130: "FORMULA.REPLACE",
  131: "SEND.KEYS",
  132: "SELECT.SPECIAL",
  133: "APPLY.NAMES",
  134: "REPLACE.FONT",
  135: "FREEZE.PANES",
  136: "SHOW.INFO",
  137: "SPLIT",
  138: "ON.WINDOW",
  139: "ON.DATA",
  140: "DISABLE.INPUT",
  142: "OUTLINE",
  143: "LIST.NAMES",
  144: "FILE.CLOSE",
  145: "SAVE.WORKBOOK",
  146: "DATA.FORM",
  147: "COPY.CHART",
  148: "ON.TIME",
  149: "WAIT",
  150: "FORMAT.FONT",
  151: "FILL.UP",
  152: "FILL.LEFT",
  153: "DELETE.OVERLAY",
  155: "SHORT.MENUS",
  159: "SET.UPDATE.STATUS",
  161: "COLOR.PALETTE",
  162: "DELETE.STYLE",
  163: "WINDOW.RESTORE",
  164: "WINDOW.MAXIMIZE",
  166: "CHANGE.LINK",
  167: "CALCULATE.DOCUMENT",
  168: "ON.KEY",
  169: "APP.RESTORE",
  170: "APP.MOVE",
  171: "APP.SIZE",
  172: "APP.MINIMIZE",
  173: "APP.MAXIMIZE",
  174: "BRING.TO.FRONT",
  175: "SEND.TO.BACK",
  185: "MAIN.CHART.TYPE",
  186: "OVERLAY.CHART.TYPE",
  187: "SELECT.END",
  188: "OPEN.MAIL",
  189: "SEND.MAIL",
  190: "STANDARD.FONT",
  191: "CONSOLIDATE",
  192: "SORT.SPECIAL",
  193: "GALLERY.3D.AREA",
  194: "GALLERY.3D.COLUMN",
  195: "GALLERY.3D.LINE",
  196: "GALLERY.3D.PIE",
  197: "VIEW.3D",
  198: "GOAL.SEEK",
  199: "WORKGROUP",
  200: "FILL.GROUP",
  201: "UPDATE.LINK",
  202: "PROMOTE",
  203: "DEMOTE",
  204: "SHOW.DETAIL",
  206: "UNGROUP",
  207: "OBJECT.PROPERTIES",
  208: "SAVE.NEW.OBJECT",
  209: "SHARE",
  210: "SHARE.NAME",
  211: "DUPLICATE",
  212: "APPLY.STYLE",
  213: "ASSIGN.TO.OBJECT",
  214: "OBJECT.PROTECTION",
  215: "HIDE.OBJECT",
  216: "SET.EXTRACT",
  217: "CREATE.PUBLISHER",
  218: "SUBSCRIBE.TO",
  219: "ATTRIBUTES",
  220: "SHOW.TOOLBAR",
  222: "PRINT.PREVIEW",
  223: "EDIT.COLOR",
  224: "SHOW.LEVELS",
  225: "FORMAT.MAIN",
  226: "FORMAT.OVERLAY",
  227: "ON.RECALC",
  228: "EDIT.SERIES",
  229: "DEFINE.STYLE",
  240: "LINE.PRINT",
  243: "ENTER.DATA",
  249: "GALLERY.RADAR",
  250: "MERGE.STYLES",
  251: "EDITION.OPTIONS",
  252: "PASTE.PICTURE",
  253: "PASTE.PICTURE.LINK",
  254: "SPELLING",
  256: "ZOOM",
  259: "INSERT.OBJECT",
  260: "WINDOW.MINIMIZE",
  265: "SOUND.NOTE",
  266: "SOUND.PLAY",
  267: "FORMAT.SHAPE",
  268: "EXTEND.POLYGON",
  269: "FORMAT.AUTO",
  272: "GALLERY.3D.BAR",
  273: "GALLERY.3D.SURFACE",
  274: "FILL.AUTO",
  276: "CUSTOMIZE.TOOLBAR",
  277: "ADD.TOOL",
  278: "EDIT.OBJECT",
  279: "ON.DOUBLECLICK",
  280: "ON.ENTRY",
  281: "WORKBOOK.ADD",
  282: "WORKBOOK.MOVE",
  283: "WORKBOOK.COPY",
  284: "WORKBOOK.OPTIONS",
  285: "SAVE.WORKSPACE",
  288: "CHART.WIZARD",
  289: "DELETE.TOOL",
  290: "MOVE.TOOL",
  291: "WORKBOOK.SELECT",
  292: "WORKBOOK.ACTIVATE",
  293: "ASSIGN.TO.TOOL",
  295: "COPY.TOOL",
  296: "RESET.TOOL",
  297: "CONSTRAIN.NUMERIC",
  298: "PASTE.TOOL",
  302: "WORKBOOK.NEW",
  305: "SCENARIO.CELLS",
  306: "SCENARIO.DELETE",
  307: "SCENARIO.ADD",
  308: "SCENARIO.EDIT",
  309: "SCENARIO.SHOW",
  310: "SCENARIO.SHOW.NEXT",
  311: "SCENARIO.SUMMARY",
  312: "PIVOT.TABLE.WIZARD",
  313: "PIVOT.FIELD.PROPERTIES",
  314: "PIVOT.FIELD",
  315: "PIVOT.ITEM",
  316: "PIVOT.ADD.FIELDS",
  318: "OPTIONS.CALCULATION",
  319: "OPTIONS.EDIT",
  320: "OPTIONS.VIEW",
  321: "ADDIN.MANAGER",
  322: "MENU.EDITOR",
  323: "ATTACH.TOOLBARS",
  324: "VBAActivate",
  325: "OPTIONS.CHART",
  328: "VBA.INSERT.FILE",
  330: "VBA.PROCEDURE.DEFINITION",
  336: "ROUTING.SLIP",
  338: "ROUTE.DOCUMENT",
  339: "MAIL.LOGON",
  342: "INSERT.PICTURE",
  343: "EDIT.TOOL",
  344: "GALLERY.DOUGHNUT",
  350: "CHART.TREND",
  352: "PIVOT.ITEM.PROPERTIES",
  354: "WORKBOOK.INSERT",
  355: "OPTIONS.TRANSITION",
  356: "OPTIONS.GENERAL",
  370: "FILTER.ADVANCED",
  373: "MAIL.ADD.MAILER",
  374: "MAIL.DELETE.MAILER",
  375: "MAIL.REPLY",
  376: "MAIL.REPLY.ALL",
  377: "MAIL.FORWARD",
  378: "MAIL.NEXT.LETTER",
  379: "DATA.LABEL",
  380: "INSERT.TITLE",
  381: "FONT.PROPERTIES",
  382: "MACRO.OPTIONS",
  383: "WORKBOOK.HIDE",
  384: "WORKBOOK.UNHIDE",
  385: "WORKBOOK.DELETE",
  386: "WORKBOOK.NAME",
  388: "GALLERY.CUSTOM",
  390: "ADD.CHART.AUTOFORMAT",
  391: "DELETE.CHART.AUTOFORMAT",
  392: "CHART.ADD.DATA",
  393: "AUTO.OUTLINE",
  394: "TAB.ORDER",
  395: "SHOW.DIALOG",
  396: "SELECT.ALL",
  397: "UNGROUP.SHEETS",
  398: "SUBTOTAL.CREATE",
  399: "SUBTOTAL.REMOVE",
  400: "RENAME.OBJECT",
  412: "WORKBOOK.SCROLL",
  413: "WORKBOOK.NEXT",
  414: "WORKBOOK.PREV",
  415: "WORKBOOK.TAB.SPLIT",
  416: "FULL.SCREEN",
  417: "WORKBOOK.PROTECT",
  420: "SCROLLBAR.PROPERTIES",
  421: "PIVOT.SHOW.PAGES",
  422: "TEXT.TO.COLUMNS",
  423: "FORMAT.CHARTTYPE",
  424: "LINK.FORMAT",
  425: "TRACER.DISPLAY",
  430: "TRACER.NAVIGATE",
  431: "TRACER.CLEAR",
  432: "TRACER.ERROR",
  433: "PIVOT.FIELD.GROUP",
  434: "PIVOT.FIELD.UNGROUP",
  435: "CHECKBOX.PROPERTIES",
  436: "LABEL.PROPERTIES",
  437: "LISTBOX.PROPERTIES",
  438: "EDITBOX.PROPERTIES",
  439: "PIVOT.REFRESH",
  440: "LINK.COMBO",
  441: "OPEN.TEXT",
  442: "HIDE.DIALOG",
  443: "SET.DIALOG.FOCUS",
  444: "ENABLE.OBJECT",
  445: "PUSHBUTTON.PROPERTIES",
  446: "SET.DIALOG.DEFAULT",
  447: "FILTER",
  448: "FILTER.SHOW.ALL",
  449: "CLEAR.OUTLINE",
  450: "FUNCTION.WIZARD",
  451: "ADD.LIST.ITEM",
  452: "SET.LIST.ITEM",
  453: "REMOVE.LIST.ITEM",
  454: "SELECT.LIST.ITEM",
  455: "SET.CONTROL.VALUE",
  456: "SAVE.COPY.AS",
  458: "OPTIONS.LISTS.ADD",
  459: "OPTIONS.LISTS.DELETE",
  460: "SERIES.AXES",
  461: "SERIES.X",
  462: "SERIES.Y",
  463: "ERRORBAR.X",
  464: "ERRORBAR.Y",
  465: "FORMAT.CHART",
  466: "SERIES.ORDER",
  467: "MAIL.LOGOFF",
  468: "CLEAR.ROUTING.SLIP",
  469: "APP.ACTIVATE.MICROSOFT",
  470: "MAIL.EDIT.MAILER",
  471: "ON.SHEET",
  472: "STANDARD.WIDTH",
  473: "SCENARIO.MERGE",
  474: "SUMMARY.INFO",
  475: "FIND.FILE",
  476: "ACTIVE.CELL.FONT",
  477: "ENABLE.TIPWIZARD",
  478: "VBA.MAKE.ADDIN",
  480: "INSERTDATATABLE",
  481: "WORKGROUP.OPTIONS",
  482: "MAIL.SEND.MAILER",
  485: "AUTOCORRECT",
  489: "POST.DOCUMENT",
  491: "PICKLIST",
  493: "VIEW.SHOW",
  494: "VIEW.DEFINE",
  495: "VIEW.DELETE",
  509: "SHEET.BACKGROUND",
  510: "INSERT.MAP.OBJECT",
  511: "OPTIONS.MENONO",
  517: "MSOCHECKS",
  518: "NORMAL",
  519: "LAYOUT",
  520: "RM.PRINT.AREA",
  521: "CLEAR.PRINT.AREA",
  522: "ADD.PRINT.AREA",
  523: "MOVE.BRK",
  545: "HIDECURR.NOTE",
  546: "HIDEALL.NOTES",
  547: "DELETE.NOTE",
  548: "TRAVERSE.NOTES",
  549: "ACTIVATE.NOTES",
  620: "PROTECT.REVISIONS",
  621: "UNPROTECT.REVISIONS",
  647: "OPTIONS.ME",
  653: "WEB.PUBLISH",
  667: "NEWWEBQUERY",
  673: "PIVOT.TABLE.CHART",
  753: "OPTIONS.SAVE",
  755: "OPTIONS.SPELL",
  808: "HIDEALL.INKANNOTS"
}, Ftab = {
  0: "COUNT",
  1: "IF",
  2: "ISNA",
  3: "ISERROR",
  4: "SUM",
  5: "AVERAGE",
  6: "MIN",
  7: "MAX",
  8: "ROW",
  9: "COLUMN",
  10: "NA",
  11: "NPV",
  12: "STDEV",
  13: "DOLLAR",
  14: "FIXED",
  15: "SIN",
  16: "COS",
  17: "TAN",
  18: "ATAN",
  19: "PI",
  20: "SQRT",
  21: "EXP",
  22: "LN",
  23: "LOG10",
  24: "ABS",
  25: "INT",
  26: "SIGN",
  27: "ROUND",
  28: "LOOKUP",
  29: "INDEX",
  30: "REPT",
  31: "MID",
  32: "LEN",
  33: "VALUE",
  34: "TRUE",
  35: "FALSE",
  36: "AND",
  37: "OR",
  38: "NOT",
  39: "MOD",
  40: "DCOUNT",
  41: "DSUM",
  42: "DAVERAGE",
  43: "DMIN",
  44: "DMAX",
  45: "DSTDEV",
  46: "VAR",
  47: "DVAR",
  48: "TEXT",
  49: "LINEST",
  50: "TREND",
  51: "LOGEST",
  52: "GROWTH",
  53: "GOTO",
  54: "HALT",
  55: "RETURN",
  56: "PV",
  57: "FV",
  58: "NPER",
  59: "PMT",
  60: "RATE",
  61: "MIRR",
  62: "IRR",
  63: "RAND",
  64: "MATCH",
  65: "DATE",
  66: "TIME",
  67: "DAY",
  68: "MONTH",
  69: "YEAR",
  70: "WEEKDAY",
  71: "HOUR",
  72: "MINUTE",
  73: "SECOND",
  74: "NOW",
  75: "AREAS",
  76: "ROWS",
  77: "COLUMNS",
  78: "OFFSET",
  79: "ABSREF",
  80: "RELREF",
  81: "ARGUMENT",
  82: "SEARCH",
  83: "TRANSPOSE",
  84: "ERROR",
  85: "STEP",
  86: "TYPE",
  87: "ECHO",
  88: "SET.NAME",
  89: "CALLER",
  90: "DEREF",
  91: "WINDOWS",
  92: "SERIES",
  93: "DOCUMENTS",
  94: "ACTIVE.CELL",
  95: "SELECTION",
  96: "RESULT",
  97: "ATAN2",
  98: "ASIN",
  99: "ACOS",
  100: "CHOOSE",
  101: "HLOOKUP",
  102: "VLOOKUP",
  103: "LINKS",
  104: "INPUT",
  105: "ISREF",
  106: "GET.FORMULA",
  107: "GET.NAME",
  108: "SET.VALUE",
  109: "LOG",
  110: "EXEC",
  111: "CHAR",
  112: "LOWER",
  113: "UPPER",
  114: "PROPER",
  115: "LEFT",
  116: "RIGHT",
  117: "EXACT",
  118: "TRIM",
  119: "REPLACE",
  120: "SUBSTITUTE",
  121: "CODE",
  122: "NAMES",
  123: "DIRECTORY",
  124: "FIND",
  125: "CELL",
  126: "ISERR",
  127: "ISTEXT",
  128: "ISNUMBER",
  129: "ISBLANK",
  130: "T",
  131: "N",
  132: "FOPEN",
  133: "FCLOSE",
  134: "FSIZE",
  135: "FREADLN",
  136: "FREAD",
  137: "FWRITELN",
  138: "FWRITE",
  139: "FPOS",
  140: "DATEVALUE",
  141: "TIMEVALUE",
  142: "SLN",
  143: "SYD",
  144: "DDB",
  145: "GET.DEF",
  146: "REFTEXT",
  147: "TEXTREF",
  148: "INDIRECT",
  149: "REGISTER",
  150: "CALL",
  151: "ADD.BAR",
  152: "ADD.MENU",
  153: "ADD.COMMAND",
  154: "ENABLE.COMMAND",
  155: "CHECK.COMMAND",
  156: "RENAME.COMMAND",
  157: "SHOW.BAR",
  158: "DELETE.MENU",
  159: "DELETE.COMMAND",
  160: "GET.CHART.ITEM",
  161: "DIALOG.BOX",
  162: "CLEAN",
  163: "MDETERM",
  164: "MINVERSE",
  165: "MMULT",
  166: "FILES",
  167: "IPMT",
  168: "PPMT",
  169: "COUNTA",
  170: "CANCEL.KEY",
  171: "FOR",
  172: "WHILE",
  173: "BREAK",
  174: "NEXT",
  175: "INITIATE",
  176: "REQUEST",
  177: "POKE",
  178: "EXECUTE",
  179: "TERMINATE",
  180: "RESTART",
  181: "HELP",
  182: "GET.BAR",
  183: "PRODUCT",
  184: "FACT",
  185: "GET.CELL",
  186: "GET.WORKSPACE",
  187: "GET.WINDOW",
  188: "GET.DOCUMENT",
  189: "DPRODUCT",
  190: "ISNONTEXT",
  191: "GET.NOTE",
  192: "NOTE",
  193: "STDEVP",
  194: "VARP",
  195: "DSTDEVP",
  196: "DVARP",
  197: "TRUNC",
  198: "ISLOGICAL",
  199: "DCOUNTA",
  200: "DELETE.BAR",
  201: "UNREGISTER",
  204: "USDOLLAR",
  205: "FINDB",
  206: "SEARCHB",
  207: "REPLACEB",
  208: "LEFTB",
  209: "RIGHTB",
  210: "MIDB",
  211: "LENB",
  212: "ROUNDUP",
  213: "ROUNDDOWN",
  214: "ASC",
  215: "DBCS",
  216: "RANK",
  219: "ADDRESS",
  220: "DAYS360",
  221: "TODAY",
  222: "VDB",
  223: "ELSE",
  224: "ELSE.IF",
  225: "END.IF",
  226: "FOR.CELL",
  227: "MEDIAN",
  228: "SUMPRODUCT",
  229: "SINH",
  230: "COSH",
  231: "TANH",
  232: "ASINH",
  233: "ACOSH",
  234: "ATANH",
  235: "DGET",
  236: "CREATE.OBJECT",
  237: "VOLATILE",
  238: "LAST.ERROR",
  239: "CUSTOM.UNDO",
  240: "CUSTOM.REPEAT",
  241: "FORMULA.CONVERT",
  242: "GET.LINK.INFO",
  243: "TEXT.BOX",
  244: "INFO",
  245: "GROUP",
  246: "GET.OBJECT",
  247: "DB",
  248: "PAUSE",
  251: "RESUME",
  252: "FREQUENCY",
  253: "ADD.TOOLBAR",
  254: "DELETE.TOOLBAR",
  255: "User",
  256: "RESET.TOOLBAR",
  257: "EVALUATE",
  258: "GET.TOOLBAR",
  259: "GET.TOOL",
  260: "SPELLING.CHECK",
  261: "ERROR.TYPE",
  262: "APP.TITLE",
  263: "WINDOW.TITLE",
  264: "SAVE.TOOLBAR",
  265: "ENABLE.TOOL",
  266: "PRESS.TOOL",
  267: "REGISTER.ID",
  268: "GET.WORKBOOK",
  269: "AVEDEV",
  270: "BETADIST",
  271: "GAMMALN",
  272: "BETAINV",
  273: "BINOMDIST",
  274: "CHIDIST",
  275: "CHIINV",
  276: "COMBIN",
  277: "CONFIDENCE",
  278: "CRITBINOM",
  279: "EVEN",
  280: "EXPONDIST",
  281: "FDIST",
  282: "FINV",
  283: "FISHER",
  284: "FISHERINV",
  285: "FLOOR",
  286: "GAMMADIST",
  287: "GAMMAINV",
  288: "CEILING",
  289: "HYPGEOMDIST",
  290: "LOGNORMDIST",
  291: "LOGINV",
  292: "NEGBINOMDIST",
  293: "NORMDIST",
  294: "NORMSDIST",
  295: "NORMINV",
  296: "NORMSINV",
  297: "STANDARDIZE",
  298: "ODD",
  299: "PERMUT",
  300: "POISSON",
  301: "TDIST",
  302: "WEIBULL",
  303: "SUMXMY2",
  304: "SUMX2MY2",
  305: "SUMX2PY2",
  306: "CHITEST",
  307: "CORREL",
  308: "COVAR",
  309: "FORECAST",
  310: "FTEST",
  311: "INTERCEPT",
  312: "PEARSON",
  313: "RSQ",
  314: "STEYX",
  315: "SLOPE",
  316: "TTEST",
  317: "PROB",
  318: "DEVSQ",
  319: "GEOMEAN",
  320: "HARMEAN",
  321: "SUMSQ",
  322: "KURT",
  323: "SKEW",
  324: "ZTEST",
  325: "LARGE",
  326: "SMALL",
  327: "QUARTILE",
  328: "PERCENTILE",
  329: "PERCENTRANK",
  330: "MODE",
  331: "TRIMMEAN",
  332: "TINV",
  334: "MOVIE.COMMAND",
  335: "GET.MOVIE",
  336: "CONCATENATE",
  337: "POWER",
  338: "PIVOT.ADD.DATA",
  339: "GET.PIVOT.TABLE",
  340: "GET.PIVOT.FIELD",
  341: "GET.PIVOT.ITEM",
  342: "RADIANS",
  343: "DEGREES",
  344: "SUBTOTAL",
  345: "SUMIF",
  346: "COUNTIF",
  347: "COUNTBLANK",
  348: "SCENARIO.GET",
  349: "OPTIONS.LISTS.GET",
  350: "ISPMT",
  351: "DATEDIF",
  352: "DATESTRING",
  353: "NUMBERSTRING",
  354: "ROMAN",
  355: "OPEN.DIALOG",
  356: "SAVE.DIALOG",
  357: "VIEW.GET",
  358: "GETPIVOTDATA",
  359: "HYPERLINK",
  360: "PHONETIC",
  361: "AVERAGEA",
  362: "MAXA",
  363: "MINA",
  364: "STDEVPA",
  365: "VARPA",
  366: "STDEVA",
  367: "VARA",
  368: "BAHTTEXT",
  369: "THAIDAYOFWEEK",
  370: "THAIDIGIT",
  371: "THAIMONTHOFYEAR",
  372: "THAINUMSOUND",
  373: "THAINUMSTRING",
  374: "THAISTRINGLENGTH",
  375: "ISTHAIDIGIT",
  376: "ROUNDBAHTDOWN",
  377: "ROUNDBAHTUP",
  378: "THAIYEAR",
  379: "RTD",
  380: "CUBEVALUE",
  381: "CUBEMEMBER",
  382: "CUBEMEMBERPROPERTY",
  383: "CUBERANKEDMEMBER",
  384: "HEX2BIN",
  385: "HEX2DEC",
  386: "HEX2OCT",
  387: "DEC2BIN",
  388: "DEC2HEX",
  389: "DEC2OCT",
  390: "OCT2BIN",
  391: "OCT2HEX",
  392: "OCT2DEC",
  393: "BIN2DEC",
  394: "BIN2OCT",
  395: "BIN2HEX",
  396: "IMSUB",
  397: "IMDIV",
  398: "IMPOWER",
  399: "IMABS",
  400: "IMSQRT",
  401: "IMLN",
  402: "IMLOG2",
  403: "IMLOG10",
  404: "IMSIN",
  405: "IMCOS",
  406: "IMEXP",
  407: "IMARGUMENT",
  408: "IMCONJUGATE",
  409: "IMAGINARY",
  410: "IMREAL",
  411: "COMPLEX",
  412: "IMSUM",
  413: "IMPRODUCT",
  414: "SERIESSUM",
  415: "FACTDOUBLE",
  416: "SQRTPI",
  417: "QUOTIENT",
  418: "DELTA",
  419: "GESTEP",
  420: "ISEVEN",
  421: "ISODD",
  422: "MROUND",
  423: "ERF",
  424: "ERFC",
  425: "BESSELJ",
  426: "BESSELK",
  427: "BESSELY",
  428: "BESSELI",
  429: "XIRR",
  430: "XNPV",
  431: "PRICEMAT",
  432: "YIELDMAT",
  433: "INTRATE",
  434: "RECEIVED",
  435: "DISC",
  436: "PRICEDISC",
  437: "YIELDDISC",
  438: "TBILLEQ",
  439: "TBILLPRICE",
  440: "TBILLYIELD",
  441: "PRICE",
  442: "YIELD",
  443: "DOLLARDE",
  444: "DOLLARFR",
  445: "NOMINAL",
  446: "EFFECT",
  447: "CUMPRINC",
  448: "CUMIPMT",
  449: "EDATE",
  450: "EOMONTH",
  451: "YEARFRAC",
  452: "COUPDAYBS",
  453: "COUPDAYS",
  454: "COUPDAYSNC",
  455: "COUPNCD",
  456: "COUPNUM",
  457: "COUPPCD",
  458: "DURATION",
  459: "MDURATION",
  460: "ODDLPRICE",
  461: "ODDLYIELD",
  462: "ODDFPRICE",
  463: "ODDFYIELD",
  464: "RANDBETWEEN",
  465: "WEEKNUM",
  466: "AMORDEGRC",
  467: "AMORLINC",
  468: "CONVERT",
  724: "SHEETJS",
  469: "ACCRINT",
  470: "ACCRINTM",
  471: "WORKDAY",
  472: "NETWORKDAYS",
  473: "GCD",
  474: "MULTINOMIAL",
  475: "LCM",
  476: "FVSCHEDULE",
  477: "CUBEKPIMEMBER",
  478: "CUBESET",
  479: "CUBESETCOUNT",
  480: "IFERROR",
  481: "COUNTIFS",
  482: "SUMIFS",
  483: "AVERAGEIF",
  484: "AVERAGEIFS"
}, FtabArgc = {
  2: 1,
  3: 1,
  10: 0,
  15: 1,
  16: 1,
  17: 1,
  18: 1,
  19: 0,
  20: 1,
  21: 1,
  22: 1,
  23: 1,
  24: 1,
  25: 1,
  26: 1,
  27: 2,
  30: 2,
  31: 3,
  32: 1,
  33: 1,
  34: 0,
  35: 0,
  38: 1,
  39: 2,
  40: 3,
  41: 3,
  42: 3,
  43: 3,
  44: 3,
  45: 3,
  47: 3,
  48: 2,
  53: 1,
  61: 3,
  63: 0,
  65: 3,
  66: 3,
  67: 1,
  68: 1,
  69: 1,
  70: 1,
  71: 1,
  72: 1,
  73: 1,
  74: 0,
  75: 1,
  76: 1,
  77: 1,
  79: 2,
  80: 2,
  83: 1,
  85: 0,
  86: 1,
  89: 0,
  90: 1,
  94: 0,
  95: 0,
  97: 2,
  98: 1,
  99: 1,
  101: 3,
  102: 3,
  105: 1,
  106: 1,
  108: 2,
  111: 1,
  112: 1,
  113: 1,
  114: 1,
  117: 2,
  118: 1,
  119: 4,
  121: 1,
  126: 1,
  127: 1,
  128: 1,
  129: 1,
  130: 1,
  131: 1,
  133: 1,
  134: 1,
  135: 1,
  136: 2,
  137: 2,
  138: 2,
  140: 1,
  141: 1,
  142: 3,
  143: 4,
  144: 4,
  161: 1,
  162: 1,
  163: 1,
  164: 1,
  165: 2,
  172: 1,
  175: 2,
  176: 2,
  177: 3,
  178: 2,
  179: 1,
  184: 1,
  186: 1,
  189: 3,
  190: 1,
  195: 3,
  196: 3,
  197: 1,
  198: 1,
  199: 3,
  201: 1,
  207: 4,
  210: 3,
  211: 1,
  212: 2,
  213: 2,
  214: 1,
  215: 1,
  225: 0,
  229: 1,
  230: 1,
  231: 1,
  232: 1,
  233: 1,
  234: 1,
  235: 3,
  244: 1,
  247: 4,
  252: 2,
  257: 1,
  261: 1,
  271: 1,
  273: 4,
  274: 2,
  275: 2,
  276: 2,
  277: 3,
  278: 3,
  279: 1,
  280: 3,
  281: 3,
  282: 3,
  283: 1,
  284: 1,
  285: 2,
  286: 4,
  287: 3,
  288: 2,
  289: 4,
  290: 3,
  291: 3,
  292: 3,
  293: 4,
  294: 1,
  295: 3,
  296: 1,
  297: 3,
  298: 1,
  299: 2,
  300: 3,
  301: 3,
  302: 4,
  303: 2,
  304: 2,
  305: 2,
  306: 2,
  307: 2,
  308: 2,
  309: 3,
  310: 2,
  311: 2,
  312: 2,
  313: 2,
  314: 2,
  315: 2,
  316: 4,
  325: 2,
  326: 2,
  327: 2,
  328: 2,
  331: 2,
  332: 2,
  337: 2,
  342: 1,
  343: 1,
  346: 2,
  347: 1,
  350: 4,
  351: 3,
  352: 1,
  353: 2,
  360: 1,
  368: 1,
  369: 1,
  370: 1,
  371: 1,
  372: 1,
  373: 1,
  374: 1,
  375: 1,
  376: 1,
  377: 1,
  378: 1,
  382: 3,
  385: 1,
  392: 1,
  393: 1,
  396: 2,
  397: 2,
  398: 2,
  399: 1,
  400: 1,
  401: 1,
  402: 1,
  403: 1,
  404: 1,
  405: 1,
  406: 1,
  407: 1,
  408: 1,
  409: 1,
  410: 1,
  414: 4,
  415: 1,
  416: 1,
  417: 2,
  420: 1,
  421: 1,
  422: 2,
  424: 1,
  425: 2,
  426: 2,
  427: 2,
  428: 2,
  430: 3,
  438: 3,
  439: 3,
  440: 3,
  443: 2,
  444: 2,
  445: 2,
  446: 2,
  447: 6,
  448: 6,
  449: 2,
  450: 2,
  464: 2,
  468: 3,
  476: 2,
  479: 1,
  480: 2,
  65535: 0
};
function ods_to_csf_formula(F) {
  return F.slice(0, 3) == "of:" && (F = F.slice(3)), F.charCodeAt(0) == 61 && (F = F.slice(1), F.charCodeAt(0) == 61 && (F = F.slice(1))), F = F.replace(/COM\.MICROSOFT\./g, ""), F = F.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function(x, w) {
    return w.replace(/\./g, "");
  }), F = F.replace(/\$'([^']|'')+'/g, function(x) {
    return x.slice(1);
  }), F = F.replace(/\$([^\]\. #$]+)/g, function(x, w) {
    return w.match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? x : w;
  }), F = F.replace(/\[.(#[A-Z]*[?!])\]/g, "$1"), F.replace(/[;~]/g, ",").replace(/\|/g, ";");
}
function csf_to_ods_formula(F) {
  var x = "of:=" + F.replace(crefregex, "$1[.$2$3$4$5]").replace(/\]:\[/g, ":");
  return x.replace(/;/g, "|").replace(/,/g, ";");
}
function ods_to_csf_3D(F) {
  F = F.replace(/\$'([^']|'')+'/g, function(O) {
    return O.slice(1);
  }), F = F.replace(/\$([^\]\. #$]+)/g, function(O, D) {
    return D.match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? O : D;
  });
  var x = F.split(":"), w = x[0].split(".")[0];
  return [w, x[0].split(".")[1] + (x.length > 1 ? ":" + (x[1].split(".")[1] || x[1].split(".")[0]) : "")];
}
function csf_to_ods_3D(F) {
  return F.replace(/!/, ".").replace(/:/, ":.");
}
var strs = {}, _ssfopts = {}, browser_has_Map = typeof Map < "u";
function get_sst_id(F, x, w) {
  var O = 0, D = F.length;
  if (w) {
    if (browser_has_Map ? w.has(x) : Object.prototype.hasOwnProperty.call(w, x)) {
      for (var U = browser_has_Map ? w.get(x) : w[x]; O < U.length; ++O)
        if (F[U[O]].t === x)
          return F.Count++, U[O];
    }
  } else for (; O < D; ++O)
    if (F[O].t === x)
      return F.Count++, O;
  return F[D] = { t: x }, F.Count++, F.Unique++, w && (browser_has_Map ? (w.has(x) || w.set(x, []), w.get(x).push(D)) : (Object.prototype.hasOwnProperty.call(w, x) || (w[x] = []), w[x].push(D))), D;
}
function col_obj_w(F, x) {
  var w = { min: F + 1, max: F + 1 }, O = -1;
  return x.MDW && (MDW = x.MDW), x.width != null ? w.customWidth = 1 : x.wpx != null ? O = px2char(x.wpx) : x.wch != null && (O = x.wch), O > -1 ? (w.width = char2width(O), w.customWidth = 1) : x.width != null && (w.width = x.width), x.hidden && (w.hidden = !0), x.level != null && (w.outlineLevel = w.level = x.level), w;
}
function default_margins(F, x) {
  if (F) {
    var w = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
    x == "xlml" && (w = [1, 1, 1, 1, 0.5, 0.5]), F.left == null && (F.left = w[0]), F.right == null && (F.right = w[1]), F.top == null && (F.top = w[2]), F.bottom == null && (F.bottom = w[3]), F.header == null && (F.header = w[4]), F.footer == null && (F.footer = w[5]);
  }
}
function get_cell_style(F, x, w) {
  var O = w.revssf[x.z != null ? x.z : "General"], D = 60, U = F.length;
  if (O == null && w.ssf) {
    for (; D < 392; ++D) if (w.ssf[D] == null) {
      SSF__load(x.z, D), w.ssf[D] = x.z, w.revssf[x.z] = O = D;
      break;
    }
  }
  for (D = 0; D != U; ++D) if (F[D].numFmtId === O) return D;
  return F[U] = {
    numFmtId: O,
    fontId: 0,
    fillId: 0,
    borderId: 0,
    xfId: 0,
    applyNumberFormat: 1
  }, U;
}
function safe_format(F, x, w, O, D, U, W) {
  try {
    O.cellNF && (F.z = table_fmt[x]);
  } catch (G) {
    if (O.WTF) throw G;
  }
  if (!(F.t === "z" && !O.cellStyles)) {
    if (F.t === "d" && typeof F.v == "string" && (F.v = parseDate(F.v)), (!O || O.cellText !== !1) && F.t !== "z") try {
      if (table_fmt[x] == null && SSF__load(SSFImplicit[x] || "General", x), F.t === "e") F.w = F.w || BErr[F.v];
      else if (x === 0)
        if (F.t === "n")
          (F.v | 0) === F.v ? F.w = F.v.toString(10) : F.w = SSF_general_num(F.v);
        else if (F.t === "d") {
          var X = datenum(F.v, !!W);
          (X | 0) === X ? F.w = X.toString(10) : F.w = SSF_general_num(X);
        } else {
          if (F.v === void 0) return "";
          F.w = SSF_general(F.v, _ssfopts);
        }
      else F.t === "d" ? F.w = SSF_format(x, datenum(F.v, !!W), _ssfopts) : F.w = SSF_format(x, F.v, _ssfopts);
    } catch (G) {
      if (O.WTF) throw G;
    }
    if (O.cellStyles && w != null)
      try {
        F.s = U.Fills[w], F.s.fgColor && F.s.fgColor.theme && !F.s.fgColor.rgb && (F.s.fgColor.rgb = rgb_tint(D.themeElements.clrScheme[F.s.fgColor.theme].rgb, F.s.fgColor.tint || 0), O.WTF && (F.s.fgColor.raw_rgb = D.themeElements.clrScheme[F.s.fgColor.theme].rgb)), F.s.bgColor && F.s.bgColor.theme && (F.s.bgColor.rgb = rgb_tint(D.themeElements.clrScheme[F.s.bgColor.theme].rgb, F.s.bgColor.tint || 0), O.WTF && (F.s.bgColor.raw_rgb = D.themeElements.clrScheme[F.s.bgColor.theme].rgb));
      } catch (G) {
        if (O.WTF && U.Fills) throw G;
      }
  }
}
function check_ws(F, x, w) {
  if (F && F["!ref"]) {
    var O = safe_decode_range(F["!ref"]);
    if (O.e.c < O.s.c || O.e.r < O.s.r) throw new Error("Bad range (" + w + "): " + F["!ref"]);
  }
}
function parse_ws_xml_dim(F, x) {
  var w = safe_decode_range(x);
  w.s.r <= w.e.r && w.s.c <= w.e.c && w.s.r >= 0 && w.s.c >= 0 && (F["!ref"] = encode_range(w));
}
var mergecregex = /<(?:\w+:)?mergeCell ref=["'][A-Z0-9:]+['"]\s*[\/]?>/g, hlinkregex = /<(?:\w+:)?hyperlink [^<>]*>/mg, dimregex = /"(\w*:\w*)"/, colregex = /<(?:\w+:)?col\b[^<>]*[\/]?>/g, afregex = /<(?:\w+:)?autoFilter[^>]*/g, marginregex = /<(?:\w+:)?pageMargins[^<>]*\/>/g, sheetprregex = /<(?:\w+:)?sheetPr\b[^<>]*?\/>/;
function parse_ws_xml(F, x, w, O, D, U, W) {
  if (!F) return F;
  O || (O = { "!id": {} });
  var X = {};
  x.dense && (X["!data"] = []);
  var G = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, Y = "", K = "", Z = str_match_xml_ns(F, "sheetData");
  Z ? (Y = F.slice(0, Z.index), K = F.slice(Z.index + Z[0].length)) : Y = K = F;
  var q = Y.match(sheetprregex);
  q ? parse_ws_xml_sheetpr(q[0], X, D, w) : (q = str_match_xml_ns(Y, "sheetPr")) && parse_ws_xml_sheetpr2(q[0], q[1] || "", X, D, w);
  var J = (Y.match(/<(?:\w*:)?dimension/) || { index: -1 }).index;
  if (J > 0) {
    var ee = Y.slice(J, J + 50).match(dimregex);
    ee && !(x && x.nodim) && parse_ws_xml_dim(X, ee[1]);
  }
  var re = str_match_xml_ns(Y, "sheetViews");
  re && re[1] && parse_ws_xml_sheetviews(re[1], D);
  var te = [];
  if (x.cellStyles) {
    var Q = Y.match(colregex);
    Q && parse_ws_xml_cols(te, Q);
  }
  Z && parse_ws_xml_data(Z[1], X, x, G, U, W, D);
  var oe = K.match(afregex);
  oe && (X["!autofilter"] = parse_ws_xml_autofilter(oe[0]));
  var ne = [], le = K.match(mergecregex);
  if (le) for (J = 0; J != le.length; ++J)
    ne[J] = safe_decode_range(le[J].slice(le[J].indexOf("=") + 2));
  var Ee = K.match(hlinkregex);
  Ee && parse_ws_xml_hlinks(X, Ee, O);
  var Te = K.match(marginregex);
  Te && (X["!margins"] = parse_ws_xml_margins(parsexmltag(Te[0])));
  var de;
  if ((de = K.match(/legacyDrawing r:id="(.*?)"/)) && (X["!legrel"] = de[1]), x && x.nodim && (G.s.c = G.s.r = 0), !X["!ref"] && G.e.c >= G.s.c && G.e.r >= G.s.r && (X["!ref"] = encode_range(G)), x.sheetRows > 0 && X["!ref"]) {
    var ae = safe_decode_range(X["!ref"]);
    x.sheetRows <= +ae.e.r && (ae.e.r = x.sheetRows - 1, ae.e.r > G.e.r && (ae.e.r = G.e.r), ae.e.r < ae.s.r && (ae.s.r = ae.e.r), ae.e.c > G.e.c && (ae.e.c = G.e.c), ae.e.c < ae.s.c && (ae.s.c = ae.e.c), X["!fullref"] = X["!ref"], X["!ref"] = encode_range(ae));
  }
  return te.length > 0 && (X["!cols"] = te), ne.length > 0 && (X["!merges"] = ne), O["!id"][X["!legrel"]] && (X["!legdrawel"] = O["!id"][X["!legrel"]]), X;
}
function write_ws_xml_merges(F) {
  if (F.length === 0) return "";
  for (var x = '<mergeCells count="' + F.length + '">', w = 0; w != F.length; ++w) x += '<mergeCell ref="' + encode_range(F[w]) + '"/>';
  return x + "</mergeCells>";
}
function parse_ws_xml_sheetpr(F, x, w, O) {
  var D = parsexmltag(F);
  w.Sheets[O] || (w.Sheets[O] = {}), D.codeName && (w.Sheets[O].CodeName = unescapexml(utf8read(D.codeName)));
}
function parse_ws_xml_sheetpr2(F, x, w, O, D) {
  parse_ws_xml_sheetpr(F.slice(0, F.indexOf(">")), w, O, D);
}
function write_ws_xml_sheetpr(F, x, w, O, D) {
  var U = !1, W = {}, X = null;
  if (O.bookType !== "xlsx" && x.vbaraw) {
    var G = x.SheetNames[w];
    try {
      x.Workbook && (G = x.Workbook.Sheets[w].CodeName || G);
    } catch {
    }
    U = !0, W.codeName = utf8write(escapexml(G));
  }
  if (F && F["!outline"]) {
    var Y = { summaryBelow: 1, summaryRight: 1 };
    F["!outline"].above && (Y.summaryBelow = 0), F["!outline"].left && (Y.summaryRight = 0), X = (X || "") + writextag("outlinePr", null, Y);
  }
  !U && !X || (D[D.length] = writextag("sheetPr", X, W));
}
var sheetprot_deffalse = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"], sheetprot_deftrue = [
  "formatColumns",
  "formatRows",
  "formatCells",
  "insertColumns",
  "insertRows",
  "insertHyperlinks",
  "deleteColumns",
  "deleteRows",
  "sort",
  "autoFilter",
  "pivotTables"
];
function write_ws_xml_protection(F) {
  var x = { sheet: 1 };
  return sheetprot_deffalse.forEach(function(w) {
    F[w] != null && F[w] && (x[w] = "1");
  }), sheetprot_deftrue.forEach(function(w) {
    F[w] != null && !F[w] && (x[w] = "0");
  }), F.password && (x.password = crypto_CreatePasswordVerifier_Method1(F.password).toString(16).toUpperCase()), writextag("sheetProtection", null, x);
}
function parse_ws_xml_hlinks(F, x, w) {
  for (var O = F["!data"] != null, D = 0; D != x.length; ++D) {
    var U = parsexmltag(utf8read(x[D]), !0);
    if (!U.ref) return;
    var W = ((w || {})["!id"] || [])[U.id];
    W ? (U.Target = W.Target, U.location && (U.Target += "#" + unescapexml(U.location))) : (U.Target = "#" + unescapexml(U.location), W = { Target: U.Target, TargetMode: "Internal" }), U.Rel = W, U.tooltip && (U.Tooltip = U.tooltip, delete U.tooltip);
    for (var X = safe_decode_range(U.ref), G = X.s.r; G <= X.e.r; ++G) for (var Y = X.s.c; Y <= X.e.c; ++Y) {
      var K = encode_col(Y) + encode_row(G);
      O ? (F["!data"][G] || (F["!data"][G] = []), F["!data"][G][Y] || (F["!data"][G][Y] = { t: "z", v: void 0 }), F["!data"][G][Y].l = U) : (F[K] || (F[K] = { t: "z", v: void 0 }), F[K].l = U);
    }
  }
}
function parse_ws_xml_margins(F) {
  var x = {};
  return ["left", "right", "top", "bottom", "header", "footer"].forEach(function(w) {
    F[w] && (x[w] = parseFloat(F[w]));
  }), x;
}
function write_ws_xml_margins(F) {
  return default_margins(F), writextag("pageMargins", null, F);
}
function parse_ws_xml_cols(F, x) {
  for (var w = !1, O = 0; O != x.length; ++O) {
    var D = parsexmltag(x[O], !0);
    D.hidden && (D.hidden = parsexmlbool(D.hidden));
    var U = parseInt(D.min, 10) - 1, W = parseInt(D.max, 10) - 1;
    for (D.outlineLevel && (D.level = +D.outlineLevel || 0), delete D.min, delete D.max, D.width = +D.width, !w && D.width && (w = !0, find_mdw_colw(D.width)), process_col(D); U <= W; ) F[U++] = dup(D);
  }
}
function write_ws_xml_cols(F, x) {
  for (var w = ["<cols>"], O, D = 0; D != x.length; ++D)
    (O = x[D]) && (w[w.length] = writextag("col", null, col_obj_w(D, O)));
  return w[w.length] = "</cols>", w.join("");
}
function parse_ws_xml_autofilter(F) {
  var x = { ref: (F.match(/ref="([^"]*)"/) || [])[1] };
  return x;
}
function write_ws_xml_autofilter(F, x, w, O) {
  var D = typeof F.ref == "string" ? F.ref : encode_range(F.ref);
  w.Workbook || (w.Workbook = { Sheets: [] }), w.Workbook.Names || (w.Workbook.Names = []);
  var U = w.Workbook.Names, W = decode_range(D);
  W.s.r == W.e.r && (W.e.r = decode_range(x["!ref"]).e.r, D = encode_range(W));
  for (var X = 0; X < U.length; ++X) {
    var G = U[X];
    if (G.Name == "_xlnm._FilterDatabase" && G.Sheet == O) {
      G.Ref = formula_quote_sheet_name(w.SheetNames[O]) + "!" + fix_range(D);
      break;
    }
  }
  return X == U.length && U.push({ Name: "_xlnm._FilterDatabase", Sheet: O, Ref: "'" + w.SheetNames[O] + "'!" + D }), writextag("autoFilter", null, { ref: D });
}
var sviewregex = /<(?:\w:)?sheetView(?:[^<>a-z][^<>]*)?\/?>/g;
function parse_ws_xml_sheetviews(F, x) {
  x.Views || (x.Views = [{}]), (F.match(sviewregex) || []).forEach(function(w, O) {
    var D = parsexmltag(w);
    x.Views[O] || (x.Views[O] = {}), +D.zoomScale && (x.Views[O].zoom = +D.zoomScale), D.rightToLeft && parsexmlbool(D.rightToLeft) && (x.Views[O].RTL = !0);
  });
}
function write_ws_xml_sheetviews(F, x, w, O) {
  var D = { workbookViewId: "0" };
  return (((O || {}).Workbook || {}).Views || [])[0] && (D.rightToLeft = O.Workbook.Views[0].RTL ? "1" : "0"), writextag("sheetViews", writextag("sheetView", null, D), {});
}
function write_ws_xml_cell(F, x, w, O, D, U, W) {
  if (F.c && w["!comments"].push([x, F.c]), (F.v === void 0 || F.t === "z" && !(O || {}).sheetStubs) && typeof F.f != "string" && typeof F.z > "u") return "";
  var X = "", G = F.t, Y = F.v;
  if (F.t !== "z") switch (F.t) {
    case "b":
      X = F.v ? "1" : "0";
      break;
    case "n":
      isNaN(F.v) ? (F.t = "e", X = BErr[F.v = 36]) : isFinite(F.v) ? X = "" + F.v : (F.t = "e", X = BErr[F.v = 7]);
      break;
    case "e":
      X = BErr[F.v];
      break;
    case "d":
      if (O && O.cellDates) {
        var K = parseDate(F.v, W);
        X = K.toISOString(), K.getUTCFullYear() < 1900 && (X = X.slice(X.indexOf("T") + 1).replace("Z", ""));
      } else
        F = dup(F), F.t = "n", X = "" + (F.v = datenum(parseDate(F.v, W), W));
      typeof F.z > "u" && (F.z = table_fmt[14]);
      break;
    default:
      X = F.v;
      break;
  }
  var Z = F.t == "z" || F.v == null ? "" : writetag("v", escapexml(X)), q = { r: x }, J = get_cell_style(O.cellXfs, F, O);
  switch (J !== 0 && (q.s = J), F.t) {
    case "n":
      break;
    case "d":
      q.t = "d";
      break;
    case "b":
      q.t = "b";
      break;
    case "e":
      q.t = "e";
      break;
    case "z":
      break;
    default:
      if (F.v == null) {
        delete F.t;
        break;
      }
      if (F.v.length > 32767) throw new Error("Text length must not exceed 32767 characters");
      if (O && O.bookSST) {
        Z = writetag("v", "" + get_sst_id(O.Strings, F.v, O.revStrings)), q.t = "s";
        break;
      } else q.t = "str";
      break;
  }
  if (F.t != G && (F.t = G, F.v = Y), typeof F.f == "string" && F.f) {
    var ee = F.F && F.F.slice(0, x.length) == x ? { t: "array", ref: F.F } : null;
    Z = writextag("f", escapexml(F.f), ee) + (F.v != null ? Z : "");
  }
  return F.l && (F.l.display = escapexml(X), w["!links"].push([x, F.l])), F.D && (q.cm = 1), writextag("c", Z, q);
}
var parse_ws_xml_data = /* @__PURE__ */ function() {
  var F = /<(?:\w+:)?c[ \/>]/, x = /<\/(?:\w+:)?row>/, w = /r=["']([^"']*)["']/, O = /ref=["']([^"']*)["']/;
  return function(U, W, X, G, Y, K, Z) {
    for (var q = 0, J = "", ee = [], re = [], te = 0, Q = 0, oe = 0, ne = "", le, Ee, Te = 0, de = 0, ae, se, ce = 0, xe = 0, Ce = Array.isArray(K.CellXf), ye, ze = [], De = [], et = W["!data"] != null, Oe = [], Xe = {}, He = !1, Ae = !!X.sheetStubs, qe = !!((Z || {}).WBProps || {}).date1904, Ue = U.split(x), Re = 0, Me = Ue.length; Re != Me; ++Re) {
      J = Ue[Re].trim();
      var je = J.length;
      if (je !== 0) {
        var Je = 0;
        e: for (q = 0; q < je; ++q) switch (
          /*x.charCodeAt(ri)*/
          J[q]
        ) {
          case ">":
            if (
              /*x.charCodeAt(ri-1) != 47*/
              J[q - 1] != "/"
            ) {
              ++q;
              break e;
            }
            if (X && X.cellStyles) {
              if (Ee = parsexmltag(J.slice(Je, q), !0), Te = Ee.r != null ? parseInt(Ee.r, 10) : Te + 1, de = -1, X.sheetRows && X.sheetRows < Te) continue;
              Xe = {}, He = !1, Ee.ht && (He = !0, Xe.hpt = parseFloat(Ee.ht), Xe.hpx = pt2px(Xe.hpt)), Ee.hidden && parsexmlbool(Ee.hidden) && (He = !0, Xe.hidden = !0), Ee.outlineLevel != null && (He = !0, Xe.level = +Ee.outlineLevel), He && (Oe[Te - 1] = Xe);
            }
            break;
          case "<":
            Je = q;
            break;
        }
        if (Je >= q) break;
        if (Ee = parsexmltag(J.slice(Je, q), !0), Te = Ee.r != null ? parseInt(Ee.r, 10) : Te + 1, de = -1, !(X.sheetRows && X.sheetRows < Te)) {
          X.nodim || (G.s.r > Te - 1 && (G.s.r = Te - 1), G.e.r < Te - 1 && (G.e.r = Te - 1)), X && X.cellStyles && (Xe = {}, He = !1, Ee.ht && (He = !0, Xe.hpt = parseFloat(Ee.ht), Xe.hpx = pt2px(Xe.hpt)), Ee.hidden && parsexmlbool(Ee.hidden) && (He = !0, Xe.hidden = !0), Ee.outlineLevel != null && (He = !0, Xe.level = +Ee.outlineLevel), He && (Oe[Te - 1] = Xe)), ee = J.slice(q).split(F);
          for (var rt = 0; rt != ee.length && ee[rt].trim().charAt(0) == "<"; ++rt) ;
          for (ee = ee.slice(rt), q = 0; q != ee.length; ++q)
            if (J = ee[q].trim(), J.length !== 0) {
              if (re = J.match(w), te = q, Q = 0, oe = 0, J = "<c " + (J.slice(0, 1) == "<" ? ">" : "") + J, re != null && re.length === 2) {
                for (te = 0, ne = re[1], Q = 0; Q != ne.length && !((oe = ne.charCodeAt(Q) - 64) < 1 || oe > 26); ++Q)
                  te = 26 * te + oe;
                --te, de = te;
              } else ++de;
              for (Q = 0; Q != J.length && J.charCodeAt(Q) !== 62; ++Q) ;
              if (++Q, Ee = parsexmltag(J.slice(0, Q), !0), Ee.r || (Ee.r = encode_cell({ r: Te - 1, c: de })), ne = J.slice(Q), le = { t: "" }, (re = str_match_xml_ns(ne, "v")) != null && /*::cref != null && */
              re[1] !== "" && (le.v = unescapexml(re[1])), X.cellFormula) {
                if ((re = str_match_xml_ns(ne, "f")) != null) {
                  if (re[1] == "")
                    /*::cref != null && cref[0] != null && */
                    re[0].indexOf('t="shared"') > -1 && (se = parsexmltag(re[0]), De[se.si] && (le.f = shift_formula_xlsx(De[se.si][1], De[se.si][2], Ee.r)));
                  else if (le.f = unescapexml(utf8read(re[1]), !0), X.xlfn || (le.f = _xlfn(le.f)), /*::cref != null && cref[0] != null && */
                  re[0].indexOf('t="array"') > -1)
                    le.F = (ne.match(O) || [])[1], le.F.indexOf(":") > -1 && ze.push([safe_decode_range(le.F), le.F]);
                  else if (
                    /*::cref != null && cref[0] != null && */
                    re[0].indexOf('t="shared"') > -1
                  ) {
                    se = parsexmltag(re[0]);
                    var fe = unescapexml(utf8read(re[1]));
                    X.xlfn || (fe = _xlfn(fe)), De[parseInt(se.si, 10)] = [se, fe, Ee.r];
                  }
                } else (re = ne.match(/<f[^<>]*\/>/)) && (se = parsexmltag(re[0]), De[se.si] && (le.f = shift_formula_xlsx(De[se.si][1], De[se.si][2], Ee.r)));
                var Se = decode_cell(Ee.r);
                for (Q = 0; Q < ze.length; ++Q)
                  Se.r >= ze[Q][0].s.r && Se.r <= ze[Q][0].e.r && Se.c >= ze[Q][0].s.c && Se.c <= ze[Q][0].e.c && (le.F = ze[Q][1]);
              }
              if (Ee.t == null && le.v === void 0)
                if (le.f || le.F)
                  le.v = 0, le.t = "n";
                else if (Ae) le.t = "z";
                else continue;
              else le.t = Ee.t || "n";
              switch (G.s.c > de && (G.s.c = de), G.e.c < de && (G.e.c = de), le.t) {
                case "n":
                  if (le.v == "" || le.v == null) {
                    if (!Ae) continue;
                    le.t = "z";
                  } else le.v = parseFloat(le.v);
                  break;
                case "s":
                  if (typeof le.v > "u") {
                    if (!Ae) continue;
                    le.t = "z";
                  } else
                    ae = strs[parseInt(le.v, 10)], le.v = ae.t, le.r = ae.r, X.cellHTML && (le.h = ae.h);
                  break;
                case "str":
                  le.t = "s", le.v = le.v != null ? unescapexml(utf8read(le.v), !0) : "", X.cellHTML && (le.h = escapehtml(le.v));
                  break;
                case "inlineStr":
                  re = str_match_xml_ns(ne, "is"), le.t = "s", re != null && (ae = parse_si(re[1])) ? (le.v = ae.t, X.cellHTML && (le.h = ae.h)) : le.v = "";
                  break;
                case "b":
                  le.v = parsexmlbool(le.v);
                  break;
                case "d":
                  X.cellDates ? le.v = parseDate(le.v, qe) : (le.v = datenum(parseDate(le.v, qe), qe), le.t = "n");
                  break;
                /* error string in .w, number in .v */
                case "e":
                  (!X || X.cellText !== !1) && (le.w = le.v), le.v = RBErr[le.v];
                  break;
              }
              if (ce = xe = 0, ye = null, Ce && Ee.s !== void 0 && (ye = K.CellXf[Ee.s], ye != null && (ye.numFmtId != null && (ce = ye.numFmtId), X.cellStyles && ye.fillId != null && (xe = ye.fillId))), safe_format(le, ce, xe, X, Y, K, qe), X.cellDates && Ce && le.t == "n" && fmt_is_date(table_fmt[ce]) && (le.v = numdate(le.v + (qe ? 1462 : 0)), le.t = typeof le.v == "number" ? "n" : "d"), Ee.cm && X.xlmeta) {
                var we = (X.xlmeta.Cell || [])[+Ee.cm - 1];
                we && we.type == "XLDAPR" && (le.D = !0);
              }
              var me;
              X.nodim && (me = decode_cell(Ee.r), G.s.r > me.r && (G.s.r = me.r), G.e.r < me.r && (G.e.r = me.r)), et ? (me = decode_cell(Ee.r), W["!data"][me.r] || (W["!data"][me.r] = []), W["!data"][me.r][me.c] = le) : W[Ee.r] = le;
            }
        }
      }
    }
    Oe.length > 0 && (W["!rows"] = Oe);
  };
}();
function write_ws_xml_data(F, x, w, O) {
  var D = [], U = [], W = safe_decode_range(F["!ref"]), X = "", G, Y = "", K = [], Z = 0, q = 0, J = F["!rows"], ee = F["!data"] != null, re = ee ? F["!data"] : [], te = { r: Y }, Q, oe = -1, ne = (((O || {}).Workbook || {}).WBProps || {}).date1904;
  for (q = W.s.c; q <= W.e.c; ++q) K[q] = encode_col(q);
  for (Z = W.s.r; Z <= W.e.r; ++Z) {
    U = [], Y = encode_row(Z);
    var le = ee ? re[Z] : [];
    for (q = W.s.c; q <= W.e.c; ++q) {
      G = K[q] + Y;
      var Ee = ee ? le[q] : F[G];
      Ee !== void 0 && (X = write_ws_xml_cell(Ee, G, F, x, w, O, ne)) != null && U.push(X);
    }
    (U.length > 0 || J && J[Z]) && (te = { r: Y }, J && J[Z] && (Q = J[Z], Q.hidden && (te.hidden = 1), oe = -1, Q.hpx ? oe = px2pt(Q.hpx) : Q.hpt && (oe = Q.hpt), oe > -1 && (te.ht = oe, te.customHeight = 1), Q.level && (te.outlineLevel = Q.level)), D[D.length] = writextag("row", U.join(""), te));
  }
  if (J) for (; Z < J.length; ++Z)
    J && J[Z] && (te = { r: Z + 1 }, Q = J[Z], Q.hidden && (te.hidden = 1), oe = -1, Q.hpx ? oe = px2pt(Q.hpx) : Q.hpt && (oe = Q.hpt), oe > -1 && (te.ht = oe, te.customHeight = 1), Q.level && (te.outlineLevel = Q.level), D[D.length] = writextag("row", "", te));
  return D.join("");
}
function write_ws_xml(F, x, w, O) {
  var D = [XML_HEADER, writextag("worksheet", null, {
    xmlns: XMLNS_main[0],
    "xmlns:r": XMLNS.r
  })], U = w.SheetNames[F], W = 0, X = "", G = w.Sheets[U];
  G == null && (G = {});
  var Y = G["!ref"] || "A1", K = safe_decode_range(Y);
  if (K.e.c > 16383 || K.e.r > 1048575) {
    if (x.WTF) throw new Error("Range " + Y + " exceeds format limit A1:XFD1048576");
    K.e.c = Math.min(K.e.c, 16383), K.e.r = Math.min(K.e.c, 1048575), Y = encode_range(K);
  }
  O || (O = {}), G["!comments"] = [];
  var Z = [];
  write_ws_xml_sheetpr(G, w, F, x, D), D[D.length] = writextag("dimension", null, { ref: Y }), D[D.length] = write_ws_xml_sheetviews(G, x, F, w), x.sheetFormat && (D[D.length] = writextag("sheetFormatPr", null, {
    defaultRowHeight: x.sheetFormat.defaultRowHeight || "16",
    baseColWidth: x.sheetFormat.baseColWidth || "10",
    outlineLevelRow: x.sheetFormat.outlineLevelRow || "7"
  })), G["!cols"] != null && G["!cols"].length > 0 && (D[D.length] = write_ws_xml_cols(G, G["!cols"])), D[W = D.length] = "<sheetData/>", G["!links"] = [], G["!ref"] != null && (X = write_ws_xml_data(G, x, F, w), X.length > 0 && (D[D.length] = X)), D.length > W + 1 && (D[D.length] = "</sheetData>", D[W] = D[W].replace("/>", ">")), G["!protect"] && (D[D.length] = write_ws_xml_protection(G["!protect"])), G["!autofilter"] != null && (D[D.length] = write_ws_xml_autofilter(G["!autofilter"], G, w, F)), G["!merges"] != null && G["!merges"].length > 0 && (D[D.length] = write_ws_xml_merges(G["!merges"]));
  var q = -1, J, ee = -1;
  return (
    /*::(*/
    G["!links"].length > 0 && (D[D.length] = "<hyperlinks>", G["!links"].forEach(function(re) {
      re[1].Target && (J = { ref: re[0] }, re[1].Target.charAt(0) != "#" && (ee = add_rels(O, -1, escapexml(re[1].Target).replace(/#[\s\S]*$/, ""), RELS.HLINK), J["r:id"] = "rId" + ee), (q = re[1].Target.indexOf("#")) > -1 && (J.location = escapexml(re[1].Target.slice(q + 1))), re[1].Tooltip && (J.tooltip = escapexml(re[1].Tooltip)), J.display = re[1].display, D[D.length] = writextag("hyperlink", null, J));
    }), D[D.length] = "</hyperlinks>"), delete G["!links"], G["!margins"] != null && (D[D.length] = write_ws_xml_margins(G["!margins"])), (!x || x.ignoreEC || x.ignoreEC == null) && (D[D.length] = writetag("ignoredErrors", writextag("ignoredError", null, { numberStoredAsText: 1, sqref: Y }))), Z.length > 0 && (ee = add_rels(O, -1, "../drawings/drawing" + (F + 1) + ".xml", RELS.DRAW), D[D.length] = writextag("drawing", null, { "r:id": "rId" + ee }), G["!drawing"] = Z), G["!comments"].length > 0 && (ee = add_rels(O, -1, "../drawings/vmlDrawing" + (F + 1) + ".vml", RELS.VML), D[D.length] = writextag("legacyDrawing", null, { "r:id": "rId" + ee }), G["!legacy"] = ee), D.length > 1 && (D[D.length] = "</worksheet>", D[1] = D[1].replace("/>", ">")), D.join("")
  );
}
function parse_BrtRowHdr(F, x) {
  var w = {}, O = F.l + x;
  w.r = F.read_shift(4), F.l += 4;
  var D = F.read_shift(2);
  F.l += 1;
  var U = F.read_shift(1);
  return F.l = O, U & 7 && (w.level = U & 7), U & 16 && (w.hidden = !0), U & 32 && (w.hpt = D / 20), w;
}
function write_BrtRowHdr(F, x, w) {
  var O = new_buf(145), D = (w["!rows"] || [])[F] || {};
  O.write_shift(4, F), O.write_shift(4, 0);
  var U = 320;
  D.hpx ? U = px2pt(D.hpx) * 20 : D.hpt && (U = D.hpt * 20), O.write_shift(2, U), O.write_shift(1, 0);
  var W = 0;
  D.level && (W |= D.level), D.hidden && (W |= 16), (D.hpx || D.hpt) && (W |= 32), O.write_shift(1, W), O.write_shift(1, 0);
  var X = 0, G = O.l;
  O.l += 4;
  for (var Y = { r: F, c: 0 }, K = w["!data"] != null, Z = 0; Z < 16; ++Z)
    if (!(x.s.c > Z + 1 << 10 || x.e.c < Z << 10)) {
      for (var q = -1, J = -1, ee = Z << 10; ee < Z + 1 << 10; ++ee) {
        Y.c = ee;
        var re = K ? (w["!data"][Y.r] || [])[Y.c] : w[encode_cell(Y)];
        re && (q < 0 && (q = ee), J = ee);
      }
      q < 0 || (++X, O.write_shift(4, q), O.write_shift(4, J));
    }
  var te = O.l;
  return O.l = G, O.write_shift(4, X), O.l = te, O.length > O.l ? O.slice(0, O.l) : O;
}
function write_row_header(F, x, w, O) {
  var D = write_BrtRowHdr(O, w, x);
  (D.length > 17 || (x["!rows"] || [])[O]) && write_record(F, 0, D);
}
var parse_BrtWsDim = parse_UncheckedRfX, write_BrtWsDim = write_UncheckedRfX;
function parse_BrtWsFmtInfo() {
}
function parse_BrtWsProp(F, x) {
  var w = {}, O = F[F.l];
  return ++F.l, w.above = !(O & 64), w.left = !(O & 128), F.l += 18, w.name = parse_XLSBCodeName(F), w;
}
function write_BrtWsProp(F, x, w) {
  w == null && (w = new_buf(84 + 4 * F.length));
  var O = 192;
  x && (x.above && (O &= -65), x.left && (O &= -129)), w.write_shift(1, O);
  for (var D = 1; D < 3; ++D) w.write_shift(1, 0);
  return write_BrtColor({ auto: 1 }, w), w.write_shift(-4, -1), w.write_shift(-4, -1), write_XLSBCodeName(F, w), w.slice(0, w.l);
}
function parse_BrtCellBlank(F) {
  var x = parse_XLSBCell(F);
  return [x];
}
function write_BrtCellBlank(F, x, w) {
  return w == null && (w = new_buf(8)), write_XLSBCell(x, w);
}
function parse_BrtShortBlank(F) {
  var x = parse_XLSBShortCell(F);
  return [x];
}
function write_BrtShortBlank(F, x, w) {
  return w == null && (w = new_buf(4)), write_XLSBShortCell(x, w);
}
function parse_BrtCellBool(F) {
  var x = parse_XLSBCell(F), w = F.read_shift(1);
  return [x, w, "b"];
}
function write_BrtCellBool(F, x, w) {
  return w == null && (w = new_buf(9)), write_XLSBCell(x, w), w.write_shift(1, F.v ? 1 : 0), w;
}
function parse_BrtShortBool(F) {
  var x = parse_XLSBShortCell(F), w = F.read_shift(1);
  return [x, w, "b"];
}
function write_BrtShortBool(F, x, w) {
  return w == null && (w = new_buf(5)), write_XLSBShortCell(x, w), w.write_shift(1, F.v ? 1 : 0), w;
}
function parse_BrtCellError(F) {
  var x = parse_XLSBCell(F), w = F.read_shift(1);
  return [x, w, "e"];
}
function write_BrtCellError(F, x, w) {
  return w == null && (w = new_buf(9)), write_XLSBCell(x, w), w.write_shift(1, F.v), w;
}
function parse_BrtShortError(F) {
  var x = parse_XLSBShortCell(F), w = F.read_shift(1);
  return [x, w, "e"];
}
function write_BrtShortError(F, x, w) {
  return w == null && (w = new_buf(8)), write_XLSBShortCell(x, w), w.write_shift(1, F.v), w.write_shift(2, 0), w.write_shift(1, 0), w;
}
function parse_BrtCellIsst(F) {
  var x = parse_XLSBCell(F), w = F.read_shift(4);
  return [x, w, "s"];
}
function write_BrtCellIsst(F, x, w) {
  return w == null && (w = new_buf(12)), write_XLSBCell(x, w), w.write_shift(4, x.v), w;
}
function parse_BrtShortIsst(F) {
  var x = parse_XLSBShortCell(F), w = F.read_shift(4);
  return [x, w, "s"];
}
function write_BrtShortIsst(F, x, w) {
  return w == null && (w = new_buf(8)), write_XLSBShortCell(x, w), w.write_shift(4, x.v), w;
}
function parse_BrtCellReal(F) {
  var x = parse_XLSBCell(F), w = parse_Xnum(F);
  return [x, w, "n"];
}
function write_BrtCellReal(F, x, w) {
  return w == null && (w = new_buf(16)), write_XLSBCell(x, w), write_Xnum(F.v, w), w;
}
function parse_BrtShortReal(F) {
  var x = parse_XLSBShortCell(F), w = parse_Xnum(F);
  return [x, w, "n"];
}
function write_BrtShortReal(F, x, w) {
  return w == null && (w = new_buf(12)), write_XLSBShortCell(x, w), write_Xnum(F.v, w), w;
}
function parse_BrtCellRk(F) {
  var x = parse_XLSBCell(F), w = parse_RkNumber(F);
  return [x, w, "n"];
}
function write_BrtCellRk(F, x, w) {
  return w == null && (w = new_buf(12)), write_XLSBCell(x, w), write_RkNumber(F.v, w), w;
}
function parse_BrtShortRk(F) {
  var x = parse_XLSBShortCell(F), w = parse_RkNumber(F);
  return [x, w, "n"];
}
function write_BrtShortRk(F, x, w) {
  return w == null && (w = new_buf(8)), write_XLSBShortCell(x, w), write_RkNumber(F.v, w), w;
}
function parse_BrtCellRString(F) {
  var x = parse_XLSBCell(F), w = parse_RichStr(F);
  return [x, w, "is"];
}
function parse_BrtCellSt(F) {
  var x = parse_XLSBCell(F), w = parse_XLWideString(F);
  return [x, w, "str"];
}
function write_BrtCellSt(F, x, w) {
  var O = F.v == null ? "" : String(F.v);
  return w == null && (w = new_buf(12 + 4 * F.v.length)), write_XLSBCell(x, w), write_XLWideString(O, w), w.length > w.l ? w.slice(0, w.l) : w;
}
function parse_BrtShortSt(F) {
  var x = parse_XLSBShortCell(F), w = parse_XLWideString(F);
  return [x, w, "str"];
}
function write_BrtShortSt(F, x, w) {
  var O = F.v == null ? "" : String(F.v);
  return w == null && (w = new_buf(8 + 4 * O.length)), write_XLSBShortCell(x, w), write_XLWideString(O, w), w.length > w.l ? w.slice(0, w.l) : w;
}
function parse_BrtFmlaBool(F, x, w) {
  var O = F.l + x, D = parse_XLSBCell(F);
  D.r = w["!row"];
  var U = F.read_shift(1), W = [D, U, "b"];
  if (w.cellFormula) {
    F.l += 2;
    var X = parse_XLSBCellParsedFormula(F, O - F.l, w);
    W[3] = stringify_formula(X, null, D, w.supbooks, w);
  } else F.l = O;
  return W;
}
function parse_BrtFmlaError(F, x, w) {
  var O = F.l + x, D = parse_XLSBCell(F);
  D.r = w["!row"];
  var U = F.read_shift(1), W = [D, U, "e"];
  if (w.cellFormula) {
    F.l += 2;
    var X = parse_XLSBCellParsedFormula(F, O - F.l, w);
    W[3] = stringify_formula(X, null, D, w.supbooks, w);
  } else F.l = O;
  return W;
}
function parse_BrtFmlaNum(F, x, w) {
  var O = F.l + x, D = parse_XLSBCell(F);
  D.r = w["!row"];
  var U = parse_Xnum(F), W = [D, U, "n"];
  if (w.cellFormula) {
    F.l += 2;
    var X = parse_XLSBCellParsedFormula(F, O - F.l, w);
    W[3] = stringify_formula(X, null, D, w.supbooks, w);
  } else F.l = O;
  return W;
}
function parse_BrtFmlaString(F, x, w) {
  var O = F.l + x, D = parse_XLSBCell(F);
  D.r = w["!row"];
  var U = parse_XLWideString(F), W = [D, U, "str"];
  if (w.cellFormula) {
    F.l += 2;
    var X = parse_XLSBCellParsedFormula(F, O - F.l, w);
    W[3] = stringify_formula(X, null, D, w.supbooks, w);
  } else F.l = O;
  return W;
}
var parse_BrtMergeCell = parse_UncheckedRfX, write_BrtMergeCell = write_UncheckedRfX;
function write_BrtBeginMergeCells(F, x) {
  return x == null && (x = new_buf(4)), x.write_shift(4, F), x;
}
function parse_BrtHLink(F, x) {
  var w = F.l + x, O = parse_UncheckedRfX(F), D = parse_XLNullableWideString(F), U = parse_XLWideString(F), W = parse_XLWideString(F), X = parse_XLWideString(F);
  F.l = w;
  var G = { rfx: O, relId: D, loc: U, display: X };
  return W && (G.Tooltip = W), G;
}
function write_BrtHLink(F, x) {
  var w = new_buf(50 + 4 * (F[1].Target.length + (F[1].Tooltip || "").length));
  write_UncheckedRfX({ s: decode_cell(F[0]), e: decode_cell(F[0]) }, w), write_RelID("rId" + x, w);
  var O = F[1].Target.indexOf("#"), D = O == -1 ? "" : F[1].Target.slice(O + 1);
  return write_XLWideString(D || "", w), write_XLWideString(F[1].Tooltip || "", w), write_XLWideString("", w), w.slice(0, w.l);
}
function parse_BrtPane() {
}
function parse_BrtArrFmla(F, x, w) {
  var O = F.l + x, D = parse_RfX(F), U = F.read_shift(1), W = [D];
  if (W[2] = U, w.cellFormula) {
    var X = parse_XLSBArrayParsedFormula(F, O - F.l, w);
    W[1] = X;
  } else F.l = O;
  return W;
}
function parse_BrtShrFmla(F, x, w) {
  var O = F.l + x, D = parse_UncheckedRfX(F), U = [D];
  if (w.cellFormula) {
    var W = parse_XLSBSharedParsedFormula(F, O - F.l, w);
    U[1] = W, F.l = O;
  } else F.l = O;
  return U;
}
function write_BrtColInfo(F, x, w) {
  w == null && (w = new_buf(18));
  var O = col_obj_w(F, x);
  w.write_shift(-4, F), w.write_shift(-4, F), w.write_shift(4, (O.width || 10) * 256), w.write_shift(
    4,
    0
    /*ixfe*/
  );
  var D = 0;
  return x.hidden && (D |= 1), typeof O.width == "number" && (D |= 2), x.level && (D |= x.level << 8), w.write_shift(2, D), w;
}
var BrtMarginKeys = ["left", "right", "top", "bottom", "header", "footer"];
function parse_BrtMargins(F) {
  var x = {};
  return BrtMarginKeys.forEach(function(w) {
    x[w] = parse_Xnum(F);
  }), x;
}
function write_BrtMargins(F, x) {
  return x == null && (x = new_buf(48)), default_margins(F), BrtMarginKeys.forEach(function(w) {
    write_Xnum(F[w], x);
  }), x;
}
function parse_BrtBeginWsView(F) {
  var x = F.read_shift(2);
  return F.l += 28, { RTL: x & 32 };
}
function write_BrtBeginWsView(F, x, w) {
  w == null && (w = new_buf(30));
  var O = 924;
  return (((x || {}).Views || [])[0] || {}).RTL && (O |= 32), w.write_shift(2, O), w.write_shift(4, 0), w.write_shift(4, 0), w.write_shift(4, 0), w.write_shift(1, 0), w.write_shift(1, 0), w.write_shift(2, 0), w.write_shift(2, 100), w.write_shift(2, 0), w.write_shift(2, 0), w.write_shift(2, 0), w.write_shift(4, 0), w;
}
function write_BrtCellIgnoreEC(F) {
  var x = new_buf(24);
  return x.write_shift(4, 4), x.write_shift(4, 1), write_UncheckedRfX(F, x), x;
}
function write_BrtSheetProtection(F, x) {
  return x == null && (x = new_buf(66)), x.write_shift(2, F.password ? crypto_CreatePasswordVerifier_Method1(F.password) : 0), x.write_shift(4, 1), [
    ["objects", !1],
    // fObjects
    ["scenarios", !1],
    // fScenarios
    ["formatCells", !0],
    // fFormatCells
    ["formatColumns", !0],
    // fFormatColumns
    ["formatRows", !0],
    // fFormatRows
    ["insertColumns", !0],
    // fInsertColumns
    ["insertRows", !0],
    // fInsertRows
    ["insertHyperlinks", !0],
    // fInsertHyperlinks
    ["deleteColumns", !0],
    // fDeleteColumns
    ["deleteRows", !0],
    // fDeleteRows
    ["selectLockedCells", !1],
    // fSelLockedCells
    ["sort", !0],
    // fSort
    ["autoFilter", !0],
    // fAutoFilter
    ["pivotTables", !0],
    // fPivotTables
    ["selectUnlockedCells", !1]
    // fSelUnlockedCells
  ].forEach(function(w) {
    w[1] ? x.write_shift(4, F[w[0]] != null && !F[w[0]] ? 1 : 0) : x.write_shift(4, F[w[0]] != null && F[w[0]] ? 0 : 1);
  }), x;
}
function parse_BrtDVal() {
}
function parse_BrtDVal14() {
}
function parse_ws_bin(F, x, w, O, D, U, W) {
  if (!F) return F;
  var X = x || {};
  O || (O = { "!id": {} });
  var G = {};
  X.dense && (G["!data"] = []);
  var Y, K = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, Z = !1, q = !1, J, ee, re, te, Q, oe, ne, le, Ee, Te = [];
  X.biff = 12, X["!row"] = 0;
  var de = 0, ae = !1, se = [], ce = {}, xe = X.supbooks || /*::(*/
  D.supbooks || [[]];
  if (xe.sharedf = ce, xe.arrayf = se, xe.SheetNames = D.SheetNames || D.Sheets.map(function(He) {
    return He.name;
  }), !X.supbooks && (X.supbooks = xe, D.Names))
    for (var Ce = 0; Ce < D.Names.length; ++Ce) xe[0][Ce + 1] = D.Names[Ce];
  var ye = [], ze = [], De = !1;
  XLSBRecordEnum[16] = { n: "BrtShortReal", f: parse_BrtShortReal };
  var et, Oe = 1462 * +!!((D || {}).WBProps || {}).date1904;
  if (recordhopper(F, function(Ae, qe, Ue) {
    if (!q)
      switch (Ue) {
        case 148:
          Y = Ae;
          break;
        case 0:
          J = Ae, X.sheetRows && X.sheetRows <= J.r && (q = !0), le = encode_row(te = J.r), X["!row"] = J.r, (Ae.hidden || Ae.hpt || Ae.level != null) && (Ae.hpt && (Ae.hpx = pt2px(Ae.hpt)), ze[Ae.r] = Ae);
          break;
        case 2:
        /* 'BrtCellRk' */
        case 3:
        /* 'BrtCellError' */
        case 4:
        /* 'BrtCellBool' */
        case 5:
        /* 'BrtCellReal' */
        case 6:
        /* 'BrtCellSt' */
        case 7:
        /* 'BrtCellIsst' */
        case 8:
        /* 'BrtFmlaString' */
        case 9:
        /* 'BrtFmlaNum' */
        case 10:
        /* 'BrtFmlaBool' */
        case 11:
        /* 'BrtFmlaError' */
        case 13:
        /* 'BrtShortRk' */
        case 14:
        /* 'BrtShortError' */
        case 15:
        /* 'BrtShortBool' */
        case 16:
        /* 'BrtShortReal' */
        case 17:
        /* 'BrtShortSt' */
        case 18:
        /* 'BrtShortIsst' */
        case 62:
          switch (ee = { t: Ae[2] }, Ae[2]) {
            case "n":
              ee.v = Ae[1];
              break;
            case "s":
              ne = strs[Ae[1]], ee.v = ne.t, ee.r = ne.r;
              break;
            case "b":
              ee.v = !!Ae[1];
              break;
            case "e":
              ee.v = Ae[1], X.cellText !== !1 && (ee.w = BErr[ee.v]);
              break;
            case "str":
              ee.t = "s", ee.v = Ae[1];
              break;
            case "is":
              ee.t = "s", ee.v = Ae[1].t;
              break;
          }
          if ((re = W.CellXf[Ae[0].iStyleRef]) && safe_format(ee, re.numFmtId, null, X, U, W, Oe > 0), Q = Ae[0].c == -1 ? Q + 1 : Ae[0].c, X.dense ? (G["!data"][te] || (G["!data"][te] = []), G["!data"][te][Q] = ee) : G[encode_col(Q) + le] = ee, X.cellFormula) {
            for (ae = !1, de = 0; de < se.length; ++de) {
              var Re = se[de];
              J.r >= Re[0].s.r && J.r <= Re[0].e.r && Q >= Re[0].s.c && Q <= Re[0].e.c && (ee.F = encode_range(Re[0]), ae = !0);
            }
            !ae && Ae.length > 3 && (ee.f = Ae[3]);
          }
          if (K.s.r > J.r && (K.s.r = J.r), K.s.c > Q && (K.s.c = Q), K.e.r < J.r && (K.e.r = J.r), K.e.c < Q && (K.e.c = Q), X.cellDates && re && ee.t == "n" && fmt_is_date(table_fmt[re.numFmtId])) {
            var Me = SSF_parse_date_code(ee.v + Oe);
            Me && (ee.t = "d", ee.v = new Date(Date.UTC(Me.y, Me.m - 1, Me.d, Me.H, Me.M, Me.S, Me.u)));
          }
          et && (et.type == "XLDAPR" && (ee.D = !0), et = void 0);
          break;
        case 1:
        /* 'BrtCellBlank' */
        case 12:
          if (!X.sheetStubs || Z) break;
          ee = { t: "z", v: void 0 }, Q = Ae[0].c == -1 ? Q + 1 : Ae[0].c, X.dense ? (G["!data"][te] || (G["!data"][te] = []), G["!data"][te][Q] = ee) : G[encode_col(Q) + le] = ee, K.s.r > J.r && (K.s.r = J.r), K.s.c > Q && (K.s.c = Q), K.e.r < J.r && (K.e.r = J.r), K.e.c < Q && (K.e.c = Q), et && (et.type == "XLDAPR" && (ee.D = !0), et = void 0);
          break;
        case 176:
          Te.push(Ae);
          break;
        case 49:
          et = ((X.xlmeta || {}).Cell || [])[Ae - 1];
          break;
        case 494:
          var je = O["!id"][Ae.relId];
          for (je ? (Ae.Target = je.Target, Ae.loc && (Ae.Target += "#" + Ae.loc), Ae.Rel = je) : Ae.relId == "" && (Ae.Target = "#" + Ae.loc), te = Ae.rfx.s.r; te <= Ae.rfx.e.r; ++te) for (Q = Ae.rfx.s.c; Q <= Ae.rfx.e.c; ++Q)
            X.dense ? (G["!data"][te] || (G["!data"][te] = []), G["!data"][te][Q] || (G["!data"][te][Q] = { t: "z", v: void 0 }), G["!data"][te][Q].l = Ae) : (oe = encode_col(Q) + encode_row(te), G[oe] || (G[oe] = { t: "z", v: void 0 }), G[oe].l = Ae);
          break;
        case 426:
          if (!X.cellFormula) break;
          se.push(Ae), Ee = X.dense ? G["!data"][te][Q] : G[encode_col(Q) + le], Ee.f = stringify_formula(Ae[1], K, { r: J.r, c: Q }, xe, X), Ee.F = encode_range(Ae[0]);
          break;
        case 427:
          if (!X.cellFormula) break;
          ce[encode_cell(Ae[0].s)] = Ae[1], Ee = X.dense ? G["!data"][te][Q] : G[encode_col(Q) + le], Ee.f = stringify_formula(Ae[1], K, { r: J.r, c: Q }, xe, X);
          break;
        /* identical to 'ColInfo' in XLS */
        case 60:
          if (!X.cellStyles) break;
          for (; Ae.e >= Ae.s; )
            ye[Ae.e--] = { width: Ae.w / 256, hidden: !!(Ae.flags & 1), level: Ae.level }, De || (De = !0, find_mdw_colw(Ae.w / 256)), process_col(ye[Ae.e + 1]);
          break;
        case 551:
          Ae && (G["!legrel"] = Ae);
          break;
        case 161:
          G["!autofilter"] = { ref: encode_range(Ae) };
          break;
        case 476:
          G["!margins"] = Ae;
          break;
        case 147:
          D.Sheets[w] || (D.Sheets[w] = {}), Ae.name && (D.Sheets[w].CodeName = Ae.name), (Ae.above || Ae.left) && (G["!outline"] = { above: Ae.above, left: Ae.left });
          break;
        case 137:
          D.Views || (D.Views = [{}]), D.Views[0] || (D.Views[0] = {}), Ae.RTL && (D.Views[0].RTL = !0);
          break;
        case 485:
          break;
        case 64:
        /* 'BrtDVal' */
        case 1053:
          break;
        case 151:
          break;
        case 152:
        /* 'BrtSel' */
        case 175:
        /* 'BrtAFilterDateGroupItem' */
        case 644:
        /* 'BrtActiveX' */
        case 625:
        /* 'BrtBigName' */
        case 562:
        /* 'BrtBkHim' */
        case 396:
        /* 'BrtBrk' */
        case 1112:
        /* 'BrtCFIcon' */
        case 1146:
        /* 'BrtCFRuleExt' */
        case 471:
        /* 'BrtCFVO' */
        case 1050:
        /* 'BrtCFVO14' */
        case 649:
        /* 'BrtCellIgnoreEC' */
        case 1105:
        /* 'BrtCellIgnoreEC14' */
        case 589:
        /* 'BrtCellSmartTagProperty' */
        case 607:
        /* 'BrtCellWatch' */
        case 564:
        /* 'BrtColor' */
        case 1055:
        /* 'BrtColor14' */
        case 168:
        /* 'BrtColorFilter' */
        case 174:
        /* 'BrtCustomFilter' */
        case 1180:
        /* 'BrtCustomFilter14' */
        case 499:
        /* 'BrtDRef' */
        case 507:
        /* 'BrtDXF' */
        case 550:
        /* 'BrtDrawing' */
        case 171:
        /* 'BrtDynamicFilter' */
        case 167:
        /* 'BrtFilter' */
        case 1177:
        /* 'BrtFilter14' */
        case 169:
        /* 'BrtIconFilter' */
        case 1181:
        /* 'BrtIconFilter14' */
        case 552:
        /* 'BrtLegacyDrawingHF' */
        case 661:
        /* 'BrtListPart' */
        case 639:
        /* 'BrtOleObject' */
        case 478:
        /* 'BrtPageSetup' */
        case 537:
        /* 'BrtPhoneticInfo' */
        case 477:
        /* 'BrtPrintOptions' */
        case 536:
        /* 'BrtRangeProtection' */
        case 1103:
        /* 'BrtRangeProtection14' */
        case 680:
        /* 'BrtRangeProtectionIso' */
        case 1104:
        /* 'BrtRangeProtectionIso14' */
        case 1024:
        /* 'BrtRwDescent' */
        case 663:
        /* 'BrtSheetCalcProp' */
        case 535:
        /* 'BrtSheetProtection' */
        case 678:
        /* 'BrtSheetProtectionIso' */
        case 504:
        /* 'BrtSlc' */
        case 1043:
        /* 'BrtSparkline' */
        case 428:
        /* 'BrtTable' */
        case 170:
        /* 'BrtTop10Filter' */
        case 3072:
        /* 'BrtUid' */
        case 50:
        /* 'BrtValueMeta' */
        case 2070:
        /* 'BrtWebExtension' */
        case 1045:
          break;
        case 35:
          Z = !0;
          break;
        case 36:
          Z = !1;
          break;
        case 37:
          Z = !0;
          break;
        case 38:
          Z = !1;
          break;
        default:
          if (!qe.T) {
            if (!Z || X.WTF) throw new Error("Unexpected record 0x" + Ue.toString(16));
          }
      }
  }, X), delete X.supbooks, delete X["!row"], !G["!ref"] && (K.s.r < 2e6 || Y && (Y.e.r > 0 || Y.e.c > 0 || Y.s.r > 0 || Y.s.c > 0)) && (G["!ref"] = encode_range(Y || K)), X.sheetRows && G["!ref"]) {
    var Xe = safe_decode_range(G["!ref"]);
    X.sheetRows <= +Xe.e.r && (Xe.e.r = X.sheetRows - 1, Xe.e.r > K.e.r && (Xe.e.r = K.e.r), Xe.e.r < Xe.s.r && (Xe.s.r = Xe.e.r), Xe.e.c > K.e.c && (Xe.e.c = K.e.c), Xe.e.c < Xe.s.c && (Xe.s.c = Xe.e.c), G["!fullref"] = G["!ref"], G["!ref"] = encode_range(Xe));
  }
  return Te.length > 0 && (G["!merges"] = Te), ye.length > 0 && (G["!cols"] = ye), ze.length > 0 && (G["!rows"] = ze), O["!id"][G["!legrel"]] && (G["!legdrawel"] = O["!id"][G["!legrel"]]), G;
}
function write_ws_bin_cell(F, x, w, O, D, U, W, X) {
  var G = { r: w, c: O };
  if (x.c && U["!comments"].push([encode_cell(G), x.c]), x.v === void 0) return !1;
  var Y = "";
  switch (x.t) {
    case "b":
      Y = x.v ? "1" : "0";
      break;
    case "d":
      x = dup(x), x.z = x.z || table_fmt[14], x.v = datenum(parseDate(x.v, X), X), x.t = "n";
      break;
    /* falls through */
    case "n":
    case "e":
      Y = "" + x.v;
      break;
    default:
      Y = x.v;
      break;
  }
  switch (G.s = get_cell_style(D.cellXfs, x, D), x.l && U["!links"].push([encode_cell(G), x.l]), x.t) {
    case "s":
    case "str":
      return D.bookSST ? (Y = get_sst_id(D.Strings, x.v == null ? "" : String(x.v), D.revStrings), G.t = "s", G.v = Y, W ? write_record(F, 18, write_BrtShortIsst(x, G)) : write_record(F, 7, write_BrtCellIsst(x, G))) : (G.t = "str", W ? write_record(F, 17, write_BrtShortSt(x, G)) : write_record(F, 6, write_BrtCellSt(x, G))), !0;
    case "n":
      return x.v == (x.v | 0) && x.v > -1e3 && x.v < 1e3 ? W ? write_record(F, 13, write_BrtShortRk(x, G)) : write_record(F, 2, write_BrtCellRk(x, G)) : isFinite(x.v) ? W ? write_record(F, 16, write_BrtShortReal(x, G)) : write_record(F, 5, write_BrtCellReal(x, G)) : (G.t = "e", isNaN(x.v) ? W ? write_record(F, 14, write_BrtShortError({ t: "e", v: 36 }, G)) : write_record(F, 3, write_BrtCellError({ t: "e", v: 36 }, G)) : W ? write_record(F, 14, write_BrtShortError({ t: "e", v: 7 }, G)) : write_record(F, 3, write_BrtCellError({ t: "e", v: 7 }, G))), !0;
    case "b":
      return G.t = "b", W ? write_record(F, 15, write_BrtShortBool(x, G)) : write_record(F, 4, write_BrtCellBool(x, G)), !0;
    case "e":
      return G.t = "e", W ? write_record(F, 14, write_BrtShortError(x, G)) : write_record(F, 3, write_BrtCellError(x, G)), !0;
  }
  return W ? write_record(F, 12, write_BrtShortBlank(x, G)) : write_record(F, 1, write_BrtCellBlank(x, G)), !0;
}
function write_CELLTABLE(F, x, w, O, D) {
  var U = safe_decode_range(x["!ref"] || "A1"), W = "", X = [], G = (((D || {}).Workbook || {}).WBProps || {}).date1904;
  write_record(
    F,
    145
    /* BrtBeginSheetData */
  );
  var Y = x["!data"] != null, K = Y ? x["!data"][U.s.r] : [], Z = U.e.r;
  x["!rows"] && (Z = Math.max(U.e.r, x["!rows"].length - 1));
  for (var q = U.s.r; q <= Z; ++q)
    if (W = encode_row(q), Y && (K = x["!data"][q]), write_row_header(F, x, U, q), !(Y && !K)) {
      var J = !1;
      if (q <= U.e.r) for (var ee = U.s.c; ee <= U.e.c; ++ee) {
        q === U.s.r && (X[ee] = encode_col(ee));
        var re = Y ? K[ee] : x[X[ee] + W];
        if (!re) {
          J = !1;
          continue;
        }
        J = write_ws_bin_cell(F, re, q, ee, O, x, J, G);
      }
    }
  write_record(
    F,
    146
    /* BrtEndSheetData */
  );
}
function write_MERGECELLS(F, x) {
  !x || !x["!merges"] || (write_record(F, 177, write_BrtBeginMergeCells(x["!merges"].length)), x["!merges"].forEach(function(w) {
    write_record(F, 176, write_BrtMergeCell(w));
  }), write_record(
    F,
    178
    /* BrtEndMergeCells */
  ));
}
function write_COLINFOS(F, x) {
  !x || !x["!cols"] || (write_record(
    F,
    390
    /* BrtBeginColInfos */
  ), x["!cols"].forEach(function(w, O) {
    w && write_record(F, 60, write_BrtColInfo(O, w));
  }), write_record(
    F,
    391
    /* BrtEndColInfos */
  ));
}
function write_IGNOREECS(F, x) {
  !x || !x["!ref"] || (write_record(
    F,
    648
    /* BrtBeginCellIgnoreECs */
  ), write_record(F, 649, write_BrtCellIgnoreEC(safe_decode_range(x["!ref"]))), write_record(
    F,
    650
    /* BrtEndCellIgnoreECs */
  ));
}
function write_HLINKS(F, x, w) {
  x["!links"].forEach(function(O) {
    if (O[1].Target) {
      var D = add_rels(w, -1, O[1].Target.replace(/#[\s\S]*$/, ""), RELS.HLINK);
      write_record(F, 494, write_BrtHLink(O, D));
    }
  }), delete x["!links"];
}
function write_LEGACYDRAWING(F, x, w, O) {
  if (x["!comments"].length > 0) {
    var D = add_rels(O, -1, "../drawings/vmlDrawing" + (w + 1) + ".vml", RELS.VML);
    write_record(F, 551, write_RelID("rId" + D)), x["!legacy"] = D;
  }
}
function write_AUTOFILTER(F, x, w, O) {
  if (x["!autofilter"]) {
    var D = x["!autofilter"], U = typeof D.ref == "string" ? D.ref : encode_range(D.ref);
    w.Workbook || (w.Workbook = { Sheets: [] }), w.Workbook.Names || (w.Workbook.Names = []);
    var W = w.Workbook.Names, X = decode_range(U);
    X.s.r == X.e.r && (X.e.r = decode_range(x["!ref"]).e.r, U = encode_range(X));
    for (var G = 0; G < W.length; ++G) {
      var Y = W[G];
      if (Y.Name == "_xlnm._FilterDatabase" && Y.Sheet == O) {
        Y.Ref = formula_quote_sheet_name(w.SheetNames[O]) + "!" + fix_range(U);
        break;
      }
    }
    G == W.length && W.push({ Name: "_xlnm._FilterDatabase", Sheet: O, Ref: formula_quote_sheet_name(w.SheetNames[O]) + "!" + fix_range(U) }), write_record(F, 161, write_UncheckedRfX(safe_decode_range(U))), write_record(
      F,
      162
      /* BrtEndAFilter */
    );
  }
}
function write_WSVIEWS2(F, x, w) {
  write_record(
    F,
    133
    /* BrtBeginWsViews */
  ), write_record(F, 137, write_BrtBeginWsView(x, w)), write_record(
    F,
    138
    /* BrtEndWsView */
  ), write_record(
    F,
    134
    /* BrtEndWsViews */
  );
}
function write_SHEETPROTECT(F, x) {
  x["!protect"] && write_record(F, 535, write_BrtSheetProtection(x["!protect"]));
}
function write_ws_bin(F, x, w, O) {
  var D = buf_array(), U = w.SheetNames[F], W = w.Sheets[U] || {}, X = U;
  try {
    w && w.Workbook && (X = w.Workbook.Sheets[F].CodeName || X);
  } catch {
  }
  var G = safe_decode_range(W["!ref"] || "A1");
  if (G.e.c > 16383 || G.e.r > 1048575) {
    if (x.WTF) throw new Error("Range " + (W["!ref"] || "A1") + " exceeds format limit A1:XFD1048576");
    G.e.c = Math.min(G.e.c, 16383), G.e.r = Math.min(G.e.c, 1048575);
  }
  return W["!links"] = [], W["!comments"] = [], write_record(
    D,
    129
    /* BrtBeginSheet */
  ), (w.vbaraw || W["!outline"]) && write_record(D, 147, write_BrtWsProp(X, W["!outline"])), write_record(D, 148, write_BrtWsDim(G)), write_WSVIEWS2(D, W, w.Workbook), write_COLINFOS(D, W), write_CELLTABLE(D, W, F, x, w), write_SHEETPROTECT(D, W), write_AUTOFILTER(D, W, w, F), write_MERGECELLS(D, W), write_HLINKS(D, W, O), W["!margins"] && write_record(D, 476, write_BrtMargins(W["!margins"])), (!x || x.ignoreEC || x.ignoreEC == null) && write_IGNOREECS(D, W), write_LEGACYDRAWING(D, W, F, O), write_record(
    D,
    130
    /* BrtEndSheet */
  ), D.end();
}
function parse_Cache(F) {
  var x = [], w = F.match(/^<c:numCache>/), O;
  (F.match(/<c:pt idx="(\d*)"[^<>\/]*><c:v>([^<])<\/c:v><\/c:pt>/mg) || []).forEach(function(U) {
    var W = U.match(/<c:pt idx="(\d*)"[^<>\/]*><c:v>([^<]*)<\/c:v><\/c:pt>/);
    W && (x[+W[1]] = w ? +W[2] : W[2]);
  });
  var D = unescapexml((str_match_xml(F, "c:formatCode") || ["", "General"])[1]);
  return (str_match_ng(F, "<c:f>", "</c:f>") || []).forEach(function(U) {
    O = U.replace(/<[^<>]*>/g, "");
  }), [x, D, O];
}
function parse_chart(F, x, w, O, D, U) {
  var W = U || { "!type": "chart" };
  if (!F) return U;
  var X = 0, G = 0, Y = "A", K = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  return (str_match_ng(F, "<c:numCache>", "</c:numCache>") || []).forEach(function(Z) {
    var q = parse_Cache(Z);
    K.s.r = K.s.c = 0, K.e.c = X, Y = encode_col(X), q[0].forEach(function(J, ee) {
      W["!data"] ? (W["!data"][ee] || (W["!data"][ee] = []), W["!data"][ee][X] = { t: "n", v: J, z: q[1] }) : W[Y + encode_row(ee)] = { t: "n", v: J, z: q[1] }, G = ee;
    }), K.e.r < G && (K.e.r = G), ++X;
  }), X > 0 && (W["!ref"] = encode_range(K)), W;
}
function parse_cs_xml(F, x, w, O, D) {
  if (!F) return F;
  O || (O = { "!id": {} });
  var U = { "!type": "chart", "!drawel": null, "!rel": "" }, W, X = F.match(sheetprregex);
  return X && parse_ws_xml_sheetpr(X[0], U, D, w), (W = F.match(/drawing r:id="(.*?)"/)) && (U["!rel"] = W[1]), O["!id"][U["!rel"]] && (U["!drawel"] = O["!id"][U["!rel"]]), U;
}
function parse_BrtCsProp(F, x) {
  F.l += 10;
  var w = parse_XLWideString(F);
  return { name: w };
}
function parse_cs_bin(F, x, w, O, D) {
  if (!F) return F;
  O || (O = { "!id": {} });
  var U = { "!type": "chart", "!drawel": null, "!rel": "" }, W = !1;
  return recordhopper(F, function(G, Y, K) {
    switch (K) {
      case 550:
        U["!rel"] = G;
        break;
      case 651:
        D.Sheets[w] || (D.Sheets[w] = {}), G.name && (D.Sheets[w].CodeName = G.name);
        break;
      case 562:
      /* 'BrtBkHim' */
      case 652:
      /* 'BrtCsPageSetup' */
      case 669:
      /* 'BrtCsProtection' */
      case 679:
      /* 'BrtCsProtectionIso' */
      case 551:
      /* 'BrtLegacyDrawing' */
      case 552:
      /* 'BrtLegacyDrawingHF' */
      case 476:
      /* 'BrtMargins' */
      case 3072:
        break;
      case 35:
        W = !0;
        break;
      case 36:
        W = !1;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (!(Y.T > 0)) {
          if (!(Y.T < 0)) {
            if (!W || x.WTF) throw new Error("Unexpected record 0x" + K.toString(16));
          }
        }
    }
  }, x), O["!id"][U["!rel"]] && (U["!drawel"] = O["!id"][U["!rel"]]), U;
}
var WBPropsDef = [
  ["allowRefreshQuery", !1, "bool"],
  ["autoCompressPictures", !0, "bool"],
  ["backupFile", !1, "bool"],
  ["checkCompatibility", !1, "bool"],
  ["CodeName", ""],
  ["date1904", !1, "bool"],
  ["defaultThemeVersion", 0, "int"],
  ["filterPrivacy", !1, "bool"],
  ["hidePivotFieldList", !1, "bool"],
  ["promptedSolutions", !1, "bool"],
  ["publishItems", !1, "bool"],
  ["refreshAllConnections", !1, "bool"],
  ["saveExternalLinkValues", !0, "bool"],
  ["showBorderUnselectedTables", !0, "bool"],
  ["showInkAnnotation", !0, "bool"],
  ["showObjects", "all"],
  ["showPivotChartFilter", !1, "bool"],
  ["updateLinks", "userSet"]
], WBViewDef = [
  ["activeTab", 0, "int"],
  ["autoFilterDateGrouping", !0, "bool"],
  ["firstSheet", 0, "int"],
  ["minimized", !1, "bool"],
  ["showHorizontalScroll", !0, "bool"],
  ["showSheetTabs", !0, "bool"],
  ["showVerticalScroll", !0, "bool"],
  ["tabRatio", 600, "int"],
  ["visibility", "visible"]
  //window{Height,Width}, {x,y}Window
], SheetDef = [
  //['state', 'visible']
], CalcPrDef = [
  ["calcCompleted", "true"],
  ["calcMode", "auto"],
  ["calcOnSave", "true"],
  ["concurrentCalc", "true"],
  ["fullCalcOnLoad", "false"],
  ["fullPrecision", "true"],
  ["iterate", "false"],
  ["iterateCount", "100"],
  ["iterateDelta", "0.001"],
  ["refMode", "A1"]
];
function push_defaults_array(F, x) {
  for (var w = 0; w != F.length; ++w)
    for (var O = F[w], D = 0; D != x.length; ++D) {
      var U = x[D];
      if (O[U[0]] == null) O[U[0]] = U[1];
      else switch (U[2]) {
        case "bool":
          typeof O[U[0]] == "string" && (O[U[0]] = parsexmlbool(O[U[0]]));
          break;
        case "int":
          typeof O[U[0]] == "string" && (O[U[0]] = parseInt(O[U[0]], 10));
          break;
      }
    }
}
function push_defaults(F, x) {
  for (var w = 0; w != x.length; ++w) {
    var O = x[w];
    if (F[O[0]] == null) F[O[0]] = O[1];
    else switch (O[2]) {
      case "bool":
        typeof F[O[0]] == "string" && (F[O[0]] = parsexmlbool(F[O[0]]));
        break;
      case "int":
        typeof F[O[0]] == "string" && (F[O[0]] = parseInt(F[O[0]], 10));
        break;
    }
  }
}
function parse_wb_defaults(F) {
  push_defaults(F.WBProps, WBPropsDef), push_defaults(F.CalcPr, CalcPrDef), push_defaults_array(F.WBView, WBViewDef), push_defaults_array(F.Sheets, SheetDef), _ssfopts.date1904 = parsexmlbool(F.WBProps.date1904);
}
function safe1904(F) {
  return !F.Workbook || !F.Workbook.WBProps ? "false" : parsexmlbool(F.Workbook.WBProps.date1904) ? "true" : "false";
}
var badchars = /* @__PURE__ */ ":][*?/\\".split("");
function check_ws_name(F, x) {
  try {
    if (F == "") throw new Error("Sheet name cannot be blank");
    if (F.length > 31) throw new Error("Sheet name cannot exceed 31 chars");
    if (F.charCodeAt(0) == 39 || F.charCodeAt(F.length - 1) == 39) throw new Error("Sheet name cannot start or end with apostrophe (')");
    if (F.toLowerCase() == "history") throw new Error("Sheet name cannot be 'History'");
    badchars.forEach(function(w) {
      if (F.indexOf(w) != -1)
        throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
    });
  } catch (w) {
    throw w;
  }
  return !0;
}
function check_wb_names(F, x, w) {
  F.forEach(function(O, D) {
    check_ws_name(O);
    for (var U = 0; U < D; ++U) if (O == F[U]) throw new Error("Duplicate Sheet Name: " + O);
    if (w) {
      var W = x[D] && x[D].CodeName || O;
      if (W.charCodeAt(0) == 95 && W.length > 22) throw new Error("Bad Code Name: Worksheet" + W);
    }
  });
}
function check_wb(F) {
  if (!F || !F.SheetNames || !F.Sheets) throw new Error("Invalid Workbook");
  if (!F.SheetNames.length) throw new Error("Workbook is empty");
  var x = F.Workbook && F.Workbook.Sheets || [];
  check_wb_names(F.SheetNames, x, !!F.vbaraw);
  for (var w = 0; w < F.SheetNames.length; ++w) check_ws(F.Sheets[F.SheetNames[w]], F.SheetNames[w], w);
  F.SheetNames.forEach(function(O, D) {
    var U = F.Sheets[O];
    if (!(!U || !U["!autofilter"])) {
      var W;
      F.Workbook || (F.Workbook = {}), F.Workbook.Names || (F.Workbook.Names = []), F.Workbook.Names.forEach(function(G) {
        G.Name == "_xlnm._FilterDatabase" && G.Sheet == D && (W = G);
      });
      var X = formula_quote_sheet_name(O) + "!" + fix_range(U["!autofilter"].ref);
      W ? W.Ref = X : F.Workbook.Names.push({ Name: "_xlnm._FilterDatabase", Sheet: D, Ref: X });
    }
  });
}
var wbnsregex = /<\w+:workbook/;
function parse_wb_xml(F, x) {
  if (!F) throw new Error("Could not find file");
  var w = (
    /*::(*/
    { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, Names: [], xmlns: "" }
  ), O = !1, D = "xmlns", U = {}, W = 0;
  if (F.replace(tagregex, function(G, Y) {
    var K = parsexmltag(G);
    switch (strip_ns(K[0])) {
      case "<?xml":
        break;
      /* 18.2.27 workbook CT_Workbook 1 */
      case "<workbook":
        G.match(wbnsregex) && (D = "xmlns" + G.match(/<(\w+):/)[1]), w.xmlns = K[D];
        break;
      case "</workbook>":
        break;
      /* 18.2.13 fileVersion CT_FileVersion ? */
      case "<fileVersion":
        delete K[0], w.AppVersion = K;
        break;
      case "<fileVersion/>":
      case "</fileVersion>":
        break;
      /* 18.2.12 fileSharing CT_FileSharing ? */
      case "<fileSharing":
        break;
      case "<fileSharing/>":
        break;
      /* 18.2.28 workbookPr CT_WorkbookPr ? */
      case "<workbookPr":
      case "<workbookPr/>":
        WBPropsDef.forEach(function(Z) {
          if (K[Z[0]] != null)
            switch (Z[2]) {
              case "bool":
                w.WBProps[Z[0]] = parsexmlbool(K[Z[0]]);
                break;
              case "int":
                w.WBProps[Z[0]] = parseInt(K[Z[0]], 10);
                break;
              default:
                w.WBProps[Z[0]] = K[Z[0]];
            }
        }), K.codeName && (w.WBProps.CodeName = utf8read(K.codeName));
        break;
      case "</workbookPr>":
        break;
      /* 18.2.29 workbookProtection CT_WorkbookProtection ? */
      case "<workbookProtection":
        break;
      case "<workbookProtection/>":
        break;
      /* 18.2.1  bookViews CT_BookViews ? */
      case "<bookViews":
      case "<bookViews>":
      case "</bookViews>":
        break;
      /* 18.2.30   workbookView CT_BookView + */
      case "<workbookView":
      case "<workbookView/>":
        delete K[0], w.WBView.push(K);
        break;
      case "</workbookView>":
        break;
      /* 18.2.20 sheets CT_Sheets 1 */
      case "<sheets":
      case "<sheets>":
      case "</sheets>":
        break;
      // aggregate sheet
      /* 18.2.19   sheet CT_Sheet + */
      case "<sheet":
        switch (K.state) {
          case "hidden":
            K.Hidden = 1;
            break;
          case "veryHidden":
            K.Hidden = 2;
            break;
          default:
            K.Hidden = 0;
        }
        delete K.state, K.name = unescapexml(utf8read(K.name)), delete K[0], w.Sheets.push(K);
        break;
      case "</sheet>":
        break;
      /* 18.2.15 functionGroups CT_FunctionGroups ? */
      case "<functionGroups":
      case "<functionGroups/>":
        break;
      /* 18.2.14   functionGroup CT_FunctionGroup + */
      case "<functionGroup":
        break;
      /* 18.2.9  externalReferences CT_ExternalReferences ? */
      case "<externalReferences":
      case "</externalReferences>":
      case "<externalReferences>":
        break;
      /* 18.2.8    externalReference CT_ExternalReference + */
      case "<externalReference":
        break;
      /* 18.2.6  definedNames CT_DefinedNames ? */
      case "<definedNames/>":
        break;
      case "<definedNames>":
      case "<definedNames":
        O = !0;
        break;
      case "</definedNames>":
        O = !1;
        break;
      /* 18.2.5    definedName CT_DefinedName + */
      case "<definedName":
        U = {}, U.Name = utf8read(K.name), K.comment && (U.Comment = K.comment), K.localSheetId && (U.Sheet = +K.localSheetId), parsexmlbool(K.hidden || "0") && (U.Hidden = !0), W = Y + G.length;
        break;
      case "</definedName>":
        U.Ref = unescapexml(utf8read(F.slice(W, Y))), w.Names.push(U);
        break;
      case "<definedName/>":
        break;
      /* 18.2.2  calcPr CT_CalcPr ? */
      case "<calcPr":
        delete K[0], w.CalcPr = K;
        break;
      case "<calcPr/>":
        delete K[0], w.CalcPr = K;
        break;
      case "</calcPr>":
        break;
      /* 18.2.16 oleSize CT_OleSize ? (ref required) */
      case "<oleSize":
        break;
      /* 18.2.4  customWorkbookViews CT_CustomWorkbookViews ? */
      case "<customWorkbookViews>":
      case "</customWorkbookViews>":
      case "<customWorkbookViews":
        break;
      /* 18.2.3  customWorkbookView CT_CustomWorkbookView + */
      case "<customWorkbookView":
      case "</customWorkbookView>":
        break;
      /* 18.2.18 pivotCaches CT_PivotCaches ? */
      case "<pivotCaches>":
      case "</pivotCaches>":
      case "<pivotCaches":
        break;
      /* 18.2.17 pivotCache CT_PivotCache ? */
      case "<pivotCache":
        break;
      /* 18.2.21 smartTagPr CT_SmartTagPr ? */
      case "<smartTagPr":
      case "<smartTagPr/>":
        break;
      /* 18.2.23 smartTagTypes CT_SmartTagTypes ? */
      case "<smartTagTypes":
      case "<smartTagTypes>":
      case "</smartTagTypes>":
        break;
      /* 18.2.22 smartTagType CT_SmartTagType ? */
      case "<smartTagType":
        break;
      /* 18.2.24 webPublishing CT_WebPublishing ? */
      case "<webPublishing":
      case "<webPublishing/>":
        break;
      /* 18.2.11 fileRecoveryPr CT_FileRecoveryPr ? */
      case "<fileRecoveryPr":
      case "<fileRecoveryPr/>":
        break;
      /* 18.2.26 webPublishObjects CT_WebPublishObjects ? */
      case "<webPublishObjects>":
      case "<webPublishObjects":
      case "</webPublishObjects>":
        break;
      /* 18.2.25 webPublishObject CT_WebPublishObject ? */
      case "<webPublishObject":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      /* 18.2.7  ext CT_Extension + */
      case "<ext":
        O = !0;
        break;
      //TODO: check with versions of excel
      case "</ext>":
        O = !1;
        break;
      /* Others */
      case "<ArchID":
        break;
      case "<AlternateContent":
      case "<AlternateContent>":
        O = !0;
        break;
      case "</AlternateContent>":
        O = !1;
        break;
      /* TODO */
      case "<revisionPtr":
        break;
      default:
        if (!O && x.WTF) throw new Error("unrecognized " + K[0] + " in workbook");
    }
    return G;
  }), XMLNS_main.indexOf(w.xmlns) === -1) throw new Error("Unknown Namespace: " + w.xmlns);
  return parse_wb_defaults(w), w;
}
function write_wb_xml(F) {
  var x = [XML_HEADER];
  x[x.length] = writextag("workbook", null, {
    xmlns: XMLNS_main[0],
    //'xmlns:mx': XMLNS.mx,
    //'xmlns:s': XMLNS_main[0],
    "xmlns:r": XMLNS.r
  });
  var w = F.Workbook && (F.Workbook.Names || []).length > 0, O = { codeName: "ThisWorkbook" };
  F.Workbook && F.Workbook.WBProps && (WBPropsDef.forEach(function(X) {
    F.Workbook.WBProps[X[0]] != null && F.Workbook.WBProps[X[0]] != X[1] && (O[X[0]] = F.Workbook.WBProps[X[0]]);
  }), F.Workbook.WBProps.CodeName && (O.codeName = F.Workbook.WBProps.CodeName, delete O.CodeName)), x[x.length] = writextag("workbookPr", null, O);
  var D = F.Workbook && F.Workbook.Sheets || [], U = 0;
  if (D[0] && D[0].Hidden) {
    for (x[x.length] = "<bookViews>", U = 0; U != F.SheetNames.length && !(!D[U] || !D[U].Hidden); ++U)
      ;
    U == F.SheetNames.length && (U = 0), x[x.length] = '<workbookView firstSheet="' + U + '" activeTab="' + U + '"/>', x[x.length] = "</bookViews>";
  }
  for (x[x.length] = "<sheets>", U = 0; U != F.SheetNames.length; ++U) {
    var W = { name: escapexml(F.SheetNames[U].slice(0, 31)) };
    if (W.sheetId = "" + (U + 1), W["r:id"] = "rId" + (U + 1), D[U]) switch (D[U].Hidden) {
      case 1:
        W.state = "hidden";
        break;
      case 2:
        W.state = "veryHidden";
        break;
    }
    x[x.length] = writextag("sheet", null, W);
  }
  return x[x.length] = "</sheets>", w && (x[x.length] = "<definedNames>", F.Workbook && F.Workbook.Names && F.Workbook.Names.forEach(function(X) {
    var G = { name: X.Name };
    X.Comment && (G.comment = X.Comment), X.Sheet != null && (G.localSheetId = "" + X.Sheet), X.Hidden && (G.hidden = "1"), X.Ref && (x[x.length] = writextag("definedName", escapexml(X.Ref), G));
  }), x[x.length] = "</definedNames>"), x.length > 2 && (x[x.length] = "</workbook>", x[1] = x[1].replace("/>", ">")), x.join("");
}
function parse_BrtBundleSh(F, x) {
  var w = {};
  return w.Hidden = F.read_shift(4), w.iTabID = F.read_shift(4), w.strRelID = parse_RelID(F), w.name = parse_XLWideString(F), w;
}
function write_BrtBundleSh(F, x) {
  return x || (x = new_buf(127)), x.write_shift(4, F.Hidden), x.write_shift(4, F.iTabID), write_RelID(F.strRelID, x), write_XLWideString(F.name.slice(0, 31), x), x.length > x.l ? x.slice(0, x.l) : x;
}
function parse_BrtWbProp(F, x) {
  var w = {}, O = F.read_shift(4);
  w.defaultThemeVersion = F.read_shift(4);
  var D = x > 8 ? parse_XLWideString(F) : "";
  return D.length > 0 && (w.CodeName = D), w.autoCompressPictures = !!(O & 65536), w.backupFile = !!(O & 64), w.checkCompatibility = !!(O & 4096), w.date1904 = !!(O & 1), w.filterPrivacy = !!(O & 8), w.hidePivotFieldList = !!(O & 1024), w.promptedSolutions = !!(O & 16), w.publishItems = !!(O & 2048), w.refreshAllConnections = !!(O & 262144), w.saveExternalLinkValues = !!(O & 128), w.showBorderUnselectedTables = !!(O & 4), w.showInkAnnotation = !!(O & 32), w.showObjects = ["all", "placeholders", "none"][O >> 13 & 3], w.showPivotChartFilter = !!(O & 32768), w.updateLinks = ["userSet", "never", "always"][O >> 8 & 3], w;
}
function write_BrtWbProp(F, x) {
  x || (x = new_buf(72));
  var w = 0;
  return F && (F.date1904 && (w |= 1), F.filterPrivacy && (w |= 8)), x.write_shift(4, w), x.write_shift(4, 0), write_XLSBCodeName(F && F.CodeName || "ThisWorkbook", x), x.slice(0, x.l);
}
function parse_BrtFRTArchID$(F, x) {
  var w = {};
  return F.read_shift(4), w.ArchID = F.read_shift(4), F.l += x - 8, w;
}
function parse_BrtName(F, x, w) {
  var O = F.l + x, D = F.read_shift(4);
  F.l += 1;
  var U = F.read_shift(4), W = parse_XLNameWideString(F), X, G = "";
  try {
    X = parse_XLSBNameParsedFormula(F, 0, w);
    try {
      G = parse_XLNullableWideString(F);
    } catch {
    }
  } catch {
    console.error("Could not parse defined name " + W);
  }
  D & 32 && (W = "_xlnm." + W), F.l = O;
  var Y = { Name: W, Ptg: X, Flags: D };
  return U < 268435455 && (Y.Sheet = U), G && (Y.Comment = G), Y;
}
function write_BrtName(F, x) {
  var w = new_buf(9), O = 0, D = F.Name;
  XLSLblBuiltIn.indexOf(D) > -1 && (O |= 32, D = D.slice(6)), w.write_shift(4, O), w.write_shift(1, 0), w.write_shift(4, F.Sheet == null ? 4294967295 : F.Sheet);
  var U = [
    w,
    write_XLWideString(D),
    write_XLSBNameParsedFormula(F.Ref, x)
  ];
  if (F.Comment) U.push(write_XLNullableWideString(F.Comment));
  else {
    var W = new_buf(4);
    W.write_shift(4, 4294967295), U.push(W);
  }
  return bconcat(U);
}
function parse_wb_bin(F, x) {
  var w = { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, xmlns: "" }, O = [], D = !1;
  x || (x = {}), x.biff = 12;
  var U = [], W = [[]];
  return W.SheetNames = [], W.XTI = [], XLSBRecordEnum[16] = { n: "BrtFRTArchID$", f: parse_BrtFRTArchID$ }, recordhopper(F, function(G, Y, K) {
    switch (K) {
      case 156:
        W.SheetNames.push(G.name), w.Sheets.push(G);
        break;
      case 153:
        w.WBProps = G;
        break;
      case 39:
        G.Sheet != null && (x.SID = G.Sheet), G.Ref = G.Ptg ? stringify_formula(G.Ptg, null, null, W, x) : "#REF!", delete x.SID, delete G.Ptg, U.push(G);
        break;
      case 1036:
        break;
      case 357:
      /* 'BrtSupSelf' */
      case 358:
      /* 'BrtSupSame' */
      case 355:
      /* 'BrtSupBookSrc' */
      case 667:
        W[0].length ? W.push([K, G]) : W[0] = [K, G], W[W.length - 1].XTI = [];
        break;
      case 362:
        W.length === 0 && (W[0] = [], W[0].XTI = []), W[W.length - 1].XTI = W[W.length - 1].XTI.concat(G), W.XTI = W.XTI.concat(G);
        break;
      case 361:
        break;
      case 2071:
      /* 'BrtAbsPath15' */
      case 158:
      /* 'BrtBookView' */
      case 143:
      /* 'BrtBeginBundleShs' */
      case 664:
      /* 'BrtBeginFnGroup' */
      case 353:
        break;
      /* case 'BrtModelTimeGroupingCalcCol' */
      case 3072:
      /* 'BrtUid' */
      case 3073:
      /* 'BrtRevisionPtr' */
      case 534:
      /* 'BrtBookProtection' */
      case 677:
      /* 'BrtBookProtectionIso' */
      case 157:
      /* 'BrtCalcProp' */
      case 610:
      /* 'BrtCrashRecErr' */
      case 2050:
      /* 'BrtDecoupledPivotCacheID' */
      case 155:
      /* 'BrtFileRecover' */
      case 548:
      /* 'BrtFileSharing' */
      case 676:
      /* 'BrtFileSharingIso' */
      case 128:
      /* 'BrtFileVersion' */
      case 665:
      /* 'BrtFnGroup' */
      case 2128:
      /* 'BrtModelRelationship' */
      case 2125:
      /* 'BrtModelTable' */
      case 549:
      /* 'BrtOleSize' */
      case 2053:
      /* 'BrtPivotTableRef' */
      case 596:
      /* 'BrtSmartTagType' */
      case 2076:
      /* 'BrtTableSlicerCacheID' */
      case 2075:
      /* 'BrtTableSlicerCacheIDs' */
      case 2082:
      /* 'BrtTimelineCachePivotCacheID' */
      case 397:
      /* 'BrtUserBookView' */
      case 154:
      /* 'BrtWbFactoid' */
      case 1117:
      /* 'BrtWbProp14' */
      case 553:
      /* 'BrtWebOpt' */
      case 2091:
        break;
      case 35:
        O.push(K), D = !0;
        break;
      case 36:
        O.pop(), D = !1;
        break;
      case 37:
        O.push(K), D = !0;
        break;
      case 38:
        O.pop(), D = !1;
        break;
      case 16:
        break;
      default:
        if (!Y.T) {
          if (!D || x.WTF && O[O.length - 1] != 37 && O[O.length - 1] != 35) throw new Error("Unexpected record 0x" + K.toString(16));
        }
    }
  }, x), parse_wb_defaults(w), w.Names = U, w.supbooks = W, w;
}
function write_BUNDLESHS(F, x) {
  write_record(
    F,
    143
    /* BrtBeginBundleShs */
  );
  for (var w = 0; w != x.SheetNames.length; ++w) {
    var O = x.Workbook && x.Workbook.Sheets && x.Workbook.Sheets[w] && x.Workbook.Sheets[w].Hidden || 0, D = { Hidden: O, iTabID: w + 1, strRelID: "rId" + (w + 1), name: x.SheetNames[w] };
    write_record(F, 156, write_BrtBundleSh(D));
  }
  write_record(
    F,
    144
    /* BrtEndBundleShs */
  );
}
function write_BrtFileVersion(F, x) {
  x || (x = new_buf(127));
  for (var w = 0; w != 4; ++w) x.write_shift(4, 0);
  return write_XLWideString("SheetJS", x), write_XLWideString(XLSX.version, x), write_XLWideString(XLSX.version, x), write_XLWideString("7262", x), x.length > x.l ? x.slice(0, x.l) : x;
}
function write_BrtBookView(F, x) {
  x || (x = new_buf(29)), x.write_shift(-4, 0), x.write_shift(-4, 460), x.write_shift(4, 28800), x.write_shift(4, 17600), x.write_shift(4, 500), x.write_shift(4, F), x.write_shift(4, F);
  var w = 120;
  return x.write_shift(1, w), x.length > x.l ? x.slice(0, x.l) : x;
}
function write_BOOKVIEWS(F, x) {
  if (!(!x.Workbook || !x.Workbook.Sheets)) {
    for (var w = x.Workbook.Sheets, O = 0, D = -1, U = -1; O < w.length; ++O)
      !w[O] || !w[O].Hidden && D == -1 ? D = O : w[O].Hidden == 1 && U == -1 && (U = O);
    U > D || (write_record(
      F,
      135
      /* BrtBeginBookViews */
    ), write_record(F, 158, write_BrtBookView(D)), write_record(
      F,
      136
      /* BrtEndBookViews */
    ));
  }
}
function write_BRTNAMES(F, x) {
  !x.Workbook || !x.Workbook.Names || x.Workbook.Names.forEach(function(w) {
    try {
      if (w.Flags & 14) return;
      write_record(F, 39, write_BrtName(w, x));
    } catch {
      console.error("Could not serialize defined name " + JSON.stringify(w));
    }
  });
}
function write_SELF_EXTERNS_xlsb(F) {
  var x = F.SheetNames.length, w = new_buf(12 * x + 28);
  w.write_shift(4, x + 2), w.write_shift(4, 0), w.write_shift(4, -2), w.write_shift(4, -2), w.write_shift(4, 0), w.write_shift(4, -1), w.write_shift(4, -1);
  for (var O = 0; O < x; ++O)
    w.write_shift(4, 0), w.write_shift(4, O), w.write_shift(4, O);
  return w;
}
function write_EXTERNALS_xlsb(F, x) {
  write_record(
    F,
    353
    /* BrtBeginExternals */
  ), write_record(
    F,
    357
    /* BrtSupSelf */
  ), write_record(F, 362, write_SELF_EXTERNS_xlsb(x)), write_record(
    F,
    354
    /* BrtEndExternals */
  );
}
function write_wb_bin(F, x) {
  var w = buf_array();
  return write_record(
    w,
    131
    /* BrtBeginBook */
  ), write_record(w, 128, write_BrtFileVersion()), write_record(w, 153, write_BrtWbProp(F.Workbook && F.Workbook.WBProps || null)), write_BOOKVIEWS(w, F), write_BUNDLESHS(w, F), write_EXTERNALS_xlsb(w, F), (F.Workbook || {}).Names && write_BRTNAMES(w, F), write_record(
    w,
    132
    /* BrtEndBook */
  ), w.end();
}
function parse_wb(F, x, w) {
  return x.slice(-4) === ".bin" ? parse_wb_bin(F, w) : parse_wb_xml(F, w);
}
function parse_ws(F, x, w, O, D, U, W, X) {
  return x.slice(-4) === ".bin" ? parse_ws_bin(F, O, w, D, U, W, X) : parse_ws_xml(F, O, w, D, U, W, X);
}
function parse_cs(F, x, w, O, D, U, W, X) {
  return x.slice(-4) === ".bin" ? parse_cs_bin(F, O, w, D, U) : parse_cs_xml(F, O, w, D, U);
}
function parse_ms(F, x, w, O, D, U, W, X) {
  return x.slice(-4) === ".bin" ? parse_ms_bin() : parse_ms_xml();
}
function parse_ds(F, x, w, O, D, U, W, X) {
  return x.slice(-4) === ".bin" ? parse_ds_bin() : parse_ds_xml();
}
function parse_sty(F, x, w, O) {
  return x.slice(-4) === ".bin" ? parse_sty_bin(F, w, O) : parse_sty_xml(F, w, O);
}
function parse_sst(F, x, w) {
  return x.slice(-4) === ".bin" ? parse_sst_bin(F, w) : parse_sst_xml(F, w);
}
function parse_cmnt(F, x, w) {
  return x.slice(-4) === ".bin" ? parse_comments_bin(F, w) : parse_comments_xml(F, w);
}
function parse_cc(F, x, w) {
  return x.slice(-4) === ".bin" ? parse_cc_bin(F) : parse_cc_xml(F);
}
function parse_xlink(F, x, w, O) {
  return w.slice(-4) === ".bin" ? parse_xlink_bin(F, x, w, O) : void 0;
}
function parse_xlmeta(F, x, w) {
  return x.slice(-4) === ".bin" ? parse_xlmeta_bin(F, x, w) : parse_xlmeta_xml(F, x, w);
}
var attregexg2 = /\b((?:\w+:)?[\w]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g, attregex2 = /\b((?:\w+:)?[\w]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;
function xlml_parsexmltag(F, x) {
  var w = F.split(/\s+/), O = [];
  if (O[0] = w[0], w.length === 1) return O;
  var D = F.match(attregexg2), U, W, X, G;
  if (D) for (G = 0; G != D.length; ++G)
    U = D[G].match(attregex2), (W = U[1].indexOf(":")) === -1 ? O[U[1]] = U[2].slice(1, U[2].length - 1) : (U[1].slice(0, 6) === "xmlns:" ? X = "xmlns" + U[1].slice(6) : X = U[1].slice(W + 1), O[X] = U[2].slice(1, U[2].length - 1));
  return O;
}
function xlml_parsexmltagobj(F) {
  var x = F.split(/\s+/), w = {};
  if (x.length === 1) return w;
  var O = F.match(attregexg2), D, U, W, X;
  if (O) for (X = 0; X != O.length; ++X)
    D = O[X].match(attregex2), (U = D[1].indexOf(":")) === -1 ? w[D[1]] = D[2].slice(1, D[2].length - 1) : (D[1].slice(0, 6) === "xmlns:" ? W = "xmlns" + D[1].slice(6) : W = D[1].slice(U + 1), w[W] = D[2].slice(1, D[2].length - 1));
  return w;
}
var XLMLFormatMap;
function xlml_format(F, x, w) {
  var O = XLMLFormatMap[F] || unescapexml(F);
  return O === "General" ? SSF_general(x) : SSF_format(O, x, { date1904: !!w });
}
function xlml_set_custprop(F, x, w, O) {
  var D = O;
  switch ((w[0].match(/dt:dt="([\w.]+)"/) || ["", ""])[1]) {
    case "boolean":
      D = parsexmlbool(O);
      break;
    case "i2":
    case "int":
      D = parseInt(O, 10);
      break;
    case "r4":
    case "float":
      D = parseFloat(O);
      break;
    case "date":
    case "dateTime.tz":
      D = parseDate(O);
      break;
    case "i8":
    case "string":
    case "fixed":
    case "uuid":
    case "bin.base64":
      break;
    default:
      throw new Error("bad custprop:" + w[0]);
  }
  F[unescapexml(x)] = D;
}
function safe_format_xlml(F, x, w, O) {
  if (F.t !== "z") {
    if (!w || w.cellText !== !1) try {
      F.t === "e" ? F.w = F.w || BErr[F.v] : x === "General" ? F.t === "n" ? (F.v | 0) === F.v ? F.w = F.v.toString(10) : F.w = SSF_general_num(F.v) : F.w = SSF_general(F.v) : F.w = xlml_format(x || "General", F.v, O);
    } catch (W) {
      if (w.WTF) throw W;
    }
    try {
      var D = XLMLFormatMap[x] || x || "General";
      if (w.cellNF && (F.z = D), w.cellDates && F.t == "n" && fmt_is_date(D)) {
        var U = SSF_parse_date_code(F.v + (O ? 1462 : 0));
        U && (F.t = "d", F.v = new Date(Date.UTC(U.y, U.m - 1, U.d, U.H, U.M, U.S, U.u)));
      }
    } catch (W) {
      if (w.WTF) throw W;
    }
  }
}
function process_style_xlml(F, x, w) {
  if (w.cellStyles && x.Interior) {
    var O = x.Interior;
    O.Pattern && (O.patternType = XLMLPatternTypeMap[O.Pattern] || O.Pattern);
  }
  F[x.ID] = x;
}
function parse_xlml_data(F, x, w, O, D, U, W, X, G, Y, K) {
  var Z = "General", q = O.StyleID, J = {};
  Y = Y || {};
  var ee = [], re = 0;
  for (q === void 0 && X && (q = X.StyleID), q === void 0 && W && (q = W.StyleID); U[q] !== void 0; ) {
    var te = U[q];
    if (te.nf && (Z = te.nf), te.Interior && ee.push(te.Interior), !te.Parent) break;
    q = te.Parent;
  }
  switch (w.Type) {
    case "Boolean":
      O.t = "b", O.v = parsexmlbool(F);
      break;
    case "String":
      O.t = "s", O.r = xlml_fixstr(unescapexml(F)), O.v = F.indexOf("<") > -1 ? unescapexml(x || F).replace(/<[^<>]*>/g, "") : O.r;
      break;
    case "DateTime":
      F.slice(-1) != "Z" && (F += "Z"), O.v = datenum(parseDate(F, K), K), O.v !== O.v && (O.v = unescapexml(F)), (!Z || Z == "General") && (Z = "yyyy-mm-dd");
    /* falls through */
    case "Number":
      O.v === void 0 && (O.v = +F), O.t || (O.t = "n");
      break;
    case "Error":
      O.t = "e", O.v = RBErr[F], Y.cellText !== !1 && (O.w = F);
      break;
    default:
      F == "" && x == "" ? O.t = "z" : (O.t = "s", O.v = xlml_fixstr(x || F));
      break;
  }
  if (safe_format_xlml(O, Z, Y, K), Y.cellFormula !== !1)
    if (O.Formula) {
      var Q = unescapexml(O.Formula);
      Q.charCodeAt(0) == 61 && (Q = Q.slice(1)), O.f = rc_to_a1(Q, D), delete O.Formula, O.ArrayRange == "RC" ? O.F = rc_to_a1("RC:RC", D) : O.ArrayRange && (O.F = rc_to_a1(O.ArrayRange, D), G.push([safe_decode_range(O.F), O.F]));
    } else
      for (re = 0; re < G.length; ++re)
        D.r >= G[re][0].s.r && D.r <= G[re][0].e.r && D.c >= G[re][0].s.c && D.c <= G[re][0].e.c && (O.F = G[re][1]);
  Y.cellStyles && (ee.forEach(function(oe) {
    !J.patternType && oe.patternType && (J.patternType = oe.patternType);
  }), O.s = J), O.StyleID !== void 0 && (O.ixfe = O.StyleID);
}
function xlml_prefix_dname(F) {
  return XLSLblBuiltIn.indexOf("_xlnm." + F) > -1 ? "_xlnm." + F : F;
}
function xlml_clean_comment(F) {
  F.t = F.v || "", F.t = F.t.replace(/\r\n/g, `
`).replace(/\r/g, `
`), F.v = F.w = F.ixfe = void 0;
}
function parse_xlml_xml(F, x) {
  var w = x || {};
  make_ssf();
  var O = debom(xlml_normalize(F));
  (w.type == "binary" || w.type == "array" || w.type == "base64") && (typeof $cptable < "u" ? O = $cptable.utils.decode(65001, char_codes(O)) : O = utf8read(O));
  var D = O.slice(0, 1024).toLowerCase(), U = !1;
  if (D = D.replace(/".*?"/g, ""), (D.indexOf(">") & 1023) > Math.min(D.indexOf(",") & 1023, D.indexOf(";") & 1023)) {
    var W = dup(w);
    return W.type = "string", PRN.to_workbook(O, W);
  }
  if (D.indexOf("<?xml") == -1 && ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(Ve) {
    D.indexOf("<" + Ve) >= 0 && (U = !0);
  }), U) return html_to_workbook(O, w);
  XLMLFormatMap = {
    "General Number": "General",
    "General Date": table_fmt[22],
    "Long Date": "dddd, mmmm dd, yyyy",
    "Medium Date": table_fmt[15],
    "Short Date": table_fmt[14],
    "Long Time": table_fmt[19],
    "Medium Time": table_fmt[18],
    "Short Time": table_fmt[20],
    Currency: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    Fixed: table_fmt[2],
    Standard: table_fmt[4],
    Percent: table_fmt[10],
    Scientific: table_fmt[11],
    "Yes/No": '"Yes";"Yes";"No";@',
    "True/False": '"True";"True";"False";@',
    "On/Off": '"Yes";"Yes";"No";@'
  };
  var X, G = [], Y, K = {}, Z = [], q = {}, J = "";
  w.dense && (q["!data"] = []);
  var ee = {}, re = {}, te = xlml_parsexmltag('<Data ss:Type="String">'), Q = 0, oe = 0, ne = 0, le = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, Ee = {}, Te = {}, de = "", ae = 0, se = [], ce = {}, xe = {}, Ce = 0, ye = [], ze = [], De = {}, et = [], Oe, Xe = !1, He = [], Ae = [], qe = {}, Ue = 0, Re = 0, Me = { Sheets: [], WBProps: { date1904: !1 } }, je = {};
  xlmlregex.lastIndex = 0, O = str_remove_ng(O, "<!--", "-->");
  for (var Je = ""; X = xlmlregex.exec(O); ) switch (X[3] = (Je = X[3]).toLowerCase()) {
    case "data":
      if (Je == "data") {
        if (X[1] === "/") {
          if ((Y = G.pop())[0] !== X[3]) throw new Error("Bad state: " + Y.join("|"));
        } else X[0].charAt(X[0].length - 2) !== "/" && G.push([X[3], !0]);
        break;
      }
      if (G[G.length - 1][1]) break;
      X[1] === "/" ? parse_xlml_data(O.slice(Q, X.index), de, te, G[G.length - 1][0] == /*"Comment"*/
      "comment" ? De : ee, { c: oe, r: ne }, Ee, et[oe], re, He, w, Me.WBProps.date1904) : (de = "", te = xlml_parsexmltag(X[0]), Q = X.index + X[0].length);
      break;
    case "cell":
      if (X[1] === "/")
        if (ze.length > 0 && (ee.c = ze), (!w.sheetRows || w.sheetRows > ne) && ee.v !== void 0 && (w.dense ? (q["!data"][ne] || (q["!data"][ne] = []), q["!data"][ne][oe] = ee) : q[encode_col(oe) + encode_row(ne)] = ee), ee.HRef && (ee.l = { Target: unescapexml(ee.HRef) }, ee.HRefScreenTip && (ee.l.Tooltip = ee.HRefScreenTip), delete ee.HRef, delete ee.HRefScreenTip), (ee.MergeAcross || ee.MergeDown) && (Ue = oe + (parseInt(ee.MergeAcross, 10) | 0), Re = ne + (parseInt(ee.MergeDown, 10) | 0), (Ue > oe || Re > ne) && se.push({ s: { c: oe, r: ne }, e: { c: Ue, r: Re } })), !w.sheetStubs)
          ee.MergeAcross ? oe = Ue + 1 : ++oe;
        else if (ee.MergeAcross || ee.MergeDown) {
          for (var rt = oe; rt <= Ue; ++rt)
            for (var fe = ne; fe <= Re; ++fe)
              (rt > oe || fe > ne) && (w.dense ? (q["!data"][fe] || (q["!data"][fe] = []), q["!data"][fe][rt] = { t: "z" }) : q[encode_col(rt) + encode_row(fe)] = { t: "z" });
          oe = Ue + 1;
        } else ++oe;
      else
        ee = xlml_parsexmltagobj(X[0]), ee.Index && (oe = +ee.Index - 1), oe < le.s.c && (le.s.c = oe), oe > le.e.c && (le.e.c = oe), X[0].slice(-2) === "/>" && ++oe, ze = [];
      break;
    case "row":
      X[1] === "/" || X[0].slice(-2) === "/>" ? (ne < le.s.r && (le.s.r = ne), ne > le.e.r && (le.e.r = ne), X[0].slice(-2) === "/>" && (re = xlml_parsexmltag(X[0]), re.Index && (ne = +re.Index - 1)), oe = 0, ++ne) : (re = xlml_parsexmltag(X[0]), re.Index && (ne = +re.Index - 1), qe = {}, (re.AutoFitHeight == "0" || re.Height) && (qe.hpx = parseInt(re.Height, 10), qe.hpt = px2pt(qe.hpx), Ae[ne] = qe), re.Hidden == "1" && (qe.hidden = !0, Ae[ne] = qe));
      break;
    case "worksheet":
      if (X[1] === "/") {
        if ((Y = G.pop())[0] !== X[3]) throw new Error("Bad state: " + Y.join("|"));
        Z.push(J), le.s.r <= le.e.r && le.s.c <= le.e.c && (q["!ref"] = encode_range(le), w.sheetRows && w.sheetRows <= le.e.r && (q["!fullref"] = q["!ref"], le.e.r = w.sheetRows - 1, q["!ref"] = encode_range(le))), se.length && (q["!merges"] = se), et.length > 0 && (q["!cols"] = et), Ae.length > 0 && (q["!rows"] = Ae), K[J] = q;
      } else
        le = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, ne = oe = 0, G.push([X[3], !1]), Y = xlml_parsexmltag(X[0]), J = unescapexml(Y.Name), q = {}, w.dense && (q["!data"] = []), se = [], He = [], Ae = [], je = { name: J, Hidden: 0 }, Me.Sheets.push(je);
      break;
    case "table":
      if (X[1] === "/") {
        if ((Y = G.pop())[0] !== X[3]) throw new Error("Bad state: " + Y.join("|"));
      } else {
        if (X[0].slice(-2) == "/>") break;
        G.push([X[3], !1]), et = [], Xe = !1;
      }
      break;
    case "style":
      X[1] === "/" ? process_style_xlml(Ee, Te, w) : Te = xlml_parsexmltag(X[0]);
      break;
    case "numberformat":
      Te.nf = unescapexml(xlml_parsexmltag(X[0]).Format || "General"), XLMLFormatMap[Te.nf] && (Te.nf = XLMLFormatMap[Te.nf]);
      for (var Se = 0; Se != 392 && table_fmt[Se] != Te.nf; ++Se) ;
      if (Se == 392) {
        for (Se = 57; Se != 392; ++Se) if (table_fmt[Se] == null) {
          SSF__load(Te.nf, Se);
          break;
        }
      }
      break;
    case "column":
      if (G[G.length - 1][0] !== /*'Table'*/
      "table" || X[1] === "/") break;
      if (Oe = xlml_parsexmltag(X[0]), Oe.Hidden && (Oe.hidden = !0, delete Oe.Hidden), Oe.Width && (Oe.wpx = parseInt(Oe.Width, 10)), !Xe && Oe.wpx > 10) {
        Xe = !0, MDW = DEF_MDW;
        for (var we = 0; we < et.length; ++we) et[we] && process_col(et[we]);
      }
      Xe && process_col(Oe), et[Oe.Index - 1 || et.length] = Oe;
      for (var me = 0; me < +Oe.Span; ++me) et[et.length] = dup(Oe);
      break;
    case "namedrange":
      if (X[1] === "/") break;
      Me.Names || (Me.Names = []);
      var ke = parsexmltag(X[0]), ue = {
        Name: xlml_prefix_dname(ke.Name),
        Ref: rc_to_a1(ke.RefersTo.slice(1), { r: 0, c: 0 })
      };
      Me.Sheets.length > 0 && (ue.Sheet = Me.Sheets.length - 1), Me.Names.push(ue);
      break;
    case "namedcell":
      break;
    case "b":
      break;
    case "i":
      break;
    case "u":
      break;
    case "s":
      break;
    case "em":
      break;
    case "h2":
      break;
    case "h3":
      break;
    case "sub":
      break;
    case "sup":
      break;
    case "span":
      break;
    case "alignment":
      break;
    case "borders":
      break;
    case "border":
      break;
    case "font":
      if (X[0].slice(-2) === "/>") break;
      X[1] === "/" ? de += O.slice(ae, X.index) : ae = X.index + X[0].length;
      break;
    case "interior":
      if (!w.cellStyles) break;
      Te.Interior = xlml_parsexmltag(X[0]);
      break;
    case "protection":
      break;
    case "author":
    case "title":
    case "description":
    case "created":
    case "keywords":
    case "subject":
    case "category":
    case "company":
    case "lastauthor":
    case "lastsaved":
    case "lastprinted":
    case "version":
    case "revision":
    case "totaltime":
    case "hyperlinkbase":
    case "manager":
    case "contentstatus":
    case "identifier":
    case "language":
    case "appname":
      if (X[0].slice(-2) === "/>") break;
      X[1] === "/" ? xlml_set_prop(ce, Je, O.slice(Ce, X.index)) : Ce = X.index + X[0].length;
      break;
    case "paragraphs":
      break;
    case "styles":
    case "workbook":
      if (X[1] === "/") {
        if ((Y = G.pop())[0] !== X[3]) throw new Error("Bad state: " + Y.join("|"));
      } else G.push([X[3], !1]);
      break;
    case "comment":
      if (X[1] === "/") {
        if ((Y = G.pop())[0] !== X[3]) throw new Error("Bad state: " + Y.join("|"));
        xlml_clean_comment(De), ze.push(De);
      } else
        G.push([X[3], !1]), Y = xlml_parsexmltag(X[0]), parsexmlbool(Y.ShowAlways || "0") || (ze.hidden = !0), De = { a: Y.Author };
      break;
    case "autofilter":
      if (X[1] === "/") {
        if ((Y = G.pop())[0] !== X[3]) throw new Error("Bad state: " + Y.join("|"));
      } else if (X[0].charAt(X[0].length - 2) !== "/") {
        var We = xlml_parsexmltag(X[0]);
        q["!autofilter"] = { ref: rc_to_a1(We.Range).replace(/\$/g, "") }, G.push([X[3], !0]);
      }
      break;
    case "name":
      break;
    case "datavalidation":
      if (X[1] === "/") {
        if ((Y = G.pop())[0] !== X[3]) throw new Error("Bad state: " + Y.join("|"));
      } else
        X[0].charAt(X[0].length - 2) !== "/" && G.push([X[3], !0]);
      break;
    case "pixelsperinch":
      break;
    case "componentoptions":
    case "documentproperties":
    case "customdocumentproperties":
    case "officedocumentsettings":
    case "pivottable":
    case "pivotcache":
    case "names":
    case "mapinfo":
    case "pagebreaks":
    case "querytable":
    case "sorting":
    case "schema":
    //case 'data' /*case 'data'*/:
    case "conditionalformatting":
    case "smarttagtype":
    case "smarttags":
    case "excelworkbook":
    case "workbookoptions":
    case "worksheetoptions":
      if (X[1] === "/") {
        if ((Y = G.pop())[0] !== X[3]) throw new Error("Bad state: " + Y.join("|"));
      } else X[0].charAt(X[0].length - 2) !== "/" && G.push([X[3], !0]);
      break;
    case "null":
      break;
    default:
      if (G.length == 0 && X[3] == "document" || G.length == 0 && X[3] == "uof") return parse_fods(O, w);
      var Ge = !0;
      switch (G[G.length - 1][0]) {
        /* OfficeDocumentSettings */
        case "officedocumentsettings":
          switch (X[3]) {
            case "allowpng":
              break;
            case "removepersonalinformation":
              break;
            case "downloadcomponents":
              break;
            case "locationofcomponents":
              break;
            case "colors":
              break;
            case "color":
              break;
            case "index":
              break;
            case "rgb":
              break;
            case "targetscreensize":
              break;
            case "readonlyrecommended":
              break;
            default:
              Ge = !1;
          }
          break;
        /* ComponentOptions */
        case "componentoptions":
          switch (X[3]) {
            case "toolbar":
              break;
            case "hideofficelogo":
              break;
            case "spreadsheetautofit":
              break;
            case "label":
              break;
            case "caption":
              break;
            case "maxheight":
              break;
            case "maxwidth":
              break;
            case "nextsheetnumber":
              break;
            default:
              Ge = !1;
          }
          break;
        /* ExcelWorkbook */
        case "excelworkbook":
          switch (X[3]) {
            case "date1904":
              Me.WBProps.date1904 = !0;
              break;
            case "hidehorizontalscrollbar":
              break;
            case "hideverticalscrollbar":
              break;
            case "hideworkbooktabs":
              break;
            case "windowheight":
              break;
            case "windowwidth":
              break;
            case "windowtopx":
              break;
            case "windowtopy":
              break;
            case "tabratio":
              break;
            case "protectstructure":
              break;
            case "protectwindow":
              break;
            case "protectwindows":
              break;
            case "activesheet":
              break;
            case "displayinknotes":
              break;
            case "firstvisiblesheet":
              break;
            case "supbook":
              break;
            case "sheetname":
              break;
            case "sheetindex":
              break;
            case "sheetindexfirst":
              break;
            case "sheetindexlast":
              break;
            case "dll":
              break;
            case "acceptlabelsinformulas":
              break;
            case "donotsavelinkvalues":
              break;
            case "iteration":
              break;
            case "maxiterations":
              break;
            case "maxchange":
              break;
            case "path":
              break;
            case "xct":
              break;
            case "count":
              break;
            case "selectedsheets":
              break;
            case "calculation":
              break;
            case "uncalced":
              break;
            case "startupprompt":
              break;
            case "crn":
              break;
            case "externname":
              break;
            case "formula":
              break;
            case "colfirst":
              break;
            case "collast":
              break;
            case "wantadvise":
              break;
            case "boolean":
              break;
            case "error":
              break;
            case "text":
              break;
            case "ole":
              break;
            case "noautorecover":
              break;
            case "publishobjects":
              break;
            case "donotcalculatebeforesave":
              break;
            case "number":
              break;
            case "refmoder1c1":
              break;
            case "embedsavesmarttags":
              break;
            default:
              Ge = !1;
          }
          break;
        /* WorkbookOptions */
        case "workbookoptions":
          switch (X[3]) {
            case "owcversion":
              break;
            case "height":
              break;
            case "width":
              break;
            default:
              Ge = !1;
          }
          break;
        /* WorksheetOptions */
        case "worksheetoptions":
          switch (X[3]) {
            case "visible":
              if (X[0].slice(-2) !== "/>") if (X[1] === "/") switch (O.slice(Ce, X.index)) {
                case "SheetHidden":
                  je.Hidden = 1;
                  break;
                case "SheetVeryHidden":
                  je.Hidden = 2;
                  break;
              }
              else Ce = X.index + X[0].length;
              break;
            case "header":
              q["!margins"] || default_margins(q["!margins"] = {}, "xlml"), isNaN(+parsexmltag(X[0]).Margin) || (q["!margins"].header = +parsexmltag(X[0]).Margin);
              break;
            case "footer":
              q["!margins"] || default_margins(q["!margins"] = {}, "xlml"), isNaN(+parsexmltag(X[0]).Margin) || (q["!margins"].footer = +parsexmltag(X[0]).Margin);
              break;
            case "pagemargins":
              var Pe = parsexmltag(X[0]);
              q["!margins"] || default_margins(q["!margins"] = {}, "xlml"), isNaN(+Pe.Top) || (q["!margins"].top = +Pe.Top), isNaN(+Pe.Left) || (q["!margins"].left = +Pe.Left), isNaN(+Pe.Right) || (q["!margins"].right = +Pe.Right), isNaN(+Pe.Bottom) || (q["!margins"].bottom = +Pe.Bottom);
              break;
            case "displayrighttoleft":
              Me.Views || (Me.Views = []), Me.Views[0] || (Me.Views[0] = {}), Me.Views[0].RTL = !0;
              break;
            case "freezepanes":
              break;
            case "frozennosplit":
              break;
            case "splithorizontal":
            case "splitvertical":
              break;
            case "donotdisplaygridlines":
              break;
            case "activerow":
              break;
            case "activecol":
              break;
            case "toprowbottompane":
              break;
            case "leftcolumnrightpane":
              break;
            case "unsynced":
              break;
            case "print":
              break;
            case "printerrors":
              break;
            case "panes":
              break;
            case "scale":
              break;
            case "pane":
              break;
            case "number":
              break;
            case "layout":
              break;
            case "pagesetup":
              break;
            case "selected":
              break;
            case "protectobjects":
              break;
            case "enableselection":
              break;
            case "protectscenarios":
              break;
            case "validprinterinfo":
              break;
            case "horizontalresolution":
              break;
            case "verticalresolution":
              break;
            case "numberofcopies":
              break;
            case "activepane":
              break;
            case "toprowvisible":
              break;
            case "leftcolumnvisible":
              break;
            case "fittopage":
              break;
            case "rangeselection":
              break;
            case "papersizeindex":
              break;
            case "pagelayoutzoom":
              break;
            case "pagebreakzoom":
              break;
            case "filteron":
              break;
            case "fitwidth":
              break;
            case "fitheight":
              break;
            case "commentslayout":
              break;
            case "zoom":
              break;
            case "lefttoright":
              break;
            case "gridlines":
              break;
            case "allowsort":
              break;
            case "allowfilter":
              break;
            case "allowinsertrows":
              break;
            case "allowdeleterows":
              break;
            case "allowinsertcols":
              break;
            case "allowdeletecols":
              break;
            case "allowinserthyperlinks":
              break;
            case "allowformatcells":
              break;
            case "allowsizecols":
              break;
            case "allowsizerows":
              break;
            case "nosummaryrowsbelowdetail":
              q["!outline"] || (q["!outline"] = {}), q["!outline"].above = !0;
              break;
            case "tabcolorindex":
              break;
            case "donotdisplayheadings":
              break;
            case "showpagelayoutzoom":
              break;
            case "nosummarycolumnsrightdetail":
              q["!outline"] || (q["!outline"] = {}), q["!outline"].left = !0;
              break;
            case "blackandwhite":
              break;
            case "donotdisplayzeros":
              break;
            case "displaypagebreak":
              break;
            case "rowcolheadings":
              break;
            case "donotdisplayoutline":
              break;
            case "noorientation":
              break;
            case "allowusepivottables":
              break;
            case "zeroheight":
              break;
            case "viewablerange":
              break;
            case "selection":
              break;
            case "protectcontents":
              break;
            default:
              Ge = !1;
          }
          break;
        /* PivotTable */
        case "pivottable":
        case "pivotcache":
          switch (X[3]) {
            case "immediateitemsondrop":
              break;
            case "showpagemultipleitemlabel":
              break;
            case "compactrowindent":
              break;
            case "location":
              break;
            case "pivotfield":
              break;
            case "orientation":
              break;
            case "layoutform":
              break;
            case "layoutsubtotallocation":
              break;
            case "layoutcompactrow":
              break;
            case "position":
              break;
            case "pivotitem":
              break;
            case "datatype":
              break;
            case "datafield":
              break;
            case "sourcename":
              break;
            case "parentfield":
              break;
            case "ptlineitems":
              break;
            case "ptlineitem":
              break;
            case "countofsameitems":
              break;
            case "item":
              break;
            case "itemtype":
              break;
            case "ptsource":
              break;
            case "cacheindex":
              break;
            case "consolidationreference":
              break;
            case "filename":
              break;
            case "reference":
              break;
            case "nocolumngrand":
              break;
            case "norowgrand":
              break;
            case "blanklineafteritems":
              break;
            case "hidden":
              break;
            case "subtotal":
              break;
            case "basefield":
              break;
            case "mapchilditems":
              break;
            case "function":
              break;
            case "refreshonfileopen":
              break;
            case "printsettitles":
              break;
            case "mergelabels":
              break;
            case "defaultversion":
              break;
            case "refreshname":
              break;
            case "refreshdate":
              break;
            case "refreshdatecopy":
              break;
            case "versionlastrefresh":
              break;
            case "versionlastupdate":
              break;
            case "versionupdateablemin":
              break;
            case "versionrefreshablemin":
              break;
            case "calculation":
              break;
            default:
              Ge = !1;
          }
          break;
        /* PageBreaks */
        case "pagebreaks":
          switch (X[3]) {
            case "colbreaks":
              break;
            case "colbreak":
              break;
            case "rowbreaks":
              break;
            case "rowbreak":
              break;
            case "colstart":
              break;
            case "colend":
              break;
            case "rowend":
              break;
            default:
              Ge = !1;
          }
          break;
        /* AutoFilter */
        case "autofilter":
          switch (X[3]) {
            case "autofiltercolumn":
              break;
            case "autofiltercondition":
              break;
            case "autofilterand":
              break;
            case "autofilteror":
              break;
            default:
              Ge = !1;
          }
          break;
        /* QueryTable */
        case "querytable":
          switch (X[3]) {
            case "id":
              break;
            case "autoformatfont":
              break;
            case "autoformatpattern":
              break;
            case "querysource":
              break;
            case "querytype":
              break;
            case "enableredirections":
              break;
            case "refreshedinxl9":
              break;
            case "urlstring":
              break;
            case "htmltables":
              break;
            case "connection":
              break;
            case "commandtext":
              break;
            case "refreshinfo":
              break;
            case "notitles":
              break;
            case "nextid":
              break;
            case "columninfo":
              break;
            case "overwritecells":
              break;
            case "donotpromptforfile":
              break;
            case "textwizardsettings":
              break;
            case "source":
              break;
            case "number":
              break;
            case "decimal":
              break;
            case "thousandseparator":
              break;
            case "trailingminusnumbers":
              break;
            case "formatsettings":
              break;
            case "fieldtype":
              break;
            case "delimiters":
              break;
            case "tab":
              break;
            case "comma":
              break;
            case "autoformatname":
              break;
            case "versionlastedit":
              break;
            case "versionlastrefresh":
              break;
            default:
              Ge = !1;
          }
          break;
        case "datavalidation":
          switch (X[3]) {
            case "range":
              break;
            case "type":
              break;
            case "min":
              break;
            case "max":
              break;
            case "sort":
              break;
            case "descending":
              break;
            case "order":
              break;
            case "casesensitive":
              break;
            case "value":
              break;
            case "errorstyle":
              break;
            case "errormessage":
              break;
            case "errortitle":
              break;
            case "inputmessage":
              break;
            case "inputtitle":
              break;
            case "combohide":
              break;
            case "inputhide":
              break;
            case "condition":
              break;
            case "qualifier":
              break;
            case "useblank":
              break;
            case "value1":
              break;
            case "value2":
              break;
            case "format":
              break;
            case "cellrangelist":
              break;
            default:
              Ge = !1;
          }
          break;
        case "sorting":
        case "conditionalformatting":
          switch (X[3]) {
            case "range":
              break;
            case "type":
              break;
            case "min":
              break;
            case "max":
              break;
            case "sort":
              break;
            case "descending":
              break;
            case "order":
              break;
            case "casesensitive":
              break;
            case "value":
              break;
            case "errorstyle":
              break;
            case "errormessage":
              break;
            case "errortitle":
              break;
            case "cellrangelist":
              break;
            case "inputmessage":
              break;
            case "inputtitle":
              break;
            case "combohide":
              break;
            case "inputhide":
              break;
            case "condition":
              break;
            case "qualifier":
              break;
            case "useblank":
              break;
            case "value1":
              break;
            case "value2":
              break;
            case "format":
              break;
            default:
              Ge = !1;
          }
          break;
        /* MapInfo (schema) */
        case "mapinfo":
        case "schema":
        case "data":
          switch (X[3]) {
            case "map":
              break;
            case "entry":
              break;
            case "range":
              break;
            case "xpath":
              break;
            case "field":
              break;
            case "xsdtype":
              break;
            case "filteron":
              break;
            case "aggregate":
              break;
            case "elementtype":
              break;
            case "attributetype":
              break;
            /* These are from xsd (XML Schema Definition) */
            case "schema":
            case "element":
            case "complextype":
            case "datatype":
            case "all":
            case "attribute":
            case "extends":
              break;
            case "row":
              break;
            default:
              Ge = !1;
          }
          break;
        /* SmartTags (can be anything) */
        case "smarttags":
          break;
        default:
          Ge = !1;
          break;
      }
      if (Ge || X[3].match(/!\[CDATA/)) break;
      if (!G[G.length - 1][1]) throw "Unrecognized tag: " + X[3] + "|" + G.join("|");
      if (G[G.length - 1][0] === /*'CustomDocumentProperties'*/
      "customdocumentproperties") {
        if (X[0].slice(-2) === "/>") break;
        X[1] === "/" ? xlml_set_custprop(xe, Je, ye, O.slice(Ce, X.index)) : (ye = X, Ce = X.index + X[0].length);
        break;
      }
      if (w.WTF) throw "Unrecognized tag: " + X[3] + "|" + G.join("|");
  }
  var it = {};
  return !w.bookSheets && !w.bookProps && (it.Sheets = K), it.SheetNames = Z, it.Workbook = Me, it.SSF = dup(table_fmt), it.Props = ce, it.Custprops = xe, it.bookType = "xlml", it;
}
function parse_xlml(F, x) {
  switch (fix_read_opts(x = x || {}), x.type || "base64") {
    case "base64":
      return parse_xlml_xml(Base64_decode(F), x);
    case "binary":
    case "buffer":
    case "file":
      return parse_xlml_xml(F, x);
    case "array":
      return parse_xlml_xml(a2s(F), x);
  }
}
function write_props_xlml(F, x) {
  var w = [];
  return F.Props && w.push(xlml_write_docprops(F.Props, x)), F.Custprops && w.push(xlml_write_custprops(F.Props, F.Custprops)), w.join("");
}
function write_wb_xlml(F) {
  return (((F || {}).Workbook || {}).WBProps || {}).date1904 ? '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel"><Date1904/></ExcelWorkbook>' : "";
}
function write_sty_xlml(F, x) {
  var w = ['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];
  return x.cellXfs.forEach(function(O, D) {
    var U = [];
    U.push(writextag("NumberFormat", null, { "ss:Format": escapexml(table_fmt[O.numFmtId]) }));
    var W = (
      /*::(*/
      { "ss:ID": "s" + (21 + D) }
    );
    w.push(writextag("Style", U.join(""), W));
  }), writextag("Styles", w.join(""));
}
function write_name_xlml(F) {
  return writextag("NamedRange", null, { "ss:Name": F.Name.slice(0, 6) == "_xlnm." ? F.Name.slice(6) : F.Name, "ss:RefersTo": "=" + a1_to_rc(F.Ref, { r: 0, c: 0 }) });
}
function write_names_xlml(F) {
  if (!((F || {}).Workbook || {}).Names) return "";
  for (var x = F.Workbook.Names, w = [], O = 0; O < x.length; ++O) {
    var D = x[O];
    D.Sheet == null && (D.Name.match(/^_xlfn\./) || w.push(write_name_xlml(D)));
  }
  return writextag("Names", w.join(""));
}
function write_ws_xlml_names(F, x, w, O) {
  if (!F || !((O || {}).Workbook || {}).Names) return "";
  for (var D = O.Workbook.Names, U = [], W = 0; W < D.length; ++W) {
    var X = D[W];
    X.Sheet == w && (X.Name.match(/^_xlfn\./) || U.push(write_name_xlml(X)));
  }
  return U.join("");
}
function write_ws_xlml_wsopts(F, x, w, O) {
  if (!F) return "";
  var D = [];
  if (F["!margins"] && (D.push("<PageSetup>"), F["!margins"].header && D.push(writextag("Header", null, { "x:Margin": F["!margins"].header })), F["!margins"].footer && D.push(writextag("Footer", null, { "x:Margin": F["!margins"].footer })), D.push(writextag("PageMargins", null, {
    "x:Bottom": F["!margins"].bottom || "0.75",
    "x:Left": F["!margins"].left || "0.7",
    "x:Right": F["!margins"].right || "0.7",
    "x:Top": F["!margins"].top || "0.75"
  })), D.push("</PageSetup>")), O && O.Workbook && O.Workbook.Sheets && O.Workbook.Sheets[w])
    if (O.Workbook.Sheets[w].Hidden) D.push(writextag("Visible", O.Workbook.Sheets[w].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden", {}));
    else {
      for (var U = 0; U < w && !(O.Workbook.Sheets[U] && !O.Workbook.Sheets[U].Hidden); ++U) ;
      U == w && D.push("<Selected/>");
    }
  return ((((O || {}).Workbook || {}).Views || [])[0] || {}).RTL && D.push("<DisplayRightToLeft/>"), F["!protect"] && (D.push(writetag("ProtectContents", "True")), F["!protect"].objects && D.push(writetag("ProtectObjects", "True")), F["!protect"].scenarios && D.push(writetag("ProtectScenarios", "True")), F["!protect"].selectLockedCells != null && !F["!protect"].selectLockedCells ? D.push(writetag("EnableSelection", "NoSelection")) : F["!protect"].selectUnlockedCells != null && !F["!protect"].selectUnlockedCells && D.push(writetag("EnableSelection", "UnlockedCells")), [
    ["formatCells", "AllowFormatCells"],
    ["formatColumns", "AllowSizeCols"],
    ["formatRows", "AllowSizeRows"],
    ["insertColumns", "AllowInsertCols"],
    ["insertRows", "AllowInsertRows"],
    ["insertHyperlinks", "AllowInsertHyperlinks"],
    ["deleteColumns", "AllowDeleteCols"],
    ["deleteRows", "AllowDeleteRows"],
    ["sort", "AllowSort"],
    ["autoFilter", "AllowFilter"],
    ["pivotTables", "AllowUsePivotTables"]
  ].forEach(function(W) {
    F["!protect"][W[0]] && D.push("<" + W[1] + "/>");
  })), D.length == 0 ? "" : writextag("WorksheetOptions", D.join(""), { xmlns: XLMLNS.x });
}
function write_ws_xlml_comment(F) {
  return F.map(function(x) {
    var w = xlml_unfixstr(x.t || ""), O = writextag("ss:Data", w, { xmlns: "http://www.w3.org/TR/REC-html40" }), D = {};
    return x.a && (D["ss:Author"] = x.a), F.hidden || (D["ss:ShowAlways"] = "1"), writextag("Comment", O, D);
  }).join("");
}
function write_ws_xlml_cell(F, x, w, O, D, U, W) {
  if (!F || F.v == null && F.f == null) return "";
  var X = {};
  if (F.f && (X["ss:Formula"] = "=" + escapexml(a1_to_rc(F.f, W))), F.F && F.F.slice(0, x.length) == x) {
    var G = decode_cell(F.F.slice(x.length + 1));
    X["ss:ArrayRange"] = "RC:R" + (G.r == W.r ? "" : "[" + (G.r - W.r) + "]") + "C" + (G.c == W.c ? "" : "[" + (G.c - W.c) + "]");
  }
  if (F.l && F.l.Target && (X["ss:HRef"] = escapexml(F.l.Target), F.l.Tooltip && (X["x:HRefScreenTip"] = escapexml(F.l.Tooltip))), w["!merges"])
    for (var Y = w["!merges"], K = 0; K != Y.length; ++K)
      Y[K].s.c != W.c || Y[K].s.r != W.r || (Y[K].e.c > Y[K].s.c && (X["ss:MergeAcross"] = Y[K].e.c - Y[K].s.c), Y[K].e.r > Y[K].s.r && (X["ss:MergeDown"] = Y[K].e.r - Y[K].s.r));
  var Z = "", q = "";
  switch (F.t) {
    case "z":
      if (!O.sheetStubs) return "";
      break;
    case "n":
      isFinite(F.v) ? (Z = "Number", q = String(F.v)) : (Z = "Error", q = BErr[isNaN(F.v) ? 36 : 7]);
      break;
    case "b":
      Z = "Boolean", q = F.v ? "1" : "0";
      break;
    case "e":
      Z = "Error", q = BErr[F.v];
      break;
    case "d":
      Z = "DateTime", q = new Date(F.v).toISOString(), F.z == null && (F.z = F.z || table_fmt[14]);
      break;
    case "s":
      Z = "String", q = escapexlml(F.v || "");
      break;
  }
  var J = get_cell_style(O.cellXfs, F, O);
  X["ss:StyleID"] = "s" + (21 + J), X["ss:Index"] = W.c + 1;
  var ee = F.v != null ? q : "", re = F.t == "z" ? "" : '<Data ss:Type="' + Z + '">' + ee + "</Data>";
  return (F.c || []).length > 0 && (re += write_ws_xlml_comment(F.c)), writextag("Cell", re, X);
}
function write_ws_xlml_row(F, x) {
  var w = '<Row ss:Index="' + (F + 1) + '"';
  return x && (x.hpt && !x.hpx && (x.hpx = pt2px(x.hpt)), x.hpx && (w += ' ss:AutoFitHeight="0" ss:Height="' + x.hpx + '"'), x.hidden && (w += ' ss:Hidden="1"')), w + ">";
}
function write_ws_xlml_table(F, x, w, O) {
  if (!F["!ref"]) return "";
  var D = safe_decode_range(F["!ref"]), U = F["!merges"] || [], W = 0, X = [];
  F["!cols"] && F["!cols"].forEach(function(te, Q) {
    process_col(te);
    var oe = !!te.width, ne = col_obj_w(Q, te), le = { "ss:Index": Q + 1 };
    oe && (le["ss:Width"] = width2px(ne.width)), te.hidden && (le["ss:Hidden"] = "1"), X.push(writextag("Column", null, le));
  });
  for (var G = F["!data"] != null, Y = { r: 0, c: 0 }, K = D.s.r; K <= D.e.r; ++K) {
    var Z = [write_ws_xlml_row(K, (F["!rows"] || [])[K])];
    Y.r = K;
    for (var q = D.s.c; q <= D.e.c; ++q) {
      Y.c = q;
      var J = !1;
      for (W = 0; W != U.length; ++W)
        if (!(U[W].s.c > q) && !(U[W].s.r > K) && !(U[W].e.c < q) && !(U[W].e.r < K)) {
          (U[W].s.c != q || U[W].s.r != K) && (J = !0);
          break;
        }
      if (!J) {
        var ee = encode_col(q) + encode_row(K), re = G ? (F["!data"][K] || [])[q] : F[ee];
        Z.push(write_ws_xlml_cell(re, ee, F, x, w, O, Y));
      }
    }
    Z.push("</Row>"), Z.length > 2 && X.push(Z.join(""));
  }
  return X.join("");
}
function write_ws_xlml(F, x, w) {
  var O = [], D = w.SheetNames[F], U = w.Sheets[D], W = U ? write_ws_xlml_names(U, x, F, w) : "";
  return W.length > 0 && O.push("<Names>" + W + "</Names>"), W = U ? write_ws_xlml_table(U, x, F, w) : "", W.length > 0 && O.push("<Table>" + W + "</Table>"), O.push(write_ws_xlml_wsopts(U, x, F, w)), U && U["!autofilter"] && O.push('<AutoFilter x:Range="' + a1_to_rc(fix_range(U["!autofilter"].ref), { r: 0, c: 0 }) + '" xmlns="urn:schemas-microsoft-com:office:excel"></AutoFilter>'), O.join("");
}
function write_xlml(F, x) {
  x || (x = {}), F.SSF || (F.SSF = dup(table_fmt)), F.SSF && (make_ssf(), SSF_load_table(F.SSF), x.revssf = evert_num(F.SSF), x.revssf[F.SSF[65535]] = 0, x.ssf = F.SSF, x.cellXfs = [], get_cell_style(x.cellXfs, {}, { revssf: { General: 0 } }));
  var w = [];
  w.push(write_props_xlml(F, x)), w.push(write_wb_xlml(F)), w.push(""), w.push(write_names_xlml(F));
  for (var O = 0; O < F.SheetNames.length; ++O)
    w.push(writextag("Worksheet", write_ws_xlml(O, x, F), { "ss:Name": escapexml(F.SheetNames[O]) }));
  return w[2] = write_sty_xlml(F, x), XML_HEADER + writextag("Workbook", w.join(""), {
    xmlns: XLMLNS.ss,
    "xmlns:o": XLMLNS.o,
    "xmlns:x": XLMLNS.x,
    "xmlns:ss": XLMLNS.ss,
    "xmlns:dt": XLMLNS.dt,
    "xmlns:html": XLMLNS.html
  });
}
function parse_compobj(F) {
  var x = {}, w = F.content;
  if (w.l = 28, x.AnsiUserType = w.read_shift(0, "lpstr-ansi"), x.AnsiClipboardFormat = parse_ClipboardFormatOrAnsiString(w), w.length - w.l <= 4) return x;
  var O = w.read_shift(4);
  if (O == 0 || O > 40 || (w.l -= 4, x.Reserved1 = w.read_shift(0, "lpstr-ansi"), w.length - w.l <= 4) || (O = w.read_shift(4), O !== 1907505652) || (x.UnicodeClipboardFormat = parse_ClipboardFormatOrUnicodeString(w), O = w.read_shift(4), O == 0 || O > 40)) return x;
  w.l -= 4, x.Reserved2 = w.read_shift(0, "lpwstr");
}
var CONTINUE_RT = [60, 1084, 2066, 2165, 2175];
function slurp(F, x, w, O, D) {
  var U = O, W = [], X = w.slice(w.l, w.l + U);
  if (D.enc && D.enc.insitu && X.length > 0) switch (F) {
    case 9:
    case 521:
    case 1033:
    case 2057:
    case 47:
    case 405:
    case 225:
    case 406:
    case 312:
    case 404:
    case 10:
      break;
    case 133:
      break;
    default:
      D.enc.insitu(X);
  }
  W.push(X), w.l += U;
  for (var G = __readUInt16LE(w, w.l), Y = XLSRecordEnum[G], K = 0; Y != null && CONTINUE_RT.indexOf(G) > -1; )
    U = __readUInt16LE(w, w.l + 2), K = w.l + 4, G == 2066 ? K += 4 : (G == 2165 || G == 2175) && (K += 12), X = w.slice(K, w.l + 4 + U), W.push(X), w.l += 4 + U, Y = XLSRecordEnum[G = __readUInt16LE(w, w.l)];
  var Z = bconcat(W);
  prep_blob(Z, 0);
  var q = 0;
  Z.lens = [];
  for (var J = 0; J < W.length; ++J)
    Z.lens.push(q), q += W[J].length;
  if (Z.length < O) throw "XLS Record 0x" + F.toString(16) + " Truncated: " + Z.length + " < " + O;
  return x.f(Z, Z.length, D);
}
function safe_format_xf(F, x, w) {
  if (F.t !== "z" && F.XF) {
    var O = 0;
    try {
      O = F.z || F.XF.numFmtId || 0, x.cellNF && F.z == null && (F.z = table_fmt[O]);
    } catch (U) {
      if (x.WTF) throw U;
    }
    if (!x || x.cellText !== !1) try {
      F.t === "e" ? F.w = F.w || BErr[F.v] : O === 0 || O == "General" ? F.t === "n" ? (F.v | 0) === F.v ? F.w = F.v.toString(10) : F.w = SSF_general_num(F.v) : F.w = SSF_general(F.v) : F.w = SSF_format(O, F.v, { date1904: !!w, dateNF: x && x.dateNF });
    } catch (U) {
      if (x.WTF) throw U;
    }
    if (x.cellDates && O && F.t == "n" && fmt_is_date(table_fmt[O] || String(O))) {
      var D = SSF_parse_date_code(F.v + (w ? 1462 : 0));
      D && (F.t = "d", F.v = new Date(Date.UTC(D.y, D.m - 1, D.d, D.H, D.M, D.S, D.u)));
    }
  }
}
function make_cell(F, x, w) {
  return { v: F, ixfe: x, t: w };
}
function parse_workbook(F, x) {
  var w = { opts: {} }, O = {}, D = {};
  x.dense && (D["!data"] = []);
  var U = {}, W = {}, X = null, G = [], Y = "", K = {}, Z, q = "", J, ee, re, te, Q = {}, oe = [], ne, le, Ee = [], Te = [], de = { Sheets: [], WBProps: { date1904: !1 }, Views: [{}] }, ae = {}, se = !1, ce = function(tt) {
    return tt < 8 ? XLSIcv[tt] : tt < 64 && Te[tt - 8] || XLSIcv[tt];
  }, xe = function(tt, ft) {
    var St = tt.XF.data;
    if (!(!St || !St.patternType || !ft || !ft.cellStyles)) {
      tt.s = {}, tt.s.patternType = St.patternType;
      var bt;
      (bt = rgb2Hex(ce(St.icvFore))) && (tt.s.fgColor = { rgb: bt }), (bt = rgb2Hex(ce(St.icvBack))) && (tt.s.bgColor = { rgb: bt });
    }
  }, Ce = function(tt, ft, St) {
    if (!(!se && Ue > 1) && !(St.sheetRows && tt.r >= St.sheetRows)) {
      if (St.cellStyles && ft.XF && ft.XF.data && xe(ft, St), delete ft.ixfe, delete ft.XF, Z = tt, q = encode_cell(tt), (!W || !W.s || !W.e) && (W = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }), tt.r < W.s.r && (W.s.r = tt.r), tt.c < W.s.c && (W.s.c = tt.c), tt.r + 1 > W.e.r && (W.e.r = tt.r + 1), tt.c + 1 > W.e.c && (W.e.c = tt.c + 1), St.cellFormula && ft.f) {
        for (var bt = 0; bt < oe.length; ++bt)
          if (!(oe[bt][0].s.c > tt.c || oe[bt][0].s.r > tt.r) && !(oe[bt][0].e.c < tt.c || oe[bt][0].e.r < tt.r)) {
            ft.F = encode_range(oe[bt][0]), (oe[bt][0].s.c != tt.c || oe[bt][0].s.r != tt.r) && delete ft.f, ft.f && (ft.f = "" + stringify_formula(oe[bt][1], W, tt, Ae, ye));
            break;
          }
      }
      St.dense ? (D["!data"][tt.r] || (D["!data"][tt.r] = []), D["!data"][tt.r][tt.c] = ft) : D[q] = ft;
    }
  }, ye = {
    enc: !1,
    // encrypted
    sbcch: 0,
    // cch in the preceding SupBook
    snames: [],
    // sheetnames
    sharedf: Q,
    // shared formulae by address
    arrayf: oe,
    // array formulae array
    rrtabid: [],
    // RRTabId
    lastuser: "",
    // Last User from WriteAccess
    biff: 8,
    // BIFF version
    codepage: 0,
    // CP from CodePage record
    winlocked: 0,
    // fLockWn from WinProtect
    cellStyles: !!x && !!x.cellStyles,
    WTF: !!x && !!x.wtf
  };
  x.password && (ye.password = x.password);
  var ze, De = [], et = [], Oe = [], Xe = [], He = !1, Ae = [];
  Ae.SheetNames = ye.snames, Ae.sharedf = ye.sharedf, Ae.arrayf = ye.arrayf, Ae.names = [], Ae.XTI = [];
  var qe = 0, Ue = 0, Re = 0, Me = [], je = [], Je;
  ye.codepage = 1200, set_cp(1200);
  for (var rt = !1; F.l < F.length - 1; ) {
    var fe = F.l, Se = F.read_shift(2);
    if (Se === 0 && qe === 10) break;
    var we = F.l === F.length ? 0 : F.read_shift(2), me = XLSRecordEnum[Se];
    if (Ue == 0 && [9, 521, 1033, 2057].indexOf(Se) == -1) break;
    if (me && me.f) {
      if (x.bookSheets && qe === 133 && Se !== 133)
        break;
      if (qe = Se, me.r === 2 || me.r == 12) {
        var ke = F.read_shift(2);
        if (we -= 2, !ye.enc && ke !== Se && ((ke & 255) << 8 | ke >> 8) !== Se) throw new Error("rt mismatch: " + ke + "!=" + Se);
        me.r == 12 && (F.l += 10, we -= 10);
      }
      var ue = {};
      if (Se === 10 ? ue = /*::(*/
      me.f(F, we, ye) : ue = /*::(*/
      slurp(Se, me, F, we, ye), Ue == 0 && [9, 521, 1033, 2057].indexOf(qe) === -1) continue;
      switch (Se) {
        case 34:
          w.opts.Date1904 = de.WBProps.date1904 = ue;
          break;
        case 134:
          w.opts.WriteProtect = !0;
          break;
        case 47:
          if (ye.enc || (F.l = 0), ye.enc = ue, !x.password) throw new Error("File is password-protected");
          if (ue.valid == null) throw new Error("Encryption scheme unsupported");
          if (!ue.valid) throw new Error("Password is incorrect");
          break;
        case 92:
          ye.lastuser = ue;
          break;
        case 66:
          var We = Number(ue);
          switch (We) {
            case 21010:
              We = 1200;
              break;
            case 32768:
              We = 1e4;
              break;
            case 32769:
              We = 1252;
              break;
          }
          set_cp(ye.codepage = We), rt = !0;
          break;
        case 317:
          ye.rrtabid = ue;
          break;
        case 25:
          ye.winlocked = ue;
          break;
        case 439:
          w.opts.RefreshAll = ue;
          break;
        case 12:
          w.opts.CalcCount = ue;
          break;
        case 16:
          w.opts.CalcDelta = ue;
          break;
        case 17:
          w.opts.CalcIter = ue;
          break;
        case 13:
          w.opts.CalcMode = ue;
          break;
        case 14:
          w.opts.CalcPrecision = ue;
          break;
        case 95:
          w.opts.CalcSaveRecalc = ue;
          break;
        case 15:
          ye.CalcRefMode = ue;
          break;
        // TODO: implement R1C1
        case 2211:
          w.opts.FullCalc = ue;
          break;
        case 129:
          ue.fDialog && (D["!type"] = "dialog"), ue.fBelow || ((D["!outline"] || (D["!outline"] = {})).above = !0), ue.fRight || ((D["!outline"] || (D["!outline"] = {})).left = !0);
          break;
        // TODO
        case 67:
        /* BIFF2XF */
        case 579:
        /* BIFF3XF */
        case 1091:
        /* BIFF4XF */
        case 224:
          Ee.push(ue);
          break;
        case 430:
          Ae.push([ue]), Ae[Ae.length - 1].XTI = [];
          break;
        case 35:
        case 547:
          Ae[Ae.length - 1].push(ue);
          break;
        case 24:
        case 536:
          Je = {
            Name: ue.Name,
            Ref: stringify_formula(ue.rgce, W, null, Ae, ye)
          }, ue.itab > 0 && (Je.Sheet = ue.itab - 1), Ae.names.push(Je), Ae[0] || (Ae[0] = [], Ae[0].XTI = []), Ae[Ae.length - 1].push(ue), ue.Name == "_xlnm._FilterDatabase" && ue.itab > 0 && ue.rgce && ue.rgce[0] && ue.rgce[0][0] && ue.rgce[0][0][0] == "PtgArea3d" && (je[ue.itab - 1] = { ref: encode_range(ue.rgce[0][0][1][2]) });
          break;
        case 22:
          ye.ExternCount = ue;
          break;
        case 23:
          Ae.length == 0 && (Ae[0] = [], Ae[0].XTI = []), Ae[Ae.length - 1].XTI = Ae[Ae.length - 1].XTI.concat(ue), Ae.XTI = Ae.XTI.concat(ue);
          break;
        case 2196:
          if (ye.biff < 8) break;
          Je != null && (Je.Comment = ue[1]);
          break;
        case 18:
          D["!protect"] = ue;
          break;
        /* for sheet or book */
        case 19:
          ue !== 0 && ye.WTF && console.error("Password verifier: " + ue);
          break;
        case 133:
          U[ye.biff == 4 ? ye.snames.length : ue.pos] = ue, ye.snames.push(ue.name);
          break;
        case 10:
          {
            if (--Ue ? !se : se) break;
            if (W.e) {
              if (W.e.r > 0 && W.e.c > 0) {
                if (W.e.r--, W.e.c--, D["!ref"] = encode_range(W), x.sheetRows && x.sheetRows <= W.e.r) {
                  var Ge = W.e.r;
                  W.e.r = x.sheetRows - 1, D["!fullref"] = D["!ref"], D["!ref"] = encode_range(W), W.e.r = Ge;
                }
                W.e.r++, W.e.c++;
              }
              De.length > 0 && (D["!merges"] = De), et.length > 0 && (D["!objects"] = et), Oe.length > 0 && (D["!cols"] = Oe), Xe.length > 0 && (D["!rows"] = Xe), de.Sheets.push(ae);
            }
            Y === "" ? K = D : O[Y] = D, D = {}, x.dense && (D["!data"] = []);
          }
          break;
        case 9:
        case 521:
        case 1033:
        case 2057:
          {
            if (ye.biff === 8 && (ye.biff = {
              9: 2,
              521: 3,
              1033: 4
            }[Se] || {
              512: 2,
              768: 3,
              1024: 4,
              1280: 5,
              1536: 8,
              2: 2,
              7: 2
            }[ue.BIFFVer] || 8), ye.biffguess = ue.BIFFVer == 0, ue.BIFFVer == 0 && ue.dt == 4096 && (ye.biff = 5, rt = !0, set_cp(ye.codepage = 28591)), ye.biff == 4 && ue.dt & 256 && (se = !0), ye.biff == 8 && ue.BIFFVer == 0 && ue.dt == 16 && (ye.biff = 2), Ue++ && !se) break;
            if (D = {}, x.dense && (D["!data"] = []), ye.biff < 8 && !rt && (rt = !0, set_cp(ye.codepage = x.codepage || 1252)), ye.biff == 4 && se)
              Y = (U[ye.snames.indexOf(Y) + 1] || { name: "" }).name;
            else if (ye.biff < 5 || ue.BIFFVer == 0 && ue.dt == 4096) {
              Y === "" && (Y = "Sheet1"), W = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              var Pe = { pos: F.l - we, name: Y };
              U[Pe.pos] = Pe, ye.snames.push(Y);
            } else Y = (U[fe] || { name: "" }).name;
            ue.dt == 32 && (D["!type"] = "chart"), ue.dt == 64 && (D["!type"] = "macro"), De = [], et = [], ye.arrayf = oe = [], Oe = [], Xe = [], He = !1, ae = { Hidden: (U[fe] || { hs: 0 }).hs, name: Y };
          }
          break;
        case 515:
        case 3:
        case 2:
          D["!type"] == "chart" && (x.dense ? (D["!data"][ue.r] || [])[ue.c] : D[encode_col(ue.c) + encode_row(ue.r)]) && ++ue.c, ne = { ixfe: ue.ixfe, XF: Ee[ue.ixfe] || {}, v: ue.val, t: "n" }, Re > 0 && (ne.z = ne.XF && ne.XF.numFmtId && Me[ne.XF.numFmtId] || Me[ne.ixfe >> 8 & 63]), safe_format_xf(ne, x, w.opts.Date1904), Ce({ c: ue.c, r: ue.r }, ne, x);
          break;
        case 5:
        case 517:
          ne = { ixfe: ue.ixfe, XF: Ee[ue.ixfe], v: ue.val, t: ue.t }, Re > 0 && (ne.z = ne.XF && ne.XF.numFmtId && Me[ne.XF.numFmtId] || Me[ne.ixfe >> 8 & 63]), safe_format_xf(ne, x, w.opts.Date1904), Ce({ c: ue.c, r: ue.r }, ne, x);
          break;
        case 638:
          ne = { ixfe: ue.ixfe, XF: Ee[ue.ixfe], v: ue.rknum, t: "n" }, Re > 0 && (ne.z = ne.XF && ne.XF.numFmtId && Me[ne.XF.numFmtId] || Me[ne.ixfe >> 8 & 63]), safe_format_xf(ne, x, w.opts.Date1904), Ce({ c: ue.c, r: ue.r }, ne, x);
          break;
        case 189:
          for (var it = ue.c; it <= ue.C; ++it) {
            var Ve = ue.rkrec[it - ue.c][0];
            ne = { ixfe: Ve, XF: Ee[Ve], v: ue.rkrec[it - ue.c][1], t: "n" }, Re > 0 && (ne.z = ne.XF && ne.XF.numFmtId && Me[ne.XF.numFmtId] || Me[ne.ixfe >> 8 & 63]), safe_format_xf(ne, x, w.opts.Date1904), Ce({ c: it, r: ue.r }, ne, x);
          }
          break;
        case 6:
        case 518:
        case 1030:
          {
            if (ue.val == "String") {
              X = ue;
              break;
            }
            if (ne = make_cell(ue.val, ue.cell.ixfe, ue.tt), ne.XF = Ee[ne.ixfe], x.cellFormula) {
              var st = ue.formula;
              if (st && st[0] && st[0][0] && st[0][0][0] == "PtgExp") {
                var dt = st[0][0][1][0], ut = st[0][0][1][1], mt = encode_cell({ r: dt, c: ut });
                Q[mt] ? ne.f = "" + stringify_formula(ue.formula, W, ue.cell, Ae, ye) : ne.F = ((x.dense ? (D["!data"][dt] || [])[ut] : D[mt]) || {}).F;
              } else ne.f = "" + stringify_formula(ue.formula, W, ue.cell, Ae, ye);
            }
            Re > 0 && (ne.z = ne.XF && ne.XF.numFmtId && Me[ne.XF.numFmtId] || Me[ne.ixfe >> 8 & 63]), safe_format_xf(ne, x, w.opts.Date1904), Ce(ue.cell, ne, x), X = ue;
          }
          break;
        case 7:
        case 519:
          if (X)
            X.val = ue, ne = make_cell(ue, X.cell.ixfe, "s"), ne.XF = Ee[ne.ixfe], x.cellFormula && (ne.f = "" + stringify_formula(X.formula, W, X.cell, Ae, ye)), Re > 0 && (ne.z = ne.XF && ne.XF.numFmtId && Me[ne.XF.numFmtId] || Me[ne.ixfe >> 8 & 63]), safe_format_xf(ne, x, w.opts.Date1904), Ce(X.cell, ne, x), X = null;
          else throw new Error("String record expects Formula");
          break;
        case 33:
        case 545:
          {
            oe.push(ue);
            var at = encode_cell(ue[0].s);
            if (J = x.dense ? (D["!data"][ue[0].s.r] || [])[ue[0].s.c] : D[at], x.cellFormula && J) {
              if (!X || !at || !J) break;
              J.f = "" + stringify_formula(ue[1], W, ue[0], Ae, ye), J.F = encode_range(ue[0]);
            }
          }
          break;
        case 1212:
          {
            if (!x.cellFormula) break;
            if (q) {
              if (!X) break;
              Q[encode_cell(X.cell)] = ue[0], J = x.dense ? (D["!data"][X.cell.r] || [])[X.cell.c] : D[encode_cell(X.cell)], (J || {}).f = "" + stringify_formula(ue[0], W, Z, Ae, ye);
            }
          }
          break;
        case 253:
          ne = make_cell(G[ue.isst].t, ue.ixfe, "s"), G[ue.isst].h && (ne.h = G[ue.isst].h), ne.XF = Ee[ne.ixfe], Re > 0 && (ne.z = ne.XF && ne.XF.numFmtId && Me[ne.XF.numFmtId] || Me[ne.ixfe >> 8 & 63]), safe_format_xf(ne, x, w.opts.Date1904), Ce({ c: ue.c, r: ue.r }, ne, x);
          break;
        case 513:
          x.sheetStubs && (ne = { ixfe: ue.ixfe, XF: Ee[ue.ixfe], t: "z" }, Re > 0 && (ne.z = ne.XF && ne.XF.numFmtId && Me[ne.XF.numFmtId] || Me[ne.ixfe >> 8 & 63]), safe_format_xf(ne, x, w.opts.Date1904), Ce({ c: ue.c, r: ue.r }, ne, x));
          break;
        case 190:
          if (x.sheetStubs)
            for (var lt = ue.c; lt <= ue.C; ++lt) {
              var Ke = ue.ixfe[lt - ue.c];
              ne = { ixfe: Ke, XF: Ee[Ke], t: "z" }, Re > 0 && (ne.z = ne.XF && ne.XF.numFmtId && Me[ne.XF.numFmtId] || Me[ne.ixfe >> 8 & 63]), safe_format_xf(ne, x, w.opts.Date1904), Ce({ c: lt, r: ue.r }, ne, x);
            }
          break;
        case 214:
        case 516:
        case 4:
          ne = make_cell(ue.val, ue.ixfe, "s"), ne.XF = Ee[ne.ixfe], Re > 0 && (ne.z = ne.XF && ne.XF.numFmtId && Me[ne.XF.numFmtId] || Me[ne.ixfe >> 8 & 63]), safe_format_xf(ne, x, w.opts.Date1904), Ce({ c: ue.c, r: ue.r }, ne, x);
          break;
        case 0:
        case 512:
          Ue === 1 && (W = ue);
          break;
        case 252:
          G = ue;
          break;
        case 1054:
          if (ye.biff >= 3 && ye.biff <= 4) {
            Me[Re++] = ue[1];
            for (var _t = 0; _t < Re + 163 && table_fmt[_t] != ue[1]; ++_t) ;
            _t >= 163 && SSF__load(ue[1], Re + 163);
          } else SSF__load(ue[1], ue[0]);
          break;
        case 30:
          {
            Me[Re++] = ue;
            for (var gt = 0; gt < Re + 163 && table_fmt[gt] != ue; ++gt) ;
            gt >= 163 && SSF__load(ue, Re + 163);
          }
          break;
        case 229:
          De = De.concat(ue);
          break;
        case 93:
          et[ue.cmo[0]] = ye.lastobj = ue;
          break;
        case 438:
          ye.lastobj.TxO = ue;
          break;
        case 127:
          ye.lastobj.ImData = ue;
          break;
        case 440:
          for (te = ue[0].s.r; te <= ue[0].e.r; ++te)
            for (re = ue[0].s.c; re <= ue[0].e.c; ++re)
              J = x.dense ? (D["!data"][te] || [])[re] : D[encode_cell({ c: re, r: te })], J && (J.l = ue[1]);
          break;
        case 2048:
          for (te = ue[0].s.r; te <= ue[0].e.r; ++te)
            for (re = ue[0].s.c; re <= ue[0].e.c; ++re)
              J = x.dense ? (D["!data"][te] || [])[re] : D[encode_cell({ c: re, r: te })], J && J.l && (J.l.Tooltip = ue[1]);
          break;
        case 28:
          {
            if (J = x.dense ? (D["!data"][ue[0].r] || [])[ue[0].c] : D[encode_cell(ue[0])], J || (x.dense ? (D["!data"][ue[0].r] || (D["!data"][ue[0].r] = []), J = D["!data"][ue[0].r][ue[0].c] = { t: "z" }) : J = D[encode_cell(ue[0])] = { t: "z" }, W.e.r = Math.max(W.e.r, ue[0].r), W.s.r = Math.min(W.s.r, ue[0].r), W.e.c = Math.max(W.e.c, ue[0].c), W.s.c = Math.min(W.s.c, ue[0].c)), J.c || (J.c = []), ye.biff <= 5 && ye.biff >= 2) ee = { a: "SheetJ5", t: ue[1] };
            else {
              var ht = et[ue[2]];
              ee = { a: ue[1], t: ht.TxO.t }, ue[3] != null && !(ue[3] & 2) && (J.c.hidden = !0);
            }
            J.c.push(ee);
          }
          break;
        case 2173:
          update_xfext(Ee[ue.ixfe], ue.ext);
          break;
        case 125:
          {
            if (!ye.cellStyles) break;
            for (; ue.e >= ue.s; )
              Oe[ue.e--] = { width: ue.w / 256, level: ue.level || 0, hidden: !!(ue.flags & 1) }, He || (He = !0, find_mdw_colw(ue.w / 256)), process_col(Oe[ue.e + 1]);
          }
          break;
        case 520:
          {
            var Pt = {};
            ue.level != null && (Xe[ue.r] = Pt, Pt.level = ue.level), ue.hidden && (Xe[ue.r] = Pt, Pt.hidden = !0), ue.hpt && (Xe[ue.r] = Pt, Pt.hpt = ue.hpt, Pt.hpx = pt2px(ue.hpt));
          }
          break;
        case 38:
        case 39:
        case 40:
        case 41:
          D["!margins"] || default_margins(D["!margins"] = {}), D["!margins"][{ 38: "left", 39: "right", 40: "top", 41: "bottom" }[Se]] = ue;
          break;
        case 161:
          D["!margins"] || default_margins(D["!margins"] = {}), D["!margins"].header = ue.header, D["!margins"].footer = ue.footer;
          break;
        case 574:
          ue.RTL && (de.Views[0].RTL = !0);
          break;
        case 146:
          Te = ue;
          break;
        case 2198:
          ze = ue;
          break;
        case 140:
          le = ue;
          break;
        case 442:
          Y ? ae.CodeName = ue || ae.name : de.WBProps.CodeName = ue || "ThisWorkbook";
          break;
      }
    } else
      me || console.error("Missing Info for XLS Record 0x" + Se.toString(16)), F.l += we;
  }
  return w.SheetNames = keys(U).sort(function(kt, tt) {
    return Number(kt) - Number(tt);
  }).map(function(kt) {
    return U[kt].name;
  }), x.bookSheets || (w.Sheets = O), !w.SheetNames.length && K["!ref"] ? (w.SheetNames.push("Sheet1"), w.Sheets && (w.Sheets.Sheet1 = K)) : w.Preamble = K, w.Sheets && je.forEach(function(kt, tt) {
    w.Sheets[w.SheetNames[tt]]["!autofilter"] = kt;
  }), w.Strings = G, w.SSF = dup(table_fmt), ye.enc && (w.Encryption = ye.enc), ze && (w.Themes = ze), w.Metadata = {}, le !== void 0 && (w.Metadata.Country = le), Ae.names.length > 0 && (de.Names = Ae.names), w.Workbook = de, w;
}
var PSCLSID = {
  SI: "e0859ff2f94f6810ab9108002b27b3d9",
  DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
  UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
};
function parse_xls_props(F, x, w) {
  var O = CFB.find(F, "/!DocumentSummaryInformation");
  if (O && O.size > 0) try {
    var D = parse_PropertySetStream(O, DocSummaryPIDDSI, PSCLSID.DSI);
    for (var U in D) x[U] = D[U];
  } catch (Y) {
    if (w.WTF) throw Y;
  }
  var W = CFB.find(F, "/!SummaryInformation");
  if (W && W.size > 0) try {
    var X = parse_PropertySetStream(W, SummaryPIDSI, PSCLSID.SI);
    for (var G in X) x[G] == null && (x[G] = X[G]);
  } catch (Y) {
    if (w.WTF) throw Y;
  }
  x.HeadingPairs && x.TitlesOfParts && (load_props_pairs(x.HeadingPairs, x.TitlesOfParts, x, w), delete x.HeadingPairs, delete x.TitlesOfParts);
}
function write_xls_props(F, x) {
  var w = [], O = [], D = [], U = 0, W, X = evert_key(DocSummaryPIDDSI, "n"), G = evert_key(SummaryPIDSI, "n");
  if (F.Props)
    for (W = keys(F.Props), U = 0; U < W.length; ++U) (Object.prototype.hasOwnProperty.call(X, W[U]) ? w : Object.prototype.hasOwnProperty.call(G, W[U]) ? O : D).push([W[U], F.Props[W[U]]]);
  if (F.Custprops)
    for (W = keys(F.Custprops), U = 0; U < W.length; ++U) Object.prototype.hasOwnProperty.call(F.Props || {}, W[U]) || (Object.prototype.hasOwnProperty.call(X, W[U]) ? w : Object.prototype.hasOwnProperty.call(G, W[U]) ? O : D).push([W[U], F.Custprops[W[U]]]);
  var Y = [];
  for (U = 0; U < D.length; ++U)
    XLSPSSkip.indexOf(D[U][0]) > -1 || PseudoPropsPairs.indexOf(D[U][0]) > -1 || D[U][1] != null && Y.push(D[U]);
  O.length && CFB.utils.cfb_add(x, "/SummaryInformation", write_PropertySetStream(O, PSCLSID.SI, G, SummaryPIDSI)), (w.length || Y.length) && CFB.utils.cfb_add(x, "/DocumentSummaryInformation", write_PropertySetStream(w, PSCLSID.DSI, X, DocSummaryPIDDSI, Y.length ? Y : null, PSCLSID.UDI));
}
function parse_xlscfb(F, x) {
  x || (x = {}), fix_read_opts(x), reset_cp(), x.codepage && set_ansi(x.codepage);
  var w, O;
  if (F.FullPaths) {
    if (CFB.find(F, "/encryption")) throw new Error("File is password-protected");
    w = CFB.find(F, "!CompObj"), O = CFB.find(F, "/Workbook") || CFB.find(F, "/Book");
  } else {
    switch (x.type) {
      case "base64":
        F = s2a(Base64_decode(F));
        break;
      case "binary":
        F = s2a(F);
        break;
      case "buffer":
        break;
      case "array":
        Array.isArray(F) || (F = Array.prototype.slice.call(F));
        break;
    }
    prep_blob(F, 0), O = { content: F };
  }
  var D, U;
  if (w && parse_compobj(w), x.bookProps && !x.bookSheets) D = {};
  else {
    var W = has_buf ? "buffer" : "array";
    if (O && O.content) D = parse_workbook(O.content, x);
    else if ((U = CFB.find(F, "PerfectOffice_MAIN")) && U.content) D = WK_.to_workbook(U.content, (x.type = W, x));
    else if ((U = CFB.find(F, "NativeContent_MAIN")) && U.content) D = WK_.to_workbook(U.content, (x.type = W, x));
    else throw (U = CFB.find(F, "MN0")) && U.content ? new Error("Unsupported Works 4 for Mac file") : new Error("Cannot find Workbook stream");
    x.bookVBA && F.FullPaths && CFB.find(F, "/_VBA_PROJECT_CUR/VBA/dir") && (D.vbaraw = make_vba_xls(F));
  }
  var X = {};
  return F.FullPaths && parse_xls_props(
    /*::((*/
    F,
    X,
    x
  ), D.Props = D.Custprops = X, x.bookFiles && (D.cfb = F), D;
}
function write_xlscfb(F, x) {
  var w = x, O = CFB.utils.cfb_new({ root: "R" }), D = "/Workbook";
  switch (w.bookType || "xls") {
    case "xls":
      w.bookType = "biff8";
    /* falls through */
    case "xla":
      w.bookType || (w.bookType = "xla");
    /* falls through */
    case "biff8":
      D = "/Workbook", w.biff = 8;
      break;
    case "biff5":
      D = "/Book", w.biff = 5;
      break;
    default:
      throw new Error("invalid type " + w.bookType + " for XLS CFB");
  }
  return CFB.utils.cfb_add(O, D, write_biff_buf(F, w)), w.biff == 8 && (F.Props || F.Custprops) && write_xls_props(F, O), w.biff == 8 && F.vbaraw && fill_vba_xls(O, CFB.read(F.vbaraw, { type: typeof F.vbaraw == "string" ? "binary" : "buffer" })), O;
}
var XLSBRecordEnum = {
  0: {
    /* n:"BrtRowHdr", */
    f: parse_BrtRowHdr
  },
  1: {
    /* n:"BrtCellBlank", */
    f: parse_BrtCellBlank
  },
  2: {
    /* n:"BrtCellRk", */
    f: parse_BrtCellRk
  },
  3: {
    /* n:"BrtCellError", */
    f: parse_BrtCellError
  },
  4: {
    /* n:"BrtCellBool", */
    f: parse_BrtCellBool
  },
  5: {
    /* n:"BrtCellReal", */
    f: parse_BrtCellReal
  },
  6: {
    /* n:"BrtCellSt", */
    f: parse_BrtCellSt
  },
  7: {
    /* n:"BrtCellIsst", */
    f: parse_BrtCellIsst
  },
  8: {
    /* n:"BrtFmlaString", */
    f: parse_BrtFmlaString
  },
  9: {
    /* n:"BrtFmlaNum", */
    f: parse_BrtFmlaNum
  },
  10: {
    /* n:"BrtFmlaBool", */
    f: parse_BrtFmlaBool
  },
  11: {
    /* n:"BrtFmlaError", */
    f: parse_BrtFmlaError
  },
  12: {
    /* n:"BrtShortBlank", */
    f: parse_BrtShortBlank
  },
  13: {
    /* n:"BrtShortRk", */
    f: parse_BrtShortRk
  },
  14: {
    /* n:"BrtShortError", */
    f: parse_BrtShortError
  },
  15: {
    /* n:"BrtShortBool", */
    f: parse_BrtShortBool
  },
  16: {
    /* n:"BrtShortReal", */
    f: parse_BrtShortReal
  },
  17: {
    /* n:"BrtShortSt", */
    f: parse_BrtShortSt
  },
  18: {
    /* n:"BrtShortIsst", */
    f: parse_BrtShortIsst
  },
  19: {
    /* n:"BrtSSTItem", */
    f: parse_RichStr
  },
  20: {
    /* n:"BrtPCDIMissing" */
  },
  21: {
    /* n:"BrtPCDINumber" */
  },
  22: {
    /* n:"BrtPCDIBoolean" */
  },
  23: {
    /* n:"BrtPCDIError" */
  },
  24: {
    /* n:"BrtPCDIString" */
  },
  25: {
    /* n:"BrtPCDIDatetime" */
  },
  26: {
    /* n:"BrtPCDIIndex" */
  },
  27: {
    /* n:"BrtPCDIAMissing" */
  },
  28: {
    /* n:"BrtPCDIANumber" */
  },
  29: {
    /* n:"BrtPCDIABoolean" */
  },
  30: {
    /* n:"BrtPCDIAError" */
  },
  31: {
    /* n:"BrtPCDIAString" */
  },
  32: {
    /* n:"BrtPCDIADatetime" */
  },
  33: {
    /* n:"BrtPCRRecord" */
  },
  34: {
    /* n:"BrtPCRRecordDt" */
  },
  35: {
    /* n:"BrtFRTBegin", */
    T: 1
  },
  36: {
    /* n:"BrtFRTEnd", */
    T: -1
  },
  37: {
    /* n:"BrtACBegin", */
    T: 1
  },
  38: {
    /* n:"BrtACEnd", */
    T: -1
  },
  39: {
    /* n:"BrtName", */
    f: parse_BrtName
  },
  40: {
    /* n:"BrtIndexRowBlock" */
  },
  42: {
    /* n:"BrtIndexBlock" */
  },
  43: {
    /* n:"BrtFont", */
    f: parse_BrtFont
  },
  44: {
    /* n:"BrtFmt", */
    f: parse_BrtFmt
  },
  45: {
    /* n:"BrtFill", */
    f: parse_BrtFill
  },
  46: {
    /* n:"BrtBorder", */
    f: parse_BrtBorder
  },
  47: {
    /* n:"BrtXF", */
    f: parse_BrtXF
  },
  48: {
    /* n:"BrtStyle" */
  },
  49: {
    /* n:"BrtCellMeta", */
    f: parse_Int32LE
  },
  50: {
    /* n:"BrtValueMeta" */
  },
  51: {
    /* n:"BrtMdb" */
    f: parse_BrtMdb
  },
  52: {
    /* n:"BrtBeginFmd", */
    T: 1
  },
  53: {
    /* n:"BrtEndFmd", */
    T: -1
  },
  54: {
    /* n:"BrtBeginMdx", */
    T: 1
  },
  55: {
    /* n:"BrtEndMdx", */
    T: -1
  },
  56: {
    /* n:"BrtBeginMdxTuple", */
    T: 1
  },
  57: {
    /* n:"BrtEndMdxTuple", */
    T: -1
  },
  58: {
    /* n:"BrtMdxMbrIstr" */
  },
  59: {
    /* n:"BrtStr" */
  },
  60: {
    /* n:"BrtColInfo", */
    f: parse_ColInfo
  },
  62: {
    /* n:"BrtCellRString", */
    f: parse_BrtCellRString
  },
  63: {
    /* n:"BrtCalcChainItem$", */
    f: parse_BrtCalcChainItem$
  },
  64: {
    /* n:"BrtDVal", */
    f: parse_BrtDVal
  },
  65: {
    /* n:"BrtSxvcellNum" */
  },
  66: {
    /* n:"BrtSxvcellStr" */
  },
  67: {
    /* n:"BrtSxvcellBool" */
  },
  68: {
    /* n:"BrtSxvcellErr" */
  },
  69: {
    /* n:"BrtSxvcellDate" */
  },
  70: {
    /* n:"BrtSxvcellNil" */
  },
  128: {
    /* n:"BrtFileVersion" */
  },
  129: {
    /* n:"BrtBeginSheet", */
    T: 1
  },
  130: {
    /* n:"BrtEndSheet", */
    T: -1
  },
  131: {
    /* n:"BrtBeginBook", */
    T: 1,
    f: parsenoop,
    p: 0
  },
  132: {
    /* n:"BrtEndBook", */
    T: -1
  },
  133: {
    /* n:"BrtBeginWsViews", */
    T: 1
  },
  134: {
    /* n:"BrtEndWsViews", */
    T: -1
  },
  135: {
    /* n:"BrtBeginBookViews", */
    T: 1
  },
  136: {
    /* n:"BrtEndBookViews", */
    T: -1
  },
  137: {
    /* n:"BrtBeginWsView", */
    T: 1,
    f: parse_BrtBeginWsView
  },
  138: {
    /* n:"BrtEndWsView", */
    T: -1
  },
  139: {
    /* n:"BrtBeginCsViews", */
    T: 1
  },
  140: {
    /* n:"BrtEndCsViews", */
    T: -1
  },
  141: {
    /* n:"BrtBeginCsView", */
    T: 1
  },
  142: {
    /* n:"BrtEndCsView", */
    T: -1
  },
  143: {
    /* n:"BrtBeginBundleShs", */
    T: 1
  },
  144: {
    /* n:"BrtEndBundleShs", */
    T: -1
  },
  145: {
    /* n:"BrtBeginSheetData", */
    T: 1
  },
  146: {
    /* n:"BrtEndSheetData", */
    T: -1
  },
  147: {
    /* n:"BrtWsProp", */
    f: parse_BrtWsProp
  },
  148: {
    /* n:"BrtWsDim", */
    f: parse_BrtWsDim,
    p: 16
  },
  151: {
    /* n:"BrtPane", */
    f: parse_BrtPane
  },
  152: {
    /* n:"BrtSel" */
  },
  153: {
    /* n:"BrtWbProp", */
    f: parse_BrtWbProp
  },
  154: {
    /* n:"BrtWbFactoid" */
  },
  155: {
    /* n:"BrtFileRecover" */
  },
  156: {
    /* n:"BrtBundleSh", */
    f: parse_BrtBundleSh
  },
  157: {
    /* n:"BrtCalcProp" */
  },
  158: {
    /* n:"BrtBookView" */
  },
  159: {
    /* n:"BrtBeginSst", */
    T: 1,
    f: parse_BrtBeginSst
  },
  160: {
    /* n:"BrtEndSst", */
    T: -1
  },
  161: {
    /* n:"BrtBeginAFilter", */
    T: 1,
    f: parse_UncheckedRfX
  },
  162: {
    /* n:"BrtEndAFilter", */
    T: -1
  },
  163: {
    /* n:"BrtBeginFilterColumn", */
    T: 1
  },
  164: {
    /* n:"BrtEndFilterColumn", */
    T: -1
  },
  165: {
    /* n:"BrtBeginFilters", */
    T: 1
  },
  166: {
    /* n:"BrtEndFilters", */
    T: -1
  },
  167: {
    /* n:"BrtFilter" */
  },
  168: {
    /* n:"BrtColorFilter" */
  },
  169: {
    /* n:"BrtIconFilter" */
  },
  170: {
    /* n:"BrtTop10Filter" */
  },
  171: {
    /* n:"BrtDynamicFilter" */
  },
  172: {
    /* n:"BrtBeginCustomFilters", */
    T: 1
  },
  173: {
    /* n:"BrtEndCustomFilters", */
    T: -1
  },
  174: {
    /* n:"BrtCustomFilter" */
  },
  175: {
    /* n:"BrtAFilterDateGroupItem" */
  },
  176: {
    /* n:"BrtMergeCell", */
    f: parse_BrtMergeCell
  },
  177: {
    /* n:"BrtBeginMergeCells", */
    T: 1
  },
  178: {
    /* n:"BrtEndMergeCells", */
    T: -1
  },
  179: {
    /* n:"BrtBeginPivotCacheDef", */
    T: 1
  },
  180: {
    /* n:"BrtEndPivotCacheDef", */
    T: -1
  },
  181: {
    /* n:"BrtBeginPCDFields", */
    T: 1
  },
  182: {
    /* n:"BrtEndPCDFields", */
    T: -1
  },
  183: {
    /* n:"BrtBeginPCDField", */
    T: 1
  },
  184: {
    /* n:"BrtEndPCDField", */
    T: -1
  },
  185: {
    /* n:"BrtBeginPCDSource", */
    T: 1
  },
  186: {
    /* n:"BrtEndPCDSource", */
    T: -1
  },
  187: {
    /* n:"BrtBeginPCDSRange", */
    T: 1
  },
  188: {
    /* n:"BrtEndPCDSRange", */
    T: -1
  },
  189: {
    /* n:"BrtBeginPCDFAtbl", */
    T: 1
  },
  190: {
    /* n:"BrtEndPCDFAtbl", */
    T: -1
  },
  191: {
    /* n:"BrtBeginPCDIRun", */
    T: 1
  },
  192: {
    /* n:"BrtEndPCDIRun", */
    T: -1
  },
  193: {
    /* n:"BrtBeginPivotCacheRecords", */
    T: 1
  },
  194: {
    /* n:"BrtEndPivotCacheRecords", */
    T: -1
  },
  195: {
    /* n:"BrtBeginPCDHierarchies", */
    T: 1
  },
  196: {
    /* n:"BrtEndPCDHierarchies", */
    T: -1
  },
  197: {
    /* n:"BrtBeginPCDHierarchy", */
    T: 1
  },
  198: {
    /* n:"BrtEndPCDHierarchy", */
    T: -1
  },
  199: {
    /* n:"BrtBeginPCDHFieldsUsage", */
    T: 1
  },
  200: {
    /* n:"BrtEndPCDHFieldsUsage", */
    T: -1
  },
  201: {
    /* n:"BrtBeginExtConnection", */
    T: 1
  },
  202: {
    /* n:"BrtEndExtConnection", */
    T: -1
  },
  203: {
    /* n:"BrtBeginECDbProps", */
    T: 1
  },
  204: {
    /* n:"BrtEndECDbProps", */
    T: -1
  },
  205: {
    /* n:"BrtBeginECOlapProps", */
    T: 1
  },
  206: {
    /* n:"BrtEndECOlapProps", */
    T: -1
  },
  207: {
    /* n:"BrtBeginPCDSConsol", */
    T: 1
  },
  208: {
    /* n:"BrtEndPCDSConsol", */
    T: -1
  },
  209: {
    /* n:"BrtBeginPCDSCPages", */
    T: 1
  },
  210: {
    /* n:"BrtEndPCDSCPages", */
    T: -1
  },
  211: {
    /* n:"BrtBeginPCDSCPage", */
    T: 1
  },
  212: {
    /* n:"BrtEndPCDSCPage", */
    T: -1
  },
  213: {
    /* n:"BrtBeginPCDSCPItem", */
    T: 1
  },
  214: {
    /* n:"BrtEndPCDSCPItem", */
    T: -1
  },
  215: {
    /* n:"BrtBeginPCDSCSets", */
    T: 1
  },
  216: {
    /* n:"BrtEndPCDSCSets", */
    T: -1
  },
  217: {
    /* n:"BrtBeginPCDSCSet", */
    T: 1
  },
  218: {
    /* n:"BrtEndPCDSCSet", */
    T: -1
  },
  219: {
    /* n:"BrtBeginPCDFGroup", */
    T: 1
  },
  220: {
    /* n:"BrtEndPCDFGroup", */
    T: -1
  },
  221: {
    /* n:"BrtBeginPCDFGItems", */
    T: 1
  },
  222: {
    /* n:"BrtEndPCDFGItems", */
    T: -1
  },
  223: {
    /* n:"BrtBeginPCDFGRange", */
    T: 1
  },
  224: {
    /* n:"BrtEndPCDFGRange", */
    T: -1
  },
  225: {
    /* n:"BrtBeginPCDFGDiscrete", */
    T: 1
  },
  226: {
    /* n:"BrtEndPCDFGDiscrete", */
    T: -1
  },
  227: {
    /* n:"BrtBeginPCDSDTupleCache", */
    T: 1
  },
  228: {
    /* n:"BrtEndPCDSDTupleCache", */
    T: -1
  },
  229: {
    /* n:"BrtBeginPCDSDTCEntries", */
    T: 1
  },
  230: {
    /* n:"BrtEndPCDSDTCEntries", */
    T: -1
  },
  231: {
    /* n:"BrtBeginPCDSDTCEMembers", */
    T: 1
  },
  232: {
    /* n:"BrtEndPCDSDTCEMembers", */
    T: -1
  },
  233: {
    /* n:"BrtBeginPCDSDTCEMember", */
    T: 1
  },
  234: {
    /* n:"BrtEndPCDSDTCEMember", */
    T: -1
  },
  235: {
    /* n:"BrtBeginPCDSDTCQueries", */
    T: 1
  },
  236: {
    /* n:"BrtEndPCDSDTCQueries", */
    T: -1
  },
  237: {
    /* n:"BrtBeginPCDSDTCQuery", */
    T: 1
  },
  238: {
    /* n:"BrtEndPCDSDTCQuery", */
    T: -1
  },
  239: {
    /* n:"BrtBeginPCDSDTCSets", */
    T: 1
  },
  240: {
    /* n:"BrtEndPCDSDTCSets", */
    T: -1
  },
  241: {
    /* n:"BrtBeginPCDSDTCSet", */
    T: 1
  },
  242: {
    /* n:"BrtEndPCDSDTCSet", */
    T: -1
  },
  243: {
    /* n:"BrtBeginPCDCalcItems", */
    T: 1
  },
  244: {
    /* n:"BrtEndPCDCalcItems", */
    T: -1
  },
  245: {
    /* n:"BrtBeginPCDCalcItem", */
    T: 1
  },
  246: {
    /* n:"BrtEndPCDCalcItem", */
    T: -1
  },
  247: {
    /* n:"BrtBeginPRule", */
    T: 1
  },
  248: {
    /* n:"BrtEndPRule", */
    T: -1
  },
  249: {
    /* n:"BrtBeginPRFilters", */
    T: 1
  },
  250: {
    /* n:"BrtEndPRFilters", */
    T: -1
  },
  251: {
    /* n:"BrtBeginPRFilter", */
    T: 1
  },
  252: {
    /* n:"BrtEndPRFilter", */
    T: -1
  },
  253: {
    /* n:"BrtBeginPNames", */
    T: 1
  },
  254: {
    /* n:"BrtEndPNames", */
    T: -1
  },
  255: {
    /* n:"BrtBeginPName", */
    T: 1
  },
  256: {
    /* n:"BrtEndPName", */
    T: -1
  },
  257: {
    /* n:"BrtBeginPNPairs", */
    T: 1
  },
  258: {
    /* n:"BrtEndPNPairs", */
    T: -1
  },
  259: {
    /* n:"BrtBeginPNPair", */
    T: 1
  },
  260: {
    /* n:"BrtEndPNPair", */
    T: -1
  },
  261: {
    /* n:"BrtBeginECWebProps", */
    T: 1
  },
  262: {
    /* n:"BrtEndECWebProps", */
    T: -1
  },
  263: {
    /* n:"BrtBeginEcWpTables", */
    T: 1
  },
  264: {
    /* n:"BrtEndECWPTables", */
    T: -1
  },
  265: {
    /* n:"BrtBeginECParams", */
    T: 1
  },
  266: {
    /* n:"BrtEndECParams", */
    T: -1
  },
  267: {
    /* n:"BrtBeginECParam", */
    T: 1
  },
  268: {
    /* n:"BrtEndECParam", */
    T: -1
  },
  269: {
    /* n:"BrtBeginPCDKPIs", */
    T: 1
  },
  270: {
    /* n:"BrtEndPCDKPIs", */
    T: -1
  },
  271: {
    /* n:"BrtBeginPCDKPI", */
    T: 1
  },
  272: {
    /* n:"BrtEndPCDKPI", */
    T: -1
  },
  273: {
    /* n:"BrtBeginDims", */
    T: 1
  },
  274: {
    /* n:"BrtEndDims", */
    T: -1
  },
  275: {
    /* n:"BrtBeginDim", */
    T: 1
  },
  276: {
    /* n:"BrtEndDim", */
    T: -1
  },
  277: {
    /* n:"BrtIndexPartEnd" */
  },
  278: {
    /* n:"BrtBeginStyleSheet", */
    T: 1
  },
  279: {
    /* n:"BrtEndStyleSheet", */
    T: -1
  },
  280: {
    /* n:"BrtBeginSXView", */
    T: 1
  },
  281: {
    /* n:"BrtEndSXVI", */
    T: -1
  },
  282: {
    /* n:"BrtBeginSXVI", */
    T: 1
  },
  283: {
    /* n:"BrtBeginSXVIs", */
    T: 1
  },
  284: {
    /* n:"BrtEndSXVIs", */
    T: -1
  },
  285: {
    /* n:"BrtBeginSXVD", */
    T: 1
  },
  286: {
    /* n:"BrtEndSXVD", */
    T: -1
  },
  287: {
    /* n:"BrtBeginSXVDs", */
    T: 1
  },
  288: {
    /* n:"BrtEndSXVDs", */
    T: -1
  },
  289: {
    /* n:"BrtBeginSXPI", */
    T: 1
  },
  290: {
    /* n:"BrtEndSXPI", */
    T: -1
  },
  291: {
    /* n:"BrtBeginSXPIs", */
    T: 1
  },
  292: {
    /* n:"BrtEndSXPIs", */
    T: -1
  },
  293: {
    /* n:"BrtBeginSXDI", */
    T: 1
  },
  294: {
    /* n:"BrtEndSXDI", */
    T: -1
  },
  295: {
    /* n:"BrtBeginSXDIs", */
    T: 1
  },
  296: {
    /* n:"BrtEndSXDIs", */
    T: -1
  },
  297: {
    /* n:"BrtBeginSXLI", */
    T: 1
  },
  298: {
    /* n:"BrtEndSXLI", */
    T: -1
  },
  299: {
    /* n:"BrtBeginSXLIRws", */
    T: 1
  },
  300: {
    /* n:"BrtEndSXLIRws", */
    T: -1
  },
  301: {
    /* n:"BrtBeginSXLICols", */
    T: 1
  },
  302: {
    /* n:"BrtEndSXLICols", */
    T: -1
  },
  303: {
    /* n:"BrtBeginSXFormat", */
    T: 1
  },
  304: {
    /* n:"BrtEndSXFormat", */
    T: -1
  },
  305: {
    /* n:"BrtBeginSXFormats", */
    T: 1
  },
  306: {
    /* n:"BrtEndSxFormats", */
    T: -1
  },
  307: {
    /* n:"BrtBeginSxSelect", */
    T: 1
  },
  308: {
    /* n:"BrtEndSxSelect", */
    T: -1
  },
  309: {
    /* n:"BrtBeginISXVDRws", */
    T: 1
  },
  310: {
    /* n:"BrtEndISXVDRws", */
    T: -1
  },
  311: {
    /* n:"BrtBeginISXVDCols", */
    T: 1
  },
  312: {
    /* n:"BrtEndISXVDCols", */
    T: -1
  },
  313: {
    /* n:"BrtEndSXLocation", */
    T: -1
  },
  314: {
    /* n:"BrtBeginSXLocation", */
    T: 1
  },
  315: {
    /* n:"BrtEndSXView", */
    T: -1
  },
  316: {
    /* n:"BrtBeginSXTHs", */
    T: 1
  },
  317: {
    /* n:"BrtEndSXTHs", */
    T: -1
  },
  318: {
    /* n:"BrtBeginSXTH", */
    T: 1
  },
  319: {
    /* n:"BrtEndSXTH", */
    T: -1
  },
  320: {
    /* n:"BrtBeginISXTHRws", */
    T: 1
  },
  321: {
    /* n:"BrtEndISXTHRws", */
    T: -1
  },
  322: {
    /* n:"BrtBeginISXTHCols", */
    T: 1
  },
  323: {
    /* n:"BrtEndISXTHCols", */
    T: -1
  },
  324: {
    /* n:"BrtBeginSXTDMPS", */
    T: 1
  },
  325: {
    /* n:"BrtEndSXTDMPs", */
    T: -1
  },
  326: {
    /* n:"BrtBeginSXTDMP", */
    T: 1
  },
  327: {
    /* n:"BrtEndSXTDMP", */
    T: -1
  },
  328: {
    /* n:"BrtBeginSXTHItems", */
    T: 1
  },
  329: {
    /* n:"BrtEndSXTHItems", */
    T: -1
  },
  330: {
    /* n:"BrtBeginSXTHItem", */
    T: 1
  },
  331: {
    /* n:"BrtEndSXTHItem", */
    T: -1
  },
  332: {
    /* n:"BrtBeginMetadata", */
    T: 1
  },
  333: {
    /* n:"BrtEndMetadata", */
    T: -1
  },
  334: {
    /* n:"BrtBeginEsmdtinfo", */
    T: 1
  },
  335: {
    /* n:"BrtMdtinfo", */
    f: parse_BrtMdtinfo
  },
  336: {
    /* n:"BrtEndEsmdtinfo", */
    T: -1
  },
  337: {
    /* n:"BrtBeginEsmdb", */
    f: parse_BrtBeginEsmdb,
    T: 1
  },
  338: {
    /* n:"BrtEndEsmdb", */
    T: -1
  },
  339: {
    /* n:"BrtBeginEsfmd", */
    T: 1
  },
  340: {
    /* n:"BrtEndEsfmd", */
    T: -1
  },
  341: {
    /* n:"BrtBeginSingleCells", */
    T: 1
  },
  342: {
    /* n:"BrtEndSingleCells", */
    T: -1
  },
  343: {
    /* n:"BrtBeginList", */
    T: 1
  },
  344: {
    /* n:"BrtEndList", */
    T: -1
  },
  345: {
    /* n:"BrtBeginListCols", */
    T: 1
  },
  346: {
    /* n:"BrtEndListCols", */
    T: -1
  },
  347: {
    /* n:"BrtBeginListCol", */
    T: 1
  },
  348: {
    /* n:"BrtEndListCol", */
    T: -1
  },
  349: {
    /* n:"BrtBeginListXmlCPr", */
    T: 1
  },
  350: {
    /* n:"BrtEndListXmlCPr", */
    T: -1
  },
  351: {
    /* n:"BrtListCCFmla" */
  },
  352: {
    /* n:"BrtListTrFmla" */
  },
  353: {
    /* n:"BrtBeginExternals", */
    T: 1
  },
  354: {
    /* n:"BrtEndExternals", */
    T: -1
  },
  355: {
    /* n:"BrtSupBookSrc", */
    f: parse_RelID
  },
  357: {
    /* n:"BrtSupSelf" */
  },
  358: {
    /* n:"BrtSupSame" */
  },
  359: {
    /* n:"BrtSupTabs" */
  },
  360: {
    /* n:"BrtBeginSupBook", */
    T: 1
  },
  361: {
    /* n:"BrtPlaceholderName" */
  },
  362: {
    /* n:"BrtExternSheet", */
    f: parse_ExternSheet
  },
  363: {
    /* n:"BrtExternTableStart" */
  },
  364: {
    /* n:"BrtExternTableEnd" */
  },
  366: {
    /* n:"BrtExternRowHdr" */
  },
  367: {
    /* n:"BrtExternCellBlank" */
  },
  368: {
    /* n:"BrtExternCellReal" */
  },
  369: {
    /* n:"BrtExternCellBool" */
  },
  370: {
    /* n:"BrtExternCellError" */
  },
  371: {
    /* n:"BrtExternCellString" */
  },
  372: {
    /* n:"BrtBeginEsmdx", */
    T: 1
  },
  373: {
    /* n:"BrtEndEsmdx", */
    T: -1
  },
  374: {
    /* n:"BrtBeginMdxSet", */
    T: 1
  },
  375: {
    /* n:"BrtEndMdxSet", */
    T: -1
  },
  376: {
    /* n:"BrtBeginMdxMbrProp", */
    T: 1
  },
  377: {
    /* n:"BrtEndMdxMbrProp", */
    T: -1
  },
  378: {
    /* n:"BrtBeginMdxKPI", */
    T: 1
  },
  379: {
    /* n:"BrtEndMdxKPI", */
    T: -1
  },
  380: {
    /* n:"BrtBeginEsstr", */
    T: 1
  },
  381: {
    /* n:"BrtEndEsstr", */
    T: -1
  },
  382: {
    /* n:"BrtBeginPRFItem", */
    T: 1
  },
  383: {
    /* n:"BrtEndPRFItem", */
    T: -1
  },
  384: {
    /* n:"BrtBeginPivotCacheIDs", */
    T: 1
  },
  385: {
    /* n:"BrtEndPivotCacheIDs", */
    T: -1
  },
  386: {
    /* n:"BrtBeginPivotCacheID", */
    T: 1
  },
  387: {
    /* n:"BrtEndPivotCacheID", */
    T: -1
  },
  388: {
    /* n:"BrtBeginISXVIs", */
    T: 1
  },
  389: {
    /* n:"BrtEndISXVIs", */
    T: -1
  },
  390: {
    /* n:"BrtBeginColInfos", */
    T: 1
  },
  391: {
    /* n:"BrtEndColInfos", */
    T: -1
  },
  392: {
    /* n:"BrtBeginRwBrk", */
    T: 1
  },
  393: {
    /* n:"BrtEndRwBrk", */
    T: -1
  },
  394: {
    /* n:"BrtBeginColBrk", */
    T: 1
  },
  395: {
    /* n:"BrtEndColBrk", */
    T: -1
  },
  396: {
    /* n:"BrtBrk" */
  },
  397: {
    /* n:"BrtUserBookView" */
  },
  398: {
    /* n:"BrtInfo" */
  },
  399: {
    /* n:"BrtCUsr" */
  },
  400: {
    /* n:"BrtUsr" */
  },
  401: {
    /* n:"BrtBeginUsers", */
    T: 1
  },
  403: {
    /* n:"BrtEOF" */
  },
  404: {
    /* n:"BrtUCR" */
  },
  405: {
    /* n:"BrtRRInsDel" */
  },
  406: {
    /* n:"BrtRREndInsDel" */
  },
  407: {
    /* n:"BrtRRMove" */
  },
  408: {
    /* n:"BrtRREndMove" */
  },
  409: {
    /* n:"BrtRRChgCell" */
  },
  410: {
    /* n:"BrtRREndChgCell" */
  },
  411: {
    /* n:"BrtRRHeader" */
  },
  412: {
    /* n:"BrtRRUserView" */
  },
  413: {
    /* n:"BrtRRRenSheet" */
  },
  414: {
    /* n:"BrtRRInsertSh" */
  },
  415: {
    /* n:"BrtRRDefName" */
  },
  416: {
    /* n:"BrtRRNote" */
  },
  417: {
    /* n:"BrtRRConflict" */
  },
  418: {
    /* n:"BrtRRTQSIF" */
  },
  419: {
    /* n:"BrtRRFormat" */
  },
  420: {
    /* n:"BrtRREndFormat" */
  },
  421: {
    /* n:"BrtRRAutoFmt" */
  },
  422: {
    /* n:"BrtBeginUserShViews", */
    T: 1
  },
  423: {
    /* n:"BrtBeginUserShView", */
    T: 1
  },
  424: {
    /* n:"BrtEndUserShView", */
    T: -1
  },
  425: {
    /* n:"BrtEndUserShViews", */
    T: -1
  },
  426: {
    /* n:"BrtArrFmla", */
    f: parse_BrtArrFmla
  },
  427: {
    /* n:"BrtShrFmla", */
    f: parse_BrtShrFmla
  },
  428: {
    /* n:"BrtTable" */
  },
  429: {
    /* n:"BrtBeginExtConnections", */
    T: 1
  },
  430: {
    /* n:"BrtEndExtConnections", */
    T: -1
  },
  431: {
    /* n:"BrtBeginPCDCalcMems", */
    T: 1
  },
  432: {
    /* n:"BrtEndPCDCalcMems", */
    T: -1
  },
  433: {
    /* n:"BrtBeginPCDCalcMem", */
    T: 1
  },
  434: {
    /* n:"BrtEndPCDCalcMem", */
    T: -1
  },
  435: {
    /* n:"BrtBeginPCDHGLevels", */
    T: 1
  },
  436: {
    /* n:"BrtEndPCDHGLevels", */
    T: -1
  },
  437: {
    /* n:"BrtBeginPCDHGLevel", */
    T: 1
  },
  438: {
    /* n:"BrtEndPCDHGLevel", */
    T: -1
  },
  439: {
    /* n:"BrtBeginPCDHGLGroups", */
    T: 1
  },
  440: {
    /* n:"BrtEndPCDHGLGroups", */
    T: -1
  },
  441: {
    /* n:"BrtBeginPCDHGLGroup", */
    T: 1
  },
  442: {
    /* n:"BrtEndPCDHGLGroup", */
    T: -1
  },
  443: {
    /* n:"BrtBeginPCDHGLGMembers", */
    T: 1
  },
  444: {
    /* n:"BrtEndPCDHGLGMembers", */
    T: -1
  },
  445: {
    /* n:"BrtBeginPCDHGLGMember", */
    T: 1
  },
  446: {
    /* n:"BrtEndPCDHGLGMember", */
    T: -1
  },
  447: {
    /* n:"BrtBeginQSI", */
    T: 1
  },
  448: {
    /* n:"BrtEndQSI", */
    T: -1
  },
  449: {
    /* n:"BrtBeginQSIR", */
    T: 1
  },
  450: {
    /* n:"BrtEndQSIR", */
    T: -1
  },
  451: {
    /* n:"BrtBeginDeletedNames", */
    T: 1
  },
  452: {
    /* n:"BrtEndDeletedNames", */
    T: -1
  },
  453: {
    /* n:"BrtBeginDeletedName", */
    T: 1
  },
  454: {
    /* n:"BrtEndDeletedName", */
    T: -1
  },
  455: {
    /* n:"BrtBeginQSIFs", */
    T: 1
  },
  456: {
    /* n:"BrtEndQSIFs", */
    T: -1
  },
  457: {
    /* n:"BrtBeginQSIF", */
    T: 1
  },
  458: {
    /* n:"BrtEndQSIF", */
    T: -1
  },
  459: {
    /* n:"BrtBeginAutoSortScope", */
    T: 1
  },
  460: {
    /* n:"BrtEndAutoSortScope", */
    T: -1
  },
  461: {
    /* n:"BrtBeginConditionalFormatting", */
    T: 1
  },
  462: {
    /* n:"BrtEndConditionalFormatting", */
    T: -1
  },
  463: {
    /* n:"BrtBeginCFRule", */
    T: 1
  },
  464: {
    /* n:"BrtEndCFRule", */
    T: -1
  },
  465: {
    /* n:"BrtBeginIconSet", */
    T: 1
  },
  466: {
    /* n:"BrtEndIconSet", */
    T: -1
  },
  467: {
    /* n:"BrtBeginDatabar", */
    T: 1
  },
  468: {
    /* n:"BrtEndDatabar", */
    T: -1
  },
  469: {
    /* n:"BrtBeginColorScale", */
    T: 1
  },
  470: {
    /* n:"BrtEndColorScale", */
    T: -1
  },
  471: {
    /* n:"BrtCFVO" */
  },
  472: {
    /* n:"BrtExternValueMeta" */
  },
  473: {
    /* n:"BrtBeginColorPalette", */
    T: 1
  },
  474: {
    /* n:"BrtEndColorPalette", */
    T: -1
  },
  475: {
    /* n:"BrtIndexedColor" */
  },
  476: {
    /* n:"BrtMargins", */
    f: parse_BrtMargins
  },
  477: {
    /* n:"BrtPrintOptions" */
  },
  478: {
    /* n:"BrtPageSetup" */
  },
  479: {
    /* n:"BrtBeginHeaderFooter", */
    T: 1
  },
  480: {
    /* n:"BrtEndHeaderFooter", */
    T: -1
  },
  481: {
    /* n:"BrtBeginSXCrtFormat", */
    T: 1
  },
  482: {
    /* n:"BrtEndSXCrtFormat", */
    T: -1
  },
  483: {
    /* n:"BrtBeginSXCrtFormats", */
    T: 1
  },
  484: {
    /* n:"BrtEndSXCrtFormats", */
    T: -1
  },
  485: {
    /* n:"BrtWsFmtInfo", */
    f: parse_BrtWsFmtInfo
  },
  486: {
    /* n:"BrtBeginMgs", */
    T: 1
  },
  487: {
    /* n:"BrtEndMGs", */
    T: -1
  },
  488: {
    /* n:"BrtBeginMGMaps", */
    T: 1
  },
  489: {
    /* n:"BrtEndMGMaps", */
    T: -1
  },
  490: {
    /* n:"BrtBeginMG", */
    T: 1
  },
  491: {
    /* n:"BrtEndMG", */
    T: -1
  },
  492: {
    /* n:"BrtBeginMap", */
    T: 1
  },
  493: {
    /* n:"BrtEndMap", */
    T: -1
  },
  494: {
    /* n:"BrtHLink", */
    f: parse_BrtHLink
  },
  495: {
    /* n:"BrtBeginDCon", */
    T: 1
  },
  496: {
    /* n:"BrtEndDCon", */
    T: -1
  },
  497: {
    /* n:"BrtBeginDRefs", */
    T: 1
  },
  498: {
    /* n:"BrtEndDRefs", */
    T: -1
  },
  499: {
    /* n:"BrtDRef" */
  },
  500: {
    /* n:"BrtBeginScenMan", */
    T: 1
  },
  501: {
    /* n:"BrtEndScenMan", */
    T: -1
  },
  502: {
    /* n:"BrtBeginSct", */
    T: 1
  },
  503: {
    /* n:"BrtEndSct", */
    T: -1
  },
  504: {
    /* n:"BrtSlc" */
  },
  505: {
    /* n:"BrtBeginDXFs", */
    T: 1
  },
  506: {
    /* n:"BrtEndDXFs", */
    T: -1
  },
  507: {
    /* n:"BrtDXF" */
  },
  508: {
    /* n:"BrtBeginTableStyles", */
    T: 1
  },
  509: {
    /* n:"BrtEndTableStyles", */
    T: -1
  },
  510: {
    /* n:"BrtBeginTableStyle", */
    T: 1
  },
  511: {
    /* n:"BrtEndTableStyle", */
    T: -1
  },
  512: {
    /* n:"BrtTableStyleElement" */
  },
  513: {
    /* n:"BrtTableStyleClient" */
  },
  514: {
    /* n:"BrtBeginVolDeps", */
    T: 1
  },
  515: {
    /* n:"BrtEndVolDeps", */
    T: -1
  },
  516: {
    /* n:"BrtBeginVolType", */
    T: 1
  },
  517: {
    /* n:"BrtEndVolType", */
    T: -1
  },
  518: {
    /* n:"BrtBeginVolMain", */
    T: 1
  },
  519: {
    /* n:"BrtEndVolMain", */
    T: -1
  },
  520: {
    /* n:"BrtBeginVolTopic", */
    T: 1
  },
  521: {
    /* n:"BrtEndVolTopic", */
    T: -1
  },
  522: {
    /* n:"BrtVolSubtopic" */
  },
  523: {
    /* n:"BrtVolRef" */
  },
  524: {
    /* n:"BrtVolNum" */
  },
  525: {
    /* n:"BrtVolErr" */
  },
  526: {
    /* n:"BrtVolStr" */
  },
  527: {
    /* n:"BrtVolBool" */
  },
  528: {
    /* n:"BrtBeginCalcChain$", */
    T: 1
  },
  529: {
    /* n:"BrtEndCalcChain$", */
    T: -1
  },
  530: {
    /* n:"BrtBeginSortState", */
    T: 1
  },
  531: {
    /* n:"BrtEndSortState", */
    T: -1
  },
  532: {
    /* n:"BrtBeginSortCond", */
    T: 1
  },
  533: {
    /* n:"BrtEndSortCond", */
    T: -1
  },
  534: {
    /* n:"BrtBookProtection" */
  },
  535: {
    /* n:"BrtSheetProtection" */
  },
  536: {
    /* n:"BrtRangeProtection" */
  },
  537: {
    /* n:"BrtPhoneticInfo" */
  },
  538: {
    /* n:"BrtBeginECTxtWiz", */
    T: 1
  },
  539: {
    /* n:"BrtEndECTxtWiz", */
    T: -1
  },
  540: {
    /* n:"BrtBeginECTWFldInfoLst", */
    T: 1
  },
  541: {
    /* n:"BrtEndECTWFldInfoLst", */
    T: -1
  },
  542: {
    /* n:"BrtBeginECTwFldInfo", */
    T: 1
  },
  548: {
    /* n:"BrtFileSharing" */
  },
  549: {
    /* n:"BrtOleSize" */
  },
  550: {
    /* n:"BrtDrawing", */
    f: parse_RelID
  },
  551: {
    /* n:"BrtLegacyDrawing", */
    f: parse_XLNullableWideString
  },
  552: {
    /* n:"BrtLegacyDrawingHF" */
  },
  553: {
    /* n:"BrtWebOpt" */
  },
  554: {
    /* n:"BrtBeginWebPubItems", */
    T: 1
  },
  555: {
    /* n:"BrtEndWebPubItems", */
    T: -1
  },
  556: {
    /* n:"BrtBeginWebPubItem", */
    T: 1
  },
  557: {
    /* n:"BrtEndWebPubItem", */
    T: -1
  },
  558: {
    /* n:"BrtBeginSXCondFmt", */
    T: 1
  },
  559: {
    /* n:"BrtEndSXCondFmt", */
    T: -1
  },
  560: {
    /* n:"BrtBeginSXCondFmts", */
    T: 1
  },
  561: {
    /* n:"BrtEndSXCondFmts", */
    T: -1
  },
  562: {
    /* n:"BrtBkHim" */
  },
  564: {
    /* n:"BrtColor" */
  },
  565: {
    /* n:"BrtBeginIndexedColors", */
    T: 1
  },
  566: {
    /* n:"BrtEndIndexedColors", */
    T: -1
  },
  569: {
    /* n:"BrtBeginMRUColors", */
    T: 1
  },
  570: {
    /* n:"BrtEndMRUColors", */
    T: -1
  },
  572: {
    /* n:"BrtMRUColor" */
  },
  573: {
    /* n:"BrtBeginDVals", */
    T: 1
  },
  574: {
    /* n:"BrtEndDVals", */
    T: -1
  },
  577: {
    /* n:"BrtSupNameStart" */
  },
  578: {
    /* n:"BrtSupNameValueStart" */
  },
  579: {
    /* n:"BrtSupNameValueEnd" */
  },
  580: {
    /* n:"BrtSupNameNum" */
  },
  581: {
    /* n:"BrtSupNameErr" */
  },
  582: {
    /* n:"BrtSupNameSt" */
  },
  583: {
    /* n:"BrtSupNameNil" */
  },
  584: {
    /* n:"BrtSupNameBool" */
  },
  585: {
    /* n:"BrtSupNameFmla" */
  },
  586: {
    /* n:"BrtSupNameBits" */
  },
  587: {
    /* n:"BrtSupNameEnd" */
  },
  588: {
    /* n:"BrtEndSupBook", */
    T: -1
  },
  589: {
    /* n:"BrtCellSmartTagProperty" */
  },
  590: {
    /* n:"BrtBeginCellSmartTag", */
    T: 1
  },
  591: {
    /* n:"BrtEndCellSmartTag", */
    T: -1
  },
  592: {
    /* n:"BrtBeginCellSmartTags", */
    T: 1
  },
  593: {
    /* n:"BrtEndCellSmartTags", */
    T: -1
  },
  594: {
    /* n:"BrtBeginSmartTags", */
    T: 1
  },
  595: {
    /* n:"BrtEndSmartTags", */
    T: -1
  },
  596: {
    /* n:"BrtSmartTagType" */
  },
  597: {
    /* n:"BrtBeginSmartTagTypes", */
    T: 1
  },
  598: {
    /* n:"BrtEndSmartTagTypes", */
    T: -1
  },
  599: {
    /* n:"BrtBeginSXFilters", */
    T: 1
  },
  600: {
    /* n:"BrtEndSXFilters", */
    T: -1
  },
  601: {
    /* n:"BrtBeginSXFILTER", */
    T: 1
  },
  602: {
    /* n:"BrtEndSXFilter", */
    T: -1
  },
  603: {
    /* n:"BrtBeginFills", */
    T: 1
  },
  604: {
    /* n:"BrtEndFills", */
    T: -1
  },
  605: {
    /* n:"BrtBeginCellWatches", */
    T: 1
  },
  606: {
    /* n:"BrtEndCellWatches", */
    T: -1
  },
  607: {
    /* n:"BrtCellWatch" */
  },
  608: {
    /* n:"BrtBeginCRErrs", */
    T: 1
  },
  609: {
    /* n:"BrtEndCRErrs", */
    T: -1
  },
  610: {
    /* n:"BrtCrashRecErr" */
  },
  611: {
    /* n:"BrtBeginFonts", */
    T: 1
  },
  612: {
    /* n:"BrtEndFonts", */
    T: -1
  },
  613: {
    /* n:"BrtBeginBorders", */
    T: 1
  },
  614: {
    /* n:"BrtEndBorders", */
    T: -1
  },
  615: {
    /* n:"BrtBeginFmts", */
    T: 1
  },
  616: {
    /* n:"BrtEndFmts", */
    T: -1
  },
  617: {
    /* n:"BrtBeginCellXFs", */
    T: 1
  },
  618: {
    /* n:"BrtEndCellXFs", */
    T: -1
  },
  619: {
    /* n:"BrtBeginStyles", */
    T: 1
  },
  620: {
    /* n:"BrtEndStyles", */
    T: -1
  },
  625: {
    /* n:"BrtBigName" */
  },
  626: {
    /* n:"BrtBeginCellStyleXFs", */
    T: 1
  },
  627: {
    /* n:"BrtEndCellStyleXFs", */
    T: -1
  },
  628: {
    /* n:"BrtBeginComments", */
    T: 1
  },
  629: {
    /* n:"BrtEndComments", */
    T: -1
  },
  630: {
    /* n:"BrtBeginCommentAuthors", */
    T: 1
  },
  631: {
    /* n:"BrtEndCommentAuthors", */
    T: -1
  },
  632: {
    /* n:"BrtCommentAuthor", */
    f: parse_BrtCommentAuthor
  },
  633: {
    /* n:"BrtBeginCommentList", */
    T: 1
  },
  634: {
    /* n:"BrtEndCommentList", */
    T: -1
  },
  635: {
    /* n:"BrtBeginComment", */
    T: 1,
    f: parse_BrtBeginComment
  },
  636: {
    /* n:"BrtEndComment", */
    T: -1
  },
  637: {
    /* n:"BrtCommentText", */
    f: parse_BrtCommentText
  },
  638: {
    /* n:"BrtBeginOleObjects", */
    T: 1
  },
  639: {
    /* n:"BrtOleObject" */
  },
  640: {
    /* n:"BrtEndOleObjects", */
    T: -1
  },
  641: {
    /* n:"BrtBeginSxrules", */
    T: 1
  },
  642: {
    /* n:"BrtEndSxRules", */
    T: -1
  },
  643: {
    /* n:"BrtBeginActiveXControls", */
    T: 1
  },
  644: {
    /* n:"BrtActiveX" */
  },
  645: {
    /* n:"BrtEndActiveXControls", */
    T: -1
  },
  646: {
    /* n:"BrtBeginPCDSDTCEMembersSortBy", */
    T: 1
  },
  648: {
    /* n:"BrtBeginCellIgnoreECs", */
    T: 1
  },
  649: {
    /* n:"BrtCellIgnoreEC" */
  },
  650: {
    /* n:"BrtEndCellIgnoreECs", */
    T: -1
  },
  651: {
    /* n:"BrtCsProp", */
    f: parse_BrtCsProp
  },
  652: {
    /* n:"BrtCsPageSetup" */
  },
  653: {
    /* n:"BrtBeginUserCsViews", */
    T: 1
  },
  654: {
    /* n:"BrtEndUserCsViews", */
    T: -1
  },
  655: {
    /* n:"BrtBeginUserCsView", */
    T: 1
  },
  656: {
    /* n:"BrtEndUserCsView", */
    T: -1
  },
  657: {
    /* n:"BrtBeginPcdSFCIEntries", */
    T: 1
  },
  658: {
    /* n:"BrtEndPCDSFCIEntries", */
    T: -1
  },
  659: {
    /* n:"BrtPCDSFCIEntry" */
  },
  660: {
    /* n:"BrtBeginListParts", */
    T: 1
  },
  661: {
    /* n:"BrtListPart" */
  },
  662: {
    /* n:"BrtEndListParts", */
    T: -1
  },
  663: {
    /* n:"BrtSheetCalcProp" */
  },
  664: {
    /* n:"BrtBeginFnGroup", */
    T: 1
  },
  665: {
    /* n:"BrtFnGroup" */
  },
  666: {
    /* n:"BrtEndFnGroup", */
    T: -1
  },
  667: {
    /* n:"BrtSupAddin" */
  },
  668: {
    /* n:"BrtSXTDMPOrder" */
  },
  669: {
    /* n:"BrtCsProtection" */
  },
  671: {
    /* n:"BrtBeginWsSortMap", */
    T: 1
  },
  672: {
    /* n:"BrtEndWsSortMap", */
    T: -1
  },
  673: {
    /* n:"BrtBeginRRSort", */
    T: 1
  },
  674: {
    /* n:"BrtEndRRSort", */
    T: -1
  },
  675: {
    /* n:"BrtRRSortItem" */
  },
  676: {
    /* n:"BrtFileSharingIso" */
  },
  677: {
    /* n:"BrtBookProtectionIso" */
  },
  678: {
    /* n:"BrtSheetProtectionIso" */
  },
  679: {
    /* n:"BrtCsProtectionIso" */
  },
  680: {
    /* n:"BrtRangeProtectionIso" */
  },
  681: {
    /* n:"BrtDValList" */
  },
  1024: {
    /* n:"BrtRwDescent" */
  },
  1025: {
    /* n:"BrtKnownFonts" */
  },
  1026: {
    /* n:"BrtBeginSXTupleSet", */
    T: 1
  },
  1027: {
    /* n:"BrtEndSXTupleSet", */
    T: -1
  },
  1028: {
    /* n:"BrtBeginSXTupleSetHeader", */
    T: 1
  },
  1029: {
    /* n:"BrtEndSXTupleSetHeader", */
    T: -1
  },
  1030: {
    /* n:"BrtSXTupleSetHeaderItem" */
  },
  1031: {
    /* n:"BrtBeginSXTupleSetData", */
    T: 1
  },
  1032: {
    /* n:"BrtEndSXTupleSetData", */
    T: -1
  },
  1033: {
    /* n:"BrtBeginSXTupleSetRow", */
    T: 1
  },
  1034: {
    /* n:"BrtEndSXTupleSetRow", */
    T: -1
  },
  1035: {
    /* n:"BrtSXTupleSetRowItem" */
  },
  1036: {
    /* n:"BrtNameExt" */
  },
  1037: {
    /* n:"BrtPCDH14" */
  },
  1038: {
    /* n:"BrtBeginPCDCalcMem14", */
    T: 1
  },
  1039: {
    /* n:"BrtEndPCDCalcMem14", */
    T: -1
  },
  1040: {
    /* n:"BrtSXTH14" */
  },
  1041: {
    /* n:"BrtBeginSparklineGroup", */
    T: 1
  },
  1042: {
    /* n:"BrtEndSparklineGroup", */
    T: -1
  },
  1043: {
    /* n:"BrtSparkline" */
  },
  1044: {
    /* n:"BrtSXDI14" */
  },
  1045: {
    /* n:"BrtWsFmtInfoEx14" */
  },
  1046: {
    /* n:"BrtBeginConditionalFormatting14", */
    T: 1
  },
  1047: {
    /* n:"BrtEndConditionalFormatting14", */
    T: -1
  },
  1048: {
    /* n:"BrtBeginCFRule14", */
    T: 1
  },
  1049: {
    /* n:"BrtEndCFRule14", */
    T: -1
  },
  1050: {
    /* n:"BrtCFVO14" */
  },
  1051: {
    /* n:"BrtBeginDatabar14", */
    T: 1
  },
  1052: {
    /* n:"BrtBeginIconSet14", */
    T: 1
  },
  1053: {
    /* n:"BrtDVal14", */
    f: parse_BrtDVal14
  },
  1054: {
    /* n:"BrtBeginDVals14", */
    T: 1
  },
  1055: {
    /* n:"BrtColor14" */
  },
  1056: {
    /* n:"BrtBeginSparklines", */
    T: 1
  },
  1057: {
    /* n:"BrtEndSparklines", */
    T: -1
  },
  1058: {
    /* n:"BrtBeginSparklineGroups", */
    T: 1
  },
  1059: {
    /* n:"BrtEndSparklineGroups", */
    T: -1
  },
  1061: {
    /* n:"BrtSXVD14" */
  },
  1062: {
    /* n:"BrtBeginSXView14", */
    T: 1
  },
  1063: {
    /* n:"BrtEndSXView14", */
    T: -1
  },
  1064: {
    /* n:"BrtBeginSXView16", */
    T: 1
  },
  1065: {
    /* n:"BrtEndSXView16", */
    T: -1
  },
  1066: {
    /* n:"BrtBeginPCD14", */
    T: 1
  },
  1067: {
    /* n:"BrtEndPCD14", */
    T: -1
  },
  1068: {
    /* n:"BrtBeginExtConn14", */
    T: 1
  },
  1069: {
    /* n:"BrtEndExtConn14", */
    T: -1
  },
  1070: {
    /* n:"BrtBeginSlicerCacheIDs", */
    T: 1
  },
  1071: {
    /* n:"BrtEndSlicerCacheIDs", */
    T: -1
  },
  1072: {
    /* n:"BrtBeginSlicerCacheID", */
    T: 1
  },
  1073: {
    /* n:"BrtEndSlicerCacheID", */
    T: -1
  },
  1075: {
    /* n:"BrtBeginSlicerCache", */
    T: 1
  },
  1076: {
    /* n:"BrtEndSlicerCache", */
    T: -1
  },
  1077: {
    /* n:"BrtBeginSlicerCacheDef", */
    T: 1
  },
  1078: {
    /* n:"BrtEndSlicerCacheDef", */
    T: -1
  },
  1079: {
    /* n:"BrtBeginSlicersEx", */
    T: 1
  },
  1080: {
    /* n:"BrtEndSlicersEx", */
    T: -1
  },
  1081: {
    /* n:"BrtBeginSlicerEx", */
    T: 1
  },
  1082: {
    /* n:"BrtEndSlicerEx", */
    T: -1
  },
  1083: {
    /* n:"BrtBeginSlicer", */
    T: 1
  },
  1084: {
    /* n:"BrtEndSlicer", */
    T: -1
  },
  1085: {
    /* n:"BrtSlicerCachePivotTables" */
  },
  1086: {
    /* n:"BrtBeginSlicerCacheOlapImpl", */
    T: 1
  },
  1087: {
    /* n:"BrtEndSlicerCacheOlapImpl", */
    T: -1
  },
  1088: {
    /* n:"BrtBeginSlicerCacheLevelsData", */
    T: 1
  },
  1089: {
    /* n:"BrtEndSlicerCacheLevelsData", */
    T: -1
  },
  1090: {
    /* n:"BrtBeginSlicerCacheLevelData", */
    T: 1
  },
  1091: {
    /* n:"BrtEndSlicerCacheLevelData", */
    T: -1
  },
  1092: {
    /* n:"BrtBeginSlicerCacheSiRanges", */
    T: 1
  },
  1093: {
    /* n:"BrtEndSlicerCacheSiRanges", */
    T: -1
  },
  1094: {
    /* n:"BrtBeginSlicerCacheSiRange", */
    T: 1
  },
  1095: {
    /* n:"BrtEndSlicerCacheSiRange", */
    T: -1
  },
  1096: {
    /* n:"BrtSlicerCacheOlapItem" */
  },
  1097: {
    /* n:"BrtBeginSlicerCacheSelections", */
    T: 1
  },
  1098: {
    /* n:"BrtSlicerCacheSelection" */
  },
  1099: {
    /* n:"BrtEndSlicerCacheSelections", */
    T: -1
  },
  1100: {
    /* n:"BrtBeginSlicerCacheNative", */
    T: 1
  },
  1101: {
    /* n:"BrtEndSlicerCacheNative", */
    T: -1
  },
  1102: {
    /* n:"BrtSlicerCacheNativeItem" */
  },
  1103: {
    /* n:"BrtRangeProtection14" */
  },
  1104: {
    /* n:"BrtRangeProtectionIso14" */
  },
  1105: {
    /* n:"BrtCellIgnoreEC14" */
  },
  1111: {
    /* n:"BrtList14" */
  },
  1112: {
    /* n:"BrtCFIcon" */
  },
  1113: {
    /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
    T: 1
  },
  1114: {
    /* n:"BrtEndSlicerCachesPivotCacheIDs", */
    T: -1
  },
  1115: {
    /* n:"BrtBeginSlicers", */
    T: 1
  },
  1116: {
    /* n:"BrtEndSlicers", */
    T: -1
  },
  1117: {
    /* n:"BrtWbProp14" */
  },
  1118: {
    /* n:"BrtBeginSXEdit", */
    T: 1
  },
  1119: {
    /* n:"BrtEndSXEdit", */
    T: -1
  },
  1120: {
    /* n:"BrtBeginSXEdits", */
    T: 1
  },
  1121: {
    /* n:"BrtEndSXEdits", */
    T: -1
  },
  1122: {
    /* n:"BrtBeginSXChange", */
    T: 1
  },
  1123: {
    /* n:"BrtEndSXChange", */
    T: -1
  },
  1124: {
    /* n:"BrtBeginSXChanges", */
    T: 1
  },
  1125: {
    /* n:"BrtEndSXChanges", */
    T: -1
  },
  1126: {
    /* n:"BrtSXTupleItems" */
  },
  1128: {
    /* n:"BrtBeginSlicerStyle", */
    T: 1
  },
  1129: {
    /* n:"BrtEndSlicerStyle", */
    T: -1
  },
  1130: {
    /* n:"BrtSlicerStyleElement" */
  },
  1131: {
    /* n:"BrtBeginStyleSheetExt14", */
    T: 1
  },
  1132: {
    /* n:"BrtEndStyleSheetExt14", */
    T: -1
  },
  1133: {
    /* n:"BrtBeginSlicerCachesPivotCacheID", */
    T: 1
  },
  1134: {
    /* n:"BrtEndSlicerCachesPivotCacheID", */
    T: -1
  },
  1135: {
    /* n:"BrtBeginConditionalFormattings", */
    T: 1
  },
  1136: {
    /* n:"BrtEndConditionalFormattings", */
    T: -1
  },
  1137: {
    /* n:"BrtBeginPCDCalcMemExt", */
    T: 1
  },
  1138: {
    /* n:"BrtEndPCDCalcMemExt", */
    T: -1
  },
  1139: {
    /* n:"BrtBeginPCDCalcMemsExt", */
    T: 1
  },
  1140: {
    /* n:"BrtEndPCDCalcMemsExt", */
    T: -1
  },
  1141: {
    /* n:"BrtPCDField14" */
  },
  1142: {
    /* n:"BrtBeginSlicerStyles", */
    T: 1
  },
  1143: {
    /* n:"BrtEndSlicerStyles", */
    T: -1
  },
  1144: {
    /* n:"BrtBeginSlicerStyleElements", */
    T: 1
  },
  1145: {
    /* n:"BrtEndSlicerStyleElements", */
    T: -1
  },
  1146: {
    /* n:"BrtCFRuleExt" */
  },
  1147: {
    /* n:"BrtBeginSXCondFmt14", */
    T: 1
  },
  1148: {
    /* n:"BrtEndSXCondFmt14", */
    T: -1
  },
  1149: {
    /* n:"BrtBeginSXCondFmts14", */
    T: 1
  },
  1150: {
    /* n:"BrtEndSXCondFmts14", */
    T: -1
  },
  1152: {
    /* n:"BrtBeginSortCond14", */
    T: 1
  },
  1153: {
    /* n:"BrtEndSortCond14", */
    T: -1
  },
  1154: {
    /* n:"BrtEndDVals14", */
    T: -1
  },
  1155: {
    /* n:"BrtEndIconSet14", */
    T: -1
  },
  1156: {
    /* n:"BrtEndDatabar14", */
    T: -1
  },
  1157: {
    /* n:"BrtBeginColorScale14", */
    T: 1
  },
  1158: {
    /* n:"BrtEndColorScale14", */
    T: -1
  },
  1159: {
    /* n:"BrtBeginSxrules14", */
    T: 1
  },
  1160: {
    /* n:"BrtEndSxrules14", */
    T: -1
  },
  1161: {
    /* n:"BrtBeginPRule14", */
    T: 1
  },
  1162: {
    /* n:"BrtEndPRule14", */
    T: -1
  },
  1163: {
    /* n:"BrtBeginPRFilters14", */
    T: 1
  },
  1164: {
    /* n:"BrtEndPRFilters14", */
    T: -1
  },
  1165: {
    /* n:"BrtBeginPRFilter14", */
    T: 1
  },
  1166: {
    /* n:"BrtEndPRFilter14", */
    T: -1
  },
  1167: {
    /* n:"BrtBeginPRFItem14", */
    T: 1
  },
  1168: {
    /* n:"BrtEndPRFItem14", */
    T: -1
  },
  1169: {
    /* n:"BrtBeginCellIgnoreECs14", */
    T: 1
  },
  1170: {
    /* n:"BrtEndCellIgnoreECs14", */
    T: -1
  },
  1171: {
    /* n:"BrtDxf14" */
  },
  1172: {
    /* n:"BrtBeginDxF14s", */
    T: 1
  },
  1173: {
    /* n:"BrtEndDxf14s", */
    T: -1
  },
  1177: {
    /* n:"BrtFilter14" */
  },
  1178: {
    /* n:"BrtBeginCustomFilters14", */
    T: 1
  },
  1180: {
    /* n:"BrtCustomFilter14" */
  },
  1181: {
    /* n:"BrtIconFilter14" */
  },
  1182: {
    /* n:"BrtPivotCacheConnectionName" */
  },
  2048: {
    /* n:"BrtBeginDecoupledPivotCacheIDs", */
    T: 1
  },
  2049: {
    /* n:"BrtEndDecoupledPivotCacheIDs", */
    T: -1
  },
  2050: {
    /* n:"BrtDecoupledPivotCacheID" */
  },
  2051: {
    /* n:"BrtBeginPivotTableRefs", */
    T: 1
  },
  2052: {
    /* n:"BrtEndPivotTableRefs", */
    T: -1
  },
  2053: {
    /* n:"BrtPivotTableRef" */
  },
  2054: {
    /* n:"BrtSlicerCacheBookPivotTables" */
  },
  2055: {
    /* n:"BrtBeginSxvcells", */
    T: 1
  },
  2056: {
    /* n:"BrtEndSxvcells", */
    T: -1
  },
  2057: {
    /* n:"BrtBeginSxRow", */
    T: 1
  },
  2058: {
    /* n:"BrtEndSxRow", */
    T: -1
  },
  2060: {
    /* n:"BrtPcdCalcMem15" */
  },
  2067: {
    /* n:"BrtQsi15" */
  },
  2068: {
    /* n:"BrtBeginWebExtensions", */
    T: 1
  },
  2069: {
    /* n:"BrtEndWebExtensions", */
    T: -1
  },
  2070: {
    /* n:"BrtWebExtension" */
  },
  2071: {
    /* n:"BrtAbsPath15" */
  },
  2072: {
    /* n:"BrtBeginPivotTableUISettings", */
    T: 1
  },
  2073: {
    /* n:"BrtEndPivotTableUISettings", */
    T: -1
  },
  2075: {
    /* n:"BrtTableSlicerCacheIDs" */
  },
  2076: {
    /* n:"BrtTableSlicerCacheID" */
  },
  2077: {
    /* n:"BrtBeginTableSlicerCache", */
    T: 1
  },
  2078: {
    /* n:"BrtEndTableSlicerCache", */
    T: -1
  },
  2079: {
    /* n:"BrtSxFilter15" */
  },
  2080: {
    /* n:"BrtBeginTimelineCachePivotCacheIDs", */
    T: 1
  },
  2081: {
    /* n:"BrtEndTimelineCachePivotCacheIDs", */
    T: -1
  },
  2082: {
    /* n:"BrtTimelineCachePivotCacheID" */
  },
  2083: {
    /* n:"BrtBeginTimelineCacheIDs", */
    T: 1
  },
  2084: {
    /* n:"BrtEndTimelineCacheIDs", */
    T: -1
  },
  2085: {
    /* n:"BrtBeginTimelineCacheID", */
    T: 1
  },
  2086: {
    /* n:"BrtEndTimelineCacheID", */
    T: -1
  },
  2087: {
    /* n:"BrtBeginTimelinesEx", */
    T: 1
  },
  2088: {
    /* n:"BrtEndTimelinesEx", */
    T: -1
  },
  2089: {
    /* n:"BrtBeginTimelineEx", */
    T: 1
  },
  2090: {
    /* n:"BrtEndTimelineEx", */
    T: -1
  },
  2091: {
    /* n:"BrtWorkBookPr15" */
  },
  2092: {
    /* n:"BrtPCDH15" */
  },
  2093: {
    /* n:"BrtBeginTimelineStyle", */
    T: 1
  },
  2094: {
    /* n:"BrtEndTimelineStyle", */
    T: -1
  },
  2095: {
    /* n:"BrtTimelineStyleElement" */
  },
  2096: {
    /* n:"BrtBeginTimelineStylesheetExt15", */
    T: 1
  },
  2097: {
    /* n:"BrtEndTimelineStylesheetExt15", */
    T: -1
  },
  2098: {
    /* n:"BrtBeginTimelineStyles", */
    T: 1
  },
  2099: {
    /* n:"BrtEndTimelineStyles", */
    T: -1
  },
  2100: {
    /* n:"BrtBeginTimelineStyleElements", */
    T: 1
  },
  2101: {
    /* n:"BrtEndTimelineStyleElements", */
    T: -1
  },
  2102: {
    /* n:"BrtDxf15" */
  },
  2103: {
    /* n:"BrtBeginDxfs15", */
    T: 1
  },
  2104: {
    /* n:"BrtEndDxfs15", */
    T: -1
  },
  2105: {
    /* n:"BrtSlicerCacheHideItemsWithNoData" */
  },
  2106: {
    /* n:"BrtBeginItemUniqueNames", */
    T: 1
  },
  2107: {
    /* n:"BrtEndItemUniqueNames", */
    T: -1
  },
  2108: {
    /* n:"BrtItemUniqueName" */
  },
  2109: {
    /* n:"BrtBeginExtConn15", */
    T: 1
  },
  2110: {
    /* n:"BrtEndExtConn15", */
    T: -1
  },
  2111: {
    /* n:"BrtBeginOledbPr15", */
    T: 1
  },
  2112: {
    /* n:"BrtEndOledbPr15", */
    T: -1
  },
  2113: {
    /* n:"BrtBeginDataFeedPr15", */
    T: 1
  },
  2114: {
    /* n:"BrtEndDataFeedPr15", */
    T: -1
  },
  2115: {
    /* n:"BrtTextPr15" */
  },
  2116: {
    /* n:"BrtRangePr15" */
  },
  2117: {
    /* n:"BrtDbCommand15" */
  },
  2118: {
    /* n:"BrtBeginDbTables15", */
    T: 1
  },
  2119: {
    /* n:"BrtEndDbTables15", */
    T: -1
  },
  2120: {
    /* n:"BrtDbTable15" */
  },
  2121: {
    /* n:"BrtBeginDataModel", */
    T: 1
  },
  2122: {
    /* n:"BrtEndDataModel", */
    T: -1
  },
  2123: {
    /* n:"BrtBeginModelTables", */
    T: 1
  },
  2124: {
    /* n:"BrtEndModelTables", */
    T: -1
  },
  2125: {
    /* n:"BrtModelTable" */
  },
  2126: {
    /* n:"BrtBeginModelRelationships", */
    T: 1
  },
  2127: {
    /* n:"BrtEndModelRelationships", */
    T: -1
  },
  2128: {
    /* n:"BrtModelRelationship" */
  },
  2129: {
    /* n:"BrtBeginECTxtWiz15", */
    T: 1
  },
  2130: {
    /* n:"BrtEndECTxtWiz15", */
    T: -1
  },
  2131: {
    /* n:"BrtBeginECTWFldInfoLst15", */
    T: 1
  },
  2132: {
    /* n:"BrtEndECTWFldInfoLst15", */
    T: -1
  },
  2133: {
    /* n:"BrtBeginECTWFldInfo15", */
    T: 1
  },
  2134: {
    /* n:"BrtFieldListActiveItem" */
  },
  2135: {
    /* n:"BrtPivotCacheIdVersion" */
  },
  2136: {
    /* n:"BrtSXDI15" */
  },
  2137: {
    /* n:"BrtBeginModelTimeGroupings", */
    T: 1
  },
  2138: {
    /* n:"BrtEndModelTimeGroupings", */
    T: -1
  },
  2139: {
    /* n:"BrtBeginModelTimeGrouping", */
    T: 1
  },
  2140: {
    /* n:"BrtEndModelTimeGrouping", */
    T: -1
  },
  2141: {
    /* n:"BrtModelTimeGroupingCalcCol" */
  },
  3072: {
    /* n:"BrtUid" */
  },
  3073: {
    /* n:"BrtRevisionPtr" */
  },
  4096: {
    /* n:"BrtBeginDynamicArrayPr", */
    T: 1
  },
  4097: {
    /* n:"BrtEndDynamicArrayPr", */
    T: -1
  },
  5002: {
    /* n:"BrtBeginRichValueBlock", */
    T: 1
  },
  5003: {
    /* n:"BrtEndRichValueBlock", */
    T: -1
  },
  5081: {
    /* n:"BrtBeginRichFilters", */
    T: 1
  },
  5082: {
    /* n:"BrtEndRichFilters", */
    T: -1
  },
  5083: {
    /* n:"BrtRichFilter" */
  },
  5084: {
    /* n:"BrtBeginRichFilterColumn", */
    T: 1
  },
  5085: {
    /* n:"BrtEndRichFilterColumn", */
    T: -1
  },
  5086: {
    /* n:"BrtBeginCustomRichFilters", */
    T: 1
  },
  5087: {
    /* n:"BrtEndCustomRichFilters", */
    T: -1
  },
  5088: {
    /* n:"BrtCustomRichFilter" */
  },
  5089: {
    /* n:"BrtTop10RichFilter" */
  },
  5090: {
    /* n:"BrtDynamicRichFilter" */
  },
  5092: {
    /* n:"BrtBeginRichSortCondition", */
    T: 1
  },
  5093: {
    /* n:"BrtEndRichSortCondition", */
    T: -1
  },
  5094: {
    /* n:"BrtRichFilterDateGroupItem" */
  },
  5095: {
    /* n:"BrtBeginCalcFeatures", */
    T: 1
  },
  5096: {
    /* n:"BrtEndCalcFeatures", */
    T: -1
  },
  5097: {
    /* n:"BrtCalcFeature" */
  },
  5099: {
    /* n:"BrtExternalLinksPr" */
  },
  65535: { n: "" }
}, XLSRecordEnum = {
  /* [MS-XLS] 2.3 Record Enumeration 2021-08-17 */
  6: {
    /* n:"Formula", */
    f: parse_Formula
  },
  10: {
    /* n:"EOF", */
    f: parsenoop2
  },
  12: {
    /* n:"CalcCount", */
    f: parseuint16
  },
  //
  13: {
    /* n:"CalcMode", */
    f: parseuint16
  },
  //
  14: {
    /* n:"CalcPrecision", */
    f: parsebool
  },
  //
  15: {
    /* n:"CalcRefMode", */
    f: parsebool
  },
  //
  16: {
    /* n:"CalcDelta", */
    f: parse_Xnum
  },
  //
  17: {
    /* n:"CalcIter", */
    f: parsebool
  },
  //
  18: {
    /* n:"Protect", */
    f: parsebool
  },
  19: {
    /* n:"Password", */
    f: parseuint16
  },
  20: {
    /* n:"Header", */
    f: parse_XLHeaderFooter
  },
  21: {
    /* n:"Footer", */
    f: parse_XLHeaderFooter
  },
  23: {
    /* n:"ExternSheet", */
    f: parse_ExternSheet
  },
  24: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  25: {
    /* n:"WinProtect", */
    f: parsebool
  },
  26: {
    /* n:"VerticalPageBreaks", */
  },
  27: {
    /* n:"HorizontalPageBreaks", */
  },
  28: {
    /* n:"Note", */
    f: parse_Note
  },
  29: {
    /* n:"Selection", */
  },
  34: {
    /* n:"Date1904", */
    f: parsebool
  },
  35: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  38: {
    /* n:"LeftMargin", */
    f: parse_Xnum
  },
  // *
  39: {
    /* n:"RightMargin", */
    f: parse_Xnum
  },
  // *
  40: {
    /* n:"TopMargin", */
    f: parse_Xnum
  },
  // *
  41: {
    /* n:"BottomMargin", */
    f: parse_Xnum
  },
  // *
  42: {
    /* n:"PrintRowCol", */
    f: parsebool
  },
  43: {
    /* n:"PrintGrid", */
    f: parsebool
  },
  47: {
    /* n:"FilePass", */
    f: parse_FilePass
  },
  49: {
    /* n:"Font", */
    f: parse_Font
  },
  51: {
    /* n:"PrintSize", */
    f: parseuint16
  },
  60: {
    /* n:"Continue", */
  },
  61: {
    /* n:"Window1", */
    f: parse_Window1
  },
  64: {
    /* n:"Backup", */
    f: parsebool
  },
  65: {
    /* n:"Pane", */
    f: parse_Pane
  },
  66: {
    /* n:"CodePage", */
    f: parseuint16
  },
  77: {
    /* n:"Pls", */
  },
  80: {
    /* n:"DCon", */
  },
  81: {
    /* n:"DConRef", */
  },
  82: {
    /* n:"DConName", */
  },
  85: {
    /* n:"DefColWidth", */
    f: parseuint16
  },
  89: {
    /* n:"XCT", */
  },
  90: {
    /* n:"CRN", */
  },
  91: {
    /* n:"FileSharing", */
  },
  92: {
    /* n:"WriteAccess", */
    f: parse_WriteAccess
  },
  93: {
    /* n:"Obj", */
    f: parse_Obj
  },
  94: {
    /* n:"Uncalced", */
  },
  95: {
    /* n:"CalcSaveRecalc", */
    f: parsebool
  },
  //
  96: {
    /* n:"Template", */
  },
  97: {
    /* n:"Intl", */
  },
  99: {
    /* n:"ObjProtect", */
    f: parsebool
  },
  125: {
    /* n:"ColInfo", */
    f: parse_ColInfo
  },
  128: {
    /* n:"Guts", */
    f: parse_Guts
  },
  129: {
    /* n:"WsBool", */
    f: parse_WsBool
  },
  130: {
    /* n:"GridSet", */
    f: parseuint16
  },
  131: {
    /* n:"HCenter", */
    f: parsebool
  },
  132: {
    /* n:"VCenter", */
    f: parsebool
  },
  133: {
    /* n:"BoundSheet8", */
    f: parse_BoundSheet8
  },
  134: {
    /* n:"WriteProtect", */
  },
  140: {
    /* n:"Country", */
    f: parse_Country
  },
  141: {
    /* n:"HideObj", */
    f: parseuint16
  },
  144: {
    /* n:"Sort", */
  },
  146: {
    /* n:"Palette", */
    f: parse_Palette
  },
  151: {
    /* n:"Sync", */
  },
  152: {
    /* n:"LPr", */
  },
  153: {
    /* n:"DxGCol", */
  },
  154: {
    /* n:"FnGroupName", */
  },
  155: {
    /* n:"FilterMode", */
  },
  156: {
    /* n:"BuiltInFnGroupCount", */
    f: parseuint16
  },
  157: {
    /* n:"AutoFilterInfo", */
  },
  158: {
    /* n:"AutoFilter", */
  },
  160: {
    /* n:"Scl", */
    f: parse_Scl
  },
  161: {
    /* n:"Setup", */
    f: parse_Setup
  },
  174: {
    /* n:"ScenMan", */
  },
  175: {
    /* n:"SCENARIO", */
  },
  176: {
    /* n:"SxView", */
  },
  177: {
    /* n:"Sxvd", */
  },
  178: {
    /* n:"SXVI", */
  },
  180: {
    /* n:"SxIvd", */
  },
  181: {
    /* n:"SXLI", */
  },
  182: {
    /* n:"SXPI", */
  },
  184: {
    /* n:"DocRoute", */
  },
  185: {
    /* n:"RecipName", */
  },
  189: {
    /* n:"MulRk", */
    f: parse_MulRk
  },
  190: {
    /* n:"MulBlank", */
    f: parse_MulBlank
  },
  193: {
    /* n:"Mms", */
    f: parsenoop2
  },
  197: {
    /* n:"SXDI", */
  },
  198: {
    /* n:"SXDB", */
  },
  199: {
    /* n:"SXFDB", */
  },
  200: {
    /* n:"SXDBB", */
  },
  201: {
    /* n:"SXNum", */
  },
  202: {
    /* n:"SxBool", */
    f: parsebool
  },
  203: {
    /* n:"SxErr", */
  },
  204: {
    /* n:"SXInt", */
  },
  205: {
    /* n:"SXString", */
  },
  206: {
    /* n:"SXDtr", */
  },
  207: {
    /* n:"SxNil", */
  },
  208: {
    /* n:"SXTbl", */
  },
  209: {
    /* n:"SXTBRGIITM", */
  },
  210: {
    /* n:"SxTbpg", */
  },
  211: {
    /* n:"ObProj", */
  },
  213: {
    /* n:"SXStreamID", */
  },
  215: {
    /* n:"DBCell", */
  },
  216: {
    /* n:"SXRng", */
  },
  217: {
    /* n:"SxIsxoper", */
  },
  218: {
    /* n:"BookBool", */
    f: parseuint16
  },
  220: {
    /* n:"DbOrParamQry", */
  },
  221: {
    /* n:"ScenarioProtect", */
    f: parsebool
  },
  222: {
    /* n:"OleObjectSize", */
  },
  224: {
    /* n:"XF", */
    f: parse_XF
  },
  225: {
    /* n:"InterfaceHdr", */
    f: parse_InterfaceHdr
  },
  226: {
    /* n:"InterfaceEnd", */
    f: parsenoop2
  },
  227: {
    /* n:"SXVS", */
  },
  229: {
    /* n:"MergeCells", */
    f: parse_MergeCells
  },
  233: {
    /* n:"BkHim", */
  },
  235: {
    /* n:"MsoDrawingGroup", */
  },
  236: {
    /* n:"MsoDrawing", */
  },
  237: {
    /* n:"MsoDrawingSelection", */
  },
  239: {
    /* n:"PhoneticInfo", */
  },
  240: {
    /* n:"SxRule", */
  },
  241: {
    /* n:"SXEx", */
  },
  242: {
    /* n:"SxFilt", */
  },
  244: {
    /* n:"SxDXF", */
  },
  245: {
    /* n:"SxItm", */
  },
  246: {
    /* n:"SxName", */
  },
  247: {
    /* n:"SxSelect", */
  },
  248: {
    /* n:"SXPair", */
  },
  249: {
    /* n:"SxFmla", */
  },
  251: {
    /* n:"SxFormat", */
  },
  252: {
    /* n:"SST", */
    f: parse_SST
  },
  253: {
    /* n:"LabelSst", */
    f: parse_LabelSst
  },
  255: {
    /* n:"ExtSST", */
    f: parse_ExtSST
  },
  256: {
    /* n:"SXVDEx", */
  },
  259: {
    /* n:"SXFormula", */
  },
  290: {
    /* n:"SXDBEx", */
  },
  311: {
    /* n:"RRDInsDel", */
  },
  312: {
    /* n:"RRDHead", */
  },
  315: {
    /* n:"RRDChgCell", */
  },
  317: {
    /* n:"RRTabId", */
    f: parseuint16a
  },
  318: {
    /* n:"RRDRenSheet", */
  },
  319: {
    /* n:"RRSort", */
  },
  320: {
    /* n:"RRDMove", */
  },
  330: {
    /* n:"RRFormat", */
  },
  331: {
    /* n:"RRAutoFmt", */
  },
  333: {
    /* n:"RRInsertSh", */
  },
  334: {
    /* n:"RRDMoveBegin", */
  },
  335: {
    /* n:"RRDMoveEnd", */
  },
  336: {
    /* n:"RRDInsDelBegin", */
  },
  337: {
    /* n:"RRDInsDelEnd", */
  },
  338: {
    /* n:"RRDConflict", */
  },
  339: {
    /* n:"RRDDefName", */
  },
  340: {
    /* n:"RRDRstEtxp", */
  },
  351: {
    /* n:"LRng", */
  },
  352: {
    /* n:"UsesELFs", */
    f: parsebool
  },
  353: {
    /* n:"DSF", */
    f: parsenoop2
  },
  401: {
    /* n:"CUsr", */
  },
  402: {
    /* n:"CbUsr", */
  },
  403: {
    /* n:"UsrInfo", */
  },
  404: {
    /* n:"UsrExcl", */
  },
  405: {
    /* n:"FileLock", */
  },
  406: {
    /* n:"RRDInfo", */
  },
  407: {
    /* n:"BCUsrs", */
  },
  408: {
    /* n:"UsrChk", */
  },
  425: {
    /* n:"UserBView", */
  },
  426: {
    /* n:"UserSViewBegin", */
  },
  427: {
    /* n:"UserSViewEnd", */
  },
  428: {
    /* n:"RRDUserView", */
  },
  429: {
    /* n:"Qsi", */
  },
  430: {
    /* n:"SupBook", */
    f: parse_SupBook
  },
  431: {
    /* n:"Prot4Rev", */
    f: parsebool
  },
  432: {
    /* n:"CondFmt", */
  },
  433: {
    /* n:"CF", */
  },
  434: {
    /* n:"DVal", */
  },
  437: {
    /* n:"DConBin", */
  },
  438: {
    /* n:"TxO", */
    f: parse_TxO
  },
  439: {
    /* n:"RefreshAll", */
    f: parsebool
  },
  //
  440: {
    /* n:"HLink", */
    f: parse_HLink
  },
  441: {
    /* n:"Lel", */
  },
  442: {
    /* n:"CodeName", */
    f: parse_XLUnicodeString
  },
  443: {
    /* n:"SXFDBType", */
  },
  444: {
    /* n:"Prot4RevPass", */
    f: parseuint16
  },
  445: {
    /* n:"ObNoMacros", */
  },
  446: {
    /* n:"Dv", */
  },
  448: {
    /* n:"Excel9File", */
    f: parsenoop2
  },
  449: {
    /* n:"RecalcId", */
    f: parse_RecalcId,
    r: 2
  },
  450: {
    /* n:"EntExU2", */
    f: parsenoop2
  },
  512: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  513: {
    /* n:"Blank", */
    f: parse_Blank
  },
  515: {
    /* n:"Number", */
    f: parse_Number
  },
  516: {
    /* n:"Label", */
    f: parse_Label
  },
  517: {
    /* n:"BoolErr", */
    f: parse_BoolErr
  },
  519: {
    /* n:"String", */
    f: parse_String
  },
  520: {
    /* n:"Row", */
    f: parse_Row
  },
  523: {
    /* n:"Index", */
  },
  545: {
    /* n:"Array", */
    f: parse_Array
  },
  549: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  566: {
    /* n:"Table", */
  },
  574: {
    /* n:"Window2", */
    f: parse_Window2
  },
  638: {
    /* n:"RK", */
    f: parse_RK
  },
  659: {
    /* n:"Style", */
  },
  1048: {
    /* n:"BigName", */
  },
  1054: {
    /* n:"Format", */
    f: parse_Format
  },
  1084: {
    /* n:"ContinueBigName", */
  },
  1212: {
    /* n:"ShrFmla", */
    f: parse_ShrFmla
  },
  2048: {
    /* n:"HLinkTooltip", */
    f: parse_HLinkTooltip
  },
  2049: {
    /* n:"WebPub", */
  },
  2050: {
    /* n:"QsiSXTag", */
  },
  2051: {
    /* n:"DBQueryExt", */
  },
  2052: {
    /* n:"ExtString", */
  },
  2053: {
    /* n:"TxtQry", */
  },
  2054: {
    /* n:"Qsir", */
  },
  2055: {
    /* n:"Qsif", */
  },
  2056: {
    /* n:"RRDTQSIF", */
  },
  2057: {
    /* n:"BOF", */
    f: parse_BOF
  },
  2058: {
    /* n:"OleDbConn", */
  },
  2059: {
    /* n:"WOpt", */
  },
  2060: {
    /* n:"SXViewEx", */
  },
  2061: {
    /* n:"SXTH", */
  },
  2062: {
    /* n:"SXPIEx", */
  },
  2063: {
    /* n:"SXVDTEx", */
  },
  2064: {
    /* n:"SXViewEx9", */
  },
  2066: {
    /* n:"ContinueFrt", */
  },
  2067: {
    /* n:"RealTimeData", */
  },
  2128: {
    /* n:"ChartFrtInfo", */
  },
  2129: {
    /* n:"FrtWrapper", */
  },
  2130: {
    /* n:"StartBlock", */
  },
  2131: {
    /* n:"EndBlock", */
  },
  2132: {
    /* n:"StartObject", */
  },
  2133: {
    /* n:"EndObject", */
  },
  2134: {
    /* n:"CatLab", */
  },
  2135: {
    /* n:"YMult", */
  },
  2136: {
    /* n:"SXViewLink", */
  },
  2137: {
    /* n:"PivotChartBits", */
  },
  2138: {
    /* n:"FrtFontList", */
  },
  2146: {
    /* n:"SheetExt", */
  },
  2147: {
    /* n:"BookExt", */
    r: 12
  },
  2148: {
    /* n:"SXAddl", */
  },
  2149: {
    /* n:"CrErr", */
  },
  2150: {
    /* n:"HFPicture", */
  },
  2151: {
    /* n:"FeatHdr", */
    f: parsenoop2
  },
  2152: {
    /* n:"Feat", */
  },
  2154: {
    /* n:"DataLabExt", */
  },
  2155: {
    /* n:"DataLabExtContents", */
  },
  2156: {
    /* n:"CellWatch", */
  },
  2161: {
    /* n:"FeatHdr11", */
  },
  2162: {
    /* n:"Feature11", */
  },
  2164: {
    /* n:"DropDownObjIds", */
  },
  2165: {
    /* n:"ContinueFrt11", */
  },
  2166: {
    /* n:"DConn", */
  },
  2167: {
    /* n:"List12", */
  },
  2168: {
    /* n:"Feature12", */
  },
  2169: {
    /* n:"CondFmt12", */
  },
  2170: {
    /* n:"CF12", */
  },
  2171: {
    /* n:"CFEx", */
  },
  2172: {
    /* n:"XFCRC", */
    f: parse_XFCRC,
    r: 12
  },
  2173: {
    /* n:"XFExt", */
    f: parse_XFExt,
    r: 12
  },
  2174: {
    /* n:"AutoFilter12", */
  },
  2175: {
    /* n:"ContinueFrt12", */
  },
  2180: {
    /* n:"MDTInfo", */
  },
  2181: {
    /* n:"MDXStr", */
  },
  2182: {
    /* n:"MDXTuple", */
  },
  2183: {
    /* n:"MDXSet", */
  },
  2184: {
    /* n:"MDXProp", */
  },
  2185: {
    /* n:"MDXKPI", */
  },
  2186: {
    /* n:"MDB", */
  },
  2187: {
    /* n:"PLV", */
  },
  2188: {
    /* n:"Compat12", */
    f: parsebool,
    r: 12
  },
  2189: {
    /* n:"DXF", */
  },
  2190: {
    /* n:"TableStyles", */
    r: 12
  },
  2191: {
    /* n:"TableStyle", */
  },
  2192: {
    /* n:"TableStyleElement", */
  },
  2194: {
    /* n:"StyleExt", */
  },
  2195: {
    /* n:"NamePublish", */
  },
  2196: {
    /* n:"NameCmt", */
    f: parse_NameCmt,
    r: 12
  },
  2197: {
    /* n:"SortData", */
  },
  2198: {
    /* n:"Theme", */
    f: parse_Theme,
    r: 12
  },
  2199: {
    /* n:"GUIDTypeLib", */
  },
  2200: {
    /* n:"FnGrp12", */
  },
  2201: {
    /* n:"NameFnGrp12", */
  },
  2202: {
    /* n:"MTRSettings", */
    f: parse_MTRSettings,
    r: 12
  },
  2203: {
    /* n:"CompressPictures", */
    f: parsenoop2
  },
  2204: {
    /* n:"HeaderFooter", */
  },
  2205: {
    /* n:"CrtLayout12", */
  },
  2206: {
    /* n:"CrtMlFrt", */
  },
  2207: {
    /* n:"CrtMlFrtContinue", */
  },
  2211: {
    /* n:"ForceFullCalculation", */
    f: parse_ForceFullCalculation
  },
  2212: {
    /* n:"ShapePropsStream", */
  },
  2213: {
    /* n:"TextPropsStream", */
  },
  2214: {
    /* n:"RichTextStream", */
  },
  2215: {
    /* n:"CrtLayout12A", */
  },
  4097: {
    /* n:"Units", */
  },
  4098: {
    /* n:"Chart", */
  },
  4099: {
    /* n:"Series", */
  },
  4102: {
    /* n:"DataFormat", */
  },
  4103: {
    /* n:"LineFormat", */
  },
  4105: {
    /* n:"MarkerFormat", */
  },
  4106: {
    /* n:"AreaFormat", */
  },
  4107: {
    /* n:"PieFormat", */
  },
  4108: {
    /* n:"AttachedLabel", */
  },
  4109: {
    /* n:"SeriesText", */
  },
  4116: {
    /* n:"ChartFormat", */
  },
  4117: {
    /* n:"Legend", */
  },
  4118: {
    /* n:"SeriesList", */
  },
  4119: {
    /* n:"Bar", */
  },
  4120: {
    /* n:"Line", */
  },
  4121: {
    /* n:"Pie", */
  },
  4122: {
    /* n:"Area", */
  },
  4123: {
    /* n:"Scatter", */
  },
  4124: {
    /* n:"CrtLine", */
  },
  4125: {
    /* n:"Axis", */
  },
  4126: {
    /* n:"Tick", */
  },
  4127: {
    /* n:"ValueRange", */
  },
  4128: {
    /* n:"CatSerRange", */
  },
  4129: {
    /* n:"AxisLine", */
  },
  4130: {
    /* n:"CrtLink", */
  },
  4132: {
    /* n:"DefaultText", */
  },
  4133: {
    /* n:"Text", */
  },
  4134: {
    /* n:"FontX", */
    f: parseuint16
  },
  4135: {
    /* n:"ObjectLink", */
  },
  4146: {
    /* n:"Frame", */
  },
  4147: {
    /* n:"Begin", */
  },
  4148: {
    /* n:"End", */
  },
  4149: {
    /* n:"PlotArea", */
  },
  4154: {
    /* n:"Chart3d", */
  },
  4156: {
    /* n:"PicF", */
  },
  4157: {
    /* n:"DropBar", */
  },
  4158: {
    /* n:"Radar", */
  },
  4159: {
    /* n:"Surf", */
  },
  4160: {
    /* n:"RadarArea", */
  },
  4161: {
    /* n:"AxisParent", */
  },
  4163: {
    /* n:"LegendException", */
  },
  4164: {
    /* n:"ShtProps", */
    f: parse_ShtProps
  },
  4165: {
    /* n:"SerToCrt", */
  },
  4166: {
    /* n:"AxesUsed", */
  },
  4168: {
    /* n:"SBaseRef", */
  },
  4170: {
    /* n:"SerParent", */
  },
  4171: {
    /* n:"SerAuxTrend", */
  },
  4174: {
    /* n:"IFmtRecord", */
  },
  4175: {
    /* n:"Pos", */
  },
  4176: {
    /* n:"AlRuns", */
  },
  4177: {
    /* n:"BRAI", */
  },
  4187: {
    /* n:"SerAuxErrBar", */
  },
  4188: {
    /* n:"ClrtClient", */
    f: parse_ClrtClient
  },
  4189: {
    /* n:"SerFmt", */
  },
  4191: {
    /* n:"Chart3DBarShape", */
  },
  4192: {
    /* n:"Fbi", */
  },
  4193: {
    /* n:"BopPop", */
  },
  4194: {
    /* n:"AxcExt", */
  },
  4195: {
    /* n:"Dat", */
  },
  4196: {
    /* n:"PlotGrowth", */
  },
  4197: {
    /* n:"SIIndex", */
  },
  4198: {
    /* n:"GelFrame", */
  },
  4199: {
    /* n:"BopPopCustom", */
  },
  4200: {
    /* n:"Fbi2", */
  },
  0: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  1: {
    /* n:"BIFF2BLANK", */
  },
  2: {
    /* n:"BIFF2INT", */
    f: parse_BIFF2INT
  },
  3: {
    /* n:"BIFF2NUM", */
    f: parse_BIFF2NUM
  },
  4: {
    /* n:"BIFF2STR", */
    f: parse_BIFF2STR
  },
  5: {
    /* n:"BIFF2BOOLERR", */
    f: parse_BIFF2BOOLERR
  },
  7: {
    /* n:"String", */
    f: parse_BIFF2STRING
  },
  8: {
    /* n:"BIFF2ROW", */
  },
  9: {
    /* n:"BOF", */
    f: parse_BOF
  },
  11: {
    /* n:"Index", */
  },
  22: {
    /* n:"ExternCount", */
    f: parseuint16
  },
  30: {
    /* n:"BIFF2FORMAT", */
    f: parse_BIFF2Format
  },
  31: {
    /* n:"BIFF2FMTCNT", */
  },
  /* 16-bit cnt of BIFF2FORMAT records */
  32: {
    /* n:"BIFF2COLINFO", */
  },
  33: {
    /* n:"Array", */
    f: parse_Array
  },
  36: {
    /* n:"COLWIDTH", */
  },
  37: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  // 0x002c ??
  // 0x002d ??
  // 0x002e ??
  // 0x0030 FONTCOUNT: number of fonts
  50: {
    /* n:"BIFF2FONTXTRA", */
    f: parse_BIFF2FONTXTRA
  },
  // 0x0035: INFOOPTS
  // 0x0036: TABLE (BIFF2 only)
  // 0x0037: TABLE2 (BIFF2 only)
  // 0x0038: WNDESK
  // 0x0039 ??
  // 0x003a: BEGINPREF
  // 0x003b: ENDPREF
  62: {
    /* n:"BIFF2WINDOW2", */
  },
  // 0x003f ??
  // 0x0046: SHOWSCROLL
  // 0x0047: SHOWFORMULA
  // 0x0048: STATUSBAR
  // 0x0049: SHORTMENUS
  // 0x004A:
  // 0x004B:
  // 0x004C:
  // 0x004E:
  // 0x004F:
  // 0x0058: TOOLBAR (BIFF3)
  /* - - - */
  52: {
    /* n:"DDEObjName", */
  },
  67: {
    /* n:"BIFF2XF", */
    f: parse_BIFF2XF
  },
  68: {
    /* n:"BIFF2XFINDEX", */
    f: parseuint16
  },
  69: {
    /* n:"BIFF2FONTCLR", */
  },
  86: {
    /* n:"BIFF4FMTCNT", */
  },
  /* 16-bit cnt, similar to BIFF2 */
  126: {
    /* n:"RK", */
  },
  /* Not necessarily same as 0x027e */
  127: {
    /* n:"ImData", */
    f: parse_ImData
  },
  135: {
    /* n:"Addin", */
  },
  136: {
    /* n:"Edg", */
  },
  137: {
    /* n:"Pub", */
  },
  // 0x8A
  // 0x8B LH: alternate menu key flag (BIFF3/4)
  // 0x8E
  143: {
    /* n:"BIFF4SheetInfo", */
    f: parse_BIFF4SheetInfo
  },
  145: {
    /* n:"Sub", */
  },
  // 0x93 STYLE
  148: {
    /* n:"LHRecord", */
  },
  149: {
    /* n:"LHNGraph", */
  },
  150: {
    /* n:"Sound", */
  },
  // 0xA2 FNPROTO: function prototypes (BIFF4)
  // 0xA3
  // 0xA8
  169: {
    /* n:"CoordList", */
  },
  171: {
    /* n:"GCW", */
  },
  188: {
    /* n:"ShrFmla", */
  },
  /* Not necessarily same as 0x04bc */
  191: {
    /* n:"ToolbarHdr", */
  },
  192: {
    /* n:"ToolbarEnd", */
  },
  194: {
    /* n:"AddMenu", */
  },
  195: {
    /* n:"DelMenu", */
  },
  214: {
    /* n:"RString", */
    f: parse_RString
  },
  223: {
    /* n:"UDDesc", */
  },
  234: {
    /* n:"TabIdConf", */
  },
  354: {
    /* n:"XL5Modify", */
  },
  421: {
    /* n:"FileSharing2", */
  },
  518: {
    /* n:"Formula", */
    f: parse_Formula
  },
  521: {
    /* n:"BOF", */
    f: parse_BOF
  },
  536: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  547: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  561: {
    /* n:"Font", */
  },
  579: {
    /* n:"BIFF3XF", */
    f: parse_BIFF3XF
  },
  1030: {
    /* n:"Formula", */
    f: parse_Formula
  },
  1033: {
    /* n:"BOF", */
    f: parse_BOF
  },
  1091: {
    /* n:"BIFF4XF", */
    f: parse_BIFF4XF
  },
  2157: {
    /* n:"FeatInfo", */
  },
  2163: {
    /* n:"FeatInfo11", */
  },
  2177: {
    /* n:"SXAddl12", */
  },
  2240: {
    /* n:"AutoWebPub", */
  },
  2241: {
    /* n:"ListObj", */
  },
  2242: {
    /* n:"ListField", */
  },
  2243: {
    /* n:"ListDV", */
  },
  2244: {
    /* n:"ListCondFmt", */
  },
  2245: {
    /* n:"ListCF", */
  },
  2246: {
    /* n:"FMQry", */
  },
  2247: {
    /* n:"FMSQry", */
  },
  2248: {
    /* n:"PLV", */
  },
  2249: {
    /* n:"LnExt", */
  },
  2250: {
    /* n:"MkrExt", */
  },
  2251: {
    /* n:"CrtCoopt", */
  },
  2262: {
    /* n:"FRTArchId$", */
    r: 12
  },
  /* --- multiplan 4 records --- */
  101: {
    /* n:"", */
  },
  // one per window
  102: {
    /* n:"", */
  },
  // calc settings
  105: {
    /* n:"", */
  },
  // print header
  106: {
    /* n:"", */
  },
  // print footer
  107: {
    /* n:"", */
  },
  // print settings
  109: {
    /* n:"", */
  },
  // one per window
  112: {
    /* n:"", */
  },
  // includes default col width
  114: {
    /* n:"", */
  },
  // includes selected cell
  29282: {}
};
function write_biff_rec(F, x, w, O) {
  var D = x;
  if (!isNaN(D)) {
    var U = O || (w || []).length || 0, W = F.next(4);
    W.write_shift(2, D), W.write_shift(2, U), /*:: len != null &&*/
    U > 0 && is_buf(w) && F.push(w);
  }
}
function write_biff_continue(F, x, w, O) {
  var D = (w || []).length || 0;
  if (D <= 8224) return write_biff_rec(F, x, w, D);
  var U = x;
  if (!isNaN(U)) {
    for (var W = w.parts || [], X = 0, G = 0, Y = 0; Y + (W[X] || 8224) <= 8224; )
      Y += W[X] || 8224, X++;
    var K = F.next(4);
    for (K.write_shift(2, U), K.write_shift(2, Y), F.push(w.slice(G, G + Y)), G += Y; G < D; ) {
      for (K = F.next(4), K.write_shift(2, 60), Y = 0; Y + (W[X] || 8224) <= 8224; )
        Y += W[X] || 8224, X++;
      K.write_shift(2, Y), F.push(w.slice(G, G + Y)), G += Y;
    }
  }
}
function write_BIFF2BERR(F, x, w, O) {
  var D = new_buf(9);
  return write_BIFF2Cell(D, F, x), write_Bes(w, O || "b", D), D;
}
function write_BIFF2LABEL(F, x, w) {
  var O = new_buf(8 + 2 * w.length);
  return write_BIFF2Cell(O, F, x), O.write_shift(1, w.length), O.write_shift(w.length, w, "sbcs"), O.l < O.length ? O.slice(0, O.l) : O;
}
function write_comments_biff2(F, x) {
  x.forEach(function(w) {
    var O = w[0].map(function(U) {
      return U.t;
    }).join("");
    if (O.length <= 2048) return write_biff_rec(F, 28, write_NOTE_BIFF2(O, w[1], w[2]));
    write_biff_rec(F, 28, write_NOTE_BIFF2(O.slice(0, 2048), w[1], w[2], O.length));
    for (var D = 2048; D < O.length; D += 2048)
      write_biff_rec(F, 28, write_NOTE_BIFF2(O.slice(D, Math.min(D + 2048, O.length)), -1, -1, Math.min(2048, O.length - D)));
  });
}
function write_ws_biff2_cell(F, x, w, O, D, U) {
  var W = 0;
  x.z != null && (W = D._BIFF2FmtTable.indexOf(x.z), W == -1 && (D._BIFF2FmtTable.push(x.z), W = D._BIFF2FmtTable.length - 1));
  var X = 0;
  if (x.z != null) {
    for (; X < D.cellXfs.length && D.cellXfs[X].numFmtId != W; ++X) ;
    X == D.cellXfs.length && D.cellXfs.push({ numFmtId: W });
  }
  if (x.v != null) switch (x.t) {
    case "d":
    case "n":
      var G = x.t == "d" ? datenum(parseDate(x.v, U), U) : x.v;
      D.biff == 2 && G == (G | 0) && G >= 0 && G < 65536 ? write_biff_rec(F, 2, write_BIFF2INT(w, O, G, X, W)) : isNaN(G) ? write_biff_rec(F, 5, write_BIFF2BERR(w, O, 36, "e")) : isFinite(G) ? write_biff_rec(F, 3, write_BIFF2NUM(w, O, G, X, W)) : write_biff_rec(F, 5, write_BIFF2BERR(w, O, 7, "e"));
      return;
    case "b":
    case "e":
      write_biff_rec(F, 5, write_BIFF2BERR(w, O, x.v, x.t));
      return;
    /* TODO: codepage, sst */
    case "s":
    case "str":
      write_biff_rec(F, 4, write_BIFF2LABEL(w, O, x.v == null ? "" : String(x.v).slice(0, 255)));
      return;
  }
  write_biff_rec(F, 1, write_BIFF2Cell(null, w, O));
}
function write_ws_biff2(F, x, w, O, D) {
  var U = x["!data"] != null, W = safe_decode_range(x["!ref"] || "A1"), X = "", G = [];
  if (W.e.c > 255 || W.e.r > 16383) {
    if (O.WTF) throw new Error("Range " + (x["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    W.e.c = Math.min(W.e.c, 255), W.e.r = Math.min(W.e.r, 16383);
  }
  for (var Y = (((D || {}).Workbook || {}).WBProps || {}).date1904, K = [], Z = [], q = W.s.c; q <= W.e.c; ++q) G[q] = encode_col(q);
  for (var J = W.s.r; J <= W.e.r; ++J)
    for (U && (K = x["!data"][J] || []), X = encode_row(J), q = W.s.c; q <= W.e.c; ++q) {
      var ee = U ? K[q] : x[G[q] + X];
      ee && (write_ws_biff2_cell(F, ee, J, q, O, Y), ee.c && Z.push([ee.c, J, q]));
    }
  write_comments_biff2(F, Z);
}
function write_biff2_buf(F, x) {
  for (var w = x || {}, O = buf_array(), D = 0, U = 0; U < F.SheetNames.length; ++U) F.SheetNames[U] == w.sheet && (D = U);
  if (D == 0 && w.sheet && F.SheetNames[0] != w.sheet) throw new Error("Sheet not found: " + w.sheet);
  write_biff_rec(O, w.biff == 4 ? 1033 : w.biff == 3 ? 521 : 9, write_BOF(F, 16, w)), ((F.Workbook || {}).WBProps || {}).date1904 && write_biff_rec(O, 34, writebool(!0)), w.cellXfs = [{ numFmtId: 0 }], w._BIFF2FmtTable = ["General"], w._Fonts = [];
  var W = buf_array();
  return write_ws_biff2(W, F.Sheets[F.SheetNames[D]], D, w, F), w._BIFF2FmtTable.forEach(function(X) {
    w.biff <= 3 ? write_biff_rec(O, 30, write_BIFF2Format(X)) : write_biff_rec(O, 1054, write_BIFF4Format(X));
  }), w.cellXfs.forEach(function(X) {
    switch (w.biff) {
      case 2:
        write_biff_rec(O, 67, write_BIFF2XF(X));
        break;
      case 3:
        write_biff_rec(O, 579, write_BIFF3XF(X));
        break;
      case 4:
        write_biff_rec(O, 1091, write_BIFF4XF(X));
        break;
    }
  }), delete w._BIFF2FmtTable, delete w.cellXfs, delete w._Fonts, O.push(W.end()), write_biff_rec(O, 10), O.end();
}
var b8oid = 1, b8ocnts = [];
function write_MsoDrawingGroup() {
  var F = new_buf(82 + 8 * b8ocnts.length);
  F.write_shift(2, 15), F.write_shift(2, 61440), F.write_shift(4, 74 + 8 * b8ocnts.length);
  {
    F.write_shift(2, 0), F.write_shift(2, 61446), F.write_shift(4, 16 + 8 * b8ocnts.length);
    {
      F.write_shift(4, b8oid), F.write_shift(4, b8ocnts.length + 1);
      for (var x = 0, w = 0; w < b8ocnts.length; ++w) x += b8ocnts[w] && b8ocnts[w][1] || 0;
      F.write_shift(4, x), F.write_shift(4, b8ocnts.length);
    }
    b8ocnts.forEach(function(O) {
      F.write_shift(4, O[0]), F.write_shift(4, O[2]);
    });
  }
  return F.write_shift(2, 51), F.write_shift(2, 61451), F.write_shift(4, 18), F.write_shift(2, 191), F.write_shift(4, 524296), F.write_shift(2, 385), F.write_shift(4, 134217793), F.write_shift(2, 448), F.write_shift(4, 134217792), F.write_shift(2, 64), F.write_shift(2, 61726), F.write_shift(4, 16), F.write_shift(4, 134217741), F.write_shift(4, 134217740), F.write_shift(4, 134217751), F.write_shift(4, 268435703), F;
}
function write_comments_biff8(F, x) {
  var w = [], O = 0, D = buf_array(), U = b8oid, W;
  x.forEach(function(G, Y) {
    var K = "", Z = G[0].map(function(ne) {
      return ne.a && !K && (K = ne.a), ne.t;
    }).join("");
    ++b8oid;
    {
      var q = new_buf(150);
      q.write_shift(2, 15), q.write_shift(2, 61444), q.write_shift(4, 150), q.write_shift(2, 3234), q.write_shift(2, 61450), q.write_shift(4, 8), q.write_shift(4, b8oid), q.write_shift(4, 2560), q.write_shift(2, 227), q.write_shift(2, 61451), q.write_shift(4, 84), q.write_shift(2, 128), q.write_shift(4, 0), q.write_shift(2, 139), q.write_shift(4, 2), q.write_shift(2, 191), q.write_shift(4, 524296), q.write_shift(2, 344), q.l += 4, q.write_shift(2, 385), q.write_shift(4, 134217808), q.write_shift(2, 387), q.write_shift(4, 134217808), q.write_shift(2, 389), q.write_shift(4, 268435700), q.write_shift(2, 447), q.write_shift(4, 1048592), q.write_shift(2, 448), q.write_shift(4, 134217809), q.write_shift(2, 451), q.write_shift(4, 268435700), q.write_shift(2, 513), q.write_shift(4, 134217809), q.write_shift(2, 515), q.write_shift(4, 268435700), q.write_shift(2, 575), q.write_shift(4, 196609), q.write_shift(2, 959), q.write_shift(4, 131072 | (G[0].hidden ? 2 : 0)), q.l += 2, q.write_shift(2, 61456), q.write_shift(4, 18), q.write_shift(2, 3), q.write_shift(2, G[2] + 2), q.l += 2, q.write_shift(2, G[1] + 1), q.l += 2, q.write_shift(2, G[2] + 4), q.l += 2, q.write_shift(2, G[1] + 5), q.l += 2, q.l += 2, q.write_shift(2, 61457), q.l += 4, q.l = 150, Y == 0 ? W = q : write_biff_rec(D, 236, q);
    }
    O += 150;
    {
      var J = new_buf(52);
      J.write_shift(2, 21), J.write_shift(2, 18), J.write_shift(2, 25), J.write_shift(2, b8oid), J.write_shift(2, 0), J.l = 22, J.write_shift(2, 13), J.write_shift(2, 22), J.write_shift(4, 1651663474), J.write_shift(4, 2503426821), J.write_shift(4, 2150634280), J.write_shift(4, 1768515844 + b8oid * 256), J.write_shift(2, 0), J.write_shift(4, 0), J.l += 4, write_biff_rec(D, 93, J);
    }
    {
      var ee = new_buf(8);
      ee.l += 2, ee.write_shift(2, 61453), ee.l += 4, write_biff_rec(D, 236, ee);
    }
    O += 8;
    {
      var re = new_buf(18);
      re.write_shift(2, 18), re.l += 8, re.write_shift(2, Z.length), re.write_shift(2, 16), re.l += 4, write_biff_rec(D, 438, re);
      {
        var te = new_buf(1 + Z.length);
        te.write_shift(1, 0), te.write_shift(Z.length, Z, "sbcs"), write_biff_rec(D, 60, te);
      }
      {
        var Q = new_buf(16);
        Q.l += 8, Q.write_shift(2, Z.length), Q.l += 6, write_biff_rec(D, 60, Q);
      }
    }
    {
      var oe = new_buf(12 + K.length);
      oe.write_shift(2, G[1]), oe.write_shift(2, G[2]), oe.write_shift(2, 0 | (G[0].hidden ? 0 : 2)), oe.write_shift(2, b8oid), oe.write_shift(2, K.length), oe.write_shift(1, 0), oe.write_shift(K.length, K, "sbcs"), oe.l++, w.push(oe);
    }
  });
  {
    var X = new_buf(80);
    X.write_shift(2, 15), X.write_shift(2, 61442), X.write_shift(4, O + X.length - 8), X.write_shift(2, 16), X.write_shift(2, 61448), X.write_shift(4, 8), X.write_shift(4, x.length + 1), X.write_shift(4, b8oid), X.write_shift(2, 15), X.write_shift(2, 61443), X.write_shift(4, O + 48), X.write_shift(2, 15), X.write_shift(2, 61444), X.write_shift(4, 40), X.write_shift(2, 1), X.write_shift(2, 61449), X.write_shift(4, 16), X.l += 16, X.write_shift(2, 2), X.write_shift(2, 61450), X.write_shift(4, 8), X.write_shift(4, U), X.write_shift(4, 5), write_biff_rec(
      F,
      236,
      /* hdr */
      W ? bconcat([X, W]) : X
    );
  }
  F.push(D.end()), w.forEach(function(G) {
    write_biff_rec(F, 28, G);
  }), b8ocnts.push([U, x.length + 1, b8oid]), ++b8oid;
}
function write_FONTS_biff8(F, x, w) {
  write_biff_rec(F, 49, write_Font({
    sz: 12,
    color: { theme: 1 },
    name: "Arial",
    family: 2,
    scheme: "minor"
  }, w));
}
function write_FMTS_biff8(F, x, w) {
  x && [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(O) {
    for (var D = O[0]; D <= O[1]; ++D) x[D] != null && write_biff_rec(F, 1054, write_Format(D, x[D], w));
  });
}
function write_FEAT(F, x) {
  var w = new_buf(19);
  w.write_shift(4, 2151), w.write_shift(4, 0), w.write_shift(4, 0), w.write_shift(2, 3), w.write_shift(1, 1), w.write_shift(4, 0), write_biff_rec(F, 2151, w), w = new_buf(39), w.write_shift(4, 2152), w.write_shift(4, 0), w.write_shift(4, 0), w.write_shift(2, 3), w.write_shift(1, 0), w.write_shift(4, 0), w.write_shift(2, 1), w.write_shift(4, 4), w.write_shift(2, 0), write_Ref8U(safe_decode_range(x["!ref"] || "A1"), w), w.write_shift(4, 4), write_biff_rec(F, 2152, w);
}
function write_CELLXFS_biff8(F, x) {
  for (var w = 0; w < 16; ++w) write_biff_rec(F, 224, write_XF({ numFmtId: 0, style: !0 }, 0, x));
  x.cellXfs.forEach(function(O) {
    write_biff_rec(F, 224, write_XF(O, 0, x));
  });
}
function write_ws_biff8_hlinks(F, x) {
  for (var w = 0; w < x["!links"].length; ++w) {
    var O = x["!links"][w];
    write_biff_rec(F, 440, write_HLink(O)), O[1].Tooltip && write_biff_rec(F, 2048, write_HLinkTooltip(O));
  }
  delete x["!links"];
}
function write_ws_cols_biff8(F, x) {
  if (x) {
    var w = 0;
    x.forEach(function(O, D) {
      ++w <= 256 && O && write_biff_rec(F, 125, write_ColInfo(col_obj_w(D, O), D));
    });
  }
}
function write_ws_biff8_cell(F, x, w, O, D, U) {
  var W = 16 + get_cell_style(D.cellXfs, x, D);
  if (x.v == null && !x.bf) {
    write_biff_rec(F, 513, write_XLSCell(w, O, W));
    return;
  }
  if (x.bf) write_biff_rec(F, 6, write_Formula(x, w, O, D, W));
  else switch (x.t) {
    case "d":
    case "n":
      var X = x.t == "d" ? datenum(parseDate(x.v, U), U) : x.v;
      isNaN(X) ? write_biff_rec(F, 517, write_BoolErr(w, O, 36, W, D, "e")) : isFinite(X) ? write_biff_rec(F, 515, write_Number(w, O, X, W)) : write_biff_rec(F, 517, write_BoolErr(w, O, 7, W, D, "e"));
      break;
    case "b":
    case "e":
      write_biff_rec(F, 517, write_BoolErr(w, O, x.v, W, D, x.t));
      break;
    /* TODO: codepage, sst */
    case "s":
    case "str":
      if (D.bookSST) {
        var G = get_sst_id(D.Strings, x.v == null ? "" : String(x.v), D.revStrings);
        write_biff_rec(F, 253, write_LabelSst(w, O, G, W));
      } else write_biff_rec(F, 516, write_Label(w, O, (x.v == null ? "" : String(x.v)).slice(0, 255), W, D));
      break;
    default:
      write_biff_rec(F, 513, write_XLSCell(w, O, W));
  }
}
function write_ws_biff8(F, x, w) {
  var O = buf_array(), D = w.SheetNames[F], U = w.Sheets[D] || {}, W = (w || {}).Workbook || {}, X = (W.Sheets || [])[F] || {}, G = U["!data"] != null, Y = x.biff == 8, K = "", Z = [], q = safe_decode_range(U["!ref"] || "A1"), J = Y ? 65536 : 16384;
  if (q.e.c > 255 || q.e.r >= J) {
    if (x.WTF) throw new Error("Range " + (U["!ref"] || "A1") + " exceeds format limit A1:IV" + J);
    q.e.c = Math.min(q.e.c, 255), q.e.r = Math.min(q.e.r, J - 1);
  }
  write_biff_rec(O, 2057, write_BOF(w, 16, x)), write_biff_rec(O, 13, writeuint16(1)), write_biff_rec(O, 12, writeuint16(100)), write_biff_rec(O, 15, writebool(!0)), write_biff_rec(O, 17, writebool(!1)), write_biff_rec(O, 16, write_Xnum(1e-3)), write_biff_rec(O, 95, writebool(!0)), write_biff_rec(O, 42, writebool(!1)), write_biff_rec(O, 43, writebool(!1)), write_biff_rec(O, 130, writeuint16(1)), write_biff_rec(O, 128, write_Guts()), write_biff_rec(O, 131, writebool(!1)), write_biff_rec(O, 132, writebool(!1)), Y && write_ws_cols_biff8(O, U["!cols"]), write_biff_rec(O, 512, write_Dimensions(q, x));
  var ee = (((w || {}).Workbook || {}).WBProps || {}).date1904;
  Y && (U["!links"] = []);
  for (var re = q.s.c; re <= q.e.c; ++re) Z[re] = encode_col(re);
  for (var te = [], Q = [], oe = q.s.r; oe <= q.e.r; ++oe)
    for (G && (Q = U["!data"][oe] || []), K = encode_row(oe), re = q.s.c; re <= q.e.c; ++re) {
      var ne = G ? Q[re] : U[Z[re] + K];
      ne && (write_ws_biff8_cell(O, ne, oe, re, x, ee), Y && ne.l && U["!links"].push([Z[re] + K, ne.l]), ne.c && te.push([ne.c, oe, re]));
    }
  var le = X.CodeName || X.name || D;
  return Y ? write_comments_biff8(O, te) : write_comments_biff2(O, te), Y && write_biff_rec(O, 574, write_Window2((W.Views || [])[0])), Y && (U["!merges"] || []).length && write_biff_rec(O, 229, write_MergeCells(U["!merges"])), Y && write_ws_biff8_hlinks(O, U), write_biff_rec(O, 442, write_XLUnicodeString(le)), Y && write_FEAT(O, U), write_biff_rec(
    O,
    10
    /* EOF */
  ), O.end();
}
function write_biff8_global(F, x, w) {
  var O = buf_array(), D = (F || {}).Workbook || {}, U = D.Sheets || [], W = (
    /*::((*/
    D.WBProps || {
      /*::CodeName:"ThisWorkbook"*/
    }
  ), X = w.biff == 8, G = w.biff == 5;
  if (write_biff_rec(O, 2057, write_BOF(F, 5, w)), w.bookType == "xla" && write_biff_rec(
    O,
    135
    /* Addin */
  ), write_biff_rec(O, 225, X ? writeuint16(1200) : null), write_biff_rec(O, 193, writezeroes(2)), G && write_biff_rec(
    O,
    191
    /* ToolbarHdr */
  ), G && write_biff_rec(
    O,
    192
    /* ToolbarEnd */
  ), write_biff_rec(
    O,
    226
    /* InterfaceEnd */
  ), write_biff_rec(O, 92, write_WriteAccess("SheetJS", w)), write_biff_rec(O, 66, writeuint16(X ? 1200 : 1252)), X && write_biff_rec(O, 353, writeuint16(0)), X && write_biff_rec(
    O,
    448
    /* Excel9File */
  ), write_biff_rec(O, 317, write_RRTabId(F.SheetNames.length)), X && F.vbaraw && write_biff_rec(
    O,
    211
    /* ObProj */
  ), X && F.vbaraw) {
    var Y = W.CodeName || "ThisWorkbook";
    write_biff_rec(O, 442, write_XLUnicodeString(Y));
  }
  write_biff_rec(O, 156, writeuint16(17)), write_biff_rec(O, 25, writebool(!1)), write_biff_rec(O, 18, writebool(!1)), write_biff_rec(O, 19, writeuint16(0)), X && write_biff_rec(O, 431, writebool(!1)), X && write_biff_rec(O, 444, writeuint16(0)), write_biff_rec(O, 61, write_Window1()), write_biff_rec(O, 64, writebool(!1)), write_biff_rec(O, 141, writeuint16(0)), write_biff_rec(O, 34, writebool(safe1904(F) == "true")), write_biff_rec(O, 14, writebool(!0)), X && write_biff_rec(O, 439, writebool(!1)), write_biff_rec(O, 218, writeuint16(0)), write_FONTS_biff8(O, F, w), write_FMTS_biff8(O, F.SSF, w), write_CELLXFS_biff8(O, w), X && write_biff_rec(O, 352, writebool(!1));
  var K = O.end(), Z = buf_array();
  X && write_biff_rec(Z, 140, write_Country()), X && b8ocnts.length && write_biff_rec(Z, 235, write_MsoDrawingGroup()), X && w.Strings && write_biff_continue(Z, 252, write_SST(w.Strings)), write_biff_rec(
    Z,
    10
    /* EOF */
  );
  var q = Z.end(), J = buf_array(), ee = 0, re = 0;
  for (re = 0; re < F.SheetNames.length; ++re) ee += (X ? 12 : 11) + (X ? 2 : 1) * F.SheetNames[re].length;
  var te = K.length + ee + q.length;
  for (re = 0; re < F.SheetNames.length; ++re) {
    var Q = U[re] || {};
    write_biff_rec(J, 133, write_BoundSheet8({ pos: te, hs: Q.Hidden || 0, dt: 0, name: F.SheetNames[re] }, w)), te += x[re].length;
  }
  var oe = J.end();
  if (ee != oe.length) throw new Error("BS8 " + ee + " != " + oe.length);
  var ne = [];
  return K.length && ne.push(K), oe.length && ne.push(oe), q.length && ne.push(q), bconcat(ne);
}
function write_biff8_buf(F, x) {
  var w = x || {}, O = [];
  F && !F.SSF && (F.SSF = dup(table_fmt)), F && F.SSF && (make_ssf(), SSF_load_table(F.SSF), w.revssf = evert_num(F.SSF), w.revssf[F.SSF[65535]] = 0, w.ssf = F.SSF), b8oid = 1, b8ocnts = [], w.Strings = /*::((*/
  [], w.Strings.Count = 0, w.Strings.Unique = 0, fix_write_opts(w), w.cellXfs = [], get_cell_style(w.cellXfs, {}, { revssf: { General: 0 } }), F.Props || (F.Props = {});
  for (var D = 0; D < F.SheetNames.length; ++D) O[O.length] = write_ws_biff8(D, w, F);
  return O.unshift(write_biff8_global(F, O, w)), bconcat(O);
}
function write_biff_buf(F, x) {
  for (var w = 0; w <= F.SheetNames.length; ++w) {
    var O = F.Sheets[F.SheetNames[w]];
    if (!(!O || !O["!ref"])) {
      var D = decode_range(O["!ref"]);
      D.e.c > 255 && typeof console < "u" && console.error && console.error("Worksheet '" + F.SheetNames[w] + "' extends beyond column IV (255).  Data may be lost."), D.e.r > 65535 && typeof console < "u" && console.error && console.error("Worksheet '" + F.SheetNames[w] + "' extends beyond row 65536.  Data may be lost.");
    }
  }
  var U = x || {};
  switch (U.biff || 2) {
    case 8:
    case 5:
      return write_biff8_buf(F, x);
    case 4:
    case 3:
    case 2:
      return write_biff2_buf(F, x);
  }
  throw new Error("invalid type " + U.bookType + " for BIFF");
}
function html_to_sheet(F, x) {
  var w = x, O = w.dense != null ? w.dense : DENSE, D = {};
  O && (D["!data"] = []), F = str_remove_ng(F, "<!--", "-->");
  var U = F.match(/<table/i);
  if (!U) throw new Error("Invalid HTML: could not find <table>");
  var W = F.match(/<\/table/i), X = U.index, G = W && W.index || F.length, Y = split_regex(F.slice(X, G), /(:?<tr[^<>]*>)/i, "<tr>"), K = -1, Z = 0, q = 0, J = 0, ee = { s: { r: 1e7, c: 1e7 }, e: { r: 0, c: 0 } }, re = [];
  for (X = 0; X < Y.length; ++X) {
    var te = Y[X].trim(), Q = te.slice(0, 3).toLowerCase();
    if (Q == "<tr") {
      if (++K, w.sheetRows && w.sheetRows <= K) {
        --K;
        break;
      }
      Z = 0;
      continue;
    }
    if (!(Q != "<td" && Q != "<th")) {
      var oe = te.split(/<\/t[dh]>/i);
      for (G = 0; G < oe.length; ++G) {
        var ne = oe[G].trim();
        if (ne.match(/<t[dh]/i)) {
          for (var le = ne, Ee = 0; le.charAt(0) == "<" && (Ee = le.indexOf(">")) > -1; ) le = le.slice(Ee + 1);
          for (var Te = 0; Te < re.length; ++Te) {
            var de = re[Te];
            de.s.c == Z && de.s.r < K && K <= de.e.r && (Z = de.e.c + 1, Te = -1);
          }
          var ae = parsexmltag(ne.slice(0, ne.indexOf(">")));
          J = ae.colspan ? +ae.colspan : 1, ((q = +ae.rowspan) > 1 || J > 1) && re.push({ s: { r: K, c: Z }, e: { r: K + (q || 1) - 1, c: Z + J - 1 } });
          var se = ae.t || ae["data-t"] || "";
          if (!le.length) {
            Z += J;
            continue;
          }
          if (le = htmldecode(le), ee.s.r > K && (ee.s.r = K), ee.e.r < K && (ee.e.r = K), ee.s.c > Z && (ee.s.c = Z), ee.e.c < Z && (ee.e.c = Z), !le.length) {
            Z += J;
            continue;
          }
          var ce = { t: "s", v: le };
          w.raw || !le.trim().length || se == "s" || (le === "TRUE" ? ce = { t: "b", v: !0 } : le === "FALSE" ? ce = { t: "b", v: !1 } : isNaN(fuzzynum(le)) ? isNaN(fuzzydate(le).getDate()) ? le.charCodeAt(0) == 35 && RBErr[le] != null && (ce.t = "e", ce.w = le, ce.v = RBErr[le]) : (ce = { t: "d", v: parseDate(le) }, w.UTC === !1 && (ce.v = utc_to_local(ce.v)), w.cellDates || (ce = { t: "n", v: datenum(ce.v) }), ce.z = w.dateNF || table_fmt[14]) : ce = { t: "n", v: fuzzynum(le) }), ce.cellText !== !1 && (ce.w = le), O ? (D["!data"][K] || (D["!data"][K] = []), D["!data"][K][Z] = ce) : D[encode_cell({ r: K, c: Z })] = ce, Z += J;
        }
      }
    }
  }
  return D["!ref"] = encode_range(ee), re.length && (D["!merges"] = re), D;
}
function make_html_row(F, x, w, O) {
  for (var D = F["!merges"] || [], U = [], W = {}, X = F["!data"] != null, G = x.s.c; G <= x.e.c; ++G) {
    for (var Y = 0, K = 0, Z = 0; Z < D.length; ++Z)
      if (!(D[Z].s.r > w || D[Z].s.c > G) && !(D[Z].e.r < w || D[Z].e.c < G)) {
        if (D[Z].s.r < w || D[Z].s.c < G) {
          Y = -1;
          break;
        }
        Y = D[Z].e.r - D[Z].s.r + 1, K = D[Z].e.c - D[Z].s.c + 1;
        break;
      }
    if (!(Y < 0)) {
      var q = encode_col(G) + encode_row(w), J = X ? (F["!data"][w] || [])[G] : F[q];
      J && J.t == "n" && J.v != null && !isFinite(J.v) && (isNaN(J.v) ? J = { t: "e", v: 36, w: BErr[36] } : J = { t: "e", v: 7, w: BErr[7] });
      var ee = J && J.v != null && (J.h || escapehtml(J.w || (format_cell(J), J.w) || "")) || "";
      W = {}, Y > 1 && (W.rowspan = Y), K > 1 && (W.colspan = K), O.editable ? ee = '<span contenteditable="true">' + ee + "</span>" : J && (W["data-t"] = J && J.t || "z", J.v != null && (W["data-v"] = escapehtml(J.v instanceof Date ? J.v.toISOString() : J.v)), J.z != null && (W["data-z"] = J.z), J.l && (J.l.Target || "#").charAt(0) != "#" && (ee = '<a href="' + escapehtml(J.l.Target) + '">' + ee + "</a>")), W.id = (O.id || "sjs") + "-" + q, U.push(writextag("td", ee, W));
    }
  }
  var re = "<tr>";
  return re + U.join("") + "</tr>";
}
var HTML_BEGIN = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>', HTML_END = "</body></html>";
function html_to_workbook(F, x) {
  var w = str_match_xml_ig(F, "table");
  if (!w || w.length == 0) throw new Error("Invalid HTML: could not find <table>");
  if (w.length == 1) {
    var O = sheet_to_workbook(html_to_sheet(w[0], x), x);
    return O.bookType = "html", O;
  }
  var D = book_new();
  return w.forEach(function(U, W) {
    book_append_sheet(D, html_to_sheet(U, x), "Sheet" + (W + 1));
  }), D.bookType = "html", D;
}
function make_html_preamble(F, x, w) {
  var O = [];
  return O.join("") + "<table" + (w && w.id ? ' id="' + w.id + '"' : "") + ">";
}
function sheet_to_html(F, x) {
  var w = x || {}, O = w.header != null ? w.header : HTML_BEGIN, D = w.footer != null ? w.footer : HTML_END, U = [O], W = decode_range(F["!ref"] || "A1");
  if (U.push(make_html_preamble(F, W, w)), F["!ref"]) for (var X = W.s.r; X <= W.e.r; ++X) U.push(make_html_row(F, W, X, w));
  return U.push("</table>" + D), U.join("");
}
function sheet_add_dom(F, x, w) {
  var O = x.rows;
  if (!O)
    throw "Unsupported origin when " + x.tagName + " is not a TABLE";
  var D = w || {}, U = F["!data"] != null, W = 0, X = 0;
  if (D.origin != null)
    if (typeof D.origin == "number") W = D.origin;
    else {
      var G = typeof D.origin == "string" ? decode_cell(D.origin) : D.origin;
      W = G.r, X = G.c;
    }
  var Y = Math.min(D.sheetRows || 1e7, O.length), K = { s: { r: 0, c: 0 }, e: { r: W, c: X } };
  if (F["!ref"]) {
    var Z = decode_range(F["!ref"]);
    K.s.r = Math.min(K.s.r, Z.s.r), K.s.c = Math.min(K.s.c, Z.s.c), K.e.r = Math.max(K.e.r, Z.e.r), K.e.c = Math.max(K.e.c, Z.e.c), W == -1 && (K.e.r = W = Z.e.r + 1);
  }
  var q = [], J = 0, ee = F["!rows"] || (F["!rows"] = []), re = 0, te = 0, Q = 0, oe = 0, ne = 0, le = 0;
  for (F["!cols"] || (F["!cols"] = []); re < O.length && te < Y; ++re) {
    var Ee = O[re];
    if (is_dom_element_hidden(Ee)) {
      if (D.display) continue;
      ee[te] = { hidden: !0 };
    }
    var Te = Ee.cells;
    for (Q = oe = 0; Q < Te.length; ++Q) {
      var de = Te[Q];
      if (!(D.display && is_dom_element_hidden(de))) {
        var ae = de.hasAttribute("data-v") ? de.getAttribute("data-v") : de.hasAttribute("v") ? de.getAttribute("v") : htmldecode(de.innerHTML), se = de.getAttribute("data-z") || de.getAttribute("z");
        for (J = 0; J < q.length; ++J) {
          var ce = q[J];
          ce.s.c == oe + X && ce.s.r < te + W && te + W <= ce.e.r && (oe = ce.e.c + 1 - X, J = -1);
        }
        le = +de.getAttribute("colspan") || 1, ((ne = +de.getAttribute("rowspan") || 1) > 1 || le > 1) && q.push({ s: { r: te + W, c: oe + X }, e: { r: te + W + (ne || 1) - 1, c: oe + X + (le || 1) - 1 } });
        var xe = { t: "s", v: ae }, Ce = de.getAttribute("data-t") || de.getAttribute("t") || "";
        ae != null && (ae.length == 0 ? xe.t = Ce || "z" : D.raw || ae.trim().length == 0 || Ce == "s" || (Ce == "e" && BErr[+ae] ? xe = { t: "e", v: +ae, w: BErr[+ae] } : ae === "TRUE" ? xe = { t: "b", v: !0 } : ae === "FALSE" ? xe = { t: "b", v: !1 } : isNaN(fuzzynum(ae)) ? isNaN(fuzzydate(ae).getDate()) ? ae.charCodeAt(0) == 35 && RBErr[ae] != null && (xe = { t: "e", v: RBErr[ae], w: ae }) : (xe = { t: "d", v: parseDate(ae) }, D.UTC && (xe.v = local_to_utc(xe.v)), D.cellDates || (xe = { t: "n", v: datenum(xe.v) }), xe.z = D.dateNF || table_fmt[14]) : xe = { t: "n", v: fuzzynum(ae) })), xe.z === void 0 && se != null && (xe.z = se);
        var ye = "", ze = de.getElementsByTagName("A");
        if (ze && ze.length) for (var De = 0; De < ze.length && !(ze[De].hasAttribute("href") && (ye = ze[De].getAttribute("href"), ye.charAt(0) != "#")); ++De) ;
        ye && ye.charAt(0) != "#" && ye.slice(0, 11).toLowerCase() != "javascript:" && (xe.l = { Target: ye }), U ? (F["!data"][te + W] || (F["!data"][te + W] = []), F["!data"][te + W][oe + X] = xe) : F[encode_cell({ c: oe + X, r: te + W })] = xe, K.e.c < oe + X && (K.e.c = oe + X), oe += le;
      }
    }
    ++te;
  }
  return q.length && (F["!merges"] = (F["!merges"] || []).concat(q)), K.e.r = Math.max(K.e.r, te - 1 + W), F["!ref"] = encode_range(K), te >= Y && (F["!fullref"] = encode_range((K.e.r = O.length - re + te - 1 + W, K))), F;
}
function parse_dom_table(F, x) {
  var w = x || {}, O = {};
  return w.dense && (O["!data"] = []), sheet_add_dom(O, F, x);
}
function table_to_book(F, x) {
  var w = sheet_to_workbook(parse_dom_table(F, x), x);
  return w;
}
function is_dom_element_hidden(F) {
  var x = "", w = get_get_computed_style_function(F);
  return w && (x = w(F).getPropertyValue("display")), x || (x = F.style && F.style.display), x === "none";
}
function get_get_computed_style_function(F) {
  return F.ownerDocument.defaultView && typeof F.ownerDocument.defaultView.getComputedStyle == "function" ? F.ownerDocument.defaultView.getComputedStyle : typeof getComputedStyle == "function" ? getComputedStyle : null;
}
function parse_text_p(F) {
  var x = F.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ").replace(/<text:s\/>/g, " ").replace(/<text:s text:c="(\d+)"\/>/g, function(O, D) {
    return Array(parseInt(D, 10) + 1).join(" ");
  }).replace(/<text:tab[^<>]*\/>/g, "	").replace(/<text:line-break\/>/g, `
`), w = unescapexml(x.replace(/<[^<>]*>/g, ""));
  return [w];
}
function parse_ods_styles(F, x, w) {
  var O = w || {}, D = xlml_normalize(F);
  xlmlregex.lastIndex = 0, D = remove_doctype(str_remove_ng(D, "<!--", "-->"));
  for (var U, W, X = "", G = "", Y, K = 0, Z = -1, q = ""; U = xlmlregex.exec(D); )
    switch (U[3] = U[3].replace(/_[\s\S]*$/, "")) {
      /* Number Format Definitions */
      case "number-style":
      // <number:number-style> 16.29.2
      case "currency-style":
      // <number:currency-style> 16.29.8
      case "percentage-style":
      // <number:percentage-style> 16.29.10
      case "date-style":
      // <number:date-style> 16.29.11
      case "time-style":
      // <number:time-style> 16.29.19
      case "text-style":
        U[1] === "/" ? (W["truncate-on-overflow"] == "false" && (X.match(/h/) ? X = X.replace(/h+/, "[$&]") : X.match(/m/) ? X = X.replace(/m+/, "[$&]") : X.match(/s/) && (X = X.replace(/s+/, "[$&]"))), O[W.name] = X, X = "") : U[0].charAt(U[0].length - 2) !== "/" && (X = "", W = parsexmltag(U[0], !1));
        break;
      // LibreOffice bug https://bugs.documentfoundation.org/show_bug.cgi?id=149484
      case "boolean-style":
        U[1] === "/" ? (O[W.name] = "General", X = "") : U[0].charAt(U[0].length - 2) !== "/" && (X = "", W = parsexmltag(U[0], !1));
        break;
      /* Number Format Elements */
      case "boolean":
        X += "General";
        break;
      case "text":
        U[1] === "/" ? (q = D.slice(Z, xlmlregex.lastIndex - U[0].length), q == "%" && W[0] == "<number:percentage-style" ? X += "%" : X += '"' + q.replace(/"/g, '""') + '"') : U[0].charAt(U[0].length - 2) !== "/" && (Z = xlmlregex.lastIndex);
        break;
      case "day":
        switch (Y = parsexmltag(U[0], !1), Y.style) {
          case "short":
            X += "d";
            break;
          case "long":
            X += "dd";
            break;
          default:
            X += "dd";
            break;
        }
        break;
      case "day-of-week":
        switch (Y = parsexmltag(U[0], !1), Y.style) {
          case "short":
            X += "ddd";
            break;
          case "long":
            X += "dddd";
            break;
          default:
            X += "ddd";
            break;
        }
        break;
      case "era":
        switch (Y = parsexmltag(U[0], !1), Y.style) {
          case "short":
            X += "ee";
            break;
          case "long":
            X += "eeee";
            break;
          default:
            X += "eeee";
            break;
        }
        break;
      case "hours":
        switch (Y = parsexmltag(U[0], !1), Y.style) {
          case "short":
            X += "h";
            break;
          case "long":
            X += "hh";
            break;
          default:
            X += "hh";
            break;
        }
        break;
      case "minutes":
        switch (Y = parsexmltag(U[0], !1), Y.style) {
          case "short":
            X += "m";
            break;
          case "long":
            X += "mm";
            break;
          default:
            X += "mm";
            break;
        }
        break;
      case "month":
        switch (Y = parsexmltag(U[0], !1), Y.textual && (X += "mm"), Y.style) {
          case "short":
            X += "m";
            break;
          case "long":
            X += "mm";
            break;
          default:
            X += "m";
            break;
        }
        break;
      case "seconds":
        {
          switch (Y = parsexmltag(U[0], !1), Y.style) {
            case "short":
              X += "s";
              break;
            case "long":
              X += "ss";
              break;
            default:
              X += "ss";
              break;
          }
          Y["decimal-places"] && (X += "." + fill("0", +Y["decimal-places"]));
        }
        break;
      case "year":
        switch (Y = parsexmltag(U[0], !1), Y.style) {
          case "short":
            X += "yy";
            break;
          case "long":
            X += "yyyy";
            break;
          default:
            X += "yy";
            break;
        }
        break;
      case "am-pm":
        X += "AM/PM";
        break;
      case "week-of-year":
      // <number:week-of-year> 16.29.17
      case "quarter":
        console.error("Excel does not support ODS format token " + U[3]);
        break;
      case "fill-character":
        U[1] === "/" ? (q = D.slice(Z, xlmlregex.lastIndex - U[0].length), X += '"' + q.replace(/"/g, '""') + '"*') : U[0].charAt(U[0].length - 2) !== "/" && (Z = xlmlregex.lastIndex);
        break;
      case "scientific-number":
        Y = parsexmltag(U[0], !1), X += "0." + fill("0", +Y["min-decimal-places"] || +Y["decimal-places"] || 2) + fill("?", +Y["decimal-places"] - +Y["min-decimal-places"] || 0) + "E" + (parsexmlbool(Y["forced-exponent-sign"]) ? "+" : "") + fill("0", +Y["min-exponent-digits"] || 2);
        break;
      case "fraction":
        Y = parsexmltag(U[0], !1), +Y["min-integer-digits"] ? X += fill("0", +Y["min-integer-digits"]) : X += "#", X += " ", X += fill("?", +Y["min-numerator-digits"] || 1), X += "/", +Y["denominator-value"] ? X += Y["denominator-value"] : X += fill("?", +Y["min-denominator-digits"] || 1);
        break;
      case "currency-symbol":
        U[1] === "/" ? X += '"' + D.slice(Z, xlmlregex.lastIndex - U[0].length).replace(/"/g, '""') + '"' : U[0].charAt(U[0].length - 2) !== "/" ? Z = xlmlregex.lastIndex : X += "$";
        break;
      case "text-properties":
        switch (Y = parsexmltag(U[0], !1), (Y.color || "").toLowerCase().replace("#", "")) {
          case "ff0000":
          case "red":
            X = "[Red]" + X;
            break;
        }
        break;
      case "text-content":
        X += "@";
        break;
      case "map":
        Y = parsexmltag(U[0], !1), unescapexml(Y.condition) == "value()>=0" ? X = O[Y["apply-style-name"]] + ";" + X : console.error("ODS number format may be incorrect: " + Y.condition);
        break;
      case "number":
        if (U[1] === "/") break;
        Y = parsexmltag(U[0], !1), G = "", G += fill("0", +Y["min-integer-digits"] || 1), parsexmlbool(Y.grouping) && (G = commaify(fill("#", Math.max(0, 4 - G.length)) + G)), (+Y["min-decimal-places"] || +Y["decimal-places"]) && (G += "."), +Y["min-decimal-places"] && (G += fill("0", +Y["min-decimal-places"] || 1)), +Y["decimal-places"] - (+Y["min-decimal-places"] || 0) && (G += fill("0", +Y["decimal-places"] - (+Y["min-decimal-places"] || 0))), X += G;
        break;
      case "embedded-text":
        U[1] === "/" ? K == 0 ? X += '"' + D.slice(Z, xlmlregex.lastIndex - U[0].length).replace(/"/g, '""') + '"' : X = X.slice(0, K) + '"' + D.slice(Z, xlmlregex.lastIndex - U[0].length).replace(/"/g, '""') + '"' + X.slice(K) : U[0].charAt(U[0].length - 2) !== "/" && (Z = xlmlregex.lastIndex, K = -+parsexmltag(U[0], !1).position || 0);
        break;
    }
  return O;
}
function parse_content_xml(F, x, w) {
  var O = x || {}, D = xlml_normalize(F), U = [], W, X, G, Y = "", K = 0, Z, q, J = {}, ee = [], re = {};
  O.dense && (re["!data"] = []);
  var te, Q, oe = { value: "" }, ne = {}, le = "", Ee = 0, Te = "", de = 0, ae = [], se = [], ce = -1, xe = -1, Ce = { s: { r: 1e6, c: 1e7 }, e: { r: 0, c: 0 } }, ye = 0, ze = w || {}, De = {}, et = [], Oe = {}, Xe = 0, He = 0, Ae = [], qe = 1, Ue = 1, Re = [], Me = { Names: [], WBProps: {} }, je = {}, Je = ["", ""], rt = [], fe = {}, Se = "", we = 0, me = !1, ke = !1, ue = 0;
  for (xlmlregex.lastIndex = 0, D = remove_doctype(str_remove_ng(D, "<!--", "-->")); te = xlmlregex.exec(D); ) switch (te[3] = te[3].replace(/_[\s\S]*$/, "")) {
    case "table":
    case "工作表":
      te[1] === "/" ? (Ce.e.c >= Ce.s.c && Ce.e.r >= Ce.s.r ? re["!ref"] = encode_range(Ce) : re["!ref"] = "A1:A1", O.sheetRows > 0 && O.sheetRows <= Ce.e.r && (re["!fullref"] = re["!ref"], Ce.e.r = O.sheetRows - 1, re["!ref"] = encode_range(Ce)), et.length && (re["!merges"] = et), Ae.length && (re["!rows"] = Ae), Z.name = Z.名称 || Z.name, typeof JSON < "u" && JSON.stringify(Z), ee.push(Z.name), J[Z.name] = re, ke = !1) : te[0].charAt(te[0].length - 2) !== "/" && (Z = parsexmltag(te[0], !1), ce = xe = -1, Ce.s.r = Ce.s.c = 1e7, Ce.e.r = Ce.e.c = 0, re = {}, O.dense && (re["!data"] = []), et = [], Ae = [], ke = !0);
      break;
    case "table-row-group":
      te[1] === "/" ? --ye : ++ye;
      break;
    case "table-row":
    case "行":
      if (te[1] === "/") {
        ce += qe, qe = 1;
        break;
      }
      if (q = parsexmltag(te[0], !1), q.行号 ? ce = q.行号 - 1 : ce == -1 && (ce = 0), qe = +q["number-rows-repeated"] || 1, qe < 10) for (ue = 0; ue < qe; ++ue) ye > 0 && (Ae[ce + ue] = { level: ye });
      xe = -1;
      break;
    case "covered-table-cell":
      if (te[1] !== "/")
        if (++xe, oe = parsexmltag(te[0], !1), Ue = parseInt(oe["number-columns-repeated"] || "1", 10) || 1, O.sheetStubs) {
          for (; Ue-- > 0; )
            O.dense ? (re["!data"][ce] || (re["!data"][ce] = []), re["!data"][ce][xe] = { t: "z" }) : re[encode_cell({ r: ce, c: xe })] = { t: "z" }, ++xe;
          --xe;
        } else xe += Ue - 1;
      le = "", ae = [];
      break;
    /* stub */
    case "table-cell":
    case "数据":
      if (te[0].charAt(te[0].length - 2) === "/")
        ++xe, oe = parsexmltag(te[0], !1), Ue = parseInt(oe["number-columns-repeated"] || "1", 10) || 1, Q = {
          t: "z",
          v: null
          /*:: , z:null, w:"",c:[]*/
        }, oe.formula && O.cellFormula != !1 && (Q.f = ods_to_csf_formula(unescapexml(oe.formula))), oe["style-name"] && De[oe["style-name"]] && (Q.z = De[oe["style-name"]]), (oe.数据类型 || oe["value-type"]) == "string" && (Q.t = "s", Q.v = unescapexml(oe["string-value"] || ""), O.dense ? (re["!data"][ce] || (re["!data"][ce] = []), re["!data"][ce][xe] = Q) : re[encode_col(xe) + encode_row(ce)] = Q), xe += Ue - 1;
      else if (te[1] !== "/") {
        ++xe, le = Te = "", Ee = de = 0, ae = [], se = [], Ue = 1;
        var We = qe ? ce + qe - 1 : ce;
        if (xe > Ce.e.c && (Ce.e.c = xe), xe < Ce.s.c && (Ce.s.c = xe), ce < Ce.s.r && (Ce.s.r = ce), We > Ce.e.r && (Ce.e.r = We), oe = parsexmltag(te[0], !1), ne = parsexmltagraw(te[0]), rt = [], fe = {}, Q = {
          t: oe.数据类型 || oe["value-type"],
          v: null
          /*:: , z:null, w:"",c:[]*/
        }, oe["style-name"] && De[oe["style-name"]] && (Q.z = De[oe["style-name"]]), O.cellFormula)
          if (oe.formula && (oe.formula = unescapexml(oe.formula)), oe["number-matrix-columns-spanned"] && oe["number-matrix-rows-spanned"] && (Xe = parseInt(oe["number-matrix-rows-spanned"], 10) || 0, He = parseInt(oe["number-matrix-columns-spanned"], 10) || 0, Oe = { s: { r: ce, c: xe }, e: { r: ce + Xe - 1, c: xe + He - 1 } }, Q.F = encode_range(Oe), Re.push([Oe, Q.F])), oe.formula) Q.f = ods_to_csf_formula(oe.formula);
          else for (ue = 0; ue < Re.length; ++ue)
            ce >= Re[ue][0].s.r && ce <= Re[ue][0].e.r && xe >= Re[ue][0].s.c && xe <= Re[ue][0].e.c && (Q.F = Re[ue][1]);
        switch ((oe["number-columns-spanned"] || oe["number-rows-spanned"]) && (Xe = parseInt(oe["number-rows-spanned"] || "1", 10) || 1, He = parseInt(oe["number-columns-spanned"] || "1", 10) || 1, Xe * He > 1 && (Oe = { s: { r: ce, c: xe }, e: { r: ce + Xe - 1, c: xe + He - 1 } }, et.push(Oe))), oe["number-columns-repeated"] && (Ue = parseInt(oe["number-columns-repeated"], 10)), Q.t) {
          case "boolean":
            Q.t = "b", Q.v = parsexmlbool(oe["boolean-value"]) || +oe["boolean-value"] >= 1;
            break;
          case "float":
            Q.t = "n", Q.v = parseFloat(oe.value), O.cellDates && Q.z && fmt_is_date(Q.z) && (Q.v = numdate(Q.v + (Me.WBProps.date1904 ? 1462 : 0)), Q.t = typeof Q.v == "number" ? "n" : "d");
            break;
          case "percentage":
            Q.t = "n", Q.v = parseFloat(oe.value);
            break;
          case "currency":
            Q.t = "n", Q.v = parseFloat(oe.value);
            break;
          case "date":
            Q.t = "d", Q.v = parseDate(oe["date-value"], Me.WBProps.date1904), O.cellDates || (Q.t = "n", Q.v = datenum(Q.v, Me.WBProps.date1904)), Q.z || (Q.z = "m/d/yy");
            break;
          /* NOTE: for `time`, Excel ODS export incorrectly uses durations relative to 1900 epoch even if 1904 is specified */
          case "time":
            Q.t = "n", Q.v = parse_isodur(oe["time-value"]) / 86400, O.cellDates && (Q.v = numdate(Q.v), Q.t = typeof Q.v == "number" ? "n" : "d"), Q.z || (Q.z = "HH:MM:SS");
            break;
          case "number":
            Q.t = "n", Q.v = parseFloat(oe.数据数值);
            break;
          default:
            if (Q.t === "string" || Q.t === "text" || !Q.t)
              Q.t = "s", oe["string-value"] != null && (le = unescapexml(oe["string-value"]), ae = []);
            else throw new Error("Unsupported value type " + Q.t);
        }
      } else {
        if (me = !1, ne["calcext:value-type"] == "error" && RBErr[le] != null && (Q.t = "e", Q.w = le, Q.v = RBErr[le]), Q.t === "s" && (Q.v = le || "", ae.length && (Q.R = ae), me = Ee == 0), je.Target && (Q.l = je), rt.length > 0 && (Q.c = rt, rt = []), le && O.cellText !== !1 && (Q.w = le), me && (Q.t = "z", delete Q.v), (!me || O.sheetStubs) && !(O.sheetRows && O.sheetRows <= ce))
          for (var Ge = 0; Ge < qe; ++Ge) {
            if (Ue = parseInt(oe["number-columns-repeated"] || "1", 10), O.dense)
              for (re["!data"][ce + Ge] || (re["!data"][ce + Ge] = []), re["!data"][ce + Ge][xe] = Ge == 0 ? Q : dup(Q); --Ue > 0; ) re["!data"][ce + Ge][xe + Ue] = dup(Q);
            else
              for (re[encode_cell({ r: ce + Ge, c: xe })] = Q; --Ue > 0; ) re[encode_cell({ r: ce + Ge, c: xe + Ue })] = dup(Q);
            Ce.e.c <= xe && (Ce.e.c = xe);
          }
        Ue = parseInt(oe["number-columns-repeated"] || "1", 10), xe += Ue - 1, Ue = 0, Q = {
          /*:: t:"", v:null, z:null, w:"",c:[]*/
        }, le = "", ae = [];
      }
      je = {};
      break;
    // 9.1.4 <table:table-cell>
    /* pure state */
    case "document":
    // TODO: <office:document> is the root for FODS
    case "document-content":
    case "电子表格文档":
    // 3.1.3.2 <office:document-content>
    case "spreadsheet":
    case "主体":
    // 3.7 <office:spreadsheet>
    case "scripts":
    // 3.12 <office:scripts>
    case "styles":
    // TODO <office:styles>
    case "font-face-decls":
    // 3.14 <office:font-face-decls>
    case "master-styles":
      if (te[1] === "/") {
        if ((W = U.pop())[0] !== te[3]) throw "Bad state: " + W;
      } else te[0].charAt(te[0].length - 2) !== "/" && U.push([te[3], !0]);
      break;
    case "annotation":
      if (te[1] === "/") {
        if ((W = U.pop())[0] !== te[3]) throw "Bad state: " + W;
        fe.t = le, ae.length && (fe.R = ae), fe.a = Se, rt.push(fe), le = Te, Ee = de, ae = se;
      } else if (te[0].charAt(te[0].length - 2) !== "/") {
        U.push([te[3], !1]);
        var Pe = parsexmltag(te[0], !0);
        Pe.display && parsexmlbool(Pe.display) || (rt.hidden = !0), Te = le, de = Ee, se = ae, le = "", Ee = 0, ae = [];
      }
      Se = "", we = 0;
      break;
    case "creator":
      te[1] === "/" ? Se = D.slice(we, te.index) : we = te.index + te[0].length;
      break;
    /* ignore state */
    case "meta":
    case "元数据":
    // TODO: <office:meta> <uof:元数据> FODS/UOF
    case "settings":
    // TODO: <office:settings>
    case "config-item-set":
    // TODO: <office:config-item-set>
    case "config-item-map-indexed":
    // TODO: <office:config-item-map-indexed>
    case "config-item-map-entry":
    // TODO: <office:config-item-map-entry>
    case "config-item-map-named":
    // TODO: <office:config-item-map-entry>
    case "shapes":
    // 9.2.8 <table:shapes>
    case "frame":
    // 10.4.2 <draw:frame>
    case "text-box":
    // 10.4.3 <draw:text-box>
    case "image":
    // 10.4.4 <draw:image>
    case "data-pilot-tables":
    // 9.6.2 <table:data-pilot-tables>
    case "list-style":
    // 16.30 <text:list-style>
    case "form":
    // 13.13 <form:form>
    case "dde-links":
    // 9.8 <table:dde-links>
    case "event-listeners":
    // TODO
    case "chart":
      if (te[1] === "/") {
        if ((W = U.pop())[0] !== te[3]) throw "Bad state: " + W;
      } else te[0].charAt(te[0].length - 2) !== "/" && U.push([te[3], !1]);
      le = "", Ee = 0, ae = [];
      break;
    case "scientific-number":
    // <number:scientific-number>
    case "currency-symbol":
    // <number:currency-symbol>
    case "fill-character":
      break;
    case "text-style":
    // 16.27.25 <number:text-style>
    case "boolean-style":
    // 16.27.23 <number:boolean-style>
    case "number-style":
    // 16.27.2 <number:number-style>
    case "currency-style":
    // 16.29.8 <number:currency-style>
    case "percentage-style":
    // 16.27.9 <number:percentage-style>
    case "date-style":
    // 16.27.10 <number:date-style>
    case "time-style":
      if (te[1] === "/") {
        var it = xlmlregex.lastIndex;
        parse_ods_styles(D.slice(G, xlmlregex.lastIndex), x, ze), xlmlregex.lastIndex = it;
      } else te[0].charAt(te[0].length - 2) !== "/" && (G = xlmlregex.lastIndex - te[0].length);
      break;
    case "script":
      break;
    // 3.13 <office:script>
    case "libraries":
      break;
    // TODO: <ooo:libraries>
    case "automatic-styles":
      break;
    // 3.15.3 <office:automatic-styles>
    case "default-style":
    // TODO: <style:default-style>
    case "page-layout":
      break;
    // TODO: <style:page-layout>
    case "style":
      {
        var Ve = parsexmltag(te[0], !1);
        Ve.family == "table-cell" && ze[Ve["data-style-name"]] && (De[Ve.name] = ze[Ve["data-style-name"]]);
      }
      break;
    case "map":
      break;
    // 16.3 <style:map>
    case "font-face":
      break;
    // 16.21 <style:font-face>
    case "paragraph-properties":
      break;
    // 17.6 <style:paragraph-properties>
    case "table-properties":
      break;
    // 17.15 <style:table-properties>
    case "table-column-properties":
      break;
    // 17.16 <style:table-column-properties>
    case "table-row-properties":
      break;
    // 17.17 <style:table-row-properties>
    case "table-cell-properties":
      break;
    // 17.18 <style:table-cell-properties>
    case "number":
      break;
    case "fraction":
      break;
    // TODO 16.27.6 <number:fraction>
    case "day":
    // 16.27.11 <number:day>
    case "month":
    // 16.27.12 <number:month>
    case "year":
    // 16.27.13 <number:year>
    case "era":
    // 16.27.14 <number:era>
    case "day-of-week":
    // 16.27.15 <number:day-of-week>
    case "week-of-year":
    // 16.27.16 <number:week-of-year>
    case "quarter":
    // 16.27.17 <number:quarter>
    case "hours":
    // 16.27.19 <number:hours>
    case "minutes":
    // 16.27.20 <number:minutes>
    case "seconds":
    // 16.27.21 <number:seconds>
    case "am-pm":
      break;
    case "boolean":
      break;
    // 16.27.24 <number:boolean>
    case "text":
      if (te[0].slice(-2) === "/>") break;
      if (te[1] === "/") switch (U[U.length - 1][0]) {
        case "number-style":
        case "date-style":
        case "time-style":
          Y += D.slice(K, te.index);
          break;
      }
      else K = te.index + te[0].length;
      break;
    case "named-range":
      X = parsexmltag(te[0], !1), Je = ods_to_csf_3D(X["cell-range-address"]);
      var st = { Name: X.name, Ref: Je[0] + "!" + Je[1] };
      ke && (st.Sheet = ee.length), Me.Names.push(st);
      break;
    case "text-content":
      break;
    // 16.27.27 <number:text-content>
    case "text-properties":
      break;
    // 16.27.27 <style:text-properties>
    case "embedded-text":
      break;
    // 16.27.4 <number:embedded-text>
    case "body":
    case "电子表格":
      break;
    // 3.3 16.9.6 19.726.3
    case "forms":
      break;
    // 12.25.2 13.2
    case "table-column":
      break;
    // 9.1.6 <table:table-column>
    case "table-header-rows":
      break;
    // 9.1.7 <table:table-header-rows>
    case "table-rows":
      break;
    // 9.1.12 <table:table-rows>
    /* TODO: outline levels */
    case "table-column-group":
      break;
    // 9.1.10 <table:table-column-group>
    case "table-header-columns":
      break;
    // 9.1.11 <table:table-header-columns>
    case "table-columns":
      break;
    // 9.1.12 <table:table-columns>
    case "null-date":
      switch (X = parsexmltag(te[0], !1), X["date-value"]) {
        case "1904-01-01":
          Me.WBProps.date1904 = !0;
          break;
      }
      break;
    case "graphic-properties":
      break;
    // 17.21 <style:graphic-properties>
    case "calculation-settings":
      break;
    // 9.4.1 <table:calculation-settings>
    case "named-expressions":
      break;
    // 9.4.11 <table:named-expressions>
    case "label-range":
      break;
    // 9.4.9 <table:label-range>
    case "label-ranges":
      break;
    // 9.4.10 <table:label-ranges>
    case "named-expression":
      break;
    // 9.4.13 <table:named-expression>
    case "sort":
      break;
    // 9.4.19 <table:sort>
    case "sort-by":
      break;
    // 9.4.20 <table:sort-by>
    case "sort-groups":
      break;
    // 9.4.22 <table:sort-groups>
    case "tab":
      break;
    // 6.1.4 <text:tab>
    case "line-break":
      break;
    // 6.1.5 <text:line-break>
    case "span":
      break;
    // 6.1.7 <text:span>
    case "p":
    case "文本串":
      if (["master-styles"].indexOf(U[U.length - 1][0]) > -1) break;
      if (te[1] === "/" && (!oe || !oe["string-value"])) {
        var dt = parse_text_p(D.slice(Ee, te.index));
        le = (le.length > 0 ? le + `
` : "") + dt[0];
      } else te[0].slice(-2) == "/>" ? le += `
` : (parsexmltag(te[0], !1), Ee = te.index + te[0].length);
      break;
    // <text:p>
    case "s":
      break;
    // <text:s>
    case "database-range":
      if (te[1] === "/") break;
      try {
        Je = ods_to_csf_3D(parsexmltag(te[0])["target-range-address"]), J[Je[0]]["!autofilter"] = { ref: Je[1] };
      } catch {
      }
      break;
    case "date":
      break;
    // <*:date>
    case "object":
      break;
    // 10.4.6.2 <draw:object>
    case "title":
    case "标题":
      break;
    // <*:title> OR <uof:标题>
    case "desc":
      break;
    // <*:desc>
    case "binary-data":
      break;
    // 10.4.5 TODO: b64 blob
    /* 9.2 Advanced Tables */
    case "table-source":
      break;
    // 9.2.6
    case "scenario":
      break;
    // 9.2.6
    case "iteration":
      break;
    // 9.4.3 <table:iteration>
    case "content-validations":
      break;
    // 9.4.4 <table:
    case "content-validation":
      break;
    // 9.4.5 <table:
    case "help-message":
      break;
    // 9.4.6 <table:
    case "error-message":
      break;
    // 9.4.7 <table:
    case "database-ranges":
      break;
    // 9.4.14 <table:database-ranges>
    /* 9.5 Filters */
    case "filter":
      break;
    // 9.5.2 <table:filter>
    case "filter-and":
      break;
    // 9.5.3 <table:filter-and>
    case "filter-or":
      break;
    // 9.5.4 <table:filter-or>
    case "filter-condition":
      break;
    // 9.5.5 <table:filter-condition>
    case "filter-set-item":
      break;
    // 9.5.6 <table:filter-condition>
    case "list-level-style-bullet":
      break;
    // 16.31 <text:
    case "list-level-style-number":
      break;
    // 16.32 <text:
    case "list-level-properties":
      break;
    // 17.19 <style:
    /* 7.3 Document Fields */
    case "sender-firstname":
    // 7.3.6.2
    case "sender-lastname":
    // 7.3.6.3
    case "sender-initials":
    // 7.3.6.4
    case "sender-title":
    // 7.3.6.5
    case "sender-position":
    // 7.3.6.6
    case "sender-email":
    // 7.3.6.7
    case "sender-phone-private":
    // 7.3.6.8
    case "sender-fax":
    // 7.3.6.9
    case "sender-company":
    // 7.3.6.10
    case "sender-phone-work":
    // 7.3.6.11
    case "sender-street":
    // 7.3.6.12
    case "sender-city":
    // 7.3.6.13
    case "sender-postal-code":
    // 7.3.6.14
    case "sender-country":
    // 7.3.6.15
    case "sender-state-or-province":
    // 7.3.6.16
    case "author-name":
    // 7.3.7.1
    case "author-initials":
    // 7.3.7.2
    case "chapter":
    // 7.3.8
    case "file-name":
    // 7.3.9
    case "template-name":
    // 7.3.9
    case "sheet-name":
      break;
    case "event-listener":
      break;
    /* TODO: FODS Properties */
    case "initial-creator":
    case "creation-date":
    case "print-date":
    case "generator":
    case "document-statistic":
    case "user-defined":
    case "editing-duration":
    case "editing-cycles":
      break;
    /* TODO: FODS Config */
    case "config-item":
      break;
    /* TODO: style tokens */
    case "page-number":
      break;
    // TODO <text:page-number>
    case "page-count":
      break;
    // TODO <text:page-count>
    case "time":
      break;
    // TODO <text:time>
    /* 9.3 Advanced Table Cells */
    case "cell-range-source":
      break;
    // 9.3.1 <table:
    case "detective":
      break;
    // 9.3.2 <table:
    case "operation":
      break;
    // 9.3.3 <table:
    case "highlighted-range":
      break;
    // 9.3.4 <table:
    /* 9.6 Data Pilot Tables <table: */
    case "data-pilot-table":
    // 9.6.3
    case "source-cell-range":
    // 9.6.5
    case "source-service":
    // 9.6.6
    case "data-pilot-field":
    // 9.6.7
    case "data-pilot-level":
    // 9.6.8
    case "data-pilot-subtotals":
    // 9.6.9
    case "data-pilot-subtotal":
    // 9.6.10
    case "data-pilot-members":
    // 9.6.11
    case "data-pilot-member":
    // 9.6.12
    case "data-pilot-display-info":
    // 9.6.13
    case "data-pilot-sort-info":
    // 9.6.14
    case "data-pilot-layout-info":
    // 9.6.15
    case "data-pilot-field-reference":
    // 9.6.16
    case "data-pilot-groups":
    // 9.6.17
    case "data-pilot-group":
    // 9.6.18
    case "data-pilot-group-member":
      break;
    /* 10.3 Drawing Shapes */
    case "rect":
      break;
    /* 14.6 DDE Connections */
    case "dde-connection-decls":
    // 14.6.2 <text:
    case "dde-connection-decl":
    // 14.6.3 <text:
    case "dde-link":
    // 14.6.4 <table:
    case "dde-source":
      break;
    case "properties":
      break;
    // 13.7 <form:properties>
    case "property":
      break;
    // 13.8 <form:property>
    case "a":
      if (te[1] !== "/") {
        if (je = parsexmltag(te[0], !1), !je.href) break;
        je.Target = unescapexml(je.href), delete je.href, je.Target.charAt(0) == "#" && je.Target.indexOf(".") > -1 ? (Je = ods_to_csf_3D(je.Target.slice(1)), je.Target = "#" + Je[0] + "!" + Je[1]) : je.Target.match(/^\.\.[\\\/]/) && (je.Target = je.Target.slice(3));
      }
      break;
    /* non-standard */
    case "table-protection":
      break;
    case "data-pilot-grand-total":
      break;
    // <table:
    case "office-document-common-attrs":
      break;
    // bare
    default:
      switch (te[2]) {
        case "dc:":
        // TODO: properties
        case "calcext:":
        // ignore undocumented extensions
        case "loext:":
        // ignore undocumented extensions
        case "ooo:":
        // ignore undocumented extensions
        case "chartooo:":
        // ignore undocumented extensions
        case "draw:":
        // TODO: drawing
        case "style:":
        // TODO: styles
        case "chart:":
        // TODO: charts
        case "form:":
        // TODO: forms
        case "uof:":
        // TODO: uof
        case "表:":
        // TODO: uof
        case "字:":
          break;
        default:
          if (O.WTF) throw new Error(te);
      }
  }
  var ut = {
    Sheets: J,
    SheetNames: ee,
    Workbook: Me
  };
  return O.bookSheets && delete /*::(*/
  ut.Sheets, ut;
}
function parse_ods(F, x) {
  x = x || {}, safegetzipfile(F, "META-INF/manifest.xml") && parse_manifest(getzipdata(F, "META-INF/manifest.xml"), x);
  var w = getzipstr(F, "styles.xml"), O = w && parse_ods_styles(utf8read(w)), D = getzipstr(F, "content.xml");
  if (!D) throw new Error("Missing content.xml in ODS / UOF file");
  var U = parse_content_xml(utf8read(D), x, O);
  return safegetzipfile(F, "meta.xml") && (U.Props = parse_core_props(getzipdata(F, "meta.xml"))), U.bookType = "ods", U;
}
function parse_fods(F, x) {
  var w = parse_content_xml(F, x);
  return w.bookType = "fods", w;
}
var write_styles_ods = /* @__PURE__ */ function() {
  var F = [
    "<office:master-styles>",
    '<style:master-page style:name="mp1" style:page-layout-name="mp1">',
    "<style:header/>",
    '<style:header-left style:display="false"/>',
    "<style:footer/>",
    '<style:footer-left style:display="false"/>',
    "</style:master-page>",
    "</office:master-styles>"
  ].join(""), x = "<office:document-styles " + wxt_helper({
    "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
    "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
    "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
    "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
    "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
    "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    "xmlns:dc": "http://purl.org/dc/elements/1.1/",
    "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
    "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
    "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
    "office:version": "1.2"
  }) + ">" + F + "</office:document-styles>";
  return function() {
    return XML_HEADER + x;
  };
}();
function write_number_format_ods(F, x) {
  var w = "number", O = "", D = { "style:name": x }, U = "", W = 0;
  F = F.replace(/"[$]"/g, "$");
  e: {
    if (F.indexOf(";") > -1 && (console.error("Unsupported ODS Style Map exported.  Using first branch of " + F), F = F.slice(0, F.indexOf(";"))), F == "@") {
      w = "text", O = "<number:text-content/>";
      break e;
    }
    if (F.indexOf(/\$/) > -1 && (w = "currency"), F[W] == '"') {
      for (U = ""; F[++W] != '"' || F[++W] == '"'; ) U += F[W];
      --W, F[W + 1] == "*" ? (W++, O += "<number:fill-character>" + escapexml(U.replace(/""/g, '"')) + "</number:fill-character>") : O += "<number:text>" + escapexml(U.replace(/""/g, '"')) + "</number:text>", F = F.slice(W + 1), W = 0;
    }
    var X = F.match(/# (\?+)\/(\?+)/);
    if (X) {
      O += writextag("number:fraction", null, { "number:min-integer-digits": 0, "number:min-numerator-digits": X[1].length, "number:max-denominator-value": Math.max(+X[1].replace(/./g, "9"), +X[2].replace(/./g, "9")) });
      break e;
    }
    if (X = F.match(/# (\?+)\/(\d+)/)) {
      O += writextag("number:fraction", null, { "number:min-integer-digits": 0, "number:min-numerator-digits": X[1].length, "number:denominator-value": +X[2] });
      break e;
    }
    if (X = F.match(/\b(\d+)(|\.\d+)%/)) {
      w = "percentage", O += writextag("number:number", null, { "number:decimal-places": X[2] && X.length - 1 || 0, "number:min-decimal-places": X[2] && X.length - 1 || 0, "number:min-integer-digits": X[1].length }) + "<number:text>%</number:text>";
      break e;
    }
    var G = !1;
    if (["y", "m", "d"].indexOf(F[0]) > -1) {
      w = "date";
      t: for (; W < F.length; ++W) switch (U = F[W].toLowerCase()) {
        case "h":
        case "s":
          G = !0, --W;
          break t;
        case "m":
          r: for (var Y = W + 1; Y < F.length; ++Y) switch (F[Y]) {
            case "y":
            case "d":
              break r;
            case "h":
            case "s":
              G = !0, --W;
              break t;
          }
        /* falls through */
        case "y":
        case "d":
          for (; (F[++W] || "").toLowerCase() == U[0]; ) U += U[0];
          switch (--W, U) {
            case "y":
            case "yy":
              O += "<number:year/>";
              break;
            case "yyy":
            case "yyyy":
              O += '<number:year number:style="long"/>';
              break;
            case "mmmmm":
              console.error("ODS has no equivalent of format |mmmmm|");
            /* falls through */
            case "m":
            case "mm":
            case "mmm":
            case "mmmm":
              O += '<number:month number:style="' + (U.length % 2 ? "short" : "long") + '" number:textual="' + (U.length >= 3 ? "true" : "false") + '"/>';
              break;
            case "d":
            case "dd":
              O += '<number:day number:style="' + (U.length % 2 ? "short" : "long") + '"/>';
              break;
            case "ddd":
            case "dddd":
              O += '<number:day-of-week number:style="' + (U.length % 2 ? "short" : "long") + '"/>';
              break;
          }
          break;
        case '"':
          for (; F[++W] != '"' || F[++W] == '"'; ) U += F[W];
          --W, O += "<number:text>" + escapexml(U.slice(1).replace(/""/g, '"')) + "</number:text>";
          break;
        case "\\":
          U = F[++W], O += "<number:text>" + escapexml(U) + "</number:text>";
          break;
        case "/":
        case ":":
          O += "<number:text>" + escapexml(U) + "</number:text>";
          break;
        default:
          console.error("unrecognized character " + U + " in ODF format " + F);
      }
      if (!G) break e;
      F = F.slice(W + 1), W = 0;
    }
    if (F.match(/^\[?[hms]/)) {
      for (w == "number" && (w = "time"), F.match(/\[/) && (F = F.replace(/[\[\]]/g, ""), D["number:truncate-on-overflow"] = "false"); W < F.length; ++W) switch (U = F[W].toLowerCase()) {
        case "h":
        case "m":
        case "s":
          for (; (F[++W] || "").toLowerCase() == U[0]; ) U += U[0];
          switch (--W, U) {
            case "h":
            case "hh":
              O += '<number:hours number:style="' + (U.length % 2 ? "short" : "long") + '"/>';
              break;
            case "m":
            case "mm":
              O += '<number:minutes number:style="' + (U.length % 2 ? "short" : "long") + '"/>';
              break;
            case "s":
            case "ss":
              if (F[W + 1] == ".") do
                U += F[W + 1], ++W;
              while (F[W + 1] == "0");
              O += '<number:seconds number:style="' + (U.match("ss") ? "long" : "short") + '"' + (U.match(/\./) ? ' number:decimal-places="' + (U.match(/0+/) || [""])[0].length + '"' : "") + "/>";
              break;
          }
          break;
        case '"':
          for (; F[++W] != '"' || F[++W] == '"'; ) U += F[W];
          --W, O += "<number:text>" + escapexml(U.slice(1).replace(/""/g, '"')) + "</number:text>";
          break;
        case "/":
        case ":":
          O += "<number:text>" + escapexml(U) + "</number:text>";
          break;
        case "a":
          if (F.slice(W, W + 3).toLowerCase() == "a/p") {
            O += "<number:am-pm/>", W += 2;
            break;
          }
          if (F.slice(W, W + 5).toLowerCase() == "am/pm") {
            O += "<number:am-pm/>", W += 4;
            break;
          }
        /* falls through */
        default:
          console.error("unrecognized character " + U + " in ODF format " + F);
      }
      break e;
    }
    if (F.indexOf(/\$/) > -1 && (w = "currency"), F[0] == "$" && (O += '<number:currency-symbol number:language="en" number:country="US">$</number:currency-symbol>', F = F.slice(1), W = 0), W = 0, F[W] == '"') {
      for (; F[++W] != '"' || F[++W] == '"'; ) U += F[W];
      --W, F[W + 1] == "*" ? (W++, O += "<number:fill-character>" + escapexml(U.replace(/""/g, '"')) + "</number:fill-character>") : O += "<number:text>" + escapexml(U.replace(/""/g, '"')) + "</number:text>", F = F.slice(W + 1), W = 0;
    }
    var K = F.match(/([#0][0#,]*)(\.[0#]*|)(E[+]?0*|)/i);
    if (!K || !K[0]) console.error("Could not find numeric part of " + F);
    else {
      var Z = K[1].replace(/,/g, "");
      O += "<number:" + (K[3] ? "scientific-" : "") + 'number number:min-integer-digits="' + (Z.indexOf("0") == -1 ? "0" : Z.length - Z.indexOf("0")) + '"' + (K[0].indexOf(",") > -1 ? ' number:grouping="true"' : "") + (K[2] && ' number:decimal-places="' + (K[2].length - 1) + '"' || ' number:decimal-places="0"') + (K[3] && K[3].indexOf("+") > -1 ? ' number:forced-exponent-sign="true"' : "") + (K[3] ? ' number:min-exponent-digits="' + K[3].match(/0+/)[0].length + '"' : "") + "></number:" + (K[3] ? "scientific-" : "") + "number>", W = K.index + K[0].length;
    }
    if (F[W] == '"') {
      for (U = ""; F[++W] != '"' || F[++W] == '"'; ) U += F[W];
      --W, O += "<number:text>" + escapexml(U.replace(/""/g, '"')) + "</number:text>";
    }
  }
  return O ? writextag("number:" + w + "-style", O, D) : (console.error("Could not generate ODS number format for |" + F + "|"), "");
}
function write_names_ods(F, x, w) {
  for (var O = [], D = 0; D < F.length; ++D) {
    var U = F[D];
    U && U.Sheet == (w == -1 ? null : w) && O.push(U);
  }
  return O.length ? `      <table:named-expressions>
` + O.map(function(W) {
    var X = (w == -1 ? "$" : "") + csf_to_ods_3D(W.Ref);
    return "        " + writextag("table:named-range", null, {
      "table:name": W.Name,
      "table:cell-range-address": X,
      "table:base-cell-address": X.replace(/[\.][^\.]*$/, ".$A$1")
    });
  }).join(`
`) + `
      </table:named-expressions>
` : "";
}
var write_content_ods = /* @__PURE__ */ function() {
  var F = function(D, U) {
    return escapexml(D).replace(/  +/g, function(W) {
      return '<text:s text:c="' + W.length + '"/>';
    }).replace(/\t/g, "<text:tab/>").replace(/\n/g, "</text:p><text:p>").replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>");
  }, x = `          <table:table-cell />
`, w = function(D, U, W, X, G, Y) {
    var K = [];
    K.push('      <table:table table:name="' + escapexml(U.SheetNames[W]) + `" table:style-name="ta1">
`);
    var Z = 0, q = 0, J = decode_range(D["!ref"] || "A1"), ee = D["!merges"] || [], re = 0, te = D["!data"] != null;
    if (D["!cols"])
      for (q = 0; q <= J.e.c; ++q) K.push("        <table:table-column" + (D["!cols"][q] ? ' table:style-name="co' + D["!cols"][q].ods + '"' : "") + `></table:table-column>
`);
    var Q = "", oe = D["!rows"] || [];
    for (Z = 0; Z < J.s.r; ++Z)
      Q = oe[Z] ? ' table:style-name="ro' + oe[Z].ods + '"' : "", K.push("        <table:table-row" + Q + `></table:table-row>
`);
    for (; Z <= J.e.r; ++Z) {
      for (Q = oe[Z] ? ' table:style-name="ro' + oe[Z].ods + '"' : "", K.push("        <table:table-row" + Q + `>
`), q = 0; q < J.s.c; ++q) K.push(x);
      for (; q <= J.e.c; ++q) {
        var ne = !1, le = {}, Ee = "";
        for (re = 0; re != ee.length; ++re)
          if (!(ee[re].s.c > q) && !(ee[re].s.r > Z) && !(ee[re].e.c < q) && !(ee[re].e.r < Z)) {
            (ee[re].s.c != q || ee[re].s.r != Z) && (ne = !0), le["table:number-columns-spanned"] = ee[re].e.c - ee[re].s.c + 1, le["table:number-rows-spanned"] = ee[re].e.r - ee[re].s.r + 1;
            break;
          }
        if (ne) {
          K.push(`          <table:covered-table-cell/>
`);
          continue;
        }
        var Te = encode_cell({ r: Z, c: q }), de = te ? (D["!data"][Z] || [])[q] : D[Te];
        if (de && de.f && (le["table:formula"] = escapexml(csf_to_ods_formula(de.f)), de.F && de.F.slice(0, Te.length) == Te)) {
          var ae = decode_range(de.F);
          le["table:number-matrix-columns-spanned"] = ae.e.c - ae.s.c + 1, le["table:number-matrix-rows-spanned"] = ae.e.r - ae.s.r + 1;
        }
        if (!de) {
          K.push(x);
          continue;
        }
        switch (de.t) {
          case "b":
            Ee = de.v ? "TRUE" : "FALSE", le["office:value-type"] = "boolean", le["office:boolean-value"] = de.v ? "true" : "false";
            break;
          case "n":
            isFinite(de.v) ? (Ee = de.w || String(de.v || 0), le["office:value-type"] = "float", le["office:value"] = de.v || 0) : (isNaN(de.v) ? (Ee = "#NUM!", le["table:formula"] = "of:=#NUM!") : (Ee = "#DIV/0!", le["table:formula"] = "of:=" + (de.v < 0 ? "-" : "") + "1/0"), le["office:string-value"] = "", le["office:value-type"] = "string", le["calcext:value-type"] = "error");
            break;
          case "s":
          case "str":
            Ee = de.v == null ? "" : de.v, le["office:value-type"] = "string";
            break;
          case "d":
            Ee = de.w || parseDate(de.v, Y).toISOString(), le["office:value-type"] = "date", le["office:date-value"] = parseDate(de.v, Y).toISOString(), le["table:style-name"] = "ce1";
            break;
          //case 'e': // TODO: translate to ODS errors
          default:
            K.push(x);
            continue;
        }
        var se = F(Ee);
        if (de.l && de.l.Target) {
          var ce = de.l.Target;
          ce = ce.charAt(0) == "#" ? "#" + csf_to_ods_3D(ce.slice(1)) : ce, ce.charAt(0) != "#" && !ce.match(/^\w+:/) && (ce = "../" + ce), se = writextag("text:a", se, { "xlink:href": ce.replace(/&/g, "&amp;") });
        }
        G[de.z] && (le["table:style-name"] = "ce" + G[de.z].slice(1));
        var xe = writextag("text:p", se, {});
        if (de.c) {
          for (var Ce = "", ye = "", ze = {}, De = 0; De < de.c.length; ++De)
            !Ce && de.c[De].a && (Ce = de.c[De].a), ye += "<text:p>" + F(de.c[De].t) + "</text:p>";
          de.c.hidden || (ze["office:display"] = !0), xe = writextag("office:annotation", ye, ze) + xe;
        }
        K.push("          " + writextag("table:table-cell", xe, le) + `
`);
      }
      K.push(`        </table:table-row>
`);
    }
    return (U.Workbook || {}).Names && K.push(write_names_ods(U.Workbook.Names, U.SheetNames, W)), K.push(`      </table:table>
`), K.join("");
  }, O = function(D, U) {
    D.push(` <office:automatic-styles>
`);
    var W = 0;
    U.SheetNames.map(function(K) {
      return U.Sheets[K];
    }).forEach(function(K) {
      if (K && K["!cols"]) {
        for (var Z = 0; Z < K["!cols"].length; ++Z) if (K["!cols"][Z]) {
          var q = K["!cols"][Z];
          if (q.width == null && q.wpx == null && q.wch == null) continue;
          process_col(q), q.ods = W;
          var J = K["!cols"][Z].wpx + "px";
          D.push('  <style:style style:name="co' + W + `" style:family="table-column">
`), D.push('   <style:table-column-properties fo:break-before="auto" style:column-width="' + J + `"/>
`), D.push(`  </style:style>
`), ++W;
        }
      }
    });
    var X = 0;
    U.SheetNames.map(function(K) {
      return U.Sheets[K];
    }).forEach(function(K) {
      if (K && K["!rows"]) {
        for (var Z = 0; Z < K["!rows"].length; ++Z) if (K["!rows"][Z]) {
          K["!rows"][Z].ods = X;
          var q = K["!rows"][Z].hpx + "px";
          D.push('  <style:style style:name="ro' + X + `" style:family="table-row">
`), D.push('   <style:table-row-properties fo:break-before="auto" style:row-height="' + q + `"/>
`), D.push(`  </style:style>
`), ++X;
        }
      }
    }), D.push(`  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">
`), D.push(`   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>
`), D.push(`  </style:style>
`), D.push(`  <number:date-style style:name="N37" number:automatic-order="true">
`), D.push(`   <number:month number:style="long"/>
`), D.push(`   <number:text>/</number:text>
`), D.push(`   <number:day number:style="long"/>
`), D.push(`   <number:text>/</number:text>
`), D.push(`   <number:year/>
`), D.push(`  </number:date-style>
`);
    var G = {}, Y = 69;
    return U.SheetNames.map(function(K) {
      return U.Sheets[K];
    }).forEach(function(K) {
      if (K) {
        var Z = K["!data"] != null;
        if (K["!ref"])
          for (var q = decode_range(K["!ref"]), J = 0; J <= q.e.r; ++J) for (var ee = 0; ee <= q.e.c; ++ee) {
            var re = Z ? (K["!data"][J] || [])[ee] : K[encode_cell({ r: J, c: ee })];
            if (!(!re || !re.z || re.z.toLowerCase() == "general") && !G[re.z]) {
              var te = write_number_format_ods(re.z, "N" + Y);
              te && (G[re.z] = "N" + Y, ++Y, D.push(te + `
`));
            }
          }
      }
    }), D.push(`  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>
`), keys(G).forEach(function(K) {
      D.push('<style:style style:name="ce' + G[K].slice(1) + '" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="' + G[K] + `"/>
`);
    }), D.push(` </office:automatic-styles>
`), G;
  };
  return function(U, W) {
    var X = [XML_HEADER], G = wxt_helper({
      "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
      "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
      "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
      "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
      "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
      "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "xmlns:dc": "http://purl.org/dc/elements/1.1/",
      "xmlns:meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
      "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
      "xmlns:presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
      "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
      "xmlns:chart": "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
      "xmlns:dr3d": "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
      "xmlns:math": "http://www.w3.org/1998/Math/MathML",
      "xmlns:form": "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
      "xmlns:script": "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
      "xmlns:ooo": "http://openoffice.org/2004/office",
      "xmlns:ooow": "http://openoffice.org/2004/writer",
      "xmlns:oooc": "http://openoffice.org/2004/calc",
      "xmlns:dom": "http://www.w3.org/2001/xml-events",
      "xmlns:xforms": "http://www.w3.org/2002/xforms",
      "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
      "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
      "xmlns:sheet": "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
      "xmlns:rpt": "http://openoffice.org/2005/report",
      "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
      "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
      "xmlns:grddl": "http://www.w3.org/2003/g/data-view#",
      "xmlns:tableooo": "http://openoffice.org/2009/table",
      "xmlns:drawooo": "http://openoffice.org/2010/draw",
      "xmlns:calcext": "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
      "xmlns:loext": "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
      "xmlns:field": "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
      "xmlns:formx": "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
      "xmlns:css3t": "http://www.w3.org/TR/css3-text/",
      "office:version": "1.2"
    }), Y = wxt_helper({
      "xmlns:config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
      "office:mimetype": "application/vnd.oasis.opendocument.spreadsheet"
    });
    W.bookType == "fods" ? (X.push("<office:document" + G + Y + `>
`), X.push(write_meta_ods().replace(/<office:document-meta[^<>]*?>/, "").replace(/<\/office:document-meta>/, "") + `
`)) : X.push("<office:document-content" + G + `>
`);
    var K = O(X, U);
    X.push(`  <office:body>
`), X.push(`    <office:spreadsheet>
`), ((U.Workbook || {}).WBProps || {}).date1904 && X.push(`      <table:calculation-settings table:case-sensitive="false" table:search-criteria-must-apply-to-whole-cell="true" table:use-wildcards="true" table:use-regular-expressions="false" table:automatic-find-labels="false">
        <table:null-date table:date-value="1904-01-01"/>
      </table:calculation-settings>
`);
    for (var Z = 0; Z != U.SheetNames.length; ++Z) X.push(w(U.Sheets[U.SheetNames[Z]], U, Z, W, K, ((U.Workbook || {}).WBProps || {}).date1904));
    return (U.Workbook || {}).Names && X.push(write_names_ods(U.Workbook.Names, U.SheetNames, -1)), X.push(`    </office:spreadsheet>
`), X.push(`  </office:body>
`), W.bookType == "fods" ? X.push("</office:document>") : X.push("</office:document-content>"), X.join("");
  };
}();
function write_ods(F, x) {
  if (x.bookType == "fods") return write_content_ods(F, x);
  var w = zip_new(), O = "", D = [], U = [];
  return O = "mimetype", zip_add_file(w, O, "application/vnd.oasis.opendocument.spreadsheet"), O = "content.xml", zip_add_file(w, O, write_content_ods(F, x)), D.push([O, "text/xml"]), U.push([O, "ContentFile"]), O = "styles.xml", zip_add_file(w, O, write_styles_ods(F, x)), D.push([O, "text/xml"]), U.push([O, "StylesFile"]), O = "meta.xml", zip_add_file(w, O, XML_HEADER + write_meta_ods(
    /*::wb, opts*/
  )), D.push([O, "text/xml"]), U.push([O, "MetadataFile"]), O = "manifest.rdf", zip_add_file(w, O, write_rdf(
    U
    /*, opts*/
  )), D.push([O, "application/rdf+xml"]), O = "META-INF/manifest.xml", zip_add_file(w, O, write_manifest(
    D
    /*, opts*/
  )), w;
}
/*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com */
var subarray = function() {
  try {
    return typeof Uint8Array > "u" || typeof Uint8Array.prototype.subarray > "u" ? "slice" : typeof Buffer < "u" ? typeof Buffer.prototype.subarray > "u" ? "slice" : (typeof Buffer.from == "function" ? Buffer.from([72, 62]) : new Buffer([72, 62])) instanceof Uint8Array ? "subarray" : "slice" : "subarray";
  } catch {
    return "slice";
  }
}();
function u8_to_dataview(F) {
  return new DataView(F.buffer, F.byteOffset, F.byteLength);
}
function u8str(F) {
  return typeof TextDecoder < "u" ? new TextDecoder().decode(F) : utf8read(a2s(F));
}
function stru8(F) {
  return typeof TextEncoder < "u" ? new TextEncoder().encode(F) : s2a(utf8write(F));
}
function u8concat(F) {
  for (var x = 0, w = 0; w < F.length; ++w)
    x += F[w].length;
  var O = new Uint8Array(x), D = 0;
  for (w = 0; w < F.length; ++w) {
    var U = F[w], W = U.length;
    if (W < 250)
      for (var X = 0; X < W; ++X)
        O[D++] = U[X];
    else
      O.set(U, D), D += W;
  }
  return O;
}
function popcnt(F) {
  return F -= F >> 1 & 1431655765, F = (F & 858993459) + (F >> 2 & 858993459), (F + (F >> 4) & 252645135) * 16843009 >>> 24;
}
function readDecimal128LE(F, x) {
  for (var w = (F[x + 15] & 127) << 7 | F[x + 14] >> 1, O = F[x + 14] & 1, D = x + 13; D >= x; --D)
    O = O * 256 + F[D];
  return (F[x + 15] & 128 ? -O : O) * Math.pow(10, w - 6176);
}
function writeDecimal128LE(F, x, w) {
  var O = Math.floor(w == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(w))) + 6176 - 16, D = w / Math.pow(10, O - 6176);
  F[x + 15] |= O >> 7, F[x + 14] |= (O & 127) << 1;
  for (var U = 0; D >= 1; ++U, D /= 256)
    F[x + U] = D & 255;
  F[x + 15] |= w >= 0 ? 0 : 128;
}
function parse_varint49(F, x) {
  var w = x.l, O = F[w] & 127;
  e:
    if (F[w++] >= 128 && (O |= (F[w] & 127) << 7, F[w++] < 128 || (O |= (F[w] & 127) << 14, F[w++] < 128) || (O |= (F[w] & 127) << 21, F[w++] < 128) || (O += (F[w] & 127) * Math.pow(2, 28), ++w, F[w++] < 128) || (O += (F[w] & 127) * Math.pow(2, 35), ++w, F[w++] < 128) || (O += (F[w] & 127) * Math.pow(2, 42), ++w, F[w++] < 128)))
      break e;
  return x.l = w, O;
}
function write_varint49(F) {
  var x = new Uint8Array(7);
  x[0] = F & 127;
  var w = 1;
  e:
    if (F > 127) {
      if (x[w - 1] |= 128, x[w] = F >> 7 & 127, ++w, F <= 16383 || (x[w - 1] |= 128, x[w] = F >> 14 & 127, ++w, F <= 2097151) || (x[w - 1] |= 128, x[w] = F >> 21 & 127, ++w, F <= 268435455) || (x[w - 1] |= 128, x[w] = F / 256 >>> 21 & 127, ++w, F <= 34359738367) || (x[w - 1] |= 128, x[w] = F / 65536 >>> 21 & 127, ++w, F <= 4398046511103))
        break e;
      x[w - 1] |= 128, x[w] = F / 16777216 >>> 21 & 127, ++w;
    }
  return x[subarray](0, w);
}
function parse_packed_varints(F) {
  for (var x = { l: 0 }, w = []; x.l < F.length; )
    w.push(parse_varint49(F, x));
  return w;
}
function write_packed_varints(F) {
  return u8concat(F.map(function(x) {
    return write_varint49(x);
  }));
}
function varint_to_i32(F) {
  var x = 0, w = F[x] & 127;
  return F[x++] < 128 || (w |= (F[x] & 127) << 7, F[x++] < 128) || (w |= (F[x] & 127) << 14, F[x++] < 128) || (w |= (F[x] & 127) << 21, F[x++] < 128) || (w |= (F[x] & 15) << 28), w;
}
function parse_shallow(F) {
  for (var x = [], w = { l: 0 }; w.l < F.length; ) {
    var O = w.l, D = parse_varint49(F, w), U = D & 7;
    D = D / 8 | 0;
    var W, X = w.l;
    switch (U) {
      case 0:
        {
          for (; F[X++] >= 128; )
            ;
          W = F[subarray](w.l, X), w.l = X;
        }
        break;
      case 1:
        W = F[subarray](X, X + 8), w.l = X + 8;
        break;
      case 2:
        {
          var G = parse_varint49(F, w);
          W = F[subarray](w.l, w.l + G), w.l += G;
        }
        break;
      case 5:
        W = F[subarray](X, X + 4), w.l = X + 4;
        break;
      default:
        throw new Error("PB Type ".concat(U, " for Field ").concat(D, " at offset ").concat(O));
    }
    var Y = { data: W, type: U };
    x[D] == null && (x[D] = []), x[D].push(Y);
  }
  return x;
}
function write_shallow(F) {
  var x = [];
  return F.forEach(function(w, O) {
    O != 0 && w.forEach(function(D) {
      D.data && (x.push(write_varint49(O * 8 + D.type)), D.type == 2 && x.push(write_varint49(D.data.length)), x.push(D.data));
    });
  }), u8concat(x);
}
function mappa(F, x) {
  return F?.map(function(w) {
    return x(w.data);
  }) || [];
}
function parse_iwa_file(F) {
  for (var x, w = [], O = { l: 0 }; O.l < F.length; ) {
    var D = parse_varint49(F, O), U = parse_shallow(F[subarray](O.l, O.l + D));
    O.l += D;
    var W = {
      id: varint_to_i32(U[1][0].data),
      messages: []
    };
    U[2].forEach(function(X) {
      var G = parse_shallow(X.data), Y = varint_to_i32(G[3][0].data);
      W.messages.push({
        meta: G,
        data: F[subarray](O.l, O.l + Y)
      }), O.l += Y;
    }), (x = U[3]) != null && x[0] && (W.merge = varint_to_i32(U[3][0].data) >>> 0 > 0), w.push(W);
  }
  return w;
}
function write_iwa_file(F) {
  var x = [];
  return F.forEach(function(w) {
    var O = [
      [],
      [{ data: write_varint49(w.id), type: 0 }],
      []
    ];
    w.merge != null && (O[3] = [{ data: write_varint49(+!!w.merge), type: 0 }]);
    var D = [];
    w.messages.forEach(function(W) {
      D.push(W.data), W.meta[3] = [{ type: 0, data: write_varint49(W.data.length) }], O[2].push({ data: write_shallow(W.meta), type: 2 });
    });
    var U = write_shallow(O);
    x.push(write_varint49(U.length)), x.push(U), D.forEach(function(W) {
      return x.push(W);
    });
  }), u8concat(x);
}
function parse_snappy_chunk(F, x) {
  if (F != 0)
    throw new Error("Unexpected Snappy chunk type ".concat(F));
  for (var w = { l: 0 }, O = parse_varint49(x, w), D = [], U = w.l; U < x.length; ) {
    var W = x[U] & 3;
    if (W == 0) {
      var X = x[U++] >> 2;
      if (X < 60)
        ++X;
      else {
        var G = X - 59;
        X = x[U], G > 1 && (X |= x[U + 1] << 8), G > 2 && (X |= x[U + 2] << 16), G > 3 && (X |= x[U + 3] << 24), X >>>= 0, X++, U += G;
      }
      D.push(x[subarray](U, U + X)), U += X;
      continue;
    } else {
      var Y = 0, K = 0;
      if (W == 1 ? (K = (x[U] >> 2 & 7) + 4, Y = (x[U++] & 224) << 3, Y |= x[U++]) : (K = (x[U++] >> 2) + 1, W == 2 ? (Y = x[U] | x[U + 1] << 8, U += 2) : (Y = (x[U] | x[U + 1] << 8 | x[U + 2] << 16 | x[U + 3] << 24) >>> 0, U += 4)), Y == 0)
        throw new Error("Invalid offset 0");
      for (var Z = D.length - 1, q = Y; Z >= 0 && q >= D[Z].length; )
        q -= D[Z].length, --Z;
      if (Z < 0)
        if (q == 0)
          q = D[Z = 0].length;
        else
          throw new Error("Invalid offset beyond length");
      if (K < q)
        D.push(D[Z][subarray](D[Z].length - q, D[Z].length - q + K));
      else {
        for (q > 0 && (D.push(D[Z][subarray](D[Z].length - q)), K -= q), ++Z; K >= D[Z].length; )
          D.push(D[Z]), K -= D[Z].length, ++Z;
        K && D.push(D[Z][subarray](0, K));
      }
      D.length > 25 && (D = [u8concat(D)]);
    }
  }
  for (var J = 0, ee = 0; ee < D.length; ++ee)
    J += D[ee].length;
  if (J != O)
    throw new Error("Unexpected length: ".concat(J, " != ").concat(O));
  return D;
}
function decompress_iwa_file(F) {
  Array.isArray(F) && (F = new Uint8Array(F));
  for (var x = [], w = 0; w < F.length; ) {
    var O = F[w++], D = F[w] | F[w + 1] << 8 | F[w + 2] << 16;
    w += 3, x.push.apply(x, parse_snappy_chunk(O, F[subarray](w, w + D))), w += D;
  }
  if (w !== F.length)
    throw new Error("data is not a valid framed stream!");
  return x.length == 1 ? x[0] : u8concat(x);
}
function compress_iwa_file(F) {
  for (var x = [], w = 0; w < F.length; ) {
    var O = Math.min(F.length - w, 268435455), D = new Uint8Array(4);
    x.push(D);
    var U = write_varint49(O), W = U.length;
    x.push(U), O <= 60 ? (W++, x.push(new Uint8Array([O - 1 << 2]))) : O <= 256 ? (W += 2, x.push(new Uint8Array([240, O - 1 & 255]))) : O <= 65536 ? (W += 3, x.push(new Uint8Array([244, O - 1 & 255, O - 1 >> 8 & 255]))) : O <= 16777216 ? (W += 4, x.push(new Uint8Array([248, O - 1 & 255, O - 1 >> 8 & 255, O - 1 >> 16 & 255]))) : O <= 4294967296 && (W += 5, x.push(new Uint8Array([252, O - 1 & 255, O - 1 >> 8 & 255, O - 1 >> 16 & 255, O - 1 >>> 24 & 255]))), x.push(F[subarray](w, w + O)), W += O, D[0] = 0, D[1] = W & 255, D[2] = W >> 8 & 255, D[3] = W >> 16 & 255, w += O;
  }
  return u8concat(x);
}
var numbers_lut_new = function() {
  return { sst: [], rsst: [], ofmt: [], nfmt: [], fmla: [], ferr: [], cmnt: [] };
};
function numbers_format_cell(F, x, w, O, D) {
  var U, W, X, G, Y = x & 255, K = x >> 8, Z = K >= 5 ? D : O;
  e:
    if (w & (K > 4 ? 8 : 4) && F.t == "n" && Y == 7) {
      var q = (U = Z[7]) != null && U[0] ? varint_to_i32(Z[7][0].data) : -1;
      if (q == -1)
        break e;
      var J = (W = Z[15]) != null && W[0] ? varint_to_i32(Z[15][0].data) : -1, ee = (X = Z[16]) != null && X[0] ? varint_to_i32(Z[16][0].data) : -1, re = (G = Z[40]) != null && G[0] ? varint_to_i32(Z[40][0].data) : -1, te = F.v, Q = te;
      t:
        if (re) {
          if (te == 0) {
            J = ee = 2;
            break t;
          }
          te >= 604800 ? J = 1 : te >= 86400 ? J = 2 : te >= 3600 ? J = 4 : te >= 60 ? J = 8 : te >= 1 ? J = 16 : J = 32, Math.floor(te) != te ? ee = 32 : te % 60 ? ee = 16 : te % 3600 ? ee = 8 : te % 86400 ? ee = 4 : te % 604800 && (ee = 2), ee < J && (ee = J);
        }
      if (J == -1 || ee == -1)
        break e;
      var oe = [], ne = [];
      J == 1 && (Q = te / 604800, ee == 1 ? ne.push('d"d"') : (Q |= 0, te -= 604800 * Q), oe.push(Q + (q == 2 ? " week" + (Q == 1 ? "" : "s") : q == 1 ? "w" : ""))), J <= 2 && ee >= 2 && (Q = te / 86400, ee > 2 && (Q |= 0, te -= 86400 * Q), ne.push('d"d"'), oe.push(Q + (q == 2 ? " day" + (Q == 1 ? "" : "s") : q == 1 ? "d" : ""))), J <= 4 && ee >= 4 && (Q = te / 3600, ee > 4 && (Q |= 0, te -= 3600 * Q), ne.push((J >= 4 ? "[h]" : "h") + '"h"'), oe.push(Q + (q == 2 ? " hour" + (Q == 1 ? "" : "s") : q == 1 ? "h" : ""))), J <= 8 && ee >= 8 && (Q = te / 60, ee > 8 && (Q |= 0, te -= 60 * Q), ne.push((J >= 8 ? "[m]" : "m") + '"m"'), q == 0 ? oe.push((J == 8 && ee == 8 || Q >= 10 ? "" : "0") + Q) : oe.push(Q + (q == 2 ? " minute" + (Q == 1 ? "" : "s") : q == 1 ? "m" : ""))), J <= 16 && ee >= 16 && (Q = te, ee > 16 && (Q |= 0, te -= Q), ne.push((J >= 16 ? "[s]" : "s") + '"s"'), q == 0 ? oe.push((ee == 16 && J == 16 || Q >= 10 ? "" : "0") + Q) : oe.push(Q + (q == 2 ? " second" + (Q == 1 ? "" : "s") : q == 1 ? "s" : ""))), ee >= 32 && (Q = Math.round(1e3 * te), J < 32 && ne.push('.000"ms"'), q == 0 ? oe.push((Q >= 100 ? "" : Q >= 10 ? "0" : "00") + Q) : oe.push(Q + (q == 2 ? " millisecond" + (Q == 1 ? "" : "s") : q == 1 ? "ms" : ""))), F.w = oe.join(q == 0 ? ":" : " "), F.z = ne.join(q == 0 ? '":"' : " "), q == 0 && (F.w = F.w.replace(/:(\d\d\d)$/, ".$1"));
    }
}
function parse_old_storage(F, x, w, O) {
  var D = u8_to_dataview(F), U = D.getUint32(4, !0), W = -1, X = -1, G = -1, Y = NaN, K = 0, Z = new Date(Date.UTC(2001, 0, 1)), q = w > 1 ? 12 : 8;
  U & 2 && (G = D.getUint32(q, !0), q += 4), q += popcnt(U & (w > 1 ? 3468 : 396)) * 4, U & 512 && (W = D.getUint32(q, !0), q += 4), q += popcnt(U & (w > 1 ? 12288 : 4096)) * 4, U & 16 && (X = D.getUint32(q, !0), q += 4), U & 32 && (Y = D.getFloat64(q, !0), q += 8), U & 64 && (Z.setTime(Z.getTime() + (K = D.getFloat64(q, !0)) * 1e3), q += 8), w > 1 && (U = D.getUint32(8, !0) >>> 16, U & 255 && (G == -1 && (G = D.getUint32(q, !0)), q += 4));
  var J, ee = F[w >= 4 ? 1 : 2];
  switch (ee) {
    case 0:
      return;
    case 2:
      J = { t: "n", v: Y };
      break;
    case 3:
      J = { t: "s", v: x.sst[X] };
      break;
    case 5:
      O?.cellDates ? J = { t: "d", v: Z } : J = { t: "n", v: K / 86400 + 35430, z: table_fmt[14] };
      break;
    case 6:
      J = { t: "b", v: Y > 0 };
      break;
    case 7:
      J = { t: "n", v: Y };
      break;
    case 8:
      J = { t: "e", v: 0 };
      break;
    case 9:
      if (W > -1) {
        var re = x.rsst[W];
        J = { t: "s", v: re.v }, re.l && (J.l = { Target: re.l });
      } else
        throw new Error("Unsupported cell type ".concat(F[subarray](0, 4)));
      break;
    default:
      throw new Error("Unsupported cell type ".concat(F[subarray](0, 4)));
  }
  return G > -1 && numbers_format_cell(J, ee | w << 8, U, x.ofmt[G], x.nfmt[G]), ee == 7 && (J.v /= 86400), J;
}
function parse_new_storage(F, x, w) {
  var O = u8_to_dataview(F);
  O.getUint32(4, !0);
  var D = O.getUint32(8, !0), U = 12, W = -1, X = -1, G = -1, Y = NaN, K = NaN, Z = 0, q = new Date(Date.UTC(2001, 0, 1));
  D & 1 && (Y = readDecimal128LE(F, U), U += 16), D & 2 && (K = O.getFloat64(U, !0), U += 8), D & 4 && (q.setTime(q.getTime() + (Z = O.getFloat64(U, !0)) * 1e3), U += 8), D & 8 && (X = O.getUint32(U, !0), U += 4), D & 16 && (W = O.getUint32(U, !0), U += 4), U += popcnt(D & 480) * 4, D & 512 && (O.getUint32(U, !0), U += 4), U += popcnt(D & 1024) * 4, D & 2048 && (O.getUint32(U, !0), U += 4);
  var J, ee = F[1];
  switch (ee) {
    case 0:
      J = { t: "z" };
      break;
    case 2:
      J = { t: "n", v: Y };
      break;
    case 3:
      J = { t: "s", v: x.sst[X] };
      break;
    case 5:
      w?.cellDates ? J = { t: "d", v: q } : J = { t: "n", v: Z / 86400 + 35430, z: table_fmt[14] };
      break;
    case 6:
      J = { t: "b", v: K > 0 };
      break;
    case 7:
      J = { t: "n", v: K };
      break;
    case 8:
      J = { t: "e", v: 0 };
      break;
    case 9:
      if (W > -1) {
        var re = x.rsst[W];
        J = { t: "s", v: re.v }, re.l && (J.l = { Target: re.l });
      } else
        throw new Error("Unsupported cell type ".concat(F[1], " : ").concat(D & 31, " : ").concat(F[subarray](0, 4)));
      break;
    case 10:
      J = { t: "n", v: Y };
      break;
    default:
      throw new Error("Unsupported cell type ".concat(F[1], " : ").concat(D & 31, " : ").concat(F[subarray](0, 4)));
  }
  if (U += popcnt(D & 4096) * 4, D & 516096 && (G == -1 && (G = O.getUint32(U, !0)), U += 4), D & 524288) {
    var te = O.getUint32(U, !0);
    U += 4, x.cmnt[te] && (J.c = iwa_to_s5s_comment(x.cmnt[te]));
  }
  return G > -1 && numbers_format_cell(J, ee | 1280, D >> 13, x.ofmt[G], x.nfmt[G]), ee == 7 && (J.v /= 86400), J;
}
function write_new_storage(F, x) {
  var w = new Uint8Array(32), O = u8_to_dataview(w), D = 12, U = 0;
  switch (w[0] = 5, F.t) {
    case "n":
      if (F.z && fmt_is_date(F.z)) {
        w[1] = 5, O.setFloat64(D, (numdate(F.v + 1462).getTime() - Date.UTC(2001, 0, 1)) / 1e3, !0), U |= 4, D += 8;
        break;
      } else
        w[1] = 2, writeDecimal128LE(w, D, F.v), U |= 1, D += 16;
      break;
    case "b":
      w[1] = 6, O.setFloat64(D, F.v ? 1 : 0, !0), U |= 2, D += 8;
      break;
    case "s":
      {
        var W = F.v == null ? "" : String(F.v);
        if (F.l) {
          var X = x.rsst.findIndex(function(Y) {
            var K;
            return Y.v == W && Y.l == ((K = F.l) == null ? void 0 : K.Target);
          });
          X == -1 && (x.rsst[X = x.rsst.length] = { v: W, l: F.l.Target }), w[1] = 9, O.setUint32(D, X, !0), U |= 16, D += 4;
        } else {
          var G = x.sst.indexOf(W);
          G == -1 && (x.sst[G = x.sst.length] = W), w[1] = 3, O.setUint32(D, G, !0), U |= 8, D += 4;
        }
      }
      break;
    case "d":
      w[1] = 5, O.setFloat64(D, (F.v.getTime() - Date.UTC(2001, 0, 1)) / 1e3, !0), U |= 4, D += 8;
      break;
    case "z":
      w[1] = 0;
      break;
    default:
      throw "unsupported cell type " + F.t;
  }
  return F.c && (x.cmnt.push(s5s_to_iwa_comment(F.c)), O.setUint32(D, x.cmnt.length - 1, !0), U |= 524288, D += 4), O.setUint32(8, U, !0), w[subarray](0, D);
}
function write_old_storage(F, x) {
  var w = new Uint8Array(32), O = u8_to_dataview(w), D = 12, U = 0, W = "";
  switch (w[0] = 4, F.t) {
    case "n":
      break;
    case "b":
      break;
    case "s":
      if (W = F.v == null ? "" : String(F.v), F.l) {
        var X = x.rsst.findIndex(function(Y) {
          var K;
          return Y.v == W && Y.l == ((K = F.l) == null ? void 0 : K.Target);
        });
        X == -1 && (x.rsst[X = x.rsst.length] = { v: W, l: F.l.Target }), w[1] = 9, O.setUint32(D, X, !0), U |= 512, D += 4;
      }
      break;
    case "d":
      break;
    case "e":
      break;
    case "z":
      break;
    default:
      throw "unsupported cell type " + F.t;
  }
  switch (F.c && (O.setUint32(D, x.cmnt.length - 1, !0), U |= 4096, D += 4), F.t) {
    case "n":
      w[1] = 2, O.setFloat64(D, F.v, !0), U |= 32, D += 8;
      break;
    case "b":
      w[1] = 6, O.setFloat64(D, F.v ? 1 : 0, !0), U |= 32, D += 8;
      break;
    case "s":
      if (W = F.v == null ? "" : String(F.v), !F.l) {
        var G = x.sst.indexOf(W);
        G == -1 && (x.sst[G = x.sst.length] = W), w[1] = 3, O.setUint32(D, G, !0), U |= 16, D += 4;
      }
      break;
    case "d":
      w[1] = 5, O.setFloat64(D, (F.v.getTime() - Date.UTC(2001, 0, 1)) / 1e3, !0), U |= 64, D += 8;
      break;
    case "z":
      w[1] = 0;
      break;
    default:
      throw "unsupported cell type " + F.t;
  }
  return O.setUint32(8, U, !0), w[subarray](0, D);
}
function parse_cell_storage(F, x, w) {
  switch (F[0]) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return parse_old_storage(F, x, F[0], w);
    case 5:
      return parse_new_storage(F, x, w);
    default:
      throw new Error("Unsupported payload version ".concat(F[0]));
  }
}
function parse_TSP_Reference(F) {
  var x = parse_shallow(F);
  return varint_to_i32(x[1][0].data);
}
function write_TSP_Reference(F) {
  return write_shallow([
    [],
    [{ type: 0, data: write_varint49(F) }]
  ]);
}
function numbers_add_oref(F, x) {
  var w, O = (w = F.messages[0].meta[5]) != null && w[0] ? parse_packed_varints(F.messages[0].meta[5][0].data) : [], D = O.indexOf(x);
  D == -1 && (O.push(x), F.messages[0].meta[5] = [{ type: 2, data: write_packed_varints(O) }]);
}
function numbers_del_oref(F, x) {
  var w, O = (w = F.messages[0].meta[5]) != null && w[0] ? parse_packed_varints(F.messages[0].meta[5][0].data) : [];
  F.messages[0].meta[5] = [{ type: 2, data: write_packed_varints(O.filter(function(D) {
    return D != x;
  })) }];
}
function parse_TST_TableDataList(F, x) {
  var w = parse_shallow(x.data), O = varint_to_i32(w[1][0].data), D = w[3], U = [];
  return (D || []).forEach(function(W) {
    var X, G, Y = parse_shallow(W.data);
    if (Y[1]) {
      var K = varint_to_i32(Y[1][0].data) >>> 0;
      switch (O) {
        case 1:
          U[K] = u8str(Y[3][0].data);
          break;
        case 8:
          {
            var Z = F[parse_TSP_Reference(Y[9][0].data)][0], q = parse_shallow(Z.data), J = F[parse_TSP_Reference(q[1][0].data)][0], ee = varint_to_i32(J.meta[1][0].data);
            if (ee != 2001)
              throw new Error("2000 unexpected reference to ".concat(ee));
            var re = parse_shallow(J.data), te = { v: re[3].map(function(ne) {
              return u8str(ne.data);
            }).join("") };
            U[K] = te;
            e:
              if ((X = re?.[11]) != null && X[0]) {
                var Q = (G = parse_shallow(re[11][0].data)) == null ? void 0 : G[1];
                if (!Q)
                  break e;
                Q.forEach(function(ne) {
                  var le, Ee, Te, de = parse_shallow(ne.data);
                  if ((le = de[2]) != null && le[0]) {
                    var ae = F[parse_TSP_Reference((Ee = de[2]) == null ? void 0 : Ee[0].data)][0], se = varint_to_i32(ae.meta[1][0].data);
                    switch (se) {
                      case 2032:
                        var ce = parse_shallow(ae.data);
                        (Te = ce?.[2]) != null && Te[0] && !te.l && (te.l = u8str(ce[2][0].data));
                        break;
                      case 2039:
                        break;
                      default:
                        console.log("unrecognized ObjectAttribute type ".concat(se));
                    }
                  }
                });
              }
          }
          break;
        case 2:
          U[K] = parse_shallow(Y[6][0].data);
          break;
        case 3:
          U[K] = parse_shallow(Y[5][0].data);
          break;
        case 10:
          {
            var oe = F[parse_TSP_Reference(Y[10][0].data)][0];
            U[K] = parse_TSD_CommentStorageArchive(F, oe.data);
          }
          break;
        default:
          throw O;
      }
    }
  }), U;
}
function parse_TST_TileRowInfo(F, x) {
  var w, O, D, U, W, X, G, Y, K, Z, q, J, ee, re, te = parse_shallow(F), Q = varint_to_i32(te[1][0].data) >>> 0, oe = varint_to_i32(te[2][0].data) >>> 0, ne = ((O = (w = te[8]) == null ? void 0 : w[0]) == null ? void 0 : O.data) && varint_to_i32(te[8][0].data) > 0 || !1, le, Ee;
  if ((U = (D = te[7]) == null ? void 0 : D[0]) != null && U.data && x != 0)
    le = (X = (W = te[7]) == null ? void 0 : W[0]) == null ? void 0 : X.data, Ee = (Y = (G = te[6]) == null ? void 0 : G[0]) == null ? void 0 : Y.data;
  else if ((Z = (K = te[4]) == null ? void 0 : K[0]) != null && Z.data && x != 1)
    le = (J = (q = te[4]) == null ? void 0 : q[0]) == null ? void 0 : J.data, Ee = (re = (ee = te[3]) == null ? void 0 : ee[0]) == null ? void 0 : re.data;
  else
    throw "NUMBERS Tile missing ".concat(x, " cell storage");
  for (var Te = ne ? 4 : 1, de = u8_to_dataview(le), ae = [], se = 0; se < le.length / 2; ++se) {
    var ce = de.getUint16(se * 2, !0);
    ce < 65535 && ae.push([se, ce]);
  }
  if (ae.length != oe)
    throw "Expected ".concat(oe, " cells, found ").concat(ae.length);
  var xe = [];
  for (se = 0; se < ae.length - 1; ++se)
    xe[ae[se][0]] = Ee[subarray](ae[se][1] * Te, ae[se + 1][1] * Te);
  return ae.length >= 1 && (xe[ae[ae.length - 1][0]] = Ee[subarray](ae[ae.length - 1][1] * Te)), { R: Q, cells: xe };
}
function parse_TST_Tile(F, x) {
  var w, O = parse_shallow(x.data), D = -1;
  (w = O?.[7]) != null && w[0] && (varint_to_i32(O[7][0].data) >>> 0 ? D = 1 : D = 0);
  var U = mappa(O[5], function(W) {
    return parse_TST_TileRowInfo(W, D);
  });
  return {
    nrows: varint_to_i32(O[4][0].data) >>> 0,
    data: U.reduce(function(W, X) {
      return W[X.R] || (W[X.R] = []), X.cells.forEach(function(G, Y) {
        if (W[X.R][Y])
          throw new Error("Duplicate cell r=".concat(X.R, " c=").concat(Y));
        W[X.R][Y] = G;
      }), W;
    }, [])
  };
}
function parse_TSD_CommentStorageArchive(F, x) {
  var w, O, D, U, W, X, G, Y, K, Z, q = { t: "", a: "" }, J = parse_shallow(x);
  if ((O = (w = J?.[1]) == null ? void 0 : w[0]) != null && O.data && (q.t = u8str((U = (D = J?.[1]) == null ? void 0 : D[0]) == null ? void 0 : U.data) || ""), (X = (W = J?.[3]) == null ? void 0 : W[0]) != null && X.data) {
    var ee = F[parse_TSP_Reference((Y = (G = J?.[3]) == null ? void 0 : G[0]) == null ? void 0 : Y.data)][0], re = parse_shallow(ee.data);
    (Z = (K = re[1]) == null ? void 0 : K[0]) != null && Z.data && (q.a = u8str(re[1][0].data));
  }
  return J?.[4] && (q.replies = [], J[4].forEach(function(te) {
    var Q = F[parse_TSP_Reference(te.data)][0];
    q.replies.push(parse_TSD_CommentStorageArchive(F, Q.data));
  })), q;
}
function iwa_to_s5s_comment(F) {
  var x = [];
  return x.push({ t: F.t || "", a: F.a, T: F.replies && F.replies.length > 0 }), F.replies && F.replies.forEach(function(w) {
    x.push({ t: w.t || "", a: w.a, T: !0 });
  }), x;
}
function s5s_to_iwa_comment(F) {
  for (var x = { a: "", t: "", replies: [] }, w = 0; w < F.length; ++w)
    w == 0 ? (x.a = F[w].a, x.t = F[w].t) : x.replies.push({ a: F[w].a, t: F[w].t });
  return x;
}
function parse_TST_TableModelArchive(F, x, w, O) {
  var D, U, W, X, G, Y, K, Z, q, J, ee, re, te, Q, oe = parse_shallow(x.data), ne = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  if (ne.e.r = (varint_to_i32(oe[6][0].data) >>> 0) - 1, ne.e.r < 0)
    throw new Error("Invalid row varint ".concat(oe[6][0].data));
  if (ne.e.c = (varint_to_i32(oe[7][0].data) >>> 0) - 1, ne.e.c < 0)
    throw new Error("Invalid col varint ".concat(oe[7][0].data));
  w["!ref"] = encode_range(ne);
  var le = w["!data"] != null, Ee = w, Te = parse_shallow(oe[4][0].data), de = numbers_lut_new();
  (D = Te[4]) != null && D[0] && (de.sst = parse_TST_TableDataList(F, F[parse_TSP_Reference(Te[4][0].data)][0])), (U = Te[6]) != null && U[0] && (de.fmla = parse_TST_TableDataList(F, F[parse_TSP_Reference(Te[6][0].data)][0])), (W = Te[11]) != null && W[0] && (de.ofmt = parse_TST_TableDataList(F, F[parse_TSP_Reference(Te[11][0].data)][0])), (X = Te[12]) != null && X[0] && (de.ferr = parse_TST_TableDataList(F, F[parse_TSP_Reference(Te[12][0].data)][0])), (G = Te[17]) != null && G[0] && (de.rsst = parse_TST_TableDataList(F, F[parse_TSP_Reference(Te[17][0].data)][0])), (Y = Te[19]) != null && Y[0] && (de.cmnt = parse_TST_TableDataList(F, F[parse_TSP_Reference(Te[19][0].data)][0])), (K = Te[22]) != null && K[0] && (de.nfmt = parse_TST_TableDataList(F, F[parse_TSP_Reference(Te[22][0].data)][0]));
  var ae = parse_shallow(Te[3][0].data), se = 0;
  if (!((Z = Te[9]) != null && Z[0]))
    throw "NUMBERS file missing row tree";
  var ce = parse_shallow(Te[9][0].data)[1].map(function(De) {
    return parse_shallow(De.data);
  });
  if (ce.forEach(function(De) {
    se = varint_to_i32(De[1][0].data);
    var et = varint_to_i32(De[2][0].data), Oe = ae[1][et];
    if (!Oe)
      throw "NUMBERS missing tile " + et;
    var Xe = parse_shallow(Oe.data), He = F[parse_TSP_Reference(Xe[2][0].data)][0], Ae = varint_to_i32(He.meta[1][0].data);
    if (Ae != 6002)
      throw new Error("6001 unexpected reference to ".concat(Ae));
    var qe = parse_TST_Tile(F, He);
    qe.data.forEach(function(Ue, Re) {
      Ue.forEach(function(Me, je) {
        var Je = parse_cell_storage(Me, de, O);
        Je && (le ? (Ee["!data"][se + Re] || (Ee["!data"][se + Re] = []), Ee["!data"][se + Re][je] = Je) : w[encode_col(je) + encode_row(se + Re)] = Je);
      });
    }), se += qe.nrows;
  }), (q = Te[13]) != null && q[0]) {
    var xe = F[parse_TSP_Reference(Te[13][0].data)][0], Ce = varint_to_i32(xe.meta[1][0].data);
    if (Ce != 6144)
      throw new Error("Expected merge type 6144, found ".concat(Ce));
    w["!merges"] = (J = parse_shallow(xe.data)) == null ? void 0 : J[1].map(function(De) {
      var et = parse_shallow(De.data), Oe = u8_to_dataview(parse_shallow(et[1][0].data)[1][0].data), Xe = u8_to_dataview(parse_shallow(et[2][0].data)[1][0].data);
      return {
        s: { r: Oe.getUint16(0, !0), c: Oe.getUint16(2, !0) },
        e: {
          r: Oe.getUint16(0, !0) + Xe.getUint16(0, !0) - 1,
          c: Oe.getUint16(2, !0) + Xe.getUint16(2, !0) - 1
        }
      };
    });
  }
  if (!((ee = w["!merges"]) != null && ee.length) && ((re = oe[47]) != null && re[0])) {
    var ye = parse_shallow(oe[47][0].data);
    if ((te = ye[2]) != null && te[0]) {
      var ze = parse_shallow(ye[2][0].data);
      (Q = ze[3]) != null && Q[0] && (w["!merges"] = mappa(ze[3], function(De) {
        var et, Oe, Xe, He, Ae, qe = parse_shallow(De), Ue = parse_shallow(qe[2][0].data), Re = parse_shallow(Ue[1][0].data);
        if ((et = Re[1]) != null && et[0]) {
          var Me = parse_shallow(Re[1][0].data), je = varint_to_i32(Me[1][0].data);
          if (je == 67) {
            var Je = parse_shallow(Me[40][0].data);
            if (!(!((Oe = Je[3]) != null && Oe[0]) || !((Xe = Je[4]) != null && Xe[0]))) {
              var rt = parse_shallow(Je[3][0].data), fe = parse_shallow(Je[4][0].data), Se = varint_to_i32(rt[1][0].data), we = (He = rt[2]) != null && He[0] ? varint_to_i32(rt[2][0].data) : Se, me = varint_to_i32(fe[1][0].data), ke = (Ae = fe[2]) != null && Ae[0] ? varint_to_i32(fe[2][0].data) : me;
              return { s: { r: me, c: Se }, e: { r: ke, c: we } };
            }
          }
        }
      }).filter(function(De) {
        return De != null;
      }));
    }
  }
}
function parse_TST_TableInfoArchive(F, x, w) {
  var O = parse_shallow(x.data), D = { "!ref": "A1" };
  w?.dense && (D["!data"] = []);
  var U = F[parse_TSP_Reference(O[2][0].data)], W = varint_to_i32(U[0].meta[1][0].data);
  if (W != 6001)
    throw new Error("6000 unexpected reference to ".concat(W));
  return parse_TST_TableModelArchive(F, U[0], D, w), D;
}
function parse_TN_SheetArchive(F, x, w) {
  var O, D = parse_shallow(x.data), U = {
    name: (O = D[1]) != null && O[0] ? u8str(D[1][0].data) : "",
    sheets: []
  }, W = mappa(D[2], parse_TSP_Reference);
  return W.forEach(function(X) {
    F[X].forEach(function(G) {
      var Y = varint_to_i32(G.meta[1][0].data);
      Y == 6e3 && U.sheets.push(parse_TST_TableInfoArchive(F, G, w));
    });
  }), U;
}
function parse_TN_DocumentArchive(F, x, w) {
  var O, D = book_new();
  D.Workbook = { WBProps: { date1904: !0 } };
  var U = parse_shallow(x.data);
  if ((O = U[2]) != null && O[0])
    throw new Error("Keynote presentations are not supported");
  var W = mappa(U[1], parse_TSP_Reference);
  if (W.forEach(function(X) {
    F[X].forEach(function(G) {
      var Y = varint_to_i32(G.meta[1][0].data);
      if (Y == 2) {
        var K = parse_TN_SheetArchive(F, G, w);
        K.sheets.forEach(function(Z, q) {
          book_append_sheet(D, Z, q == 0 ? K.name : K.name + "_" + q, !0);
        });
      }
    });
  }), D.SheetNames.length == 0)
    throw new Error("Empty NUMBERS file");
  return D.bookType = "numbers", D;
}
function parse_numbers_iwa(F, x) {
  var w, O, D, U, W, X, G, Y = {}, K = [];
  if (F.FullPaths.forEach(function(q) {
    if (q.match(/\.iwpv2/))
      throw new Error("Unsupported password protection");
  }), F.FileIndex.forEach(function(q) {
    if (q.name.match(/\.iwa$/) && q.content[0] == 0) {
      var J;
      try {
        J = decompress_iwa_file(q.content);
      } catch (re) {
        return console.log("?? " + q.content.length + " " + (re.message || re));
      }
      var ee;
      try {
        ee = parse_iwa_file(J);
      } catch (re) {
        return console.log("## " + (re.message || re));
      }
      ee.forEach(function(re) {
        Y[re.id] = re.messages, K.push(re.id);
      });
    }
  }), !K.length)
    throw new Error("File has no messages");
  if ((D = (O = (w = Y?.[1]) == null ? void 0 : w[0].meta) == null ? void 0 : O[1]) != null && D[0].data && varint_to_i32(Y[1][0].meta[1][0].data) == 1e4)
    throw new Error("Pages documents are not supported");
  var Z = ((G = (X = (W = (U = Y?.[1]) == null ? void 0 : U[0]) == null ? void 0 : W.meta) == null ? void 0 : X[1]) == null ? void 0 : G[0].data) && varint_to_i32(Y[1][0].meta[1][0].data) == 1 && Y[1][0];
  if (Z || K.forEach(function(q) {
    Y[q].forEach(function(J) {
      var ee = varint_to_i32(J.meta[1][0].data) >>> 0;
      if (ee == 1)
        if (!Z)
          Z = J;
        else
          throw new Error("Document has multiple roots");
    });
  }), !Z)
    throw new Error("Cannot find Document root");
  return parse_TN_DocumentArchive(Y, Z, x);
}
function write_TST_TileRowInfo(F, x, w) {
  var O, D, U, W = [
    [],
    [{ type: 0, data: write_varint49(0) }],
    [{ type: 0, data: write_varint49(0) }],
    [{ type: 2, data: new Uint8Array([]) }],
    [{ type: 2, data: new Uint8Array(Array.from({ length: 510 }, function() {
      return 255;
    })) }],
    [{ type: 0, data: write_varint49(5) }],
    [{ type: 2, data: new Uint8Array([]) }],
    [{ type: 2, data: new Uint8Array(Array.from({ length: 510 }, function() {
      return 255;
    })) }],
    [{ type: 0, data: write_varint49(1) }]
  ];
  if (!((O = W[6]) != null && O[0]) || !((D = W[7]) != null && D[0]))
    throw "Mutation only works on post-BNC storages!";
  var X = 0;
  if (W[7][0].data.length < 2 * F.length) {
    var G = new Uint8Array(2 * F.length);
    G.set(W[7][0].data), W[7][0].data = G;
  }
  if (W[4][0].data.length < 2 * F.length) {
    var Y = new Uint8Array(2 * F.length);
    Y.set(W[4][0].data), W[4][0].data = Y;
  }
  for (var K = u8_to_dataview(W[7][0].data), Z = 0, q = [], J = u8_to_dataview(W[4][0].data), ee = 0, re = [], te = 4, Q = 0; Q < F.length; ++Q) {
    if (F[Q] == null || F[Q].t == "z" && !((U = F[Q].c) != null && U.length) || F[Q].t == "e") {
      K.setUint16(Q * 2, 65535, !0), J.setUint16(Q * 2, 65535);
      continue;
    }
    K.setUint16(Q * 2, Z / te, !0), J.setUint16(Q * 2, ee / te, !0);
    var oe, ne;
    switch (F[Q].t) {
      case "d":
        if (F[Q].v instanceof Date) {
          oe = write_new_storage(F[Q], x), ne = write_old_storage(F[Q], x);
          break;
        }
        oe = write_new_storage(F[Q], x), ne = write_old_storage(F[Q], x);
        break;
      case "s":
      case "n":
      case "b":
      case "z":
        oe = write_new_storage(F[Q], x), ne = write_old_storage(F[Q], x);
        break;
      default:
        throw new Error("Unsupported value " + F[Q]);
    }
    q.push(oe), Z += oe.length, re.push(ne), ee += ne.length, ++X;
  }
  for (W[2][0].data = write_varint49(X), W[5][0].data = write_varint49(5); Q < W[7][0].data.length / 2; ++Q)
    K.setUint16(Q * 2, 65535, !0), J.setUint16(Q * 2, 65535, !0);
  return W[6][0].data = u8concat(q), W[3][0].data = u8concat(re), W[8] = [{ type: 0, data: write_varint49(1) }], W;
}
function write_iwam(F, x) {
  return {
    meta: [
      [],
      [{ type: 0, data: write_varint49(F) }]
    ],
    data: x
  };
}
function get_unique_msgid(F, x) {
  x.last || (x.last = 927262);
  for (var w = x.last; w < 2e6; ++w)
    if (!x[w])
      return x[x.last = w] = F, w;
  throw new Error("Too many messages");
}
function build_numbers_deps(F) {
  var x = {}, w = [];
  return F.FileIndex.map(function(O, D) {
    return [O, F.FullPaths[D]];
  }).forEach(function(O) {
    var D = O[0], U = O[1];
    D.type == 2 && D.name.match(/\.iwa/) && D.content[0] == 0 && parse_iwa_file(decompress_iwa_file(D.content)).forEach(function(W) {
      w.push(W.id), x[W.id] = { deps: [], location: U, type: varint_to_i32(W.messages[0].meta[1][0].data) };
    });
  }), F.FileIndex.forEach(function(O) {
    O.name.match(/\.iwa/) && O.content[0] == 0 && parse_iwa_file(decompress_iwa_file(O.content)).forEach(function(D) {
      D.messages.forEach(function(U) {
        [5, 6].forEach(function(W) {
          U.meta[W] && U.meta[W].forEach(function(X) {
            x[D.id].deps.push(varint_to_i32(X.data));
          });
        });
      });
    });
  }), x;
}
function write_TSP_Color_RGB(F, x, w) {
  return write_shallow([
    [],
    [{ type: 0, data: write_varint49(1) }],
    [],
    [{ type: 5, data: new Uint8Array(Float32Array.from([F / 255]).buffer) }],
    [{ type: 5, data: new Uint8Array(Float32Array.from([x / 255]).buffer) }],
    [{ type: 5, data: new Uint8Array(Float32Array.from([w / 255]).buffer) }],
    [{ type: 5, data: new Uint8Array(Float32Array.from([1]).buffer) }],
    [],
    [],
    [],
    [],
    [],
    [{ type: 0, data: write_varint49(1) }]
  ]);
}
function get_author_color(F) {
  switch (F) {
    case 0:
      return write_TSP_Color_RGB(99, 222, 171);
    case 1:
      return write_TSP_Color_RGB(162, 197, 240);
    case 2:
      return write_TSP_Color_RGB(255, 189, 189);
  }
  return write_TSP_Color_RGB(Math.random() * 255, Math.random() * 255, Math.random() * 255);
}
function write_numbers_iwa(F, x) {
  if (!x || !x.numbers)
    throw new Error("Must pass a `numbers` option -- check the README");
  var w = CFB.read(x.numbers, { type: "base64" }), O = build_numbers_deps(w), D = numbers_iwa_find(w, O, 1);
  if (D == null)
    throw "Could not find message ".concat(1, " in Numbers template");
  var U = mappa(parse_shallow(D.messages[0].data)[1], parse_TSP_Reference);
  if (U.length > 1)
    throw new Error("Template NUMBERS file must have exactly one sheet");
  return F.SheetNames.forEach(function(W, X) {
    X >= 1 && (numbers_add_ws(w, O, X + 1), D = numbers_iwa_find(w, O, 1), U = mappa(parse_shallow(D.messages[0].data)[1], parse_TSP_Reference)), write_numbers_ws(w, O, F.Sheets[W], W, X, U[X]);
  }), w;
}
function numbers_iwa_doit(F, x, w, O) {
  var D = CFB.find(F, x[w].location);
  if (!D)
    throw "Could not find ".concat(x[w].location, " in Numbers template");
  var U = parse_iwa_file(decompress_iwa_file(D.content)), W = U.find(function(X) {
    return X.id == w;
  });
  O(W, U), D.content = compress_iwa_file(write_iwa_file(U)), D.size = D.content.length;
}
function numbers_iwa_find(F, x, w) {
  var O = CFB.find(F, x[w].location);
  if (!O)
    throw "Could not find ".concat(x[w].location, " in Numbers template");
  var D = parse_iwa_file(decompress_iwa_file(O.content)), U = D.find(function(W) {
    return W.id == w;
  });
  return U;
}
function numbers_add_meta(F, x, w) {
  F[3].push({ type: 2, data: write_shallow([
    [],
    [{ type: 0, data: write_varint49(x) }],
    [{ type: 2, data: stru8(w.replace(/-[\s\S]*$/, "")) }],
    [{ type: 2, data: stru8(w) }],
    [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
    [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
    [],
    [],
    [],
    [],
    [{ type: 0, data: write_varint49(0) }],
    [],
    [{ type: 0, data: write_varint49(0) }]
  ]) }), F[1] = [{ type: 0, data: write_varint49(Math.max(x + 1, varint_to_i32(F[1][0].data))) }];
}
function numbers_add_msg(F, x, w, O, D, U) {
  U || (U = get_unique_msgid({ deps: [], location: "", type: x }, D));
  var W = "".concat(O, "-").concat(U, ".iwa");
  D[U].location = "Root Entry" + W, CFB.utils.cfb_add(F, W, compress_iwa_file(write_iwa_file([{
    id: U,
    messages: [write_iwam(x, write_shallow(w))]
  }])));
  var X = W.replace(/^[\/]/, "").replace(/^Index\//, "").replace(/\.iwa$/, "");
  return numbers_iwa_doit(F, D, 2, function(G) {
    var Y = parse_shallow(G.messages[0].data);
    numbers_add_meta(Y, U || 0, X), G.messages[0].data = write_shallow(Y);
  }), U;
}
function numbers_meta_add_dep(F, x, w, O) {
  var D = x[w].location.replace(/^Root Entry\//, "").replace(/^Index\//, "").replace(/\.iwa$/, ""), U = F[3].findIndex(function(X) {
    var G, Y, K = parse_shallow(X.data);
    return (G = K[3]) != null && G[0] ? u8str(K[3][0].data) == D : !!((Y = K[2]) != null && Y[0] && u8str(K[2][0].data) == D);
  }), W = parse_shallow(F[3][U].data);
  W[6] || (W[6] = []), (Array.isArray(O) ? O : [O]).forEach(function(X) {
    W[6].push({
      type: 2,
      data: write_shallow([
        [],
        [{ type: 0, data: write_varint49(X) }]
      ])
    });
  }), F[3][U].data = write_shallow(W);
}
function numbers_meta_del_dep(F, x, w, O) {
  var D = x[w].location.replace(/^Root Entry\//, "").replace(/^Index\//, "").replace(/\.iwa$/, ""), U = F[3].findIndex(function(X) {
    var G, Y, K = parse_shallow(X.data);
    return (G = K[3]) != null && G[0] ? u8str(K[3][0].data) == D : !!((Y = K[2]) != null && Y[0] && u8str(K[2][0].data) == D);
  }), W = parse_shallow(F[3][U].data);
  W[6] || (W[6] = []), W[6] = W[6].filter(function(X) {
    return varint_to_i32(parse_shallow(X.data)[1][0].data) != O;
  }), F[3][U].data = write_shallow(W);
}
function numbers_add_ws(F, x, w) {
  var O = -1, D = -1, U = {};
  numbers_iwa_doit(F, x, 1, function(G, Y) {
    var K = parse_shallow(G.messages[0].data);
    O = parse_TSP_Reference(parse_shallow(G.messages[0].data)[1][0].data), D = get_unique_msgid({ deps: [1], location: x[O].location, type: 2 }, x), U[O] = D, numbers_add_oref(G, D), K[1].push({ type: 2, data: write_TSP_Reference(D) });
    var Z = numbers_iwa_find(F, x, O);
    Z.id = D, x[1].location == x[D].location ? Y.push(Z) : numbers_iwa_doit(F, x, D, function(q, J) {
      return J.push(Z);
    }), G.messages[0].data = write_shallow(K);
  });
  var W = -1;
  numbers_iwa_doit(F, x, D, function(G, Y) {
    for (var K = parse_shallow(G.messages[0].data), Z = 3; Z <= 69; ++Z)
      delete K[Z];
    var q = mappa(K[2], parse_TSP_Reference);
    q.forEach(function(ee) {
      return numbers_del_oref(G, ee);
    }), W = get_unique_msgid({ deps: [D], location: x[q[0]].location, type: x[q[0]].type }, x), numbers_add_oref(G, W), U[q[0]] = W, K[2] = [{ type: 2, data: write_TSP_Reference(W) }];
    var J = numbers_iwa_find(F, x, q[0]);
    J.id = W, x[q[0]].location == x[D].location ? Y.push(J) : (numbers_iwa_doit(F, x, 2, function(ee) {
      var re = parse_shallow(ee.messages[0].data);
      numbers_meta_add_dep(re, x, D, W), ee.messages[0].data = write_shallow(re);
    }), numbers_iwa_doit(F, x, W, function(ee, re) {
      return re.push(J);
    })), G.messages[0].data = write_shallow(K);
  });
  var X = -1;
  numbers_iwa_doit(F, x, W, function(G, Y) {
    for (var K = parse_shallow(G.messages[0].data), Z = parse_shallow(K[1][0].data), q = 3; q <= 69; ++q)
      delete Z[q];
    var J = parse_TSP_Reference(Z[2][0].data);
    Z[2][0].data = write_TSP_Reference(U[J]), K[1][0].data = write_shallow(Z);
    var ee = parse_TSP_Reference(K[2][0].data);
    numbers_del_oref(G, ee), X = get_unique_msgid({ deps: [W], location: x[ee].location, type: x[ee].type }, x), numbers_add_oref(G, X), U[ee] = X, K[2][0].data = write_TSP_Reference(X);
    var re = numbers_iwa_find(F, x, ee);
    re.id = X, x[W].location == x[X].location ? Y.push(re) : numbers_iwa_doit(F, x, X, function(te, Q) {
      return Q.push(re);
    }), G.messages[0].data = write_shallow(K);
  }), numbers_iwa_doit(F, x, X, function(G, Y) {
    var K, Z, q = parse_shallow(G.messages[0].data), J = u8str(q[1][0].data), ee = J.replace(/-[A-Z0-9]*/, "-".concat(("0000" + w.toString(16)).slice(-4)));
    if (q[1][0].data = stru8(ee), [12, 13, 29, 31, 32, 33, 39, 44, 47, 81, 82, 84].forEach(function(Ee) {
      return delete q[Ee];
    }), q[45]) {
      var re = parse_shallow(q[45][0].data), te = parse_TSP_Reference(re[1][0].data);
      numbers_del_oref(G, te), delete q[45];
    }
    if (q[70]) {
      var Q = parse_shallow(q[70][0].data);
      (K = Q[2]) == null || K.forEach(function(Ee) {
        var Te = parse_shallow(Ee.data);
        [2, 3].map(function(de) {
          return Te[de][0];
        }).forEach(function(de) {
          var ae = parse_shallow(de.data);
          if (ae[8]) {
            var se = parse_TSP_Reference(ae[8][0].data);
            numbers_del_oref(G, se);
          }
        });
      }), delete q[70];
    }
    [
      46,
      30,
      34,
      35,
      36,
      38,
      48,
      49,
      60,
      61,
      62,
      63,
      64,
      71,
      72,
      73,
      74,
      75,
      85,
      86,
      87,
      88,
      89
    ].forEach(function(Ee) {
      if (q[Ee]) {
        var Te = parse_TSP_Reference(q[Ee][0].data);
        delete q[Ee], numbers_del_oref(G, Te);
      }
    });
    var oe = parse_shallow(q[4][0].data);
    {
      [2, 4, 5, 6, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22].forEach(function(Ee) {
        var Te;
        if ((Te = oe[Ee]) != null && Te[0]) {
          var de = parse_TSP_Reference(oe[Ee][0].data), ae = get_unique_msgid({ deps: [X], location: x[de].location, type: x[de].type }, x);
          numbers_del_oref(G, de), numbers_add_oref(G, ae), U[de] = ae;
          var se = numbers_iwa_find(F, x, de);
          if (se.id = ae, x[de].location == x[X].location)
            Y.push(se);
          else {
            x[ae].location = x[de].location.replace(de.toString(), ae.toString()), x[ae].location == x[de].location && (x[ae].location = x[ae].location.replace(/\.iwa/, "-".concat(ae, ".iwa"))), CFB.utils.cfb_add(F, x[ae].location, compress_iwa_file(write_iwa_file([se])));
            var ce = x[ae].location.replace(/^Root Entry\//, "").replace(/^Index\//, "").replace(/\.iwa$/, "");
            numbers_iwa_doit(F, x, 2, function(xe) {
              var Ce = parse_shallow(xe.messages[0].data);
              numbers_add_meta(Ce, ae, ce), numbers_meta_add_dep(Ce, x, X, ae), xe.messages[0].data = write_shallow(Ce);
            });
          }
          oe[Ee][0].data = write_TSP_Reference(ae);
        }
      });
      var ne = parse_shallow(oe[1][0].data);
      (Z = ne[2]) == null || Z.forEach(function(Ee) {
        var Te = parse_TSP_Reference(Ee.data), de = get_unique_msgid({ deps: [X], location: x[Te].location, type: x[Te].type }, x);
        numbers_del_oref(G, Te), numbers_add_oref(G, de), U[Te] = de;
        var ae = numbers_iwa_find(F, x, Te);
        if (ae.id = de, x[Te].location == x[X].location)
          Y.push(ae);
        else {
          x[de].location = x[Te].location.replace(Te.toString(), de.toString()), x[de].location == x[Te].location && (x[de].location = x[de].location.replace(/\.iwa/, "-".concat(de, ".iwa"))), CFB.utils.cfb_add(F, x[de].location, compress_iwa_file(write_iwa_file([ae])));
          var se = x[de].location.replace(/^Root Entry\//, "").replace(/^Index\//, "").replace(/\.iwa$/, "");
          numbers_iwa_doit(F, x, 2, function(ce) {
            var xe = parse_shallow(ce.messages[0].data);
            numbers_add_meta(xe, de, se), numbers_meta_add_dep(xe, x, X, de), ce.messages[0].data = write_shallow(xe);
          });
        }
        Ee.data = write_TSP_Reference(de);
      }), oe[1][0].data = write_shallow(ne);
      var le = parse_shallow(oe[3][0].data);
      le[1].forEach(function(Ee) {
        var Te = parse_shallow(Ee.data), de = parse_TSP_Reference(Te[2][0].data), ae = U[de];
        if (!U[de]) {
          ae = get_unique_msgid({ deps: [X], location: "", type: x[de].type }, x), x[ae].location = "Root Entry/Index/Tables/Tile-".concat(ae, ".iwa"), U[de] = ae;
          var se = numbers_iwa_find(F, x, de);
          se.id = ae, numbers_del_oref(G, de), numbers_add_oref(G, ae), CFB.utils.cfb_add(F, "/Index/Tables/Tile-".concat(ae, ".iwa"), compress_iwa_file(write_iwa_file([se]))), numbers_iwa_doit(F, x, 2, function(ce) {
            var xe = parse_shallow(ce.messages[0].data);
            xe[3].push({ type: 2, data: write_shallow([
              [],
              [{ type: 0, data: write_varint49(ae) }],
              [{ type: 2, data: stru8("Tables/Tile") }],
              [{ type: 2, data: stru8("Tables/Tile-".concat(ae)) }],
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
              [],
              [],
              [],
              [],
              [{ type: 0, data: write_varint49(0) }],
              [],
              [{ type: 0, data: write_varint49(0) }]
            ]) }), xe[1] = [{ type: 0, data: write_varint49(Math.max(ae + 1, varint_to_i32(xe[1][0].data))) }], numbers_meta_add_dep(xe, x, X, ae), ce.messages[0].data = write_shallow(xe);
          });
        }
        Te[2][0].data = write_TSP_Reference(ae), Ee.data = write_shallow(Te);
      }), oe[3][0].data = write_shallow(le);
    }
    q[4][0].data = write_shallow(oe), G.messages[0].data = write_shallow(q);
  });
}
function write_numbers_ws(F, x, w, O, D, U) {
  var W = [];
  numbers_iwa_doit(F, x, U, function(Y) {
    var K = parse_shallow(Y.messages[0].data);
    K[1] = [{ type: 2, data: stru8(O) }], W = mappa(K[2], parse_TSP_Reference), Y.messages[0].data = write_shallow(K);
  });
  var X = numbers_iwa_find(F, x, W[0]), G = parse_TSP_Reference(parse_shallow(X.messages[0].data)[2][0].data);
  numbers_iwa_doit(F, x, G, function(Y, K) {
    return write_numbers_tma(F, x, w, Y, K, G);
  });
}
function write_numbers_tma(F, x, w, O, D, U) {
  if (!w["!ref"])
    throw new Error("Cannot export empty sheet to NUMBERS");
  var W = decode_range(w["!ref"]);
  W.s.r = W.s.c = 0;
  var X = !1;
  W.e.c > 999 && (X = !0, W.e.c = 999), W.e.r > 999999 && (X = !0, W.e.r = 999999), X && console.error("Truncating to ".concat(encode_range(W)));
  var G = [];
  if (w["!data"])
    G = w["!data"];
  else {
    for (var Y = [], K = 0; K <= W.e.c; ++K)
      Y[K] = encode_col(K);
    for (var Z = 0; Z <= W.e.r; ++Z) {
      G[Z] = [];
      var q = "" + (Z + 1);
      for (K = 0; K <= W.e.c; ++K) {
        var J = w[Y[K] + q];
        J && (G[Z][K] = J);
      }
    }
  }
  var ee = {
    cmnt: [{ a: "~54ee77S~", t: "... the people who are crazy enough to think they can change the world, are the ones who do." }],
    ferr: [],
    fmla: [],
    nfmt: [],
    ofmt: [],
    rsst: [{ v: "~54ee77S~", l: "https://sheetjs.com/" }],
    sst: ["~Sh33tJ5~"]
  }, re = parse_shallow(O.messages[0].data);
  {
    re[6][0].data = write_varint49(W.e.r + 1), re[7][0].data = write_varint49(W.e.c + 1), delete re[46];
    var te = parse_shallow(re[4][0].data);
    {
      var Q = parse_TSP_Reference(parse_shallow(te[1][0].data)[2][0].data);
      numbers_iwa_doit(F, x, Q, function(Ue, Re) {
        var Me, je = parse_shallow(Ue.messages[0].data);
        if ((Me = je?.[2]) != null && Me[0])
          for (var Je = 0; Je < G.length; ++Je) {
            var rt = parse_shallow(je[2][0].data);
            rt[1][0].data = write_varint49(Je), rt[4][0].data = write_varint49(G[Je].length), je[2][Je] = { type: je[2][0].type, data: write_shallow(rt) };
          }
        Ue.messages[0].data = write_shallow(je);
      });
      var oe = parse_TSP_Reference(te[2][0].data);
      numbers_iwa_doit(F, x, oe, function(Ue, Re) {
        for (var Me = parse_shallow(Ue.messages[0].data), je = 0; je <= W.e.c; ++je) {
          var Je = parse_shallow(Me[2][0].data);
          Je[1][0].data = write_varint49(je), Je[4][0].data = write_varint49(W.e.r + 1), Me[2][je] = { type: Me[2][0].type, data: write_shallow(Je) };
        }
        Ue.messages[0].data = write_shallow(Me);
      });
      var ne = parse_shallow(te[9][0].data);
      ne[1] = [];
      var le = parse_shallow(te[3][0].data);
      {
        var Ee = 256;
        le[2] = [{ type: 0, data: write_varint49(Ee) }];
        var Te = parse_TSP_Reference(parse_shallow(le[1][0].data)[2][0].data), de = function() {
          var Ue = numbers_iwa_find(F, x, 2), Re = parse_shallow(Ue.messages[0].data), Me = Re[3].filter(function(je) {
            return varint_to_i32(parse_shallow(je.data)[1][0].data) == Te;
          });
          return Me?.length ? varint_to_i32(parse_shallow(Me[0].data)[12][0].data) : 0;
        }();
        CFB.utils.cfb_del(F, x[Te].location), numbers_iwa_doit(F, x, 2, function(Ue) {
          var Re = parse_shallow(Ue.messages[0].data);
          Re[3] = Re[3].filter(function(Me) {
            return varint_to_i32(parse_shallow(Me.data)[1][0].data) != Te;
          }), numbers_meta_del_dep(Re, x, U, Te), Ue.messages[0].data = write_shallow(Re);
        }), numbers_del_oref(O, Te), le[1] = [];
        for (var ae = Math.ceil((W.e.r + 1) / Ee), se = 0; se < ae; ++se) {
          var ce = get_unique_msgid({
            deps: [],
            location: "",
            type: 6002
          }, x);
          x[ce].location = "Root Entry/Index/Tables/Tile-".concat(ce, ".iwa");
          for (var xe = [
            [],
            [{ type: 0, data: write_varint49(0) }],
            [{ type: 0, data: write_varint49(Math.min(W.e.r + 1, (se + 1) * Ee)) }],
            [{ type: 0, data: write_varint49(0) }],
            [{ type: 0, data: write_varint49(Math.min((se + 1) * Ee, W.e.r + 1) - se * Ee) }],
            [],
            [{ type: 0, data: write_varint49(5) }],
            [{ type: 0, data: write_varint49(1) }],
            [{ type: 0, data: write_varint49(1) }]
          ], Ce = se * Ee; Ce <= Math.min(W.e.r, (se + 1) * Ee - 1); ++Ce) {
            var ye = write_TST_TileRowInfo(G[Ce], ee);
            ye[1][0].data = write_varint49(Ce - se * Ee), xe[5].push({ data: write_shallow(ye), type: 2 });
          }
          le[1].push({ type: 2, data: write_shallow([
            [],
            [{ type: 0, data: write_varint49(se) }],
            [{ type: 2, data: write_TSP_Reference(ce) }]
          ]) });
          var ze = {
            id: ce,
            messages: [write_iwam(6002, write_shallow(xe))]
          }, De = compress_iwa_file(write_iwa_file([ze]));
          CFB.utils.cfb_add(F, "/Index/Tables/Tile-".concat(ce, ".iwa"), De), numbers_iwa_doit(F, x, 2, function(Ue) {
            var Re = parse_shallow(Ue.messages[0].data);
            Re[3].push({ type: 2, data: write_shallow([
              [],
              [{ type: 0, data: write_varint49(ce) }],
              [{ type: 2, data: stru8("Tables/Tile") }],
              [{ type: 2, data: stru8("Tables/Tile-".concat(ce)) }],
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
              [],
              [],
              [],
              [],
              [{ type: 0, data: write_varint49(0) }],
              [],
              [{ type: 0, data: write_varint49(de) }]
            ]) }), Re[1] = [{ type: 0, data: write_varint49(Math.max(ce + 1, varint_to_i32(Re[1][0].data))) }], numbers_meta_add_dep(Re, x, U, ce), Ue.messages[0].data = write_shallow(Re);
          }), numbers_add_oref(O, ce), ne[1].push({ type: 2, data: write_shallow([
            [],
            [{ type: 0, data: write_varint49(se * Ee) }],
            [{ type: 0, data: write_varint49(se) }]
          ]) });
        }
      }
      if (te[3][0].data = write_shallow(le), te[9][0].data = write_shallow(ne), te[10] = [{ type: 2, data: new Uint8Array([]) }], w["!merges"]) {
        var et = get_unique_msgid({
          type: 6144,
          deps: [U],
          location: x[U].location
        }, x);
        D.push({
          id: et,
          messages: [write_iwam(6144, write_shallow([
            [],
            w["!merges"].map(function(Ue) {
              return { type: 2, data: write_shallow([
                [],
                [{ type: 2, data: write_shallow([
                  [],
                  [{ type: 5, data: new Uint8Array(new Uint16Array([Ue.s.r, Ue.s.c]).buffer) }]
                ]) }],
                [{ type: 2, data: write_shallow([
                  [],
                  [{ type: 5, data: new Uint8Array(new Uint16Array([Ue.e.r - Ue.s.r + 1, Ue.e.c - Ue.s.c + 1]).buffer) }]
                ]) }]
              ]) };
            })
          ]))]
        }), te[13] = [{ type: 2, data: write_TSP_Reference(et) }], numbers_iwa_doit(F, x, 2, function(Ue) {
          var Re = parse_shallow(Ue.messages[0].data);
          numbers_meta_add_dep(Re, x, U, et), Ue.messages[0].data = write_shallow(Re);
        }), numbers_add_oref(O, et);
      } else
        delete te[13];
      var Oe = parse_TSP_Reference(te[4][0].data);
      numbers_iwa_doit(F, x, Oe, function(Ue) {
        var Re = parse_shallow(Ue.messages[0].data);
        Re[3] = [], ee.sst.forEach(function(Me, je) {
          je != 0 && Re[3].push({ type: 2, data: write_shallow([
            [],
            [{ type: 0, data: write_varint49(je) }],
            [{ type: 0, data: write_varint49(1) }],
            [{ type: 2, data: stru8(Me) }]
          ]) });
        }), Ue.messages[0].data = write_shallow(Re);
      });
      var Xe = parse_TSP_Reference(te[17][0].data);
      if (numbers_iwa_doit(F, x, Xe, function(Ue) {
        var Re = parse_shallow(Ue.messages[0].data);
        Re[3] = [];
        var Me = [
          904980,
          903835,
          903815,
          903845
        ];
        ee.rsst.forEach(function(je, Je) {
          if (Je != 0) {
            var rt = [
              [],
              [{ type: 0, data: new Uint8Array([5]) }],
              [],
              [{ type: 2, data: stru8(je.v) }]
            ];
            rt[10] = [{ type: 0, data: new Uint8Array([1]) }], rt[19] = [{ type: 2, data: new Uint8Array([10, 6, 8, 0, 18, 2, 101, 110]) }], rt[5] = [{ type: 2, data: new Uint8Array([10, 8, 8, 0, 18, 4, 8, 155, 149, 55]) }], rt[2] = [{ type: 2, data: new Uint8Array([8, 148, 158, 55]) }], rt[6] = [{ type: 2, data: new Uint8Array([10, 6, 8, 0, 16, 0, 24, 0]) }], rt[7] = [{ type: 2, data: new Uint8Array([10, 8, 8, 0, 18, 4, 8, 135, 149, 55]) }], rt[8] = [{ type: 2, data: new Uint8Array([10, 8, 8, 0, 18, 4, 8, 165, 149, 55]) }], rt[14] = [{ type: 2, data: new Uint8Array([10, 6, 8, 0, 16, 0, 24, 0]) }], rt[24] = [{ type: 2, data: new Uint8Array([10, 6, 8, 0, 16, 0, 24, 0]) }];
            var fe = get_unique_msgid({ deps: [], location: "", type: 2001 }, x), Se = [];
            if (je.l) {
              var we = numbers_add_msg(F, 2032, [
                [],
                [],
                [{ type: 2, data: stru8(je.l) }]
              ], "/Index/Tables/DataList", x);
              rt[11] = [];
              var me = [[], []];
              me[1] || (me[1] = []), me[1].push({ type: 2, data: write_shallow([
                [],
                [{ type: 0, data: write_varint49(0) }],
                [{ type: 2, data: write_TSP_Reference(we) }]
              ]) }), rt[11][0] = { type: 2, data: write_shallow(me) }, Se.push(we);
            }
            numbers_add_msg(F, 2001, rt, "/Index/Tables/DataList", x, fe), numbers_iwa_doit(F, x, fe, function(ue) {
              Me.forEach(function(We) {
                return numbers_add_oref(ue, We);
              }), Se.forEach(function(We) {
                return numbers_add_oref(ue, We);
              });
            });
            var ke = numbers_add_msg(F, 6218, [
              [],
              [{ type: 2, data: write_TSP_Reference(fe) }],
              [],
              [{ type: 2, data: new Uint8Array([13, 255, 255, 255, 0, 18, 10, 16, 255, 255, 1, 24, 255, 255, 255, 255, 7]) }]
            ], "/Index/Tables/DataList", x);
            numbers_iwa_doit(F, x, ke, function(ue) {
              return numbers_add_oref(ue, fe);
            }), Re[3].push({ type: 2, data: write_shallow([
              [],
              [{ type: 0, data: write_varint49(Je) }],
              [{ type: 0, data: write_varint49(1) }],
              [],
              [],
              [],
              [],
              [],
              [],
              [{ type: 2, data: write_TSP_Reference(ke) }]
            ]) }), numbers_add_oref(Ue, ke), numbers_iwa_doit(F, x, 2, function(ue) {
              var We = parse_shallow(ue.messages[0].data);
              numbers_meta_add_dep(We, x, Xe, ke), numbers_meta_add_dep(We, x, ke, fe), numbers_meta_add_dep(We, x, fe, Se), numbers_meta_add_dep(We, x, fe, Me), ue.messages[0].data = write_shallow(We);
            });
          }
        }), Ue.messages[0].data = write_shallow(Re);
      }), ee.cmnt.length > 1) {
        var He = parse_TSP_Reference(te[19][0].data), Ae = {}, qe = 0;
        numbers_iwa_doit(F, x, He, function(Ue) {
          var Re = parse_shallow(Ue.messages[0].data);
          Re[3] = [], ee.cmnt.forEach(function(Me, je) {
            if (je != 0) {
              var Je = [];
              Me.replies && Me.replies.forEach(function(Se) {
                Ae[Se.a || ""] || (Ae[Se.a || ""] = numbers_add_msg(F, 212, [
                  [],
                  [{ type: 2, data: stru8(Se.a || "") }],
                  [{ type: 2, data: get_author_color(++qe) }],
                  [],
                  [{ type: 0, data: write_varint49(0) }]
                ], "/Index/Tables/DataList", x));
                var we = Ae[Se.a || ""], me = numbers_add_msg(F, 3056, [
                  [],
                  [{ type: 2, data: stru8(Se.t || "") }],
                  [{ type: 2, data: write_shallow([
                    [],
                    [{ type: 1, data: new Uint8Array([0, 0, 0, 128, 116, 109, 182, 65]) }]
                  ]) }],
                  [{ type: 2, data: write_TSP_Reference(we) }]
                ], "/Index/Tables/DataList", x);
                numbers_iwa_doit(F, x, me, function(ke) {
                  return numbers_add_oref(ke, we);
                }), Je.push(me), numbers_iwa_doit(F, x, 2, function(ke) {
                  var ue = parse_shallow(ke.messages[0].data);
                  numbers_meta_add_dep(ue, x, me, we), ke.messages[0].data = write_shallow(ue);
                });
              }), Ae[Me.a || ""] || (Ae[Me.a || ""] = numbers_add_msg(F, 212, [
                [],
                [{ type: 2, data: stru8(Me.a || "") }],
                [{ type: 2, data: get_author_color(++qe) }],
                [],
                [{ type: 0, data: write_varint49(0) }]
              ], "/Index/Tables/DataList", x));
              var rt = Ae[Me.a || ""], fe = numbers_add_msg(F, 3056, [
                [],
                [{ type: 2, data: stru8(Me.t || "") }],
                [{ type: 2, data: write_shallow([
                  [],
                  [{ type: 1, data: new Uint8Array([0, 0, 0, 128, 116, 109, 182, 65]) }]
                ]) }],
                [{ type: 2, data: write_TSP_Reference(rt) }],
                Je.map(function(Se) {
                  return { type: 2, data: write_TSP_Reference(Se) };
                }),
                [{ type: 2, data: write_shallow([
                  [],
                  [{ type: 0, data: write_varint49(je) }],
                  [{ type: 0, data: write_varint49(0) }]
                ]) }]
              ], "/Index/Tables/DataList", x);
              numbers_iwa_doit(F, x, fe, function(Se) {
                numbers_add_oref(Se, rt), Je.forEach(function(we) {
                  return numbers_add_oref(Se, we);
                });
              }), Re[3].push({ type: 2, data: write_shallow([
                [],
                [{ type: 0, data: write_varint49(je) }],
                [{ type: 0, data: write_varint49(1) }],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [{ type: 2, data: write_TSP_Reference(fe) }]
              ]) }), numbers_add_oref(Ue, fe), numbers_iwa_doit(F, x, 2, function(Se) {
                var we = parse_shallow(Se.messages[0].data);
                numbers_meta_add_dep(we, x, He, fe), numbers_meta_add_dep(we, x, fe, rt), Je.length && numbers_meta_add_dep(we, x, fe, Je), Se.messages[0].data = write_shallow(we);
              });
            }
          }), Re[2][0].data = write_varint49(ee.cmnt.length + 1), Ue.messages[0].data = write_shallow(Re);
        });
      }
    }
    re[4][0].data = write_shallow(te);
  }
  O.messages[0].data = write_shallow(re);
}
function fix_opts_func(F) {
  return function(w) {
    for (var O = 0; O != F.length; ++O) {
      var D = F[O];
      w[D[0]] === void 0 && (w[D[0]] = D[1]), D[2] === "n" && (w[D[0]] = Number(w[D[0]]));
    }
  };
}
function fix_read_opts(F) {
  fix_opts_func([
    ["cellNF", !1],
    /* emit cell number format string as .z */
    ["cellHTML", !0],
    /* emit html string as .h */
    ["cellFormula", !0],
    /* emit formulae as .f */
    ["cellStyles", !1],
    /* emits style/theme as .s */
    ["cellText", !0],
    /* emit formatted text as .w */
    ["cellDates", !1],
    /* emit date cells with type `d` */
    ["sheetStubs", !1],
    /* emit empty cells */
    ["sheetRows", 0, "n"],
    /* read n rows (0 = read all rows) */
    ["bookDeps", !1],
    /* parse calculation chains */
    ["bookSheets", !1],
    /* only try to get sheet names (no Sheets) */
    ["bookProps", !1],
    /* only try to get properties (no Sheets) */
    ["bookFiles", !1],
    /* include raw file structure (keys, files, cfb) */
    ["bookVBA", !1],
    /* include vba raw data (vbaraw) */
    ["password", ""],
    /* password */
    ["WTF", !1]
    /* WTF mode (throws errors) */
  ])(F);
}
function fix_write_opts(F) {
  fix_opts_func([
    ["cellDates", !1],
    /* write date cells with type `d` */
    ["bookSST", !1],
    /* Generate Shared String Table */
    ["bookType", "xlsx"],
    /* Type of workbook (xlsx/m/b) */
    ["compression", !1],
    /* Use file compression */
    ["WTF", !1]
    /* WTF mode (throws errors) */
  ])(F);
}
function get_sheet_type(F) {
  return RELS.WS.indexOf(F) > -1 ? "sheet" : F == RELS.CS ? "chart" : F == RELS.DS ? "dialog" : F == RELS.MS ? "macro" : F && F.length ? F : "sheet";
}
function safe_parse_wbrels(F, x) {
  if (!F) return 0;
  try {
    F = x.map(function(O) {
      return O.id || (O.id = O.strRelID), [O.name, F["!id"][O.id].Target, get_sheet_type(F["!id"][O.id].Type)];
    });
  } catch {
    return null;
  }
  return !F || F.length === 0 ? null : F;
}
function parse_sheet_legacy_drawing(F, x, w, O, D, U, W, X) {
  if (!(!F || !F["!legdrawel"])) {
    var G = resolve_path(F["!legdrawel"].Target, O), Y = getzipstr(w, G, !0);
    Y && parse_vml(utf8read(Y), F, X || []);
  }
}
function safe_parse_sheet(F, x, w, O, D, U, W, X, G, Y, K, Z) {
  try {
    U[O] = parse_rels(getzipstr(F, w, !0), x);
    var q = getzipdata(F, x), J;
    switch (X) {
      case "sheet":
        J = parse_ws(q, x, D, G, U[O], Y, K, Z);
        break;
      case "chart":
        if (J = parse_cs(q, x, D, G, U[O], Y, K, Z), !J || !J["!drawel"]) break;
        var ee = resolve_path(J["!drawel"].Target, x), re = get_rels_path(ee), te = parse_drawing(getzipstr(F, ee, !0), parse_rels(getzipstr(F, re, !0), ee)), Q = resolve_path(te, ee), oe = get_rels_path(Q);
        J = parse_chart(getzipstr(F, Q, !0), Q, G, parse_rels(getzipstr(F, oe, !0), Q), Y, J);
        break;
      case "macro":
        J = parse_ms(q, x, D, G, U[O], Y, K, Z);
        break;
      case "dialog":
        J = parse_ds(q, x, D, G, U[O], Y, K, Z);
        break;
      default:
        throw new Error("Unrecognized sheet type " + X);
    }
    W[O] = J;
    var ne = [], le = [];
    U && U[O] && keys(U[O]).forEach(function(Ee) {
      var Te = "";
      if (U[O][Ee].Type == RELS.CMNT) {
        if (Te = resolve_path(U[O][Ee].Target, x), ne = parse_cmnt(getzipdata(F, Te, !0), Te, G), !ne || !ne.length) return;
        sheet_insert_comments(J, ne, !1);
      }
      U[O][Ee].Type == RELS.TCMNT && (Te = resolve_path(U[O][Ee].Target, x), le = le.concat(parse_tcmnt_xml(getzipdata(F, Te, !0), G)));
    }), le && le.length && sheet_insert_comments(J, le, !0, G.people || []), parse_sheet_legacy_drawing(J, X, F, x, D, G, Y, ne);
  } catch (Ee) {
    if (G.WTF) throw Ee;
  }
}
function strip_front_slash(F) {
  return F.charAt(0) == "/" ? F.slice(1) : F;
}
function parse_zip(F, x) {
  if (make_ssf(), x = x || {}, fix_read_opts(x), safegetzipfile(F, "META-INF/manifest.xml") || safegetzipfile(F, "objectdata.xml")) return parse_ods(F, x);
  if (safegetzipfile(F, "Index/Document.iwa")) {
    if (typeof Uint8Array > "u") throw new Error("NUMBERS file parsing requires Uint8Array support");
    if (typeof parse_numbers_iwa < "u") {
      if (F.FileIndex) return parse_numbers_iwa(F, x);
      var w = CFB.utils.cfb_new();
      return zipentries(F).forEach(function(De) {
        zip_add_file(w, De, getzipbin(F, De));
      }), parse_numbers_iwa(w, x);
    }
    throw new Error("Unsupported NUMBERS file");
  }
  if (!safegetzipfile(F, "[Content_Types].xml")) {
    if (safegetzipfile(F, "index.xml.gz")) throw new Error("Unsupported NUMBERS 08 file");
    if (safegetzipfile(F, "index.xml")) throw new Error("Unsupported NUMBERS 09 file");
    var O = CFB.find(F, "Index.zip");
    if (O)
      return x = dup(x), delete x.type, typeof O.content == "string" && (x.type = "binary"), typeof Bun < "u" && Buffer.isBuffer(O.content) ? readSync(new Uint8Array(O.content), x) : readSync(O.content, x);
    throw new Error("Unsupported ZIP file");
  }
  var D = zipentries(F), U = parse_ct(getzipstr(F, "[Content_Types].xml")), W = !1, X, G;
  if (U.workbooks.length === 0 && (G = "xl/workbook.xml", getzipdata(F, G, !0) && U.workbooks.push(G)), U.workbooks.length === 0) {
    if (G = "xl/workbook.bin", !getzipdata(F, G, !0)) throw new Error("Could not find workbook");
    U.workbooks.push(G), W = !0;
  }
  U.workbooks[0].slice(-3) == "bin" && (W = !0);
  var Y = {}, K = {};
  if (!x.bookSheets && !x.bookProps) {
    if (strs = [], U.sst) try {
      strs = parse_sst(getzipdata(F, strip_front_slash(U.sst)), U.sst, x);
    } catch (De) {
      if (x.WTF) throw De;
    }
    x.cellStyles && U.themes.length && (Y = parse_theme_xml(getzipstr(F, U.themes[0].replace(/^\//, ""), !0) || "", x)), U.style && (K = parse_sty(getzipdata(F, strip_front_slash(U.style)), U.style, Y, x));
  }
  U.links.map(function(De) {
    try {
      var et = parse_rels(getzipstr(F, get_rels_path(strip_front_slash(De))), De);
      return parse_xlink(getzipdata(F, strip_front_slash(De)), et, De, x);
    } catch {
    }
  });
  var Z = parse_wb(getzipdata(F, strip_front_slash(U.workbooks[0])), U.workbooks[0], x), q = {}, J = "";
  U.coreprops.length && (J = getzipdata(F, strip_front_slash(U.coreprops[0]), !0), J && (q = parse_core_props(J)), U.extprops.length !== 0 && (J = getzipdata(F, strip_front_slash(U.extprops[0]), !0), J && parse_ext_props(J, q, x)));
  var ee = {};
  (!x.bookSheets || x.bookProps) && U.custprops.length !== 0 && (J = getzipstr(F, strip_front_slash(U.custprops[0]), !0), J && (ee = parse_cust_props(J, x)));
  var re = {};
  if ((x.bookSheets || x.bookProps) && (Z.Sheets ? X = Z.Sheets.map(function(et) {
    return et.name;
  }) : q.Worksheets && q.SheetNames.length > 0 && (X = q.SheetNames), x.bookProps && (re.Props = q, re.Custprops = ee), x.bookSheets && typeof X < "u" && (re.SheetNames = X), x.bookSheets ? re.SheetNames : x.bookProps))
    return re;
  X = {};
  var te = {};
  x.bookDeps && U.calcchain && (te = parse_cc(getzipdata(F, strip_front_slash(U.calcchain)), U.calcchain));
  var Q = 0, oe = {}, ne, le;
  {
    var Ee = Z.Sheets;
    q.Worksheets = Ee.length, q.SheetNames = [];
    for (var Te = 0; Te != Ee.length; ++Te)
      q.SheetNames[Te] = Ee[Te].name;
  }
  var de = W ? "bin" : "xml", ae = U.workbooks[0].lastIndexOf("/"), se = (U.workbooks[0].slice(0, ae + 1) + "_rels/" + U.workbooks[0].slice(ae + 1) + ".rels").replace(/^\//, "");
  safegetzipfile(F, se) || (se = "xl/_rels/workbook." + de + ".rels");
  var ce = parse_rels(getzipstr(F, se, !0), se.replace(/_rels.*/, "s5s"));
  (U.metadata || []).length >= 1 && (x.xlmeta = parse_xlmeta(getzipdata(F, strip_front_slash(U.metadata[0])), U.metadata[0], x)), (U.people || []).length >= 1 && (x.people = parse_people_xml(getzipdata(F, strip_front_slash(U.people[0])), x)), ce && (ce = safe_parse_wbrels(ce, Z.Sheets));
  var xe = getzipdata(F, "xl/worksheets/sheet.xml", !0) ? 1 : 0;
  e: for (Q = 0; Q != q.Worksheets; ++Q) {
    var Ce = "sheet";
    if (ce && ce[Q] ? (ne = "xl/" + ce[Q][1].replace(/[\/]?xl\//, ""), safegetzipfile(F, ne) || (ne = ce[Q][1]), safegetzipfile(F, ne) || (ne = se.replace(/_rels\/[\S\s]*$/, "") + ce[Q][1]), Ce = ce[Q][2]) : (ne = "xl/worksheets/sheet" + (Q + 1 - xe) + "." + de, ne = ne.replace(/sheet0\./, "sheet.")), le = ne.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels"), x && x.sheets != null) switch (typeof x.sheets) {
      case "number":
        if (Q != x.sheets) continue e;
        break;
      case "string":
        if (q.SheetNames[Q].toLowerCase() != x.sheets.toLowerCase()) continue e;
        break;
      default:
        if (Array.isArray && Array.isArray(x.sheets)) {
          for (var ye = !1, ze = 0; ze != x.sheets.length; ++ze)
            typeof x.sheets[ze] == "number" && x.sheets[ze] == Q && (ye = 1), typeof x.sheets[ze] == "string" && x.sheets[ze].toLowerCase() == q.SheetNames[Q].toLowerCase() && (ye = 1);
          if (!ye) continue e;
        }
    }
    safe_parse_sheet(F, ne, le, q.SheetNames[Q], Q, oe, X, Ce, x, Z, Y, K);
  }
  return re = {
    Directory: U,
    Workbook: Z,
    Props: q,
    Custprops: ee,
    Deps: te,
    Sheets: X,
    SheetNames: q.SheetNames,
    Strings: strs,
    Styles: K,
    Themes: Y,
    SSF: dup(table_fmt)
  }, x && x.bookFiles && (F.files ? (re.keys = D, re.files = F.files) : (re.keys = [], re.files = {}, F.FullPaths.forEach(function(De, et) {
    De = De.replace(/^Root Entry[\/]/, ""), re.keys.push(De), re.files[De] = F.FileIndex[et];
  }))), x && x.bookVBA && (U.vba.length > 0 ? re.vbaraw = getzipdata(F, strip_front_slash(U.vba[0]), !0) : U.defaults && U.defaults.bin === CT_VBA && (re.vbaraw = getzipdata(F, "xl/vbaProject.bin", !0))), re.bookType = W ? "xlsb" : "xlsx", re;
}
function parse_xlsxcfb(F, x) {
  var w = x || {}, O = "Workbook", D = CFB.find(F, O);
  try {
    if (O = "/!DataSpaces/Version", D = CFB.find(F, O), !D || !D.content) throw new Error("ECMA-376 Encrypted file missing " + O);
    if (parse_DataSpaceVersionInfo(D.content), O = "/!DataSpaces/DataSpaceMap", D = CFB.find(F, O), !D || !D.content) throw new Error("ECMA-376 Encrypted file missing " + O);
    var U = parse_DataSpaceMap(D.content);
    if (U.length !== 1 || U[0].comps.length !== 1 || U[0].comps[0].t !== 0 || U[0].name !== "StrongEncryptionDataSpace" || U[0].comps[0].v !== "EncryptedPackage")
      throw new Error("ECMA-376 Encrypted file bad " + O);
    if (O = "/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace", D = CFB.find(F, O), !D || !D.content) throw new Error("ECMA-376 Encrypted file missing " + O);
    var W = parse_DataSpaceDefinition(D.content);
    if (W.length != 1 || W[0] != "StrongEncryptionTransform")
      throw new Error("ECMA-376 Encrypted file bad " + O);
    if (O = "/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary", D = CFB.find(F, O), !D || !D.content) throw new Error("ECMA-376 Encrypted file missing " + O);
    parse_Primary(D.content);
  } catch {
  }
  if (O = "/EncryptionInfo", D = CFB.find(F, O), !D || !D.content) throw new Error("ECMA-376 Encrypted file missing " + O);
  var X = parse_EncryptionInfo(D.content);
  if (O = "/EncryptedPackage", D = CFB.find(F, O), !D || !D.content) throw new Error("ECMA-376 Encrypted file missing " + O);
  if (X[0] == 4 && typeof decrypt_agile < "u") return decrypt_agile(X[1], D.content, w.password || "", w);
  if (X[0] == 2 && typeof decrypt_std76 < "u") return decrypt_std76(X[1], D.content, w.password || "", w);
  throw new Error("File is password-protected");
}
function write_zip_xlsb(F, x) {
  F && !F.SSF && (F.SSF = dup(table_fmt)), F && F.SSF && (make_ssf(), SSF_load_table(F.SSF), x.revssf = evert_num(F.SSF), x.revssf[F.SSF[65535]] = 0, x.ssf = F.SSF), x.rels = {}, x.wbrels = {}, x.Strings = /*::((*/
  [], x.Strings.Count = 0, x.Strings.Unique = 0, browser_has_Map ? x.revStrings = /* @__PURE__ */ new Map() : (x.revStrings = {}, x.revStrings.foo = [], delete x.revStrings.foo);
  var w = "bin", O = !0, D = new_ct();
  fix_write_opts(x = x || {});
  var U = zip_new(), W = "", X = 0;
  if (x.cellXfs = [], get_cell_style(x.cellXfs, {}, { revssf: { General: 0 } }), F.Props || (F.Props = {}), W = "docProps/core.xml", zip_add_file(U, W, write_core_props(F.Props, x)), D.coreprops.push(W), add_rels(x.rels, 2, W, RELS.CORE_PROPS), W = "docProps/app.xml", !(F.Props && F.Props.SheetNames)) if (!F.Workbook || !F.Workbook.Sheets) F.Props.SheetNames = F.SheetNames;
  else {
    for (var G = [], Y = 0; Y < F.SheetNames.length; ++Y)
      (F.Workbook.Sheets[Y] || {}).Hidden != 2 && G.push(F.SheetNames[Y]);
    F.Props.SheetNames = G;
  }
  F.Props.Worksheets = F.Props.SheetNames.length, zip_add_file(U, W, write_ext_props(F.Props)), D.extprops.push(W), add_rels(x.rels, 3, W, RELS.EXT_PROPS), F.Custprops !== F.Props && keys(F.Custprops || {}).length > 0 && (W = "docProps/custom.xml", zip_add_file(U, W, write_cust_props(F.Custprops)), D.custprops.push(W), add_rels(x.rels, 4, W, RELS.CUST_PROPS));
  var K = ["SheetJ5"];
  for (x.tcid = 0, X = 1; X <= F.SheetNames.length; ++X) {
    var Z = { "!id": {} }, q = F.Sheets[F.SheetNames[X - 1]], J = (q || {})["!type"] || "sheet";
    switch (J) {
      case "chart":
      /* falls through */
      default:
        W = "xl/worksheets/sheet" + X + "." + w, zip_add_file(U, W, write_ws_bin(X - 1, x, F, Z)), D.sheets.push(W), add_rels(x.wbrels, -1, "worksheets/sheet" + X + "." + w, RELS.WS[0]);
    }
    if (q) {
      var ee = q["!comments"], re = !1, te = "";
      if (ee && ee.length > 0) {
        var Q = !1;
        ee.forEach(function(ne) {
          ne[1].forEach(function(le) {
            le.T == !0 && (Q = !0);
          });
        }), Q && (te = "xl/threadedComments/threadedComment" + X + ".xml", zip_add_file(U, te, write_tcmnt_xml(ee, K, x)), D.threadedcomments.push(te), add_rels(Z, -1, "../threadedComments/threadedComment" + X + ".xml", RELS.TCMNT)), te = "xl/comments" + X + "." + w, zip_add_file(U, te, write_comments_bin(ee)), D.comments.push(te), add_rels(Z, -1, "../comments" + X + "." + w, RELS.CMNT), re = !0;
      }
      q["!legacy"] && re && zip_add_file(U, "xl/drawings/vmlDrawing" + X + ".vml", write_vml(X, q["!comments"])), delete q["!comments"], delete q["!legacy"];
    }
    Z["!id"].rId1 && zip_add_file(U, get_rels_path(W), write_rels(Z));
  }
  x.Strings != null && x.Strings.length > 0 && (W = "xl/sharedStrings." + w, zip_add_file(U, W, write_sst_bin(x.Strings)), D.strs.push(W), add_rels(x.wbrels, -1, "sharedStrings." + w, RELS.SST)), W = "xl/workbook." + w, zip_add_file(U, W, write_wb_bin(F)), D.workbooks.push(W), add_rels(x.rels, 1, W, RELS.WB), W = "xl/theme/theme1.xml";
  var oe = write_theme(F.Themes, x);
  return zip_add_file(U, W, oe), D.themes.push(W), add_rels(x.wbrels, -1, "theme/theme1.xml", RELS.THEME), W = "xl/styles." + w, zip_add_file(U, W, write_sty_bin(F, x)), D.styles.push(W), add_rels(x.wbrels, -1, "styles." + w, RELS.STY), F.vbaraw && O && (W = "xl/vbaProject.bin", zip_add_file(U, W, F.vbaraw), D.vba.push(W), add_rels(x.wbrels, -1, "vbaProject.bin", RELS.VBA)), W = "xl/metadata." + w, zip_add_file(U, W, write_xlmeta_bin()), D.metadata.push(W), add_rels(x.wbrels, -1, "metadata." + w, RELS.XLMETA), K.length > 1 && (W = "xl/persons/person.xml", zip_add_file(U, W, write_people_xml(K)), D.people.push(W), add_rels(x.wbrels, -1, "persons/person.xml", RELS.PEOPLE)), zip_add_file(U, "[Content_Types].xml", write_ct(D, x)), zip_add_file(U, "_rels/.rels", write_rels(x.rels)), zip_add_file(U, "xl/_rels/workbook." + w + ".rels", write_rels(x.wbrels)), delete x.revssf, delete x.ssf, U;
}
function write_zip_xlsx(F, x) {
  F && !F.SSF && (F.SSF = dup(table_fmt)), F && F.SSF && (make_ssf(), SSF_load_table(F.SSF), x.revssf = evert_num(F.SSF), x.revssf[F.SSF[65535]] = 0, x.ssf = F.SSF), x.rels = {}, x.wbrels = {}, x.Strings = /*::((*/
  [], x.Strings.Count = 0, x.Strings.Unique = 0, browser_has_Map ? x.revStrings = /* @__PURE__ */ new Map() : (x.revStrings = {}, x.revStrings.foo = [], delete x.revStrings.foo);
  var w = "xml", O = VBAFMTS.indexOf(x.bookType) > -1, D = new_ct();
  fix_write_opts(x = x || {});
  var U = zip_new(), W = "", X = 0;
  if (x.cellXfs = [], get_cell_style(x.cellXfs, {}, { revssf: { General: 0 } }), F.Props || (F.Props = {}), W = "docProps/core.xml", zip_add_file(U, W, write_core_props(F.Props, x)), D.coreprops.push(W), add_rels(x.rels, 2, W, RELS.CORE_PROPS), W = "docProps/app.xml", !(F.Props && F.Props.SheetNames)) if (!F.Workbook || !F.Workbook.Sheets) F.Props.SheetNames = F.SheetNames;
  else {
    for (var G = [], Y = 0; Y < F.SheetNames.length; ++Y)
      (F.Workbook.Sheets[Y] || {}).Hidden != 2 && G.push(F.SheetNames[Y]);
    F.Props.SheetNames = G;
  }
  F.Props.Worksheets = F.Props.SheetNames.length, zip_add_file(U, W, write_ext_props(F.Props)), D.extprops.push(W), add_rels(x.rels, 3, W, RELS.EXT_PROPS), F.Custprops !== F.Props && keys(F.Custprops || {}).length > 0 && (W = "docProps/custom.xml", zip_add_file(U, W, write_cust_props(F.Custprops)), D.custprops.push(W), add_rels(x.rels, 4, W, RELS.CUST_PROPS));
  var K = ["SheetJ5"];
  for (x.tcid = 0, X = 1; X <= F.SheetNames.length; ++X) {
    var Z = { "!id": {} }, q = F.Sheets[F.SheetNames[X - 1]], J = (q || {})["!type"] || "sheet";
    switch (J) {
      case "chart":
      /* falls through */
      default:
        W = "xl/worksheets/sheet" + X + "." + w, zip_add_file(U, W, write_ws_xml(X - 1, x, F, Z)), D.sheets.push(W), add_rels(x.wbrels, -1, "worksheets/sheet" + X + "." + w, RELS.WS[0]);
    }
    if (q) {
      var ee = q["!comments"], re = !1, te = "";
      if (ee && ee.length > 0) {
        var Q = !1;
        ee.forEach(function(oe) {
          oe[1].forEach(function(ne) {
            ne.T == !0 && (Q = !0);
          });
        }), Q && (te = "xl/threadedComments/threadedComment" + X + ".xml", zip_add_file(U, te, write_tcmnt_xml(ee, K, x)), D.threadedcomments.push(te), add_rels(Z, -1, "../threadedComments/threadedComment" + X + ".xml", RELS.TCMNT)), te = "xl/comments" + X + "." + w, zip_add_file(U, te, write_comments_xml(ee)), D.comments.push(te), add_rels(Z, -1, "../comments" + X + "." + w, RELS.CMNT), re = !0;
      }
      q["!legacy"] && re && zip_add_file(U, "xl/drawings/vmlDrawing" + X + ".vml", write_vml(X, q["!comments"])), delete q["!comments"], delete q["!legacy"];
    }
    Z["!id"].rId1 && zip_add_file(U, get_rels_path(W), write_rels(Z));
  }
  return x.Strings != null && x.Strings.length > 0 && (W = "xl/sharedStrings." + w, zip_add_file(U, W, write_sst_xml(x.Strings, x)), D.strs.push(W), add_rels(x.wbrels, -1, "sharedStrings." + w, RELS.SST)), W = "xl/workbook." + w, zip_add_file(U, W, write_wb_xml(F)), D.workbooks.push(W), add_rels(x.rels, 1, W, RELS.WB), W = "xl/theme/theme1.xml", zip_add_file(U, W, write_theme(F.Themes, x)), D.themes.push(W), add_rels(x.wbrels, -1, "theme/theme1.xml", RELS.THEME), W = "xl/styles." + w, zip_add_file(U, W, write_sty_xml(F, x)), D.styles.push(W), add_rels(x.wbrels, -1, "styles." + w, RELS.STY), F.vbaraw && O && (W = "xl/vbaProject.bin", zip_add_file(U, W, F.vbaraw), D.vba.push(W), add_rels(x.wbrels, -1, "vbaProject.bin", RELS.VBA)), W = "xl/metadata." + w, zip_add_file(U, W, write_xlmeta_xml()), D.metadata.push(W), add_rels(x.wbrels, -1, "metadata." + w, RELS.XLMETA), K.length > 1 && (W = "xl/persons/person.xml", zip_add_file(U, W, write_people_xml(K)), D.people.push(W), add_rels(x.wbrels, -1, "persons/person.xml", RELS.PEOPLE)), zip_add_file(U, "[Content_Types].xml", write_ct(D, x)), zip_add_file(U, "_rels/.rels", write_rels(x.rels)), zip_add_file(U, "xl/_rels/workbook." + w + ".rels", write_rels(x.wbrels)), delete x.revssf, delete x.ssf, U;
}
function firstbyte(F, x) {
  var w = "";
  switch ((x || {}).type || "base64") {
    case "buffer":
      return [F[0], F[1], F[2], F[3], F[4], F[5], F[6], F[7]];
    case "base64":
      w = Base64_decode(F.slice(0, 12));
      break;
    case "binary":
      w = F;
      break;
    case "array":
      return [F[0], F[1], F[2], F[3], F[4], F[5], F[6], F[7]];
    default:
      throw new Error("Unrecognized type " + (x && x.type || "undefined"));
  }
  return [w.charCodeAt(0), w.charCodeAt(1), w.charCodeAt(2), w.charCodeAt(3), w.charCodeAt(4), w.charCodeAt(5), w.charCodeAt(6), w.charCodeAt(7)];
}
function read_cfb(F, x) {
  return CFB.find(F, "EncryptedPackage") ? parse_xlsxcfb(F, x) : parse_xlscfb(F, x);
}
function read_zip(F, x) {
  var w, O = F, D = x || {};
  return D.type || (D.type = has_buf && Buffer.isBuffer(F) ? "buffer" : "base64"), w = zip_read(O, D), parse_zip(w, D);
}
function read_plaintext(F, x) {
  var w = 0;
  e: for (; w < F.length; ) switch (F.charCodeAt(w)) {
    case 10:
    case 13:
    case 32:
      ++w;
      break;
    case 60:
      return parse_xlml(F.slice(w), x);
    default:
      break e;
  }
  return PRN.to_workbook(F, x);
}
function read_plaintext_raw(F, x) {
  var w = "", O = firstbyte(F, x);
  switch (x.type) {
    case "base64":
      w = Base64_decode(F);
      break;
    case "binary":
      w = F;
      break;
    case "buffer":
      w = F.toString("binary");
      break;
    case "array":
      w = cc2str(F);
      break;
    default:
      throw new Error("Unrecognized type " + x.type);
  }
  return O[0] == 239 && O[1] == 187 && O[2] == 191 && (w = utf8read(w)), x.type = "binary", read_plaintext(w, x);
}
function read_utf16(F, x) {
  var w = F;
  return x.type == "base64" && (w = Base64_decode(w)), typeof ArrayBuffer < "u" && F instanceof ArrayBuffer && (w = new Uint8Array(F)), w = typeof $cptable < "u" ? $cptable.utils.decode(1200, w.slice(2), "str") : has_buf && Buffer.isBuffer(F) ? F.slice(2).toString("utf16le") : typeof Uint8Array < "u" && w instanceof Uint8Array ? typeof TextDecoder < "u" ? new TextDecoder("utf-16le").decode(w.slice(2)) : utf16lereadu(w.slice(2)) : utf16leread(w.slice(2)), x.type = "binary", read_plaintext(w, x);
}
function bstrify(F) {
  return F.match(/[^\x00-\x7F]/) ? utf8write(F) : F;
}
function read_prn(F, x, w, O) {
  return O ? (w.type = "string", PRN.to_workbook(F, w)) : PRN.to_workbook(x, w);
}
function readSync(F, x) {
  reset_cp();
  var w = x || {};
  if (w.codepage && typeof $cptable > "u" && console.error("Codepage tables are not loaded.  Non-ASCII characters may not give expected results"), typeof ArrayBuffer < "u" && F instanceof ArrayBuffer) return readSync(new Uint8Array(F), (w = dup(w), w.type = "array", w));
  if (typeof Int8Array < "u" && F instanceof Int8Array) return readSync(new Uint8Array(F.buffer, F.byteOffset, F.length), w);
  typeof Uint8Array < "u" && F instanceof Uint8Array && !w.type && (w.type = typeof Deno < "u" ? "buffer" : "array");
  var O = F, D = [0, 0, 0, 0], U = !1;
  if (w.cellStyles && (w.cellNF = !0, w.sheetStubs = !0), _ssfopts = {}, w.dateNF && (_ssfopts.dateNF = w.dateNF), w.type || (w.type = has_buf && Buffer.isBuffer(F) ? "buffer" : "base64"), w.type == "file" && (w.type = has_buf ? "buffer" : "binary", O = read_binary(F), typeof Uint8Array < "u" && !has_buf && (w.type = "array")), w.type == "string" && (U = !0, w.type = "binary", w.codepage = 65001, O = bstrify(F)), w.type == "array" && typeof Uint8Array < "u" && F instanceof Uint8Array && typeof ArrayBuffer < "u") {
    var W = new ArrayBuffer(3), X = new Uint8Array(W);
    if (X.foo = "bar", !X.foo)
      return w = dup(w), w.type = "array", readSync(ab2a(O), w);
  }
  switch ((D = firstbyte(O, w))[0]) {
    case 208:
      if (D[1] === 207 && D[2] === 17 && D[3] === 224 && D[4] === 161 && D[5] === 177 && D[6] === 26 && D[7] === 225) return read_cfb(CFB.read(O, w), w);
      break;
    case 9:
      if (D[1] <= 8) return parse_xlscfb(O, w);
      break;
    case 60:
      return parse_xlml(O, w);
    case 73:
      if (D[1] === 73 && D[2] === 42 && D[3] === 0) throw new Error("TIFF Image File is not a spreadsheet");
      if (D[1] === 68) return read_wb_ID(O, w);
      break;
    case 84:
      if (D[1] === 65 && D[2] === 66 && D[3] === 76) return DIF.to_workbook(O, w);
      break;
    case 80:
      return D[1] === 75 && D[2] < 9 && D[3] < 9 ? read_zip(O, w) : read_prn(F, O, w, U);
    case 239:
      return D[3] === 60 ? parse_xlml(O, w) : read_prn(F, O, w, U);
    case 255:
      if (D[1] === 254)
        return read_utf16(O, w);
      if (D[1] === 0 && D[2] === 2 && D[3] === 0) return WK_.to_workbook(O, w);
      break;
    case 0:
      if (D[1] === 0 && (D[2] >= 2 && D[3] === 0 || D[2] === 0 && (D[3] === 8 || D[3] === 9)))
        return WK_.to_workbook(O, w);
      break;
    case 3:
    case 131:
    case 139:
    case 140:
      return DBF.to_workbook(O, w);
    case 123:
      if (D[1] === 92 && D[2] === 114 && D[3] === 116) return rtf_to_workbook(O, w);
      break;
    case 10:
    case 13:
    case 32:
      return read_plaintext_raw(O, w);
    case 137:
      if (D[1] === 80 && D[2] === 78 && D[3] === 71) throw new Error("PNG Image File is not a spreadsheet");
      break;
    case 8:
      if (D[1] === 231) throw new Error("Unsupported Multiplan 1.x file!");
      break;
    case 12:
      if (D[1] === 236) throw new Error("Unsupported Multiplan 2.x file!");
      if (D[1] === 237) throw new Error("Unsupported Multiplan 3.x file!");
      break;
  }
  return DBF_SUPPORTED_VERSIONS.indexOf(D[0]) > -1 && D[2] <= 12 && D[3] <= 31 ? DBF.to_workbook(O, w) : read_prn(F, O, w, U);
}
function readFileSync(F, x) {
  var w = x || {};
  return w.type = "file", readSync(F, w);
}
function write_cfb_ctr(F, x) {
  switch (x.type) {
    case "base64":
    case "binary":
      break;
    case "buffer":
    case "array":
      x.type = "";
      break;
    case "file":
      return write_dl(x.file, CFB.write(F, { type: has_buf ? "buffer" : "" }));
    case "string":
      throw new Error("'string' output type invalid for '" + x.bookType + "' files");
    default:
      throw new Error("Unrecognized type " + x.type);
  }
  return CFB.write(F, x);
}
function write_zip(F, x) {
  switch (x.bookType) {
    case "ods":
      return write_ods(F, x);
    case "numbers":
      return write_numbers_iwa(F, x);
    case "xlsb":
      return write_zip_xlsb(F, x);
    default:
      return write_zip_xlsx(F, x);
  }
}
function write_zip_type(F, x) {
  var w = dup(x || {}), O = write_zip(F, w);
  return write_zip_denouement(O, w);
}
function write_zip_typeXLSX(F, x) {
  var w = dup(x || {}), O = write_zip_xlsx(F, w);
  return write_zip_denouement(O, w);
}
function write_zip_denouement(F, x) {
  var w = {}, O = has_buf ? "nodebuffer" : typeof Uint8Array < "u" ? "array" : "string";
  if (x.compression && (w.compression = "DEFLATE"), x.password) w.type = O;
  else switch (x.type) {
    case "base64":
      w.type = "base64";
      break;
    case "binary":
      w.type = "string";
      break;
    case "string":
      throw new Error("'string' output type invalid for '" + x.bookType + "' files");
    case "buffer":
    case "file":
      w.type = O;
      break;
    default:
      throw new Error("Unrecognized type " + x.type);
  }
  var D = F.FullPaths ? CFB.write(F, { fileType: "zip", type: (
    /*::(*/
    { nodebuffer: "buffer", string: "binary" }[w.type] || w.type
  ), compression: !!x.compression }) : F.generate(w);
  if (typeof Deno < "u" && typeof D == "string") {
    if (x.type == "binary" || x.type == "base64") return D;
    D = new Uint8Array(s2ab(D));
  }
  return x.password && typeof encrypt_agile < "u" ? write_cfb_ctr(encrypt_agile(D, x.password), x) : x.type === "file" ? write_dl(x.file, D) : x.type == "string" ? utf8read(
    /*::(*/
    D
    /*:: :any)*/
  ) : D;
}
function write_cfb_type(F, x) {
  var w = x || {}, O = write_xlscfb(F, w);
  return write_cfb_ctr(O, w);
}
function write_string_type(F, x, w) {
  w || (w = "");
  var O = w + F;
  switch (x.type) {
    case "base64":
      return Base64_encode(utf8write(O));
    case "binary":
      return utf8write(O);
    case "string":
      return F;
    case "file":
      return write_dl(x.file, O, "utf8");
    case "buffer":
      return has_buf ? Buffer_from(O, "utf8") : typeof TextEncoder < "u" ? new TextEncoder().encode(O) : write_string_type(O, { type: "binary" }).split("").map(function(D) {
        return D.charCodeAt(0);
      });
  }
  throw new Error("Unrecognized type " + x.type);
}
function write_stxt_type(F, x) {
  switch (x.type) {
    case "base64":
      return Base64_encode_pass(F);
    case "binary":
      return F;
    case "string":
      return F;
    /* override in sheet_to_txt */
    case "file":
      return write_dl(x.file, F, "binary");
    case "buffer":
      return has_buf ? Buffer_from(F, "binary") : F.split("").map(function(w) {
        return w.charCodeAt(0);
      });
  }
  throw new Error("Unrecognized type " + x.type);
}
function write_binary_type(F, x) {
  switch (x.type) {
    case "string":
    case "base64":
    case "binary":
      for (var w = "", O = 0; O < F.length; ++O) w += String.fromCharCode(F[O]);
      return x.type == "base64" ? Base64_encode(w) : x.type == "string" ? utf8read(w) : w;
    case "file":
      return write_dl(x.file, F);
    case "buffer":
      return F;
    default:
      throw new Error("Unrecognized type " + x.type);
  }
}
function writeSyncXLSX(F, x) {
  reset_cp(), check_wb(F);
  var w = dup(x || {});
  if (w.cellStyles && (w.cellNF = !0, w.sheetStubs = !0), w.type == "array") {
    w.type = "binary";
    var O = writeSyncXLSX(F, w);
    return w.type = "array", s2ab(O);
  }
  return write_zip_typeXLSX(F, w);
}
function writeSync(F, x) {
  reset_cp(), check_wb(F);
  var w = dup(x || {});
  if (w.cellStyles && (w.cellNF = !0, w.sheetStubs = !0), w.type == "array") {
    w.type = "binary";
    var O = writeSync(F, w);
    return w.type = "array", s2ab(O);
  }
  var D = 0;
  if (w.sheet && (typeof w.sheet == "number" ? D = w.sheet : D = F.SheetNames.indexOf(w.sheet), !F.SheetNames[D]))
    throw new Error("Sheet not found: " + w.sheet + " : " + typeof w.sheet);
  switch (w.bookType || "xlsb") {
    case "xml":
    case "xlml":
      return write_string_type(write_xlml(F, w), w);
    case "slk":
    case "sylk":
      return write_string_type(SYLK.from_sheet(F.Sheets[F.SheetNames[D]], w, F), w);
    case "htm":
    case "html":
      return write_string_type(sheet_to_html(F.Sheets[F.SheetNames[D]], w), w);
    case "txt":
      return write_stxt_type(sheet_to_txt(F.Sheets[F.SheetNames[D]], w), w);
    case "csv":
      return write_string_type(sheet_to_csv(F.Sheets[F.SheetNames[D]], w), w, "\uFEFF");
    case "dif":
      return write_string_type(DIF.from_sheet(F.Sheets[F.SheetNames[D]], w), w);
    case "dbf":
      return write_binary_type(DBF.from_sheet(F.Sheets[F.SheetNames[D]], w), w);
    case "prn":
      return write_string_type(PRN.from_sheet(F.Sheets[F.SheetNames[D]], w), w);
    case "rtf":
      return write_string_type(sheet_to_rtf(F.Sheets[F.SheetNames[D]]), w);
    case "eth":
      return write_string_type(ETH.from_sheet(F.Sheets[F.SheetNames[D]], w), w);
    case "fods":
      return write_string_type(write_ods(F, w), w);
    case "wk1":
      return write_binary_type(WK_.sheet_to_wk1(F.Sheets[F.SheetNames[D]], w), w);
    case "wk3":
      return write_binary_type(WK_.book_to_wk3(F, w), w);
    case "biff2":
      w.biff || (w.biff = 2);
    /* falls through */
    case "biff3":
      w.biff || (w.biff = 3);
    /* falls through */
    case "biff4":
      return w.biff || (w.biff = 4), write_binary_type(write_biff_buf(F, w), w);
    case "biff5":
      w.biff || (w.biff = 5);
    /* falls through */
    case "biff8":
    case "xla":
    case "xls":
      return w.biff || (w.biff = 8), write_cfb_type(F, w);
    case "xlsx":
    case "xlsm":
    case "xlam":
    case "xlsb":
    case "numbers":
    case "ods":
      return write_zip_type(F, w);
    default:
      throw new Error("Unrecognized bookType |" + w.bookType + "|");
  }
}
function resolve_book_type(F) {
  if (!F.bookType) {
    var x = {
      xls: "biff8",
      htm: "html",
      slk: "sylk",
      socialcalc: "eth",
      Sh33tJS: "WTF"
    }, w = F.file.slice(F.file.lastIndexOf(".")).toLowerCase();
    w.match(/^\.[a-z]+$/) && (F.bookType = w.slice(1)), F.bookType = x[F.bookType] || F.bookType;
  }
}
function writeFileSync(F, x, w) {
  var O = w || {};
  return O.type = "file", O.file = x, resolve_book_type(O), writeSync(F, O);
}
function writeFileSyncXLSX(F, x, w) {
  var O = w || {};
  return O.type = "file", O.file = x, resolve_book_type(O), writeSyncXLSX(F, O);
}
function writeFileAsync(F, x, w, O) {
  var D = w || {};
  D.type = "file", D.file = F, resolve_book_type(D), D.type = "buffer";
  var U = O;
  return U instanceof Function || (U = w), _fs.writeFile(F, writeSync(x, D), U);
}
function make_json_row(F, x, w, O, D, U, W) {
  var X = encode_row(w), G = W.defval, Y = W.raw || !Object.prototype.hasOwnProperty.call(W, "raw"), K = !0, Z = F["!data"] != null, q = D === 1 ? [] : {};
  if (D !== 1)
    if (Object.defineProperty) try {
      Object.defineProperty(q, "__rowNum__", { value: w, enumerable: !1 });
    } catch {
      q.__rowNum__ = w;
    }
    else q.__rowNum__ = w;
  if (!Z || F["!data"][w]) for (var J = x.s.c; J <= x.e.c; ++J) {
    var ee = Z ? (F["!data"][w] || [])[J] : F[O[J] + X];
    if (ee == null || ee.t === void 0) {
      if (G === void 0) continue;
      U[J] != null && (q[U[J]] = G);
      continue;
    }
    var re = ee.v;
    switch (ee.t) {
      case "z":
        if (re == null) break;
        continue;
      case "e":
        re = re == 0 ? null : void 0;
        break;
      case "s":
      case "b":
      case "n":
        if (!ee.z || !fmt_is_date(ee.z) || (re = numdate(re), typeof re == "number")) break;
      /* falls through */
      case "d":
        W && (W.UTC || W.raw === !1) || (re = utc_to_local(new Date(re)));
        break;
      default:
        throw new Error("unrecognized type " + ee.t);
    }
    if (U[J] != null) {
      if (re == null)
        if (ee.t == "e" && re === null) q[U[J]] = null;
        else if (G !== void 0) q[U[J]] = G;
        else if (Y && re === null) q[U[J]] = null;
        else continue;
      else
        q[U[J]] = (ee.t === "n" && typeof W.rawNumbers == "boolean" ? W.rawNumbers : Y) ? re : format_cell(ee, re, W);
      re != null && (K = !1);
    }
  }
  return { row: q, isempty: K };
}
function sheet_to_json(F, x) {
  if (F == null || F["!ref"] == null) return [];
  var w = { t: "n", v: 0 }, O = 0, D = 1, U = [], W = 0, X = "", G = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, Y = x || {}, K = Y.range != null ? Y.range : F["!ref"];
  switch (Y.header === 1 ? O = 1 : Y.header === "A" ? O = 2 : Array.isArray(Y.header) ? O = 3 : Y.header == null && (O = 0), typeof K) {
    case "string":
      G = safe_decode_range(K);
      break;
    case "number":
      G = safe_decode_range(F["!ref"]), G.s.r = K;
      break;
    default:
      G = K;
  }
  O > 0 && (D = 0);
  var Z = encode_row(G.s.r), q = [], J = [], ee = 0, re = 0, te = F["!data"] != null, Q = G.s.r, oe = 0, ne = {};
  te && !F["!data"][Q] && (F["!data"][Q] = []);
  var le = Y.skipHidden && F["!cols"] || [], Ee = Y.skipHidden && F["!rows"] || [];
  for (oe = G.s.c; oe <= G.e.c; ++oe)
    if (!(le[oe] || {}).hidden)
      switch (q[oe] = encode_col(oe), w = te ? F["!data"][Q][oe] : F[q[oe] + Z], O) {
        case 1:
          U[oe] = oe - G.s.c;
          break;
        case 2:
          U[oe] = q[oe];
          break;
        case 3:
          U[oe] = Y.header[oe - G.s.c];
          break;
        default:
          if (w == null && (w = { w: "__EMPTY", t: "s" }), X = W = format_cell(w, null, Y), re = ne[W] || 0, !re) ne[W] = 1;
          else {
            do
              X = W + "_" + re++;
            while (ne[X]);
            ne[W] = re, ne[X] = 1;
          }
          U[oe] = X;
      }
  for (Q = G.s.r + D; Q <= G.e.r; ++Q)
    if (!(Ee[Q] || {}).hidden) {
      var Te = make_json_row(F, G, Q, q, O, U, Y);
      (Te.isempty === !1 || (O === 1 ? Y.blankrows !== !1 : Y.blankrows)) && (J[ee++] = Te.row);
    }
  return J.length = ee, J;
}
var qreg = /"/g;
function make_csv_row(F, x, w, O, D, U, W, X, G) {
  for (var Y = !0, K = [], Z = "", q = encode_row(w), J = F["!data"] != null, ee = J && F["!data"][w] || [], re = x.s.c; re <= x.e.c; ++re)
    if (O[re]) {
      var te = J ? ee[re] : F[O[re] + q];
      if (te == null) Z = "";
      else if (te.v != null) {
        Y = !1, Z = "" + (G.rawNumbers && te.t == "n" ? te.v : format_cell(te, null, G));
        for (var Q = 0, oe = 0; Q !== Z.length; ++Q) if ((oe = Z.charCodeAt(Q)) === D || oe === U || oe === 34 || G.forceQuotes) {
          Z = '"' + Z.replace(qreg, '""') + '"';
          break;
        }
        Z == "ID" && X == 0 && K.length == 0 && (Z = '"ID"');
      } else te.f != null && !te.F ? (Y = !1, Z = "=" + te.f, Z.indexOf(",") >= 0 && (Z = '"' + Z.replace(qreg, '""') + '"')) : Z = "";
      K.push(Z);
    }
  if (G.strip) for (; K[K.length - 1] === ""; ) --K.length;
  return G.blankrows === !1 && Y ? null : K.join(W);
}
function sheet_to_csv(F, x) {
  var w = [], O = x ?? {};
  if (F == null || F["!ref"] == null) return "";
  for (var D = safe_decode_range(F["!ref"]), U = O.FS !== void 0 ? O.FS : ",", W = U.charCodeAt(0), X = O.RS !== void 0 ? O.RS : `
`, G = X.charCodeAt(0), Y = "", K = [], Z = O.skipHidden && F["!cols"] || [], q = O.skipHidden && F["!rows"] || [], J = D.s.c; J <= D.e.c; ++J) (Z[J] || {}).hidden || (K[J] = encode_col(J));
  for (var ee = 0, re = D.s.r; re <= D.e.r; ++re)
    (q[re] || {}).hidden || (Y = make_csv_row(F, D, re, K, W, G, U, ee, O), Y != null && (Y || O.blankrows !== !1) && w.push((ee++ ? X : "") + Y));
  return w.join("");
}
function sheet_to_txt(F, x) {
  x || (x = {}), x.FS = "	", x.RS = `
`;
  var w = sheet_to_csv(F, x);
  if (typeof $cptable > "u" || x.type == "string") return w;
  var O = $cptable.utils.encode(1200, w, "str");
  return "ÿþ" + O;
}
function sheet_to_formulae(F, x) {
  var w = "", O, D = "";
  if (F == null || F["!ref"] == null) return [];
  var U = safe_decode_range(F["!ref"]), W = "", X = [], G, Y = [], K = F["!data"] != null;
  for (G = U.s.c; G <= U.e.c; ++G) X[G] = encode_col(G);
  for (var Z = U.s.r; Z <= U.e.r; ++Z)
    for (W = encode_row(Z), G = U.s.c; G <= U.e.c; ++G)
      if (w = X[G] + W, O = K ? (F["!data"][Z] || [])[G] : F[w], D = "", O !== void 0) {
        if (O.F != null) {
          if (w = O.F, !O.f) continue;
          D = O.f, w.indexOf(":") == -1 && (w = w + ":" + w);
        }
        if (O.f != null) D = O.f;
        else {
          if (x && x.values === !1) continue;
          if (O.t == "z") continue;
          if (O.t == "n" && O.v != null) D = "" + O.v;
          else if (O.t == "b") D = O.v ? "TRUE" : "FALSE";
          else if (O.w !== void 0) D = "'" + O.w;
          else {
            if (O.v === void 0) continue;
            O.t == "s" ? D = "'" + O.v : D = "" + O.v;
          }
        }
        Y[Y.length] = w + "=" + D;
      }
  return Y;
}
function sheet_add_json(F, x, w) {
  var O = w || {}, D = F ? F["!data"] != null : O.dense, U = +!O.skipHeader, W = F || {};
  !F && D && (W["!data"] = []);
  var X = 0, G = 0;
  if (W && O.origin != null)
    if (typeof O.origin == "number") X = O.origin;
    else {
      var Y = typeof O.origin == "string" ? decode_cell(O.origin) : O.origin;
      X = Y.r, G = Y.c;
    }
  var K = { s: { c: 0, r: 0 }, e: { c: G, r: X + x.length - 1 + U } };
  if (W["!ref"]) {
    var Z = safe_decode_range(W["!ref"]);
    K.e.c = Math.max(K.e.c, Z.e.c), K.e.r = Math.max(K.e.r, Z.e.r), X == -1 && (X = Z.e.r + 1, K.e.r = X + x.length - 1 + U);
  } else
    X == -1 && (X = 0, K.e.r = x.length - 1 + U);
  var q = O.header || [], J = 0, ee = [];
  x.forEach(function(te, Q) {
    D && !W["!data"][X + Q + U] && (W["!data"][X + Q + U] = []), D && (ee = W["!data"][X + Q + U]), keys(te).forEach(function(oe) {
      (J = q.indexOf(oe)) == -1 && (q[J = q.length] = oe);
      var ne = te[oe], le = "z", Ee = "", Te = D ? "" : encode_col(G + J) + encode_row(X + Q + U), de = D ? ee[G + J] : W[Te];
      ne && typeof ne == "object" && !(ne instanceof Date) ? D ? ee[G + J] = ne : W[Te] = ne : (typeof ne == "number" ? le = "n" : typeof ne == "boolean" ? le = "b" : typeof ne == "string" ? le = "s" : ne instanceof Date ? (le = "d", O.UTC || (ne = local_to_utc(ne)), O.cellDates || (le = "n", ne = datenum(ne)), Ee = de != null && de.z && fmt_is_date(de.z) ? de.z : O.dateNF || table_fmt[14]) : ne === null && O.nullError && (le = "e", ne = 0), de ? (de.t = le, de.v = ne, delete de.w, delete de.R, Ee && (de.z = Ee)) : D ? ee[G + J] = de = { t: le, v: ne } : W[Te] = de = { t: le, v: ne }, Ee && (de.z = Ee));
    });
  }), K.e.c = Math.max(K.e.c, G + q.length - 1);
  var re = encode_row(X);
  if (D && !W["!data"][X] && (W["!data"][X] = []), U) for (J = 0; J < q.length; ++J)
    D ? W["!data"][X][J + G] = { t: "s", v: q[J] } : W[encode_col(J + G) + re] = { t: "s", v: q[J] };
  return W["!ref"] = encode_range(K), W;
}
function json_to_sheet(F, x) {
  return sheet_add_json(null, F, x);
}
function ws_get_cell_stub(F, x, w) {
  if (typeof x == "string") {
    if (F["!data"] != null) {
      var O = decode_cell(x);
      return F["!data"][O.r] || (F["!data"][O.r] = []), F["!data"][O.r][O.c] || (F["!data"][O.r][O.c] = { t: "z" });
    }
    return F[x] || (F[x] = { t: "z" });
  }
  return typeof x != "number" ? ws_get_cell_stub(F, encode_cell(x)) : ws_get_cell_stub(F, encode_col(w || 0) + encode_row(x));
}
function wb_sheet_idx(F, x) {
  if (typeof x == "number") {
    if (x >= 0 && F.SheetNames.length > x) return x;
    throw new Error("Cannot find sheet # " + x);
  } else if (typeof x == "string") {
    var w = F.SheetNames.indexOf(x);
    if (w > -1) return w;
    throw new Error("Cannot find sheet name |" + x + "|");
  } else throw new Error("Cannot find sheet |" + x + "|");
}
function book_new(F, x) {
  var w = { SheetNames: [], Sheets: {} };
  return F && book_append_sheet(w, F, x || "Sheet1"), w;
}
function book_append_sheet(F, x, w, O) {
  var D = 1;
  if (!w) for (; D <= 65535 && F.SheetNames.indexOf(w = "Sheet" + D) != -1; ++D, w = void 0) ;
  if (!w || F.SheetNames.length >= 65535) throw new Error("Too many worksheets");
  if (O && F.SheetNames.indexOf(w) >= 0 && w.length < 32) {
    var U = w.match(/\d+$/);
    D = U && +U[0] || 0;
    var W = U && w.slice(0, U.index) || w;
    for (++D; D <= 65535 && F.SheetNames.indexOf(w = W + D) != -1; ++D) ;
  }
  if (check_ws_name(w), F.SheetNames.indexOf(w) >= 0) throw new Error("Worksheet with name |" + w + "| already exists!");
  return F.SheetNames.push(w), F.Sheets[w] = x, w;
}
function book_set_sheet_visibility(F, x, w) {
  F.Workbook || (F.Workbook = {}), F.Workbook.Sheets || (F.Workbook.Sheets = []);
  var O = wb_sheet_idx(F, x);
  switch (F.Workbook.Sheets[O] || (F.Workbook.Sheets[O] = {}), w) {
    case 0:
    case 1:
    case 2:
      break;
    default:
      throw new Error("Bad sheet visibility setting " + w);
  }
  F.Workbook.Sheets[O].Hidden = w;
}
function cell_set_number_format(F, x) {
  return F.z = x, F;
}
function cell_set_hyperlink(F, x, w) {
  return x ? (F.l = { Target: x }, w && (F.l.Tooltip = w)) : delete F.l, F;
}
function cell_set_internal_link(F, x, w) {
  return cell_set_hyperlink(F, "#" + x, w);
}
function cell_add_comment(F, x, w) {
  F.c || (F.c = []), F.c.push({ t: x, a: w || "SheetJS" });
}
function sheet_set_array_formula(F, x, w, O) {
  for (var D = typeof x != "string" ? x : safe_decode_range(x), U = typeof x == "string" ? x : encode_range(x), W = D.s.r; W <= D.e.r; ++W) for (var X = D.s.c; X <= D.e.c; ++X) {
    var G = ws_get_cell_stub(F, W, X);
    G.t = "n", G.F = U, delete G.v, W == D.s.r && X == D.s.c && (G.f = w, O && (G.D = !0));
  }
  var Y = decode_range(F["!ref"]);
  return Y.s.r > D.s.r && (Y.s.r = D.s.r), Y.s.c > D.s.c && (Y.s.c = D.s.c), Y.e.r < D.e.r && (Y.e.r = D.e.r), Y.e.c < D.e.c && (Y.e.c = D.e.c), F["!ref"] = encode_range(Y), F;
}
var utils = {
  encode_col,
  encode_row,
  encode_cell,
  encode_range,
  decode_col,
  decode_row,
  split_cell,
  decode_cell,
  decode_range,
  format_cell,
  sheet_new,
  sheet_add_aoa,
  sheet_add_json,
  sheet_add_dom,
  aoa_to_sheet,
  json_to_sheet,
  table_to_sheet: parse_dom_table,
  table_to_book,
  sheet_to_csv,
  sheet_to_txt,
  sheet_to_json,
  sheet_to_html,
  sheet_to_formulae,
  sheet_to_row_object_array: sheet_to_json,
  sheet_get_cell: ws_get_cell_stub,
  book_new,
  book_append_sheet,
  book_set_sheet_visibility,
  cell_set_number_format,
  cell_set_hyperlink,
  cell_set_internal_link,
  cell_add_comment,
  sheet_set_array_formula,
  consts: {
    SHEET_VISIBLE: 0,
    SHEET_HIDDEN: 1,
    SHEET_VERY_HIDDEN: 2
  }
}, _Readable;
function set_readable(F) {
  _Readable = F;
}
function write_csv_stream(F, x) {
  var w = _Readable(), O = x ?? {};
  if (F == null || F["!ref"] == null)
    return w.push(null), w;
  for (var D = safe_decode_range(F["!ref"]), U = O.FS !== void 0 ? O.FS : ",", W = U.charCodeAt(0), X = O.RS !== void 0 ? O.RS : `
`, G = X.charCodeAt(0), Y = "", K = [], Z = O.skipHidden && F["!cols"] || [], q = O.skipHidden && F["!rows"] || [], J = D.s.c; J <= D.e.c; ++J) (Z[J] || {}).hidden || (K[J] = encode_col(J));
  var ee = D.s.r, re = !1, te = 0;
  return w._read = function() {
    if (!re)
      return re = !0, w.push("\uFEFF");
    for (; ee <= D.e.r; )
      if (++ee, !(q[ee - 1] || {}).hidden && (Y = make_csv_row(F, D, ee - 1, K, W, G, U, te, O), Y != null && (Y || O.blankrows !== !1)))
        return w.push((te++ ? X : "") + Y);
    return w.push(null);
  }, w;
}
function write_html_stream(F, x) {
  var w = _Readable(), O = x || {}, D = O.header != null ? O.header : HTML_BEGIN, U = O.footer != null ? O.footer : HTML_END;
  w.push(D);
  var W = decode_range(F["!ref"]);
  w.push(make_html_preamble(F, W, O));
  var X = W.s.r, G = !1;
  return w._read = function() {
    if (X > W.e.r)
      return G || (G = !0, w.push("</table>" + U)), w.push(null);
    for (; X <= W.e.r; ) {
      w.push(make_html_row(F, W, X, O)), ++X;
      break;
    }
  }, w;
}
function write_json_stream(F, x) {
  var w = _Readable({ objectMode: !0 });
  if (F == null || F["!ref"] == null)
    return w.push(null), w;
  var O = { t: "n", v: 0 }, D = 0, U = 1, W = [], X = 0, G = "", Y = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, K = x || {}, Z = K.range != null ? K.range : F["!ref"];
  switch (K.header === 1 ? D = 1 : K.header === "A" ? D = 2 : Array.isArray(K.header) && (D = 3), typeof Z) {
    case "string":
      Y = safe_decode_range(Z);
      break;
    case "number":
      Y = safe_decode_range(F["!ref"]), Y.s.r = Z;
      break;
    default:
      Y = Z;
  }
  D > 0 && (U = 0);
  var q = encode_row(Y.s.r), J = [], ee = 0, re = F["!data"] != null, te = Y.s.r, Q = 0, oe = {};
  re && !F["!data"][te] && (F["!data"][te] = []);
  var ne = K.skipHidden && F["!cols"] || [], le = K.skipHidden && F["!rows"] || [];
  for (Q = Y.s.c; Q <= Y.e.c; ++Q)
    if (!(ne[Q] || {}).hidden)
      switch (J[Q] = encode_col(Q), O = re ? F["!data"][te][Q] : F[J[Q] + q], D) {
        case 1:
          W[Q] = Q - Y.s.c;
          break;
        case 2:
          W[Q] = J[Q];
          break;
        case 3:
          W[Q] = K.header[Q - Y.s.c];
          break;
        default:
          if (O == null && (O = { w: "__EMPTY", t: "s" }), G = X = format_cell(O, null, K), ee = oe[X] || 0, !ee) oe[X] = 1;
          else {
            do
              G = X + "_" + ee++;
            while (oe[G]);
            oe[X] = ee, oe[G] = 1;
          }
          W[Q] = G;
      }
  return te = Y.s.r + U, w._read = function() {
    for (; te <= Y.e.r; )
      if (!(le[te - 1] || {}).hidden) {
        var Ee = make_json_row(F, Y, te, J, D, W, K);
        if (++te, Ee.isempty === !1 || (D === 1 ? K.blankrows !== !1 : K.blankrows)) {
          w.push(Ee.row);
          return;
        }
      }
    return w.push(null);
  }, w;
}
function write_xlml_stream(F, x) {
  var w = _Readable(), O = x ?? {}, D = +O.stride || 10;
  F.SSF || (F.SSF = dup(table_fmt)), F.SSF && (make_ssf(), SSF_load_table(F.SSF), O.revssf = evert_num(F.SSF), O.revssf[F.SSF[65535]] = 0, O.ssf = F.SSF, O.cellXfs = [], get_cell_style(O.cellXfs, {}, { revssf: { General: 0 } })), F.SheetNames.forEach(function(Q) {
    var oe = F.Sheets[Q];
    if (!(!oe || !oe["!ref"])) {
      for (var ne = decode_range(oe["!ref"]), le = oe["!data"] != null, Ee = le ? oe["!data"] : [], Te = ne.s.r; Te <= ne.e.r; ++Te)
        if (!(le && !Ee[Te]))
          for (var de = ne.s.c; de <= ne.e.c; ++de) {
            var ae = le ? Ee[Te][de] : oe[encode_col(de) + encode_row(Te)];
            ae && (ae.t == "d" && ae.z == null && (ae = dup(ae), ae.z = table_fmt[14]), get_cell_style(O.cellXfs, ae, O));
          }
    }
  });
  var U = write_sty_xlml(F, O), W = 0, X = 0, G = F.Sheets[F.SheetNames[X]], Y = safe_decode_range(G), K = -1, Z = !1, q = [], J = 0, ee = !1, re = [], te = { r: 0, c: 0 };
  return w._read = function() {
    switch (W) {
      /* header */
      case 0:
        W = 1, w.push(XML_HEADER), w.push("<Workbook" + wxt_helper({
          xmlns: XLMLNS.ss,
          "xmlns:o": XLMLNS.o,
          "xmlns:x": XLMLNS.x,
          "xmlns:ss": XLMLNS.ss,
          "xmlns:dt": XLMLNS.dt,
          "xmlns:html": XLMLNS.html
        }) + ">");
        break;
      /* preamble */
      case 1:
        W = 2, w.push(write_props_xlml(F, O)), w.push(write_wb_xlml(F));
        break;
      /* style and name tables */
      case 2:
        W = 3, w.push(U), w.push(write_names_xlml(F));
        break;
      /* worksheet preamble */
      case 3:
        {
          if (Z = !1, X >= F.SheetNames.length) {
            W = -1, w.push("");
            break;
          }
          if (w.push("<Worksheet" + wxt_helper({ "ss:Name": escapexml(F.SheetNames[X]) }) + ">"), G = F.Sheets[F.SheetNames[X]], !G)
            return w.push("</Worksheet>"), void ++X;
          var Q = write_ws_xlml_names(G, O, X, F);
          if (Q.length && w.push("<Names>" + Q + "</Names>"), !G["!ref"]) return W = 5;
          Y = safe_decode_range(G["!ref"]), K = Y.s.r, W = 4;
        }
        break;
      /* worksheet intramble */
      case 4:
        {
          if (K < 0 || K > Y.e.r)
            return Z && w.push("</Table>"), void (W = 5);
          K <= Y.s.r && (G["!cols"] && G["!cols"].forEach(function(ae, se) {
            process_col(ae);
            var ce = !!ae.width, xe = col_obj_w(se, ae), Ce = { "ss:Index": se + 1 };
            ce && (Ce["ss:Width"] = width2px(xe.width)), ae.hidden && (Ce["ss:Hidden"] = "1"), Z || (Z = !0, w.push("<Table>")), w.push(writextag("Column", null, Ce));
          }), ee = G["!data"] != null, ee && (re = G["!data"]), te.r = te.c = 0);
          for (var oe = 0; K <= Y.e.r && oe < D; ++K, ++oe) {
            var ne = [write_ws_xlml_row(K, (G["!rows"] || [])[K])];
            if (te.r = K, !(ee && !re[K])) for (var le = Y.s.c; le <= Y.e.c; ++le) {
              te.c = le;
              var Ee = !1;
              for (J = 0; J != q.length; ++J)
                if (!(q[J].s.c > le) && !(q[J].s.r > K) && !(q[J].e.c < le) && !(q[J].e.r < K)) {
                  (q[J].s.c != le || q[J].s.r != K) && (Ee = !0);
                  break;
                }
              if (!Ee) {
                var Te = encode_col(le) + encode_row(K), de = ee ? re[K][le] : G[Te];
                ne.push(write_ws_xlml_cell(de, Te, G, O, X, F, te));
              }
            }
            ne.push("</Row>"), Z || (Z = !0, w.push("<Table>")), w.push(ne.join(""));
          }
        }
        break;
      /* worksheet postamble */
      case 5:
        return w.push(write_ws_xlml_wsopts(G, O, X, F)), G && G["!autofilter"] && w.push('<AutoFilter x:Range="' + a1_to_rc(fix_range(G["!autofilter"].ref), { r: 0, c: 0 }) + '" xmlns="urn:schemas-microsoft-com:office:excel"></AutoFilter>'), w.push("</Worksheet>"), X++, K = -1, void (W = 3);
      /* footer */
      case -1:
        W = -2, w.push("</Workbook>");
        break;
      /* exeunt */
      case -2:
        w.push(null);
        break;
    }
  }, w;
}
var __stream = {
  to_json: write_json_stream,
  to_html: write_html_stream,
  to_csv: write_csv_stream,
  to_xlml: write_xlml_stream,
  set_readable
};
const version = XLSX.version, xlsx = {
  parse_xlscfb,
  parse_zip,
  read: readSync,
  readFile: readFileSync,
  readFileSync,
  write: writeSync,
  writeFile: writeFileSync,
  writeFileSync,
  writeFileAsync,
  writeXLSX: writeSyncXLSX,
  writeFileXLSX: writeFileSyncXLSX,
  utils,
  set_fs,
  set_cptable,
  stream: __stream,
  SSF,
  CFB
}, xlsx$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CFB,
  SSF,
  default: xlsx,
  parse_xlscfb,
  parse_zip,
  read: readSync,
  readFile: readFileSync,
  readFileSync,
  set_cptable,
  set_fs,
  stream: __stream,
  utils,
  version,
  write: writeSync,
  writeFile: writeFileSync,
  writeFileAsync,
  writeFileSync,
  writeFileXLSX: writeFileSyncXLSX,
  writeXLSX: writeSyncXLSX
}, Symbol.toStringTag, { value: "Module" })), state = {
  activeObservers: /* @__PURE__ */ new Set(),
  currentData: [],
  dataTable: null,
  defaultData: [
    ["var_1", "var_2", "var_3"],
    ["sample1", "sample2", "sample3"],
    ["", "", ""],
    ["", "", ""]
  ],
  elements: {},
  logPrefix: "LT Dynamic Content: ",
  options: {
    labels: {
      btnContinue: "Confirm",
      csvUploadHelp: `Add dynamic data to your item by typing directly into the table below. Or, import a file
            (csv, xls, xlsx, ods, and txt are supported).`,
      headerValidationHelp: `The header row must contain only lowercase letters, numbers, and underscores.
            Supports a maximum of 20 columns and 50 rows.`
    }
  },
  renderedCss: !1,
  useElementCache: !1
};
function run(F) {
  state.options = validateOptions(F), state.renderedCss || injectCSS(), document.querySelector(".lrn-author").classList.add("lt__dynamicContent"), window.XLSX = xlsx$1, appInstance().on("navigate", w);
  function w() {
    setTimeout(() => {
      ["items/:reference/settings/:tab", void 0].includes(appInstance().getLocation().route) && appInstance().getLocation().location.split("/").pop() === "data-table" && (setObserver(".lrn-author-datatable-editor", setup, {
        dispatchEvent: !1,
        root: getElement('[data-tab-content="data-table"]'),
        state
      }), setObserver(".lrn-author-datatable-preview", actionContinue, {
        dispatchEvent: !1,
        root: getElement('[data-tab-content="data-table"]'),
        state
      }));
    }, 150), appInstance().on("render:item", () => {
      state.currentData = [], state.dataTable = null, state.elements = {};
    });
  }
}
function setup() {
  const F = getElement(".lrn-author-datatable-source"), x = getElement(".lrn-author-datatable-header"), w = getElement('[data-authorapi-selector="datatable-source-continue"]');
  if (setObserver("#dynamic-content-table", () => {
  }, {
    dispatchEvent: !0,
    name: "lt:datatable:editor",
    root: getElement('[data-tab-content="data-table"]'),
    state
  }), F) {
    if (!getElement("#dynamic-content-table")) {
      const U = document.querySelector(".CodeMirror").CodeMirror.getDoc().getValue(), W = getTableTemplate();
      if (w.textContent = state.options.labels.btnContinue, x.insertAdjacentHTML("afterend", W), state.options.labels.csvUploadHelp.length) {
        const X = document.createElement("p");
        X.className = "lt-dynamic-content-help-text", X.textContent = state.options.labels.csvUploadHelp, x.appendChild(X);
      }
      if (state.options.labels.headerValidationHelp.length) {
        const X = document.createElement("p");
        X.className = "lrn-author-message lrn-author-message-small lrn-author-message-info", X.textContent = state.options.labels.headerValidationHelp, x.appendChild(X);
      }
      U.length && (state.currentData = Papa.parse(U.trim()).data);
    }
    const D = getElement("#dynamic-content-table");
    if (D) {
      const U = state.currentData.length ? state.currentData : state.defaultData, W = debounce(updateAPIDataTable, 200), X = debounce(checkHeader, 200);
      state.dataTable = D, state.dataTable.updateData(U), state.dataTable.onDataUpdate = (G) => {
        W(G), X(G);
      }, w.addEventListener("click", actionContinue);
    } else
      logger.error(`${state.logPrefix}Dynamic table element not found`);
  } else
    logger.error(`${state.logPrefix}Data element not found`);
}
function updateAPIDataTable(F) {
  const x = {
    delimiter: ",",
    escapeChar: '"',
    header: !0,
    newline: `\r
`,
    quotes: !0,
    quoteChar: '"',
    skipEmptyLines: "greedy"
  }, w = Papa.unparse(F, x);
  document.querySelector(".CodeMirror").CodeMirror.getDoc().setValue(w), state.currentData = F;
}
function checkHeader(F) {
  if (Array.isArray(F) && F.length) {
    for (const [x, w] of F[0].entries())
      if (!/^[a-z0-9 _]+$/.test(w))
        try {
          state.dataTable.updateCell({
            newText: w.replace(/-/g, "_").replace(/[^a-zA-Z0-9 _]/g, "").toLowerCase(),
            rowIndex: 0,
            columnIndex: x
          });
        } catch (O) {
          O.message !== "Cannot read properties of undefined (reading 'settings')" && logger.error(`${state.logPrefix}Error updating header cell: ${O}`);
        }
  }
}
function actionContinue() {
  const F = getElement(".lrn-author-datatable-header");
  F.querySelector(".lrn-author-form-label-name").textContent = state.options.labels.headerLabel, setTimeout(() => {
    const x = getElement('[data-authorapi-selector="datatable-preview-edit"]');
    x ? x.addEventListener("click", () => {
      setTimeout(() => {
        F.classList.add("hidden"), setup();
      }, 300);
    }) : logger.error(`${state.logPrefix}Edit button not found`);
    const w = getElement('[data-authorapi-selector="datatable-preview-reset"]');
    w.addEventListener("click", () => {
      w.classList.contains("lrn-author-btn-confirm-active") && setTimeout(() => {
        state.currentData = [], setup();
      }, 200);
    });
  }, 300);
}
function getElement(F) {
  if (state.useElementCache && state.elements[F])
    return state.elements[F];
  const x = document.querySelector(F);
  return x && (state.elements[F] = x), x;
}
function getTableTemplate() {
  return `<active-table
        id='dynamic-content-table'
        allowduplicateheaders='false'
        availableDefaultColumnTypes='[]'
        customColumnTypes='[
            {
                "name": "api-column",
                "customTextProcessing": {
                    "changeTextFunc": "(cellText) => cellText.replace(/^\\"(.*)\\"$/, \\"$1\\")"
                }
            }
        ]'
        defaultColumnTypeName="api-column"
        displayHeaderIcons='true'
        dragcolumns='true'
        dragrows='true'
        draganddrop='true'
        enterkeymovedown='true'
        maxcolumns='20'
        maxrows='51'
        preserveNarrowColumns='true'
        spellcheck='false'
        stickyHeader='true'
        files='{
            "buttons": [
                {
                    "position": "top-left",
                    "order": 0,
                    "text": "Import",
                    "import": {
                        "formats": ["csv", "xls", "xlsx", "ods", "txt"]
                    },
                    "styles": {
                        "default":{
                            "backgroundColor":"#eaeaea",
                            "color":"#333"
                        },
                        "hover":{
                            "backgroundColor":"#d9d9d9",
                            "color":"#333"
                        }
                    }
                },
                {
                    "position": "top-left",
                    "order": 1,
                    "text": "Export",
                    "export": {
                        "formats": ["csv", "xlsx", "ods"]
                    },
                    "styles": {
                        "default":{
                            "backgroundColor":"#eaeaea"
                        },
                        "hover":{
                            "backgroundColor":"#d9d9d9"
                        }
                    }
                }
            ]
        }'
        tableStyle='{
            "borderRadius":"4px"
        }'
        overflow='{
            "maxHeight":"${document.querySelector(".lrn-author-item-settings-container").offsetHeight - 230 || 300}px",
            "maxWidth":"481px"
        }'
        framecomponentsstyles='{
            "styles":{
                "default": {"backgroundColor": "#f5f5f5"},
                "hoverColors": {"backgroundColor": "#dedede"}
            },
            "inheritHeaderColors":false
        }'
        rowhoverstyles='{
            "style":{
                "backgroundColor":"#d6d6d630",
                "transitionDuration":"0.05s"
            }
        }'
    ></active-table>`;
}
function validateOptions(F) {
  let x = F || {};
  return F && typeof F == "object" ? x = { ...state.options, ...F } : x = { ...state.options }, x;
}
function injectCSS() {
  const F = document.createElement("style"), x = `
/* Learnosity dynamic content styles */
.lt__dynamicContent.lrn-author.lrn-author  {
    .lt-dynamic-content-help-text {
        font-size: 15.4px;
        line-height: 1.4em;
    }

    .lrn-author-datatable-footer {
        justify-content: space-between;
    }

    .lrn-author-api-react-container .lrn-author-item-settings .lrn-author-datatable-footer button:nth-child(2),
    .lrn-author-api-react-container .lrn-author-activity-labels .lrn-author-datatable-footer button:nth-child(2) {
        margin: 0 2px;
    }

    .lrn-author-api-react-container .lrn-author-item-settings,
    .lrn-author-api-react-container .lrn-author-activity-labels {
        .lrn-author-datatable-editor {
            .lrn-author-datatable-header {
                height: auto;
                padding-bottom: 0;
            }

            .lrn-author-datatable-source-wrapper {
                display: none;
            }
        }

        .lrn-author-datatable-header {
            label {
                display: none;
            }
        }
    }
}
`;
  F.setAttribute("data-style", "LT Dynamic Content"), F.textContent = x, document.head.append(F), state.renderedCss = !0;
}
const dynamicContent = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  run,
  setup,
  updateAPIDataTable,
  validateOptions
}, Symbol.toStringTag, { value: "Module" }));
export {
  dynamicContent as d,
  run as r,
  setup as s,
  updateAPIDataTable as u,
  validateOptions as v
};
